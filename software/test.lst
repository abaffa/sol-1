0001   0000             .include "kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0002   0000             
0003   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0005   0000             
0006   0400             .org PROC_TEXT_ORG			; origin at 1024
0007   0400             
0008   0400             ; when running the installer, we need to be inside /boot because the mkbin system call
0009   0400             ; creates all binary files inside whatever is the current directory
0010   0400             ; and we want the kernel to live inside /boot
0011   0400             bootloader_installer:
0012   0400             ;; create the kernel file
0013   0400 D2            push bp
0014   0401 9B            mov bp, sp
0015   0402             
0016   0402 3B 0B 04      mov d, s_warning
0017   0405 07 20 07      call puts
0018   0408             
0019   0408 F9            leave
0020   0409 05 0B       	syscall sys_terminate_proc
0021   040B             
0022   040B             
0023   040B             
0024   040B 4D 61 6B 65 s_warning:        .db "Make sure you are in "
0024   040F 20 73 75 72 
0024   0413 65 20 79 6F 
0024   0417 75 20 61 72 
0024   041B 65 20 69 6E 
0024   041F 20 
0025   0420 2F 62 6F 6F 									.db "/boot before creating "
0025   0424 74 20 62 65 
0025   0428 66 6F 72 65 
0025   042C 20 63 72 65 
0025   0430 61 74 69 6E 
0025   0434 67 20 
0026   0436 74 68 65 20 									.db "the file.\n", 0
0026   043A 66 69 6C 65 
0026   043E 2E 0A 00 
0027   0441             
0028   0441 25 20 00    s_prompt:         .db "% ", 0
0029   0444 4B 65 72 6E s_enter_filename: .db "Kernel filename: ", 0
0029   0448 65 6C 20 66 
0029   044C 69 6C 65 6E 
0029   0450 61 6D 65 3A 
0029   0454 20 00 
0030   0456 00 00 00 00 kernel_filename:    .fill 64, 0
0030   045A 00 00 00 00 
0030   045E 00 00 00 00 
0030   0462 00 00 00 00 
0030   0466 00 00 00 00 
0030   046A 00 00 00 00 
0030   046E 00 00 00 00 
0030   0472 00 00 00 00 
0030   0476 00 00 00 00 
0030   047A 00 00 00 00 
0030   047E 00 00 00 00 
0030   0482 00 00 00 00 
0030   0486 00 00 00 00 
0030   048A 00 00 00 00 
0030   048E 00 00 00 00 
0030   0492 00 00 00 00 
0031   0496 2F 62 6F 6F kernel_fullpath:  	.db "/boot/"
0031   049A 74 2F 
0032   049C 00 00 00 00                     .fill 64, 0
0032   04A0 00 00 00 00 
0032   04A4 00 00 00 00 
0032   04A8 00 00 00 00 
0032   04AC 00 00 00 00 
0032   04B0 00 00 00 00 
0032   04B4 00 00 00 00 
0032   04B8 00 00 00 00 
0032   04BC 00 00 00 00 
0032   04C0 00 00 00 00 
0032   04C4 00 00 00 00 
0032   04C8 00 00 00 00 
0032   04CC 00 00 00 00 
0032   04D0 00 00 00 00 
0032   04D4 00 00 00 00 
0032   04D8 00 00 00 00 
0033   04DC             
0034   04DC             .include "stdio.asm"
0001+  04DC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  04DC             ; stdio.s
0003+  04DC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  04DC             .include "string.asm"
0001++ 04DC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 04DC             ; string.s
0003++ 04DC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 04DC             
0005++ 04DC             
0006++ 04DC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 04DC             ; strrev
0008++ 04DC             ; reverse a string
0009++ 04DC             ; D = string address
0010++ 04DC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 04DC             ; 01234
0012++ 04DC             strrev:
0013++ 04DC 4B          	pusha
0014++ 04DD 07 23 05    	call strlen	; length in C
0015++ 04E0 12          	mov a, c
0016++ 04E1 AF 01 00    	cmp a, 1
0017++ 04E4 D0 FE 04    	jleu strrev_end	; check string length. string len must be > 1
0018++ 04E7 7D          	dec a
0019++ 04E8 FD 4E       	mov si, d	; beginning of string
0020++ 04EA FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 04EC 59          	add d, a	; end of string
0022++ 04ED 12          	mov a, c
0023++ 04EE FD 9B       	shr a		; divide by 2
0024++ 04F0 39          	mov c, a	; C now counts the steps
0025++ 04F1             strrev_L0:
0026++ 04F1 32          	mov bl, [d]	; save load right-side char into BL
0027++ 04F2 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 04F3 3E          	mov [d], al	; store left char into right side
0029++ 04F4 1B          	mov al, bl
0030++ 04F5 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 04F6 7E          	dec c
0032++ 04F7 7F          	dec d
0033++ 04F8 C2 00 00    	cmp c, 0
0034++ 04FB C7 F1 04    	jne strrev_L0
0035++ 04FE             strrev_end:
0036++ 04FE 4C          	popa
0037++ 04FF 09          	ret
0038++ 0500             	
0039++ 0500             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0500             ; strchr
0041++ 0500             ; search string in D for char in AL
0042++ 0500             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0500             strchr:
0044++ 0500             strchr_L0:
0045++ 0500 32          	mov bl, [d]
0046++ 0501 C1 00       	cmp bl, 0
0047++ 0503 C6 0E 05    	je strchr_end
0048++ 0506 BA          	cmp al, bl
0049++ 0507 C6 0E 05    	je strchr_end
0050++ 050A 79          	inc d
0051++ 050B 0A 00 05    	jmp strchr_L0
0052++ 050E             strchr_end:
0053++ 050E 1B          	mov al, bl
0054++ 050F 09          	ret
0055++ 0510             
0056++ 0510             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0510             ; strstr
0058++ 0510             ; find sub-string
0059++ 0510             ; str1 in SI
0060++ 0510             ; str2 in DI
0061++ 0510             ; SI points to end of source string
0062++ 0510             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0510             strstr:
0064++ 0510 DB          	push al
0065++ 0511 DA          	push d
0066++ 0512 E3          	push di
0067++ 0513             strstr_loop:
0068++ 0513 F3          	cmpsb					; compare a byte of the strings
0069++ 0514 C7 1F 05    	jne strstr_ret
0070++ 0517 FC 00 00    	lea d, [di + 0]
0071++ 051A BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 051C C7 13 05    	jne strstr_loop				; equal chars but not at end
0073++ 051F             strstr_ret:
0074++ 051F F0          	pop di
0075++ 0520 E7          	pop d
0076++ 0521 E8          	pop al
0077++ 0522 09          	ret
0078++ 0523             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0523             ; length of null terminated string
0080++ 0523             ; result in C
0081++ 0523             ; pointer in D
0082++ 0523             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0523             strlen:
0084++ 0523 DA          	push d
0085++ 0524 38 00 00    	mov c, 0
0086++ 0527             strlen_L1:
0087++ 0527 BD 00       	cmp byte [d], 0
0088++ 0529 C6 31 05    	je strlen_ret
0089++ 052C 79          	inc d
0090++ 052D 78          	inc c
0091++ 052E 0A 27 05    	jmp strlen_L1
0092++ 0531             strlen_ret:
0093++ 0531 E7          	pop d
0094++ 0532 09          	ret
0095++ 0533             
0096++ 0533             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0533             ; STRCMP
0098++ 0533             ; compare two strings
0099++ 0533             ; str1 in SI
0100++ 0533             ; str2 in DI
0101++ 0533             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0533             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0533             strcmp:
0104++ 0533 DB          	push al
0105++ 0534 DA          	push d
0106++ 0535 E3          	push di
0107++ 0536 E2          	push si
0108++ 0537             strcmp_loop:
0109++ 0537 F3          	cmpsb					; compare a byte of the strings
0110++ 0538 C7 43 05    	jne strcmp_ret
0111++ 053B FB FF FF    	lea d, [si +- 1]
0112++ 053E BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0540 C7 37 05    	jne strcmp_loop				; equal chars but not at end
0114++ 0543             strcmp_ret:
0115++ 0543 EF          	pop si
0116++ 0544 F0          	pop di
0117++ 0545 E7          	pop d
0118++ 0546 E8          	pop al
0119++ 0547 09          	ret
0120++ 0548             
0121++ 0548             
0122++ 0548             ; STRCPY
0123++ 0548             ; copy null terminated string from SI to DI
0124++ 0548             ; source in SI
0125++ 0548             ; destination in DI
0126++ 0548             strcpy:
0127++ 0548 E2          	push si
0128++ 0549 E3          	push di
0129++ 054A DB          	push al
0130++ 054B             strcpy_L1:
0131++ 054B F6          	lodsb
0132++ 054C F7          	stosb
0133++ 054D B9 00       	cmp al, 0
0134++ 054F C7 4B 05    	jne strcpy_L1
0135++ 0552             strcpy_end:
0136++ 0552 E8          	pop al
0137++ 0553 F0          	pop di
0138++ 0554 EF          	pop si
0139++ 0555 09          	ret
0140++ 0556             
0141++ 0556             ; STRCAT
0142++ 0556             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0556             ; source in SI
0144++ 0556             ; destination in DI
0145++ 0556             strcat:
0146++ 0556 E2          	push si
0147++ 0557 E3          	push di
0148++ 0558 D7          	push a
0149++ 0559 DA          	push d
0150++ 055A 50          	mov a, di
0151++ 055B 3C          	mov d, a
0152++ 055C             strcat_goto_end_L1:
0153++ 055C BD 00       	cmp byte[d], 0
0154++ 055E C6 65 05    	je strcat_start
0155++ 0561 79          	inc d
0156++ 0562 0A 5C 05    	jmp strcat_goto_end_L1
0157++ 0565             strcat_start:
0158++ 0565 FD 50       	mov di, d
0159++ 0567             strcat_L1:
0160++ 0567 F6          	lodsb
0161++ 0568 F7          	stosb
0162++ 0569 B9 00       	cmp al, 0
0163++ 056B C7 67 05    	jne strcat_L1
0164++ 056E             strcat_end:
0165++ 056E E7          	pop d
0166++ 056F E4          	pop a
0167++ 0570 F0          	pop di
0168++ 0571 EF          	pop si
0169++ 0572 09          	ret
0005+  0573             
0006+  0573 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  0577 34 35 36 37 
0006+  057B 38 39 41 42 
0006+  057F 43 44 45 46 
0007+  0583             
0008+  0583 01 00       table_power:.dw 1
0009+  0585 0A 00       			.dw 10
0010+  0587 64 00       			.dw 100
0011+  0589 E8 03       			.dw 1000
0012+  058B 10 27       			.dw 10000
0013+  058D             
0014+  058D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0015+  058D             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0016+  058D             ; ASCII in BL
0017+  058D             ; result in AL
0018+  058D             ; ascii for F = 0100 0110
0019+  058D             ; ascii for 9 = 0011 1001
0020+  058D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0021+  058D             hex_ascii_encode:
0022+  058D 1B          	mov al, bl
0023+  058E 93 40       	test al, $40				; test if letter or number
0024+  0590 C7 96 05    	jnz hex_letter
0025+  0593 87 0F       	and al, $0F				; get number
0026+  0595 09          	ret
0027+  0596             hex_letter:
0028+  0596 87 0F       	and al, $0F				; get letter
0029+  0598 6A 09       	add al, 9
0030+  059A 09          	ret
0031+  059B             
0032+  059B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0033+  059B             ; ATOI
0034+  059B             ; 2 letter hex string in B
0035+  059B             ; 8bit integer returned in AL
0036+  059B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0037+  059B             atoi:
0038+  059B D8          	push b
0039+  059C 07 8D 05    	call hex_ascii_encode			; convert BL to 4bit code in AL
0040+  059F 30          	mov bl, bh
0041+  05A0 DB          	push al					; save a
0042+  05A1 07 8D 05    	call hex_ascii_encode
0043+  05A4 EA          	pop bl	
0044+  05A5 FD 9E 04    	shl al, 4
0045+  05A8 8C          	or al, bl
0046+  05A9 E5          	pop b
0047+  05AA 09          	ret	
0048+  05AB             
0049+  05AB             
0050+  05AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  05AB             ; printf
0052+  05AB             ; no need for explanations!
0053+  05AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0054+  05AB             printf:
0055+  05AB 09          	ret
0056+  05AC             
0057+  05AC             
0058+  05AC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  05AC             ; scanf
0060+  05AC             ; no need for explanations!
0061+  05AC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  05AC             scanf:
0063+  05AC 09          	ret
0064+  05AD             
0065+  05AD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  05AD             ; ITOA
0067+  05AD             ; 8bit value in BL
0068+  05AD             ; 2 byte ASCII result in A
0069+  05AD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0070+  05AD             itoa:
0071+  05AD DA          	push d
0072+  05AE D8          	push b
0073+  05AF A7 00       	mov bh, 0
0074+  05B1 FD A4 04    	shr bl, 4	
0075+  05B4 74          	mov d, b
0076+  05B5 1F 73 05    	mov al, [d + s_hex_digits]
0077+  05B8 23          	mov ah, al
0078+  05B9             	
0079+  05B9 E5          	pop b
0080+  05BA D8          	push b
0081+  05BB A7 00       	mov bh, 0
0082+  05BD FD 87 0F    	and bl, $0F
0083+  05C0 74          	mov d, b
0084+  05C1 1F 73 05    	mov al, [d + s_hex_digits]
0085+  05C4 E5          	pop b
0086+  05C5 E7          	pop d
0087+  05C6 09          	ret
0088+  05C7             
0089+  05C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0090+  05C7             ; HEX STRING TO BINARY
0091+  05C7             ; di = destination address
0092+  05C7             ; si = source
0093+  05C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0094+  05C7             hex_to_int:
0095+  05C7             hex_to_int_L1:
0096+  05C7 F6          	lodsb					; load from [SI] to AL
0097+  05C8 B9 00       	cmp al, 0				; check if ASCII 0
0098+  05CA C6 D7 05    	jz hex_to_int_ret
0099+  05CD 36          	mov bh, al
0100+  05CE F6          	lodsb
0101+  05CF 2F          	mov bl, al
0102+  05D0 07 9B 05    	call atoi				; convert ASCII byte in B to int (to AL)
0103+  05D3 F7          	stosb					; store AL to [DI]
0104+  05D4 0A C7 05    	jmp hex_to_int_L1
0105+  05D7             hex_to_int_ret:
0106+  05D7 09          	ret		
0107+  05D8             
0108+  05D8             
0109+  05D8             
0110+  05D8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  05D8             ; GETCHAR
0112+  05D8             ; char in ah
0113+  05D8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0114+  05D8             getchar:
0115+  05D8 DB          	push al
0116+  05D9             getchar_retry:
0117+  05D9 FD 0C       	sti
0118+  05DB 19 01       	mov al, 1
0119+  05DD 05 03       	syscall sys_io			; receive in AH
0120+  05DF B9 00       	cmp al, 0			; check if any char was receive
0121+  05E1 C6 D9 05    	je getchar_retry
0122+  05E4 E8          	pop al
0123+  05E5 09          	ret
0124+  05E6             
0125+  05E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0126+  05E6             ; PUTCHAR
0127+  05E6             ; char in ah
0128+  05E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  05E6             putchar:
0130+  05E6 D7          	push a
0131+  05E7 19 00       	mov al, 0
0132+  05E9 05 03       	syscall sys_io			; char in AH
0133+  05EB E4          	pop a
0134+  05EC 09          	ret
0135+  05ED             
0136+  05ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0137+  05ED             ;; INPUT A STRING
0138+  05ED             ;; terminates with null
0139+  05ED             ;; pointer in D
0140+  05ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  05ED             gets:
0142+  05ED D7          	push a
0143+  05EE DA          	push d
0144+  05EF             gets_loop:
0145+  05EF FD 0C       	sti
0146+  05F1 19 01       	mov al, 1
0147+  05F3 05 03       	syscall sys_io			; receive in AH
0148+  05F5 B9 00       	cmp al, 0				; check error code (AL)
0149+  05F7 C6 EF 05    	je gets_loop			; if no char received, retry
0150+  05FA             
0151+  05FA 76 1B       	cmp ah, 27
0152+  05FC C6 1D 06    	je gets_telnet_escape
0153+  05FF 76 0A       	cmp ah, $0A				; LF
0154+  0601 C6 76 06    	je gets_end
0155+  0604 76 0D       	cmp ah, $0D				; CR
0156+  0606 C6 76 06    	je gets_end
0157+  0609 76 5C       	cmp ah, $5C				; '\\'
0158+  060B C6 4D 06    	je gets_escape
0159+  060E             	
0160+  060E 76 08       	cmp ah, $08			; check for backspace
0161+  0610 C6 19 06    	je gets_backspace
0162+  0613             
0163+  0613 1A          	mov al, ah
0164+  0614 3E          	mov [d], al
0165+  0615 79          	inc d
0166+  0616 0A EF 05    	jmp gets_loop
0167+  0619             gets_backspace:
0168+  0619 7F          	dec d
0169+  061A 0A EF 05    	jmp gets_loop
0170+  061D             gets_telnet_escape:
0171+  061D FD 0C       	sti
0172+  061F 19 01       	mov al, 1
0173+  0621 05 03       	syscall sys_io				; receive in AH without echo
0174+  0623 B9 00       	cmp al, 0					; check error code (AL)
0175+  0625 C6 1D 06    	je gets_telnet_escape		; if no char received, retry
0176+  0628 76 5B       	cmp ah, '['
0177+  062A C7 EF 05    	jne gets_loop
0178+  062D             gets_telnet_escape_phase2:
0179+  062D FD 0C       	sti
0180+  062F 19 01       	mov al, 1
0181+  0631 05 03       	syscall sys_io					; receive in AH without echo
0182+  0633 B9 00       	cmp al, 0						; check error code (AL)
0183+  0635 C6 2D 06    	je gets_telnet_escape_phase2	; if no char received, retry
0184+  0638 76 44       	cmp ah, 'D'
0185+  063A C6 45 06    	je gets_left_arrow
0186+  063D 76 43       	cmp ah, 'C'
0187+  063F C6 49 06    	je gets_right_arrow
0188+  0642 0A EF 05    	jmp gets_loop
0189+  0645             gets_left_arrow:
0190+  0645 7F          	dec d
0191+  0646 0A EF 05    	jmp gets_loop
0192+  0649             gets_right_arrow:
0193+  0649 79          	inc d
0194+  064A 0A EF 05    	jmp gets_loop
0195+  064D             gets_escape:
0196+  064D FD 0C       	sti
0197+  064F 19 01       	mov al, 1
0198+  0651 05 03       	syscall sys_io			; receive in AH
0199+  0653 B9 00       	cmp al, 0				; check error code (AL)
0200+  0655 C6 4D 06    	je gets_escape			; if no char received, retry
0201+  0658 76 6E       	cmp ah, 'n'
0202+  065A C6 68 06    	je gets_LF
0203+  065D 76 72       	cmp ah, 'r'
0204+  065F C6 6F 06    	je gets_CR
0205+  0662 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0206+  0663 3E          	mov [d], al
0207+  0664 79          	inc d
0208+  0665 0A EF 05    	jmp gets_loop
0209+  0668             gets_LF:
0210+  0668 19 0A       	mov al, $0A
0211+  066A 3E          	mov [d], al
0212+  066B 79          	inc d
0213+  066C 0A EF 05    	jmp gets_loop
0214+  066F             gets_CR:
0215+  066F 19 0D       	mov al, $0D
0216+  0671 3E          	mov [d], al
0217+  0672 79          	inc d
0218+  0673 0A EF 05    	jmp gets_loop
0219+  0676             gets_end:
0220+  0676 19 00       	mov al, 0
0221+  0678 3E          	mov [d], al				; terminate string
0222+  0679 E7          	pop d
0223+  067A E4          	pop a
0224+  067B 09          	ret
0225+  067C             
0226+  067C             
0227+  067C             
0228+  067C             
0229+  067C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0230+  067C             ;; INPUT TEXT
0231+  067C             ;; terminated with CTRL+D
0232+  067C             ;; pointer in D
0233+  067C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0234+  067C             gettxt:
0235+  067C D7          	push a
0236+  067D DA          	push d
0237+  067E             gettxt_loop:
0238+  067E 19 01       	mov al, 1
0239+  0680 05 03       	syscall sys_io			; receive in AH
0240+  0682 B9 00       	cmp al, 0				; check error code (AL)
0241+  0684 C6 7E 06    	je gettxt_loop		; if no char received, retry
0242+  0687 76 04       	cmp ah, 4			; EOT
0243+  0689 C6 C7 06    	je gettxt_end
0244+  068C 76 08       	cmp ah, $08			; check for backspace
0245+  068E C6 C3 06    	je gettxt_backspace
0246+  0691 76 5C       	cmp ah, $5C				; '\\'
0247+  0693 C6 9C 06    	je gettxt_escape
0248+  0696 1A          	mov al, ah
0249+  0697 3E          	mov [d], al
0250+  0698 79          	inc d
0251+  0699 0A 7E 06    	jmp gettxt_loop
0252+  069C             gettxt_escape:
0253+  069C 19 01       	mov al, 1
0254+  069E 05 03       	syscall sys_io			; receive in AH
0255+  06A0 B9 00       	cmp al, 0				; check error code (AL)
0256+  06A2 C6 9C 06    	je gettxt_escape		; if no char received, retry
0257+  06A5 76 6E       	cmp ah, 'n'
0258+  06A7 C6 B5 06    	je gettxt_LF
0259+  06AA 76 72       	cmp ah, 'r'
0260+  06AC C6 BC 06    	je gettxt_CR
0261+  06AF 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0262+  06B0 3E          	mov [d], al
0263+  06B1 79          	inc d
0264+  06B2 0A 7E 06    	jmp gettxt_loop
0265+  06B5             gettxt_LF:
0266+  06B5 19 0A       	mov al, $0A
0267+  06B7 3E          	mov [d], al
0268+  06B8 79          	inc d
0269+  06B9 0A 7E 06    	jmp gettxt_loop
0270+  06BC             gettxt_CR:
0271+  06BC 19 0D       	mov al, $0D
0272+  06BE 3E          	mov [d], al
0273+  06BF 79          	inc d
0274+  06C0 0A 7E 06    	jmp gettxt_loop
0275+  06C3             gettxt_backspace:
0276+  06C3 7F          	dec d
0277+  06C4 0A 7E 06    	jmp gettxt_loop
0278+  06C7             gettxt_end:
0279+  06C7 19 00       	mov al, 0
0280+  06C9 3E          	mov [d], al				; terminate string
0281+  06CA E7          	pop d
0282+  06CB E4          	pop a
0283+  06CC 09          	ret
0284+  06CD             
0285+  06CD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0286+  06CD             ; PRINT NEW LINE
0287+  06CD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  06CD             printnl:
0289+  06CD D7          	push a
0290+  06CE 10 00 0A    	mov a, $0A00
0291+  06D1 05 03       	syscall sys_io
0292+  06D3 10 00 0D    	mov a, $0D00
0293+  06D6 05 03       	syscall sys_io
0294+  06D8 E4          	pop a
0295+  06D9 09          	ret
0296+  06DA             
0297+  06DA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0298+  06DA             ; strtoint
0299+  06DA             ; 4 digit hex string number in d
0300+  06DA             ; integer returned in A
0301+  06DA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0302+  06DA             strtointx:
0303+  06DA D8          	push b
0304+  06DB 32          	mov bl, [d]
0305+  06DC 37          	mov bh, bl
0306+  06DD 33 01 00    	mov bl, [d + 1]
0307+  06E0 07 9B 05    	call atoi				; convert to int in AL
0308+  06E3 23          	mov ah, al				; move to AH
0309+  06E4 33 02 00    	mov bl, [d + 2]
0310+  06E7 37          	mov bh, bl
0311+  06E8 33 03 00    	mov bl, [d + 3]
0312+  06EB 07 9B 05    	call atoi				; convert to int in AL
0313+  06EE E5          	pop b
0314+  06EF 09          	ret
0315+  06F0             
0316+  06F0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0317+  06F0             ; strtoint
0318+  06F0             ; 5 digit base10 string number in d
0319+  06F0             ; integer returned in A
0320+  06F0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0321+  06F0             strtoint:
0322+  06F0 E2          	push si
0323+  06F1 D8          	push b
0324+  06F2 D9          	push c
0325+  06F3 DA          	push d
0326+  06F4 07 23 05    	call strlen			; get string length in C
0327+  06F7 7E          	dec c
0328+  06F8 FD 4E       	mov si, d
0329+  06FA 12          	mov a, c
0330+  06FB FD 99       	shl a
0331+  06FD 3B 83 05    	mov d, table_power
0332+  0700 59          	add d, a
0333+  0701 38 00 00    	mov c, 0
0334+  0704             strtoint_L0:
0335+  0704 F6          	lodsb			; load ASCII to al
0336+  0705 B9 00       	cmp al, 0
0337+  0707 C6 1A 07    	je strtoint_end
0338+  070A 6F 30       	sub al, $30		; make into integer
0339+  070C 22 00       	mov ah, 0
0340+  070E 2A          	mov b, [d]
0341+  070F AC          	mul a, b			; result in B since it fits in 16bits
0342+  0710 11          	mov a, b
0343+  0711 28          	mov b, c
0344+  0712 54          	add a, b
0345+  0713 39          	mov c, a
0346+  0714 63 02 00    	sub d, 2
0347+  0717 0A 04 07    	jmp strtoint_L0
0348+  071A             strtoint_end:
0349+  071A 12          	mov a, c
0350+  071B E7          	pop d
0351+  071C E6          	pop c
0352+  071D E5          	pop b
0353+  071E EF          	pop si
0354+  071F 09          	ret
0355+  0720             
0356+  0720             
0357+  0720             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0358+  0720             ; PRINT NULL TERMINATED STRING
0359+  0720             ; pointer in D
0360+  0720             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0361+  0720             puts:
0362+  0720 D7          	push a
0363+  0721 DA          	push d
0364+  0722             puts_L1:
0365+  0722 1E          	mov al, [d]
0366+  0723 B9 00       	cmp al, 0
0367+  0725 C6 31 07    	jz puts_END
0368+  0728 23          	mov ah, al
0369+  0729 19 00       	mov al, 0
0370+  072B 05 03       	syscall sys_io
0371+  072D 79          	inc d
0372+  072E 0A 22 07    	jmp puts_L1
0373+  0731             puts_END:
0374+  0731 E7          	pop d
0375+  0732 E4          	pop a
0376+  0733 09          	ret
0377+  0734             
0378+  0734             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  0734             ; PRINT N SIZE STRING
0380+  0734             ; pointer in D
0381+  0734             ; size in C
0382+  0734             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0383+  0734             putsn:
0384+  0734 DB          	push al
0385+  0735 DA          	push d
0386+  0736 D9          	push c
0387+  0737             putsn_L0:
0388+  0737 1E          	mov al, [d]
0389+  0738 23          	mov ah, al
0390+  0739 19 00       	mov al, 0
0391+  073B 05 03       	syscall sys_io
0392+  073D 79          	inc d
0393+  073E 7E          	dec c	
0394+  073F C2 00 00    	cmp c, 0
0395+  0742 C7 37 07    	jne putsn_L0
0396+  0745             putsn_end:
0397+  0745 E6          	pop c
0398+  0746 E7          	pop d
0399+  0747 E8          	pop al
0400+  0748 09          	ret
0401+  0749             
0402+  0749             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0403+  0749             ; print 16bit decimal number
0404+  0749             ; input number in A
0405+  0749             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  0749             print_u16d:
0407+  0749 D7          	push a
0408+  074A D8          	push b
0409+  074B 26 10 27    	mov b, 10000
0410+  074E AE          	div a, b			; get 10000 coeff.
0411+  074F 07 75 07    	call print_number
0412+  0752 11          	mov a, b
0413+  0753 26 E8 03    	mov b, 1000
0414+  0756 AE          	div a, b			; get 10000 coeff.
0415+  0757 07 75 07    	call print_number
0416+  075A 11          	mov a, b
0417+  075B 26 64 00    	mov b, 100
0418+  075E AE          	div a, b
0419+  075F 07 75 07    	call print_number
0420+  0762 11          	mov a, b
0421+  0763 26 0A 00    	mov b, 10
0422+  0766 AE          	div a, b
0423+  0767 07 75 07    	call print_number
0424+  076A 11          	mov a, b
0425+  076B 6A 30       	add al, $30
0426+  076D 23          	mov ah, al
0427+  076E 19 00       	mov al, 0
0428+  0770 05 03       	syscall sys_io	; print coeff
0429+  0772 E5          	pop b
0430+  0773 E4          	pop a
0431+  0774 09          	ret
0432+  0775             
0433+  0775             
0434+  0775             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0435+  0775             ; if A == 0, print space
0436+  0775             ; else print A
0437+  0775             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0438+  0775             print_number:
0439+  0775 6A 30       	add al, $30
0440+  0777 23          	mov ah, al
0441+  0778 07 E6 05    	call putchar
0442+  077B 09          	ret
0443+  077C             
0444+  077C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  077C             ; PRINT 16BIT HEX INTEGER
0446+  077C             ; integer value in reg B
0447+  077C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  077C             print_u16x:
0449+  077C D7          	push a
0450+  077D D8          	push b
0451+  077E DD          	push bl
0452+  077F 30          	mov bl, bh
0453+  0780 07 AD 05    	call itoa				; convert bh to char in A
0454+  0783 2F          	mov bl, al				; save al
0455+  0784 19 00       	mov al, 0
0456+  0786 05 03       	syscall sys_io				; display AH
0457+  0788 24          	mov ah, bl				; retrieve al
0458+  0789 19 00       	mov al, 0
0459+  078B 05 03       	syscall sys_io				; display AL
0460+  078D             
0461+  078D EA          	pop bl
0462+  078E 07 AD 05    	call itoa				; convert bh to char in A
0463+  0791 2F          	mov bl, al				; save al
0464+  0792 19 00       	mov al, 0
0465+  0794 05 03       	syscall sys_io				; display AH
0466+  0796 24          	mov ah, bl				; retrieve al
0467+  0797 19 00       	mov al, 0
0468+  0799 05 03       	syscall sys_io				; display AL
0469+  079B             
0470+  079B E5          	pop b
0471+  079C E4          	pop a
0472+  079D 09          	ret
0473+  079E             
0474+  079E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0475+  079E             ; INPUT 16BIT HEX INTEGER
0476+  079E             ; read 16bit integer into A
0477+  079E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0478+  079E             scan_u16x:
0479+  079E F8 10 00    	enter 16
0480+  07A1 D8          	push b
0481+  07A2 DA          	push d
0482+  07A3             
0483+  07A3 FA F1 FF    	lea d, [bp + -15]
0484+  07A6 07 ED 05    	call gets				; get number
0485+  07A9             
0486+  07A9 32          	mov bl, [d]
0487+  07AA 37          	mov bh, bl
0488+  07AB 33 01 00    	mov bl, [d + 1]
0489+  07AE 07 9B 05    	call atoi				; convert to int in AL
0490+  07B1 23          	mov ah, al				; move to AH
0491+  07B2             
0492+  07B2 33 02 00    	mov bl, [d + 2]
0493+  07B5 37          	mov bh, bl
0494+  07B6 33 03 00    	mov bl, [d + 3]
0495+  07B9 07 9B 05    	call atoi				; convert to int in AL
0496+  07BC             
0497+  07BC E7          	pop d
0498+  07BD E5          	pop b
0499+  07BE F9          	leave
0500+  07BF 09          	ret
0501+  07C0             
0502+  07C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0503+  07C0             ; PRINT 8bit HEX INTEGER
0504+  07C0             ; integer value in reg bl
0505+  07C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0506+  07C0             print_u8x:
0507+  07C0 D7          	push a
0508+  07C1 DD          	push bl
0509+  07C2             
0510+  07C2 07 AD 05    	call itoa				; convert bl to char in A
0511+  07C5 2F          	mov bl, al				; save al
0512+  07C6 19 00       	mov al, 0
0513+  07C8 05 03       	syscall sys_io				; display AH
0514+  07CA 24          	mov ah, bl				; retrieve al
0515+  07CB 19 00       	mov al, 0
0516+  07CD 05 03       	syscall sys_io				; display AL
0517+  07CF             
0518+  07CF EA          	pop bl
0519+  07D0 E4          	pop a
0520+  07D1 09          	ret
0521+  07D2             
0522+  07D2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0523+  07D2             ; print 8bit decimal unsigned number
0524+  07D2             ; input number in AL
0525+  07D2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0526+  07D2             print_u8d:
0527+  07D2 D7          	push a
0528+  07D3 D8          	push b
0529+  07D4             
0530+  07D4 22 00       	mov ah, 0
0531+  07D6 26 64 00    	mov b, 100
0532+  07D9 AE          	div a, b
0533+  07DA D8          	push b			; save remainder
0534+  07DB B9 00       	cmp al, 0
0535+  07DD C6 E7 07    	je skip100
0536+  07E0 6A 30       	add al, $30
0537+  07E2 23          	mov ah, al
0538+  07E3 19 00       	mov al, 0
0539+  07E5 05 03       	syscall sys_io	; print coeff
0540+  07E7             skip100:
0541+  07E7 E4          	pop a
0542+  07E8 22 00       	mov ah, 0
0543+  07EA 26 0A 00    	mov b, 10
0544+  07ED AE          	div a, b
0545+  07EE D8          	push b			; save remainder
0546+  07EF B9 00       	cmp al, 0
0547+  07F1 C6 FB 07    	je skip10
0548+  07F4 6A 30       	add al, $30
0549+  07F6 23          	mov ah, al
0550+  07F7 19 00       	mov al, 0
0551+  07F9 05 03       	syscall sys_io	; print coeff
0552+  07FB             skip10:
0553+  07FB E4          	pop a
0554+  07FC 1B          	mov al, bl
0555+  07FD 6A 30       	add al, $30
0556+  07FF 23          	mov ah, al
0557+  0800 19 00       	mov al, 0
0558+  0802 05 03       	syscall sys_io	; print coeff
0559+  0804 E5          	pop b
0560+  0805 E4          	pop a
0561+  0806 09          	ret
0562+  0807             
0563+  0807             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0564+  0807             ; INPUT 8BIT HEX INTEGER
0565+  0807             ; read 8bit integer into AL
0566+  0807             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0567+  0807             scan_u8x:
0568+  0807 F8 04 00    	enter 4
0569+  080A D8          	push b
0570+  080B DA          	push d
0571+  080C             
0572+  080C FA FD FF    	lea d, [bp + -3]
0573+  080F 07 ED 05    	call gets				; get number
0574+  0812             
0575+  0812 32          	mov bl, [d]
0576+  0813 37          	mov bh, bl
0577+  0814 33 01 00    	mov bl, [d + 1]
0578+  0817 07 9B 05    	call atoi				; convert to int in AL
0579+  081A             
0580+  081A E7          	pop d
0581+  081B E5          	pop b
0582+  081C F9          	leave
0583+  081D 09          	ret
0584+  081E             
0585+  081E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0586+  081E             ; input decimal number
0587+  081E             ; result in A
0588+  081E             ; 655'\0'
0589+  081E             ; low--------high
0590+  081E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0591+  081E             scan_u16d:
0592+  081E F8 08 00    	enter 8
0593+  0821 E2          	push si
0594+  0822 D8          	push b
0595+  0823 D9          	push c
0596+  0824 DA          	push d
0597+  0825 FA F9 FF    	lea d, [bp +- 7]
0598+  0828 07 ED 05    	call gets
0599+  082B 07 23 05    	call strlen			; get string length in C
0600+  082E 7E          	dec c
0601+  082F FD 4E       	mov si, d
0602+  0831 12          	mov a, c
0603+  0832 FD 99       	shl a
0604+  0834 3B 83 05    	mov d, table_power
0605+  0837 59          	add d, a
0606+  0838 38 00 00    	mov c, 0
0607+  083B             mul_loop:
0608+  083B F6          	lodsb			; load ASCII to al
0609+  083C B9 00       	cmp al, 0
0610+  083E C6 51 08    	je mul_exit
0611+  0841 6F 30       	sub al, $30		; make into integer
0612+  0843 22 00       	mov ah, 0
0613+  0845 2A          	mov b, [d]
0614+  0846 AC          	mul a, b			; result in B since it fits in 16bits
0615+  0847 11          	mov a, b
0616+  0848 28          	mov b, c
0617+  0849 54          	add a, b
0618+  084A 39          	mov c, a
0619+  084B 63 02 00    	sub d, 2
0620+  084E 0A 3B 08    	jmp mul_loop
0621+  0851             mul_exit:
0622+  0851 12          	mov a, c
0623+  0852 E7          	pop d
0624+  0853 E6          	pop c
0625+  0854 E5          	pop b
0626+  0855 EF          	pop si
0627+  0856 F9          	leave
0628+  0857 09          	ret
0035   0858             
0036   0858             
0037   0858             .end
0038   0858             
0039   0858             
0040   0858             
tasm: Number of errors = 0
