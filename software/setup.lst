0001   0000             .include "kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0002   0000             
0003   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0005   0000             
0006   0400             .org PROC_TEXT_ORG			; origin at 1024
0007   0400             
0008   0400             ; 1) read /etc/boot.conf to find kernel filename
0009   0400             ; 2) from filename, obtain LBA address of kernel file
0010   0400             ; 3) write LBA address to bootloader sector, at address 1FF (511)
0011   0400             
0012   0400             bootloader_installer:
0013   0400             ; open /etc/boot.conf file
0014   0400             ; read image config entry
0015   0400 3B 73 04    	mov d, s_etc_bootconf			; '/etc/boot.conf'
0016   0403 FD 4D 82 04 	mov si, s_image					; config entry name is "image"
0017   0407 FD 4F 88 04 	mov di, kernel_filename		
0018   040B 07 2A 04    	call read_config
0019   040E             	
0020   040E 3B 88 04    	mov d, kernel_filename
0021   0411 07 3A 0A    	call puts
0022   0414 07 E7 09    	call printnl
0023   0417             	
0024   0417 3B 88 04    	mov d, kernel_filename
0025   041A 19 13       	mov al, 19
0026   041C 05 04       	syscall sys_fileio		; obtain dirID for kernel file, in A
0027   041E 77          	inc a					; increment LBA because data starts after the header sector
0028   041F 27          	mov b, a
0029   0420 07 96 0A    	call print_u16x
0030   0423 05 0D       	syscall sys_boot_install
0031   0425             
0032   0425 07 E7 09    	call printnl
0033   0428 05 0B       	syscall sys_terminate_proc
0034   042A             
0035   042A             ; inputs:
0036   042A             ; D = filename ptr
0037   042A             ; SI = entry name ptr
0038   042A             ; DI = output value string ptr
0039   042A             read_config:
0040   042A E3          	push di
0041   042B E2          	push si
0042   042C FD 4F 0F 0C 	mov di, transient_area
0043   0430 19 14       	mov al, 20
0044   0432 05 04       	syscall sys_fileio				; read entire config file
0045   0434 10 0F 0C    	mov a, transient_area
0046   0437 42 F2 06    	mov [prog], a
0047   043A EF          	pop si
0048   043B             read_config_L0:
0049   043B 07 53 05    	call get_token
0050   043E BC F5 06 14 	cmp byte[tok], TOK_END
0051   0442 C6 6E 04    	je read_config_EOF
0052   0445 FD 4F F6 06 	mov di, tokstr
0053   0449 07 4D 08    	call strcmp
0054   044C C6 5C 04    	je read_config_found_entry
0055   044F             read_config_L0_L0:
0056   044F 07 53 05    	call get_token
0057   0452 BC F5 06 06 	cmp byte[tok], TOK_SEMI
0058   0456 C6 3B 04    	je read_config_L0
0059   0459 0A 4F 04    	jmp read_config_L0_L0
0060   045C             read_config_found_entry:
0061   045C 07 53 05    	call get_token			; bypass '=' sign
0062   045F F0          	pop di
0063   0460 14 F2 06    	mov a, [prog]
0064   0463 4D          	mov si, a
0065   0464             read_conf_L1:
0066   0464 F6          	lodsb
0067   0465 B9 3B       	cmp al, $3B				; ';'
0068   0467 C6 6F 04    	je read_config_EOF_2
0069   046A F7          	stosb
0070   046B 0A 64 04    	jmp read_conf_L1
0071   046E             read_config_EOF:
0072   046E F0          	pop di
0073   046F             read_config_EOF_2:
0074   046F 19 00       	mov al, 0
0075   0471 F7          	stosb					; terminate value with NULL
0076   0472 09          	ret
0077   0473             
0078   0473 2F 65 74 63 s_etc_bootconf:		.db "/etc/boot.conf", 0
0078   0477 2F 62 6F 6F 
0078   047B 74 2E 63 6F 
0078   047F 6E 66 00 
0079   0482 69 6D 61 67 s_image:			.db "image", 0
0079   0486 65 00 
0080   0488 00 00 00 00 kernel_filename:	.fill 64, 0
0080   048C 00 00 00 00 
0080   0490 00 00 00 00 
0080   0494 00 00 00 00 
0080   0498 00 00 00 00 
0080   049C 00 00 00 00 
0080   04A0 00 00 00 00 
0080   04A4 00 00 00 00 
0080   04A8 00 00 00 00 
0080   04AC 00 00 00 00 
0080   04B0 00 00 00 00 
0080   04B4 00 00 00 00 
0080   04B8 00 00 00 00 
0080   04BC 00 00 00 00 
0080   04C0 00 00 00 00 
0080   04C4 00 00 00 00 
0081   04C8             
0082   04C8             .include "token.asm"
0001+  04C8             TOKTYP_IDENTIFIER	.equ 0
0002+  04C8             TOKTYP_KEYWORD		.equ 1
0003+  04C8             TOKTYP_DELIMITER	.equ 2
0004+  04C8             TOKTYP_STRING		.equ 3
0005+  04C8             TOKTYP_CHAR			.equ 4
0006+  04C8             TOKTYP_NUMERIC		.equ 5
0007+  04C8             TOKTYP_END			.equ 6
0008+  04C8             
0009+  04C8             TOK_NULL			.equ 0
0010+  04C8             TOK_FSLASH			.equ 1
0011+  04C8             TOK_TIMES 			.equ 2
0012+  04C8             TOK_PLUS 			.equ 3
0013+  04C8             TOK_MINUS 			.equ 4
0014+  04C8             TOK_DOT				.equ 5
0015+  04C8             TOK_SEMI			.equ 6
0016+  04C8             TOK_ANGLE			.equ 7
0017+  04C8             TOK_TILDE			.equ 8
0018+  04C8             TOK_EQUAL			.equ 9
0019+  04C8             TOK_COLON			.equ 10
0020+  04C8             TOK_COMMA			.equ 11
0021+  04C8             
0022+  04C8             TOK_END				.equ 20
0023+  04C8             
0024+  04C8             
0025+  04C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  04C8             ;; read a full command argment from shell input buffer
0027+  04C8             ;; argument is written into tokstr
0028+  04C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  04C8             get_arg:
0030+  04C8 D7          	push a
0031+  04C9 E2          	push si
0032+  04CA E3          	push di
0033+  04CB 19 00       	mov al, 0
0034+  04CD 3D F6 06    	mov [tokstr], al			; nullify tokstr string
0035+  04D0 14 F2 06    	mov a, [prog]
0036+  04D3 4D          	mov si, a
0037+  04D4 FD 4F F6 06 	mov di, tokstr
0038+  04D8             get_arg_skip_spaces:
0039+  04D8 F6          	lodsb
0040+  04D9 07 E8 0B    	call isspace
0041+  04DC C6 D8 04    	je get_arg_skip_spaces
0042+  04DF             get_arg_L0:
0043+  04DF B9 3B       	cmp al, $3B				; check if is ';'
0044+  04E1 C6 EE 04    	je get_arg_end
0045+  04E4 B9 00       	cmp al, 0
0046+  04E6 C6 EE 04    	je get_arg_end			; check if end of input
0047+  04E9 F7          	stosb
0048+  04EA F6          	lodsb
0049+  04EB 0A DF 04    	jmp get_arg_L0
0050+  04EE             get_arg_end:
0051+  04EE 19 00       	mov al, 0
0052+  04F0 F7          	stosb
0053+  04F1 D5 01 00    	sub si, 1
0054+  04F4 4E          	mov a, si
0055+  04F5 42 F2 06    	mov [prog], a		; update pointer
0056+  04F8 F0          	pop di
0057+  04F9 EF          	pop si
0058+  04FA E4          	pop a
0059+  04FB 09          	ret
0060+  04FC             
0061+  04FC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  04FC             ;; read a path formation from shell input buffer
0063+  04FC             ;; path is written into tokstr
0064+  04FC             ;; /usr/bin
0065+  04FC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  04FC             get_path:
0067+  04FC D7          	push a
0068+  04FD E2          	push si
0069+  04FE E3          	push di
0070+  04FF 19 00       	mov al, 0
0071+  0501 3D F6 06    	mov [tokstr], al			; nullify tokstr string
0072+  0504 14 F2 06    	mov a, [prog]
0073+  0507 4D          	mov si, a
0074+  0508 FD 4F F6 06 	mov di, tokstr
0075+  050C             get_path_skip_spaces:
0076+  050C F6          	lodsb
0077+  050D 07 E8 0B    	call isspace
0078+  0510 C6 0C 05    	je get_path_skip_spaces
0079+  0513             get_path_is_pathchar:
0080+  0513 F7          	stosb
0081+  0514 F6          	lodsb
0082+  0515 07 72 0B    	call isalnum			;check if is alphanumeric
0083+  0518 C6 13 05    	je get_path_is_pathchar
0084+  051B B9 2F       	cmp al, '/'				; check if is '/'
0085+  051D C6 13 05    	je get_path_is_pathchar
0086+  0520 19 00       	mov al, 0
0087+  0522 F7          	stosb
0088+  0523 D5 01 00    	sub si, 1
0089+  0526 4E          	mov a, si
0090+  0527 42 F2 06    	mov [prog], a		; update pointer
0091+  052A             get_path_end:
0092+  052A F0          	pop di
0093+  052B EF          	pop si
0094+  052C E4          	pop a
0095+  052D 09          	ret
0096+  052E             
0097+  052E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  052E             ;; read a line
0099+  052E             ;; line is written into tokstr
0100+  052E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  052E             get_line:
0102+  052E D7          	push a
0103+  052F E2          	push si
0104+  0530 E3          	push di
0105+  0531 19 00       	mov al, 0
0106+  0533 3D F6 06    	mov [tokstr], al			; nullify tokstr string
0107+  0536 14 F2 06    	mov a, [prog]
0108+  0539 4D          	mov si, a
0109+  053A FD 4F F6 06 	mov di, tokstr
0110+  053E             get_line_L0:
0111+  053E F6          	lodsb
0112+  053F B9 0A       	cmp al, $0A		; check for new line
0113+  0541 C6 48 05    	je get_line_exit
0114+  0544 F7          	stosb
0115+  0545 0A 3E 05    	jmp get_line_L0
0116+  0548             get_line_exit:
0117+  0548 19 00       	mov al, 0
0118+  054A F7          	stosb
0119+  054B 4E          	mov a, si
0120+  054C 42 F2 06    	mov [prog], a		; update pointer
0121+  054F F0          	pop di
0122+  0550 EF          	pop si
0123+  0551 E4          	pop a
0124+  0552 09          	ret
0125+  0553             
0126+  0553             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  0553             ;; token parser
0128+  0553             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  0553             get_token:
0130+  0553 D7          	push a
0131+  0554 DA          	push d
0132+  0555 E2          	push si
0133+  0556 E3          	push di
0134+  0557 19 00       	mov al, 0
0135+  0559 3D F6 06    	mov [tokstr], al			; nullify tokstr string
0136+  055C 19 00       	mov al, TOK_NULL
0137+  055E 3D F5 06    	mov [tok], al				; nullify token
0138+  0561 14 F2 06    	mov a, [prog]
0139+  0564 4D          	mov si, a
0140+  0565 FD 4F F6 06 	mov di, tokstr
0141+  0569             get_tok_skip_spaces:
0142+  0569 F6          	lodsb
0143+  056A 07 E8 0B    	call isspace
0144+  056D C6 69 05    	je get_tok_skip_spaces
0145+  0570 B9 00       	cmp al, 0			; check for end of input (NULL)
0146+  0572 C6 57 06    	je get_token_end
0147+  0575 B9 23       	cmp al, '#'			; comments!
0148+  0577 C6 85 06    	je get_tok_comment
0149+  057A 07 72 0B    	call isalnum
0150+  057D C6 64 06    	jz is_alphanumeric
0151+  0580             ; other token types
0152+  0580             get_token_slash:
0153+  0580 B9 2F       	cmp al, '/'				; check if '/'
0154+  0582 C7 9A 05    	jne get_token_minus
0155+  0585 F7          	stosb					; store '/' into token string
0156+  0586 19 00       	mov al, 0
0157+  0588 F7          	stosb					; terminate token string
0158+  0589 19 01       	mov al, TOK_FSLASH
0159+  058B 3D F5 06    	mov [tok], al			
0160+  058E 19 02       	mov al, TOKTYP_DELIMITER
0161+  0590 3D F4 06    	mov [toktyp], al
0162+  0593 4E          	mov a, si
0163+  0594 42 F2 06    	mov [prog], a		; update pointer
0164+  0597 0A 80 06    	jmp get_token_return
0165+  059A             get_token_minus:
0166+  059A B9 2D       	cmp al, '-'				; check if '-'
0167+  059C C7 B4 05    	jne get_token_comma
0168+  059F F7          	stosb					; store '-' into token string
0169+  05A0 19 00       	mov al, 0
0170+  05A2 F7          	stosb					; terminate token string
0171+  05A3 19 04       	mov al, TOK_MINUS
0172+  05A5 3D F5 06    	mov [tok], al			
0173+  05A8 19 02       	mov al, TOKTYP_DELIMITER
0174+  05AA 3D F4 06    	mov [toktyp], al
0175+  05AD 4E          	mov a, si
0176+  05AE 42 F2 06    	mov [prog], a		; update pointer
0177+  05B1 0A 80 06    	jmp get_token_return
0178+  05B4             get_token_comma:
0179+  05B4 B9 2C       	cmp al, ','				; check if ','
0180+  05B6 C7 CE 05    	jne get_token_semi
0181+  05B9 F7          	stosb					; store ',' into token string
0182+  05BA 19 00       	mov al, 0
0183+  05BC F7          	stosb					; terminate token string
0184+  05BD 19 0B       	mov al, TOK_COMMA
0185+  05BF 3D F5 06    	mov [tok], al			
0186+  05C2 19 02       	mov al, TOKTYP_DELIMITER
0187+  05C4 3D F4 06    	mov [toktyp], al
0188+  05C7 4E          	mov a, si
0189+  05C8 42 F2 06    	mov [prog], a		; update pointer
0190+  05CB 0A 80 06    	jmp get_token_return
0191+  05CE             get_token_semi:
0192+  05CE B9 3B       	cmp al, $3B				; check if ';'
0193+  05D0 C7 E8 05    	jne get_token_colon
0194+  05D3 F7          	stosb					; store ';' into token string
0195+  05D4 19 00       	mov al, 0
0196+  05D6 F7          	stosb					; terminate token string
0197+  05D7 19 06       	mov al, TOK_SEMI
0198+  05D9 3D F5 06    	mov [tok], al			
0199+  05DC 19 02       	mov al, TOKTYP_DELIMITER
0200+  05DE 3D F4 06    	mov [toktyp], al
0201+  05E1 4E          	mov a, si
0202+  05E2 42 F2 06    	mov [prog], a		; update pointer
0203+  05E5 0A 80 06    	jmp get_token_return
0204+  05E8             get_token_colon:
0205+  05E8 B9 3A       	cmp al, $3A				; check if ':'
0206+  05EA C7 02 06    	jne get_token_angle
0207+  05ED F7          	stosb					; store ':' into token string
0208+  05EE 19 00       	mov al, 0
0209+  05F0 F7          	stosb					; terminate token string
0210+  05F1 19 0A       	mov al, TOK_COLON
0211+  05F3 3D F5 06    	mov [tok], al			
0212+  05F6 19 02       	mov al, TOKTYP_DELIMITER
0213+  05F8 3D F4 06    	mov [toktyp], al
0214+  05FB 4E          	mov a, si
0215+  05FC 42 F2 06    	mov [prog], a		; update pointer
0216+  05FF 0A 80 06    	jmp get_token_return
0217+  0602             get_token_angle:
0218+  0602 B9 3E       	cmp al, $3E				; check if '>'
0219+  0604 C7 1C 06    	jne get_token_tilde
0220+  0607 F7          	stosb					; store '>' into token string
0221+  0608 19 00       	mov al, 0
0222+  060A F7          	stosb					; terminate token string
0223+  060B 19 07       	mov al, TOK_ANGLE
0224+  060D 3D F5 06    	mov [tok], al			
0225+  0610 19 02       	mov al, TOKTYP_DELIMITER
0226+  0612 3D F4 06    	mov [toktyp], al
0227+  0615 4E          	mov a, si
0228+  0616 42 F2 06    	mov [prog], a		; update pointer
0229+  0619 0A 80 06    	jmp get_token_return
0230+  061C             get_token_tilde:
0231+  061C B9 7E       	cmp al, '~'				; check if '~'
0232+  061E C7 36 06    	jne get_token_equal
0233+  0621 F7          	stosb					; store '~' into token string
0234+  0622 19 00       	mov al, 0
0235+  0624 F7          	stosb					; terminate token string
0236+  0625 19 08       	mov al, TOK_TILDE
0237+  0627 3D F5 06    	mov [tok], al			
0238+  062A 19 02       	mov al, TOKTYP_DELIMITER
0239+  062C 3D F4 06    	mov [toktyp], al
0240+  062F 4E          	mov a, si
0241+  0630 42 F2 06    	mov [prog], a		; update pointer
0242+  0633 0A 80 06    	jmp get_token_return
0243+  0636             get_token_equal:
0244+  0636 B9 3D       	cmp al, '='				; check if '='
0245+  0638 C7 50 06    	jne get_token_skip
0246+  063B F7          	stosb					; store '=' into token string
0247+  063C 19 00       	mov al, 0
0248+  063E F7          	stosb					; terminate token string
0249+  063F 19 09       	mov al, TOK_EQUAL
0250+  0641 3D F5 06    	mov [tok], al			
0251+  0644 19 02       	mov al, TOKTYP_DELIMITER
0252+  0646 3D F4 06    	mov [toktyp], al
0253+  0649 4E          	mov a, si
0254+  064A 42 F2 06    	mov [prog], a		; update pointer
0255+  064D 0A 80 06    	jmp get_token_return
0256+  0650             get_token_skip:
0257+  0650 4E          	mov a, si
0258+  0651 42 F2 06    	mov [prog], a		; update pointer
0259+  0654 0A 80 06    	jmp get_token_return
0260+  0657             get_token_end:				; end of file token
0261+  0657 19 14       	mov al, TOK_END
0262+  0659 3D F5 06    	mov [tok], al
0263+  065C 19 06       	mov al, TOKTYP_END
0264+  065E 3D F4 06    	mov [toktyp], al
0265+  0661 0A 80 06    	jmp get_token_return
0266+  0664             is_alphanumeric:
0267+  0664 F7          	stosb
0268+  0665 F6          	lodsb
0269+  0666 07 72 0B    	call isalnum			;check if is alphanumeric
0270+  0669 C6 64 06    	jz is_alphanumeric
0271+  066C B9 2E       	cmp al, $2E				; check if is '.'
0272+  066E C6 64 06    	je is_alphanumeric
0273+  0671 19 00       	mov al, 0
0274+  0673 F7          	stosb
0275+  0674 19 00       	mov al, TOKTYP_IDENTIFIER
0276+  0676 3D F4 06    	mov [toktyp], al
0277+  0679 D5 01 00    	sub si, 1
0278+  067C 4E          	mov a, si
0279+  067D 42 F2 06    	mov [prog], a		; update pointer
0280+  0680             get_token_return:
0281+  0680 F0          	pop di
0282+  0681 EF          	pop si
0283+  0682 E7          	pop d
0284+  0683 E4          	pop a
0285+  0684 09          	ret
0286+  0685             get_tok_comment:
0287+  0685 F6          	lodsb
0288+  0686 B9 0A       	cmp al, $0A			; new line
0289+  0688 C7 85 06    	jne get_tok_comment
0290+  068B 0A 69 05    	jmp get_tok_skip_spaces
0291+  068E             
0292+  068E             
0293+  068E             get_number:
0294+  068E D7          	push a
0295+  068F DA          	push d
0296+  0690 E2          	push si
0297+  0691 E3          	push di
0298+  0692 19 00       	mov al, 0
0299+  0694 3D F6 06    	mov [tokstr], al			; nullify tokstr string
0300+  0697 19 00       	mov al, TOK_NULL
0301+  0699 3D F5 06    	mov [tok], al				; nullify token
0302+  069C 14 F2 06    	mov a, [prog]
0303+  069F 4D          	mov si, a
0304+  06A0 FD 4F F6 06 	mov di, tokstr
0305+  06A4             get_number_skip_spaces:
0306+  06A4 F6          	lodsb
0307+  06A5 07 E8 0B    	call isspace
0308+  06A8 C6 A4 06    	je get_number_skip_spaces
0309+  06AB B9 00       	cmp al, 0			; check for end of input (NULL)
0310+  06AD C7 BD 06    	jne get_number_L0
0311+  06B0 19 14       	mov al, TOK_END
0312+  06B2 3D F5 06    	mov [tok], al
0313+  06B5 19 06       	mov al, TOKTYP_END
0314+  06B7 3D F4 06    	mov [toktyp], al
0315+  06BA 0A D4 06    	jmp get_number_return
0316+  06BD             get_number_L0:
0317+  06BD F7          	stosb
0318+  06BE F6          	lodsb
0319+  06BF 07 7C 0B    	call isdigit			;check if is numeric
0320+  06C2 C6 BD 06    	jz get_number_L0
0321+  06C5 19 00       	mov al, 0
0322+  06C7 F7          	stosb
0323+  06C8 19 05       	mov al, TOKTYP_NUMERIC
0324+  06CA 3D F4 06    	mov [toktyp], al
0325+  06CD D5 01 00    	sub si, 1
0326+  06D0 4E          	mov a, si
0327+  06D1 42 F2 06    	mov [prog], a		; update pointer
0328+  06D4             get_number_return:
0329+  06D4 F0          	pop di
0330+  06D5 EF          	pop si
0331+  06D6 E7          	pop d
0332+  06D7 E4          	pop a
0333+  06D8 09          	ret
0334+  06D9             
0335+  06D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  06D9             ;; PUT BACK TOKEN
0337+  06D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
0338+  06D9             putback:
0339+  06D9 D7          	push a
0340+  06DA E2          	push si
0341+  06DB FD 4D F6 06 	mov si, tokstr	
0342+  06DF             putback_loop:
0343+  06DF F6          	lodsb
0344+  06E0 B9 00       	cmp al, 0
0345+  06E2 C6 EF 06    	je putback_end
0346+  06E5 14 F2 06    	mov a, [prog]
0347+  06E8 7D          	dec a
0348+  06E9 42 F2 06    	mov [prog], a			; update pointer
0349+  06EC 0A DF 06    	jmp putback_loop
0350+  06EF             putback_end:
0351+  06EF EF          	pop si
0352+  06F0 E4          	pop a
0353+  06F1 09          	ret
0354+  06F2             
0355+  06F2             
0356+  06F2             
0357+  06F2             
0358+  06F2 00 00       prog:		.dw 0			; pointer to current position in buffer
0359+  06F4             
0360+  06F4 00          toktyp: 	.db 0			; token type symbol
0361+  06F5 00          tok:		.db 0			; current token symbol
0362+  06F6 00 00 00 00 tokstr:		.fill 256, 0	; token as a string
0362+  06FA 00 00 00 00 
0362+  06FE 00 00 00 00 
0362+  0702 00 00 00 00 
0362+  0706 00 00 00 00 
0362+  070A 00 00 00 00 
0362+  070E 00 00 00 00 
0362+  0712 00 00 00 00 
0362+  0716 00 00 00 00 
0362+  071A 00 00 00 00 
0362+  071E 00 00 00 00 
0362+  0722 00 00 00 00 
0362+  0726 00 00 00 00 
0362+  072A 00 00 00 00 
0362+  072E 00 00 00 00 
0362+  0732 00 00 00 00 
0362+  0736 00 00 00 00 
0362+  073A 00 00 00 00 
0362+  073E 00 00 00 00 
0362+  0742 00 00 00 00 
0362+  0746 00 00 00 00 
0362+  074A 00 00 00 00 
0362+  074E 00 00 00 00 
0362+  0752 00 00 00 00 
0362+  0756 00 00 00 00 
0362+  075A 00 00 00 00 
0362+  075E 00 00 00 00 
0362+  0762 00 00 00 00 
0362+  0766 00 00 00 00 
0362+  076A 00 00 00 00 
0362+  076E 00 00 00 00 
0362+  0772 00 00 00 00 
0362+  0776 00 00 00 00 
0362+  077A 00 00 00 00 
0362+  077E 00 00 00 00 
0362+  0782 00 00 00 00 
0362+  0786 00 00 00 00 
0362+  078A 00 00 00 00 
0362+  078E 00 00 00 00 
0362+  0792 00 00 00 00 
0362+  0796 00 00 00 00 
0362+  079A 00 00 00 00 
0362+  079E 00 00 00 00 
0362+  07A2 00 00 00 00 
0362+  07A6 00 00 00 00 
0362+  07AA 00 00 00 00 
0362+  07AE 00 00 00 00 
0362+  07B2 00 00 00 00 
0362+  07B6 00 00 00 00 
0362+  07BA 00 00 00 00 
0362+  07BE 00 00 00 00 
0362+  07C2 00 00 00 00 
0362+  07C6 00 00 00 00 
0362+  07CA 00 00 00 00 
0362+  07CE 00 00 00 00 
0362+  07D2 00 00 00 00 
0362+  07D6 00 00 00 00 
0362+  07DA 00 00 00 00 
0362+  07DE 00 00 00 00 
0362+  07E2 00 00 00 00 
0362+  07E6 00 00 00 00 
0362+  07EA 00 00 00 00 
0362+  07EE 00 00 00 00 
0362+  07F2 00 00 00 00 
0083   07F6             .include "stdio.asm"
0001+  07F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  07F6             ; stdio.s
0003+  07F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  07F6             .include "string.asm"
0001++ 07F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 07F6             ; string.s
0003++ 07F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 07F6             
0005++ 07F6             
0006++ 07F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 07F6             ; strrev
0008++ 07F6             ; reverse a string
0009++ 07F6             ; D = string address
0010++ 07F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 07F6             ; 01234
0012++ 07F6             strrev:
0013++ 07F6 4B          	pusha
0014++ 07F7 07 3D 08    	call strlen	; length in C
0015++ 07FA 12          	mov a, c
0016++ 07FB AF 01 00    	cmp a, 1
0017++ 07FE D0 18 08    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0801 7D          	dec a
0019++ 0802 FD 4E       	mov si, d	; beginning of string
0020++ 0804 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0806 59          	add d, a	; end of string
0022++ 0807 12          	mov a, c
0023++ 0808 FD 9B       	shr a		; divide by 2
0024++ 080A 39          	mov c, a	; C now counts the steps
0025++ 080B             strrev_L0:
0026++ 080B 32          	mov bl, [d]	; save load right-side char into BL
0027++ 080C F6          	lodsb		; load left-side char into AL; increase SI
0028++ 080D 3E          	mov [d], al	; store left char into right side
0029++ 080E 1B          	mov al, bl
0030++ 080F F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0810 7E          	dec c
0032++ 0811 7F          	dec d
0033++ 0812 C2 00 00    	cmp c, 0
0034++ 0815 C7 0B 08    	jne strrev_L0
0035++ 0818             strrev_end:
0036++ 0818 4C          	popa
0037++ 0819 09          	ret
0038++ 081A             	
0039++ 081A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 081A             ; strchr
0041++ 081A             ; search string in D for char in AL
0042++ 081A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 081A             strchr:
0044++ 081A             strchr_L0:
0045++ 081A 32          	mov bl, [d]
0046++ 081B C1 00       	cmp bl, 0
0047++ 081D C6 28 08    	je strchr_end
0048++ 0820 BA          	cmp al, bl
0049++ 0821 C6 28 08    	je strchr_end
0050++ 0824 79          	inc d
0051++ 0825 0A 1A 08    	jmp strchr_L0
0052++ 0828             strchr_end:
0053++ 0828 1B          	mov al, bl
0054++ 0829 09          	ret
0055++ 082A             
0056++ 082A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 082A             ; strstr
0058++ 082A             ; find sub-string
0059++ 082A             ; str1 in SI
0060++ 082A             ; str2 in DI
0061++ 082A             ; SI points to end of source string
0062++ 082A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 082A             strstr:
0064++ 082A DB          	push al
0065++ 082B DA          	push d
0066++ 082C E3          	push di
0067++ 082D             strstr_loop:
0068++ 082D F3          	cmpsb					; compare a byte of the strings
0069++ 082E C7 39 08    	jne strstr_ret
0070++ 0831 FC 00 00    	lea d, [di + 0]
0071++ 0834 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0836 C7 2D 08    	jne strstr_loop				; equal chars but not at end
0073++ 0839             strstr_ret:
0074++ 0839 F0          	pop di
0075++ 083A E7          	pop d
0076++ 083B E8          	pop al
0077++ 083C 09          	ret
0078++ 083D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 083D             ; length of null terminated string
0080++ 083D             ; result in C
0081++ 083D             ; pointer in D
0082++ 083D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 083D             strlen:
0084++ 083D DA          	push d
0085++ 083E 38 00 00    	mov c, 0
0086++ 0841             strlen_L1:
0087++ 0841 BD 00       	cmp byte [d], 0
0088++ 0843 C6 4B 08    	je strlen_ret
0089++ 0846 79          	inc d
0090++ 0847 78          	inc c
0091++ 0848 0A 41 08    	jmp strlen_L1
0092++ 084B             strlen_ret:
0093++ 084B E7          	pop d
0094++ 084C 09          	ret
0095++ 084D             
0096++ 084D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 084D             ; STRCMP
0098++ 084D             ; compare two strings
0099++ 084D             ; str1 in SI
0100++ 084D             ; str2 in DI
0101++ 084D             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 084D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 084D             strcmp:
0104++ 084D DB          	push al
0105++ 084E DA          	push d
0106++ 084F E3          	push di
0107++ 0850 E2          	push si
0108++ 0851             strcmp_loop:
0109++ 0851 F3          	cmpsb					; compare a byte of the strings
0110++ 0852 C7 5D 08    	jne strcmp_ret
0111++ 0855 FB FF FF    	lea d, [si +- 1]
0112++ 0858 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 085A C7 51 08    	jne strcmp_loop				; equal chars but not at end
0114++ 085D             strcmp_ret:
0115++ 085D EF          	pop si
0116++ 085E F0          	pop di
0117++ 085F E7          	pop d
0118++ 0860 E8          	pop al
0119++ 0861 09          	ret
0120++ 0862             
0121++ 0862             
0122++ 0862             ; STRCPY
0123++ 0862             ; copy null terminated string from SI to DI
0124++ 0862             ; source in SI
0125++ 0862             ; destination in DI
0126++ 0862             strcpy:
0127++ 0862 E2          	push si
0128++ 0863 E3          	push di
0129++ 0864 DB          	push al
0130++ 0865             strcpy_L1:
0131++ 0865 F6          	lodsb
0132++ 0866 F7          	stosb
0133++ 0867 B9 00       	cmp al, 0
0134++ 0869 C7 65 08    	jne strcpy_L1
0135++ 086C             strcpy_end:
0136++ 086C E8          	pop al
0137++ 086D F0          	pop di
0138++ 086E EF          	pop si
0139++ 086F 09          	ret
0140++ 0870             
0141++ 0870             ; STRCAT
0142++ 0870             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0870             ; source in SI
0144++ 0870             ; destination in DI
0145++ 0870             strcat:
0146++ 0870 E2          	push si
0147++ 0871 E3          	push di
0148++ 0872 D7          	push a
0149++ 0873 DA          	push d
0150++ 0874 50          	mov a, di
0151++ 0875 3C          	mov d, a
0152++ 0876             strcat_goto_end_L1:
0153++ 0876 BD 00       	cmp byte[d], 0
0154++ 0878 C6 7F 08    	je strcat_start
0155++ 087B 79          	inc d
0156++ 087C 0A 76 08    	jmp strcat_goto_end_L1
0157++ 087F             strcat_start:
0158++ 087F FD 50       	mov di, d
0159++ 0881             strcat_L1:
0160++ 0881 F6          	lodsb
0161++ 0882 F7          	stosb
0162++ 0883 B9 00       	cmp al, 0
0163++ 0885 C7 81 08    	jne strcat_L1
0164++ 0888             strcat_end:
0165++ 0888 E7          	pop d
0166++ 0889 E4          	pop a
0167++ 088A F0          	pop di
0168++ 088B EF          	pop si
0169++ 088C 09          	ret
0005+  088D             
0006+  088D 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  0891 34 35 36 37 
0006+  0895 38 39 41 42 
0006+  0899 43 44 45 46 
0007+  089D             
0008+  089D 01 00       table_power:.dw 1
0009+  089F 0A 00       			.dw 10
0010+  08A1 64 00       			.dw 100
0011+  08A3 E8 03       			.dw 1000
0012+  08A5 10 27       			.dw 10000
0013+  08A7             
0014+  08A7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0015+  08A7             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0016+  08A7             ; ASCII in BL
0017+  08A7             ; result in AL
0018+  08A7             ; ascii for F = 0100 0110
0019+  08A7             ; ascii for 9 = 0011 1001
0020+  08A7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0021+  08A7             hex_ascii_encode:
0022+  08A7 1B          	mov al, bl
0023+  08A8 93 40       	test al, $40				; test if letter or number
0024+  08AA C7 B0 08    	jnz hex_letter
0025+  08AD 87 0F       	and al, $0F				; get number
0026+  08AF 09          	ret
0027+  08B0             hex_letter:
0028+  08B0 87 0F       	and al, $0F				; get letter
0029+  08B2 6A 09       	add al, 9
0030+  08B4 09          	ret
0031+  08B5             
0032+  08B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0033+  08B5             ; ATOI
0034+  08B5             ; 2 letter hex string in B
0035+  08B5             ; 8bit integer returned in AL
0036+  08B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0037+  08B5             atoi:
0038+  08B5 D8          	push b
0039+  08B6 07 A7 08    	call hex_ascii_encode			; convert BL to 4bit code in AL
0040+  08B9 30          	mov bl, bh
0041+  08BA DB          	push al					; save a
0042+  08BB 07 A7 08    	call hex_ascii_encode
0043+  08BE EA          	pop bl	
0044+  08BF FD 9E 04    	shl al, 4
0045+  08C2 8C          	or al, bl
0046+  08C3 E5          	pop b
0047+  08C4 09          	ret	
0048+  08C5             
0049+  08C5             
0050+  08C5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  08C5             ; printf
0052+  08C5             ; no need for explanations!
0053+  08C5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0054+  08C5             printf:
0055+  08C5 09          	ret
0056+  08C6             
0057+  08C6             
0058+  08C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  08C6             ; scanf
0060+  08C6             ; no need for explanations!
0061+  08C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  08C6             scanf:
0063+  08C6 09          	ret
0064+  08C7             
0065+  08C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  08C7             ; ITOA
0067+  08C7             ; 8bit value in BL
0068+  08C7             ; 2 byte ASCII result in A
0069+  08C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0070+  08C7             itoa:
0071+  08C7 DA          	push d
0072+  08C8 D8          	push b
0073+  08C9 A7 00       	mov bh, 0
0074+  08CB FD A4 04    	shr bl, 4	
0075+  08CE 74          	mov d, b
0076+  08CF 1F 8D 08    	mov al, [d + s_hex_digits]
0077+  08D2 23          	mov ah, al
0078+  08D3             	
0079+  08D3 E5          	pop b
0080+  08D4 D8          	push b
0081+  08D5 A7 00       	mov bh, 0
0082+  08D7 FD 87 0F    	and bl, $0F
0083+  08DA 74          	mov d, b
0084+  08DB 1F 8D 08    	mov al, [d + s_hex_digits]
0085+  08DE E5          	pop b
0086+  08DF E7          	pop d
0087+  08E0 09          	ret
0088+  08E1             
0089+  08E1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0090+  08E1             ; HEX STRING TO BINARY
0091+  08E1             ; di = destination address
0092+  08E1             ; si = source
0093+  08E1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0094+  08E1             hex_to_int:
0095+  08E1             hex_to_int_L1:
0096+  08E1 F6          	lodsb					; load from [SI] to AL
0097+  08E2 B9 00       	cmp al, 0				; check if ASCII 0
0098+  08E4 C6 F1 08    	jz hex_to_int_ret
0099+  08E7 36          	mov bh, al
0100+  08E8 F6          	lodsb
0101+  08E9 2F          	mov bl, al
0102+  08EA 07 B5 08    	call atoi				; convert ASCII byte in B to int (to AL)
0103+  08ED F7          	stosb					; store AL to [DI]
0104+  08EE 0A E1 08    	jmp hex_to_int_L1
0105+  08F1             hex_to_int_ret:
0106+  08F1 09          	ret		
0107+  08F2             
0108+  08F2             
0109+  08F2             
0110+  08F2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  08F2             ; GETCHAR
0112+  08F2             ; char in ah
0113+  08F2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0114+  08F2             getchar:
0115+  08F2 DB          	push al
0116+  08F3             getchar_retry:
0117+  08F3 FD 0C       	sti
0118+  08F5 19 01       	mov al, 1
0119+  08F7 05 03       	syscall sys_io			; receive in AH
0120+  08F9 B9 00       	cmp al, 0			; check if any char was receive
0121+  08FB C6 F3 08    	je getchar_retry
0122+  08FE E8          	pop al
0123+  08FF 09          	ret
0124+  0900             
0125+  0900             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0126+  0900             ; PUTCHAR
0127+  0900             ; char in ah
0128+  0900             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  0900             putchar:
0130+  0900 D7          	push a
0131+  0901 19 00       	mov al, 0
0132+  0903 05 03       	syscall sys_io			; char in AH
0133+  0905 E4          	pop a
0134+  0906 09          	ret
0135+  0907             
0136+  0907             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0137+  0907             ;; INPUT A STRING
0138+  0907             ;; terminates with null
0139+  0907             ;; pointer in D
0140+  0907             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  0907             gets:
0142+  0907 D7          	push a
0143+  0908 DA          	push d
0144+  0909             gets_loop:
0145+  0909 FD 0C       	sti
0146+  090B 19 01       	mov al, 1
0147+  090D 05 03       	syscall sys_io			; receive in AH
0148+  090F B9 00       	cmp al, 0				; check error code (AL)
0149+  0911 C6 09 09    	je gets_loop			; if no char received, retry
0150+  0914             
0151+  0914 76 1B       	cmp ah, 27
0152+  0916 C6 37 09    	je gets_telnet_escape
0153+  0919 76 0A       	cmp ah, $0A				; LF
0154+  091B C6 90 09    	je gets_end
0155+  091E 76 0D       	cmp ah, $0D				; CR
0156+  0920 C6 90 09    	je gets_end
0157+  0923 76 5C       	cmp ah, $5C				; '\\'
0158+  0925 C6 67 09    	je gets_escape
0159+  0928             	
0160+  0928 76 08       	cmp ah, $08			; check for backspace
0161+  092A C6 33 09    	je gets_backspace
0162+  092D             
0163+  092D 1A          	mov al, ah
0164+  092E 3E          	mov [d], al
0165+  092F 79          	inc d
0166+  0930 0A 09 09    	jmp gets_loop
0167+  0933             gets_backspace:
0168+  0933 7F          	dec d
0169+  0934 0A 09 09    	jmp gets_loop
0170+  0937             gets_telnet_escape:
0171+  0937 FD 0C       	sti
0172+  0939 19 01       	mov al, 1
0173+  093B 05 03       	syscall sys_io				; receive in AH without echo
0174+  093D B9 00       	cmp al, 0					; check error code (AL)
0175+  093F C6 37 09    	je gets_telnet_escape		; if no char received, retry
0176+  0942 76 5B       	cmp ah, '['
0177+  0944 C7 09 09    	jne gets_loop
0178+  0947             gets_telnet_escape_phase2:
0179+  0947 FD 0C       	sti
0180+  0949 19 01       	mov al, 1
0181+  094B 05 03       	syscall sys_io					; receive in AH without echo
0182+  094D B9 00       	cmp al, 0						; check error code (AL)
0183+  094F C6 47 09    	je gets_telnet_escape_phase2	; if no char received, retry
0184+  0952 76 44       	cmp ah, 'D'
0185+  0954 C6 5F 09    	je gets_left_arrow
0186+  0957 76 43       	cmp ah, 'C'
0187+  0959 C6 63 09    	je gets_right_arrow
0188+  095C 0A 09 09    	jmp gets_loop
0189+  095F             gets_left_arrow:
0190+  095F 7F          	dec d
0191+  0960 0A 09 09    	jmp gets_loop
0192+  0963             gets_right_arrow:
0193+  0963 79          	inc d
0194+  0964 0A 09 09    	jmp gets_loop
0195+  0967             gets_escape:
0196+  0967 FD 0C       	sti
0197+  0969 19 01       	mov al, 1
0198+  096B 05 03       	syscall sys_io			; receive in AH
0199+  096D B9 00       	cmp al, 0				; check error code (AL)
0200+  096F C6 67 09    	je gets_escape			; if no char received, retry
0201+  0972 76 6E       	cmp ah, 'n'
0202+  0974 C6 82 09    	je gets_LF
0203+  0977 76 72       	cmp ah, 'r'
0204+  0979 C6 89 09    	je gets_CR
0205+  097C 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0206+  097D 3E          	mov [d], al
0207+  097E 79          	inc d
0208+  097F 0A 09 09    	jmp gets_loop
0209+  0982             gets_LF:
0210+  0982 19 0A       	mov al, $0A
0211+  0984 3E          	mov [d], al
0212+  0985 79          	inc d
0213+  0986 0A 09 09    	jmp gets_loop
0214+  0989             gets_CR:
0215+  0989 19 0D       	mov al, $0D
0216+  098B 3E          	mov [d], al
0217+  098C 79          	inc d
0218+  098D 0A 09 09    	jmp gets_loop
0219+  0990             gets_end:
0220+  0990 19 00       	mov al, 0
0221+  0992 3E          	mov [d], al				; terminate string
0222+  0993 E7          	pop d
0223+  0994 E4          	pop a
0224+  0995 09          	ret
0225+  0996             
0226+  0996             
0227+  0996             
0228+  0996             
0229+  0996             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0230+  0996             ;; INPUT TEXT
0231+  0996             ;; terminated with CTRL+D
0232+  0996             ;; pointer in D
0233+  0996             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0234+  0996             gettxt:
0235+  0996 D7          	push a
0236+  0997 DA          	push d
0237+  0998             gettxt_loop:
0238+  0998 19 01       	mov al, 1
0239+  099A 05 03       	syscall sys_io			; receive in AH
0240+  099C B9 00       	cmp al, 0				; check error code (AL)
0241+  099E C6 98 09    	je gettxt_loop		; if no char received, retry
0242+  09A1 76 04       	cmp ah, 4			; EOT
0243+  09A3 C6 E1 09    	je gettxt_end
0244+  09A6 76 08       	cmp ah, $08			; check for backspace
0245+  09A8 C6 DD 09    	je gettxt_backspace
0246+  09AB 76 5C       	cmp ah, $5C				; '\\'
0247+  09AD C6 B6 09    	je gettxt_escape
0248+  09B0 1A          	mov al, ah
0249+  09B1 3E          	mov [d], al
0250+  09B2 79          	inc d
0251+  09B3 0A 98 09    	jmp gettxt_loop
0252+  09B6             gettxt_escape:
0253+  09B6 19 01       	mov al, 1
0254+  09B8 05 03       	syscall sys_io			; receive in AH
0255+  09BA B9 00       	cmp al, 0				; check error code (AL)
0256+  09BC C6 B6 09    	je gettxt_escape		; if no char received, retry
0257+  09BF 76 6E       	cmp ah, 'n'
0258+  09C1 C6 CF 09    	je gettxt_LF
0259+  09C4 76 72       	cmp ah, 'r'
0260+  09C6 C6 D6 09    	je gettxt_CR
0261+  09C9 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0262+  09CA 3E          	mov [d], al
0263+  09CB 79          	inc d
0264+  09CC 0A 98 09    	jmp gettxt_loop
0265+  09CF             gettxt_LF:
0266+  09CF 19 0A       	mov al, $0A
0267+  09D1 3E          	mov [d], al
0268+  09D2 79          	inc d
0269+  09D3 0A 98 09    	jmp gettxt_loop
0270+  09D6             gettxt_CR:
0271+  09D6 19 0D       	mov al, $0D
0272+  09D8 3E          	mov [d], al
0273+  09D9 79          	inc d
0274+  09DA 0A 98 09    	jmp gettxt_loop
0275+  09DD             gettxt_backspace:
0276+  09DD 7F          	dec d
0277+  09DE 0A 98 09    	jmp gettxt_loop
0278+  09E1             gettxt_end:
0279+  09E1 19 00       	mov al, 0
0280+  09E3 3E          	mov [d], al				; terminate string
0281+  09E4 E7          	pop d
0282+  09E5 E4          	pop a
0283+  09E6 09          	ret
0284+  09E7             
0285+  09E7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0286+  09E7             ; PRINT NEW LINE
0287+  09E7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  09E7             printnl:
0289+  09E7 D7          	push a
0290+  09E8 10 00 0A    	mov a, $0A00
0291+  09EB 05 03       	syscall sys_io
0292+  09ED 10 00 0D    	mov a, $0D00
0293+  09F0 05 03       	syscall sys_io
0294+  09F2 E4          	pop a
0295+  09F3 09          	ret
0296+  09F4             
0297+  09F4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0298+  09F4             ; strtoint
0299+  09F4             ; 4 digit hex string number in d
0300+  09F4             ; integer returned in A
0301+  09F4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0302+  09F4             strtointx:
0303+  09F4 D8          	push b
0304+  09F5 32          	mov bl, [d]
0305+  09F6 37          	mov bh, bl
0306+  09F7 33 01 00    	mov bl, [d + 1]
0307+  09FA 07 B5 08    	call atoi				; convert to int in AL
0308+  09FD 23          	mov ah, al				; move to AH
0309+  09FE 33 02 00    	mov bl, [d + 2]
0310+  0A01 37          	mov bh, bl
0311+  0A02 33 03 00    	mov bl, [d + 3]
0312+  0A05 07 B5 08    	call atoi				; convert to int in AL
0313+  0A08 E5          	pop b
0314+  0A09 09          	ret
0315+  0A0A             
0316+  0A0A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0317+  0A0A             ; strtoint
0318+  0A0A             ; 5 digit base10 string number in d
0319+  0A0A             ; integer returned in A
0320+  0A0A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0321+  0A0A             strtoint:
0322+  0A0A E2          	push si
0323+  0A0B D8          	push b
0324+  0A0C D9          	push c
0325+  0A0D DA          	push d
0326+  0A0E 07 3D 08    	call strlen			; get string length in C
0327+  0A11 7E          	dec c
0328+  0A12 FD 4E       	mov si, d
0329+  0A14 12          	mov a, c
0330+  0A15 FD 99       	shl a
0331+  0A17 3B 9D 08    	mov d, table_power
0332+  0A1A 59          	add d, a
0333+  0A1B 38 00 00    	mov c, 0
0334+  0A1E             strtoint_L0:
0335+  0A1E F6          	lodsb			; load ASCII to al
0336+  0A1F B9 00       	cmp al, 0
0337+  0A21 C6 34 0A    	je strtoint_end
0338+  0A24 6F 30       	sub al, $30		; make into integer
0339+  0A26 22 00       	mov ah, 0
0340+  0A28 2A          	mov b, [d]
0341+  0A29 AC          	mul a, b			; result in B since it fits in 16bits
0342+  0A2A 11          	mov a, b
0343+  0A2B 28          	mov b, c
0344+  0A2C 54          	add a, b
0345+  0A2D 39          	mov c, a
0346+  0A2E 63 02 00    	sub d, 2
0347+  0A31 0A 1E 0A    	jmp strtoint_L0
0348+  0A34             strtoint_end:
0349+  0A34 12          	mov a, c
0350+  0A35 E7          	pop d
0351+  0A36 E6          	pop c
0352+  0A37 E5          	pop b
0353+  0A38 EF          	pop si
0354+  0A39 09          	ret
0355+  0A3A             
0356+  0A3A             
0357+  0A3A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0358+  0A3A             ; PRINT NULL TERMINATED STRING
0359+  0A3A             ; pointer in D
0360+  0A3A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0361+  0A3A             puts:
0362+  0A3A D7          	push a
0363+  0A3B DA          	push d
0364+  0A3C             puts_L1:
0365+  0A3C 1E          	mov al, [d]
0366+  0A3D B9 00       	cmp al, 0
0367+  0A3F C6 4B 0A    	jz puts_END
0368+  0A42 23          	mov ah, al
0369+  0A43 19 00       	mov al, 0
0370+  0A45 05 03       	syscall sys_io
0371+  0A47 79          	inc d
0372+  0A48 0A 3C 0A    	jmp puts_L1
0373+  0A4B             puts_END:
0374+  0A4B E7          	pop d
0375+  0A4C E4          	pop a
0376+  0A4D 09          	ret
0377+  0A4E             
0378+  0A4E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  0A4E             ; PRINT N SIZE STRING
0380+  0A4E             ; pointer in D
0381+  0A4E             ; size in C
0382+  0A4E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0383+  0A4E             putsn:
0384+  0A4E DB          	push al
0385+  0A4F DA          	push d
0386+  0A50 D9          	push c
0387+  0A51             putsn_L0:
0388+  0A51 1E          	mov al, [d]
0389+  0A52 23          	mov ah, al
0390+  0A53 19 00       	mov al, 0
0391+  0A55 05 03       	syscall sys_io
0392+  0A57 79          	inc d
0393+  0A58 7E          	dec c	
0394+  0A59 C2 00 00    	cmp c, 0
0395+  0A5C C7 51 0A    	jne putsn_L0
0396+  0A5F             putsn_end:
0397+  0A5F E6          	pop c
0398+  0A60 E7          	pop d
0399+  0A61 E8          	pop al
0400+  0A62 09          	ret
0401+  0A63             
0402+  0A63             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0403+  0A63             ; print 16bit decimal number
0404+  0A63             ; input number in A
0405+  0A63             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  0A63             print_u16d:
0407+  0A63 D7          	push a
0408+  0A64 D8          	push b
0409+  0A65 26 10 27    	mov b, 10000
0410+  0A68 AE          	div a, b			; get 10000 coeff.
0411+  0A69 07 8F 0A    	call print_number
0412+  0A6C 11          	mov a, b
0413+  0A6D 26 E8 03    	mov b, 1000
0414+  0A70 AE          	div a, b			; get 10000 coeff.
0415+  0A71 07 8F 0A    	call print_number
0416+  0A74 11          	mov a, b
0417+  0A75 26 64 00    	mov b, 100
0418+  0A78 AE          	div a, b
0419+  0A79 07 8F 0A    	call print_number
0420+  0A7C 11          	mov a, b
0421+  0A7D 26 0A 00    	mov b, 10
0422+  0A80 AE          	div a, b
0423+  0A81 07 8F 0A    	call print_number
0424+  0A84 11          	mov a, b
0425+  0A85 6A 30       	add al, $30
0426+  0A87 23          	mov ah, al
0427+  0A88 19 00       	mov al, 0
0428+  0A8A 05 03       	syscall sys_io	; print coeff
0429+  0A8C E5          	pop b
0430+  0A8D E4          	pop a
0431+  0A8E 09          	ret
0432+  0A8F             
0433+  0A8F             
0434+  0A8F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0435+  0A8F             ; if A == 0, print space
0436+  0A8F             ; else print A
0437+  0A8F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0438+  0A8F             print_number:
0439+  0A8F 6A 30       	add al, $30
0440+  0A91 23          	mov ah, al
0441+  0A92 07 00 09    	call putchar
0442+  0A95 09          	ret
0443+  0A96             
0444+  0A96             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  0A96             ; PRINT 16BIT HEX INTEGER
0446+  0A96             ; integer value in reg B
0447+  0A96             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  0A96             print_u16x:
0449+  0A96 D7          	push a
0450+  0A97 D8          	push b
0451+  0A98 DD          	push bl
0452+  0A99 30          	mov bl, bh
0453+  0A9A 07 C7 08    	call itoa				; convert bh to char in A
0454+  0A9D 2F          	mov bl, al				; save al
0455+  0A9E 19 00       	mov al, 0
0456+  0AA0 05 03       	syscall sys_io				; display AH
0457+  0AA2 24          	mov ah, bl				; retrieve al
0458+  0AA3 19 00       	mov al, 0
0459+  0AA5 05 03       	syscall sys_io				; display AL
0460+  0AA7             
0461+  0AA7 EA          	pop bl
0462+  0AA8 07 C7 08    	call itoa				; convert bh to char in A
0463+  0AAB 2F          	mov bl, al				; save al
0464+  0AAC 19 00       	mov al, 0
0465+  0AAE 05 03       	syscall sys_io				; display AH
0466+  0AB0 24          	mov ah, bl				; retrieve al
0467+  0AB1 19 00       	mov al, 0
0468+  0AB3 05 03       	syscall sys_io				; display AL
0469+  0AB5             
0470+  0AB5 E5          	pop b
0471+  0AB6 E4          	pop a
0472+  0AB7 09          	ret
0473+  0AB8             
0474+  0AB8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0475+  0AB8             ; INPUT 16BIT HEX INTEGER
0476+  0AB8             ; read 16bit integer into A
0477+  0AB8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0478+  0AB8             scan_u16x:
0479+  0AB8 F8 10 00    	enter 16
0480+  0ABB D8          	push b
0481+  0ABC DA          	push d
0482+  0ABD             
0483+  0ABD FA F1 FF    	lea d, [bp + -15]
0484+  0AC0 07 07 09    	call gets				; get number
0485+  0AC3             
0486+  0AC3 32          	mov bl, [d]
0487+  0AC4 37          	mov bh, bl
0488+  0AC5 33 01 00    	mov bl, [d + 1]
0489+  0AC8 07 B5 08    	call atoi				; convert to int in AL
0490+  0ACB 23          	mov ah, al				; move to AH
0491+  0ACC             
0492+  0ACC 33 02 00    	mov bl, [d + 2]
0493+  0ACF 37          	mov bh, bl
0494+  0AD0 33 03 00    	mov bl, [d + 3]
0495+  0AD3 07 B5 08    	call atoi				; convert to int in AL
0496+  0AD6             
0497+  0AD6 E7          	pop d
0498+  0AD7 E5          	pop b
0499+  0AD8 F9          	leave
0500+  0AD9 09          	ret
0501+  0ADA             
0502+  0ADA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0503+  0ADA             ; PRINT 8bit HEX INTEGER
0504+  0ADA             ; integer value in reg bl
0505+  0ADA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0506+  0ADA             print_u8x:
0507+  0ADA D7          	push a
0508+  0ADB DD          	push bl
0509+  0ADC             
0510+  0ADC 07 C7 08    	call itoa				; convert bl to char in A
0511+  0ADF 2F          	mov bl, al				; save al
0512+  0AE0 19 00       	mov al, 0
0513+  0AE2 05 03       	syscall sys_io				; display AH
0514+  0AE4 24          	mov ah, bl				; retrieve al
0515+  0AE5 19 00       	mov al, 0
0516+  0AE7 05 03       	syscall sys_io				; display AL
0517+  0AE9             
0518+  0AE9 EA          	pop bl
0519+  0AEA E4          	pop a
0520+  0AEB 09          	ret
0521+  0AEC             
0522+  0AEC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0523+  0AEC             ; print 8bit decimal unsigned number
0524+  0AEC             ; input number in AL
0525+  0AEC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0526+  0AEC             print_u8d:
0527+  0AEC D7          	push a
0528+  0AED D8          	push b
0529+  0AEE             
0530+  0AEE 22 00       	mov ah, 0
0531+  0AF0 26 64 00    	mov b, 100
0532+  0AF3 AE          	div a, b
0533+  0AF4 D8          	push b			; save remainder
0534+  0AF5 B9 00       	cmp al, 0
0535+  0AF7 C6 01 0B    	je skip100
0536+  0AFA 6A 30       	add al, $30
0537+  0AFC 23          	mov ah, al
0538+  0AFD 19 00       	mov al, 0
0539+  0AFF 05 03       	syscall sys_io	; print coeff
0540+  0B01             skip100:
0541+  0B01 E4          	pop a
0542+  0B02 22 00       	mov ah, 0
0543+  0B04 26 0A 00    	mov b, 10
0544+  0B07 AE          	div a, b
0545+  0B08 D8          	push b			; save remainder
0546+  0B09 B9 00       	cmp al, 0
0547+  0B0B C6 15 0B    	je skip10
0548+  0B0E 6A 30       	add al, $30
0549+  0B10 23          	mov ah, al
0550+  0B11 19 00       	mov al, 0
0551+  0B13 05 03       	syscall sys_io	; print coeff
0552+  0B15             skip10:
0553+  0B15 E4          	pop a
0554+  0B16 1B          	mov al, bl
0555+  0B17 6A 30       	add al, $30
0556+  0B19 23          	mov ah, al
0557+  0B1A 19 00       	mov al, 0
0558+  0B1C 05 03       	syscall sys_io	; print coeff
0559+  0B1E E5          	pop b
0560+  0B1F E4          	pop a
0561+  0B20 09          	ret
0562+  0B21             
0563+  0B21             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0564+  0B21             ; INPUT 8BIT HEX INTEGER
0565+  0B21             ; read 8bit integer into AL
0566+  0B21             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0567+  0B21             scan_u8x:
0568+  0B21 F8 04 00    	enter 4
0569+  0B24 D8          	push b
0570+  0B25 DA          	push d
0571+  0B26             
0572+  0B26 FA FD FF    	lea d, [bp + -3]
0573+  0B29 07 07 09    	call gets				; get number
0574+  0B2C             
0575+  0B2C 32          	mov bl, [d]
0576+  0B2D 37          	mov bh, bl
0577+  0B2E 33 01 00    	mov bl, [d + 1]
0578+  0B31 07 B5 08    	call atoi				; convert to int in AL
0579+  0B34             
0580+  0B34 E7          	pop d
0581+  0B35 E5          	pop b
0582+  0B36 F9          	leave
0583+  0B37 09          	ret
0584+  0B38             
0585+  0B38             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0586+  0B38             ; input decimal number
0587+  0B38             ; result in A
0588+  0B38             ; 655'\0'
0589+  0B38             ; low--------high
0590+  0B38             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0591+  0B38             scan_u16d:
0592+  0B38 F8 08 00    	enter 8
0593+  0B3B E2          	push si
0594+  0B3C D8          	push b
0595+  0B3D D9          	push c
0596+  0B3E DA          	push d
0597+  0B3F FA F9 FF    	lea d, [bp +- 7]
0598+  0B42 07 07 09    	call gets
0599+  0B45 07 3D 08    	call strlen			; get string length in C
0600+  0B48 7E          	dec c
0601+  0B49 FD 4E       	mov si, d
0602+  0B4B 12          	mov a, c
0603+  0B4C FD 99       	shl a
0604+  0B4E 3B 9D 08    	mov d, table_power
0605+  0B51 59          	add d, a
0606+  0B52 38 00 00    	mov c, 0
0607+  0B55             mul_loop:
0608+  0B55 F6          	lodsb			; load ASCII to al
0609+  0B56 B9 00       	cmp al, 0
0610+  0B58 C6 6B 0B    	je mul_exit
0611+  0B5B 6F 30       	sub al, $30		; make into integer
0612+  0B5D 22 00       	mov ah, 0
0613+  0B5F 2A          	mov b, [d]
0614+  0B60 AC          	mul a, b			; result in B since it fits in 16bits
0615+  0B61 11          	mov a, b
0616+  0B62 28          	mov b, c
0617+  0B63 54          	add a, b
0618+  0B64 39          	mov c, a
0619+  0B65 63 02 00    	sub d, 2
0620+  0B68 0A 55 0B    	jmp mul_loop
0621+  0B6B             mul_exit:
0622+  0B6B 12          	mov a, c
0623+  0B6C E7          	pop d
0624+  0B6D E6          	pop c
0625+  0B6E E5          	pop b
0626+  0B6F EF          	pop si
0627+  0B70 F9          	leave
0628+  0B71 09          	ret
0084   0B72             .include "ctype.asm"
0001+  0B72             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0B72             ; ctype.s
0003+  0B72             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0B72             
0005+  0B72             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  0B72             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  0B72             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  0B72             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  0B72             ;; characters are supported.
0010+  0B72             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  0B72             ;; isalnum 
0012+  0B72             ;; isalpha 
0013+  0B72             ;; islower 
0014+  0B72             ;; isupper 
0015+  0B72             ;; isdigit 
0016+  0B72             ;; isxdigit
0017+  0B72             ;; iscntrl 
0018+  0B72             ;; isgraph 
0019+  0B72             ;; isspace 
0020+  0B72             ;; isblank 
0021+  0B72             ;; isprint 
0022+  0B72             ;; ispunct 
0023+  0B72             ;; tolower 
0024+  0B72             ;; toupper
0025+  0B72             
0026+  0B72             
0027+  0B72             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  0B72             ;; IS ALPHANUMERIC
0029+  0B72             ;; sets ZF according with result
0030+  0B72             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  0B72             isalnum:
0032+  0B72 07 8F 0B    	call isalpha
0033+  0B75 C6 7B 0B    	je isalnum_exit
0034+  0B78 07 7C 0B    	call isdigit
0035+  0B7B             isalnum_exit:
0036+  0B7B 09          	ret	
0037+  0B7C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0B7C             ;; IS DIGIT
0039+  0B7C             ;; sets ZF according with result
0040+  0B7C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  0B7C             isdigit:
0042+  0B7C DB          	push al
0043+  0B7D B9 30       	cmp al, '0'
0044+  0B7F C8 8B 0B    	jlu isdigit_false
0045+  0B82 B9 39       	cmp al, '9'
0046+  0B84 D1 8B 0B    	jgu isdigit_false
0047+  0B87 87 00       	and al, 0	; set ZF
0048+  0B89 E8          	pop al
0049+  0B8A 09          	ret
0050+  0B8B             isdigit_false:
0051+  0B8B 8B 01       	or al, 1	; clear ZF
0052+  0B8D E8          	pop al
0053+  0B8E 09          	ret	
0054+  0B8F             	
0055+  0B8F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  0B8F             ;; IS ALPHA
0057+  0B8F             ;; sets ZF according with result
0058+  0B8F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  0B8F             isalpha:
0060+  0B8F DB          	push al
0061+  0B90 B9 5F       	cmp al, '_'
0062+  0B92 C6 B2 0B    	je isalpha_true
0063+  0B95 B9 2E       	cmp al, '.'
0064+  0B97 C6 B2 0B    	je isalpha_true
0065+  0B9A B9 41       	cmp al, 'A'
0066+  0B9C C8 AE 0B    	jlu isalpha_false
0067+  0B9F B9 7A       	cmp al, 'z'
0068+  0BA1 D1 AE 0B    	jgu isalpha_false
0069+  0BA4 B9 5A       	cmp al, 'Z'
0070+  0BA6 D0 B2 0B    	jleu isalpha_true
0071+  0BA9 B9 61       	cmp al, 'a'
0072+  0BAB C9 B2 0B    	jgeu isalpha_true
0073+  0BAE             isalpha_false:
0074+  0BAE 8B 01       	or al, 1	; clear ZF
0075+  0BB0 E8          	pop al
0076+  0BB1 09          	ret
0077+  0BB2             isalpha_true:
0078+  0BB2 87 00       	and al, 0	; set ZF
0079+  0BB4 E8          	pop al
0080+  0BB5 09          	ret
0081+  0BB6             
0082+  0BB6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  0BB6             ;; IS PATH-ALPHA
0084+  0BB6             ;; sets ZF according with result
0085+  0BB6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  0BB6             ispath:
0087+  0BB6 DB          	push al
0088+  0BB7 07 7C 0B    	call isdigit
0089+  0BBA C6 E4 0B    	je ispath_true
0090+  0BBD B9 5F       	cmp al, '_'
0091+  0BBF C6 E4 0B    	je ispath_true
0092+  0BC2 B9 2F       	cmp al, '/'
0093+  0BC4 C6 E4 0B    	je ispath_true
0094+  0BC7 B9 2E       	cmp al, '.'
0095+  0BC9 C6 E4 0B    	je ispath_true
0096+  0BCC B9 41       	cmp al, 'A'
0097+  0BCE C8 E0 0B    	jlu ispath_false
0098+  0BD1 B9 7A       	cmp al, 'z'
0099+  0BD3 D1 E0 0B    	jgu ispath_false
0100+  0BD6 B9 5A       	cmp al, 'Z'
0101+  0BD8 D0 E4 0B    	jleu ispath_true
0102+  0BDB B9 61       	cmp al, 'a'
0103+  0BDD C9 E4 0B    	jgeu ispath_true
0104+  0BE0             ispath_false:
0105+  0BE0 8B 01       	or al, 1	; clear ZF
0106+  0BE2 E8          	pop al
0107+  0BE3 09          	ret
0108+  0BE4             ispath_true:
0109+  0BE4 87 00       	and al, 0	; set ZF
0110+  0BE6 E8          	pop al
0111+  0BE7 09          	ret
0112+  0BE8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  0BE8             ;; IS SPACE
0114+  0BE8             ;; sets ZF according with result
0115+  0BE8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  0BE8             isspace:
0117+  0BE8 B9 20       	cmp al, $20		; ' '
0118+  0BEA C6 FE 0B    	je isspace_exit
0119+  0BED B9 09       	cmp al, $09		; '\t'
0120+  0BEF C6 FE 0B    	je isspace_exit
0121+  0BF2 B9 0A       	cmp al, $0A		; '\n'
0122+  0BF4 C6 FE 0B    	je isspace_exit
0123+  0BF7 B9 0D       	cmp al, $0D		; '\r'
0124+  0BF9 C6 FE 0B    	je isspace_exit
0125+  0BFC B9 0B       	cmp al, $0B		; '\v'
0126+  0BFE             isspace_exit:
0127+  0BFE 09          	ret	
0128+  0BFF             
0129+  0BFF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0BFF             ; TO LOWER
0131+  0BFF             ; input in AL
0132+  0BFF             ; output in AL
0133+  0BFF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  0BFF             to_lower:
0135+  0BFF B9 5A       	cmp al, 'Z'
0136+  0C01 D1 06 0C    	jgu to_lower_ret
0137+  0C04 6A 20       	add al, $20				; convert to lower case
0138+  0C06             to_lower_ret:
0139+  0C06 09          	ret
0140+  0C07             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  0C07             ; TO UPPER
0142+  0C07             ; input in AL
0143+  0C07             ; output in AL
0144+  0C07             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  0C07             to_upper:
0146+  0C07 B9 61       	cmp al, 'a'
0147+  0C09 C8 0E 0C    	jlu to_upper_ret
0148+  0C0C 6F 20       	sub al, $20			; convert to upper case
0149+  0C0E             to_upper_ret:
0150+  0C0E 09          	ret
0151+  0C0F             
0085   0C0F             
0086   0C0F             transient_area:
0087   0C0F             
0088   0C0F             .end
0089   0C0F             
0090   0C0F             
0091   0C0F             
tasm: Number of errors = 0
