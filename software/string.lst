0001   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002   0000             ; string.s
0003   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004   0000             
0005   0000             
0006   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007   0000             ; strrev
0008   0000             ; reverse a string
0009   0000             ; D = string address
0010   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011   0000             ; 01234
0012   0000             strrev:
0013   0000 4B          	pusha
0014   0001 07 48 00    	call strlen	; length in C
0015   0004 12          	mov a, c
0016   0005 AF 01 00    	cmp a, 1
0017   0008 D0 22 00    	jleu strrev_end	; check string length. string len must be > 1
0018   000B 7D          	dec a
0019   000C FD 4E       	mov si, d	; beginning of string
0020   000E FD 50       	mov di, d	; beginning of string (for destinations)
0021   0010 59          	add d, a	; end of string
0022   0011 12          	mov a, c
0023   0012 FD 9B       	shr a		; divide by 2
0024   0014 39          	mov c, a	; C now counts the steps
0025   0015             strrev_L0:
0026   0015 32          	mov bl, [d]	; save load right-side char into BL
0027   0016 F6          	lodsb		; load left-side char into AL; increase SI
0028   0017 3E          	mov [d], al	; store left char into right side
0029   0018 1B          	mov al, bl
0030   0019 F7          	stosb		; store right-side char into left-side; increase DI
0031   001A 7E          	dec c
0032   001B 7F          	dec d
0033   001C C2 00 00    	cmp c, 0
0034   001F C7 15 00    	jne strrev_L0
0035   0022             strrev_end:
0036   0022 4C          	popa
0037   0023 09          	ret
0038   0024             	
0039   0024             	
0040   0024             	
0041   0024             	
0042   0024             
0043   0024             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044   0024             ; strchr
0045   0024             ; search string in D for char in AL
0046   0024             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047   0024             strchr:
0048   0024             strchr_L0:
0049   0024 32          	mov bl, [d]
0050   0025 C1 00       	cmp bl, 0
0051   0027 C6 32 00    	je strchr_end
0052   002A BA          	cmp al, bl
0053   002B C6 32 00    	je strchr_end
0054   002E 79          	inc d
0055   002F 0A 24 00    	jmp strchr_L0
0056   0032             strchr_end:
0057   0032 1B          	mov al, bl
0058   0033 09          	ret
0059   0034             
0060   0034             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0061   0034             ; strstr
0062   0034             ; find sub-string
0063   0034             ; str1 in SI
0064   0034             ; str2 in DI
0065   0034             ; SI points to end of source string
0066   0034             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067   0034             strstr:
0068   0034 DB          	push al
0069   0035 DA          	push d
0070   0036 E3          	push di
0071   0037             strstr_loop:
0072   0037 F3          	cmpsb					; compare a byte of the strings
0073   0038 C7 44 00    	jne strstr_ret
0074   003B FC 00 00    	lea d, [di + 0]
0075   003E 1E          	mov al, [d]
0076   003F B9 00       	cmp al, 0				; check if at end of string (null)
0077   0041 C7 37 00    	jne strstr_loop				; equal chars but not at end
0078   0044             strstr_ret:
0079   0044 F0          	pop di
0080   0045 E7          	pop d
0081   0046 E8          	pop al
0082   0047 09          	ret
0083   0048             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0084   0048             ; length of null terminated string
0085   0048             ; result in C
0086   0048             ; pointer in D
0087   0048             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0088   0048             strlen:
0089   0048 DA          	push d
0090   0049 38 00 00    	mov c, 0
0091   004C             strlen_L1:
0092   004C BD 00       	cmp byte [d], 0
0093   004E C6 56 00    	je strlen_ret
0094   0051 79          	inc d
0095   0052 78          	inc c
0096   0053 0A 4C 00    	jmp strlen_L1
0097   0056             strlen_ret:
0098   0056 E7          	pop d
0099   0057 09          	ret
0100   0058             
0101   0058             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0102   0058             ; STRCMP
0103   0058             ; compare two strings
0104   0058             ; str1 in SI
0105   0058             ; str2 in DI
0106   0058             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0107   0058             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108   0058             strcmp:
0109   0058 DB          	push al
0110   0059 DA          	push d
0111   005A E3          	push di
0112   005B E2          	push si
0113   005C             strcmp_loop:
0114   005C F3          	cmpsb					; compare a byte of the strings
0115   005D C7 69 00    	jne strcmp_ret
0116   0060 FB FF FF    	lea d, [si +- 1]
0117   0063 1E          	mov al, [d]
0118   0064 B9 00       	cmp al, 0				; check if at end of string (null)
0119   0066 C7 5C 00    	jne strcmp_loop				; equal chars but not at end
0120   0069             strcmp_ret:
0121   0069 EF          	pop si
0122   006A F0          	pop di
0123   006B E7          	pop d
0124   006C E8          	pop al
0125   006D 09          	ret
0126   006E             
0127   006E             
0128   006E             ; STRCPY
0129   006E             ; copy null terminated string from SI to DI
0130   006E             ; source in SI
0131   006E             ; destination in DI
0132   006E             strcpy:
0133   006E E2          	push si
0134   006F E3          	push di
0135   0070 DB          	push al
0136   0071             strcpy_L1:
0137   0071 F6          	lodsb
0138   0072 F7          	stosb
0139   0073 B9 00       	cmp al, 0
0140   0075 C7 71 00    	jne strcpy_L1
0141   0078             strcpy_end:
0142   0078 E8          	pop al
0143   0079 F0          	pop di
0144   007A EF          	pop si
0145   007B 09          	ret
0146   007C             
0147   007C             ; STRCAT
0148   007C             ; concatenate a NULL terminated string into string at DI, from string at SI
0149   007C             ; source in SI
0150   007C             ; destination in DI
0151   007C             strcat:
0152   007C E2          	push si
0153   007D E3          	push di
0154   007E D7          	push a
0155   007F DA          	push d
0156   0080 50          	mov a, di
0157   0081 3C          	mov d, a
0158   0082             strcat_goto_end_L1:
0159   0082 1E          	mov al, [d]
0160   0083 B9 00       	cmp al, 0
0161   0085 C6 8C 00    	je strcat_start
0162   0088 79          	inc d
0163   0089 0A 82 00    	jmp strcat_goto_end_L1
0164   008C             strcat_start:
0165   008C FD 50       	mov di, d
0166   008E             strcat_L1:
0167   008E F6          	lodsb
0168   008F F7          	stosb
0169   0090 B9 00       	cmp al, 0
0170   0092 C7 8E 00    	jne strcat_L1
0171   0095             strcat_end:
0172   0095 E7          	pop d
0173   0096 E4          	pop a
0174   0097 F0          	pop di
0175   0098 EF          	pop si
0176   0099 09          	ret
 line 0176: No END directive before EOF.       
tasm: Number of errors = 1
