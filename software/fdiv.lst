0001   0000             ;Code for division of floating point numbers
0002   0000             ;Performs fp_a divided by fp_b (that is, fp_a is dividend, fp_b is divisor)
0003   0000             ;Uses long_a, long_b, long_c and long_d to perform calculation
0004   0000             ;Quotient returned in fp_c
0005   0000             ;Does not check for zero divisor
0006   0000             			.include "kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0007   0400             			.org	1024
0008   0400             
0009   0400             ;First gets fp_a and fp_b from input
0010   0400             ;Get fp_a as an ascii hex string
0011   0400 07 FF 09    			call	printnl
0012   0403 3B 54 07    			mov	d,enter_fp_A_string
0013   0406 07 52 0A    			call	puts
0014   0409 3B E6 07    			mov	d,buffer
0015   040C 07 1F 09    			call	gets
0016   040F             ;Now parse string and put in fp_a
0017   040F 29 E6 07    			mov	b,[buffer]		;gets two ascii hex char values
0018   0412 FD AB       			swp	b			;mov gets little-endian, so need to swap bytes
0019   0414 07 CD 08    			call	atoi			;converts ascii hex pair in B to value in AL
0020   0417 3D B4 07    			mov	[fp_a],al
0021   041A 29 E8 07    			mov	b,[buffer+2]
0022   041D FD AB       			swp	b
0023   041F 07 CD 08    			call	atoi
0024   0422 3D B5 07    			mov	[fp_a+1],al
0025   0425 29 EA 07    			mov	b,[buffer+4]
0026   0428 FD AB       			swp	b
0027   042A 07 CD 08    			call	atoi
0028   042D 3D B6 07    			mov	[fp_a+2],al
0029   0430 29 EC 07    			mov	b,[buffer+6]
0030   0433 FD AB       			swp	b
0031   0435 07 CD 08    			call	atoi
0032   0438 3D B7 07    			mov	[fp_a+3],al
0033   043B             ;Get fp_b as an ascii hex string
0034   043B 07 FF 09    			call	printnl
0035   043E 3B 6E 07    			mov	d,enter_fp_B_string
0036   0441 07 52 0A    			call	puts
0037   0444 3B E6 07    			mov	d,buffer
0038   0447 07 1F 09    			call	gets
0039   044A             ;Now parse string and put in fp_b
0040   044A 29 E6 07    			mov	b,[buffer]		;gets two ascii hex char values
0041   044D FD AB       			swp	b			;mov gets little-endian, so need to swap bytes
0042   044F 07 CD 08    			call	atoi			;converts ascii hex pair in B to value in AL
0043   0452 3D B8 07    			mov	[fp_b],al
0044   0455 29 E8 07    			mov	b,[buffer+2]
0045   0458 FD AB       			swp	b
0046   045A 07 CD 08    			call	atoi
0047   045D 3D B9 07    			mov	[fp_b+1],al
0048   0460 29 EA 07    			mov	b,[buffer+4]
0049   0463 FD AB       			swp	b
0050   0465 07 CD 08    			call	atoi
0051   0468 3D BA 07    			mov	[fp_b+2],al
0052   046B 29 EC 07    			mov	b,[buffer+6]
0053   046E FD AB       			swp	b
0054   0470 07 CD 08    			call	atoi
0055   0473 3D BB 07    			mov	[fp_b+3],al
0056   0476             
0057   0476             divide_float:					
0058   0476             			
0059   0476             ;Calculate sign of quotient first (same as in multiplication)							
0060   0476 1D B4 07    			mov	al,[fp_a]
0061   0479 2F          			mov	bl,al
0062   047A 1D B8 07    			mov	al,[fp_b]
0063   047D 90          			xor	al,bl		;sign of result is XOR of signs of products
0064   047E 2F          			mov	bl,al
0065   047F 19 80       			mov	al,10000000b	;mask of remainder of bits
0066   0481 88          			and	al,bl
0067   0482 3D C0 07    			mov	[sign],al	;(sign) is 8-bit mask used to OR-in the sign bit
0068   0485             			
0069   0485             			
0070   0485             ;Calculate exponent of quotient (same as in multiplication, except subtract exp of fp_b from exp fp_a
0071   0485             ;Get exponent of a
0072   0485 1D B4 07    			mov	al,[fp_a]	;need to get bit 0 of exponent from bit 7 of
0073   0488 FD 9E 01    			shl	al,1		;fp_a+1 and combine with the rest of the
0074   048B 2F          			mov	bl,al		;exponent from fp_a
0075   048C 1D B5 07    			mov	al,[fp_a+1]	;is bit 7 one?
0076   048F 87 80       			and	al,10000000b
0077   0491 C7 98 04    			jnz	dfp_next_1	;yes, OR-in a 1 in bit 0 of exponent byte
0078   0494 1B          			mov	al,bl
0079   0495 0A 9B 04    			jmp	dfp_next_2	;no, skip OR-in (will have a zero from shift)
0080   0498 19 01       dfp_next_1:		mov	al,00000001b
0081   049A 8C          			or	al,bl
0082   049B             			
0083   049B             ;Remove exponent bias and save
0084   049B 6F 7F       dfp_next_2:		sub	al,127		;al now has unbiased exponent of a
0085   049D 3D C1 07    			mov	[exponent_a],al
0086   04A0             			
0087   04A0             ;Get exponent of b
0088   04A0 1D B8 07    			mov	al,[fp_b]	;need to get bit 0 of exponent from bit 7 of
0089   04A3 FD 9E 01    			shl	al,1		;fp_a+1 and combine with the rest of the
0090   04A6 2F          			mov	bl,al		;exponent from fp_a
0091   04A7 1D B9 07    			mov	al,[fp_b+1]	;is bit 7 one?
0092   04AA 87 80       			and	al,10000000b
0093   04AC C7 B3 04    			jnz	dfp_next_3	;yes, OR-in a 1 in bit 0 of exponent byte
0094   04AF 1B          			mov	al,bl
0095   04B0 0A B6 04    			jmp	dfp_next_4	;no, skip OR-in (will have a zero from shift)
0096   04B3 19 01       dfp_next_3:		mov	al,00000001b
0097   04B5 8C          			or	al,bl
0098   04B6             			
0099   04B6             ;Remove exponent bias and save
0100   04B6 6F 7F       dfp_next_4:		sub	al,127		;al now has unbiased exponent of b
0101   04B8 3D C2 07    			mov	[exponent_b],al
0102   04BB             			
0103   04BB             ;Subtract unbiased exponent b from a and save
0104   04BB 2F          			mov	bl,al		;temp store unbiased exp b
0105   04BC 1D C1 07    			mov	al,[exponent_a]
0106   04BF 70          			sub	al,bl		;unbiased exponent a - unbiased exponent b
0107   04C0 3D C3 07    			mov	[exponent_c],al	;exponent_c has unbiased exponent of result
0108   04C3             
0109   04C3             ;Divide significands
0110   04C3             ;Unpack and divide
0111   04C3 1D B5 07    			mov	al,[fp_a+1]	;need to set leftmost bit of significand to one
0112   04C6 2F          			mov	bl,al		;this bit is implied but not stored in fp
0113   04C7 19 80       			mov	al,10000000b
0114   04C9 8C          			or	al,bl
0115   04CA 3D C4 07    			mov	[long_a],al
0116   04CD 1D B6 07    			mov	al,[fp_a+2]
0117   04D0 3D C5 07    			mov	[long_a+1],al
0118   04D3 1D B7 07    			mov	al,[fp_a+3]
0119   04D6 3D C6 07    			mov	[long_a+2],al
0120   04D9 1D B9 07    			mov	al,[fp_b+1]
0121   04DC 2F          			mov	bl,al
0122   04DD 19 80       			mov	al,10000000b
0123   04DF 8C          			or	al,bl
0124   04E0 3D C7 07    			mov	[long_b],al
0125   04E3 1D BA 07    			mov	al,[fp_b+2]
0126   04E6 3D C8 07    			mov	[long_b+1],al
0127   04E9 1D BB 07    			mov	al,[fp_b+3]
0128   04EC 3D C9 07    			mov	[long_b+2],al
0129   04EF 07 5B 05    			call	divide_long
0130   04F2             			
0131   04F2             ;Normalize quotient		
0132   04F2 1D CA 07    dfp_loop_1:		mov	al,[long_c]	;check leftmost bit of quotient
0133   04F5 2F          			mov	bl,al
0134   04F6 19 80       			mov	al,10000000b
0135   04F8 88          			and	al,bl			;test leftmost bit of quotient
0136   04F9 C7 09 05    			jnz	dfp_next_5		;normalized, assemble final fp
0137   04FC 07 39 07    			call	shift_left_long_c	;not normalized, shift left and dec exponent
0138   04FF 1D C3 07    			mov	al,[exponent_c]
0139   0502 80          			dec	al
0140   0503 3D C3 07    			mov	[exponent_c],al
0141   0506 0A F2 04    			jmp	dfp_loop_1			
0142   0509             
0143   0509             ;Assemble final fp 
0144   0509 1D C3 07    dfp_next_5:		mov	al,[exponent_c]	;First byte is sign bit and bits 7 to 1
0145   050C 6A 7F       			add	al,127			;restore bias
0146   050E 3D C3 07    			mov	[exponent_c],al	;exponent_c now has biased exponent
0147   0511 FD A2 01    			shr	al,1
0148   0514 31 C0 07    			mov	bl,[sign]		;move over for sign bit
0149   0517 8C          			or	al,bl			;put sign bit in
0150   0518 3D BC 07    			mov	[fp_c],al		;First byte done
0151   051B 1D CA 07    			mov	al,[long_c]		;get first byte of mantissa
0152   051E 3D BD 07    			mov	[fp_c+1],al		;store in second byte of fp
0153   0521 1D C3 07    			mov	al,[exponent_c]	;check bit 0 of biased exponent
0154   0524 87 01       			and	al,00000001b		;test bit 0 of exponent
0155   0526 C7 31 05    			jnz	dfp_next_6		;bit is one, leave one in bit 7 of fp_c+1
0156   0529 1D BD 07    			mov	al,[fp_c+1]		;bit is 0, mask off bit 7 of fp_c+1
0157   052C 87 7F       			and	al,01111111b
0158   052E 3D BD 07    			mov	[fp_c+1],al
0159   0531 1D CB 07    dfp_next_6:		mov	al,[long_c+1]		;get second and third product bytes
0160   0534 3D BE 07    			mov	[fp_c+2],al
0161   0537 1D CC 07    			mov	al,[long_c+2]
0162   053A 3D BF 07    			mov	[fp_c+3],al		;complete fp product now assembled in fp_c
0163   053D             
0164   053D             ;Insert rounding code here -- check leftmost bits of double_long_a+4, and increment mantissa if rounding
0165   053D             
0166   053D             ;Print result
0167   053D 07 FF 09    			call	printnl
0168   0540 3B 88 07    			mov	d,result_string
0169   0543 07 52 0A    			call	puts
0170   0546 29 BC 07    			mov	b,[fp_c]
0171   0549 FD AB       			swp	b
0172   054B 07 AE 0A    			call	print_u16x
0173   054E 29 BE 07    			mov	b,[fp_c+2]
0174   0551 FD AB       			swp	b
0175   0553 07 AE 0A    			call	print_u16x
0176   0556 07 FF 09    			call	printnl
0177   0559             
0178   0559 05 0B       			syscall sys_terminate_proc	;special call to return to OS
0179   055B             			
0180   055B             ;Subroutines
0181   055B             
0182   055B             ;Divide_long subroutine
0183   055B             ;Subroutine for 24-bit division
0184   055B             ;Dividend passed in long_a
0185   055B             ;Divisor passed in long_b
0186   055B             ;Divisor and dividend words must be left-aligned before passing
0187   055B             ;Does not check for zero divisor
0188   055B             ;Uses double_long_a, b and c and long_d for calculation
0189   055B             ;Quotient returned in long_c
0190   055B             ;Remainder returned in long_r
0191   055B             
0192   055B 19 00       divide_long:		mov	al,0			;clear variables used in calculation
0193   055D 3D D3 07    			mov	[double_long_a],al
0194   0560 3D D4 07    			mov	[double_long_a+1],al
0195   0563 3D D5 07    			mov	[double_long_a+2],al
0196   0566 3D D6 07    			mov	[double_long_a+3],al
0197   0569 3D D7 07    			mov	[double_long_a+4],al
0198   056C 3D D8 07    			mov	[double_long_a+5],al
0199   056F 3D D9 07    			mov	[double_long_b],al
0200   0572 3D DA 07    			mov	[double_long_b+1],al
0201   0575 3D DB 07    			mov	[double_long_b+2],al
0202   0578 3D DC 07    			mov	[double_long_b+3],al
0203   057B 3D DD 07    			mov	[double_long_b+4],al
0204   057E 3D DE 07    			mov	[double_long_b+5],al
0205   0581 3D DF 07    			mov	[double_long_c],al
0206   0584 3D E0 07    			mov	[double_long_c+1],al
0207   0587 3D E1 07    			mov	[double_long_c+2],al
0208   058A 3D E2 07    			mov	[double_long_c+3],al
0209   058D 3D E3 07    			mov	[double_long_c+4],al
0210   0590 3D E4 07    			mov	[double_long_c+5],al
0211   0593 3D CA 07    			mov	[long_c],al		;clear quotient
0212   0596 3D CB 07    			mov	[long_c+1],al
0213   0599 3D CC 07    			mov	[long_c+2],al
0214   059C 19 80       			mov	al,10000000b		;Set up mask to OR-in quotient bits
0215   059E 3D CD 07    			mov	[long_d],al
0216   05A1 19 00       			mov	al,0
0217   05A3 3D CE 07    			mov	[long_d+1],al
0218   05A6 3D CF 07    			mov	[long_d+2],al
0219   05A9 19 18       			mov	al,24
0220   05AB 3D E5 07    			mov	[divide_rounds],al	;Maximum 24 rounds of division
0221   05AE 1D C4 07    			mov	al,[long_a]		;set up divisor and dividend in 48-bit words
0222   05B1 3D D3 07    			mov	[double_long_a],al	;dividend
0223   05B4 1D C5 07    			mov	al,[long_a+1]
0224   05B7 3D D4 07    			mov	[double_long_a+1],al
0225   05BA 1D C6 07    			mov	al,[long_a+2]
0226   05BD 3D D5 07    			mov	[double_long_a+2],al
0227   05C0 1D C7 07    			mov	al,[long_b]		;divisor
0228   05C3 3D D9 07    			mov	[double_long_b],al
0229   05C6 1D C8 07    			mov	al,[long_b+1]
0230   05C9 3D DA 07    			mov	[double_long_b+1],al
0231   05CC 1D C9 07    			mov	al,[long_b+2]
0232   05CF 3D DB 07    			mov	[double_long_b+2],al
0233   05D2             						
0234   05D2 14 D7 07    long_divide_loop:	mov	a,[double_long_a+4]	;48-bit subtraction of divisor from dividend
0235   05D5 29 DD 07    			mov	b,[double_long_b+4]	;Divisor in double_long_b to reg b
0236   05D8 FD AA       			swp	a			;Dividend in double_long_a to reg a
0237   05DA FD AB       			swp	b
0238   05DC 60          			sub	a,b			;Reg A - Reg B is dividend - divisor
0239   05DD FD AA       			swp	a						
0240   05DF 42 E3 07    			mov	[double_long_c+4],a	;result placed in double_long_c
0241   05E2 14 D5 07    			mov	a,[double_long_a+2]	;move through bytes right to left
0242   05E5 29 DB 07    			mov	b,[double_long_b+2]
0243   05E8 FD AA       			swp	a
0244   05EA FD AB       			swp	b
0245   05EC 67          			sbb	a,b
0246   05ED FD AA       			swp	a
0247   05EF 42 E1 07    			mov	[double_long_c+2],a
0248   05F2 14 D3 07    			mov	a,[double_long_a]
0249   05F5 29 D9 07    			mov	b,[double_long_b]
0250   05F8 FD AA       			swp	a
0251   05FA FD AB       			swp	b
0252   05FC 67          			sbb	a,b
0253   05FD FD AA       			swp	a
0254   05FF 42 DF 07    			mov	[double_long_c],a	;double_long_c now has result of subtraction
0255   0602 C9 15 06    			jnc	long_quotient_one	;no borrow, put 1 in quotient and replace dividend
0256   0605 1D E5 07    			mov	al,[divide_rounds]	;borrow, leave 0 in quotient
0257   0608 80          			dec	al			;check if reached divide limit
0258   0609 C6 84 06    			jz	long_divide_done	;24 rounds done, quit
0259   060C 3D E5 07    			mov	[divide_rounds],al	;more rounds to do, go on
0260   060F 07 F5 06    			call	shift_right_long_d	;shift mask in long_d right one
0261   0612 0A 7E 06    			jmp	long_divisor_shift	;do not replace dividend, shift divisor
0262   0615             
0263   0615 1D CA 07    long_quotient_one:	mov	al,[long_c]		;place a one in quotient word
0264   0618 31 CD 07    			mov	bl,[long_d]
0265   061B 8C          			or	al,bl			;uses long_d as mask for quotient bits
0266   061C 3D CA 07    			mov	[long_c],al
0267   061F 1D CB 07    			mov	al,[long_c+1]
0268   0622 31 CE 07    			mov	bl,[long_d+1]
0269   0625 8C          			or	al,bl
0270   0626 3D CB 07    			mov	[long_c+1],al
0271   0629 1D CC 07    			mov	al,[long_c+2]
0272   062C 31 CF 07    			mov	bl,[long_d+2]
0273   062F 8C          			or	al,bl
0274   0630 3D CC 07    			mov	[long_c+2],al
0275   0633             
0276   0633 1D DF 07    			mov	al,[double_long_c]	;replace dividend with subtracted dividend
0277   0636 3D D3 07    			mov	[double_long_a],al
0278   0639 1D E0 07    			mov	al,[double_long_c+1]
0279   063C 3D D4 07    			mov	[double_long_a+1],al
0280   063F 1D E1 07    			mov	al,[double_long_c+2]
0281   0642 3D D5 07    			mov	[double_long_a+2],al
0282   0645 1D E2 07    			mov	al,[double_long_c+3]
0283   0648 3D D6 07    			mov	[double_long_a+3],al
0284   064B 1D E3 07    			mov	al,[double_long_c+4]
0285   064E 3D D7 07    			mov	[double_long_a+4],al
0286   0651 1D E4 07    			mov	al,[double_long_c+5]
0287   0654 3D D8 07    			mov	[double_long_a+5],al
0288   0657             
0289   0657             			
0290   0657 1D D3 07    			mov	al,[double_long_a]	;check if remainder zero
0291   065A 31 D4 07    			mov	bl,[double_long_a+1]
0292   065D 8C          			or	al,bl
0293   065E 31 D5 07    			mov	bl,[double_long_a+2]
0294   0661 8C          			or	al,bl
0295   0662 31 D6 07    			mov	bl,[double_long_a+3]
0296   0665 8C          			or	al,bl
0297   0666 31 D7 07    			mov	bl,[double_long_a+4]
0298   0669 8C          			or	al,bl
0299   066A 31 D8 07    			mov	bl,[double_long_a+5]
0300   066D 8C          			or	al,bl
0301   066E C6 84 06    			jz	long_divide_done	;remainder zero, quit
0302   0671 1D E5 07    			mov	al,[divide_rounds]	;remainder not zero, check if reached divide limit
0303   0674 80          			dec	al
0304   0675 C6 84 06    			jz	long_divide_done	;24 rounds done, quit
0305   0678 3D E5 07    			mov	[divide_rounds],al	;more rounds to do, go on
0306   067B 07 F5 06    			call	shift_right_long_d	;subroutine shifts mask in long_d one right
0307   067E             									
0308   067E 07 10 07    long_divisor_shift:	call	shift_right_double_long_b	;shift divisor in double_long_b one position
0309   0681 0A D2 05    			jmp	long_divide_loop
0310   0684             
0311   0684 1D E4 07    long_divide_done:	mov	al,[double_long_c+5]	;put remainder in long_r
0312   0687 3D D2 07    			mov	[long_r+2],al
0313   068A 1D E3 07    			mov	al,[double_long_c+4]
0314   068D 3D D1 07    			mov	[long_r+1],al
0315   0690 1D E2 07    			mov	al,[double_long_c+3]
0316   0693 3D D0 07    			mov	[long_r],al
0317   0696             			
0318   0696             ;Rounding code here. If remainder not zero, do one more round of division
0319   0696             ;If no borrow on this extra round of division, add 1 to quotient
0320   0696             
0321   0696 1D D0 07    			mov	al,[long_r]		;check if remainder zero
0322   0699 31 D1 07    			mov	bl,[long_r+1]
0323   069C 8C          			or	al,bl
0324   069D 31 D2 07    			mov	bl,[long_r+2]
0325   06A0 8C          			or	al,bl
0326   06A1 C6 F4 06    			jz	rounding_done		;If remainder zero, no need to round
0327   06A4             			
0328   06A4             ;Remainder not zero, do another round of division
0329   06A4 07 10 07    			call	shift_right_double_long_b
0330   06A7 14 D7 07    			mov	a,[double_long_a+4]	;48-bit subtraction of divisor from dividend
0331   06AA 29 DD 07    			mov	b,[double_long_b+4]	;Divisor in double_long_b to reg b
0332   06AD FD AA       			swp	a			;Dividend in double_long_a to reg a
0333   06AF FD AB       			swp	b
0334   06B1 60          			sub	a,b			;Reg A - Reg B is dividend - divisor
0335   06B2 FD AA       			swp	a						
0336   06B4 42 E3 07    			mov	[double_long_c+4],a	;result placed in double_long_c
0337   06B7 14 D5 07    			mov	a,[double_long_a+2]	;move through bytes right to left
0338   06BA 29 DB 07    			mov	b,[double_long_b+2]
0339   06BD FD AA       			swp	a
0340   06BF FD AB       			swp	b
0341   06C1 67          			sbb	a,b
0342   06C2 FD AA       			swp	a
0343   06C4 42 E1 07    			mov	[double_long_c+2],a
0344   06C7 14 D3 07    			mov	a,[double_long_a]
0345   06CA 29 D9 07    			mov	b,[double_long_b]
0346   06CD FD AA       			swp	a
0347   06CF FD AB       			swp	b
0348   06D1 67          			sbb	a,b
0349   06D2 FD AA       			swp	a
0350   06D4 42 DF 07    			mov	[double_long_c],a	;double_long_c now has result of subtraction
0351   06D7 C8 F4 06    			jc	rounding_done		;borrow, leave quotient alone
0352   06DA             							
0353   06DA 14 CB 07    			mov	a,[long_c+1]		;no borrow, round up
0354   06DD FD AA       			swp	a			;16-bit additions for 24-bit add one to quotient
0355   06DF 53 01 00    			add	a,1			
0356   06E2 FD AA       			swp	a				
0357   06E4 42 CB 07    			mov	[long_c+1],a
0358   06E7 14 C9 07    			mov	a,[long_c-1]		;uppermost byte will be garbage
0359   06EA FD AA       			swp	a
0360   06EC 5B 00 00    			adc	a,0
0361   06EF FD AA       			swp	a
0362   06F1 3D C9 07    			mov	[long_c-1],al
0363   06F4             			
0364   06F4 09          rounding_done:		ret
0365   06F5             		
0366   06F5 14 CD 07    shift_right_long_d:	mov	a,[long_d]	;16-bit load, little endian
0367   06F8 FD AA       			swp	a		;swap to make it fit the big-endian mantissa
0368   06FA FD 9B       			shr	a
0369   06FC FD AA       			swp	a
0370   06FE 42 CD 07    			mov	[long_d],a
0371   0701 14 CF 07    			mov	a,[long_d+2]	;16-bit load, but high byte in memory is garbage
0372   0704 3A 01       			mov	cl, 1
0373   0706 FD AA       			swp	a
0374   0708 FD E4       			rrc	a, cl
0375   070A FD AA       			swp	a
0376   070C 3D CF 07    			mov	[long_d+2],al	;discard high byte which is garbage
0377   070F 09          			ret
0378   0710             
0379   0710             shift_right_double_long_b:	
0380   0710 14 D9 07    			mov	a,[double_long_b]
0381   0713 FD AA       			swp	a
0382   0715 FD 9B       			shr	a
0383   0717 FD AA       			swp	a
0384   0719 42 D9 07    			mov	[double_long_b],a
0385   071C 14 DB 07    			mov	a,[double_long_b+2]
0386   071F 3A 01       			mov	cl, 1
0387   0721 FD AA       			swp	a
0388   0723 FD E4       			rrc	a, cl
0389   0725 FD AA       			swp	a
0390   0727 42 DB 07    			mov	[double_long_b+2],a
0391   072A 14 DD 07    			mov	a,[double_long_b+4]
0392   072D 3A 01       			mov	cl, 1
0393   072F FD AA       			swp	a
0394   0731 FD E4       			rrc	a, cl
0395   0733 FD AA       			swp	a
0396   0735 42 DD 07    			mov	[double_long_b+4],a
0397   0738 09          			ret
0398   0739             
0399   0739             ;Subroutine to shift left one a 24-bit value
0400   0739             ;24-bit value in long_c
0401   0739 14 CB 07    shift_left_long_c:	mov	a,[long_c+1]	;16-bit load, little endian
0402   073C FD AA       			swp	a		;swap to make it fit the big-endian mantissa
0403   073E FD 99       			shl	a
0404   0740 FD AA       			swp	a
0405   0742 42 CB 07    			mov	[long_c+1],a
0406   0745 14 C9 07    			mov	a,[long_c-1]	;16-bit load, low byte in memory is garbage
0407   0748 3A 01       			mov	cl, 1
0408   074A FD AA       			swp	a
0409   074C FD E0       			rlc	a, cl
0410   074E FD AA       			swp	a
0411   0750 42 C9 07    			mov	[long_c-1],a	;discard high byte which is garbage
0412   0753 09          			ret
0413   0754             ;Strings
0414   0754 45 6E 74 65 enter_fp_A_string:	.db	"Enter fp_A (32-bit hex): ",0
0414   0758 72 20 66 70 
0414   075C 5F 41 20 28 
0414   0760 33 32 2D 62 
0414   0764 69 74 20 68 
0414   0768 65 78 29 3A 
0414   076C 20 00 
0415   076E 45 6E 74 65 enter_fp_B_string:	.db	"Enter fp_B (32-bit hex): ",0
0415   0772 72 20 66 70 
0415   0776 5F 42 20 28 
0415   077A 33 32 2D 62 
0415   077E 69 74 20 68 
0415   0782 65 78 29 3A 
0415   0786 20 00 
0416   0788 52 65 73 75 result_string:		.db	"Result (quotient) of fp_A divided by fp_B: ",0			
0416   078C 6C 74 20 28 
0416   0790 71 75 6F 74 
0416   0794 69 65 6E 74 
0416   0798 29 20 6F 66 
0416   079C 20 66 70 5F 
0416   07A0 41 20 64 69 
0416   07A4 76 69 64 65 
0416   07A8 64 20 62 79 
0416   07AC 20 66 70 5F 
0416   07B0 42 3A 20 00 
0417   07B4             
0418   07B4             ;Variables
0419   07B4             			
0420   07B4 41 B2 CA C1 fp_a			.db	041h,0b2h,0cah,0c1h	;Dividend IEEE 754 float 0x41b2cac1 = decimal 22.349			
0421   07B8 42 9A 00 00 fp_b			.db	42h,9ah,00h,00h	;Divisor IEEE 754 float 0x429a0000 = decimal 77.0			
0422   07BC 00 00 00 00 fp_c			.db	0,0,0,0		;Quotient IEEE 754 float 0x3e949b39 = decimal 0.290246753			
0423   07C0 00          sign			.db	0			
0424   07C1 00          exponent_a		.db	0			
0425   07C2 00          exponent_b		.db	0			
0426   07C3 00          exponent_c		.db	0			
0427   07C4 00 00 00    long_a			.db	0,0,0		;Significand dividend			
0428   07C7 00 00 00    long_b			.db	0,0,0		;Significand divisor			
0429   07CA 00 00 00    long_c			.db	0,0,0		;Significand quotient			
0430   07CD 00 00 00    long_d			.db	0,0,0			
0431   07D0 00 00 00    long_r			.db	0,0,0		;Significand remainder			
0432   07D3 00 00 00 00 double_long_a		.db	0,0,0,0,0,0	;48-bit integer			
0432   07D7 00 00 
0433   07D9 00 00 00 00 double_long_b		.db	0,0,0,0,0,0	;48-bit interger			
0433   07DD 00 00 
0434   07DF 00 00 00 00 double_long_c		.db	0,0,0,0,0,0			
0434   07E3 00 00 
0435   07E5 00          divide_rounds		.db	0
0436   07E6             
0437   07E6             ;Input buffer		
0438   07E6 00 00 00 00 buffer:		.fill	40,0
0438   07EA 00 00 00 00 
0438   07EE 00 00 00 00 
0438   07F2 00 00 00 00 
0438   07F6 00 00 00 00 
0438   07FA 00 00 00 00 
0438   07FE 00 00 00 00 
0438   0802 00 00 00 00 
0438   0806 00 00 00 00 
0438   080A 00 00 00 00 
0439   080E             
0440   080E             			.include "stdio.asm"
0001+  080E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  080E             ; stdio.s
0003+  080E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  080E             .include "string.asm"
0001++ 080E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 080E             ; string.s
0003++ 080E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 080E             
0005++ 080E             
0006++ 080E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 080E             ; strrev
0008++ 080E             ; reverse a string
0009++ 080E             ; D = string address
0010++ 080E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 080E             ; 01234
0012++ 080E             strrev:
0013++ 080E 4B          	pusha
0014++ 080F 07 55 08    	call strlen	; length in C
0015++ 0812 12          	mov a, c
0016++ 0813 AF 01 00    	cmp a, 1
0017++ 0816 D0 30 08    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0819 7D          	dec a
0019++ 081A FD 4E       	mov si, d	; beginning of string
0020++ 081C FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 081E 59          	add d, a	; end of string
0022++ 081F 12          	mov a, c
0023++ 0820 FD 9B       	shr a		; divide by 2
0024++ 0822 39          	mov c, a	; C now counts the steps
0025++ 0823             strrev_L0:
0026++ 0823 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0824 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0825 3E          	mov [d], al	; store left char into right side
0029++ 0826 1B          	mov al, bl
0030++ 0827 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0828 7E          	dec c
0032++ 0829 7F          	dec d
0033++ 082A C2 00 00    	cmp c, 0
0034++ 082D C7 23 08    	jne strrev_L0
0035++ 0830             strrev_end:
0036++ 0830 4C          	popa
0037++ 0831 09          	ret
0038++ 0832             	
0039++ 0832             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0832             ; strchr
0041++ 0832             ; search string in D for char in AL
0042++ 0832             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0832             strchr:
0044++ 0832             strchr_L0:
0045++ 0832 32          	mov bl, [d]
0046++ 0833 C1 00       	cmp bl, 0
0047++ 0835 C6 40 08    	je strchr_end
0048++ 0838 BA          	cmp al, bl
0049++ 0839 C6 40 08    	je strchr_end
0050++ 083C 79          	inc d
0051++ 083D 0A 32 08    	jmp strchr_L0
0052++ 0840             strchr_end:
0053++ 0840 1B          	mov al, bl
0054++ 0841 09          	ret
0055++ 0842             
0056++ 0842             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0842             ; strstr
0058++ 0842             ; find sub-string
0059++ 0842             ; str1 in SI
0060++ 0842             ; str2 in DI
0061++ 0842             ; SI points to end of source string
0062++ 0842             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0842             strstr:
0064++ 0842 DB          	push al
0065++ 0843 DA          	push d
0066++ 0844 E3          	push di
0067++ 0845             strstr_loop:
0068++ 0845 F3          	cmpsb					; compare a byte of the strings
0069++ 0846 C7 51 08    	jne strstr_ret
0070++ 0849 FC 00 00    	lea d, [di + 0]
0071++ 084C BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 084E C7 45 08    	jne strstr_loop				; equal chars but not at end
0073++ 0851             strstr_ret:
0074++ 0851 F0          	pop di
0075++ 0852 E7          	pop d
0076++ 0853 E8          	pop al
0077++ 0854 09          	ret
0078++ 0855             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0855             ; length of null terminated string
0080++ 0855             ; result in C
0081++ 0855             ; pointer in D
0082++ 0855             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0855             strlen:
0084++ 0855 DA          	push d
0085++ 0856 38 00 00    	mov c, 0
0086++ 0859             strlen_L1:
0087++ 0859 BD 00       	cmp byte [d], 0
0088++ 085B C6 63 08    	je strlen_ret
0089++ 085E 79          	inc d
0090++ 085F 78          	inc c
0091++ 0860 0A 59 08    	jmp strlen_L1
0092++ 0863             strlen_ret:
0093++ 0863 E7          	pop d
0094++ 0864 09          	ret
0095++ 0865             
0096++ 0865             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0865             ; STRCMP
0098++ 0865             ; compare two strings
0099++ 0865             ; str1 in SI
0100++ 0865             ; str2 in DI
0101++ 0865             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0865             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0865             strcmp:
0104++ 0865 DB          	push al
0105++ 0866 DA          	push d
0106++ 0867 E3          	push di
0107++ 0868 E2          	push si
0108++ 0869             strcmp_loop:
0109++ 0869 F3          	cmpsb					; compare a byte of the strings
0110++ 086A C7 75 08    	jne strcmp_ret
0111++ 086D FB FF FF    	lea d, [si +- 1]
0112++ 0870 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0872 C7 69 08    	jne strcmp_loop				; equal chars but not at end
0114++ 0875             strcmp_ret:
0115++ 0875 EF          	pop si
0116++ 0876 F0          	pop di
0117++ 0877 E7          	pop d
0118++ 0878 E8          	pop al
0119++ 0879 09          	ret
0120++ 087A             
0121++ 087A             
0122++ 087A             ; STRCPY
0123++ 087A             ; copy null terminated string from SI to DI
0124++ 087A             ; source in SI
0125++ 087A             ; destination in DI
0126++ 087A             strcpy:
0127++ 087A E2          	push si
0128++ 087B E3          	push di
0129++ 087C DB          	push al
0130++ 087D             strcpy_L1:
0131++ 087D F6          	lodsb
0132++ 087E F7          	stosb
0133++ 087F B9 00       	cmp al, 0
0134++ 0881 C7 7D 08    	jne strcpy_L1
0135++ 0884             strcpy_end:
0136++ 0884 E8          	pop al
0137++ 0885 F0          	pop di
0138++ 0886 EF          	pop si
0139++ 0887 09          	ret
0140++ 0888             
0141++ 0888             ; STRCAT
0142++ 0888             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0888             ; source in SI
0144++ 0888             ; destination in DI
0145++ 0888             strcat:
0146++ 0888 E2          	push si
0147++ 0889 E3          	push di
0148++ 088A D7          	push a
0149++ 088B DA          	push d
0150++ 088C 50          	mov a, di
0151++ 088D 3C          	mov d, a
0152++ 088E             strcat_goto_end_L1:
0153++ 088E BD 00       	cmp byte[d], 0
0154++ 0890 C6 97 08    	je strcat_start
0155++ 0893 79          	inc d
0156++ 0894 0A 8E 08    	jmp strcat_goto_end_L1
0157++ 0897             strcat_start:
0158++ 0897 FD 50       	mov di, d
0159++ 0899             strcat_L1:
0160++ 0899 F6          	lodsb
0161++ 089A F7          	stosb
0162++ 089B B9 00       	cmp al, 0
0163++ 089D C7 99 08    	jne strcat_L1
0164++ 08A0             strcat_end:
0165++ 08A0 E7          	pop d
0166++ 08A1 E4          	pop a
0167++ 08A2 F0          	pop di
0168++ 08A3 EF          	pop si
0169++ 08A4 09          	ret
0005+  08A5             
0006+  08A5 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  08A9 34 35 36 37 
0006+  08AD 38 39 41 42 
0006+  08B1 43 44 45 46 
0007+  08B5             
0008+  08B5 01 00       table_power:.dw 1
0009+  08B7 0A 00       			.dw 10
0010+  08B9 64 00       			.dw 100
0011+  08BB E8 03       			.dw 1000
0012+  08BD 10 27       			.dw 10000
0013+  08BF             
0014+  08BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0015+  08BF             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0016+  08BF             ; ASCII in BL
0017+  08BF             ; result in AL
0018+  08BF             ; ascii for F = 0100 0110
0019+  08BF             ; ascii for 9 = 0011 1001
0020+  08BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0021+  08BF             hex_ascii_encode:
0022+  08BF 1B          	mov al, bl
0023+  08C0 93 40       	test al, $40				; test if letter or number
0024+  08C2 C7 C8 08    	jnz hex_letter
0025+  08C5 87 0F       	and al, $0F				; get number
0026+  08C7 09          	ret
0027+  08C8             hex_letter:
0028+  08C8 87 0F       	and al, $0F				; get letter
0029+  08CA 6A 09       	add al, 9
0030+  08CC 09          	ret
0031+  08CD             
0032+  08CD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0033+  08CD             ; ATOI
0034+  08CD             ; 2 letter hex string in B
0035+  08CD             ; 8bit integer returned in AL
0036+  08CD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0037+  08CD             atoi:
0038+  08CD D8          	push b
0039+  08CE 07 BF 08    	call hex_ascii_encode			; convert BL to 4bit code in AL
0040+  08D1 30          	mov bl, bh
0041+  08D2 DB          	push al					; save a
0042+  08D3 07 BF 08    	call hex_ascii_encode
0043+  08D6 EA          	pop bl	
0044+  08D7 FD 9E 04    	shl al, 4
0045+  08DA 8C          	or al, bl
0046+  08DB E5          	pop b
0047+  08DC 09          	ret	
0048+  08DD             
0049+  08DD             
0050+  08DD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  08DD             ; printf
0052+  08DD             ; no need for explanations!
0053+  08DD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0054+  08DD             printf:
0055+  08DD 09          	ret
0056+  08DE             
0057+  08DE             
0058+  08DE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  08DE             ; scanf
0060+  08DE             ; no need for explanations!
0061+  08DE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  08DE             scanf:
0063+  08DE 09          	ret
0064+  08DF             
0065+  08DF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  08DF             ; ITOA
0067+  08DF             ; 8bit value in BL
0068+  08DF             ; 2 byte ASCII result in A
0069+  08DF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0070+  08DF             itoa:
0071+  08DF DA          	push d
0072+  08E0 D8          	push b
0073+  08E1 A7 00       	mov bh, 0
0074+  08E3 FD A4 04    	shr bl, 4	
0075+  08E6 74          	mov d, b
0076+  08E7 1F A5 08    	mov al, [d + s_hex_digits]
0077+  08EA 23          	mov ah, al
0078+  08EB             	
0079+  08EB E5          	pop b
0080+  08EC D8          	push b
0081+  08ED A7 00       	mov bh, 0
0082+  08EF FD 87 0F    	and bl, $0F
0083+  08F2 74          	mov d, b
0084+  08F3 1F A5 08    	mov al, [d + s_hex_digits]
0085+  08F6 E5          	pop b
0086+  08F7 E7          	pop d
0087+  08F8 09          	ret
0088+  08F9             
0089+  08F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0090+  08F9             ; HEX STRING TO BINARY
0091+  08F9             ; di = destination address
0092+  08F9             ; si = source
0093+  08F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0094+  08F9             hex_to_int:
0095+  08F9             hex_to_int_L1:
0096+  08F9 F6          	lodsb					; load from [SI] to AL
0097+  08FA B9 00       	cmp al, 0				; check if ASCII 0
0098+  08FC C6 09 09    	jz hex_to_int_ret
0099+  08FF 36          	mov bh, al
0100+  0900 F6          	lodsb
0101+  0901 2F          	mov bl, al
0102+  0902 07 CD 08    	call atoi				; convert ASCII byte in B to int (to AL)
0103+  0905 F7          	stosb					; store AL to [DI]
0104+  0906 0A F9 08    	jmp hex_to_int_L1
0105+  0909             hex_to_int_ret:
0106+  0909 09          	ret		
0107+  090A             
0108+  090A             
0109+  090A             
0110+  090A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  090A             ; GETCHAR
0112+  090A             ; char in ah
0113+  090A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0114+  090A             getchar:
0115+  090A DB          	push al
0116+  090B             getchar_retry:
0117+  090B FD 0C       	sti
0118+  090D 19 01       	mov al, 1
0119+  090F 05 03       	syscall sys_io			; receive in AH
0120+  0911 B9 00       	cmp al, 0			; check if any char was receive
0121+  0913 C6 0B 09    	je getchar_retry
0122+  0916 E8          	pop al
0123+  0917 09          	ret
0124+  0918             
0125+  0918             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0126+  0918             ; PUTCHAR
0127+  0918             ; char in ah
0128+  0918             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  0918             putchar:
0130+  0918 D7          	push a
0131+  0919 19 00       	mov al, 0
0132+  091B 05 03       	syscall sys_io			; char in AH
0133+  091D E4          	pop a
0134+  091E 09          	ret
0135+  091F             
0136+  091F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0137+  091F             ;; INPUT A STRING
0138+  091F             ;; terminates with null
0139+  091F             ;; pointer in D
0140+  091F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  091F             gets:
0142+  091F D7          	push a
0143+  0920 DA          	push d
0144+  0921             gets_loop:
0145+  0921 FD 0C       	sti
0146+  0923 19 01       	mov al, 1
0147+  0925 05 03       	syscall sys_io			; receive in AH
0148+  0927 B9 00       	cmp al, 0				; check error code (AL)
0149+  0929 C6 21 09    	je gets_loop			; if no char received, retry
0150+  092C             
0151+  092C 76 1B       	cmp ah, 27
0152+  092E C6 4F 09    	je gets_telnet_escape
0153+  0931 76 0A       	cmp ah, $0A				; LF
0154+  0933 C6 A8 09    	je gets_end
0155+  0936 76 0D       	cmp ah, $0D				; CR
0156+  0938 C6 A8 09    	je gets_end
0157+  093B 76 5C       	cmp ah, $5C				; '\\'
0158+  093D C6 7F 09    	je gets_escape
0159+  0940             	
0160+  0940 76 08       	cmp ah, $08			; check for backspace
0161+  0942 C6 4B 09    	je gets_backspace
0162+  0945             
0163+  0945 1A          	mov al, ah
0164+  0946 3E          	mov [d], al
0165+  0947 79          	inc d
0166+  0948 0A 21 09    	jmp gets_loop
0167+  094B             gets_backspace:
0168+  094B 7F          	dec d
0169+  094C 0A 21 09    	jmp gets_loop
0170+  094F             gets_telnet_escape:
0171+  094F FD 0C       	sti
0172+  0951 19 01       	mov al, 1
0173+  0953 05 03       	syscall sys_io				; receive in AH without echo
0174+  0955 B9 00       	cmp al, 0					; check error code (AL)
0175+  0957 C6 4F 09    	je gets_telnet_escape		; if no char received, retry
0176+  095A 76 5B       	cmp ah, '['
0177+  095C C7 21 09    	jne gets_loop
0178+  095F             gets_telnet_escape_phase2:
0179+  095F FD 0C       	sti
0180+  0961 19 01       	mov al, 1
0181+  0963 05 03       	syscall sys_io					; receive in AH without echo
0182+  0965 B9 00       	cmp al, 0						; check error code (AL)
0183+  0967 C6 5F 09    	je gets_telnet_escape_phase2	; if no char received, retry
0184+  096A 76 44       	cmp ah, 'D'
0185+  096C C6 77 09    	je gets_left_arrow
0186+  096F 76 43       	cmp ah, 'C'
0187+  0971 C6 7B 09    	je gets_right_arrow
0188+  0974 0A 21 09    	jmp gets_loop
0189+  0977             gets_left_arrow:
0190+  0977 7F          	dec d
0191+  0978 0A 21 09    	jmp gets_loop
0192+  097B             gets_right_arrow:
0193+  097B 79          	inc d
0194+  097C 0A 21 09    	jmp gets_loop
0195+  097F             gets_escape:
0196+  097F FD 0C       	sti
0197+  0981 19 01       	mov al, 1
0198+  0983 05 03       	syscall sys_io			; receive in AH
0199+  0985 B9 00       	cmp al, 0				; check error code (AL)
0200+  0987 C6 7F 09    	je gets_escape			; if no char received, retry
0201+  098A 76 6E       	cmp ah, 'n'
0202+  098C C6 9A 09    	je gets_LF
0203+  098F 76 72       	cmp ah, 'r'
0204+  0991 C6 A1 09    	je gets_CR
0205+  0994 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0206+  0995 3E          	mov [d], al
0207+  0996 79          	inc d
0208+  0997 0A 21 09    	jmp gets_loop
0209+  099A             gets_LF:
0210+  099A 19 0A       	mov al, $0A
0211+  099C 3E          	mov [d], al
0212+  099D 79          	inc d
0213+  099E 0A 21 09    	jmp gets_loop
0214+  09A1             gets_CR:
0215+  09A1 19 0D       	mov al, $0D
0216+  09A3 3E          	mov [d], al
0217+  09A4 79          	inc d
0218+  09A5 0A 21 09    	jmp gets_loop
0219+  09A8             gets_end:
0220+  09A8 19 00       	mov al, 0
0221+  09AA 3E          	mov [d], al				; terminate string
0222+  09AB E7          	pop d
0223+  09AC E4          	pop a
0224+  09AD 09          	ret
0225+  09AE             
0226+  09AE             
0227+  09AE             
0228+  09AE             
0229+  09AE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0230+  09AE             ;; INPUT TEXT
0231+  09AE             ;; terminated with CTRL+D
0232+  09AE             ;; pointer in D
0233+  09AE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0234+  09AE             gettxt:
0235+  09AE D7          	push a
0236+  09AF DA          	push d
0237+  09B0             gettxt_loop:
0238+  09B0 19 01       	mov al, 1
0239+  09B2 05 03       	syscall sys_io			; receive in AH
0240+  09B4 B9 00       	cmp al, 0				; check error code (AL)
0241+  09B6 C6 B0 09    	je gettxt_loop		; if no char received, retry
0242+  09B9 76 04       	cmp ah, 4			; EOT
0243+  09BB C6 F9 09    	je gettxt_end
0244+  09BE 76 08       	cmp ah, $08			; check for backspace
0245+  09C0 C6 F5 09    	je gettxt_backspace
0246+  09C3 76 5C       	cmp ah, $5C				; '\\'
0247+  09C5 C6 CE 09    	je gettxt_escape
0248+  09C8 1A          	mov al, ah
0249+  09C9 3E          	mov [d], al
0250+  09CA 79          	inc d
0251+  09CB 0A B0 09    	jmp gettxt_loop
0252+  09CE             gettxt_escape:
0253+  09CE 19 01       	mov al, 1
0254+  09D0 05 03       	syscall sys_io			; receive in AH
0255+  09D2 B9 00       	cmp al, 0				; check error code (AL)
0256+  09D4 C6 CE 09    	je gettxt_escape		; if no char received, retry
0257+  09D7 76 6E       	cmp ah, 'n'
0258+  09D9 C6 E7 09    	je gettxt_LF
0259+  09DC 76 72       	cmp ah, 'r'
0260+  09DE C6 EE 09    	je gettxt_CR
0261+  09E1 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0262+  09E2 3E          	mov [d], al
0263+  09E3 79          	inc d
0264+  09E4 0A B0 09    	jmp gettxt_loop
0265+  09E7             gettxt_LF:
0266+  09E7 19 0A       	mov al, $0A
0267+  09E9 3E          	mov [d], al
0268+  09EA 79          	inc d
0269+  09EB 0A B0 09    	jmp gettxt_loop
0270+  09EE             gettxt_CR:
0271+  09EE 19 0D       	mov al, $0D
0272+  09F0 3E          	mov [d], al
0273+  09F1 79          	inc d
0274+  09F2 0A B0 09    	jmp gettxt_loop
0275+  09F5             gettxt_backspace:
0276+  09F5 7F          	dec d
0277+  09F6 0A B0 09    	jmp gettxt_loop
0278+  09F9             gettxt_end:
0279+  09F9 19 00       	mov al, 0
0280+  09FB 3E          	mov [d], al				; terminate string
0281+  09FC E7          	pop d
0282+  09FD E4          	pop a
0283+  09FE 09          	ret
0284+  09FF             
0285+  09FF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0286+  09FF             ; PRINT NEW LINE
0287+  09FF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  09FF             printnl:
0289+  09FF D7          	push a
0290+  0A00 10 00 0A    	mov a, $0A00
0291+  0A03 05 03       	syscall sys_io
0292+  0A05 10 00 0D    	mov a, $0D00
0293+  0A08 05 03       	syscall sys_io
0294+  0A0A E4          	pop a
0295+  0A0B 09          	ret
0296+  0A0C             
0297+  0A0C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0298+  0A0C             ; strtoint
0299+  0A0C             ; 4 digit hex string number in d
0300+  0A0C             ; integer returned in A
0301+  0A0C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0302+  0A0C             strtointx:
0303+  0A0C D8          	push b
0304+  0A0D 32          	mov bl, [d]
0305+  0A0E 37          	mov bh, bl
0306+  0A0F 33 01 00    	mov bl, [d + 1]
0307+  0A12 07 CD 08    	call atoi				; convert to int in AL
0308+  0A15 23          	mov ah, al				; move to AH
0309+  0A16 33 02 00    	mov bl, [d + 2]
0310+  0A19 37          	mov bh, bl
0311+  0A1A 33 03 00    	mov bl, [d + 3]
0312+  0A1D 07 CD 08    	call atoi				; convert to int in AL
0313+  0A20 E5          	pop b
0314+  0A21 09          	ret
0315+  0A22             
0316+  0A22             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0317+  0A22             ; strtoint
0318+  0A22             ; 5 digit base10 string number in d
0319+  0A22             ; integer returned in A
0320+  0A22             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0321+  0A22             strtoint:
0322+  0A22 E2          	push si
0323+  0A23 D8          	push b
0324+  0A24 D9          	push c
0325+  0A25 DA          	push d
0326+  0A26 07 55 08    	call strlen			; get string length in C
0327+  0A29 7E          	dec c
0328+  0A2A FD 4E       	mov si, d
0329+  0A2C 12          	mov a, c
0330+  0A2D FD 99       	shl a
0331+  0A2F 3B B5 08    	mov d, table_power
0332+  0A32 59          	add d, a
0333+  0A33 38 00 00    	mov c, 0
0334+  0A36             strtoint_L0:
0335+  0A36 F6          	lodsb			; load ASCII to al
0336+  0A37 B9 00       	cmp al, 0
0337+  0A39 C6 4C 0A    	je strtoint_end
0338+  0A3C 6F 30       	sub al, $30		; make into integer
0339+  0A3E 22 00       	mov ah, 0
0340+  0A40 2A          	mov b, [d]
0341+  0A41 AC          	mul a, b			; result in B since it fits in 16bits
0342+  0A42 11          	mov a, b
0343+  0A43 28          	mov b, c
0344+  0A44 54          	add a, b
0345+  0A45 39          	mov c, a
0346+  0A46 63 02 00    	sub d, 2
0347+  0A49 0A 36 0A    	jmp strtoint_L0
0348+  0A4C             strtoint_end:
0349+  0A4C 12          	mov a, c
0350+  0A4D E7          	pop d
0351+  0A4E E6          	pop c
0352+  0A4F E5          	pop b
0353+  0A50 EF          	pop si
0354+  0A51 09          	ret
0355+  0A52             
0356+  0A52             
0357+  0A52             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0358+  0A52             ; PRINT NULL TERMINATED STRING
0359+  0A52             ; pointer in D
0360+  0A52             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0361+  0A52             puts:
0362+  0A52 D7          	push a
0363+  0A53 DA          	push d
0364+  0A54             puts_L1:
0365+  0A54 1E          	mov al, [d]
0366+  0A55 B9 00       	cmp al, 0
0367+  0A57 C6 63 0A    	jz puts_END
0368+  0A5A 23          	mov ah, al
0369+  0A5B 19 00       	mov al, 0
0370+  0A5D 05 03       	syscall sys_io
0371+  0A5F 79          	inc d
0372+  0A60 0A 54 0A    	jmp puts_L1
0373+  0A63             puts_END:
0374+  0A63 E7          	pop d
0375+  0A64 E4          	pop a
0376+  0A65 09          	ret
0377+  0A66             
0378+  0A66             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  0A66             ; PRINT N SIZE STRING
0380+  0A66             ; pointer in D
0381+  0A66             ; size in C
0382+  0A66             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0383+  0A66             putsn:
0384+  0A66 DB          	push al
0385+  0A67 DA          	push d
0386+  0A68 D9          	push c
0387+  0A69             putsn_L0:
0388+  0A69 1E          	mov al, [d]
0389+  0A6A 23          	mov ah, al
0390+  0A6B 19 00       	mov al, 0
0391+  0A6D 05 03       	syscall sys_io
0392+  0A6F 79          	inc d
0393+  0A70 7E          	dec c	
0394+  0A71 C2 00 00    	cmp c, 0
0395+  0A74 C7 69 0A    	jne putsn_L0
0396+  0A77             putsn_end:
0397+  0A77 E6          	pop c
0398+  0A78 E7          	pop d
0399+  0A79 E8          	pop al
0400+  0A7A 09          	ret
0401+  0A7B             
0402+  0A7B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0403+  0A7B             ; print 16bit decimal number
0404+  0A7B             ; input number in A
0405+  0A7B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  0A7B             print_u16d:
0407+  0A7B D7          	push a
0408+  0A7C D8          	push b
0409+  0A7D 26 10 27    	mov b, 10000
0410+  0A80 AE          	div a, b			; get 10000 coeff.
0411+  0A81 07 A7 0A    	call print_number
0412+  0A84 11          	mov a, b
0413+  0A85 26 E8 03    	mov b, 1000
0414+  0A88 AE          	div a, b			; get 10000 coeff.
0415+  0A89 07 A7 0A    	call print_number
0416+  0A8C 11          	mov a, b
0417+  0A8D 26 64 00    	mov b, 100
0418+  0A90 AE          	div a, b
0419+  0A91 07 A7 0A    	call print_number
0420+  0A94 11          	mov a, b
0421+  0A95 26 0A 00    	mov b, 10
0422+  0A98 AE          	div a, b
0423+  0A99 07 A7 0A    	call print_number
0424+  0A9C 11          	mov a, b
0425+  0A9D 6A 30       	add al, $30
0426+  0A9F 23          	mov ah, al
0427+  0AA0 19 00       	mov al, 0
0428+  0AA2 05 03       	syscall sys_io	; print coeff
0429+  0AA4 E5          	pop b
0430+  0AA5 E4          	pop a
0431+  0AA6 09          	ret
0432+  0AA7             
0433+  0AA7             
0434+  0AA7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0435+  0AA7             ; if A == 0, print space
0436+  0AA7             ; else print A
0437+  0AA7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0438+  0AA7             print_number:
0439+  0AA7 6A 30       	add al, $30
0440+  0AA9 23          	mov ah, al
0441+  0AAA 07 18 09    	call putchar
0442+  0AAD 09          	ret
0443+  0AAE             
0444+  0AAE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  0AAE             ; PRINT 16BIT HEX INTEGER
0446+  0AAE             ; integer value in reg B
0447+  0AAE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  0AAE             print_u16x:
0449+  0AAE D7          	push a
0450+  0AAF D8          	push b
0451+  0AB0 DD          	push bl
0452+  0AB1 30          	mov bl, bh
0453+  0AB2 07 DF 08    	call itoa				; convert bh to char in A
0454+  0AB5 2F          	mov bl, al				; save al
0455+  0AB6 19 00       	mov al, 0
0456+  0AB8 05 03       	syscall sys_io				; display AH
0457+  0ABA 24          	mov ah, bl				; retrieve al
0458+  0ABB 19 00       	mov al, 0
0459+  0ABD 05 03       	syscall sys_io				; display AL
0460+  0ABF             
0461+  0ABF EA          	pop bl
0462+  0AC0 07 DF 08    	call itoa				; convert bh to char in A
0463+  0AC3 2F          	mov bl, al				; save al
0464+  0AC4 19 00       	mov al, 0
0465+  0AC6 05 03       	syscall sys_io				; display AH
0466+  0AC8 24          	mov ah, bl				; retrieve al
0467+  0AC9 19 00       	mov al, 0
0468+  0ACB 05 03       	syscall sys_io				; display AL
0469+  0ACD             
0470+  0ACD E5          	pop b
0471+  0ACE E4          	pop a
0472+  0ACF 09          	ret
0473+  0AD0             
0474+  0AD0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0475+  0AD0             ; INPUT 16BIT HEX INTEGER
0476+  0AD0             ; read 16bit integer into A
0477+  0AD0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0478+  0AD0             scan_u16x:
0479+  0AD0 F8 10 00    	enter 16
0480+  0AD3 D8          	push b
0481+  0AD4 DA          	push d
0482+  0AD5             
0483+  0AD5 FA F1 FF    	lea d, [bp + -15]
0484+  0AD8 07 1F 09    	call gets				; get number
0485+  0ADB             
0486+  0ADB 32          	mov bl, [d]
0487+  0ADC 37          	mov bh, bl
0488+  0ADD 33 01 00    	mov bl, [d + 1]
0489+  0AE0 07 CD 08    	call atoi				; convert to int in AL
0490+  0AE3 23          	mov ah, al				; move to AH
0491+  0AE4             
0492+  0AE4 33 02 00    	mov bl, [d + 2]
0493+  0AE7 37          	mov bh, bl
0494+  0AE8 33 03 00    	mov bl, [d + 3]
0495+  0AEB 07 CD 08    	call atoi				; convert to int in AL
0496+  0AEE             
0497+  0AEE E7          	pop d
0498+  0AEF E5          	pop b
0499+  0AF0 F9          	leave
0500+  0AF1 09          	ret
0501+  0AF2             
0502+  0AF2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0503+  0AF2             ; PRINT 8bit HEX INTEGER
0504+  0AF2             ; integer value in reg bl
0505+  0AF2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0506+  0AF2             print_u8x:
0507+  0AF2 D7          	push a
0508+  0AF3 DD          	push bl
0509+  0AF4             
0510+  0AF4 07 DF 08    	call itoa				; convert bl to char in A
0511+  0AF7 2F          	mov bl, al				; save al
0512+  0AF8 19 00       	mov al, 0
0513+  0AFA 05 03       	syscall sys_io				; display AH
0514+  0AFC 24          	mov ah, bl				; retrieve al
0515+  0AFD 19 00       	mov al, 0
0516+  0AFF 05 03       	syscall sys_io				; display AL
0517+  0B01             
0518+  0B01 EA          	pop bl
0519+  0B02 E4          	pop a
0520+  0B03 09          	ret
0521+  0B04             
0522+  0B04             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0523+  0B04             ; print 8bit decimal unsigned number
0524+  0B04             ; input number in AL
0525+  0B04             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0526+  0B04             print_u8d:
0527+  0B04 D7          	push a
0528+  0B05 D8          	push b
0529+  0B06             
0530+  0B06 22 00       	mov ah, 0
0531+  0B08 26 64 00    	mov b, 100
0532+  0B0B AE          	div a, b
0533+  0B0C D8          	push b			; save remainder
0534+  0B0D B9 00       	cmp al, 0
0535+  0B0F C6 19 0B    	je skip100
0536+  0B12 6A 30       	add al, $30
0537+  0B14 23          	mov ah, al
0538+  0B15 19 00       	mov al, 0
0539+  0B17 05 03       	syscall sys_io	; print coeff
0540+  0B19             skip100:
0541+  0B19 E4          	pop a
0542+  0B1A 22 00       	mov ah, 0
0543+  0B1C 26 0A 00    	mov b, 10
0544+  0B1F AE          	div a, b
0545+  0B20 D8          	push b			; save remainder
0546+  0B21 B9 00       	cmp al, 0
0547+  0B23 C6 2D 0B    	je skip10
0548+  0B26 6A 30       	add al, $30
0549+  0B28 23          	mov ah, al
0550+  0B29 19 00       	mov al, 0
0551+  0B2B 05 03       	syscall sys_io	; print coeff
0552+  0B2D             skip10:
0553+  0B2D E4          	pop a
0554+  0B2E 1B          	mov al, bl
0555+  0B2F 6A 30       	add al, $30
0556+  0B31 23          	mov ah, al
0557+  0B32 19 00       	mov al, 0
0558+  0B34 05 03       	syscall sys_io	; print coeff
0559+  0B36 E5          	pop b
0560+  0B37 E4          	pop a
0561+  0B38 09          	ret
0562+  0B39             
0563+  0B39             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0564+  0B39             ; INPUT 8BIT HEX INTEGER
0565+  0B39             ; read 8bit integer into AL
0566+  0B39             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0567+  0B39             scan_u8x:
0568+  0B39 F8 04 00    	enter 4
0569+  0B3C D8          	push b
0570+  0B3D DA          	push d
0571+  0B3E             
0572+  0B3E FA FD FF    	lea d, [bp + -3]
0573+  0B41 07 1F 09    	call gets				; get number
0574+  0B44             
0575+  0B44 32          	mov bl, [d]
0576+  0B45 37          	mov bh, bl
0577+  0B46 33 01 00    	mov bl, [d + 1]
0578+  0B49 07 CD 08    	call atoi				; convert to int in AL
0579+  0B4C             
0580+  0B4C E7          	pop d
0581+  0B4D E5          	pop b
0582+  0B4E F9          	leave
0583+  0B4F 09          	ret
0584+  0B50             
0585+  0B50             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0586+  0B50             ; input decimal number
0587+  0B50             ; result in A
0588+  0B50             ; 655'\0'
0589+  0B50             ; low--------high
0590+  0B50             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0591+  0B50             scan_u16d:
0592+  0B50 F8 08 00    	enter 8
0593+  0B53 E2          	push si
0594+  0B54 D8          	push b
0595+  0B55 D9          	push c
0596+  0B56 DA          	push d
0597+  0B57 FA F9 FF    	lea d, [bp +- 7]
0598+  0B5A 07 1F 09    	call gets
0599+  0B5D 07 55 08    	call strlen			; get string length in C
0600+  0B60 7E          	dec c
0601+  0B61 FD 4E       	mov si, d
0602+  0B63 12          	mov a, c
0603+  0B64 FD 99       	shl a
0604+  0B66 3B B5 08    	mov d, table_power
0605+  0B69 59          	add d, a
0606+  0B6A 38 00 00    	mov c, 0
0607+  0B6D             mul_loop:
0608+  0B6D F6          	lodsb			; load ASCII to al
0609+  0B6E B9 00       	cmp al, 0
0610+  0B70 C6 83 0B    	je mul_exit
0611+  0B73 6F 30       	sub al, $30		; make into integer
0612+  0B75 22 00       	mov ah, 0
0613+  0B77 2A          	mov b, [d]
0614+  0B78 AC          	mul a, b			; result in B since it fits in 16bits
0615+  0B79 11          	mov a, b
0616+  0B7A 28          	mov b, c
0617+  0B7B 54          	add a, b
0618+  0B7C 39          	mov c, a
0619+  0B7D 63 02 00    	sub d, 2
0620+  0B80 0A 6D 0B    	jmp mul_loop
0621+  0B83             mul_exit:
0622+  0B83 12          	mov a, c
0623+  0B84 E7          	pop d
0624+  0B85 E6          	pop c
0625+  0B86 E5          	pop b
0626+  0B87 EF          	pop si
0627+  0B88 F9          	leave
0628+  0B89 09          	ret
0441   0B8A             
0442   0B8A             		
0443   0B8A             			.end
0444   0B8A             			
0445   0B8A             
tasm: Number of errors = 0
