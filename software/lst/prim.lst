0001   0000             .include "kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0002   0000             
0003   0400             .org PROC_TEXT_ORG
0004   0400             
0005   0400             primes:
0006   0400 FD 47 FF FF 	mov sp, $FFFF
0007   0404 FD 49 FF FF 	mov bp, $FFFF
0008   0408             
0009   0408 10 00 00    	mov a, 0
0010   040B 42 2B 0A    	mov [prog], a
0011   040E 07 8C 08    	call get_token
0012   0411 1D 2E 0A    	mov al, [tok]
0013   0414 B9 14       	cmp al, TOK_END
0014   0416 C6 78 04    	je bad_args
0015   0419 3B 2F 0A    	mov d, tokstr
0016   041C 07 9D 06    	call strtoint
0017   041F 42 EB 0B    	mov [min], a
0018   0422 07 8C 08    	call get_token
0019   0425 1D 2E 0A    	mov al, [tok]
0020   0428 B9 14       	cmp al, TOK_END
0021   042A C6 78 04    	je bad_args
0022   042D 3B 2F 0A    	mov d, tokstr
0023   0430 07 9D 06    	call strtoint
0024   0433 42 E9 0B    	mov [max], a
0025   0436             	
0026   0436 14 EB 0B    	mov a, [min]
0027   0439             primes_L1:
0028   0439 38 02 00    	mov c, 2	
0029   043C             primes_L2:
0030   043C D7          	push a
0031   043D 28          	mov b, c
0032   043E AE          	div a, b
0033   043F C0 00 00    	cmp b, 0
0034   0442 C6 4A 04    	jz divisible
0035   0445 78          	inc c
0036   0446 E4          	pop a
0037   0447 0A 3C 04    	jmp primes_L2		
0038   044A             divisible:
0039   044A E4          	pop a
0040   044B B1          	cmp a, c
0041   044C C7 72 04    	jnz notprime			
0042   044F             isprime:
0043   044F 07 F6 06    	call print_u16d
0044   0452             	
0045   0452 D7          	push a
0046   0453 14 E7 0B    	mov a, [total]
0047   0456 77          	inc a
0048   0457 42 E7 0B    	mov [total], a
0049   045A 3B FC 0B    	mov d, s_total
0050   045D 07 CD 06    	call puts
0051   0460 07 F6 06    	call print_u16d
0052   0463             	
0053   0463 E4          	pop a
0054   0464             
0055   0464 07 7A 06    	call printnl
0056   0467 77          	inc a
0057   0468 29 E9 0B    	mov b, [max]
0058   046B B0          	cmp a, b
0059   046C C9 76 04    	jgeu primes_ret
0060   046F 0A 39 04    	jmp primes_L1
0061   0472             notprime:
0062   0472 77          	inc a
0063   0473 0A 39 04    	jmp primes_L1		
0064   0476             primes_ret:
0065   0476 05 0B       	syscall sys_terminate_proc
0066   0478             
0067   0478             bad_args:
0068   0478 3B CC 0B    	mov d, s_usage
0069   047B 07 CD 06    	call puts
0070   047E 0A 76 04    	jmp primes_ret
0071   0481             
0072   0481             .include "stdio.asm"
0001+  0481             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0481             ; stdio.s
0003+  0481             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0481             .include "string.asm"
0001++ 0481             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0481             ; string.s
0003++ 0481             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0481             
0005++ 0481             
0006++ 0481             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0481             ; strrev
0008++ 0481             ; reverse a string
0009++ 0481             ; D = string address
0010++ 0481             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0481             ; 01234
0012++ 0481             strrev:
0013++ 0481 4B          	pusha
0014++ 0482 07 C8 04    	call strlen	; length in C
0015++ 0485 12          	mov a, c
0016++ 0486 AF 01 00    	cmp a, 1
0017++ 0489 D0 A3 04    	jleu strrev_end	; check string length. string len must be > 1
0018++ 048C 7D          	dec a
0019++ 048D FD 4E       	mov si, d	; beginning of string
0020++ 048F FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0491 59          	add d, a	; end of string
0022++ 0492 12          	mov a, c
0023++ 0493 FD 9B       	shr a		; divide by 2
0024++ 0495 39          	mov c, a	; C now counts the steps
0025++ 0496             strrev_L0:
0026++ 0496 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0497 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0498 3E          	mov [d], al	; store left char into right side
0029++ 0499 1B          	mov al, bl
0030++ 049A F7          	stosb		; store right-side char into left-side; increase DI
0031++ 049B 7E          	dec c
0032++ 049C 7F          	dec d
0033++ 049D C2 00 00    	cmp c, 0
0034++ 04A0 C7 96 04    	jne strrev_L0
0035++ 04A3             strrev_end:
0036++ 04A3 4C          	popa
0037++ 04A4 09          	ret
0038++ 04A5             	
0039++ 04A5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 04A5             ; strchr
0041++ 04A5             ; search string in D for char in AL
0042++ 04A5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 04A5             strchr:
0044++ 04A5             strchr_L0:
0045++ 04A5 32          	mov bl, [d]
0046++ 04A6 C1 00       	cmp bl, 0
0047++ 04A8 C6 B3 04    	je strchr_end
0048++ 04AB BA          	cmp al, bl
0049++ 04AC C6 B3 04    	je strchr_end
0050++ 04AF 79          	inc d
0051++ 04B0 0A A5 04    	jmp strchr_L0
0052++ 04B3             strchr_end:
0053++ 04B3 1B          	mov al, bl
0054++ 04B4 09          	ret
0055++ 04B5             
0056++ 04B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 04B5             ; strstr
0058++ 04B5             ; find sub-string
0059++ 04B5             ; str1 in SI
0060++ 04B5             ; str2 in DI
0061++ 04B5             ; SI points to end of source string
0062++ 04B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 04B5             strstr:
0064++ 04B5 DB          	push al
0065++ 04B6 DA          	push d
0066++ 04B7 E3          	push di
0067++ 04B8             strstr_loop:
0068++ 04B8 F3          	cmpsb					; compare a byte of the strings
0069++ 04B9 C7 C4 04    	jne strstr_ret
0070++ 04BC FC 00 00    	lea d, [di + 0]
0071++ 04BF BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 04C1 C7 B8 04    	jne strstr_loop				; equal chars but not at end
0073++ 04C4             strstr_ret:
0074++ 04C4 F0          	pop di
0075++ 04C5 E7          	pop d
0076++ 04C6 E8          	pop al
0077++ 04C7 09          	ret
0078++ 04C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 04C8             ; length of null terminated string
0080++ 04C8             ; result in C
0081++ 04C8             ; pointer in D
0082++ 04C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 04C8             strlen:
0084++ 04C8 DA          	push d
0085++ 04C9 38 00 00    	mov c, 0
0086++ 04CC             strlen_L1:
0087++ 04CC BD 00       	cmp byte [d], 0
0088++ 04CE C6 D6 04    	je strlen_ret
0089++ 04D1 79          	inc d
0090++ 04D2 78          	inc c
0091++ 04D3 0A CC 04    	jmp strlen_L1
0092++ 04D6             strlen_ret:
0093++ 04D6 E7          	pop d
0094++ 04D7 09          	ret
0095++ 04D8             
0096++ 04D8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 04D8             ; STRCMP
0098++ 04D8             ; compare two strings
0099++ 04D8             ; str1 in SI
0100++ 04D8             ; str2 in DI
0101++ 04D8             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 04D8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 04D8             strcmp:
0104++ 04D8 DB          	push al
0105++ 04D9 DA          	push d
0106++ 04DA E3          	push di
0107++ 04DB E2          	push si
0108++ 04DC             strcmp_loop:
0109++ 04DC F3          	cmpsb					; compare a byte of the strings
0110++ 04DD C7 E8 04    	jne strcmp_ret
0111++ 04E0 FB FF FF    	lea d, [si +- 1]
0112++ 04E3 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 04E5 C7 DC 04    	jne strcmp_loop				; equal chars but not at end
0114++ 04E8             strcmp_ret:
0115++ 04E8 EF          	pop si
0116++ 04E9 F0          	pop di
0117++ 04EA E7          	pop d
0118++ 04EB E8          	pop al
0119++ 04EC 09          	ret
0120++ 04ED             
0121++ 04ED             
0122++ 04ED             ; STRCPY
0123++ 04ED             ; copy null terminated string from SI to DI
0124++ 04ED             ; source in SI
0125++ 04ED             ; destination in DI
0126++ 04ED             strcpy:
0127++ 04ED E2          	push si
0128++ 04EE E3          	push di
0129++ 04EF DB          	push al
0130++ 04F0             strcpy_L1:
0131++ 04F0 F6          	lodsb
0132++ 04F1 F7          	stosb
0133++ 04F2 B9 00       	cmp al, 0
0134++ 04F4 C7 F0 04    	jne strcpy_L1
0135++ 04F7             strcpy_end:
0136++ 04F7 E8          	pop al
0137++ 04F8 F0          	pop di
0138++ 04F9 EF          	pop si
0139++ 04FA 09          	ret
0140++ 04FB             
0141++ 04FB             ; STRCAT
0142++ 04FB             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 04FB             ; source in SI
0144++ 04FB             ; destination in DI
0145++ 04FB             strcat:
0146++ 04FB E2          	push si
0147++ 04FC E3          	push di
0148++ 04FD D7          	push a
0149++ 04FE DA          	push d
0150++ 04FF 50          	mov a, di
0151++ 0500 3C          	mov d, a
0152++ 0501             strcat_goto_end_L1:
0153++ 0501 BD 00       	cmp byte[d], 0
0154++ 0503 C6 0A 05    	je strcat_start
0155++ 0506 79          	inc d
0156++ 0507 0A 01 05    	jmp strcat_goto_end_L1
0157++ 050A             strcat_start:
0158++ 050A FD 50       	mov di, d
0159++ 050C             strcat_L1:
0160++ 050C F6          	lodsb
0161++ 050D F7          	stosb
0162++ 050E B9 00       	cmp al, 0
0163++ 0510 C7 0C 05    	jne strcat_L1
0164++ 0513             strcat_end:
0165++ 0513 E7          	pop d
0166++ 0514 E4          	pop a
0167++ 0515 F0          	pop di
0168++ 0516 EF          	pop si
0169++ 0517 09          	ret
0005+  0518             
0006+  0518 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  051C 34 35 36 37 
0006+  0520 38 39 41 42 
0006+  0524 43 44 45 46 
0007+  0528 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  052C 1B 5B 48 00 
0008+  0530             
0009+  0530 01 00       table_power:.dw 1
0010+  0532 0A 00       			.dw 10
0011+  0534 64 00       			.dw 100
0012+  0536 E8 03       			.dw 1000
0013+  0538 10 27       			.dw 10000
0014+  053A             
0015+  053A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  053A             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  053A             ; ASCII in BL
0018+  053A             ; result in AL
0019+  053A             ; ascii for F = 0100 0110
0020+  053A             ; ascii for 9 = 0011 1001
0021+  053A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  053A             hex_ascii_encode:
0023+  053A 1B          	mov al, bl
0024+  053B 93 40       	test al, $40				; test if letter or number
0025+  053D C7 43 05    	jnz hex_letter
0026+  0540 87 0F       	and al, $0F				; get number
0027+  0542 09          	ret
0028+  0543             hex_letter:
0029+  0543 87 0F       	and al, $0F				; get letter
0030+  0545 6A 09       	add al, 9
0031+  0547 09          	ret
0032+  0548             
0033+  0548             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  0548             ; ATOI
0035+  0548             ; 2 letter hex string in B
0036+  0548             ; 8bit integer returned in AL
0037+  0548             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0548             atoi:
0039+  0548 D8          	push b
0040+  0549 07 3A 05    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  054C 30          	mov bl, bh
0042+  054D DB          	push al					; save a
0043+  054E 07 3A 05    	call hex_ascii_encode
0044+  0551 EA          	pop bl	
0045+  0552 FD 9E 04    	shl al, 4
0046+  0555 8C          	or al, bl
0047+  0556 E5          	pop b
0048+  0557 09          	ret	
0049+  0558             
0050+  0558             
0051+  0558             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  0558             ; printf
0053+  0558             ; no need for explanations!
0054+  0558             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0558             printf:
0056+  0558 09          	ret
0057+  0559             
0058+  0559             
0059+  0559             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  0559             ; scanf
0061+  0559             ; no need for explanations!
0062+  0559             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  0559             scanf:
0064+  0559 09          	ret
0065+  055A             
0066+  055A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  055A             ; ITOA
0068+  055A             ; 8bit value in BL
0069+  055A             ; 2 byte ASCII result in A
0070+  055A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  055A             itoa:
0072+  055A DA          	push d
0073+  055B D8          	push b
0074+  055C A7 00       	mov bh, 0
0075+  055E FD A4 04    	shr bl, 4	
0076+  0561 74          	mov d, b
0077+  0562 1F 18 05    	mov al, [d + s_hex_digits]
0078+  0565 23          	mov ah, al
0079+  0566             	
0080+  0566 E5          	pop b
0081+  0567 D8          	push b
0082+  0568 A7 00       	mov bh, 0
0083+  056A FD 87 0F    	and bl, $0F
0084+  056D 74          	mov d, b
0085+  056E 1F 18 05    	mov al, [d + s_hex_digits]
0086+  0571 E5          	pop b
0087+  0572 E7          	pop d
0088+  0573 09          	ret
0089+  0574             
0090+  0574             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  0574             ; HEX STRING TO BINARY
0092+  0574             ; di = destination address
0093+  0574             ; si = source
0094+  0574             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  0574             hex_to_int:
0096+  0574             hex_to_int_L1:
0097+  0574 F6          	lodsb					; load from [SI] to AL
0098+  0575 B9 00       	cmp al, 0				; check if ASCII 0
0099+  0577 C6 84 05    	jz hex_to_int_ret
0100+  057A 36          	mov bh, al
0101+  057B F6          	lodsb
0102+  057C 2F          	mov bl, al
0103+  057D 07 48 05    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  0580 F7          	stosb					; store AL to [DI]
0105+  0581 0A 74 05    	jmp hex_to_int_L1
0106+  0584             hex_to_int_ret:
0107+  0584 09          	ret		
0108+  0585             
0109+  0585             
0110+  0585             
0111+  0585             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  0585             ; GETCHAR
0113+  0585             ; char in ah
0114+  0585             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  0585             getchar:
0116+  0585 DB          	push al
0117+  0586             getchar_retry:
0118+  0586 FD 0C       	sti
0119+  0588 19 01       	mov al, 1
0120+  058A 05 03       	syscall sys_io			; receive in AH
0121+  058C B9 00       	cmp al, 0			; check if any char was receive
0122+  058E C6 86 05    	je getchar_retry
0123+  0591 E8          	pop al
0124+  0592 09          	ret
0125+  0593             
0126+  0593             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  0593             ; PUTCHAR
0128+  0593             ; char in ah
0129+  0593             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0593             putchar:
0131+  0593 D7          	push a
0132+  0594 19 00       	mov al, 0
0133+  0596 05 03       	syscall sys_io			; char in AH
0134+  0598 E4          	pop a
0135+  0599 09          	ret
0136+  059A             
0137+  059A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  059A             ;; INPUT A STRING
0139+  059A             ;; terminates with null
0140+  059A             ;; pointer in D
0141+  059A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  059A             gets:
0143+  059A D7          	push a
0144+  059B DA          	push d
0145+  059C             gets_loop:
0146+  059C FD 0C       	sti
0147+  059E 19 01       	mov al, 1
0148+  05A0 05 03       	syscall sys_io			; receive in AH
0149+  05A2 B9 00       	cmp al, 0				; check error code (AL)
0150+  05A4 C6 9C 05    	je gets_loop			; if no char received, retry
0151+  05A7             
0152+  05A7 76 1B       	cmp ah, 27
0153+  05A9 C6 CA 05    	je gets_telnet_escape
0154+  05AC 76 0A       	cmp ah, $0A				; LF
0155+  05AE C6 23 06    	je gets_end
0156+  05B1 76 0D       	cmp ah, $0D				; CR
0157+  05B3 C6 23 06    	je gets_end
0158+  05B6 76 5C       	cmp ah, $5C				; '\\'
0159+  05B8 C6 FA 05    	je gets_escape
0160+  05BB             	
0161+  05BB 76 08       	cmp ah, $08			; check for backspace
0162+  05BD C6 C6 05    	je gets_backspace
0163+  05C0             
0164+  05C0 1A          	mov al, ah
0165+  05C1 3E          	mov [d], al
0166+  05C2 79          	inc d
0167+  05C3 0A 9C 05    	jmp gets_loop
0168+  05C6             gets_backspace:
0169+  05C6 7F          	dec d
0170+  05C7 0A 9C 05    	jmp gets_loop
0171+  05CA             gets_telnet_escape:
0172+  05CA FD 0C       	sti
0173+  05CC 19 01       	mov al, 1
0174+  05CE 05 03       	syscall sys_io				; receive in AH without echo
0175+  05D0 B9 00       	cmp al, 0					; check error code (AL)
0176+  05D2 C6 CA 05    	je gets_telnet_escape		; if no char received, retry
0177+  05D5 76 5B       	cmp ah, '['
0178+  05D7 C7 9C 05    	jne gets_loop
0179+  05DA             gets_telnet_escape_phase2:
0180+  05DA FD 0C       	sti
0181+  05DC 19 01       	mov al, 1
0182+  05DE 05 03       	syscall sys_io					; receive in AH without echo
0183+  05E0 B9 00       	cmp al, 0						; check error code (AL)
0184+  05E2 C6 DA 05    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  05E5 76 44       	cmp ah, 'D'
0186+  05E7 C6 F2 05    	je gets_left_arrow
0187+  05EA 76 43       	cmp ah, 'C'
0188+  05EC C6 F6 05    	je gets_right_arrow
0189+  05EF 0A 9C 05    	jmp gets_loop
0190+  05F2             gets_left_arrow:
0191+  05F2 7F          	dec d
0192+  05F3 0A 9C 05    	jmp gets_loop
0193+  05F6             gets_right_arrow:
0194+  05F6 79          	inc d
0195+  05F7 0A 9C 05    	jmp gets_loop
0196+  05FA             gets_escape:
0197+  05FA FD 0C       	sti
0198+  05FC 19 01       	mov al, 1
0199+  05FE 05 03       	syscall sys_io			; receive in AH
0200+  0600 B9 00       	cmp al, 0				; check error code (AL)
0201+  0602 C6 FA 05    	je gets_escape			; if no char received, retry
0202+  0605 76 6E       	cmp ah, 'n'
0203+  0607 C6 15 06    	je gets_LF
0204+  060A 76 72       	cmp ah, 'r'
0205+  060C C6 1C 06    	je gets_CR
0206+  060F 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  0610 3E          	mov [d], al
0208+  0611 79          	inc d
0209+  0612 0A 9C 05    	jmp gets_loop
0210+  0615             gets_LF:
0211+  0615 19 0A       	mov al, $0A
0212+  0617 3E          	mov [d], al
0213+  0618 79          	inc d
0214+  0619 0A 9C 05    	jmp gets_loop
0215+  061C             gets_CR:
0216+  061C 19 0D       	mov al, $0D
0217+  061E 3E          	mov [d], al
0218+  061F 79          	inc d
0219+  0620 0A 9C 05    	jmp gets_loop
0220+  0623             gets_end:
0221+  0623 19 00       	mov al, 0
0222+  0625 3E          	mov [d], al				; terminate string
0223+  0626 E7          	pop d
0224+  0627 E4          	pop a
0225+  0628 09          	ret
0226+  0629             
0227+  0629             
0228+  0629             
0229+  0629             
0230+  0629             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  0629             ;; INPUT TEXT
0232+  0629             ;; terminated with CTRL+D
0233+  0629             ;; pointer in D
0234+  0629             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  0629             gettxt:
0236+  0629 D7          	push a
0237+  062A DA          	push d
0238+  062B             gettxt_loop:
0239+  062B 19 01       	mov al, 1
0240+  062D 05 03       	syscall sys_io			; receive in AH
0241+  062F B9 00       	cmp al, 0				; check error code (AL)
0242+  0631 C6 2B 06    	je gettxt_loop		; if no char received, retry
0243+  0634 76 04       	cmp ah, 4			; EOT
0244+  0636 C6 74 06    	je gettxt_end
0245+  0639 76 08       	cmp ah, $08			; check for backspace
0246+  063B C6 70 06    	je gettxt_backspace
0247+  063E 76 5C       	cmp ah, $5C				; '\\'
0248+  0640 C6 49 06    	je gettxt_escape
0249+  0643 1A          	mov al, ah
0250+  0644 3E          	mov [d], al
0251+  0645 79          	inc d
0252+  0646 0A 2B 06    	jmp gettxt_loop
0253+  0649             gettxt_escape:
0254+  0649 19 01       	mov al, 1
0255+  064B 05 03       	syscall sys_io			; receive in AH
0256+  064D B9 00       	cmp al, 0				; check error code (AL)
0257+  064F C6 49 06    	je gettxt_escape		; if no char received, retry
0258+  0652 76 6E       	cmp ah, 'n'
0259+  0654 C6 62 06    	je gettxt_LF
0260+  0657 76 72       	cmp ah, 'r'
0261+  0659 C6 69 06    	je gettxt_CR
0262+  065C 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  065D 3E          	mov [d], al
0264+  065E 79          	inc d
0265+  065F 0A 2B 06    	jmp gettxt_loop
0266+  0662             gettxt_LF:
0267+  0662 19 0A       	mov al, $0A
0268+  0664 3E          	mov [d], al
0269+  0665 79          	inc d
0270+  0666 0A 2B 06    	jmp gettxt_loop
0271+  0669             gettxt_CR:
0272+  0669 19 0D       	mov al, $0D
0273+  066B 3E          	mov [d], al
0274+  066C 79          	inc d
0275+  066D 0A 2B 06    	jmp gettxt_loop
0276+  0670             gettxt_backspace:
0277+  0670 7F          	dec d
0278+  0671 0A 2B 06    	jmp gettxt_loop
0279+  0674             gettxt_end:
0280+  0674 19 00       	mov al, 0
0281+  0676 3E          	mov [d], al				; terminate string
0282+  0677 E7          	pop d
0283+  0678 E4          	pop a
0284+  0679 09          	ret
0285+  067A             
0286+  067A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  067A             ; PRINT NEW LINE
0288+  067A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  067A             printnl:
0290+  067A D7          	push a
0291+  067B 10 00 0A    	mov a, $0A00
0292+  067E 05 03       	syscall sys_io
0293+  0680 10 00 0D    	mov a, $0D00
0294+  0683 05 03       	syscall sys_io
0295+  0685 E4          	pop a
0296+  0686 09          	ret
0297+  0687             
0298+  0687             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  0687             ; strtoint
0300+  0687             ; 4 digit hex string number in d
0301+  0687             ; integer returned in A
0302+  0687             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  0687             strtointx:
0304+  0687 D8          	push b
0305+  0688 32          	mov bl, [d]
0306+  0689 37          	mov bh, bl
0307+  068A 33 01 00    	mov bl, [d + 1]
0308+  068D 07 48 05    	call atoi				; convert to int in AL
0309+  0690 23          	mov ah, al				; move to AH
0310+  0691 33 02 00    	mov bl, [d + 2]
0311+  0694 37          	mov bh, bl
0312+  0695 33 03 00    	mov bl, [d + 3]
0313+  0698 07 48 05    	call atoi				; convert to int in AL
0314+  069B E5          	pop b
0315+  069C 09          	ret
0316+  069D             
0317+  069D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  069D             ; strtoint
0319+  069D             ; 5 digit base10 string number in d
0320+  069D             ; integer returned in A
0321+  069D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  069D             strtoint:
0323+  069D E2          	push si
0324+  069E D8          	push b
0325+  069F D9          	push c
0326+  06A0 DA          	push d
0327+  06A1 07 C8 04    	call strlen			; get string length in C
0328+  06A4 7E          	dec c
0329+  06A5 FD 4E       	mov si, d
0330+  06A7 12          	mov a, c
0331+  06A8 FD 99       	shl a
0332+  06AA 3B 30 05    	mov d, table_power
0333+  06AD 59          	add d, a
0334+  06AE 38 00 00    	mov c, 0
0335+  06B1             strtoint_L0:
0336+  06B1 F6          	lodsb			; load ASCII to al
0337+  06B2 B9 00       	cmp al, 0
0338+  06B4 C6 C7 06    	je strtoint_end
0339+  06B7 6F 30       	sub al, $30		; make into integer
0340+  06B9 22 00       	mov ah, 0
0341+  06BB 2A          	mov b, [d]
0342+  06BC AC          	mul a, b			; result in B since it fits in 16bits
0343+  06BD 11          	mov a, b
0344+  06BE 28          	mov b, c
0345+  06BF 54          	add a, b
0346+  06C0 39          	mov c, a
0347+  06C1 63 02 00    	sub d, 2
0348+  06C4 0A B1 06    	jmp strtoint_L0
0349+  06C7             strtoint_end:
0350+  06C7 12          	mov a, c
0351+  06C8 E7          	pop d
0352+  06C9 E6          	pop c
0353+  06CA E5          	pop b
0354+  06CB EF          	pop si
0355+  06CC 09          	ret
0356+  06CD             
0357+  06CD             
0358+  06CD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  06CD             ; PRINT NULL TERMINATED STRING
0360+  06CD             ; pointer in D
0361+  06CD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  06CD             puts:
0363+  06CD D7          	push a
0364+  06CE DA          	push d
0365+  06CF             puts_L1:
0366+  06CF 1E          	mov al, [d]
0367+  06D0 B9 00       	cmp al, 0
0368+  06D2 C6 DE 06    	jz puts_END
0369+  06D5 23          	mov ah, al
0370+  06D6 19 00       	mov al, 0
0371+  06D8 05 03       	syscall sys_io
0372+  06DA 79          	inc d
0373+  06DB 0A CF 06    	jmp puts_L1
0374+  06DE             puts_END:
0375+  06DE E7          	pop d
0376+  06DF E4          	pop a
0377+  06E0 09          	ret
0378+  06E1             
0379+  06E1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  06E1             ; PRINT N SIZE STRING
0381+  06E1             ; pointer in D
0382+  06E1             ; size in C
0383+  06E1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  06E1             putsn:
0385+  06E1 DB          	push al
0386+  06E2 DA          	push d
0387+  06E3 D9          	push c
0388+  06E4             putsn_L0:
0389+  06E4 1E          	mov al, [d]
0390+  06E5 23          	mov ah, al
0391+  06E6 19 00       	mov al, 0
0392+  06E8 05 03       	syscall sys_io
0393+  06EA 79          	inc d
0394+  06EB 7E          	dec c	
0395+  06EC C2 00 00    	cmp c, 0
0396+  06EF C7 E4 06    	jne putsn_L0
0397+  06F2             putsn_end:
0398+  06F2 E6          	pop c
0399+  06F3 E7          	pop d
0400+  06F4 E8          	pop al
0401+  06F5 09          	ret
0402+  06F6             
0403+  06F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  06F6             ; print 16bit decimal number
0405+  06F6             ; input number in A
0406+  06F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  06F6             print_u16d:
0408+  06F6 D7          	push a
0409+  06F7 D8          	push b
0410+  06F8 26 10 27    	mov b, 10000
0411+  06FB AE          	div a, b			; get 10000's coeff.
0412+  06FC 07 1E 07    	call print_number
0413+  06FF 11          	mov a, b
0414+  0700 26 E8 03    	mov b, 1000
0415+  0703 AE          	div a, b			; get 1000's coeff.
0416+  0704 07 1E 07    	call print_number
0417+  0707 11          	mov a, b
0418+  0708 26 64 00    	mov b, 100
0419+  070B AE          	div a, b
0420+  070C 07 1E 07    	call print_number
0421+  070F 11          	mov a, b
0422+  0710 26 0A 00    	mov b, 10
0423+  0713 AE          	div a, b
0424+  0714 07 1E 07    	call print_number
0425+  0717 1B          	mov al, bl			; 1's coeff in bl
0426+  0718 07 1E 07    	call print_number
0427+  071B E5          	pop b
0428+  071C E4          	pop a
0429+  071D 09          	ret
0430+  071E             
0431+  071E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0432+  071E             ; print AL
0433+  071E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0434+  071E             print_number:
0435+  071E 6A 30       	add al, $30
0436+  0720 23          	mov ah, al
0437+  0721 07 93 05    	call putchar
0438+  0724 09          	ret
0439+  0725             
0440+  0725             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0441+  0725             ; PRINT 16BIT HEX INTEGER
0442+  0725             ; integer value in reg B
0443+  0725             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0444+  0725             print_u16x:
0445+  0725 D7          	push a
0446+  0726 D8          	push b
0447+  0727 DD          	push bl
0448+  0728 30          	mov bl, bh
0449+  0729 07 5A 05    	call itoa				; convert bh to char in A
0450+  072C 2F          	mov bl, al				; save al
0451+  072D 19 00       	mov al, 0
0452+  072F 05 03       	syscall sys_io				; display AH
0453+  0731 24          	mov ah, bl				; retrieve al
0454+  0732 19 00       	mov al, 0
0455+  0734 05 03       	syscall sys_io				; display AL
0456+  0736             
0457+  0736 EA          	pop bl
0458+  0737 07 5A 05    	call itoa				; convert bh to char in A
0459+  073A 2F          	mov bl, al				; save al
0460+  073B 19 00       	mov al, 0
0461+  073D 05 03       	syscall sys_io				; display AH
0462+  073F 24          	mov ah, bl				; retrieve al
0463+  0740 19 00       	mov al, 0
0464+  0742 05 03       	syscall sys_io				; display AL
0465+  0744             
0466+  0744 E5          	pop b
0467+  0745 E4          	pop a
0468+  0746 09          	ret
0469+  0747             
0470+  0747             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0471+  0747             ; INPUT 16BIT HEX INTEGER
0472+  0747             ; read 16bit integer into A
0473+  0747             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0474+  0747             scan_u16x:
0475+  0747 F8 10 00    	enter 16
0476+  074A D8          	push b
0477+  074B DA          	push d
0478+  074C             
0479+  074C FA F1 FF    	lea d, [bp + -15]
0480+  074F 07 9A 05    	call gets				; get number
0481+  0752             
0482+  0752 32          	mov bl, [d]
0483+  0753 37          	mov bh, bl
0484+  0754 33 01 00    	mov bl, [d + 1]
0485+  0757 07 48 05    	call atoi				; convert to int in AL
0486+  075A 23          	mov ah, al				; move to AH
0487+  075B             
0488+  075B 33 02 00    	mov bl, [d + 2]
0489+  075E 37          	mov bh, bl
0490+  075F 33 03 00    	mov bl, [d + 3]
0491+  0762 07 48 05    	call atoi				; convert to int in AL
0492+  0765             
0493+  0765 E7          	pop d
0494+  0766 E5          	pop b
0495+  0767 F9          	leave
0496+  0768 09          	ret
0497+  0769             
0498+  0769             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0499+  0769             ; PRINT 8bit HEX INTEGER
0500+  0769             ; integer value in reg bl
0501+  0769             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0502+  0769             print_u8x:
0503+  0769 D7          	push a
0504+  076A DD          	push bl
0505+  076B             
0506+  076B 07 5A 05    	call itoa				; convert bl to char in A
0507+  076E 2F          	mov bl, al				; save al
0508+  076F 19 00       	mov al, 0
0509+  0771 05 03       	syscall sys_io				; display AH
0510+  0773 24          	mov ah, bl				; retrieve al
0511+  0774 19 00       	mov al, 0
0512+  0776 05 03       	syscall sys_io				; display AL
0513+  0778             
0514+  0778 EA          	pop bl
0515+  0779 E4          	pop a
0516+  077A 09          	ret
0517+  077B             
0518+  077B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0519+  077B             ; print 8bit decimal unsigned number
0520+  077B             ; input number in AL
0521+  077B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0522+  077B             print_u8d:
0523+  077B D7          	push a
0524+  077C D8          	push b
0525+  077D             
0526+  077D 22 00       	mov ah, 0
0527+  077F 26 64 00    	mov b, 100
0528+  0782 AE          	div a, b
0529+  0783 D8          	push b			; save remainder
0530+  0784 B9 00       	cmp al, 0
0531+  0786 C6 90 07    	je skip100
0532+  0789 6A 30       	add al, $30
0533+  078B 23          	mov ah, al
0534+  078C 19 00       	mov al, 0
0535+  078E 05 03       	syscall sys_io	; print coeff
0536+  0790             skip100:
0537+  0790 E4          	pop a
0538+  0791 22 00       	mov ah, 0
0539+  0793 26 0A 00    	mov b, 10
0540+  0796 AE          	div a, b
0541+  0797 D8          	push b			; save remainder
0542+  0798 B9 00       	cmp al, 0
0543+  079A C6 A4 07    	je skip10
0544+  079D 6A 30       	add al, $30
0545+  079F 23          	mov ah, al
0546+  07A0 19 00       	mov al, 0
0547+  07A2 05 03       	syscall sys_io	; print coeff
0548+  07A4             skip10:
0549+  07A4 E4          	pop a
0550+  07A5 1B          	mov al, bl
0551+  07A6 6A 30       	add al, $30
0552+  07A8 23          	mov ah, al
0553+  07A9 19 00       	mov al, 0
0554+  07AB 05 03       	syscall sys_io	; print coeff
0555+  07AD E5          	pop b
0556+  07AE E4          	pop a
0557+  07AF 09          	ret
0558+  07B0             
0559+  07B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0560+  07B0             ; INPUT 8BIT HEX INTEGER
0561+  07B0             ; read 8bit integer into AL
0562+  07B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0563+  07B0             scan_u8x:
0564+  07B0 F8 04 00    	enter 4
0565+  07B3 D8          	push b
0566+  07B4 DA          	push d
0567+  07B5             
0568+  07B5 FA FD FF    	lea d, [bp + -3]
0569+  07B8 07 9A 05    	call gets				; get number
0570+  07BB             
0571+  07BB 32          	mov bl, [d]
0572+  07BC 37          	mov bh, bl
0573+  07BD 33 01 00    	mov bl, [d + 1]
0574+  07C0 07 48 05    	call atoi				; convert to int in AL
0575+  07C3             
0576+  07C3 E7          	pop d
0577+  07C4 E5          	pop b
0578+  07C5 F9          	leave
0579+  07C6 09          	ret
0580+  07C7             
0581+  07C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0582+  07C7             ; input decimal number
0583+  07C7             ; result in A
0584+  07C7             ; 655'\0'
0585+  07C7             ; low--------high
0586+  07C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  07C7             scan_u16d:
0588+  07C7 F8 08 00    	enter 8
0589+  07CA E2          	push si
0590+  07CB D8          	push b
0591+  07CC D9          	push c
0592+  07CD DA          	push d
0593+  07CE FA F9 FF    	lea d, [bp +- 7]
0594+  07D1 07 9A 05    	call gets
0595+  07D4 07 C8 04    	call strlen			; get string length in C
0596+  07D7 7E          	dec c
0597+  07D8 FD 4E       	mov si, d
0598+  07DA 12          	mov a, c
0599+  07DB FD 99       	shl a
0600+  07DD 3B 30 05    	mov d, table_power
0601+  07E0 59          	add d, a
0602+  07E1 38 00 00    	mov c, 0
0603+  07E4             mul_loop:
0604+  07E4 F6          	lodsb			; load ASCII to al
0605+  07E5 B9 00       	cmp al, 0
0606+  07E7 C6 FA 07    	je mul_exit
0607+  07EA 6F 30       	sub al, $30		; make into integer
0608+  07EC 22 00       	mov ah, 0
0609+  07EE 2A          	mov b, [d]
0610+  07EF AC          	mul a, b			; result in B since it fits in 16bits
0611+  07F0 11          	mov a, b
0612+  07F1 28          	mov b, c
0613+  07F2 54          	add a, b
0614+  07F3 39          	mov c, a
0615+  07F4 63 02 00    	sub d, 2
0616+  07F7 0A E4 07    	jmp mul_loop
0617+  07FA             mul_exit:
0618+  07FA 12          	mov a, c
0619+  07FB E7          	pop d
0620+  07FC E6          	pop c
0621+  07FD E5          	pop b
0622+  07FE EF          	pop si
0623+  07FF F9          	leave
0624+  0800 09          	ret
0073   0801             .include "token.asm"
0001+  0801             TOKTYP_IDENTIFIER	.equ 0
0002+  0801             TOKTYP_KEYWORD		.equ 1
0003+  0801             TOKTYP_DELIMITER	.equ 2
0004+  0801             TOKTYP_STRING		.equ 3
0005+  0801             TOKTYP_CHAR			.equ 4
0006+  0801             TOKTYP_NUMERIC		.equ 5
0007+  0801             TOKTYP_END			.equ 6
0008+  0801             
0009+  0801             TOK_NULL			.equ 0
0010+  0801             TOK_FSLASH			.equ 1
0011+  0801             TOK_TIMES 			.equ 2
0012+  0801             TOK_PLUS 			.equ 3
0013+  0801             TOK_MINUS 			.equ 4
0014+  0801             TOK_DOT				.equ 5
0015+  0801             TOK_SEMI			.equ 6
0016+  0801             TOK_ANGLE			.equ 7
0017+  0801             TOK_TILDE			.equ 8
0018+  0801             TOK_EQUAL			.equ 9
0019+  0801             TOK_COLON			.equ 10
0020+  0801             TOK_COMMA			.equ 11
0021+  0801             
0022+  0801             TOK_END				.equ 20
0023+  0801             
0024+  0801             
0025+  0801             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  0801             ;; read a full command argment from shell input buffer
0027+  0801             ;; argument is written into tokstr
0028+  0801             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  0801             get_arg:
0030+  0801 D7          	push a
0031+  0802 E2          	push si
0032+  0803 E3          	push di
0033+  0804 19 00       	mov al, 0
0034+  0806 3D 2F 0A    	mov [tokstr], al			; nullify tokstr string
0035+  0809 14 2B 0A    	mov a, [prog]
0036+  080C 4D          	mov si, a
0037+  080D FD 4F 2F 0A 	mov di, tokstr
0038+  0811             get_arg_skip_spaces:
0039+  0811 F6          	lodsb
0040+  0812 07 A5 0B    	call isspace
0041+  0815 C6 11 08    	je get_arg_skip_spaces
0042+  0818             get_arg_L0:
0043+  0818 B9 3B       	cmp al, $3B				; check if is ';'
0044+  081A C6 27 08    	je get_arg_end
0045+  081D B9 00       	cmp al, 0
0046+  081F C6 27 08    	je get_arg_end			; check if end of input
0047+  0822 F7          	stosb
0048+  0823 F6          	lodsb
0049+  0824 0A 18 08    	jmp get_arg_L0
0050+  0827             get_arg_end:
0051+  0827 19 00       	mov al, 0
0052+  0829 F7          	stosb
0053+  082A D5 01 00    	sub si, 1
0054+  082D 4E          	mov a, si
0055+  082E 42 2B 0A    	mov [prog], a		; update pointer
0056+  0831 F0          	pop di
0057+  0832 EF          	pop si
0058+  0833 E4          	pop a
0059+  0834 09          	ret
0060+  0835             
0061+  0835             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  0835             ;; read a path formation from shell input buffer
0063+  0835             ;; path is written into tokstr
0064+  0835             ;; /usr/bin
0065+  0835             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  0835             get_path:
0067+  0835 D7          	push a
0068+  0836 E2          	push si
0069+  0837 E3          	push di
0070+  0838 19 00       	mov al, 0
0071+  083A 3D 2F 0A    	mov [tokstr], al			; nullify tokstr string
0072+  083D 14 2B 0A    	mov a, [prog]
0073+  0840 4D          	mov si, a
0074+  0841 FD 4F 2F 0A 	mov di, tokstr
0075+  0845             get_path_skip_spaces:
0076+  0845 F6          	lodsb
0077+  0846 07 A5 0B    	call isspace
0078+  0849 C6 45 08    	je get_path_skip_spaces
0079+  084C             get_path_is_pathchar:
0080+  084C F7          	stosb
0081+  084D F6          	lodsb
0082+  084E 07 2F 0B    	call isalnum			;check if is alphanumeric
0083+  0851 C6 4C 08    	je get_path_is_pathchar
0084+  0854 B9 2F       	cmp al, '/'				; check if is '/'
0085+  0856 C6 4C 08    	je get_path_is_pathchar
0086+  0859 19 00       	mov al, 0
0087+  085B F7          	stosb
0088+  085C D5 01 00    	sub si, 1
0089+  085F 4E          	mov a, si
0090+  0860 42 2B 0A    	mov [prog], a		; update pointer
0091+  0863             get_path_end:
0092+  0863 F0          	pop di
0093+  0864 EF          	pop si
0094+  0865 E4          	pop a
0095+  0866 09          	ret
0096+  0867             
0097+  0867             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  0867             ;; read a line
0099+  0867             ;; line is written into tokstr
0100+  0867             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  0867             get_line:
0102+  0867 D7          	push a
0103+  0868 E2          	push si
0104+  0869 E3          	push di
0105+  086A 19 00       	mov al, 0
0106+  086C 3D 2F 0A    	mov [tokstr], al			; nullify tokstr string
0107+  086F 14 2B 0A    	mov a, [prog]
0108+  0872 4D          	mov si, a
0109+  0873 FD 4F 2F 0A 	mov di, tokstr
0110+  0877             get_line_L0:
0111+  0877 F6          	lodsb
0112+  0878 B9 0A       	cmp al, $0A		; check for new line
0113+  087A C6 81 08    	je get_line_exit
0114+  087D F7          	stosb
0115+  087E 0A 77 08    	jmp get_line_L0
0116+  0881             get_line_exit:
0117+  0881 19 00       	mov al, 0
0118+  0883 F7          	stosb
0119+  0884 4E          	mov a, si
0120+  0885 42 2B 0A    	mov [prog], a		; update pointer
0121+  0888 F0          	pop di
0122+  0889 EF          	pop si
0123+  088A E4          	pop a
0124+  088B 09          	ret
0125+  088C             
0126+  088C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  088C             ;; token parser
0128+  088C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  088C             get_token:
0130+  088C D7          	push a
0131+  088D DA          	push d
0132+  088E E2          	push si
0133+  088F E3          	push di
0134+  0890 19 00       	mov al, 0
0135+  0892 3D 2F 0A    	mov [tokstr], al			; nullify tokstr string
0136+  0895 19 00       	mov al, TOK_NULL
0137+  0897 3D 2E 0A    	mov [tok], al				; nullify token
0138+  089A 14 2B 0A    	mov a, [prog]
0139+  089D 4D          	mov si, a
0140+  089E FD 4F 2F 0A 	mov di, tokstr
0141+  08A2             get_tok_skip_spaces:
0142+  08A2 F6          	lodsb
0143+  08A3 07 A5 0B    	call isspace
0144+  08A6 C6 A2 08    	je get_tok_skip_spaces
0145+  08A9 B9 00       	cmp al, 0			; check for end of input (NULL)
0146+  08AB C6 90 09    	je get_token_end
0147+  08AE B9 23       	cmp al, '#'			; comments!
0148+  08B0 C6 BE 09    	je get_tok_comment
0149+  08B3 07 2F 0B    	call isalnum
0150+  08B6 C6 9D 09    	jz is_alphanumeric
0151+  08B9             ; other token types
0152+  08B9             get_token_slash:
0153+  08B9 B9 2F       	cmp al, '/'				; check if '/'
0154+  08BB C7 D3 08    	jne get_token_minus
0155+  08BE F7          	stosb					; store '/' into token string
0156+  08BF 19 00       	mov al, 0
0157+  08C1 F7          	stosb					; terminate token string
0158+  08C2 19 01       	mov al, TOK_FSLASH
0159+  08C4 3D 2E 0A    	mov [tok], al			
0160+  08C7 19 02       	mov al, TOKTYP_DELIMITER
0161+  08C9 3D 2D 0A    	mov [toktyp], al
0162+  08CC 4E          	mov a, si
0163+  08CD 42 2B 0A    	mov [prog], a		; update pointer
0164+  08D0 0A B9 09    	jmp get_token_return
0165+  08D3             get_token_minus:
0166+  08D3 B9 2D       	cmp al, '-'				; check if '-'
0167+  08D5 C7 ED 08    	jne get_token_comma
0168+  08D8 F7          	stosb					; store '-' into token string
0169+  08D9 19 00       	mov al, 0
0170+  08DB F7          	stosb					; terminate token string
0171+  08DC 19 04       	mov al, TOK_MINUS
0172+  08DE 3D 2E 0A    	mov [tok], al			
0173+  08E1 19 02       	mov al, TOKTYP_DELIMITER
0174+  08E3 3D 2D 0A    	mov [toktyp], al
0175+  08E6 4E          	mov a, si
0176+  08E7 42 2B 0A    	mov [prog], a		; update pointer
0177+  08EA 0A B9 09    	jmp get_token_return
0178+  08ED             get_token_comma:
0179+  08ED B9 2C       	cmp al, ','				; check if ','
0180+  08EF C7 07 09    	jne get_token_semi
0181+  08F2 F7          	stosb					; store ',' into token string
0182+  08F3 19 00       	mov al, 0
0183+  08F5 F7          	stosb					; terminate token string
0184+  08F6 19 0B       	mov al, TOK_COMMA
0185+  08F8 3D 2E 0A    	mov [tok], al			
0186+  08FB 19 02       	mov al, TOKTYP_DELIMITER
0187+  08FD 3D 2D 0A    	mov [toktyp], al
0188+  0900 4E          	mov a, si
0189+  0901 42 2B 0A    	mov [prog], a		; update pointer
0190+  0904 0A B9 09    	jmp get_token_return
0191+  0907             get_token_semi:
0192+  0907 B9 3B       	cmp al, $3B				; check if ';'
0193+  0909 C7 21 09    	jne get_token_colon
0194+  090C F7          	stosb					; store ';' into token string
0195+  090D 19 00       	mov al, 0
0196+  090F F7          	stosb					; terminate token string
0197+  0910 19 06       	mov al, TOK_SEMI
0198+  0912 3D 2E 0A    	mov [tok], al			
0199+  0915 19 02       	mov al, TOKTYP_DELIMITER
0200+  0917 3D 2D 0A    	mov [toktyp], al
0201+  091A 4E          	mov a, si
0202+  091B 42 2B 0A    	mov [prog], a		; update pointer
0203+  091E 0A B9 09    	jmp get_token_return
0204+  0921             get_token_colon:
0205+  0921 B9 3A       	cmp al, $3A				; check if ':'
0206+  0923 C7 3B 09    	jne get_token_angle
0207+  0926 F7          	stosb					; store ':' into token string
0208+  0927 19 00       	mov al, 0
0209+  0929 F7          	stosb					; terminate token string
0210+  092A 19 0A       	mov al, TOK_COLON
0211+  092C 3D 2E 0A    	mov [tok], al			
0212+  092F 19 02       	mov al, TOKTYP_DELIMITER
0213+  0931 3D 2D 0A    	mov [toktyp], al
0214+  0934 4E          	mov a, si
0215+  0935 42 2B 0A    	mov [prog], a		; update pointer
0216+  0938 0A B9 09    	jmp get_token_return
0217+  093B             get_token_angle:
0218+  093B B9 3E       	cmp al, $3E				; check if '>'
0219+  093D C7 55 09    	jne get_token_tilde
0220+  0940 F7          	stosb					; store '>' into token string
0221+  0941 19 00       	mov al, 0
0222+  0943 F7          	stosb					; terminate token string
0223+  0944 19 07       	mov al, TOK_ANGLE
0224+  0946 3D 2E 0A    	mov [tok], al			
0225+  0949 19 02       	mov al, TOKTYP_DELIMITER
0226+  094B 3D 2D 0A    	mov [toktyp], al
0227+  094E 4E          	mov a, si
0228+  094F 42 2B 0A    	mov [prog], a		; update pointer
0229+  0952 0A B9 09    	jmp get_token_return
0230+  0955             get_token_tilde:
0231+  0955 B9 7E       	cmp al, '~'				; check if '~'
0232+  0957 C7 6F 09    	jne get_token_equal
0233+  095A F7          	stosb					; store '~' into token string
0234+  095B 19 00       	mov al, 0
0235+  095D F7          	stosb					; terminate token string
0236+  095E 19 08       	mov al, TOK_TILDE
0237+  0960 3D 2E 0A    	mov [tok], al			
0238+  0963 19 02       	mov al, TOKTYP_DELIMITER
0239+  0965 3D 2D 0A    	mov [toktyp], al
0240+  0968 4E          	mov a, si
0241+  0969 42 2B 0A    	mov [prog], a		; update pointer
0242+  096C 0A B9 09    	jmp get_token_return
0243+  096F             get_token_equal:
0244+  096F B9 3D       	cmp al, '='				; check if '='
0245+  0971 C7 89 09    	jne get_token_skip
0246+  0974 F7          	stosb					; store '=' into token string
0247+  0975 19 00       	mov al, 0
0248+  0977 F7          	stosb					; terminate token string
0249+  0978 19 09       	mov al, TOK_EQUAL
0250+  097A 3D 2E 0A    	mov [tok], al			
0251+  097D 19 02       	mov al, TOKTYP_DELIMITER
0252+  097F 3D 2D 0A    	mov [toktyp], al
0253+  0982 4E          	mov a, si
0254+  0983 42 2B 0A    	mov [prog], a		; update pointer
0255+  0986 0A B9 09    	jmp get_token_return
0256+  0989             get_token_skip:
0257+  0989 4E          	mov a, si
0258+  098A 42 2B 0A    	mov [prog], a		; update pointer
0259+  098D 0A B9 09    	jmp get_token_return
0260+  0990             get_token_end:				; end of file token
0261+  0990 19 14       	mov al, TOK_END
0262+  0992 3D 2E 0A    	mov [tok], al
0263+  0995 19 06       	mov al, TOKTYP_END
0264+  0997 3D 2D 0A    	mov [toktyp], al
0265+  099A 0A B9 09    	jmp get_token_return
0266+  099D             is_alphanumeric:
0267+  099D F7          	stosb
0268+  099E F6          	lodsb
0269+  099F 07 2F 0B    	call isalnum			;check if is alphanumeric
0270+  09A2 C6 9D 09    	jz is_alphanumeric
0271+  09A5 B9 2E       	cmp al, $2E				; check if is '.'
0272+  09A7 C6 9D 09    	je is_alphanumeric
0273+  09AA 19 00       	mov al, 0
0274+  09AC F7          	stosb
0275+  09AD 19 00       	mov al, TOKTYP_IDENTIFIER
0276+  09AF 3D 2D 0A    	mov [toktyp], al
0277+  09B2 D5 01 00    	sub si, 1
0278+  09B5 4E          	mov a, si
0279+  09B6 42 2B 0A    	mov [prog], a		; update pointer
0280+  09B9             get_token_return:
0281+  09B9 F0          	pop di
0282+  09BA EF          	pop si
0283+  09BB E7          	pop d
0284+  09BC E4          	pop a
0285+  09BD 09          	ret
0286+  09BE             get_tok_comment:
0287+  09BE F6          	lodsb
0288+  09BF B9 0A       	cmp al, $0A			; new line
0289+  09C1 C7 BE 09    	jne get_tok_comment
0290+  09C4 0A A2 08    	jmp get_tok_skip_spaces
0291+  09C7             
0292+  09C7             
0293+  09C7             get_number:
0294+  09C7 D7          	push a
0295+  09C8 DA          	push d
0296+  09C9 E2          	push si
0297+  09CA E3          	push di
0298+  09CB 19 00       	mov al, 0
0299+  09CD 3D 2F 0A    	mov [tokstr], al			; nullify tokstr string
0300+  09D0 19 00       	mov al, TOK_NULL
0301+  09D2 3D 2E 0A    	mov [tok], al				; nullify token
0302+  09D5 14 2B 0A    	mov a, [prog]
0303+  09D8 4D          	mov si, a
0304+  09D9 FD 4F 2F 0A 	mov di, tokstr
0305+  09DD             get_number_skip_spaces:
0306+  09DD F6          	lodsb
0307+  09DE 07 A5 0B    	call isspace
0308+  09E1 C6 DD 09    	je get_number_skip_spaces
0309+  09E4 B9 00       	cmp al, 0			; check for end of input (NULL)
0310+  09E6 C7 F6 09    	jne get_number_L0
0311+  09E9 19 14       	mov al, TOK_END
0312+  09EB 3D 2E 0A    	mov [tok], al
0313+  09EE 19 06       	mov al, TOKTYP_END
0314+  09F0 3D 2D 0A    	mov [toktyp], al
0315+  09F3 0A 0D 0A    	jmp get_number_return
0316+  09F6             get_number_L0:
0317+  09F6 F7          	stosb
0318+  09F7 F6          	lodsb
0319+  09F8 07 39 0B    	call isdigit			;check if is numeric
0320+  09FB C6 F6 09    	jz get_number_L0
0321+  09FE 19 00       	mov al, 0
0322+  0A00 F7          	stosb
0323+  0A01 19 05       	mov al, TOKTYP_NUMERIC
0324+  0A03 3D 2D 0A    	mov [toktyp], al
0325+  0A06 D5 01 00    	sub si, 1
0326+  0A09 4E          	mov a, si
0327+  0A0A 42 2B 0A    	mov [prog], a		; update pointer
0328+  0A0D             get_number_return:
0329+  0A0D F0          	pop di
0330+  0A0E EF          	pop si
0331+  0A0F E7          	pop d
0332+  0A10 E4          	pop a
0333+  0A11 09          	ret
0334+  0A12             
0335+  0A12             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  0A12             ;; PUT BACK TOKEN
0337+  0A12             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
0338+  0A12             putback:
0339+  0A12 D7          	push a
0340+  0A13 E2          	push si
0341+  0A14 FD 4D 2F 0A 	mov si, tokstr	
0342+  0A18             putback_loop:
0343+  0A18 F6          	lodsb
0344+  0A19 B9 00       	cmp al, 0
0345+  0A1B C6 28 0A    	je putback_end
0346+  0A1E 14 2B 0A    	mov a, [prog]
0347+  0A21 7D          	dec a
0348+  0A22 42 2B 0A    	mov [prog], a			; update pointer
0349+  0A25 0A 18 0A    	jmp putback_loop
0350+  0A28             putback_end:
0351+  0A28 EF          	pop si
0352+  0A29 E4          	pop a
0353+  0A2A 09          	ret
0354+  0A2B             
0355+  0A2B             
0356+  0A2B             
0357+  0A2B             
0358+  0A2B 00 00       prog:		.dw 0			; pointer to current position in buffer
0359+  0A2D             
0360+  0A2D 00          toktyp: 	.db 0			; token type symbol
0361+  0A2E 00          tok:		.db 0			; current token symbol
0362+  0A2F 00 00 00 00 tokstr:		.fill 256, 0	; token as a string
0362+  0A33 00 00 00 00 
0362+  0A37 00 00 00 00 
0362+  0A3B 00 00 00 00 
0362+  0A3F 00 00 00 00 
0362+  0A43 00 00 00 00 
0362+  0A47 00 00 00 00 
0362+  0A4B 00 00 00 00 
0362+  0A4F 00 00 00 00 
0362+  0A53 00 00 00 00 
0362+  0A57 00 00 00 00 
0362+  0A5B 00 00 00 00 
0362+  0A5F 00 00 00 00 
0362+  0A63 00 00 00 00 
0362+  0A67 00 00 00 00 
0362+  0A6B 00 00 00 00 
0362+  0A6F 00 00 00 00 
0362+  0A73 00 00 00 00 
0362+  0A77 00 00 00 00 
0362+  0A7B 00 00 00 00 
0362+  0A7F 00 00 00 00 
0362+  0A83 00 00 00 00 
0362+  0A87 00 00 00 00 
0362+  0A8B 00 00 00 00 
0362+  0A8F 00 00 00 00 
0362+  0A93 00 00 00 00 
0362+  0A97 00 00 00 00 
0362+  0A9B 00 00 00 00 
0362+  0A9F 00 00 00 00 
0362+  0AA3 00 00 00 00 
0362+  0AA7 00 00 00 00 
0362+  0AAB 00 00 00 00 
0362+  0AAF 00 00 00 00 
0362+  0AB3 00 00 00 00 
0362+  0AB7 00 00 00 00 
0362+  0ABB 00 00 00 00 
0362+  0ABF 00 00 00 00 
0362+  0AC3 00 00 00 00 
0362+  0AC7 00 00 00 00 
0362+  0ACB 00 00 00 00 
0362+  0ACF 00 00 00 00 
0362+  0AD3 00 00 00 00 
0362+  0AD7 00 00 00 00 
0362+  0ADB 00 00 00 00 
0362+  0ADF 00 00 00 00 
0362+  0AE3 00 00 00 00 
0362+  0AE7 00 00 00 00 
0362+  0AEB 00 00 00 00 
0362+  0AEF 00 00 00 00 
0362+  0AF3 00 00 00 00 
0362+  0AF7 00 00 00 00 
0362+  0AFB 00 00 00 00 
0362+  0AFF 00 00 00 00 
0362+  0B03 00 00 00 00 
0362+  0B07 00 00 00 00 
0362+  0B0B 00 00 00 00 
0362+  0B0F 00 00 00 00 
0362+  0B13 00 00 00 00 
0362+  0B17 00 00 00 00 
0362+  0B1B 00 00 00 00 
0362+  0B1F 00 00 00 00 
0362+  0B23 00 00 00 00 
0362+  0B27 00 00 00 00 
0362+  0B2B 00 00 00 00 
0074   0B2F             .include "ctype.asm"
0001+  0B2F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0B2F             ; ctype.s
0003+  0B2F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0B2F             
0005+  0B2F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  0B2F             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  0B2F             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  0B2F             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  0B2F             ;; characters are supported.
0010+  0B2F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  0B2F             ;; isalnum 
0012+  0B2F             ;; isalpha 
0013+  0B2F             ;; islower 
0014+  0B2F             ;; isupper 
0015+  0B2F             ;; isdigit 
0016+  0B2F             ;; isxdigit
0017+  0B2F             ;; iscntrl 
0018+  0B2F             ;; isgraph 
0019+  0B2F             ;; isspace 
0020+  0B2F             ;; isblank 
0021+  0B2F             ;; isprint 
0022+  0B2F             ;; ispunct 
0023+  0B2F             ;; tolower 
0024+  0B2F             ;; toupper
0025+  0B2F             
0026+  0B2F             
0027+  0B2F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  0B2F             ;; IS ALPHANUMERIC
0029+  0B2F             ;; sets ZF according with result
0030+  0B2F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  0B2F             isalnum:
0032+  0B2F 07 4C 0B    	call isalpha
0033+  0B32 C6 38 0B    	je isalnum_exit
0034+  0B35 07 39 0B    	call isdigit
0035+  0B38             isalnum_exit:
0036+  0B38 09          	ret	
0037+  0B39             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0B39             ;; IS DIGIT
0039+  0B39             ;; sets ZF according with result
0040+  0B39             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  0B39             isdigit:
0042+  0B39 DB          	push al
0043+  0B3A B9 30       	cmp al, '0'
0044+  0B3C C8 48 0B    	jlu isdigit_false
0045+  0B3F B9 39       	cmp al, '9'
0046+  0B41 D1 48 0B    	jgu isdigit_false
0047+  0B44 87 00       	and al, 0	; set ZF
0048+  0B46 E8          	pop al
0049+  0B47 09          	ret
0050+  0B48             isdigit_false:
0051+  0B48 8B 01       	or al, 1	; clear ZF
0052+  0B4A E8          	pop al
0053+  0B4B 09          	ret	
0054+  0B4C             	
0055+  0B4C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  0B4C             ;; IS ALPHA
0057+  0B4C             ;; sets ZF according with result
0058+  0B4C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  0B4C             isalpha:
0060+  0B4C DB          	push al
0061+  0B4D B9 5F       	cmp al, '_'
0062+  0B4F C6 6F 0B    	je isalpha_true
0063+  0B52 B9 2E       	cmp al, '.'
0064+  0B54 C6 6F 0B    	je isalpha_true
0065+  0B57 B9 41       	cmp al, 'A'
0066+  0B59 C8 6B 0B    	jlu isalpha_false
0067+  0B5C B9 7A       	cmp al, 'z'
0068+  0B5E D1 6B 0B    	jgu isalpha_false
0069+  0B61 B9 5A       	cmp al, 'Z'
0070+  0B63 D0 6F 0B    	jleu isalpha_true
0071+  0B66 B9 61       	cmp al, 'a'
0072+  0B68 C9 6F 0B    	jgeu isalpha_true
0073+  0B6B             isalpha_false:
0074+  0B6B 8B 01       	or al, 1	; clear ZF
0075+  0B6D E8          	pop al
0076+  0B6E 09          	ret
0077+  0B6F             isalpha_true:
0078+  0B6F 87 00       	and al, 0	; set ZF
0079+  0B71 E8          	pop al
0080+  0B72 09          	ret
0081+  0B73             
0082+  0B73             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  0B73             ;; IS PATH-ALPHA
0084+  0B73             ;; sets ZF according with result
0085+  0B73             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  0B73             ispath:
0087+  0B73 DB          	push al
0088+  0B74 07 39 0B    	call isdigit
0089+  0B77 C6 A1 0B    	je ispath_true
0090+  0B7A B9 5F       	cmp al, '_'
0091+  0B7C C6 A1 0B    	je ispath_true
0092+  0B7F B9 2F       	cmp al, '/'
0093+  0B81 C6 A1 0B    	je ispath_true
0094+  0B84 B9 2E       	cmp al, '.'
0095+  0B86 C6 A1 0B    	je ispath_true
0096+  0B89 B9 41       	cmp al, 'A'
0097+  0B8B C8 9D 0B    	jlu ispath_false
0098+  0B8E B9 7A       	cmp al, 'z'
0099+  0B90 D1 9D 0B    	jgu ispath_false
0100+  0B93 B9 5A       	cmp al, 'Z'
0101+  0B95 D0 A1 0B    	jleu ispath_true
0102+  0B98 B9 61       	cmp al, 'a'
0103+  0B9A C9 A1 0B    	jgeu ispath_true
0104+  0B9D             ispath_false:
0105+  0B9D 8B 01       	or al, 1	; clear ZF
0106+  0B9F E8          	pop al
0107+  0BA0 09          	ret
0108+  0BA1             ispath_true:
0109+  0BA1 87 00       	and al, 0	; set ZF
0110+  0BA3 E8          	pop al
0111+  0BA4 09          	ret
0112+  0BA5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  0BA5             ;; IS SPACE
0114+  0BA5             ;; sets ZF according with result
0115+  0BA5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  0BA5             isspace:
0117+  0BA5 B9 20       	cmp al, $20		; ' '
0118+  0BA7 C6 BB 0B    	je isspace_exit
0119+  0BAA B9 09       	cmp al, $09		; '\t'
0120+  0BAC C6 BB 0B    	je isspace_exit
0121+  0BAF B9 0A       	cmp al, $0A		; '\n'
0122+  0BB1 C6 BB 0B    	je isspace_exit
0123+  0BB4 B9 0D       	cmp al, $0D		; '\r'
0124+  0BB6 C6 BB 0B    	je isspace_exit
0125+  0BB9 B9 0B       	cmp al, $0B		; '\v'
0126+  0BBB             isspace_exit:
0127+  0BBB 09          	ret	
0128+  0BBC             
0129+  0BBC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0BBC             ; TO LOWER
0131+  0BBC             ; input in AL
0132+  0BBC             ; output in AL
0133+  0BBC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  0BBC             to_lower:
0135+  0BBC B9 5A       	cmp al, 'Z'
0136+  0BBE D1 C3 0B    	jgu to_lower_ret
0137+  0BC1 6A 20       	add al, $20				; convert to lower case
0138+  0BC3             to_lower_ret:
0139+  0BC3 09          	ret
0140+  0BC4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  0BC4             ; TO UPPER
0142+  0BC4             ; input in AL
0143+  0BC4             ; output in AL
0144+  0BC4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  0BC4             to_upper:
0146+  0BC4 B9 61       	cmp al, 'a'
0147+  0BC6 C8 CB 0B    	jlu to_upper_ret
0148+  0BC9 6F 20       	sub al, $20			; convert to upper case
0149+  0BCB             to_upper_ret:
0150+  0BCB 09          	ret
0151+  0BCC             
0075   0BCC             
0076   0BCC 55 73 61 67 s_usage:	.db "Usage: primes [min] [max]\n", 0
0076   0BD0 65 3A 20 70 
0076   0BD4 72 69 6D 65 
0076   0BD8 73 20 5B 6D 
0076   0BDC 69 6E 5D 20 
0076   0BE0 5B 6D 61 78 
0076   0BE4 5D 0A 00 
0077   0BE7 00 00       total:		.dw 0
0078   0BE9 E8 03       max:		.dw 1000
0079   0BEB 05 00       min:		.dw 5
0080   0BED             
0081   0BED 0D 55 70 70 s_max:		.db "\rUpper bound: ", 0
0081   0BF1 65 72 20 62 
0081   0BF5 6F 75 6E 64 
0081   0BF9 3A 20 00 
0082   0BFC 2C 20 54 6F s_total:	.db ", Total primes: ", 0
0082   0C00 74 61 6C 20 
0082   0C04 70 72 69 6D 
0082   0C08 65 73 3A 20 
0082   0C0C 00 
0083   0C0D             			
0084   0C0D             .end
tasm: Number of errors = 0
