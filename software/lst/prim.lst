0001   0000             .include "kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0002   0000             
0003   0400             .org PROC_TEXT_ORG
0004   0400             
0005   0400             primes:
0006   0400 FD 47 FF FF 	mov sp, $FFFF
0007   0404 FD 49 FF FF 	mov bp, $FFFF
0008   0408             
0009   0408 10 00 00    	mov a, 0
0010   040B 42 2F 0A    	mov [prog], a
0011   040E 07 90 08    	call get_token
0012   0411 1D 32 0A    	mov al, [tok]
0013   0414 B9 14       	cmp al, TOK_END
0014   0416 C6 78 04    	je bad_args
0015   0419 3B 33 0A    	mov d, tokstr
0016   041C 07 9D 06    	call strtoint
0017   041F 42 EF 0B    	mov [min], a
0018   0422 07 90 08    	call get_token
0019   0425 1D 32 0A    	mov al, [tok]
0020   0428 B9 14       	cmp al, TOK_END
0021   042A C6 78 04    	je bad_args
0022   042D 3B 33 0A    	mov d, tokstr
0023   0430 07 9D 06    	call strtoint
0024   0433 42 ED 0B    	mov [max], a
0025   0436             	
0026   0436 14 EF 0B    	mov a, [min]
0027   0439             primes_L1:
0028   0439 38 02 00    	mov c, 2	
0029   043C             primes_L2:
0030   043C D7          	push a
0031   043D 28          	mov b, c
0032   043E AE          	div a, b
0033   043F C0 00 00    	cmp b, 0
0034   0442 C6 4A 04    	jz divisible
0035   0445 78          	inc c
0036   0446 E4          	pop a
0037   0447 0A 3C 04    	jmp primes_L2		
0038   044A             divisible:
0039   044A E4          	pop a
0040   044B B1          	cmp a, c
0041   044C C7 72 04    	jnz notprime			
0042   044F             isprime:
0043   044F 07 F6 06    	call print_u16d
0044   0452             	
0045   0452 D7          	push a
0046   0453 14 EB 0B    	mov a, [total]
0047   0456 77          	inc a
0048   0457 42 EB 0B    	mov [total], a
0049   045A 3B 00 0C    	mov d, s_total
0050   045D 07 CD 06    	call puts
0051   0460 07 F6 06    	call print_u16d
0052   0463             	
0053   0463 E4          	pop a
0054   0464             
0055   0464 07 7A 06    	call printnl
0056   0467 77          	inc a
0057   0468 29 ED 0B    	mov b, [max]
0058   046B B0          	cmp a, b
0059   046C C9 76 04    	jgeu primes_ret
0060   046F 0A 39 04    	jmp primes_L1
0061   0472             notprime:
0062   0472 77          	inc a
0063   0473 0A 39 04    	jmp primes_L1		
0064   0476             primes_ret:
0065   0476 05 0B       	syscall sys_terminate_proc
0066   0478             
0067   0478             bad_args:
0068   0478 3B D0 0B    	mov d, s_usage
0069   047B 07 CD 06    	call puts
0070   047E 0A 76 04    	jmp primes_ret
0071   0481             
0072   0481             .include "stdio.asm"
0001+  0481             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0481             ; stdio.s
0003+  0481             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0481             .include "string.asm"
0001++ 0481             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0481             ; string.s
0003++ 0481             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0481             
0005++ 0481             
0006++ 0481             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0481             ; strrev
0008++ 0481             ; reverse a string
0009++ 0481             ; D = string address
0010++ 0481             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0481             ; 01234
0012++ 0481             strrev:
0013++ 0481 4B          	pusha
0014++ 0482 07 C8 04    	call strlen	; length in C
0015++ 0485 12          	mov a, c
0016++ 0486 AF 01 00    	cmp a, 1
0017++ 0489 D0 A3 04    	jleu strrev_end	; check string length. string len must be > 1
0018++ 048C 7D          	dec a
0019++ 048D FD 4E       	mov si, d	; beginning of string
0020++ 048F FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0491 59          	add d, a	; end of string
0022++ 0492 12          	mov a, c
0023++ 0493 FD 9B       	shr a		; divide by 2
0024++ 0495 39          	mov c, a	; C now counts the steps
0025++ 0496             strrev_L0:
0026++ 0496 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0497 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0498 3E          	mov [d], al	; store left char into right side
0029++ 0499 1B          	mov al, bl
0030++ 049A F7          	stosb		; store right-side char into left-side; increase DI
0031++ 049B 7E          	dec c
0032++ 049C 7F          	dec d
0033++ 049D C2 00 00    	cmp c, 0
0034++ 04A0 C7 96 04    	jne strrev_L0
0035++ 04A3             strrev_end:
0036++ 04A3 4C          	popa
0037++ 04A4 09          	ret
0038++ 04A5             	
0039++ 04A5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 04A5             ; strchr
0041++ 04A5             ; search string in D for char in AL
0042++ 04A5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 04A5             strchr:
0044++ 04A5             strchr_L0:
0045++ 04A5 32          	mov bl, [d]
0046++ 04A6 C1 00       	cmp bl, 0
0047++ 04A8 C6 B3 04    	je strchr_end
0048++ 04AB BA          	cmp al, bl
0049++ 04AC C6 B3 04    	je strchr_end
0050++ 04AF 79          	inc d
0051++ 04B0 0A A5 04    	jmp strchr_L0
0052++ 04B3             strchr_end:
0053++ 04B3 1B          	mov al, bl
0054++ 04B4 09          	ret
0055++ 04B5             
0056++ 04B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 04B5             ; strstr
0058++ 04B5             ; find sub-string
0059++ 04B5             ; str1 in SI
0060++ 04B5             ; str2 in DI
0061++ 04B5             ; SI points to end of source string
0062++ 04B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 04B5             strstr:
0064++ 04B5 DB          	push al
0065++ 04B6 DA          	push d
0066++ 04B7 E3          	push di
0067++ 04B8             strstr_loop:
0068++ 04B8 F3          	cmpsb					; compare a byte of the strings
0069++ 04B9 C7 C4 04    	jne strstr_ret
0070++ 04BC FC 00 00    	lea d, [di + 0]
0071++ 04BF BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 04C1 C7 B8 04    	jne strstr_loop				; equal chars but not at end
0073++ 04C4             strstr_ret:
0074++ 04C4 F0          	pop di
0075++ 04C5 E7          	pop d
0076++ 04C6 E8          	pop al
0077++ 04C7 09          	ret
0078++ 04C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 04C8             ; length of null terminated string
0080++ 04C8             ; result in C
0081++ 04C8             ; pointer in D
0082++ 04C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 04C8             strlen:
0084++ 04C8 DA          	push d
0085++ 04C9 38 00 00    	mov c, 0
0086++ 04CC             strlen_L1:
0087++ 04CC BD 00       	cmp byte [d], 0
0088++ 04CE C6 D6 04    	je strlen_ret
0089++ 04D1 79          	inc d
0090++ 04D2 78          	inc c
0091++ 04D3 0A CC 04    	jmp strlen_L1
0092++ 04D6             strlen_ret:
0093++ 04D6 E7          	pop d
0094++ 04D7 09          	ret
0095++ 04D8             
0096++ 04D8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 04D8             ; STRCMP
0098++ 04D8             ; compare two strings
0099++ 04D8             ; str1 in SI
0100++ 04D8             ; str2 in DI
0101++ 04D8             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 04D8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 04D8             strcmp:
0104++ 04D8 DB          	push al
0105++ 04D9 DA          	push d
0106++ 04DA E3          	push di
0107++ 04DB E2          	push si
0108++ 04DC             strcmp_loop:
0109++ 04DC F3          	cmpsb					; compare a byte of the strings
0110++ 04DD C7 E8 04    	jne strcmp_ret
0111++ 04E0 FB FF FF    	lea d, [si +- 1]
0112++ 04E3 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 04E5 C7 DC 04    	jne strcmp_loop				; equal chars but not at end
0114++ 04E8             strcmp_ret:
0115++ 04E8 EF          	pop si
0116++ 04E9 F0          	pop di
0117++ 04EA E7          	pop d
0118++ 04EB E8          	pop al
0119++ 04EC 09          	ret
0120++ 04ED             
0121++ 04ED             
0122++ 04ED             ; STRCPY
0123++ 04ED             ; copy null terminated string from SI to DI
0124++ 04ED             ; source in SI
0125++ 04ED             ; destination in DI
0126++ 04ED             strcpy:
0127++ 04ED E2          	push si
0128++ 04EE E3          	push di
0129++ 04EF DB          	push al
0130++ 04F0             strcpy_L1:
0131++ 04F0 F6          	lodsb
0132++ 04F1 F7          	stosb
0133++ 04F2 B9 00       	cmp al, 0
0134++ 04F4 C7 F0 04    	jne strcpy_L1
0135++ 04F7             strcpy_end:
0136++ 04F7 E8          	pop al
0137++ 04F8 F0          	pop di
0138++ 04F9 EF          	pop si
0139++ 04FA 09          	ret
0140++ 04FB             
0141++ 04FB             ; STRCAT
0142++ 04FB             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 04FB             ; source in SI
0144++ 04FB             ; destination in DI
0145++ 04FB             strcat:
0146++ 04FB E2          	push si
0147++ 04FC E3          	push di
0148++ 04FD D7          	push a
0149++ 04FE DA          	push d
0150++ 04FF 50          	mov a, di
0151++ 0500 3C          	mov d, a
0152++ 0501             strcat_goto_end_L1:
0153++ 0501 BD 00       	cmp byte[d], 0
0154++ 0503 C6 0A 05    	je strcat_start
0155++ 0506 79          	inc d
0156++ 0507 0A 01 05    	jmp strcat_goto_end_L1
0157++ 050A             strcat_start:
0158++ 050A FD 50       	mov di, d
0159++ 050C             strcat_L1:
0160++ 050C F6          	lodsb
0161++ 050D F7          	stosb
0162++ 050E B9 00       	cmp al, 0
0163++ 0510 C7 0C 05    	jne strcat_L1
0164++ 0513             strcat_end:
0165++ 0513 E7          	pop d
0166++ 0514 E4          	pop a
0167++ 0515 F0          	pop di
0168++ 0516 EF          	pop si
0169++ 0517 09          	ret
0005+  0518             
0006+  0518 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  051C 34 35 36 37 
0006+  0520 38 39 41 42 
0006+  0524 43 44 45 46 
0007+  0528 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  052C 1B 5B 48 00 
0008+  0530             
0009+  0530 01 00       table_power:.dw 1
0010+  0532 0A 00       			.dw 10
0011+  0534 64 00       			.dw 100
0012+  0536 E8 03       			.dw 1000
0013+  0538 10 27       			.dw 10000
0014+  053A             
0015+  053A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  053A             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  053A             ; ASCII in BL
0018+  053A             ; result in AL
0019+  053A             ; ascii for F = 0100 0110
0020+  053A             ; ascii for 9 = 0011 1001
0021+  053A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  053A             hex_ascii_encode:
0023+  053A 1B          	mov al, bl
0024+  053B 93 40       	test al, $40				; test if letter or number
0025+  053D C7 43 05    	jnz hex_letter
0026+  0540 87 0F       	and al, $0F				; get number
0027+  0542 09          	ret
0028+  0543             hex_letter:
0029+  0543 87 0F       	and al, $0F				; get letter
0030+  0545 6A 09       	add al, 9
0031+  0547 09          	ret
0032+  0548             
0033+  0548             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  0548             ; ATOI
0035+  0548             ; 2 letter hex string in B
0036+  0548             ; 8bit integer returned in AL
0037+  0548             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0548             atoi:
0039+  0548 D8          	push b
0040+  0549 07 3A 05    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  054C 30          	mov bl, bh
0042+  054D DB          	push al					; save a
0043+  054E 07 3A 05    	call hex_ascii_encode
0044+  0551 EA          	pop bl	
0045+  0552 FD 9E 04    	shl al, 4
0046+  0555 8C          	or al, bl
0047+  0556 E5          	pop b
0048+  0557 09          	ret	
0049+  0558             
0050+  0558             
0051+  0558             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  0558             ; printf
0053+  0558             ; no need for explanations!
0054+  0558             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0558             printf:
0056+  0558 09          	ret
0057+  0559             
0058+  0559             
0059+  0559             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  0559             ; scanf
0061+  0559             ; no need for explanations!
0062+  0559             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  0559             scanf:
0064+  0559 09          	ret
0065+  055A             
0066+  055A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  055A             ; ITOA
0068+  055A             ; 8bit value in BL
0069+  055A             ; 2 byte ASCII result in A
0070+  055A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  055A             itoa:
0072+  055A DA          	push d
0073+  055B D8          	push b
0074+  055C A7 00       	mov bh, 0
0075+  055E FD A4 04    	shr bl, 4	
0076+  0561 74          	mov d, b
0077+  0562 1F 18 05    	mov al, [d + s_hex_digits]
0078+  0565 23          	mov ah, al
0079+  0566             	
0080+  0566 E5          	pop b
0081+  0567 D8          	push b
0082+  0568 A7 00       	mov bh, 0
0083+  056A FD 87 0F    	and bl, $0F
0084+  056D 74          	mov d, b
0085+  056E 1F 18 05    	mov al, [d + s_hex_digits]
0086+  0571 E5          	pop b
0087+  0572 E7          	pop d
0088+  0573 09          	ret
0089+  0574             
0090+  0574             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  0574             ; HEX STRING TO BINARY
0092+  0574             ; di = destination address
0093+  0574             ; si = source
0094+  0574             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  0574             hex_to_int:
0096+  0574             hex_to_int_L1:
0097+  0574 F6          	lodsb					; load from [SI] to AL
0098+  0575 B9 00       	cmp al, 0				; check if ASCII 0
0099+  0577 C6 84 05    	jz hex_to_int_ret
0100+  057A 36          	mov bh, al
0101+  057B F6          	lodsb
0102+  057C 2F          	mov bl, al
0103+  057D 07 48 05    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  0580 F7          	stosb					; store AL to [DI]
0105+  0581 0A 74 05    	jmp hex_to_int_L1
0106+  0584             hex_to_int_ret:
0107+  0584 09          	ret		
0108+  0585             
0109+  0585             
0110+  0585             
0111+  0585             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  0585             ; GETCHAR
0113+  0585             ; char in ah
0114+  0585             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  0585             getchar:
0116+  0585 DB          	push al
0117+  0586             getchar_retry:
0118+  0586 FD 0C       	sti
0119+  0588 19 01       	mov al, 1
0120+  058A 05 03       	syscall sys_io			; receive in AH
0121+  058C B9 00       	cmp al, 0			; check if any char was receive
0122+  058E C6 86 05    	je getchar_retry
0123+  0591 E8          	pop al
0124+  0592 09          	ret
0125+  0593             
0126+  0593             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  0593             ; PUTCHAR
0128+  0593             ; char in ah
0129+  0593             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0593             putchar:
0131+  0593 D7          	push a
0132+  0594 19 00       	mov al, 0
0133+  0596 05 03       	syscall sys_io			; char in AH
0134+  0598 E4          	pop a
0135+  0599 09          	ret
0136+  059A             
0137+  059A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  059A             ;; INPUT A STRING
0139+  059A             ;; terminates with null
0140+  059A             ;; pointer in D
0141+  059A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  059A             gets:
0143+  059A D7          	push a
0144+  059B DA          	push d
0145+  059C             gets_loop:
0146+  059C FD 0C       	sti
0147+  059E 19 01       	mov al, 1
0148+  05A0 05 03       	syscall sys_io			; receive in AH
0149+  05A2 B9 00       	cmp al, 0				; check error code (AL)
0150+  05A4 C6 9C 05    	je gets_loop			; if no char received, retry
0151+  05A7             
0152+  05A7 76 1B       	cmp ah, 27
0153+  05A9 C6 CA 05    	je gets_telnet_escape
0154+  05AC 76 0A       	cmp ah, $0A				; LF
0155+  05AE C6 23 06    	je gets_end
0156+  05B1 76 0D       	cmp ah, $0D				; CR
0157+  05B3 C6 23 06    	je gets_end
0158+  05B6 76 5C       	cmp ah, $5C				; '\\'
0159+  05B8 C6 FA 05    	je gets_escape
0160+  05BB             	
0161+  05BB 76 08       	cmp ah, $08			; check for backspace
0162+  05BD C6 C6 05    	je gets_backspace
0163+  05C0             
0164+  05C0 1A          	mov al, ah
0165+  05C1 3E          	mov [d], al
0166+  05C2 79          	inc d
0167+  05C3 0A 9C 05    	jmp gets_loop
0168+  05C6             gets_backspace:
0169+  05C6 7F          	dec d
0170+  05C7 0A 9C 05    	jmp gets_loop
0171+  05CA             gets_telnet_escape:
0172+  05CA FD 0C       	sti
0173+  05CC 19 01       	mov al, 1
0174+  05CE 05 03       	syscall sys_io				; receive in AH without echo
0175+  05D0 B9 00       	cmp al, 0					; check error code (AL)
0176+  05D2 C6 CA 05    	je gets_telnet_escape		; if no char received, retry
0177+  05D5 76 5B       	cmp ah, '['
0178+  05D7 C7 9C 05    	jne gets_loop
0179+  05DA             gets_telnet_escape_phase2:
0180+  05DA FD 0C       	sti
0181+  05DC 19 01       	mov al, 1
0182+  05DE 05 03       	syscall sys_io					; receive in AH without echo
0183+  05E0 B9 00       	cmp al, 0						; check error code (AL)
0184+  05E2 C6 DA 05    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  05E5 76 44       	cmp ah, 'D'
0186+  05E7 C6 F2 05    	je gets_left_arrow
0187+  05EA 76 43       	cmp ah, 'C'
0188+  05EC C6 F6 05    	je gets_right_arrow
0189+  05EF 0A 9C 05    	jmp gets_loop
0190+  05F2             gets_left_arrow:
0191+  05F2 7F          	dec d
0192+  05F3 0A 9C 05    	jmp gets_loop
0193+  05F6             gets_right_arrow:
0194+  05F6 79          	inc d
0195+  05F7 0A 9C 05    	jmp gets_loop
0196+  05FA             gets_escape:
0197+  05FA FD 0C       	sti
0198+  05FC 19 01       	mov al, 1
0199+  05FE 05 03       	syscall sys_io			; receive in AH
0200+  0600 B9 00       	cmp al, 0				; check error code (AL)
0201+  0602 C6 FA 05    	je gets_escape			; if no char received, retry
0202+  0605 76 6E       	cmp ah, 'n'
0203+  0607 C6 15 06    	je gets_LF
0204+  060A 76 72       	cmp ah, 'r'
0205+  060C C6 1C 06    	je gets_CR
0206+  060F 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  0610 3E          	mov [d], al
0208+  0611 79          	inc d
0209+  0612 0A 9C 05    	jmp gets_loop
0210+  0615             gets_LF:
0211+  0615 19 0A       	mov al, $0A
0212+  0617 3E          	mov [d], al
0213+  0618 79          	inc d
0214+  0619 0A 9C 05    	jmp gets_loop
0215+  061C             gets_CR:
0216+  061C 19 0D       	mov al, $0D
0217+  061E 3E          	mov [d], al
0218+  061F 79          	inc d
0219+  0620 0A 9C 05    	jmp gets_loop
0220+  0623             gets_end:
0221+  0623 19 00       	mov al, 0
0222+  0625 3E          	mov [d], al				; terminate string
0223+  0626 E7          	pop d
0224+  0627 E4          	pop a
0225+  0628 09          	ret
0226+  0629             
0227+  0629             
0228+  0629             
0229+  0629             
0230+  0629             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  0629             ;; INPUT TEXT
0232+  0629             ;; terminated with CTRL+D
0233+  0629             ;; pointer in D
0234+  0629             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  0629             gettxt:
0236+  0629 D7          	push a
0237+  062A DA          	push d
0238+  062B             gettxt_loop:
0239+  062B 19 01       	mov al, 1
0240+  062D 05 03       	syscall sys_io			; receive in AH
0241+  062F B9 00       	cmp al, 0				; check error code (AL)
0242+  0631 C6 2B 06    	je gettxt_loop		; if no char received, retry
0243+  0634 76 04       	cmp ah, 4			; EOT
0244+  0636 C6 74 06    	je gettxt_end
0245+  0639 76 08       	cmp ah, $08			; check for backspace
0246+  063B C6 70 06    	je gettxt_backspace
0247+  063E 76 5C       	cmp ah, $5C				; '\\'
0248+  0640 C6 49 06    	je gettxt_escape
0249+  0643 1A          	mov al, ah
0250+  0644 3E          	mov [d], al
0251+  0645 79          	inc d
0252+  0646 0A 2B 06    	jmp gettxt_loop
0253+  0649             gettxt_escape:
0254+  0649 19 01       	mov al, 1
0255+  064B 05 03       	syscall sys_io			; receive in AH
0256+  064D B9 00       	cmp al, 0				; check error code (AL)
0257+  064F C6 49 06    	je gettxt_escape		; if no char received, retry
0258+  0652 76 6E       	cmp ah, 'n'
0259+  0654 C6 62 06    	je gettxt_LF
0260+  0657 76 72       	cmp ah, 'r'
0261+  0659 C6 69 06    	je gettxt_CR
0262+  065C 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  065D 3E          	mov [d], al
0264+  065E 79          	inc d
0265+  065F 0A 2B 06    	jmp gettxt_loop
0266+  0662             gettxt_LF:
0267+  0662 19 0A       	mov al, $0A
0268+  0664 3E          	mov [d], al
0269+  0665 79          	inc d
0270+  0666 0A 2B 06    	jmp gettxt_loop
0271+  0669             gettxt_CR:
0272+  0669 19 0D       	mov al, $0D
0273+  066B 3E          	mov [d], al
0274+  066C 79          	inc d
0275+  066D 0A 2B 06    	jmp gettxt_loop
0276+  0670             gettxt_backspace:
0277+  0670 7F          	dec d
0278+  0671 0A 2B 06    	jmp gettxt_loop
0279+  0674             gettxt_end:
0280+  0674 19 00       	mov al, 0
0281+  0676 3E          	mov [d], al				; terminate string
0282+  0677 E7          	pop d
0283+  0678 E4          	pop a
0284+  0679 09          	ret
0285+  067A             
0286+  067A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  067A             ; PRINT NEW LINE
0288+  067A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  067A             printnl:
0290+  067A D7          	push a
0291+  067B 10 00 0A    	mov a, $0A00
0292+  067E 05 03       	syscall sys_io
0293+  0680 10 00 0D    	mov a, $0D00
0294+  0683 05 03       	syscall sys_io
0295+  0685 E4          	pop a
0296+  0686 09          	ret
0297+  0687             
0298+  0687             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  0687             ; strtoint
0300+  0687             ; 4 digit hex string number in d
0301+  0687             ; integer returned in A
0302+  0687             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  0687             strtointx:
0304+  0687 D8          	push b
0305+  0688 32          	mov bl, [d]
0306+  0689 37          	mov bh, bl
0307+  068A 33 01 00    	mov bl, [d + 1]
0308+  068D 07 48 05    	call atoi				; convert to int in AL
0309+  0690 23          	mov ah, al				; move to AH
0310+  0691 33 02 00    	mov bl, [d + 2]
0311+  0694 37          	mov bh, bl
0312+  0695 33 03 00    	mov bl, [d + 3]
0313+  0698 07 48 05    	call atoi				; convert to int in AL
0314+  069B E5          	pop b
0315+  069C 09          	ret
0316+  069D             
0317+  069D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  069D             ; strtoint
0319+  069D             ; 5 digit base10 string number in d
0320+  069D             ; integer returned in A
0321+  069D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  069D             strtoint:
0323+  069D E2          	push si
0324+  069E D8          	push b
0325+  069F D9          	push c
0326+  06A0 DA          	push d
0327+  06A1 07 C8 04    	call strlen			; get string length in C
0328+  06A4 7E          	dec c
0329+  06A5 FD 4E       	mov si, d
0330+  06A7 12          	mov a, c
0331+  06A8 FD 99       	shl a
0332+  06AA 3B 30 05    	mov d, table_power
0333+  06AD 59          	add d, a
0334+  06AE 38 00 00    	mov c, 0
0335+  06B1             strtoint_L0:
0336+  06B1 F6          	lodsb			; load ASCII to al
0337+  06B2 B9 00       	cmp al, 0
0338+  06B4 C6 C7 06    	je strtoint_end
0339+  06B7 6F 30       	sub al, $30		; make into integer
0340+  06B9 22 00       	mov ah, 0
0341+  06BB 2A          	mov b, [d]
0342+  06BC AC          	mul a, b			; result in B since it fits in 16bits
0343+  06BD 11          	mov a, b
0344+  06BE 28          	mov b, c
0345+  06BF 54          	add a, b
0346+  06C0 39          	mov c, a
0347+  06C1 63 02 00    	sub d, 2
0348+  06C4 0A B1 06    	jmp strtoint_L0
0349+  06C7             strtoint_end:
0350+  06C7 12          	mov a, c
0351+  06C8 E7          	pop d
0352+  06C9 E6          	pop c
0353+  06CA E5          	pop b
0354+  06CB EF          	pop si
0355+  06CC 09          	ret
0356+  06CD             
0357+  06CD             
0358+  06CD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  06CD             ; PRINT NULL TERMINATED STRING
0360+  06CD             ; pointer in D
0361+  06CD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  06CD             puts:
0363+  06CD D7          	push a
0364+  06CE DA          	push d
0365+  06CF             puts_L1:
0366+  06CF 1E          	mov al, [d]
0367+  06D0 B9 00       	cmp al, 0
0368+  06D2 C6 DE 06    	jz puts_END
0369+  06D5 23          	mov ah, al
0370+  06D6 19 00       	mov al, 0
0371+  06D8 05 03       	syscall sys_io
0372+  06DA 79          	inc d
0373+  06DB 0A CF 06    	jmp puts_L1
0374+  06DE             puts_END:
0375+  06DE E7          	pop d
0376+  06DF E4          	pop a
0377+  06E0 09          	ret
0378+  06E1             
0379+  06E1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  06E1             ; PRINT N SIZE STRING
0381+  06E1             ; pointer in D
0382+  06E1             ; size in C
0383+  06E1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  06E1             putsn:
0385+  06E1 DB          	push al
0386+  06E2 DA          	push d
0387+  06E3 D9          	push c
0388+  06E4             putsn_L0:
0389+  06E4 1E          	mov al, [d]
0390+  06E5 23          	mov ah, al
0391+  06E6 19 00       	mov al, 0
0392+  06E8 05 03       	syscall sys_io
0393+  06EA 79          	inc d
0394+  06EB 7E          	dec c	
0395+  06EC C2 00 00    	cmp c, 0
0396+  06EF C7 E4 06    	jne putsn_L0
0397+  06F2             putsn_end:
0398+  06F2 E6          	pop c
0399+  06F3 E7          	pop d
0400+  06F4 E8          	pop al
0401+  06F5 09          	ret
0402+  06F6             
0403+  06F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  06F6             ; print 16bit decimal number
0405+  06F6             ; input number in A
0406+  06F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  06F6             print_u16d:
0408+  06F6 D7          	push a
0409+  06F7 D8          	push b
0410+  06F8 26 10 27    	mov b, 10000
0411+  06FB AE          	div a, b			; get 10000 coeff.
0412+  06FC 07 22 07    	call print_number
0413+  06FF 11          	mov a, b
0414+  0700 26 E8 03    	mov b, 1000
0415+  0703 AE          	div a, b			; get 10000 coeff.
0416+  0704 07 22 07    	call print_number
0417+  0707 11          	mov a, b
0418+  0708 26 64 00    	mov b, 100
0419+  070B AE          	div a, b
0420+  070C 07 22 07    	call print_number
0421+  070F 11          	mov a, b
0422+  0710 26 0A 00    	mov b, 10
0423+  0713 AE          	div a, b
0424+  0714 07 22 07    	call print_number
0425+  0717 11          	mov a, b
0426+  0718 6A 30       	add al, $30
0427+  071A 23          	mov ah, al
0428+  071B 19 00       	mov al, 0
0429+  071D 05 03       	syscall sys_io	; print coeff
0430+  071F E5          	pop b
0431+  0720 E4          	pop a
0432+  0721 09          	ret
0433+  0722             
0434+  0722             
0435+  0722             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  0722             ; if A == 0, print space
0437+  0722             ; else print A
0438+  0722             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0439+  0722             print_number:
0440+  0722 6A 30       	add al, $30
0441+  0724 23          	mov ah, al
0442+  0725 07 93 05    	call putchar
0443+  0728 09          	ret
0444+  0729             
0445+  0729             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0446+  0729             ; PRINT 16BIT HEX INTEGER
0447+  0729             ; integer value in reg B
0448+  0729             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  0729             print_u16x:
0450+  0729 D7          	push a
0451+  072A D8          	push b
0452+  072B DD          	push bl
0453+  072C 30          	mov bl, bh
0454+  072D 07 5A 05    	call itoa				; convert bh to char in A
0455+  0730 2F          	mov bl, al				; save al
0456+  0731 19 00       	mov al, 0
0457+  0733 05 03       	syscall sys_io				; display AH
0458+  0735 24          	mov ah, bl				; retrieve al
0459+  0736 19 00       	mov al, 0
0460+  0738 05 03       	syscall sys_io				; display AL
0461+  073A             
0462+  073A EA          	pop bl
0463+  073B 07 5A 05    	call itoa				; convert bh to char in A
0464+  073E 2F          	mov bl, al				; save al
0465+  073F 19 00       	mov al, 0
0466+  0741 05 03       	syscall sys_io				; display AH
0467+  0743 24          	mov ah, bl				; retrieve al
0468+  0744 19 00       	mov al, 0
0469+  0746 05 03       	syscall sys_io				; display AL
0470+  0748             
0471+  0748 E5          	pop b
0472+  0749 E4          	pop a
0473+  074A 09          	ret
0474+  074B             
0475+  074B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  074B             ; INPUT 16BIT HEX INTEGER
0477+  074B             ; read 16bit integer into A
0478+  074B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  074B             scan_u16x:
0480+  074B F8 10 00    	enter 16
0481+  074E D8          	push b
0482+  074F DA          	push d
0483+  0750             
0484+  0750 FA F1 FF    	lea d, [bp + -15]
0485+  0753 07 9A 05    	call gets				; get number
0486+  0756             
0487+  0756 32          	mov bl, [d]
0488+  0757 37          	mov bh, bl
0489+  0758 33 01 00    	mov bl, [d + 1]
0490+  075B 07 48 05    	call atoi				; convert to int in AL
0491+  075E 23          	mov ah, al				; move to AH
0492+  075F             
0493+  075F 33 02 00    	mov bl, [d + 2]
0494+  0762 37          	mov bh, bl
0495+  0763 33 03 00    	mov bl, [d + 3]
0496+  0766 07 48 05    	call atoi				; convert to int in AL
0497+  0769             
0498+  0769 E7          	pop d
0499+  076A E5          	pop b
0500+  076B F9          	leave
0501+  076C 09          	ret
0502+  076D             
0503+  076D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0504+  076D             ; PRINT 8bit HEX INTEGER
0505+  076D             ; integer value in reg bl
0506+  076D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  076D             print_u8x:
0508+  076D D7          	push a
0509+  076E DD          	push bl
0510+  076F             
0511+  076F 07 5A 05    	call itoa				; convert bl to char in A
0512+  0772 2F          	mov bl, al				; save al
0513+  0773 19 00       	mov al, 0
0514+  0775 05 03       	syscall sys_io				; display AH
0515+  0777 24          	mov ah, bl				; retrieve al
0516+  0778 19 00       	mov al, 0
0517+  077A 05 03       	syscall sys_io				; display AL
0518+  077C             
0519+  077C EA          	pop bl
0520+  077D E4          	pop a
0521+  077E 09          	ret
0522+  077F             
0523+  077F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0524+  077F             ; print 8bit decimal unsigned number
0525+  077F             ; input number in AL
0526+  077F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  077F             print_u8d:
0528+  077F D7          	push a
0529+  0780 D8          	push b
0530+  0781             
0531+  0781 22 00       	mov ah, 0
0532+  0783 26 64 00    	mov b, 100
0533+  0786 AE          	div a, b
0534+  0787 D8          	push b			; save remainder
0535+  0788 B9 00       	cmp al, 0
0536+  078A C6 94 07    	je skip100
0537+  078D 6A 30       	add al, $30
0538+  078F 23          	mov ah, al
0539+  0790 19 00       	mov al, 0
0540+  0792 05 03       	syscall sys_io	; print coeff
0541+  0794             skip100:
0542+  0794 E4          	pop a
0543+  0795 22 00       	mov ah, 0
0544+  0797 26 0A 00    	mov b, 10
0545+  079A AE          	div a, b
0546+  079B D8          	push b			; save remainder
0547+  079C B9 00       	cmp al, 0
0548+  079E C6 A8 07    	je skip10
0549+  07A1 6A 30       	add al, $30
0550+  07A3 23          	mov ah, al
0551+  07A4 19 00       	mov al, 0
0552+  07A6 05 03       	syscall sys_io	; print coeff
0553+  07A8             skip10:
0554+  07A8 E4          	pop a
0555+  07A9 1B          	mov al, bl
0556+  07AA 6A 30       	add al, $30
0557+  07AC 23          	mov ah, al
0558+  07AD 19 00       	mov al, 0
0559+  07AF 05 03       	syscall sys_io	; print coeff
0560+  07B1 E5          	pop b
0561+  07B2 E4          	pop a
0562+  07B3 09          	ret
0563+  07B4             
0564+  07B4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0565+  07B4             ; INPUT 8BIT HEX INTEGER
0566+  07B4             ; read 8bit integer into AL
0567+  07B4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  07B4             scan_u8x:
0569+  07B4 F8 04 00    	enter 4
0570+  07B7 D8          	push b
0571+  07B8 DA          	push d
0572+  07B9             
0573+  07B9 FA FD FF    	lea d, [bp + -3]
0574+  07BC 07 9A 05    	call gets				; get number
0575+  07BF             
0576+  07BF 32          	mov bl, [d]
0577+  07C0 37          	mov bh, bl
0578+  07C1 33 01 00    	mov bl, [d + 1]
0579+  07C4 07 48 05    	call atoi				; convert to int in AL
0580+  07C7             
0581+  07C7 E7          	pop d
0582+  07C8 E5          	pop b
0583+  07C9 F9          	leave
0584+  07CA 09          	ret
0585+  07CB             
0586+  07CB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  07CB             ; input decimal number
0588+  07CB             ; result in A
0589+  07CB             ; 655'\0'
0590+  07CB             ; low--------high
0591+  07CB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0592+  07CB             scan_u16d:
0593+  07CB F8 08 00    	enter 8
0594+  07CE E2          	push si
0595+  07CF D8          	push b
0596+  07D0 D9          	push c
0597+  07D1 DA          	push d
0598+  07D2 FA F9 FF    	lea d, [bp +- 7]
0599+  07D5 07 9A 05    	call gets
0600+  07D8 07 C8 04    	call strlen			; get string length in C
0601+  07DB 7E          	dec c
0602+  07DC FD 4E       	mov si, d
0603+  07DE 12          	mov a, c
0604+  07DF FD 99       	shl a
0605+  07E1 3B 30 05    	mov d, table_power
0606+  07E4 59          	add d, a
0607+  07E5 38 00 00    	mov c, 0
0608+  07E8             mul_loop:
0609+  07E8 F6          	lodsb			; load ASCII to al
0610+  07E9 B9 00       	cmp al, 0
0611+  07EB C6 FE 07    	je mul_exit
0612+  07EE 6F 30       	sub al, $30		; make into integer
0613+  07F0 22 00       	mov ah, 0
0614+  07F2 2A          	mov b, [d]
0615+  07F3 AC          	mul a, b			; result in B since it fits in 16bits
0616+  07F4 11          	mov a, b
0617+  07F5 28          	mov b, c
0618+  07F6 54          	add a, b
0619+  07F7 39          	mov c, a
0620+  07F8 63 02 00    	sub d, 2
0621+  07FB 0A E8 07    	jmp mul_loop
0622+  07FE             mul_exit:
0623+  07FE 12          	mov a, c
0624+  07FF E7          	pop d
0625+  0800 E6          	pop c
0626+  0801 E5          	pop b
0627+  0802 EF          	pop si
0628+  0803 F9          	leave
0629+  0804 09          	ret
0073   0805             .include "token.asm"
0001+  0805             TOKTYP_IDENTIFIER	.equ 0
0002+  0805             TOKTYP_KEYWORD		.equ 1
0003+  0805             TOKTYP_DELIMITER	.equ 2
0004+  0805             TOKTYP_STRING		.equ 3
0005+  0805             TOKTYP_CHAR			.equ 4
0006+  0805             TOKTYP_NUMERIC		.equ 5
0007+  0805             TOKTYP_END			.equ 6
0008+  0805             
0009+  0805             TOK_NULL			.equ 0
0010+  0805             TOK_FSLASH			.equ 1
0011+  0805             TOK_TIMES 			.equ 2
0012+  0805             TOK_PLUS 			.equ 3
0013+  0805             TOK_MINUS 			.equ 4
0014+  0805             TOK_DOT				.equ 5
0015+  0805             TOK_SEMI			.equ 6
0016+  0805             TOK_ANGLE			.equ 7
0017+  0805             TOK_TILDE			.equ 8
0018+  0805             TOK_EQUAL			.equ 9
0019+  0805             TOK_COLON			.equ 10
0020+  0805             TOK_COMMA			.equ 11
0021+  0805             
0022+  0805             TOK_END				.equ 20
0023+  0805             
0024+  0805             
0025+  0805             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  0805             ;; read a full command argment from shell input buffer
0027+  0805             ;; argument is written into tokstr
0028+  0805             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  0805             get_arg:
0030+  0805 D7          	push a
0031+  0806 E2          	push si
0032+  0807 E3          	push di
0033+  0808 19 00       	mov al, 0
0034+  080A 3D 33 0A    	mov [tokstr], al			; nullify tokstr string
0035+  080D 14 2F 0A    	mov a, [prog]
0036+  0810 4D          	mov si, a
0037+  0811 FD 4F 33 0A 	mov di, tokstr
0038+  0815             get_arg_skip_spaces:
0039+  0815 F6          	lodsb
0040+  0816 07 A9 0B    	call isspace
0041+  0819 C6 15 08    	je get_arg_skip_spaces
0042+  081C             get_arg_L0:
0043+  081C B9 3B       	cmp al, $3B				; check if is ';'
0044+  081E C6 2B 08    	je get_arg_end
0045+  0821 B9 00       	cmp al, 0
0046+  0823 C6 2B 08    	je get_arg_end			; check if end of input
0047+  0826 F7          	stosb
0048+  0827 F6          	lodsb
0049+  0828 0A 1C 08    	jmp get_arg_L0
0050+  082B             get_arg_end:
0051+  082B 19 00       	mov al, 0
0052+  082D F7          	stosb
0053+  082E D5 01 00    	sub si, 1
0054+  0831 4E          	mov a, si
0055+  0832 42 2F 0A    	mov [prog], a		; update pointer
0056+  0835 F0          	pop di
0057+  0836 EF          	pop si
0058+  0837 E4          	pop a
0059+  0838 09          	ret
0060+  0839             
0061+  0839             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  0839             ;; read a path formation from shell input buffer
0063+  0839             ;; path is written into tokstr
0064+  0839             ;; /usr/bin
0065+  0839             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  0839             get_path:
0067+  0839 D7          	push a
0068+  083A E2          	push si
0069+  083B E3          	push di
0070+  083C 19 00       	mov al, 0
0071+  083E 3D 33 0A    	mov [tokstr], al			; nullify tokstr string
0072+  0841 14 2F 0A    	mov a, [prog]
0073+  0844 4D          	mov si, a
0074+  0845 FD 4F 33 0A 	mov di, tokstr
0075+  0849             get_path_skip_spaces:
0076+  0849 F6          	lodsb
0077+  084A 07 A9 0B    	call isspace
0078+  084D C6 49 08    	je get_path_skip_spaces
0079+  0850             get_path_is_pathchar:
0080+  0850 F7          	stosb
0081+  0851 F6          	lodsb
0082+  0852 07 33 0B    	call isalnum			;check if is alphanumeric
0083+  0855 C6 50 08    	je get_path_is_pathchar
0084+  0858 B9 2F       	cmp al, '/'				; check if is '/'
0085+  085A C6 50 08    	je get_path_is_pathchar
0086+  085D 19 00       	mov al, 0
0087+  085F F7          	stosb
0088+  0860 D5 01 00    	sub si, 1
0089+  0863 4E          	mov a, si
0090+  0864 42 2F 0A    	mov [prog], a		; update pointer
0091+  0867             get_path_end:
0092+  0867 F0          	pop di
0093+  0868 EF          	pop si
0094+  0869 E4          	pop a
0095+  086A 09          	ret
0096+  086B             
0097+  086B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  086B             ;; read a line
0099+  086B             ;; line is written into tokstr
0100+  086B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  086B             get_line:
0102+  086B D7          	push a
0103+  086C E2          	push si
0104+  086D E3          	push di
0105+  086E 19 00       	mov al, 0
0106+  0870 3D 33 0A    	mov [tokstr], al			; nullify tokstr string
0107+  0873 14 2F 0A    	mov a, [prog]
0108+  0876 4D          	mov si, a
0109+  0877 FD 4F 33 0A 	mov di, tokstr
0110+  087B             get_line_L0:
0111+  087B F6          	lodsb
0112+  087C B9 0A       	cmp al, $0A		; check for new line
0113+  087E C6 85 08    	je get_line_exit
0114+  0881 F7          	stosb
0115+  0882 0A 7B 08    	jmp get_line_L0
0116+  0885             get_line_exit:
0117+  0885 19 00       	mov al, 0
0118+  0887 F7          	stosb
0119+  0888 4E          	mov a, si
0120+  0889 42 2F 0A    	mov [prog], a		; update pointer
0121+  088C F0          	pop di
0122+  088D EF          	pop si
0123+  088E E4          	pop a
0124+  088F 09          	ret
0125+  0890             
0126+  0890             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  0890             ;; token parser
0128+  0890             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  0890             get_token:
0130+  0890 D7          	push a
0131+  0891 DA          	push d
0132+  0892 E2          	push si
0133+  0893 E3          	push di
0134+  0894 19 00       	mov al, 0
0135+  0896 3D 33 0A    	mov [tokstr], al			; nullify tokstr string
0136+  0899 19 00       	mov al, TOK_NULL
0137+  089B 3D 32 0A    	mov [tok], al				; nullify token
0138+  089E 14 2F 0A    	mov a, [prog]
0139+  08A1 4D          	mov si, a
0140+  08A2 FD 4F 33 0A 	mov di, tokstr
0141+  08A6             get_tok_skip_spaces:
0142+  08A6 F6          	lodsb
0143+  08A7 07 A9 0B    	call isspace
0144+  08AA C6 A6 08    	je get_tok_skip_spaces
0145+  08AD B9 00       	cmp al, 0			; check for end of input (NULL)
0146+  08AF C6 94 09    	je get_token_end
0147+  08B2 B9 23       	cmp al, '#'			; comments!
0148+  08B4 C6 C2 09    	je get_tok_comment
0149+  08B7 07 33 0B    	call isalnum
0150+  08BA C6 A1 09    	jz is_alphanumeric
0151+  08BD             ; other token types
0152+  08BD             get_token_slash:
0153+  08BD B9 2F       	cmp al, '/'				; check if '/'
0154+  08BF C7 D7 08    	jne get_token_minus
0155+  08C2 F7          	stosb					; store '/' into token string
0156+  08C3 19 00       	mov al, 0
0157+  08C5 F7          	stosb					; terminate token string
0158+  08C6 19 01       	mov al, TOK_FSLASH
0159+  08C8 3D 32 0A    	mov [tok], al			
0160+  08CB 19 02       	mov al, TOKTYP_DELIMITER
0161+  08CD 3D 31 0A    	mov [toktyp], al
0162+  08D0 4E          	mov a, si
0163+  08D1 42 2F 0A    	mov [prog], a		; update pointer
0164+  08D4 0A BD 09    	jmp get_token_return
0165+  08D7             get_token_minus:
0166+  08D7 B9 2D       	cmp al, '-'				; check if '-'
0167+  08D9 C7 F1 08    	jne get_token_comma
0168+  08DC F7          	stosb					; store '-' into token string
0169+  08DD 19 00       	mov al, 0
0170+  08DF F7          	stosb					; terminate token string
0171+  08E0 19 04       	mov al, TOK_MINUS
0172+  08E2 3D 32 0A    	mov [tok], al			
0173+  08E5 19 02       	mov al, TOKTYP_DELIMITER
0174+  08E7 3D 31 0A    	mov [toktyp], al
0175+  08EA 4E          	mov a, si
0176+  08EB 42 2F 0A    	mov [prog], a		; update pointer
0177+  08EE 0A BD 09    	jmp get_token_return
0178+  08F1             get_token_comma:
0179+  08F1 B9 2C       	cmp al, ','				; check if ','
0180+  08F3 C7 0B 09    	jne get_token_semi
0181+  08F6 F7          	stosb					; store ',' into token string
0182+  08F7 19 00       	mov al, 0
0183+  08F9 F7          	stosb					; terminate token string
0184+  08FA 19 0B       	mov al, TOK_COMMA
0185+  08FC 3D 32 0A    	mov [tok], al			
0186+  08FF 19 02       	mov al, TOKTYP_DELIMITER
0187+  0901 3D 31 0A    	mov [toktyp], al
0188+  0904 4E          	mov a, si
0189+  0905 42 2F 0A    	mov [prog], a		; update pointer
0190+  0908 0A BD 09    	jmp get_token_return
0191+  090B             get_token_semi:
0192+  090B B9 3B       	cmp al, $3B				; check if ';'
0193+  090D C7 25 09    	jne get_token_colon
0194+  0910 F7          	stosb					; store ';' into token string
0195+  0911 19 00       	mov al, 0
0196+  0913 F7          	stosb					; terminate token string
0197+  0914 19 06       	mov al, TOK_SEMI
0198+  0916 3D 32 0A    	mov [tok], al			
0199+  0919 19 02       	mov al, TOKTYP_DELIMITER
0200+  091B 3D 31 0A    	mov [toktyp], al
0201+  091E 4E          	mov a, si
0202+  091F 42 2F 0A    	mov [prog], a		; update pointer
0203+  0922 0A BD 09    	jmp get_token_return
0204+  0925             get_token_colon:
0205+  0925 B9 3A       	cmp al, $3A				; check if ':'
0206+  0927 C7 3F 09    	jne get_token_angle
0207+  092A F7          	stosb					; store ':' into token string
0208+  092B 19 00       	mov al, 0
0209+  092D F7          	stosb					; terminate token string
0210+  092E 19 0A       	mov al, TOK_COLON
0211+  0930 3D 32 0A    	mov [tok], al			
0212+  0933 19 02       	mov al, TOKTYP_DELIMITER
0213+  0935 3D 31 0A    	mov [toktyp], al
0214+  0938 4E          	mov a, si
0215+  0939 42 2F 0A    	mov [prog], a		; update pointer
0216+  093C 0A BD 09    	jmp get_token_return
0217+  093F             get_token_angle:
0218+  093F B9 3E       	cmp al, $3E				; check if '>'
0219+  0941 C7 59 09    	jne get_token_tilde
0220+  0944 F7          	stosb					; store '>' into token string
0221+  0945 19 00       	mov al, 0
0222+  0947 F7          	stosb					; terminate token string
0223+  0948 19 07       	mov al, TOK_ANGLE
0224+  094A 3D 32 0A    	mov [tok], al			
0225+  094D 19 02       	mov al, TOKTYP_DELIMITER
0226+  094F 3D 31 0A    	mov [toktyp], al
0227+  0952 4E          	mov a, si
0228+  0953 42 2F 0A    	mov [prog], a		; update pointer
0229+  0956 0A BD 09    	jmp get_token_return
0230+  0959             get_token_tilde:
0231+  0959 B9 7E       	cmp al, '~'				; check if '~'
0232+  095B C7 73 09    	jne get_token_equal
0233+  095E F7          	stosb					; store '~' into token string
0234+  095F 19 00       	mov al, 0
0235+  0961 F7          	stosb					; terminate token string
0236+  0962 19 08       	mov al, TOK_TILDE
0237+  0964 3D 32 0A    	mov [tok], al			
0238+  0967 19 02       	mov al, TOKTYP_DELIMITER
0239+  0969 3D 31 0A    	mov [toktyp], al
0240+  096C 4E          	mov a, si
0241+  096D 42 2F 0A    	mov [prog], a		; update pointer
0242+  0970 0A BD 09    	jmp get_token_return
0243+  0973             get_token_equal:
0244+  0973 B9 3D       	cmp al, '='				; check if '='
0245+  0975 C7 8D 09    	jne get_token_skip
0246+  0978 F7          	stosb					; store '=' into token string
0247+  0979 19 00       	mov al, 0
0248+  097B F7          	stosb					; terminate token string
0249+  097C 19 09       	mov al, TOK_EQUAL
0250+  097E 3D 32 0A    	mov [tok], al			
0251+  0981 19 02       	mov al, TOKTYP_DELIMITER
0252+  0983 3D 31 0A    	mov [toktyp], al
0253+  0986 4E          	mov a, si
0254+  0987 42 2F 0A    	mov [prog], a		; update pointer
0255+  098A 0A BD 09    	jmp get_token_return
0256+  098D             get_token_skip:
0257+  098D 4E          	mov a, si
0258+  098E 42 2F 0A    	mov [prog], a		; update pointer
0259+  0991 0A BD 09    	jmp get_token_return
0260+  0994             get_token_end:				; end of file token
0261+  0994 19 14       	mov al, TOK_END
0262+  0996 3D 32 0A    	mov [tok], al
0263+  0999 19 06       	mov al, TOKTYP_END
0264+  099B 3D 31 0A    	mov [toktyp], al
0265+  099E 0A BD 09    	jmp get_token_return
0266+  09A1             is_alphanumeric:
0267+  09A1 F7          	stosb
0268+  09A2 F6          	lodsb
0269+  09A3 07 33 0B    	call isalnum			;check if is alphanumeric
0270+  09A6 C6 A1 09    	jz is_alphanumeric
0271+  09A9 B9 2E       	cmp al, $2E				; check if is '.'
0272+  09AB C6 A1 09    	je is_alphanumeric
0273+  09AE 19 00       	mov al, 0
0274+  09B0 F7          	stosb
0275+  09B1 19 00       	mov al, TOKTYP_IDENTIFIER
0276+  09B3 3D 31 0A    	mov [toktyp], al
0277+  09B6 D5 01 00    	sub si, 1
0278+  09B9 4E          	mov a, si
0279+  09BA 42 2F 0A    	mov [prog], a		; update pointer
0280+  09BD             get_token_return:
0281+  09BD F0          	pop di
0282+  09BE EF          	pop si
0283+  09BF E7          	pop d
0284+  09C0 E4          	pop a
0285+  09C1 09          	ret
0286+  09C2             get_tok_comment:
0287+  09C2 F6          	lodsb
0288+  09C3 B9 0A       	cmp al, $0A			; new line
0289+  09C5 C7 C2 09    	jne get_tok_comment
0290+  09C8 0A A6 08    	jmp get_tok_skip_spaces
0291+  09CB             
0292+  09CB             
0293+  09CB             get_number:
0294+  09CB D7          	push a
0295+  09CC DA          	push d
0296+  09CD E2          	push si
0297+  09CE E3          	push di
0298+  09CF 19 00       	mov al, 0
0299+  09D1 3D 33 0A    	mov [tokstr], al			; nullify tokstr string
0300+  09D4 19 00       	mov al, TOK_NULL
0301+  09D6 3D 32 0A    	mov [tok], al				; nullify token
0302+  09D9 14 2F 0A    	mov a, [prog]
0303+  09DC 4D          	mov si, a
0304+  09DD FD 4F 33 0A 	mov di, tokstr
0305+  09E1             get_number_skip_spaces:
0306+  09E1 F6          	lodsb
0307+  09E2 07 A9 0B    	call isspace
0308+  09E5 C6 E1 09    	je get_number_skip_spaces
0309+  09E8 B9 00       	cmp al, 0			; check for end of input (NULL)
0310+  09EA C7 FA 09    	jne get_number_L0
0311+  09ED 19 14       	mov al, TOK_END
0312+  09EF 3D 32 0A    	mov [tok], al
0313+  09F2 19 06       	mov al, TOKTYP_END
0314+  09F4 3D 31 0A    	mov [toktyp], al
0315+  09F7 0A 11 0A    	jmp get_number_return
0316+  09FA             get_number_L0:
0317+  09FA F7          	stosb
0318+  09FB F6          	lodsb
0319+  09FC 07 3D 0B    	call isdigit			;check if is numeric
0320+  09FF C6 FA 09    	jz get_number_L0
0321+  0A02 19 00       	mov al, 0
0322+  0A04 F7          	stosb
0323+  0A05 19 05       	mov al, TOKTYP_NUMERIC
0324+  0A07 3D 31 0A    	mov [toktyp], al
0325+  0A0A D5 01 00    	sub si, 1
0326+  0A0D 4E          	mov a, si
0327+  0A0E 42 2F 0A    	mov [prog], a		; update pointer
0328+  0A11             get_number_return:
0329+  0A11 F0          	pop di
0330+  0A12 EF          	pop si
0331+  0A13 E7          	pop d
0332+  0A14 E4          	pop a
0333+  0A15 09          	ret
0334+  0A16             
0335+  0A16             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  0A16             ;; PUT BACK TOKEN
0337+  0A16             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
0338+  0A16             putback:
0339+  0A16 D7          	push a
0340+  0A17 E2          	push si
0341+  0A18 FD 4D 33 0A 	mov si, tokstr	
0342+  0A1C             putback_loop:
0343+  0A1C F6          	lodsb
0344+  0A1D B9 00       	cmp al, 0
0345+  0A1F C6 2C 0A    	je putback_end
0346+  0A22 14 2F 0A    	mov a, [prog]
0347+  0A25 7D          	dec a
0348+  0A26 42 2F 0A    	mov [prog], a			; update pointer
0349+  0A29 0A 1C 0A    	jmp putback_loop
0350+  0A2C             putback_end:
0351+  0A2C EF          	pop si
0352+  0A2D E4          	pop a
0353+  0A2E 09          	ret
0354+  0A2F             
0355+  0A2F             
0356+  0A2F             
0357+  0A2F             
0358+  0A2F 00 00       prog:		.dw 0			; pointer to current position in buffer
0359+  0A31             
0360+  0A31 00          toktyp: 	.db 0			; token type symbol
0361+  0A32 00          tok:		.db 0			; current token symbol
0362+  0A33 00 00 00 00 tokstr:		.fill 256, 0	; token as a string
0362+  0A37 00 00 00 00 
0362+  0A3B 00 00 00 00 
0362+  0A3F 00 00 00 00 
0362+  0A43 00 00 00 00 
0362+  0A47 00 00 00 00 
0362+  0A4B 00 00 00 00 
0362+  0A4F 00 00 00 00 
0362+  0A53 00 00 00 00 
0362+  0A57 00 00 00 00 
0362+  0A5B 00 00 00 00 
0362+  0A5F 00 00 00 00 
0362+  0A63 00 00 00 00 
0362+  0A67 00 00 00 00 
0362+  0A6B 00 00 00 00 
0362+  0A6F 00 00 00 00 
0362+  0A73 00 00 00 00 
0362+  0A77 00 00 00 00 
0362+  0A7B 00 00 00 00 
0362+  0A7F 00 00 00 00 
0362+  0A83 00 00 00 00 
0362+  0A87 00 00 00 00 
0362+  0A8B 00 00 00 00 
0362+  0A8F 00 00 00 00 
0362+  0A93 00 00 00 00 
0362+  0A97 00 00 00 00 
0362+  0A9B 00 00 00 00 
0362+  0A9F 00 00 00 00 
0362+  0AA3 00 00 00 00 
0362+  0AA7 00 00 00 00 
0362+  0AAB 00 00 00 00 
0362+  0AAF 00 00 00 00 
0362+  0AB3 00 00 00 00 
0362+  0AB7 00 00 00 00 
0362+  0ABB 00 00 00 00 
0362+  0ABF 00 00 00 00 
0362+  0AC3 00 00 00 00 
0362+  0AC7 00 00 00 00 
0362+  0ACB 00 00 00 00 
0362+  0ACF 00 00 00 00 
0362+  0AD3 00 00 00 00 
0362+  0AD7 00 00 00 00 
0362+  0ADB 00 00 00 00 
0362+  0ADF 00 00 00 00 
0362+  0AE3 00 00 00 00 
0362+  0AE7 00 00 00 00 
0362+  0AEB 00 00 00 00 
0362+  0AEF 00 00 00 00 
0362+  0AF3 00 00 00 00 
0362+  0AF7 00 00 00 00 
0362+  0AFB 00 00 00 00 
0362+  0AFF 00 00 00 00 
0362+  0B03 00 00 00 00 
0362+  0B07 00 00 00 00 
0362+  0B0B 00 00 00 00 
0362+  0B0F 00 00 00 00 
0362+  0B13 00 00 00 00 
0362+  0B17 00 00 00 00 
0362+  0B1B 00 00 00 00 
0362+  0B1F 00 00 00 00 
0362+  0B23 00 00 00 00 
0362+  0B27 00 00 00 00 
0362+  0B2B 00 00 00 00 
0362+  0B2F 00 00 00 00 
0074   0B33             .include "ctype.asm"
0001+  0B33             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0B33             ; ctype.s
0003+  0B33             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0B33             
0005+  0B33             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  0B33             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  0B33             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  0B33             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  0B33             ;; characters are supported.
0010+  0B33             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  0B33             ;; isalnum 
0012+  0B33             ;; isalpha 
0013+  0B33             ;; islower 
0014+  0B33             ;; isupper 
0015+  0B33             ;; isdigit 
0016+  0B33             ;; isxdigit
0017+  0B33             ;; iscntrl 
0018+  0B33             ;; isgraph 
0019+  0B33             ;; isspace 
0020+  0B33             ;; isblank 
0021+  0B33             ;; isprint 
0022+  0B33             ;; ispunct 
0023+  0B33             ;; tolower 
0024+  0B33             ;; toupper
0025+  0B33             
0026+  0B33             
0027+  0B33             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  0B33             ;; IS ALPHANUMERIC
0029+  0B33             ;; sets ZF according with result
0030+  0B33             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  0B33             isalnum:
0032+  0B33 07 50 0B    	call isalpha
0033+  0B36 C6 3C 0B    	je isalnum_exit
0034+  0B39 07 3D 0B    	call isdigit
0035+  0B3C             isalnum_exit:
0036+  0B3C 09          	ret	
0037+  0B3D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0B3D             ;; IS DIGIT
0039+  0B3D             ;; sets ZF according with result
0040+  0B3D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  0B3D             isdigit:
0042+  0B3D DB          	push al
0043+  0B3E B9 30       	cmp al, '0'
0044+  0B40 C8 4C 0B    	jlu isdigit_false
0045+  0B43 B9 39       	cmp al, '9'
0046+  0B45 D1 4C 0B    	jgu isdigit_false
0047+  0B48 87 00       	and al, 0	; set ZF
0048+  0B4A E8          	pop al
0049+  0B4B 09          	ret
0050+  0B4C             isdigit_false:
0051+  0B4C 8B 01       	or al, 1	; clear ZF
0052+  0B4E E8          	pop al
0053+  0B4F 09          	ret	
0054+  0B50             	
0055+  0B50             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  0B50             ;; IS ALPHA
0057+  0B50             ;; sets ZF according with result
0058+  0B50             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  0B50             isalpha:
0060+  0B50 DB          	push al
0061+  0B51 B9 5F       	cmp al, '_'
0062+  0B53 C6 73 0B    	je isalpha_true
0063+  0B56 B9 2E       	cmp al, '.'
0064+  0B58 C6 73 0B    	je isalpha_true
0065+  0B5B B9 41       	cmp al, 'A'
0066+  0B5D C8 6F 0B    	jlu isalpha_false
0067+  0B60 B9 7A       	cmp al, 'z'
0068+  0B62 D1 6F 0B    	jgu isalpha_false
0069+  0B65 B9 5A       	cmp al, 'Z'
0070+  0B67 D0 73 0B    	jleu isalpha_true
0071+  0B6A B9 61       	cmp al, 'a'
0072+  0B6C C9 73 0B    	jgeu isalpha_true
0073+  0B6F             isalpha_false:
0074+  0B6F 8B 01       	or al, 1	; clear ZF
0075+  0B71 E8          	pop al
0076+  0B72 09          	ret
0077+  0B73             isalpha_true:
0078+  0B73 87 00       	and al, 0	; set ZF
0079+  0B75 E8          	pop al
0080+  0B76 09          	ret
0081+  0B77             
0082+  0B77             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  0B77             ;; IS PATH-ALPHA
0084+  0B77             ;; sets ZF according with result
0085+  0B77             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  0B77             ispath:
0087+  0B77 DB          	push al
0088+  0B78 07 3D 0B    	call isdigit
0089+  0B7B C6 A5 0B    	je ispath_true
0090+  0B7E B9 5F       	cmp al, '_'
0091+  0B80 C6 A5 0B    	je ispath_true
0092+  0B83 B9 2F       	cmp al, '/'
0093+  0B85 C6 A5 0B    	je ispath_true
0094+  0B88 B9 2E       	cmp al, '.'
0095+  0B8A C6 A5 0B    	je ispath_true
0096+  0B8D B9 41       	cmp al, 'A'
0097+  0B8F C8 A1 0B    	jlu ispath_false
0098+  0B92 B9 7A       	cmp al, 'z'
0099+  0B94 D1 A1 0B    	jgu ispath_false
0100+  0B97 B9 5A       	cmp al, 'Z'
0101+  0B99 D0 A5 0B    	jleu ispath_true
0102+  0B9C B9 61       	cmp al, 'a'
0103+  0B9E C9 A5 0B    	jgeu ispath_true
0104+  0BA1             ispath_false:
0105+  0BA1 8B 01       	or al, 1	; clear ZF
0106+  0BA3 E8          	pop al
0107+  0BA4 09          	ret
0108+  0BA5             ispath_true:
0109+  0BA5 87 00       	and al, 0	; set ZF
0110+  0BA7 E8          	pop al
0111+  0BA8 09          	ret
0112+  0BA9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  0BA9             ;; IS SPACE
0114+  0BA9             ;; sets ZF according with result
0115+  0BA9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  0BA9             isspace:
0117+  0BA9 B9 20       	cmp al, $20		; ' '
0118+  0BAB C6 BF 0B    	je isspace_exit
0119+  0BAE B9 09       	cmp al, $09		; '\t'
0120+  0BB0 C6 BF 0B    	je isspace_exit
0121+  0BB3 B9 0A       	cmp al, $0A		; '\n'
0122+  0BB5 C6 BF 0B    	je isspace_exit
0123+  0BB8 B9 0D       	cmp al, $0D		; '\r'
0124+  0BBA C6 BF 0B    	je isspace_exit
0125+  0BBD B9 0B       	cmp al, $0B		; '\v'
0126+  0BBF             isspace_exit:
0127+  0BBF 09          	ret	
0128+  0BC0             
0129+  0BC0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0BC0             ; TO LOWER
0131+  0BC0             ; input in AL
0132+  0BC0             ; output in AL
0133+  0BC0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  0BC0             to_lower:
0135+  0BC0 B9 5A       	cmp al, 'Z'
0136+  0BC2 D1 C7 0B    	jgu to_lower_ret
0137+  0BC5 6A 20       	add al, $20				; convert to lower case
0138+  0BC7             to_lower_ret:
0139+  0BC7 09          	ret
0140+  0BC8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  0BC8             ; TO UPPER
0142+  0BC8             ; input in AL
0143+  0BC8             ; output in AL
0144+  0BC8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  0BC8             to_upper:
0146+  0BC8 B9 61       	cmp al, 'a'
0147+  0BCA C8 CF 0B    	jlu to_upper_ret
0148+  0BCD 6F 20       	sub al, $20			; convert to upper case
0149+  0BCF             to_upper_ret:
0150+  0BCF 09          	ret
0151+  0BD0             
0075   0BD0             
0076   0BD0 55 73 61 67 s_usage:	.db "Usage: primes [min] [max]\n", 0
0076   0BD4 65 3A 20 70 
0076   0BD8 72 69 6D 65 
0076   0BDC 73 20 5B 6D 
0076   0BE0 69 6E 5D 20 
0076   0BE4 5B 6D 61 78 
0076   0BE8 5D 0A 00 
0077   0BEB 00 00       total:		.dw 0
0078   0BED E8 03       max:		.dw 1000
0079   0BEF 05 00       min:		.dw 5
0080   0BF1             
0081   0BF1 0D 55 70 70 s_max:		.db "\rUpper bound: ", 0
0081   0BF5 65 72 20 62 
0081   0BF9 6F 75 6E 64 
0081   0BFD 3A 20 00 
0082   0C00 2C 20 54 6F s_total:	.db ", Total primes: ", 0
0082   0C04 74 61 6C 20 
0082   0C08 70 72 69 6D 
0082   0C0C 65 73 3A 20 
0082   0C10 00 
0083   0C11             			
0084   0C11             .end
tasm: Number of errors = 0
