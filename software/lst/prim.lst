0001   0000             .include "kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0002   0000             
0003   0400             .org PROC_TEXT_ORG
0004   0400             
0005   0400             primes:
0006   0400 FD 47 FF FF 	mov sp, $FFFF
0007   0404 FD 49 FF FF 	mov bp, $FFFF
0008   0408             
0009   0408 10 00 00    	mov a, 0
0010   040B 42 27 0A    	mov [prog], a
0011   040E 07 88 08    	call get_token
0012   0411 1D 2A 0A    	mov al, [tok]
0013   0414 B9 14       	cmp al, TOK_END
0014   0416 C6 78 04    	je bad_args
0015   0419 3B 2B 0A    	mov d, tokstr
0016   041C 07 95 06    	call strtoint
0017   041F 42 E7 0B    	mov [min], a
0018   0422 07 88 08    	call get_token
0019   0425 1D 2A 0A    	mov al, [tok]
0020   0428 B9 14       	cmp al, TOK_END
0021   042A C6 78 04    	je bad_args
0022   042D 3B 2B 0A    	mov d, tokstr
0023   0430 07 95 06    	call strtoint
0024   0433 42 E5 0B    	mov [max], a
0025   0436             	
0026   0436 14 E7 0B    	mov a, [min]
0027   0439             primes_L1:
0028   0439 38 02 00    	mov c, 2	
0029   043C             primes_L2:
0030   043C D7          	push a
0031   043D 28          	mov b, c
0032   043E AE          	div a, b
0033   043F C0 00 00    	cmp b, 0
0034   0442 C6 4A 04    	jz divisible
0035   0445 78          	inc c
0036   0446 E4          	pop a
0037   0447 0A 3C 04    	jmp primes_L2		
0038   044A             divisible:
0039   044A E4          	pop a
0040   044B B1          	cmp a, c
0041   044C C7 72 04    	jnz notprime			
0042   044F             isprime:
0043   044F 07 EE 06    	call print_u16d
0044   0452             	
0045   0452 D7          	push a
0046   0453 14 E3 0B    	mov a, [total]
0047   0456 77          	inc a
0048   0457 42 E3 0B    	mov [total], a
0049   045A 3B F8 0B    	mov d, s_total
0050   045D 07 C5 06    	call puts
0051   0460 07 EE 06    	call print_u16d
0052   0463             	
0053   0463 E4          	pop a
0054   0464             
0055   0464 07 72 06    	call printnl
0056   0467 77          	inc a
0057   0468 29 E5 0B    	mov b, [max]
0058   046B B0          	cmp a, b
0059   046C C9 76 04    	jgeu primes_ret
0060   046F 0A 39 04    	jmp primes_L1
0061   0472             notprime:
0062   0472 77          	inc a
0063   0473 0A 39 04    	jmp primes_L1		
0064   0476             primes_ret:
0065   0476 05 0B       	syscall sys_terminate_proc
0066   0478             
0067   0478             bad_args:
0068   0478 3B C8 0B    	mov d, s_usage
0069   047B 07 C5 06    	call puts
0070   047E 0A 76 04    	jmp primes_ret
0071   0481             
0072   0481             .include "stdio.asm"
0001+  0481             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0481             ; stdio.s
0003+  0481             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0481             .include "string.asm"
0001++ 0481             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0481             ; string.s
0003++ 0481             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0481             
0005++ 0481             
0006++ 0481             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0481             ; strrev
0008++ 0481             ; reverse a string
0009++ 0481             ; D = string address
0010++ 0481             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0481             ; 01234
0012++ 0481             strrev:
0013++ 0481 4B          	pusha
0014++ 0482 07 C8 04    	call strlen	; length in C
0015++ 0485 12          	mov a, c
0016++ 0486 AF 01 00    	cmp a, 1
0017++ 0489 D0 A3 04    	jleu strrev_end	; check string length. string len must be > 1
0018++ 048C 7D          	dec a
0019++ 048D FD 4E       	mov si, d	; beginning of string
0020++ 048F FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0491 59          	add d, a	; end of string
0022++ 0492 12          	mov a, c
0023++ 0493 FD 9B       	shr a		; divide by 2
0024++ 0495 39          	mov c, a	; C now counts the steps
0025++ 0496             strrev_L0:
0026++ 0496 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0497 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0498 3E          	mov [d], al	; store left char into right side
0029++ 0499 1B          	mov al, bl
0030++ 049A F7          	stosb		; store right-side char into left-side; increase DI
0031++ 049B 7E          	dec c
0032++ 049C 7F          	dec d
0033++ 049D C2 00 00    	cmp c, 0
0034++ 04A0 C7 96 04    	jne strrev_L0
0035++ 04A3             strrev_end:
0036++ 04A3 4C          	popa
0037++ 04A4 09          	ret
0038++ 04A5             	
0039++ 04A5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 04A5             ; strchr
0041++ 04A5             ; search string in D for char in AL
0042++ 04A5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 04A5             strchr:
0044++ 04A5             strchr_L0:
0045++ 04A5 32          	mov bl, [d]
0046++ 04A6 C1 00       	cmp bl, 0
0047++ 04A8 C6 B3 04    	je strchr_end
0048++ 04AB BA          	cmp al, bl
0049++ 04AC C6 B3 04    	je strchr_end
0050++ 04AF 79          	inc d
0051++ 04B0 0A A5 04    	jmp strchr_L0
0052++ 04B3             strchr_end:
0053++ 04B3 1B          	mov al, bl
0054++ 04B4 09          	ret
0055++ 04B5             
0056++ 04B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 04B5             ; strstr
0058++ 04B5             ; find sub-string
0059++ 04B5             ; str1 in SI
0060++ 04B5             ; str2 in DI
0061++ 04B5             ; SI points to end of source string
0062++ 04B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 04B5             strstr:
0064++ 04B5 DB          	push al
0065++ 04B6 DA          	push d
0066++ 04B7 E3          	push di
0067++ 04B8             strstr_loop:
0068++ 04B8 F3          	cmpsb					; compare a byte of the strings
0069++ 04B9 C7 C4 04    	jne strstr_ret
0070++ 04BC FC 00 00    	lea d, [di + 0]
0071++ 04BF BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 04C1 C7 B8 04    	jne strstr_loop				; equal chars but not at end
0073++ 04C4             strstr_ret:
0074++ 04C4 F0          	pop di
0075++ 04C5 E7          	pop d
0076++ 04C6 E8          	pop al
0077++ 04C7 09          	ret
0078++ 04C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 04C8             ; length of null terminated string
0080++ 04C8             ; result in C
0081++ 04C8             ; pointer in D
0082++ 04C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 04C8             strlen:
0084++ 04C8 DA          	push d
0085++ 04C9 38 00 00    	mov c, 0
0086++ 04CC             strlen_L1:
0087++ 04CC BD 00       	cmp byte [d], 0
0088++ 04CE C6 D6 04    	je strlen_ret
0089++ 04D1 79          	inc d
0090++ 04D2 78          	inc c
0091++ 04D3 0A CC 04    	jmp strlen_L1
0092++ 04D6             strlen_ret:
0093++ 04D6 E7          	pop d
0094++ 04D7 09          	ret
0095++ 04D8             
0096++ 04D8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 04D8             ; STRCMP
0098++ 04D8             ; compare two strings
0099++ 04D8             ; str1 in SI
0100++ 04D8             ; str2 in DI
0101++ 04D8             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 04D8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 04D8             strcmp:
0104++ 04D8 DB          	push al
0105++ 04D9 DA          	push d
0106++ 04DA E3          	push di
0107++ 04DB E2          	push si
0108++ 04DC             strcmp_loop:
0109++ 04DC F3          	cmpsb					; compare a byte of the strings
0110++ 04DD C7 E8 04    	jne strcmp_ret
0111++ 04E0 FB FF FF    	lea d, [si +- 1]
0112++ 04E3 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 04E5 C7 DC 04    	jne strcmp_loop				; equal chars but not at end
0114++ 04E8             strcmp_ret:
0115++ 04E8 EF          	pop si
0116++ 04E9 F0          	pop di
0117++ 04EA E7          	pop d
0118++ 04EB E8          	pop al
0119++ 04EC 09          	ret
0120++ 04ED             
0121++ 04ED             
0122++ 04ED             ; STRCPY
0123++ 04ED             ; copy null terminated string from SI to DI
0124++ 04ED             ; source in SI
0125++ 04ED             ; destination in DI
0126++ 04ED             strcpy:
0127++ 04ED E2          	push si
0128++ 04EE E3          	push di
0129++ 04EF DB          	push al
0130++ 04F0             strcpy_L1:
0131++ 04F0 F6          	lodsb
0132++ 04F1 F7          	stosb
0133++ 04F2 B9 00       	cmp al, 0
0134++ 04F4 C7 F0 04    	jne strcpy_L1
0135++ 04F7             strcpy_end:
0136++ 04F7 E8          	pop al
0137++ 04F8 F0          	pop di
0138++ 04F9 EF          	pop si
0139++ 04FA 09          	ret
0140++ 04FB             
0141++ 04FB             ; STRCAT
0142++ 04FB             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 04FB             ; source in SI
0144++ 04FB             ; destination in DI
0145++ 04FB             strcat:
0146++ 04FB E2          	push si
0147++ 04FC E3          	push di
0148++ 04FD D7          	push a
0149++ 04FE DA          	push d
0150++ 04FF 50          	mov a, di
0151++ 0500 3C          	mov d, a
0152++ 0501             strcat_goto_end_L1:
0153++ 0501 BD 00       	cmp byte[d], 0
0154++ 0503 C6 0A 05    	je strcat_start
0155++ 0506 79          	inc d
0156++ 0507 0A 01 05    	jmp strcat_goto_end_L1
0157++ 050A             strcat_start:
0158++ 050A FD 50       	mov di, d
0159++ 050C             strcat_L1:
0160++ 050C F6          	lodsb
0161++ 050D F7          	stosb
0162++ 050E B9 00       	cmp al, 0
0163++ 0510 C7 0C 05    	jne strcat_L1
0164++ 0513             strcat_end:
0165++ 0513 E7          	pop d
0166++ 0514 E4          	pop a
0167++ 0515 F0          	pop di
0168++ 0516 EF          	pop si
0169++ 0517 09          	ret
0005+  0518             
0006+  0518 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  051C 34 35 36 37 
0006+  0520 38 39 41 42 
0006+  0524 43 44 45 46 
0007+  0528             
0008+  0528 01 00       table_power:.dw 1
0009+  052A 0A 00       			.dw 10
0010+  052C 64 00       			.dw 100
0011+  052E E8 03       			.dw 1000
0012+  0530 10 27       			.dw 10000
0013+  0532             
0014+  0532             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0015+  0532             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0016+  0532             ; ASCII in BL
0017+  0532             ; result in AL
0018+  0532             ; ascii for F = 0100 0110
0019+  0532             ; ascii for 9 = 0011 1001
0020+  0532             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0021+  0532             hex_ascii_encode:
0022+  0532 1B          	mov al, bl
0023+  0533 93 40       	test al, $40				; test if letter or number
0024+  0535 C7 3B 05    	jnz hex_letter
0025+  0538 87 0F       	and al, $0F				; get number
0026+  053A 09          	ret
0027+  053B             hex_letter:
0028+  053B 87 0F       	and al, $0F				; get letter
0029+  053D 6A 09       	add al, 9
0030+  053F 09          	ret
0031+  0540             
0032+  0540             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0033+  0540             ; ATOI
0034+  0540             ; 2 letter hex string in B
0035+  0540             ; 8bit integer returned in AL
0036+  0540             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0037+  0540             atoi:
0038+  0540 D8          	push b
0039+  0541 07 32 05    	call hex_ascii_encode			; convert BL to 4bit code in AL
0040+  0544 30          	mov bl, bh
0041+  0545 DB          	push al					; save a
0042+  0546 07 32 05    	call hex_ascii_encode
0043+  0549 EA          	pop bl	
0044+  054A FD 9E 04    	shl al, 4
0045+  054D 8C          	or al, bl
0046+  054E E5          	pop b
0047+  054F 09          	ret	
0048+  0550             
0049+  0550             
0050+  0550             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  0550             ; printf
0052+  0550             ; no need for explanations!
0053+  0550             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0054+  0550             printf:
0055+  0550 09          	ret
0056+  0551             
0057+  0551             
0058+  0551             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  0551             ; scanf
0060+  0551             ; no need for explanations!
0061+  0551             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  0551             scanf:
0063+  0551 09          	ret
0064+  0552             
0065+  0552             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  0552             ; ITOA
0067+  0552             ; 8bit value in BL
0068+  0552             ; 2 byte ASCII result in A
0069+  0552             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0070+  0552             itoa:
0071+  0552 DA          	push d
0072+  0553 D8          	push b
0073+  0554 A7 00       	mov bh, 0
0074+  0556 FD A4 04    	shr bl, 4	
0075+  0559 74          	mov d, b
0076+  055A 1F 18 05    	mov al, [d + s_hex_digits]
0077+  055D 23          	mov ah, al
0078+  055E             	
0079+  055E E5          	pop b
0080+  055F D8          	push b
0081+  0560 A7 00       	mov bh, 0
0082+  0562 FD 87 0F    	and bl, $0F
0083+  0565 74          	mov d, b
0084+  0566 1F 18 05    	mov al, [d + s_hex_digits]
0085+  0569 E5          	pop b
0086+  056A E7          	pop d
0087+  056B 09          	ret
0088+  056C             
0089+  056C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0090+  056C             ; HEX STRING TO BINARY
0091+  056C             ; di = destination address
0092+  056C             ; si = source
0093+  056C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0094+  056C             hex_to_int:
0095+  056C             hex_to_int_L1:
0096+  056C F6          	lodsb					; load from [SI] to AL
0097+  056D B9 00       	cmp al, 0				; check if ASCII 0
0098+  056F C6 7C 05    	jz hex_to_int_ret
0099+  0572 36          	mov bh, al
0100+  0573 F6          	lodsb
0101+  0574 2F          	mov bl, al
0102+  0575 07 40 05    	call atoi				; convert ASCII byte in B to int (to AL)
0103+  0578 F7          	stosb					; store AL to [DI]
0104+  0579 0A 6C 05    	jmp hex_to_int_L1
0105+  057C             hex_to_int_ret:
0106+  057C 09          	ret		
0107+  057D             
0108+  057D             
0109+  057D             
0110+  057D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  057D             ; GETCHAR
0112+  057D             ; char in ah
0113+  057D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0114+  057D             getchar:
0115+  057D DB          	push al
0116+  057E             getchar_retry:
0117+  057E FD 0C       	sti
0118+  0580 19 01       	mov al, 1
0119+  0582 05 03       	syscall sys_io			; receive in AH
0120+  0584 B9 00       	cmp al, 0			; check if any char was receive
0121+  0586 C6 7E 05    	je getchar_retry
0122+  0589 E8          	pop al
0123+  058A 09          	ret
0124+  058B             
0125+  058B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0126+  058B             ; PUTCHAR
0127+  058B             ; char in ah
0128+  058B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  058B             putchar:
0130+  058B D7          	push a
0131+  058C 19 00       	mov al, 0
0132+  058E 05 03       	syscall sys_io			; char in AH
0133+  0590 E4          	pop a
0134+  0591 09          	ret
0135+  0592             
0136+  0592             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0137+  0592             ;; INPUT A STRING
0138+  0592             ;; terminates with null
0139+  0592             ;; pointer in D
0140+  0592             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  0592             gets:
0142+  0592 D7          	push a
0143+  0593 DA          	push d
0144+  0594             gets_loop:
0145+  0594 FD 0C       	sti
0146+  0596 19 01       	mov al, 1
0147+  0598 05 03       	syscall sys_io			; receive in AH
0148+  059A B9 00       	cmp al, 0				; check error code (AL)
0149+  059C C6 94 05    	je gets_loop			; if no char received, retry
0150+  059F             
0151+  059F 76 1B       	cmp ah, 27
0152+  05A1 C6 C2 05    	je gets_telnet_escape
0153+  05A4 76 0A       	cmp ah, $0A				; LF
0154+  05A6 C6 1B 06    	je gets_end
0155+  05A9 76 0D       	cmp ah, $0D				; CR
0156+  05AB C6 1B 06    	je gets_end
0157+  05AE 76 5C       	cmp ah, $5C				; '\\'
0158+  05B0 C6 F2 05    	je gets_escape
0159+  05B3             	
0160+  05B3 76 08       	cmp ah, $08			; check for backspace
0161+  05B5 C6 BE 05    	je gets_backspace
0162+  05B8             
0163+  05B8 1A          	mov al, ah
0164+  05B9 3E          	mov [d], al
0165+  05BA 79          	inc d
0166+  05BB 0A 94 05    	jmp gets_loop
0167+  05BE             gets_backspace:
0168+  05BE 7F          	dec d
0169+  05BF 0A 94 05    	jmp gets_loop
0170+  05C2             gets_telnet_escape:
0171+  05C2 FD 0C       	sti
0172+  05C4 19 01       	mov al, 1
0173+  05C6 05 03       	syscall sys_io				; receive in AH without echo
0174+  05C8 B9 00       	cmp al, 0					; check error code (AL)
0175+  05CA C6 C2 05    	je gets_telnet_escape		; if no char received, retry
0176+  05CD 76 5B       	cmp ah, '['
0177+  05CF C7 94 05    	jne gets_loop
0178+  05D2             gets_telnet_escape_phase2:
0179+  05D2 FD 0C       	sti
0180+  05D4 19 01       	mov al, 1
0181+  05D6 05 03       	syscall sys_io					; receive in AH without echo
0182+  05D8 B9 00       	cmp al, 0						; check error code (AL)
0183+  05DA C6 D2 05    	je gets_telnet_escape_phase2	; if no char received, retry
0184+  05DD 76 44       	cmp ah, 'D'
0185+  05DF C6 EA 05    	je gets_left_arrow
0186+  05E2 76 43       	cmp ah, 'C'
0187+  05E4 C6 EE 05    	je gets_right_arrow
0188+  05E7 0A 94 05    	jmp gets_loop
0189+  05EA             gets_left_arrow:
0190+  05EA 7F          	dec d
0191+  05EB 0A 94 05    	jmp gets_loop
0192+  05EE             gets_right_arrow:
0193+  05EE 79          	inc d
0194+  05EF 0A 94 05    	jmp gets_loop
0195+  05F2             gets_escape:
0196+  05F2 FD 0C       	sti
0197+  05F4 19 01       	mov al, 1
0198+  05F6 05 03       	syscall sys_io			; receive in AH
0199+  05F8 B9 00       	cmp al, 0				; check error code (AL)
0200+  05FA C6 F2 05    	je gets_escape			; if no char received, retry
0201+  05FD 76 6E       	cmp ah, 'n'
0202+  05FF C6 0D 06    	je gets_LF
0203+  0602 76 72       	cmp ah, 'r'
0204+  0604 C6 14 06    	je gets_CR
0205+  0607 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0206+  0608 3E          	mov [d], al
0207+  0609 79          	inc d
0208+  060A 0A 94 05    	jmp gets_loop
0209+  060D             gets_LF:
0210+  060D 19 0A       	mov al, $0A
0211+  060F 3E          	mov [d], al
0212+  0610 79          	inc d
0213+  0611 0A 94 05    	jmp gets_loop
0214+  0614             gets_CR:
0215+  0614 19 0D       	mov al, $0D
0216+  0616 3E          	mov [d], al
0217+  0617 79          	inc d
0218+  0618 0A 94 05    	jmp gets_loop
0219+  061B             gets_end:
0220+  061B 19 00       	mov al, 0
0221+  061D 3E          	mov [d], al				; terminate string
0222+  061E E7          	pop d
0223+  061F E4          	pop a
0224+  0620 09          	ret
0225+  0621             
0226+  0621             
0227+  0621             
0228+  0621             
0229+  0621             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0230+  0621             ;; INPUT TEXT
0231+  0621             ;; terminated with CTRL+D
0232+  0621             ;; pointer in D
0233+  0621             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0234+  0621             gettxt:
0235+  0621 D7          	push a
0236+  0622 DA          	push d
0237+  0623             gettxt_loop:
0238+  0623 19 01       	mov al, 1
0239+  0625 05 03       	syscall sys_io			; receive in AH
0240+  0627 B9 00       	cmp al, 0				; check error code (AL)
0241+  0629 C6 23 06    	je gettxt_loop		; if no char received, retry
0242+  062C 76 04       	cmp ah, 4			; EOT
0243+  062E C6 6C 06    	je gettxt_end
0244+  0631 76 08       	cmp ah, $08			; check for backspace
0245+  0633 C6 68 06    	je gettxt_backspace
0246+  0636 76 5C       	cmp ah, $5C				; '\\'
0247+  0638 C6 41 06    	je gettxt_escape
0248+  063B 1A          	mov al, ah
0249+  063C 3E          	mov [d], al
0250+  063D 79          	inc d
0251+  063E 0A 23 06    	jmp gettxt_loop
0252+  0641             gettxt_escape:
0253+  0641 19 01       	mov al, 1
0254+  0643 05 03       	syscall sys_io			; receive in AH
0255+  0645 B9 00       	cmp al, 0				; check error code (AL)
0256+  0647 C6 41 06    	je gettxt_escape		; if no char received, retry
0257+  064A 76 6E       	cmp ah, 'n'
0258+  064C C6 5A 06    	je gettxt_LF
0259+  064F 76 72       	cmp ah, 'r'
0260+  0651 C6 61 06    	je gettxt_CR
0261+  0654 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0262+  0655 3E          	mov [d], al
0263+  0656 79          	inc d
0264+  0657 0A 23 06    	jmp gettxt_loop
0265+  065A             gettxt_LF:
0266+  065A 19 0A       	mov al, $0A
0267+  065C 3E          	mov [d], al
0268+  065D 79          	inc d
0269+  065E 0A 23 06    	jmp gettxt_loop
0270+  0661             gettxt_CR:
0271+  0661 19 0D       	mov al, $0D
0272+  0663 3E          	mov [d], al
0273+  0664 79          	inc d
0274+  0665 0A 23 06    	jmp gettxt_loop
0275+  0668             gettxt_backspace:
0276+  0668 7F          	dec d
0277+  0669 0A 23 06    	jmp gettxt_loop
0278+  066C             gettxt_end:
0279+  066C 19 00       	mov al, 0
0280+  066E 3E          	mov [d], al				; terminate string
0281+  066F E7          	pop d
0282+  0670 E4          	pop a
0283+  0671 09          	ret
0284+  0672             
0285+  0672             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0286+  0672             ; PRINT NEW LINE
0287+  0672             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  0672             printnl:
0289+  0672 D7          	push a
0290+  0673 10 00 0A    	mov a, $0A00
0291+  0676 05 03       	syscall sys_io
0292+  0678 10 00 0D    	mov a, $0D00
0293+  067B 05 03       	syscall sys_io
0294+  067D E4          	pop a
0295+  067E 09          	ret
0296+  067F             
0297+  067F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0298+  067F             ; strtoint
0299+  067F             ; 4 digit hex string number in d
0300+  067F             ; integer returned in A
0301+  067F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0302+  067F             strtointx:
0303+  067F D8          	push b
0304+  0680 32          	mov bl, [d]
0305+  0681 37          	mov bh, bl
0306+  0682 33 01 00    	mov bl, [d + 1]
0307+  0685 07 40 05    	call atoi				; convert to int in AL
0308+  0688 23          	mov ah, al				; move to AH
0309+  0689 33 02 00    	mov bl, [d + 2]
0310+  068C 37          	mov bh, bl
0311+  068D 33 03 00    	mov bl, [d + 3]
0312+  0690 07 40 05    	call atoi				; convert to int in AL
0313+  0693 E5          	pop b
0314+  0694 09          	ret
0315+  0695             
0316+  0695             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0317+  0695             ; strtoint
0318+  0695             ; 5 digit base10 string number in d
0319+  0695             ; integer returned in A
0320+  0695             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0321+  0695             strtoint:
0322+  0695 E2          	push si
0323+  0696 D8          	push b
0324+  0697 D9          	push c
0325+  0698 DA          	push d
0326+  0699 07 C8 04    	call strlen			; get string length in C
0327+  069C 7E          	dec c
0328+  069D FD 4E       	mov si, d
0329+  069F 12          	mov a, c
0330+  06A0 FD 99       	shl a
0331+  06A2 3B 28 05    	mov d, table_power
0332+  06A5 59          	add d, a
0333+  06A6 38 00 00    	mov c, 0
0334+  06A9             strtoint_L0:
0335+  06A9 F6          	lodsb			; load ASCII to al
0336+  06AA B9 00       	cmp al, 0
0337+  06AC C6 BF 06    	je strtoint_end
0338+  06AF 6F 30       	sub al, $30		; make into integer
0339+  06B1 22 00       	mov ah, 0
0340+  06B3 2A          	mov b, [d]
0341+  06B4 AC          	mul a, b			; result in B since it fits in 16bits
0342+  06B5 11          	mov a, b
0343+  06B6 28          	mov b, c
0344+  06B7 54          	add a, b
0345+  06B8 39          	mov c, a
0346+  06B9 63 02 00    	sub d, 2
0347+  06BC 0A A9 06    	jmp strtoint_L0
0348+  06BF             strtoint_end:
0349+  06BF 12          	mov a, c
0350+  06C0 E7          	pop d
0351+  06C1 E6          	pop c
0352+  06C2 E5          	pop b
0353+  06C3 EF          	pop si
0354+  06C4 09          	ret
0355+  06C5             
0356+  06C5             
0357+  06C5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0358+  06C5             ; PRINT NULL TERMINATED STRING
0359+  06C5             ; pointer in D
0360+  06C5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0361+  06C5             puts:
0362+  06C5 D7          	push a
0363+  06C6 DA          	push d
0364+  06C7             puts_L1:
0365+  06C7 1E          	mov al, [d]
0366+  06C8 B9 00       	cmp al, 0
0367+  06CA C6 D6 06    	jz puts_END
0368+  06CD 23          	mov ah, al
0369+  06CE 19 00       	mov al, 0
0370+  06D0 05 03       	syscall sys_io
0371+  06D2 79          	inc d
0372+  06D3 0A C7 06    	jmp puts_L1
0373+  06D6             puts_END:
0374+  06D6 E7          	pop d
0375+  06D7 E4          	pop a
0376+  06D8 09          	ret
0377+  06D9             
0378+  06D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  06D9             ; PRINT N SIZE STRING
0380+  06D9             ; pointer in D
0381+  06D9             ; size in C
0382+  06D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0383+  06D9             putsn:
0384+  06D9 DB          	push al
0385+  06DA DA          	push d
0386+  06DB D9          	push c
0387+  06DC             putsn_L0:
0388+  06DC 1E          	mov al, [d]
0389+  06DD 23          	mov ah, al
0390+  06DE 19 00       	mov al, 0
0391+  06E0 05 03       	syscall sys_io
0392+  06E2 79          	inc d
0393+  06E3 7E          	dec c	
0394+  06E4 C2 00 00    	cmp c, 0
0395+  06E7 C7 DC 06    	jne putsn_L0
0396+  06EA             putsn_end:
0397+  06EA E6          	pop c
0398+  06EB E7          	pop d
0399+  06EC E8          	pop al
0400+  06ED 09          	ret
0401+  06EE             
0402+  06EE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0403+  06EE             ; print 16bit decimal number
0404+  06EE             ; input number in A
0405+  06EE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  06EE             print_u16d:
0407+  06EE D7          	push a
0408+  06EF D8          	push b
0409+  06F0 26 10 27    	mov b, 10000
0410+  06F3 AE          	div a, b			; get 10000 coeff.
0411+  06F4 07 1A 07    	call print_number
0412+  06F7 11          	mov a, b
0413+  06F8 26 E8 03    	mov b, 1000
0414+  06FB AE          	div a, b			; get 10000 coeff.
0415+  06FC 07 1A 07    	call print_number
0416+  06FF 11          	mov a, b
0417+  0700 26 64 00    	mov b, 100
0418+  0703 AE          	div a, b
0419+  0704 07 1A 07    	call print_number
0420+  0707 11          	mov a, b
0421+  0708 26 0A 00    	mov b, 10
0422+  070B AE          	div a, b
0423+  070C 07 1A 07    	call print_number
0424+  070F 11          	mov a, b
0425+  0710 6A 30       	add al, $30
0426+  0712 23          	mov ah, al
0427+  0713 19 00       	mov al, 0
0428+  0715 05 03       	syscall sys_io	; print coeff
0429+  0717 E5          	pop b
0430+  0718 E4          	pop a
0431+  0719 09          	ret
0432+  071A             
0433+  071A             
0434+  071A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0435+  071A             ; if A == 0, print space
0436+  071A             ; else print A
0437+  071A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0438+  071A             print_number:
0439+  071A 6A 30       	add al, $30
0440+  071C 23          	mov ah, al
0441+  071D 07 8B 05    	call putchar
0442+  0720 09          	ret
0443+  0721             
0444+  0721             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  0721             ; PRINT 16BIT HEX INTEGER
0446+  0721             ; integer value in reg B
0447+  0721             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  0721             print_u16x:
0449+  0721 D7          	push a
0450+  0722 D8          	push b
0451+  0723 DD          	push bl
0452+  0724 30          	mov bl, bh
0453+  0725 07 52 05    	call itoa				; convert bh to char in A
0454+  0728 2F          	mov bl, al				; save al
0455+  0729 19 00       	mov al, 0
0456+  072B 05 03       	syscall sys_io				; display AH
0457+  072D 24          	mov ah, bl				; retrieve al
0458+  072E 19 00       	mov al, 0
0459+  0730 05 03       	syscall sys_io				; display AL
0460+  0732             
0461+  0732 EA          	pop bl
0462+  0733 07 52 05    	call itoa				; convert bh to char in A
0463+  0736 2F          	mov bl, al				; save al
0464+  0737 19 00       	mov al, 0
0465+  0739 05 03       	syscall sys_io				; display AH
0466+  073B 24          	mov ah, bl				; retrieve al
0467+  073C 19 00       	mov al, 0
0468+  073E 05 03       	syscall sys_io				; display AL
0469+  0740             
0470+  0740 E5          	pop b
0471+  0741 E4          	pop a
0472+  0742 09          	ret
0473+  0743             
0474+  0743             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0475+  0743             ; INPUT 16BIT HEX INTEGER
0476+  0743             ; read 16bit integer into A
0477+  0743             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0478+  0743             scan_u16x:
0479+  0743 F8 10 00    	enter 16
0480+  0746 D8          	push b
0481+  0747 DA          	push d
0482+  0748             
0483+  0748 FA F1 FF    	lea d, [bp + -15]
0484+  074B 07 92 05    	call gets				; get number
0485+  074E             
0486+  074E 32          	mov bl, [d]
0487+  074F 37          	mov bh, bl
0488+  0750 33 01 00    	mov bl, [d + 1]
0489+  0753 07 40 05    	call atoi				; convert to int in AL
0490+  0756 23          	mov ah, al				; move to AH
0491+  0757             
0492+  0757 33 02 00    	mov bl, [d + 2]
0493+  075A 37          	mov bh, bl
0494+  075B 33 03 00    	mov bl, [d + 3]
0495+  075E 07 40 05    	call atoi				; convert to int in AL
0496+  0761             
0497+  0761 E7          	pop d
0498+  0762 E5          	pop b
0499+  0763 F9          	leave
0500+  0764 09          	ret
0501+  0765             
0502+  0765             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0503+  0765             ; PRINT 8bit HEX INTEGER
0504+  0765             ; integer value in reg bl
0505+  0765             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0506+  0765             print_u8x:
0507+  0765 D7          	push a
0508+  0766 DD          	push bl
0509+  0767             
0510+  0767 07 52 05    	call itoa				; convert bl to char in A
0511+  076A 2F          	mov bl, al				; save al
0512+  076B 19 00       	mov al, 0
0513+  076D 05 03       	syscall sys_io				; display AH
0514+  076F 24          	mov ah, bl				; retrieve al
0515+  0770 19 00       	mov al, 0
0516+  0772 05 03       	syscall sys_io				; display AL
0517+  0774             
0518+  0774 EA          	pop bl
0519+  0775 E4          	pop a
0520+  0776 09          	ret
0521+  0777             
0522+  0777             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0523+  0777             ; print 8bit decimal unsigned number
0524+  0777             ; input number in AL
0525+  0777             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0526+  0777             print_u8d:
0527+  0777 D7          	push a
0528+  0778 D8          	push b
0529+  0779             
0530+  0779 22 00       	mov ah, 0
0531+  077B 26 64 00    	mov b, 100
0532+  077E AE          	div a, b
0533+  077F D8          	push b			; save remainder
0534+  0780 B9 00       	cmp al, 0
0535+  0782 C6 8C 07    	je skip100
0536+  0785 6A 30       	add al, $30
0537+  0787 23          	mov ah, al
0538+  0788 19 00       	mov al, 0
0539+  078A 05 03       	syscall sys_io	; print coeff
0540+  078C             skip100:
0541+  078C E4          	pop a
0542+  078D 22 00       	mov ah, 0
0543+  078F 26 0A 00    	mov b, 10
0544+  0792 AE          	div a, b
0545+  0793 D8          	push b			; save remainder
0546+  0794 B9 00       	cmp al, 0
0547+  0796 C6 A0 07    	je skip10
0548+  0799 6A 30       	add al, $30
0549+  079B 23          	mov ah, al
0550+  079C 19 00       	mov al, 0
0551+  079E 05 03       	syscall sys_io	; print coeff
0552+  07A0             skip10:
0553+  07A0 E4          	pop a
0554+  07A1 1B          	mov al, bl
0555+  07A2 6A 30       	add al, $30
0556+  07A4 23          	mov ah, al
0557+  07A5 19 00       	mov al, 0
0558+  07A7 05 03       	syscall sys_io	; print coeff
0559+  07A9 E5          	pop b
0560+  07AA E4          	pop a
0561+  07AB 09          	ret
0562+  07AC             
0563+  07AC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0564+  07AC             ; INPUT 8BIT HEX INTEGER
0565+  07AC             ; read 8bit integer into AL
0566+  07AC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0567+  07AC             scan_u8x:
0568+  07AC F8 04 00    	enter 4
0569+  07AF D8          	push b
0570+  07B0 DA          	push d
0571+  07B1             
0572+  07B1 FA FD FF    	lea d, [bp + -3]
0573+  07B4 07 92 05    	call gets				; get number
0574+  07B7             
0575+  07B7 32          	mov bl, [d]
0576+  07B8 37          	mov bh, bl
0577+  07B9 33 01 00    	mov bl, [d + 1]
0578+  07BC 07 40 05    	call atoi				; convert to int in AL
0579+  07BF             
0580+  07BF E7          	pop d
0581+  07C0 E5          	pop b
0582+  07C1 F9          	leave
0583+  07C2 09          	ret
0584+  07C3             
0585+  07C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0586+  07C3             ; input decimal number
0587+  07C3             ; result in A
0588+  07C3             ; 655'\0'
0589+  07C3             ; low--------high
0590+  07C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0591+  07C3             scan_u16d:
0592+  07C3 F8 08 00    	enter 8
0593+  07C6 E2          	push si
0594+  07C7 D8          	push b
0595+  07C8 D9          	push c
0596+  07C9 DA          	push d
0597+  07CA FA F9 FF    	lea d, [bp +- 7]
0598+  07CD 07 92 05    	call gets
0599+  07D0 07 C8 04    	call strlen			; get string length in C
0600+  07D3 7E          	dec c
0601+  07D4 FD 4E       	mov si, d
0602+  07D6 12          	mov a, c
0603+  07D7 FD 99       	shl a
0604+  07D9 3B 28 05    	mov d, table_power
0605+  07DC 59          	add d, a
0606+  07DD 38 00 00    	mov c, 0
0607+  07E0             mul_loop:
0608+  07E0 F6          	lodsb			; load ASCII to al
0609+  07E1 B9 00       	cmp al, 0
0610+  07E3 C6 F6 07    	je mul_exit
0611+  07E6 6F 30       	sub al, $30		; make into integer
0612+  07E8 22 00       	mov ah, 0
0613+  07EA 2A          	mov b, [d]
0614+  07EB AC          	mul a, b			; result in B since it fits in 16bits
0615+  07EC 11          	mov a, b
0616+  07ED 28          	mov b, c
0617+  07EE 54          	add a, b
0618+  07EF 39          	mov c, a
0619+  07F0 63 02 00    	sub d, 2
0620+  07F3 0A E0 07    	jmp mul_loop
0621+  07F6             mul_exit:
0622+  07F6 12          	mov a, c
0623+  07F7 E7          	pop d
0624+  07F8 E6          	pop c
0625+  07F9 E5          	pop b
0626+  07FA EF          	pop si
0627+  07FB F9          	leave
0628+  07FC 09          	ret
0073   07FD             .include "token.asm"
0001+  07FD             TOKTYP_IDENTIFIER	.equ 0
0002+  07FD             TOKTYP_KEYWORD		.equ 1
0003+  07FD             TOKTYP_DELIMITER	.equ 2
0004+  07FD             TOKTYP_STRING		.equ 3
0005+  07FD             TOKTYP_CHAR			.equ 4
0006+  07FD             TOKTYP_NUMERIC		.equ 5
0007+  07FD             TOKTYP_END			.equ 6
0008+  07FD             
0009+  07FD             TOK_NULL			.equ 0
0010+  07FD             TOK_FSLASH			.equ 1
0011+  07FD             TOK_TIMES 			.equ 2
0012+  07FD             TOK_PLUS 			.equ 3
0013+  07FD             TOK_MINUS 			.equ 4
0014+  07FD             TOK_DOT				.equ 5
0015+  07FD             TOK_SEMI			.equ 6
0016+  07FD             TOK_ANGLE			.equ 7
0017+  07FD             TOK_TILDE			.equ 8
0018+  07FD             TOK_EQUAL			.equ 9
0019+  07FD             TOK_COLON			.equ 10
0020+  07FD             TOK_COMMA			.equ 11
0021+  07FD             
0022+  07FD             TOK_END				.equ 20
0023+  07FD             
0024+  07FD             
0025+  07FD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  07FD             ;; read a full command argment from shell input buffer
0027+  07FD             ;; argument is written into tokstr
0028+  07FD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  07FD             get_arg:
0030+  07FD D7          	push a
0031+  07FE E2          	push si
0032+  07FF E3          	push di
0033+  0800 19 00       	mov al, 0
0034+  0802 3D 2B 0A    	mov [tokstr], al			; nullify tokstr string
0035+  0805 14 27 0A    	mov a, [prog]
0036+  0808 4D          	mov si, a
0037+  0809 FD 4F 2B 0A 	mov di, tokstr
0038+  080D             get_arg_skip_spaces:
0039+  080D F6          	lodsb
0040+  080E 07 A1 0B    	call isspace
0041+  0811 C6 0D 08    	je get_arg_skip_spaces
0042+  0814             get_arg_L0:
0043+  0814 B9 3B       	cmp al, $3B				; check if is ';'
0044+  0816 C6 23 08    	je get_arg_end
0045+  0819 B9 00       	cmp al, 0
0046+  081B C6 23 08    	je get_arg_end			; check if end of input
0047+  081E F7          	stosb
0048+  081F F6          	lodsb
0049+  0820 0A 14 08    	jmp get_arg_L0
0050+  0823             get_arg_end:
0051+  0823 19 00       	mov al, 0
0052+  0825 F7          	stosb
0053+  0826 D5 01 00    	sub si, 1
0054+  0829 4E          	mov a, si
0055+  082A 42 27 0A    	mov [prog], a		; update pointer
0056+  082D F0          	pop di
0057+  082E EF          	pop si
0058+  082F E4          	pop a
0059+  0830 09          	ret
0060+  0831             
0061+  0831             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  0831             ;; read a path formation from shell input buffer
0063+  0831             ;; path is written into tokstr
0064+  0831             ;; /usr/bin
0065+  0831             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  0831             get_path:
0067+  0831 D7          	push a
0068+  0832 E2          	push si
0069+  0833 E3          	push di
0070+  0834 19 00       	mov al, 0
0071+  0836 3D 2B 0A    	mov [tokstr], al			; nullify tokstr string
0072+  0839 14 27 0A    	mov a, [prog]
0073+  083C 4D          	mov si, a
0074+  083D FD 4F 2B 0A 	mov di, tokstr
0075+  0841             get_path_skip_spaces:
0076+  0841 F6          	lodsb
0077+  0842 07 A1 0B    	call isspace
0078+  0845 C6 41 08    	je get_path_skip_spaces
0079+  0848             get_path_is_pathchar:
0080+  0848 F7          	stosb
0081+  0849 F6          	lodsb
0082+  084A 07 2B 0B    	call isalnum			;check if is alphanumeric
0083+  084D C6 48 08    	je get_path_is_pathchar
0084+  0850 B9 2F       	cmp al, '/'				; check if is '/'
0085+  0852 C6 48 08    	je get_path_is_pathchar
0086+  0855 19 00       	mov al, 0
0087+  0857 F7          	stosb
0088+  0858 D5 01 00    	sub si, 1
0089+  085B 4E          	mov a, si
0090+  085C 42 27 0A    	mov [prog], a		; update pointer
0091+  085F             get_path_end:
0092+  085F F0          	pop di
0093+  0860 EF          	pop si
0094+  0861 E4          	pop a
0095+  0862 09          	ret
0096+  0863             
0097+  0863             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  0863             ;; read a line
0099+  0863             ;; line is written into tokstr
0100+  0863             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  0863             get_line:
0102+  0863 D7          	push a
0103+  0864 E2          	push si
0104+  0865 E3          	push di
0105+  0866 19 00       	mov al, 0
0106+  0868 3D 2B 0A    	mov [tokstr], al			; nullify tokstr string
0107+  086B 14 27 0A    	mov a, [prog]
0108+  086E 4D          	mov si, a
0109+  086F FD 4F 2B 0A 	mov di, tokstr
0110+  0873             get_line_L0:
0111+  0873 F6          	lodsb
0112+  0874 B9 0A       	cmp al, $0A		; check for new line
0113+  0876 C6 7D 08    	je get_line_exit
0114+  0879 F7          	stosb
0115+  087A 0A 73 08    	jmp get_line_L0
0116+  087D             get_line_exit:
0117+  087D 19 00       	mov al, 0
0118+  087F F7          	stosb
0119+  0880 4E          	mov a, si
0120+  0881 42 27 0A    	mov [prog], a		; update pointer
0121+  0884 F0          	pop di
0122+  0885 EF          	pop si
0123+  0886 E4          	pop a
0124+  0887 09          	ret
0125+  0888             
0126+  0888             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  0888             ;; token parser
0128+  0888             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  0888             get_token:
0130+  0888 D7          	push a
0131+  0889 DA          	push d
0132+  088A E2          	push si
0133+  088B E3          	push di
0134+  088C 19 00       	mov al, 0
0135+  088E 3D 2B 0A    	mov [tokstr], al			; nullify tokstr string
0136+  0891 19 00       	mov al, TOK_NULL
0137+  0893 3D 2A 0A    	mov [tok], al				; nullify token
0138+  0896 14 27 0A    	mov a, [prog]
0139+  0899 4D          	mov si, a
0140+  089A FD 4F 2B 0A 	mov di, tokstr
0141+  089E             get_tok_skip_spaces:
0142+  089E F6          	lodsb
0143+  089F 07 A1 0B    	call isspace
0144+  08A2 C6 9E 08    	je get_tok_skip_spaces
0145+  08A5 B9 00       	cmp al, 0			; check for end of input (NULL)
0146+  08A7 C6 8C 09    	je get_token_end
0147+  08AA B9 23       	cmp al, '#'			; comments!
0148+  08AC C6 BA 09    	je get_tok_comment
0149+  08AF 07 2B 0B    	call isalnum
0150+  08B2 C6 99 09    	jz is_alphanumeric
0151+  08B5             ; other token types
0152+  08B5             get_token_slash:
0153+  08B5 B9 2F       	cmp al, '/'				; check if '/'
0154+  08B7 C7 CF 08    	jne get_token_minus
0155+  08BA F7          	stosb					; store '/' into token string
0156+  08BB 19 00       	mov al, 0
0157+  08BD F7          	stosb					; terminate token string
0158+  08BE 19 01       	mov al, TOK_FSLASH
0159+  08C0 3D 2A 0A    	mov [tok], al			
0160+  08C3 19 02       	mov al, TOKTYP_DELIMITER
0161+  08C5 3D 29 0A    	mov [toktyp], al
0162+  08C8 4E          	mov a, si
0163+  08C9 42 27 0A    	mov [prog], a		; update pointer
0164+  08CC 0A B5 09    	jmp get_token_return
0165+  08CF             get_token_minus:
0166+  08CF B9 2D       	cmp al, '-'				; check if '-'
0167+  08D1 C7 E9 08    	jne get_token_comma
0168+  08D4 F7          	stosb					; store '-' into token string
0169+  08D5 19 00       	mov al, 0
0170+  08D7 F7          	stosb					; terminate token string
0171+  08D8 19 04       	mov al, TOK_MINUS
0172+  08DA 3D 2A 0A    	mov [tok], al			
0173+  08DD 19 02       	mov al, TOKTYP_DELIMITER
0174+  08DF 3D 29 0A    	mov [toktyp], al
0175+  08E2 4E          	mov a, si
0176+  08E3 42 27 0A    	mov [prog], a		; update pointer
0177+  08E6 0A B5 09    	jmp get_token_return
0178+  08E9             get_token_comma:
0179+  08E9 B9 2C       	cmp al, ','				; check if ','
0180+  08EB C7 03 09    	jne get_token_semi
0181+  08EE F7          	stosb					; store ',' into token string
0182+  08EF 19 00       	mov al, 0
0183+  08F1 F7          	stosb					; terminate token string
0184+  08F2 19 0B       	mov al, TOK_COMMA
0185+  08F4 3D 2A 0A    	mov [tok], al			
0186+  08F7 19 02       	mov al, TOKTYP_DELIMITER
0187+  08F9 3D 29 0A    	mov [toktyp], al
0188+  08FC 4E          	mov a, si
0189+  08FD 42 27 0A    	mov [prog], a		; update pointer
0190+  0900 0A B5 09    	jmp get_token_return
0191+  0903             get_token_semi:
0192+  0903 B9 3B       	cmp al, $3B				; check if ';'
0193+  0905 C7 1D 09    	jne get_token_colon
0194+  0908 F7          	stosb					; store ';' into token string
0195+  0909 19 00       	mov al, 0
0196+  090B F7          	stosb					; terminate token string
0197+  090C 19 06       	mov al, TOK_SEMI
0198+  090E 3D 2A 0A    	mov [tok], al			
0199+  0911 19 02       	mov al, TOKTYP_DELIMITER
0200+  0913 3D 29 0A    	mov [toktyp], al
0201+  0916 4E          	mov a, si
0202+  0917 42 27 0A    	mov [prog], a		; update pointer
0203+  091A 0A B5 09    	jmp get_token_return
0204+  091D             get_token_colon:
0205+  091D B9 3A       	cmp al, $3A				; check if ':'
0206+  091F C7 37 09    	jne get_token_angle
0207+  0922 F7          	stosb					; store ':' into token string
0208+  0923 19 00       	mov al, 0
0209+  0925 F7          	stosb					; terminate token string
0210+  0926 19 0A       	mov al, TOK_COLON
0211+  0928 3D 2A 0A    	mov [tok], al			
0212+  092B 19 02       	mov al, TOKTYP_DELIMITER
0213+  092D 3D 29 0A    	mov [toktyp], al
0214+  0930 4E          	mov a, si
0215+  0931 42 27 0A    	mov [prog], a		; update pointer
0216+  0934 0A B5 09    	jmp get_token_return
0217+  0937             get_token_angle:
0218+  0937 B9 3E       	cmp al, $3E				; check if '>'
0219+  0939 C7 51 09    	jne get_token_tilde
0220+  093C F7          	stosb					; store '>' into token string
0221+  093D 19 00       	mov al, 0
0222+  093F F7          	stosb					; terminate token string
0223+  0940 19 07       	mov al, TOK_ANGLE
0224+  0942 3D 2A 0A    	mov [tok], al			
0225+  0945 19 02       	mov al, TOKTYP_DELIMITER
0226+  0947 3D 29 0A    	mov [toktyp], al
0227+  094A 4E          	mov a, si
0228+  094B 42 27 0A    	mov [prog], a		; update pointer
0229+  094E 0A B5 09    	jmp get_token_return
0230+  0951             get_token_tilde:
0231+  0951 B9 7E       	cmp al, '~'				; check if '~'
0232+  0953 C7 6B 09    	jne get_token_equal
0233+  0956 F7          	stosb					; store '~' into token string
0234+  0957 19 00       	mov al, 0
0235+  0959 F7          	stosb					; terminate token string
0236+  095A 19 08       	mov al, TOK_TILDE
0237+  095C 3D 2A 0A    	mov [tok], al			
0238+  095F 19 02       	mov al, TOKTYP_DELIMITER
0239+  0961 3D 29 0A    	mov [toktyp], al
0240+  0964 4E          	mov a, si
0241+  0965 42 27 0A    	mov [prog], a		; update pointer
0242+  0968 0A B5 09    	jmp get_token_return
0243+  096B             get_token_equal:
0244+  096B B9 3D       	cmp al, '='				; check if '='
0245+  096D C7 85 09    	jne get_token_skip
0246+  0970 F7          	stosb					; store '=' into token string
0247+  0971 19 00       	mov al, 0
0248+  0973 F7          	stosb					; terminate token string
0249+  0974 19 09       	mov al, TOK_EQUAL
0250+  0976 3D 2A 0A    	mov [tok], al			
0251+  0979 19 02       	mov al, TOKTYP_DELIMITER
0252+  097B 3D 29 0A    	mov [toktyp], al
0253+  097E 4E          	mov a, si
0254+  097F 42 27 0A    	mov [prog], a		; update pointer
0255+  0982 0A B5 09    	jmp get_token_return
0256+  0985             get_token_skip:
0257+  0985 4E          	mov a, si
0258+  0986 42 27 0A    	mov [prog], a		; update pointer
0259+  0989 0A B5 09    	jmp get_token_return
0260+  098C             get_token_end:				; end of file token
0261+  098C 19 14       	mov al, TOK_END
0262+  098E 3D 2A 0A    	mov [tok], al
0263+  0991 19 06       	mov al, TOKTYP_END
0264+  0993 3D 29 0A    	mov [toktyp], al
0265+  0996 0A B5 09    	jmp get_token_return
0266+  0999             is_alphanumeric:
0267+  0999 F7          	stosb
0268+  099A F6          	lodsb
0269+  099B 07 2B 0B    	call isalnum			;check if is alphanumeric
0270+  099E C6 99 09    	jz is_alphanumeric
0271+  09A1 B9 2E       	cmp al, $2E				; check if is '.'
0272+  09A3 C6 99 09    	je is_alphanumeric
0273+  09A6 19 00       	mov al, 0
0274+  09A8 F7          	stosb
0275+  09A9 19 00       	mov al, TOKTYP_IDENTIFIER
0276+  09AB 3D 29 0A    	mov [toktyp], al
0277+  09AE D5 01 00    	sub si, 1
0278+  09B1 4E          	mov a, si
0279+  09B2 42 27 0A    	mov [prog], a		; update pointer
0280+  09B5             get_token_return:
0281+  09B5 F0          	pop di
0282+  09B6 EF          	pop si
0283+  09B7 E7          	pop d
0284+  09B8 E4          	pop a
0285+  09B9 09          	ret
0286+  09BA             get_tok_comment:
0287+  09BA F6          	lodsb
0288+  09BB B9 0A       	cmp al, $0A			; new line
0289+  09BD C7 BA 09    	jne get_tok_comment
0290+  09C0 0A 9E 08    	jmp get_tok_skip_spaces
0291+  09C3             
0292+  09C3             
0293+  09C3             get_number:
0294+  09C3 D7          	push a
0295+  09C4 DA          	push d
0296+  09C5 E2          	push si
0297+  09C6 E3          	push di
0298+  09C7 19 00       	mov al, 0
0299+  09C9 3D 2B 0A    	mov [tokstr], al			; nullify tokstr string
0300+  09CC 19 00       	mov al, TOK_NULL
0301+  09CE 3D 2A 0A    	mov [tok], al				; nullify token
0302+  09D1 14 27 0A    	mov a, [prog]
0303+  09D4 4D          	mov si, a
0304+  09D5 FD 4F 2B 0A 	mov di, tokstr
0305+  09D9             get_number_skip_spaces:
0306+  09D9 F6          	lodsb
0307+  09DA 07 A1 0B    	call isspace
0308+  09DD C6 D9 09    	je get_number_skip_spaces
0309+  09E0 B9 00       	cmp al, 0			; check for end of input (NULL)
0310+  09E2 C7 F2 09    	jne get_number_L0
0311+  09E5 19 14       	mov al, TOK_END
0312+  09E7 3D 2A 0A    	mov [tok], al
0313+  09EA 19 06       	mov al, TOKTYP_END
0314+  09EC 3D 29 0A    	mov [toktyp], al
0315+  09EF 0A 09 0A    	jmp get_number_return
0316+  09F2             get_number_L0:
0317+  09F2 F7          	stosb
0318+  09F3 F6          	lodsb
0319+  09F4 07 35 0B    	call isdigit			;check if is numeric
0320+  09F7 C6 F2 09    	jz get_number_L0
0321+  09FA 19 00       	mov al, 0
0322+  09FC F7          	stosb
0323+  09FD 19 05       	mov al, TOKTYP_NUMERIC
0324+  09FF 3D 29 0A    	mov [toktyp], al
0325+  0A02 D5 01 00    	sub si, 1
0326+  0A05 4E          	mov a, si
0327+  0A06 42 27 0A    	mov [prog], a		; update pointer
0328+  0A09             get_number_return:
0329+  0A09 F0          	pop di
0330+  0A0A EF          	pop si
0331+  0A0B E7          	pop d
0332+  0A0C E4          	pop a
0333+  0A0D 09          	ret
0334+  0A0E             
0335+  0A0E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  0A0E             ;; PUT BACK TOKEN
0337+  0A0E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
0338+  0A0E             putback:
0339+  0A0E D7          	push a
0340+  0A0F E2          	push si
0341+  0A10 FD 4D 2B 0A 	mov si, tokstr	
0342+  0A14             putback_loop:
0343+  0A14 F6          	lodsb
0344+  0A15 B9 00       	cmp al, 0
0345+  0A17 C6 24 0A    	je putback_end
0346+  0A1A 14 27 0A    	mov a, [prog]
0347+  0A1D 7D          	dec a
0348+  0A1E 42 27 0A    	mov [prog], a			; update pointer
0349+  0A21 0A 14 0A    	jmp putback_loop
0350+  0A24             putback_end:
0351+  0A24 EF          	pop si
0352+  0A25 E4          	pop a
0353+  0A26 09          	ret
0354+  0A27             
0355+  0A27             
0356+  0A27             
0357+  0A27             
0358+  0A27 00 00       prog:		.dw 0			; pointer to current position in buffer
0359+  0A29             
0360+  0A29 00          toktyp: 	.db 0			; token type symbol
0361+  0A2A 00          tok:		.db 0			; current token symbol
0362+  0A2B 00 00 00 00 tokstr:		.fill 256, 0	; token as a string
0362+  0A2F 00 00 00 00 
0362+  0A33 00 00 00 00 
0362+  0A37 00 00 00 00 
0362+  0A3B 00 00 00 00 
0362+  0A3F 00 00 00 00 
0362+  0A43 00 00 00 00 
0362+  0A47 00 00 00 00 
0362+  0A4B 00 00 00 00 
0362+  0A4F 00 00 00 00 
0362+  0A53 00 00 00 00 
0362+  0A57 00 00 00 00 
0362+  0A5B 00 00 00 00 
0362+  0A5F 00 00 00 00 
0362+  0A63 00 00 00 00 
0362+  0A67 00 00 00 00 
0362+  0A6B 00 00 00 00 
0362+  0A6F 00 00 00 00 
0362+  0A73 00 00 00 00 
0362+  0A77 00 00 00 00 
0362+  0A7B 00 00 00 00 
0362+  0A7F 00 00 00 00 
0362+  0A83 00 00 00 00 
0362+  0A87 00 00 00 00 
0362+  0A8B 00 00 00 00 
0362+  0A8F 00 00 00 00 
0362+  0A93 00 00 00 00 
0362+  0A97 00 00 00 00 
0362+  0A9B 00 00 00 00 
0362+  0A9F 00 00 00 00 
0362+  0AA3 00 00 00 00 
0362+  0AA7 00 00 00 00 
0362+  0AAB 00 00 00 00 
0362+  0AAF 00 00 00 00 
0362+  0AB3 00 00 00 00 
0362+  0AB7 00 00 00 00 
0362+  0ABB 00 00 00 00 
0362+  0ABF 00 00 00 00 
0362+  0AC3 00 00 00 00 
0362+  0AC7 00 00 00 00 
0362+  0ACB 00 00 00 00 
0362+  0ACF 00 00 00 00 
0362+  0AD3 00 00 00 00 
0362+  0AD7 00 00 00 00 
0362+  0ADB 00 00 00 00 
0362+  0ADF 00 00 00 00 
0362+  0AE3 00 00 00 00 
0362+  0AE7 00 00 00 00 
0362+  0AEB 00 00 00 00 
0362+  0AEF 00 00 00 00 
0362+  0AF3 00 00 00 00 
0362+  0AF7 00 00 00 00 
0362+  0AFB 00 00 00 00 
0362+  0AFF 00 00 00 00 
0362+  0B03 00 00 00 00 
0362+  0B07 00 00 00 00 
0362+  0B0B 00 00 00 00 
0362+  0B0F 00 00 00 00 
0362+  0B13 00 00 00 00 
0362+  0B17 00 00 00 00 
0362+  0B1B 00 00 00 00 
0362+  0B1F 00 00 00 00 
0362+  0B23 00 00 00 00 
0362+  0B27 00 00 00 00 
0074   0B2B             .include "ctype.asm"
0001+  0B2B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0B2B             ; ctype.s
0003+  0B2B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0B2B             
0005+  0B2B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  0B2B             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  0B2B             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  0B2B             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  0B2B             ;; characters are supported.
0010+  0B2B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  0B2B             ;; isalnum 
0012+  0B2B             ;; isalpha 
0013+  0B2B             ;; islower 
0014+  0B2B             ;; isupper 
0015+  0B2B             ;; isdigit 
0016+  0B2B             ;; isxdigit
0017+  0B2B             ;; iscntrl 
0018+  0B2B             ;; isgraph 
0019+  0B2B             ;; isspace 
0020+  0B2B             ;; isblank 
0021+  0B2B             ;; isprint 
0022+  0B2B             ;; ispunct 
0023+  0B2B             ;; tolower 
0024+  0B2B             ;; toupper
0025+  0B2B             
0026+  0B2B             
0027+  0B2B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  0B2B             ;; IS ALPHANUMERIC
0029+  0B2B             ;; sets ZF according with result
0030+  0B2B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  0B2B             isalnum:
0032+  0B2B 07 48 0B    	call isalpha
0033+  0B2E C6 34 0B    	je isalnum_exit
0034+  0B31 07 35 0B    	call isdigit
0035+  0B34             isalnum_exit:
0036+  0B34 09          	ret	
0037+  0B35             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0B35             ;; IS DIGIT
0039+  0B35             ;; sets ZF according with result
0040+  0B35             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  0B35             isdigit:
0042+  0B35 DB          	push al
0043+  0B36 B9 30       	cmp al, '0'
0044+  0B38 C8 44 0B    	jlu isdigit_false
0045+  0B3B B9 39       	cmp al, '9'
0046+  0B3D D1 44 0B    	jgu isdigit_false
0047+  0B40 87 00       	and al, 0	; set ZF
0048+  0B42 E8          	pop al
0049+  0B43 09          	ret
0050+  0B44             isdigit_false:
0051+  0B44 8B 01       	or al, 1	; clear ZF
0052+  0B46 E8          	pop al
0053+  0B47 09          	ret	
0054+  0B48             	
0055+  0B48             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  0B48             ;; IS ALPHA
0057+  0B48             ;; sets ZF according with result
0058+  0B48             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  0B48             isalpha:
0060+  0B48 DB          	push al
0061+  0B49 B9 5F       	cmp al, '_'
0062+  0B4B C6 6B 0B    	je isalpha_true
0063+  0B4E B9 2E       	cmp al, '.'
0064+  0B50 C6 6B 0B    	je isalpha_true
0065+  0B53 B9 41       	cmp al, 'A'
0066+  0B55 C8 67 0B    	jlu isalpha_false
0067+  0B58 B9 7A       	cmp al, 'z'
0068+  0B5A D1 67 0B    	jgu isalpha_false
0069+  0B5D B9 5A       	cmp al, 'Z'
0070+  0B5F D0 6B 0B    	jleu isalpha_true
0071+  0B62 B9 61       	cmp al, 'a'
0072+  0B64 C9 6B 0B    	jgeu isalpha_true
0073+  0B67             isalpha_false:
0074+  0B67 8B 01       	or al, 1	; clear ZF
0075+  0B69 E8          	pop al
0076+  0B6A 09          	ret
0077+  0B6B             isalpha_true:
0078+  0B6B 87 00       	and al, 0	; set ZF
0079+  0B6D E8          	pop al
0080+  0B6E 09          	ret
0081+  0B6F             
0082+  0B6F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  0B6F             ;; IS PATH-ALPHA
0084+  0B6F             ;; sets ZF according with result
0085+  0B6F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  0B6F             ispath:
0087+  0B6F DB          	push al
0088+  0B70 07 35 0B    	call isdigit
0089+  0B73 C6 9D 0B    	je ispath_true
0090+  0B76 B9 5F       	cmp al, '_'
0091+  0B78 C6 9D 0B    	je ispath_true
0092+  0B7B B9 2F       	cmp al, '/'
0093+  0B7D C6 9D 0B    	je ispath_true
0094+  0B80 B9 2E       	cmp al, '.'
0095+  0B82 C6 9D 0B    	je ispath_true
0096+  0B85 B9 41       	cmp al, 'A'
0097+  0B87 C8 99 0B    	jlu ispath_false
0098+  0B8A B9 7A       	cmp al, 'z'
0099+  0B8C D1 99 0B    	jgu ispath_false
0100+  0B8F B9 5A       	cmp al, 'Z'
0101+  0B91 D0 9D 0B    	jleu ispath_true
0102+  0B94 B9 61       	cmp al, 'a'
0103+  0B96 C9 9D 0B    	jgeu ispath_true
0104+  0B99             ispath_false:
0105+  0B99 8B 01       	or al, 1	; clear ZF
0106+  0B9B E8          	pop al
0107+  0B9C 09          	ret
0108+  0B9D             ispath_true:
0109+  0B9D 87 00       	and al, 0	; set ZF
0110+  0B9F E8          	pop al
0111+  0BA0 09          	ret
0112+  0BA1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  0BA1             ;; IS SPACE
0114+  0BA1             ;; sets ZF according with result
0115+  0BA1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  0BA1             isspace:
0117+  0BA1 B9 20       	cmp al, $20		; ' '
0118+  0BA3 C6 B7 0B    	je isspace_exit
0119+  0BA6 B9 09       	cmp al, $09		; '\t'
0120+  0BA8 C6 B7 0B    	je isspace_exit
0121+  0BAB B9 0A       	cmp al, $0A		; '\n'
0122+  0BAD C6 B7 0B    	je isspace_exit
0123+  0BB0 B9 0D       	cmp al, $0D		; '\r'
0124+  0BB2 C6 B7 0B    	je isspace_exit
0125+  0BB5 B9 0B       	cmp al, $0B		; '\v'
0126+  0BB7             isspace_exit:
0127+  0BB7 09          	ret	
0128+  0BB8             
0129+  0BB8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0BB8             ; TO LOWER
0131+  0BB8             ; input in AL
0132+  0BB8             ; output in AL
0133+  0BB8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  0BB8             to_lower:
0135+  0BB8 B9 5A       	cmp al, 'Z'
0136+  0BBA D1 BF 0B    	jgu to_lower_ret
0137+  0BBD 6A 20       	add al, $20				; convert to lower case
0138+  0BBF             to_lower_ret:
0139+  0BBF 09          	ret
0140+  0BC0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  0BC0             ; TO UPPER
0142+  0BC0             ; input in AL
0143+  0BC0             ; output in AL
0144+  0BC0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  0BC0             to_upper:
0146+  0BC0 B9 61       	cmp al, 'a'
0147+  0BC2 C8 C7 0B    	jlu to_upper_ret
0148+  0BC5 6F 20       	sub al, $20			; convert to upper case
0149+  0BC7             to_upper_ret:
0150+  0BC7 09          	ret
0151+  0BC8             
0075   0BC8             
0076   0BC8 55 73 61 67 s_usage:	.db "Usage: primes [min] [max]\n", 0
0076   0BCC 65 3A 20 70 
0076   0BD0 72 69 6D 65 
0076   0BD4 73 20 5B 6D 
0076   0BD8 69 6E 5D 20 
0076   0BDC 5B 6D 61 78 
0076   0BE0 5D 0A 00 
0077   0BE3 00 00       total:		.dw 0
0078   0BE5 E8 03       max:		.dw 1000
0079   0BE7 05 00       min:		.dw 5
0080   0BE9             
0081   0BE9 0D 55 70 70 s_max:		.db "\rUpper bound: ", 0
0081   0BED 65 72 20 62 
0081   0BF1 6F 75 6E 64 
0081   0BF5 3A 20 00 
0082   0BF8 2C 20 54 6F s_total:	.db ", Total primes: ", 0
0082   0BFC 74 61 6C 20 
0082   0C00 70 72 69 6D 
0082   0C04 65 73 3A 20 
0082   0C08 00 
0083   0C09             			
0084   0C09             .end
tasm: Number of errors = 0
