0001   0000             .include "kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0002   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0003   0000             ; SHELL
0004   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0005   0000             
0006   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007   0000             ; SYSTEM CONSTANTS / EQUATIONS
0008   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0009   0000             STACK_BEGIN:  .equ $F7FF  ; beginning of stack
0010   0000             
0011   0400             .org PROC_TEXT_ORG      ; origin at 1024
0012   0400             
0013   0400             shell_main:  
0014   0400 FD 49 FF F7   mov bp, STACK_BEGIN
0015   0404 FD 47 FF F7   mov sp, STACK_BEGIN
0016   0408             
0017   0408 3B AF 07      mov d, s_prompt_config
0018   040B 07 5F 0C      call puts
0019   040E             
0020   040E             ; open config file
0021   040E             ; example: PATH=/usr/bin;
0022   040E             ; read PATH config entry
0023   040E 3B A9 07      mov d, s_prompt_PATH
0024   0411 07 5F 0C      call puts
0025   0414 3B 81 07      mov d, s_etc_config        ; '/etc/sh.conf'
0026   0417 FD 4D 93 07   mov si, s_PATH          ; config entry name is "PATH"
0027   041B FD 4F F4 06   mov di, PATH          ; config value destination is the var that holds the PATH variable
0028   041F 07 C3 04      call read_config  
0029   0422 3B F4 06      mov d, PATH
0030   0425 07 5F 0C      call puts
0031   0428             
0032   0428             ; open config file
0033   0428             ; read home directory config entry
0034   0428 3B 81 07      mov d, s_etc_config        ; '/etc/sh.conf'
0035   042B FD 4D 8E 07   mov si, s_home          ; config entry name is "home"
0036   042F FD 4F 74 06   mov di, homedir          ; config value destination is the var that holds the home directory path
0037   0433 07 C3 04      call read_config  
0038   0436             
0039   0436 10 74 07      mov a, s_etc_profile
0040   0439 42 5A 10      mov [prog], a
0041   043C 07 0C 05      call cmd_ssh
0042   043F             
0043   043F             shell_L0:
0044   043F 3B 04 08      mov d, s_sol1
0045   0442 07 5F 0C      call puts
0046   0445 19 12         mov al, 18
0047   0447 05 04         syscall sys_fileio        ; print current path
0048   0449 3B FE 07      mov d, s_hash
0049   044C 07 5F 0C      call puts
0050   044F 3B 0F 08      mov d, shell_input_buff
0051   0452 13            mov a, d
0052   0453 42 5A 10      mov [prog], a      ; reset tokenizer buffer pointer
0053   0456 07 2C 0B      call gets            ; get command
0054   0459 07 5F 04      call cmd_parser
0055   045C 0A 3F 04      jmp shell_L0
0056   045F             
0057   045F             cmd_parser:
0058   045F 07 BB 0E      call get_token          ; get command into tokstr
0059   0462 FD 4F 35 06   mov di, commands
0060   0466 FD 10         cla
0061   0468 42 11 0A      mov [parser_index], a    ; reset commands index
0062   046B             parser_L0:
0063   046B FD 4D 5E 10   mov si, tokstr
0064   046F 07 6A 0A      call strcmp
0065   0472 C6 9A 04      je parser_cmd_equal
0066   0475             parser_L0_L0:
0067   0475 FC 00 00      lea d, [di + 0]
0068   0478 BD 00         cmp byte[d], 0
0069   047A C6 83 04      je parser_L0_L0_exit      ; run through the keyword until finding NULL
0070   047D D4 01 00      add di, 1
0071   0480 0A 75 04      jmp parser_L0_L0
0072   0483             parser_L0_L0_exit:
0073   0483 D4 01 00      add di, 1        ; then skip NULL byte at the end 
0074   0486 14 11 0A      mov a, [parser_index]
0075   0489 53 02 00      add a, 2
0076   048C 42 11 0A      mov [parser_index], a      ; increase commands table index
0077   048F FC 00 00      lea d, [di + 0]
0078   0492 BD 00         cmp byte[d], 0
0079   0494 C6 B9 04      je parser_cmd_not_found
0080   0497 0A 6B 04      jmp parser_L0
0081   049A             parser_cmd_equal:
0082   049A 10 00 0D      mov a, $0D00
0083   049D 05 03         syscall sys_io        ; print carriage return
0084   049F 14 11 0A      mov a, [parser_index]      ; get the keyword pointer
0085   04A2 FD 07 64 06   call [a + keyword_ptrs]    ; execute command
0086   04A6 10 00 0D      mov a, $0D00
0087   04A9 05 03         syscall sys_io        ; print carriage return
0088   04AB             parser_retry:
0089   04AB 07 BB 0E      call get_token
0090   04AE BC 5D 10 06   cmp byte[tok], TOK_SEMI
0091   04B2 C6 5F 04      je cmd_parser
0092   04B5 07 41 10      call putback
0093   04B8 09            ret
0094   04B9             parser_cmd_not_found:
0095   04B9 07 41 10      call putback
0096   04BC 07 83 05      call cmd_exec      ; execute as file/program
0097   04BF 0A AB 04      jmp parser_retry    ; check for more commands
0098   04C2 09            ret
0099   04C3             
0100   04C3             ; inputs:
0101   04C3             ; D = filename ptr
0102   04C3             ; SI = entry name ptr
0103   04C3             ; DI = output value string ptr
0104   04C3             read_config:
0105   04C3 E3            push di
0106   04C4 E2            push si
0107   04C5 FD 4F 5E 14   mov di, shell_transient_area
0108   04C9 19 14         mov al, 20
0109   04CB 05 04         syscall sys_fileio        ; read entire config file
0110   04CD 10 5E 14      mov a, shell_transient_area
0111   04D0 42 5A 10      mov [prog], a
0112   04D3 EF            pop si
0113   04D4             read_config_L0:
0114   04D4 07 BB 0E      call get_token
0115   04D7 BC 5D 10 14   cmp byte[tok], TOK_END
0116   04DB C6 07 05      je read_config_EOF
0117   04DE FD 4F 5E 10   mov di, tokstr
0118   04E2 07 6A 0A      call strcmp
0119   04E5 C6 F5 04      je read_config_found_entry
0120   04E8             read_config_L0_L0:
0121   04E8 07 BB 0E      call get_token
0122   04EB BC 5D 10 06   cmp byte[tok], TOK_SEMI
0123   04EF C6 D4 04      je read_config_L0
0124   04F2 0A E8 04      jmp read_config_L0_L0
0125   04F5             read_config_found_entry:
0126   04F5 07 BB 0E      call get_token      ; bypass '=' sign
0127   04F8 F0            pop di
0128   04F9 14 5A 10      mov a, [prog]
0129   04FC 4D            mov si, a
0130   04FD             read_conf_L1:
0131   04FD F6            lodsb
0132   04FE B9 3B         cmp al, $3B        ; ';'
0133   0500 C6 08 05      je read_config_EOF_2
0134   0503 F7            stosb
0135   0504 0A FD 04      jmp read_conf_L1
0136   0507             read_config_EOF:
0137   0507 F0            pop di
0138   0508             read_config_EOF_2:
0139   0508 19 00         mov al, 0
0140   050A F7            stosb          ; terminate value with NULL
0141   050B 09            ret
0142   050C             
0143   050C             ; ssh = sol shell
0144   050C             cmd_ssh:
0145   050C 07 64 0E      call get_path
0146   050F 3B 5E 10      mov d, tokstr
0147   0512 FD 4F 5E 14   mov di, shell_transient_area
0148   0516 19 14         mov al, 20
0149   0518 05 04         syscall sys_fileio        ; read textfile 
0150   051A               
0151   051A 3B 5E 14      mov d, shell_transient_area
0152   051D 13            mov a, d
0153   051E 42 5A 10      mov [prog], a      ; reset tokenizer buffer pointer
0154   0521 07 5F 04      call cmd_parser
0155   0524             
0156   0524 07 0C 0C      call printnl
0157   0527 09            ret
0158   0528             
0159   0528             cmd_setdate:
0160   0528 19 01         mov al, 1      ; set datetime
0161   052A 05 07         syscall sys_datetime  
0162   052C 09            ret  
0163   052D               
0164   052D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0165   052D             ;; FILE SYSTEM DATA
0166   052D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0167   052D             ; infor for : IDE SERVICES INTERRUPT
0168   052D             ; al = option
0169   052D             ; IDE read/write sector
0170   052D             ; 512 bytes
0171   052D             ; user buffer pointer in D
0172   052D             ; AH = number of sectors
0173   052D             ; CB = LBA bytes 3..0  
0174   052D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0175   052D             ;; FILE SYSTEM DATA STRUCTURE
0176   052D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0177   052D             ; for a directory we have the header first, followed by metadata
0178   052D             ; header 1 sector (512 bytes)
0179   052D             ; metadata 1 sector (512 bytes)
0180   052D             ; HEADER ENTRIES:
0181   052D             ; filename (64)
0182   052D             ; parent dir LBA (2) -  to be used for faster backwards navigation...
0183   052D             ;
0184   052D             ; metadata entries:
0185   052D             ; filename (24)
0186   052D             ; attributes (1)
0187   052D             ; LBA (2)
0188   052D             ; size (2)
0189   052D             ; day (1)
0190   052D             ; month (1)
0191   052D             ; year (1)
0192   052D             ; packet size = 32 bytes
0193   052D             ;
0194   052D             ; first directory on disk is the root directory '/'
0195   052D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0196   052D             ;; FILE SYSTEM DISK FORMATTING
0197   052D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0198   052D             ; writes FST_TOTAL_SECTORS + FS_NBR_FILES disk sectors  with 0's
0199   052D             ; this is the file system table formating
0200   052D             cmd_mkfs:
0201   052D 19 00         mov al, 0
0202   052F 05 04         syscall sys_fileio
0203   0531 09            ret
0204   0532             
0205   0532             
0206   0532             
0207   0532             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208   0532             ;; parse path
0209   0532             ;; 
0210   0532             ;;
0211   0532             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212   0532             
0213   0532             
0214   0532             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0215   0532             ;; CD
0216   0532             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0217   0532             ; search for given directory inside current dir
0218   0532             ; if found, read its LBA, and switch directories
0219   0532             ; example:  cd /usr/bin; ls
0220   0532             ;       cd /usr/bin;
0221   0532             ;      cd /usr/bin
0222   0532             cmd_cd:
0223   0532 07 BB 0E      call get_token
0224   0535 1D 5D 10      mov al, [tok]
0225   0538 B9 14         cmp al, TOK_END
0226   053A C6 60 05      je cmd_cd_gotohome
0227   053D B9 06         cmp al, TOK_SEMI
0228   053F C6 60 05      je cmd_cd_gotohome
0229   0542 B9 08         cmp al, TOK_TILDE
0230   0544 C6 60 05      je cmd_cd_gotohome
0231   0547 07 41 10      call putback
0232   054A 07 64 0E      call get_path    ; get the path for the cd command
0233   054D             cmd_cd_syscall:
0234   054D 3B 5E 10      mov d, tokstr
0235   0550 19 13         mov al, 19
0236   0552 05 04         syscall sys_fileio  ; get dirID in A
0237   0554 AF FF FF      cmp a, $FFFF
0238   0557 C6 71 05      je cmd_cd_fail
0239   055A 27            mov b, a
0240   055B 19 03         mov al, 3
0241   055D 05 04         syscall sys_fileio  ; set dir to B
0242   055F 09            ret
0243   0560             cmd_cd_gotohome:
0244   0560 07 41 10      call putback
0245   0563 FD 4D 74 06   mov si, homedir
0246   0567 FD 4F 5E 10   mov di, tokstr
0247   056B 07 7F 0A      call strcpy
0248   056E 0A 4D 05      jmp cmd_cd_syscall
0249   0571             cmd_cd_fail:
0250   0571 09            ret
0251   0572             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0252   0572             ;; pad string to 32 chars
0253   0572             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0254   0572             ; count in C
0255   0572             padding:
0256   0572 D7            push a
0257   0573 10 20 00      mov a, 32
0258   0576 28            mov b, c
0259   0577 60            sub a, b
0260   0578 39            mov c, a
0261   0579             padding_L1:
0262   0579 22 20         mov ah, $20
0263   057B 07 25 0B      call putchar
0264   057E A9 79 05      loopc padding_L1
0265   0581 E4            pop a
0266   0582 09            ret
0267   0583             ; file structure:
0268   0583             ; 512 bytes header
0269   0583             ; header used to tell whether the block is free
0270   0583             
0271   0583             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272   0583             ;; EXEC/OPEN PROGRAM/FILE
0273   0583             ;; 'filename' maps to '$path/filename'
0274   0583             ;; './file' or '/a/directory/file' loads a file directly
0275   0583             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276   0583             cmd_exec:
0277   0583 BC 5D 10 14   cmp byte[tok], TOK_END
0278   0587 C6 0D 06      je cmd_exec_ret    ; check for NULL input
0279   058A 07 64 0E      call get_path    ; get file path 
0280   058D 14 5A 10      mov a, [prog]
0281   0590 D7            push a        ; save argument pointer
0282   0591 FD 4D 5E 10   mov si, tokstr
0283   0595 FD 4F 5E 11   mov di, temp_data1
0284   0599 07 7F 0A      call strcpy      ; copy filename for later
0285   059C BC 5E 10 2F   cmp byte[tokstr], '/'  ; check first character of path
0286   05A0 C6 FE 05      je cmd_exec_abs
0287   05A3 BC 5E 10 2E   cmp byte[tokstr], '.'  ; check first character of path
0288   05A7 C6 FE 05      je cmd_exec_abs
0289   05AA 10 F4 06      mov a, PATH
0290   05AD 42 5A 10      mov [prog], a    ; set token pointer to $PATH beginning
0291   05B0             cmd_exec_L0:
0292   05B0 07 64 0E      call get_path    ; get a path option
0293   05B3 FD 4D 5E 10   mov si, tokstr
0294   05B7 FD 4F 5E 12   mov di, temp_data
0295   05BB 07 7F 0A      call strcpy      ; firstly, form address from one of the '$PATH' addresses
0296   05BE FD 4D 02 08   mov si, s_fslash
0297   05C2 FD 4F 5E 12   mov di, temp_data
0298   05C6 07 8D 0A      call strcat      ; add '/' in between $PATH component and filename
0299   05C9 FD 4D 5E 11   mov si, temp_data1
0300   05CD FD 4F 5E 12   mov di, temp_data
0301   05D1 07 8D 0A      call strcat      ; now glue the given filename to the total path
0302   05D4 3B 5E 12      mov d, temp_data
0303   05D7 19 15         mov al, 21
0304   05D9 05 04         syscall sys_fileio  ; now we check whether such a file exists. success code is given in A. if 0, file does not exist
0305   05DB AF 00 00      cmp a, 0
0306   05DE C7 EE 05      jne cmd_exec_PATH_exists
0307   05E1 07 BB 0E      call get_token
0308   05E4 BC 5D 10 06   cmp byte[tok], TOK_SEMI
0309   05E8 C7 B0 05      jne cmd_exec_L0    ; if not ';' at the end, then token must be a separator. so try another path
0310   05EB 0A 0E 06      jmp cmd_exec_unknown
0311   05EE             cmd_exec_PATH_exists:
0312   05EE E4            pop a        ; retrieve token pointer which points to the arguments given
0313   05EF 42 5A 10      mov [prog], a
0314   05F2 07 30 0E      call get_arg    ; if however, $PATH/filename was found, then we execute it
0315   05F5 26 5E 10      mov b, tokstr
0316   05F8 3B 5E 12      mov d, temp_data
0317   05FB 05 05         syscall sys_fork
0318   05FD 09            ret
0319   05FE             cmd_exec_abs:  ; execute as absolute path
0320   05FE E4            pop a
0321   05FF 42 5A 10      mov [prog], a
0322   0602 07 30 0E      call get_arg
0323   0605 26 5E 10      mov b, tokstr
0324   0608 3B 5E 11      mov d, temp_data1  ;original filename
0325   060B 05 05         syscall sys_fork
0326   060D             cmd_exec_ret:
0327   060D 09            ret
0328   060E             cmd_exec_unknown:
0329   060E E4            pop a
0330   060F 09            ret
0331   0610             
0332   0610             cmd_shutdown:
0333   0610 19 01         mov al, 1
0334   0612 05 02         syscall sys_IDE
0335   0614 FF            halt
0336   0615 09            ret
0337   0616             
0338   0616             cmd_reboot:
0339   0616 3B DB 07      mov d, s_rebooting
0340   0619 07 5F 0C      call puts
0341   061C 05 08         syscall sys_reboot
0342   061E             
0343   061E             cmd_drtoggle:
0344   061E 0C            lodstat
0345   061F 2F            mov bl, al
0346   0620 FD 87 DF      and bl, %11011111
0347   0623 87 20         and al, %00100000
0348   0625 8F 20         xor al, %00100000
0349   0627 8C            or al, bl
0350   0628 0D            stostat
0351   0629               
0352   0629 09            ret
0353   062A             
0354   062A             cmd_fg:
0355   062A 07 BB 0E      call get_token
0356   062D 1D 5E 10      mov al, [tokstr]
0357   0630 6F 30         sub al, $30
0358   0632 05 0A         syscall sys_resumeproc
0359   0634 09            ret
0360   0635             
0361   0635 6D 6B 66 73 commands: .db "mkfs", 0
0361   0639 00 
0362   063A 63 64 00              .db "cd", 0
0363   063D 73 64 61 74           .db "sdate", 0
0363   0641 65 00 
0364   0643 72 65 62 6F           .db "reboot", 0
0364   0647 6F 74 00 
0365   064A 73 68 75 74           .db "shutdown", 0
0365   064E 64 6F 77 6E 
0365   0652 00 
0366   0653 64 72 74 6F           .db "drtoggle", 0
0366   0657 67 67 6C 65 
0366   065B 00 
0367   065C 66 67 00              .db "fg", 0
0368   065F 73 73 68 00           .db "ssh", 0
0369   0663 00                    .db 0
0370   0664             
0371   0664 2D 05       keyword_ptrs: .dw cmd_mkfs
0372   0666 32 05                     .dw cmd_cd
0373   0668 28 05                     .dw cmd_setdate
0374   066A 16 06                     .dw cmd_reboot
0375   066C 10 06                     .dw cmd_shutdown
0376   066E 1E 06                     .dw cmd_drtoggle
0377   0670 2A 06                     .dw cmd_fg
0378   0672 0C 05                     .dw cmd_ssh
0379   0674             
0380   0674 00 00 00 00 homedir:    .fill 128, 0
0380   0678 00 00 00 00 
0380   067C 00 00 00 00 
0380   0680 00 00 00 00 
0380   0684 00 00 00 00 
0380   0688 00 00 00 00 
0380   068C 00 00 00 00 
0380   0690 00 00 00 00 
0380   0694 00 00 00 00 
0380   0698 00 00 00 00 
0380   069C 00 00 00 00 
0380   06A0 00 00 00 00 
0380   06A4 00 00 00 00 
0380   06A8 00 00 00 00 
0380   06AC 00 00 00 00 
0380   06B0 00 00 00 00 
0380   06B4 00 00 00 00 
0380   06B8 00 00 00 00 
0380   06BC 00 00 00 00 
0380   06C0 00 00 00 00 
0380   06C4 00 00 00 00 
0380   06C8 00 00 00 00 
0380   06CC 00 00 00 00 
0380   06D0 00 00 00 00 
0380   06D4 00 00 00 00 
0380   06D8 00 00 00 00 
0380   06DC 00 00 00 00 
0380   06E0 00 00 00 00 
0380   06E4 00 00 00 00 
0380   06E8 00 00 00 00 
0380   06EC 00 00 00 00 
0380   06F0 00 00 00 00 
0381   06F4 00 00 00 00 PATH:      .fill 128, 0    ; $PATH environment variable (for now just one path)
0381   06F8 00 00 00 00 
0381   06FC 00 00 00 00 
0381   0700 00 00 00 00 
0381   0704 00 00 00 00 
0381   0708 00 00 00 00 
0381   070C 00 00 00 00 
0381   0710 00 00 00 00 
0381   0714 00 00 00 00 
0381   0718 00 00 00 00 
0381   071C 00 00 00 00 
0381   0720 00 00 00 00 
0381   0724 00 00 00 00 
0381   0728 00 00 00 00 
0381   072C 00 00 00 00 
0381   0730 00 00 00 00 
0381   0734 00 00 00 00 
0381   0738 00 00 00 00 
0381   073C 00 00 00 00 
0381   0740 00 00 00 00 
0381   0744 00 00 00 00 
0381   0748 00 00 00 00 
0381   074C 00 00 00 00 
0381   0750 00 00 00 00 
0381   0754 00 00 00 00 
0381   0758 00 00 00 00 
0381   075C 00 00 00 00 
0381   0760 00 00 00 00 
0381   0764 00 00 00 00 
0381   0768 00 00 00 00 
0381   076C 00 00 00 00 
0381   0770 00 00 00 00 
0382   0774             
0383   0774 2F 65 74 63 s_etc_profile:  .db "/etc/profile", 0
0383   0778 2F 70 72 6F 
0383   077C 66 69 6C 65 
0383   0780 00 
0384   0781 2F 65 74 63 s_etc_config:  .db "/etc/sh.conf", 0
0384   0785 2F 73 68 2E 
0384   0789 63 6F 6E 66 
0384   078D 00 
0385   078E 68 6F 6D 65 s_home:      .db "home", 0
0385   0792 00 
0386   0793 50 41 54 48 s_PATH:      .db "PATH", 0
0386   0797 00 
0387   0798             
0388   0798 0A 68 6F 6D s_prompt_homedir:  .db "\nhome directory=", 0
0388   079C 65 20 64 69 
0388   07A0 72 65 63 74 
0388   07A4 6F 72 79 3D 
0388   07A8 00 
0389   07A9 50 41 54 48 s_prompt_PATH:    .db "PATH=", 0
0389   07AD 3D 00 
0390   07AF 0A 72 65 61 s_prompt_config:  .db "\nreading \'/etc/sh.conf\' configuration file\n", 0
0390   07B3 64 69 6E 67 
0390   07B7 20 27 2F 65 
0390   07BB 74 63 2F 73 
0390   07BF 68 2E 63 6F 
0390   07C3 6E 66 27 20 
0390   07C7 63 6F 6E 66 
0390   07CB 69 67 75 72 
0390   07CF 61 74 69 6F 
0390   07D3 6E 20 66 69 
0390   07D7 6C 65 0A 00 
0391   07DB             
0392   07DB 1B 5B 32 4A s_rebooting:   .db 27, "[2J", 27, "[H", "rebooting", 0
0392   07DF 1B 5B 48 72 
0392   07E3 65 62 6F 6F 
0392   07E7 74 69 6E 67 
0392   07EB 00 
0393   07EC 25 20 00    s_dataentry:  .db "% ", 0
0394   07EF 0A 73 79 6E s_syntax_err:  .db "\nsyntax error\n", 0
0394   07F3 74 61 78 20 
0394   07F7 65 72 72 6F 
0394   07FB 72 0A 00 
0395   07FE 20 23 20 00 s_hash:      .db " # ", 0
0396   0802 2F 00       s_fslash:    .db "/", 0
0397   0804 53 6F 6C 61 s_sol1:      .db "Solarium:", 0, 0
0397   0808 72 69 75 6D 
0397   080C 3A 00 00 
0398   080F             ; shell variables
0399   080F 00 00 00 00 shell_input_buff:  .fill 512, 0
0399   0813 00 00 00 00 
0399   0817 00 00 00 00 
0399   081B 00 00 00 00 
0399   081F 00 00 00 00 
0399   0823 00 00 00 00 
0399   0827 00 00 00 00 
0399   082B 00 00 00 00 
0399   082F 00 00 00 00 
0399   0833 00 00 00 00 
0399   0837 00 00 00 00 
0399   083B 00 00 00 00 
0399   083F 00 00 00 00 
0399   0843 00 00 00 00 
0399   0847 00 00 00 00 
0399   084B 00 00 00 00 
0399   084F 00 00 00 00 
0399   0853 00 00 00 00 
0399   0857 00 00 00 00 
0399   085B 00 00 00 00 
0399   085F 00 00 00 00 
0399   0863 00 00 00 00 
0399   0867 00 00 00 00 
0399   086B 00 00 00 00 
0399   086F 00 00 00 00 
0399   0873 00 00 00 00 
0399   0877 00 00 00 00 
0399   087B 00 00 00 00 
0399   087F 00 00 00 00 
0399   0883 00 00 00 00 
0399   0887 00 00 00 00 
0399   088B 00 00 00 00 
0399   088F 00 00 00 00 
0399   0893 00 00 00 00 
0399   0897 00 00 00 00 
0399   089B 00 00 00 00 
0399   089F 00 00 00 00 
0399   08A3 00 00 00 00 
0399   08A7 00 00 00 00 
0399   08AB 00 00 00 00 
0399   08AF 00 00 00 00 
0399   08B3 00 00 00 00 
0399   08B7 00 00 00 00 
0399   08BB 00 00 00 00 
0399   08BF 00 00 00 00 
0399   08C3 00 00 00 00 
0399   08C7 00 00 00 00 
0399   08CB 00 00 00 00 
0399   08CF 00 00 00 00 
0399   08D3 00 00 00 00 
0399   08D7 00 00 00 00 
0399   08DB 00 00 00 00 
0399   08DF 00 00 00 00 
0399   08E3 00 00 00 00 
0399   08E7 00 00 00 00 
0399   08EB 00 00 00 00 
0399   08EF 00 00 00 00 
0399   08F3 00 00 00 00 
0399   08F7 00 00 00 00 
0399   08FB 00 00 00 00 
0399   08FF 00 00 00 00 
0399   0903 00 00 00 00 
0399   0907 00 00 00 00 
0399   090B 00 00 00 00 
0399   090F 00 00 00 00 
0399   0913 00 00 00 00 
0399   0917 00 00 00 00 
0399   091B 00 00 00 00 
0399   091F 00 00 00 00 
0399   0923 00 00 00 00 
0399   0927 00 00 00 00 
0399   092B 00 00 00 00 
0399   092F 00 00 00 00 
0399   0933 00 00 00 00 
0399   0937 00 00 00 00 
0399   093B 00 00 00 00 
0399   093F 00 00 00 00 
0399   0943 00 00 00 00 
0399   0947 00 00 00 00 
0399   094B 00 00 00 00 
0399   094F 00 00 00 00 
0399   0953 00 00 00 00 
0399   0957 00 00 00 00 
0399   095B 00 00 00 00 
0399   095F 00 00 00 00 
0399   0963 00 00 00 00 
0399   0967 00 00 00 00 
0399   096B 00 00 00 00 
0399   096F 00 00 00 00 
0399   0973 00 00 00 00 
0399   0977 00 00 00 00 
0399   097B 00 00 00 00 
0399   097F 00 00 00 00 
0399   0983 00 00 00 00 
0399   0987 00 00 00 00 
0399   098B 00 00 00 00 
0399   098F 00 00 00 00 
0399   0993 00 00 00 00 
0399   0997 00 00 00 00 
0399   099B 00 00 00 00 
0399   099F 00 00 00 00 
0399   09A3 00 00 00 00 
0399   09A7 00 00 00 00 
0399   09AB 00 00 00 00 
0399   09AF 00 00 00 00 
0399   09B3 00 00 00 00 
0399   09B7 00 00 00 00 
0399   09BB 00 00 00 00 
0399   09BF 00 00 00 00 
0399   09C3 00 00 00 00 
0399   09C7 00 00 00 00 
0399   09CB 00 00 00 00 
0399   09CF 00 00 00 00 
0399   09D3 00 00 00 00 
0399   09D7 00 00 00 00 
0399   09DB 00 00 00 00 
0399   09DF 00 00 00 00 
0399   09E3 00 00 00 00 
0399   09E7 00 00 00 00 
0399   09EB 00 00 00 00 
0399   09EF 00 00 00 00 
0399   09F3 00 00 00 00 
0399   09F7 00 00 00 00 
0399   09FB 00 00 00 00 
0399   09FF 00 00 00 00 
0399   0A03 00 00 00 00 
0399   0A07 00 00 00 00 
0399   0A0B 00 00 00 00 
0400   0A0F 00 00       shell_buff_ptr:    .dw 0
0401   0A11 00 00       parser_index:     .dw 0
0402   0A13             
0403   0A13             .include "stdio.asm"
0001+  0A13             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0A13             ; stdio.s
0003+  0A13             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0A13             .include "string.asm"
0001++ 0A13             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0A13             ; string.s
0003++ 0A13             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0A13             
0005++ 0A13             
0006++ 0A13             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0A13             ; strrev
0008++ 0A13             ; reverse a string
0009++ 0A13             ; D = string address
0010++ 0A13             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0A13             ; 01234
0012++ 0A13             strrev:
0013++ 0A13 4B          	pusha
0014++ 0A14 07 5A 0A    	call strlen	; length in C
0015++ 0A17 12          	mov a, c
0016++ 0A18 AF 01 00    	cmp a, 1
0017++ 0A1B D0 35 0A    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0A1E 7D          	dec a
0019++ 0A1F FD 4E       	mov si, d	; beginning of string
0020++ 0A21 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0A23 59          	add d, a	; end of string
0022++ 0A24 12          	mov a, c
0023++ 0A25 FD 9B       	shr a		; divide by 2
0024++ 0A27 39          	mov c, a	; C now counts the steps
0025++ 0A28             strrev_L0:
0026++ 0A28 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0A29 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0A2A 3E          	mov [d], al	; store left char into right side
0029++ 0A2B 1B          	mov al, bl
0030++ 0A2C F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0A2D 7E          	dec c
0032++ 0A2E 7F          	dec d
0033++ 0A2F C2 00 00    	cmp c, 0
0034++ 0A32 C7 28 0A    	jne strrev_L0
0035++ 0A35             strrev_end:
0036++ 0A35 4C          	popa
0037++ 0A36 09          	ret
0038++ 0A37             	
0039++ 0A37             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0A37             ; strchr
0041++ 0A37             ; search string in D for char in AL
0042++ 0A37             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0A37             strchr:
0044++ 0A37             strchr_L0:
0045++ 0A37 32          	mov bl, [d]
0046++ 0A38 C1 00       	cmp bl, 0
0047++ 0A3A C6 45 0A    	je strchr_end
0048++ 0A3D BA          	cmp al, bl
0049++ 0A3E C6 45 0A    	je strchr_end
0050++ 0A41 79          	inc d
0051++ 0A42 0A 37 0A    	jmp strchr_L0
0052++ 0A45             strchr_end:
0053++ 0A45 1B          	mov al, bl
0054++ 0A46 09          	ret
0055++ 0A47             
0056++ 0A47             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0A47             ; strstr
0058++ 0A47             ; find sub-string
0059++ 0A47             ; str1 in SI
0060++ 0A47             ; str2 in DI
0061++ 0A47             ; SI points to end of source string
0062++ 0A47             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0A47             strstr:
0064++ 0A47 DB          	push al
0065++ 0A48 DA          	push d
0066++ 0A49 E3          	push di
0067++ 0A4A             strstr_loop:
0068++ 0A4A F3          	cmpsb					; compare a byte of the strings
0069++ 0A4B C7 56 0A    	jne strstr_ret
0070++ 0A4E FC 00 00    	lea d, [di + 0]
0071++ 0A51 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0A53 C7 4A 0A    	jne strstr_loop				; equal chars but not at end
0073++ 0A56             strstr_ret:
0074++ 0A56 F0          	pop di
0075++ 0A57 E7          	pop d
0076++ 0A58 E8          	pop al
0077++ 0A59 09          	ret
0078++ 0A5A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0A5A             ; length of null terminated string
0080++ 0A5A             ; result in C
0081++ 0A5A             ; pointer in D
0082++ 0A5A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0A5A             strlen:
0084++ 0A5A DA          	push d
0085++ 0A5B 38 00 00    	mov c, 0
0086++ 0A5E             strlen_L1:
0087++ 0A5E BD 00       	cmp byte [d], 0
0088++ 0A60 C6 68 0A    	je strlen_ret
0089++ 0A63 79          	inc d
0090++ 0A64 78          	inc c
0091++ 0A65 0A 5E 0A    	jmp strlen_L1
0092++ 0A68             strlen_ret:
0093++ 0A68 E7          	pop d
0094++ 0A69 09          	ret
0095++ 0A6A             
0096++ 0A6A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0A6A             ; STRCMP
0098++ 0A6A             ; compare two strings
0099++ 0A6A             ; str1 in SI
0100++ 0A6A             ; str2 in DI
0101++ 0A6A             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0A6A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0A6A             strcmp:
0104++ 0A6A DB          	push al
0105++ 0A6B DA          	push d
0106++ 0A6C E3          	push di
0107++ 0A6D E2          	push si
0108++ 0A6E             strcmp_loop:
0109++ 0A6E F3          	cmpsb					; compare a byte of the strings
0110++ 0A6F C7 7A 0A    	jne strcmp_ret
0111++ 0A72 FB FF FF    	lea d, [si +- 1]
0112++ 0A75 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0A77 C7 6E 0A    	jne strcmp_loop				; equal chars but not at end
0114++ 0A7A             strcmp_ret:
0115++ 0A7A EF          	pop si
0116++ 0A7B F0          	pop di
0117++ 0A7C E7          	pop d
0118++ 0A7D E8          	pop al
0119++ 0A7E 09          	ret
0120++ 0A7F             
0121++ 0A7F             
0122++ 0A7F             ; STRCPY
0123++ 0A7F             ; copy null terminated string from SI to DI
0124++ 0A7F             ; source in SI
0125++ 0A7F             ; destination in DI
0126++ 0A7F             strcpy:
0127++ 0A7F E2          	push si
0128++ 0A80 E3          	push di
0129++ 0A81 DB          	push al
0130++ 0A82             strcpy_L1:
0131++ 0A82 F6          	lodsb
0132++ 0A83 F7          	stosb
0133++ 0A84 B9 00       	cmp al, 0
0134++ 0A86 C7 82 0A    	jne strcpy_L1
0135++ 0A89             strcpy_end:
0136++ 0A89 E8          	pop al
0137++ 0A8A F0          	pop di
0138++ 0A8B EF          	pop si
0139++ 0A8C 09          	ret
0140++ 0A8D             
0141++ 0A8D             ; STRCAT
0142++ 0A8D             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0A8D             ; source in SI
0144++ 0A8D             ; destination in DI
0145++ 0A8D             strcat:
0146++ 0A8D E2          	push si
0147++ 0A8E E3          	push di
0148++ 0A8F D7          	push a
0149++ 0A90 DA          	push d
0150++ 0A91 50          	mov a, di
0151++ 0A92 3C          	mov d, a
0152++ 0A93             strcat_goto_end_L1:
0153++ 0A93 BD 00       	cmp byte[d], 0
0154++ 0A95 C6 9C 0A    	je strcat_start
0155++ 0A98 79          	inc d
0156++ 0A99 0A 93 0A    	jmp strcat_goto_end_L1
0157++ 0A9C             strcat_start:
0158++ 0A9C FD 50       	mov di, d
0159++ 0A9E             strcat_L1:
0160++ 0A9E F6          	lodsb
0161++ 0A9F F7          	stosb
0162++ 0AA0 B9 00       	cmp al, 0
0163++ 0AA2 C7 9E 0A    	jne strcat_L1
0164++ 0AA5             strcat_end:
0165++ 0AA5 E7          	pop d
0166++ 0AA6 E4          	pop a
0167++ 0AA7 F0          	pop di
0168++ 0AA8 EF          	pop si
0169++ 0AA9 09          	ret
0005+  0AAA             
0006+  0AAA 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  0AAE 34 35 36 37 
0006+  0AB2 38 39 41 42 
0006+  0AB6 43 44 45 46 
0007+  0ABA 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  0ABE 1B 5B 48 00 
0008+  0AC2             
0009+  0AC2 01 00       table_power:.dw 1
0010+  0AC4 0A 00       			.dw 10
0011+  0AC6 64 00       			.dw 100
0012+  0AC8 E8 03       			.dw 1000
0013+  0ACA 10 27       			.dw 10000
0014+  0ACC             
0015+  0ACC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  0ACC             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  0ACC             ; ASCII in BL
0018+  0ACC             ; result in AL
0019+  0ACC             ; ascii for F = 0100 0110
0020+  0ACC             ; ascii for 9 = 0011 1001
0021+  0ACC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  0ACC             hex_ascii_encode:
0023+  0ACC 1B          	mov al, bl
0024+  0ACD 93 40       	test al, $40				; test if letter or number
0025+  0ACF C7 D5 0A    	jnz hex_letter
0026+  0AD2 87 0F       	and al, $0F				; get number
0027+  0AD4 09          	ret
0028+  0AD5             hex_letter:
0029+  0AD5 87 0F       	and al, $0F				; get letter
0030+  0AD7 6A 09       	add al, 9
0031+  0AD9 09          	ret
0032+  0ADA             
0033+  0ADA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  0ADA             ; ATOI
0035+  0ADA             ; 2 letter hex string in B
0036+  0ADA             ; 8bit integer returned in AL
0037+  0ADA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0ADA             atoi:
0039+  0ADA D8          	push b
0040+  0ADB 07 CC 0A    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  0ADE 30          	mov bl, bh
0042+  0ADF DB          	push al					; save a
0043+  0AE0 07 CC 0A    	call hex_ascii_encode
0044+  0AE3 EA          	pop bl	
0045+  0AE4 FD 9E 04    	shl al, 4
0046+  0AE7 8C          	or al, bl
0047+  0AE8 E5          	pop b
0048+  0AE9 09          	ret	
0049+  0AEA             
0050+  0AEA             
0051+  0AEA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  0AEA             ; printf
0053+  0AEA             ; no need for explanations!
0054+  0AEA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0AEA             printf:
0056+  0AEA 09          	ret
0057+  0AEB             
0058+  0AEB             
0059+  0AEB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  0AEB             ; scanf
0061+  0AEB             ; no need for explanations!
0062+  0AEB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  0AEB             scanf:
0064+  0AEB 09          	ret
0065+  0AEC             
0066+  0AEC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  0AEC             ; ITOA
0068+  0AEC             ; 8bit value in BL
0069+  0AEC             ; 2 byte ASCII result in A
0070+  0AEC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  0AEC             itoa:
0072+  0AEC DA          	push d
0073+  0AED D8          	push b
0074+  0AEE A7 00       	mov bh, 0
0075+  0AF0 FD A4 04    	shr bl, 4	
0076+  0AF3 74          	mov d, b
0077+  0AF4 1F AA 0A    	mov al, [d + s_hex_digits]
0078+  0AF7 23          	mov ah, al
0079+  0AF8             	
0080+  0AF8 E5          	pop b
0081+  0AF9 D8          	push b
0082+  0AFA A7 00       	mov bh, 0
0083+  0AFC FD 87 0F    	and bl, $0F
0084+  0AFF 74          	mov d, b
0085+  0B00 1F AA 0A    	mov al, [d + s_hex_digits]
0086+  0B03 E5          	pop b
0087+  0B04 E7          	pop d
0088+  0B05 09          	ret
0089+  0B06             
0090+  0B06             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  0B06             ; HEX STRING TO BINARY
0092+  0B06             ; di = destination address
0093+  0B06             ; si = source
0094+  0B06             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  0B06             hex_to_int:
0096+  0B06             hex_to_int_L1:
0097+  0B06 F6          	lodsb					; load from [SI] to AL
0098+  0B07 B9 00       	cmp al, 0				; check if ASCII 0
0099+  0B09 C6 16 0B    	jz hex_to_int_ret
0100+  0B0C 36          	mov bh, al
0101+  0B0D F6          	lodsb
0102+  0B0E 2F          	mov bl, al
0103+  0B0F 07 DA 0A    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  0B12 F7          	stosb					; store AL to [DI]
0105+  0B13 0A 06 0B    	jmp hex_to_int_L1
0106+  0B16             hex_to_int_ret:
0107+  0B16 09          	ret		
0108+  0B17             
0109+  0B17             
0110+  0B17             
0111+  0B17             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  0B17             ; GETCHAR
0113+  0B17             ; char in ah
0114+  0B17             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  0B17             getchar:
0116+  0B17 DB          	push al
0117+  0B18             getchar_retry:
0118+  0B18 FD 0C       	sti
0119+  0B1A 19 01       	mov al, 1
0120+  0B1C 05 03       	syscall sys_io			; receive in AH
0121+  0B1E B9 00       	cmp al, 0			; check if any char was receive
0122+  0B20 C6 18 0B    	je getchar_retry
0123+  0B23 E8          	pop al
0124+  0B24 09          	ret
0125+  0B25             
0126+  0B25             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  0B25             ; PUTCHAR
0128+  0B25             ; char in ah
0129+  0B25             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0B25             putchar:
0131+  0B25 D7          	push a
0132+  0B26 19 00       	mov al, 0
0133+  0B28 05 03       	syscall sys_io			; char in AH
0134+  0B2A E4          	pop a
0135+  0B2B 09          	ret
0136+  0B2C             
0137+  0B2C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  0B2C             ;; INPUT A STRING
0139+  0B2C             ;; terminates with null
0140+  0B2C             ;; pointer in D
0141+  0B2C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  0B2C             gets:
0143+  0B2C D7          	push a
0144+  0B2D DA          	push d
0145+  0B2E             gets_loop:
0146+  0B2E FD 0C       	sti
0147+  0B30 19 01       	mov al, 1
0148+  0B32 05 03       	syscall sys_io			; receive in AH
0149+  0B34 B9 00       	cmp al, 0				; check error code (AL)
0150+  0B36 C6 2E 0B    	je gets_loop			; if no char received, retry
0151+  0B39             
0152+  0B39 76 1B       	cmp ah, 27
0153+  0B3B C6 5C 0B    	je gets_telnet_escape
0154+  0B3E 76 0A       	cmp ah, $0A				; LF
0155+  0B40 C6 B5 0B    	je gets_end
0156+  0B43 76 0D       	cmp ah, $0D				; CR
0157+  0B45 C6 B5 0B    	je gets_end
0158+  0B48 76 5C       	cmp ah, $5C				; '\\'
0159+  0B4A C6 8C 0B    	je gets_escape
0160+  0B4D             	
0161+  0B4D 76 08       	cmp ah, $08			; check for backspace
0162+  0B4F C6 58 0B    	je gets_backspace
0163+  0B52             
0164+  0B52 1A          	mov al, ah
0165+  0B53 3E          	mov [d], al
0166+  0B54 79          	inc d
0167+  0B55 0A 2E 0B    	jmp gets_loop
0168+  0B58             gets_backspace:
0169+  0B58 7F          	dec d
0170+  0B59 0A 2E 0B    	jmp gets_loop
0171+  0B5C             gets_telnet_escape:
0172+  0B5C FD 0C       	sti
0173+  0B5E 19 01       	mov al, 1
0174+  0B60 05 03       	syscall sys_io				; receive in AH without echo
0175+  0B62 B9 00       	cmp al, 0					; check error code (AL)
0176+  0B64 C6 5C 0B    	je gets_telnet_escape		; if no char received, retry
0177+  0B67 76 5B       	cmp ah, '['
0178+  0B69 C7 2E 0B    	jne gets_loop
0179+  0B6C             gets_telnet_escape_phase2:
0180+  0B6C FD 0C       	sti
0181+  0B6E 19 01       	mov al, 1
0182+  0B70 05 03       	syscall sys_io					; receive in AH without echo
0183+  0B72 B9 00       	cmp al, 0						; check error code (AL)
0184+  0B74 C6 6C 0B    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  0B77 76 44       	cmp ah, 'D'
0186+  0B79 C6 84 0B    	je gets_left_arrow
0187+  0B7C 76 43       	cmp ah, 'C'
0188+  0B7E C6 88 0B    	je gets_right_arrow
0189+  0B81 0A 2E 0B    	jmp gets_loop
0190+  0B84             gets_left_arrow:
0191+  0B84 7F          	dec d
0192+  0B85 0A 2E 0B    	jmp gets_loop
0193+  0B88             gets_right_arrow:
0194+  0B88 79          	inc d
0195+  0B89 0A 2E 0B    	jmp gets_loop
0196+  0B8C             gets_escape:
0197+  0B8C FD 0C       	sti
0198+  0B8E 19 01       	mov al, 1
0199+  0B90 05 03       	syscall sys_io			; receive in AH
0200+  0B92 B9 00       	cmp al, 0				; check error code (AL)
0201+  0B94 C6 8C 0B    	je gets_escape			; if no char received, retry
0202+  0B97 76 6E       	cmp ah, 'n'
0203+  0B99 C6 A7 0B    	je gets_LF
0204+  0B9C 76 72       	cmp ah, 'r'
0205+  0B9E C6 AE 0B    	je gets_CR
0206+  0BA1 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  0BA2 3E          	mov [d], al
0208+  0BA3 79          	inc d
0209+  0BA4 0A 2E 0B    	jmp gets_loop
0210+  0BA7             gets_LF:
0211+  0BA7 19 0A       	mov al, $0A
0212+  0BA9 3E          	mov [d], al
0213+  0BAA 79          	inc d
0214+  0BAB 0A 2E 0B    	jmp gets_loop
0215+  0BAE             gets_CR:
0216+  0BAE 19 0D       	mov al, $0D
0217+  0BB0 3E          	mov [d], al
0218+  0BB1 79          	inc d
0219+  0BB2 0A 2E 0B    	jmp gets_loop
0220+  0BB5             gets_end:
0221+  0BB5 19 00       	mov al, 0
0222+  0BB7 3E          	mov [d], al				; terminate string
0223+  0BB8 E7          	pop d
0224+  0BB9 E4          	pop a
0225+  0BBA 09          	ret
0226+  0BBB             
0227+  0BBB             
0228+  0BBB             
0229+  0BBB             
0230+  0BBB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  0BBB             ;; INPUT TEXT
0232+  0BBB             ;; terminated with CTRL+D
0233+  0BBB             ;; pointer in D
0234+  0BBB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  0BBB             gettxt:
0236+  0BBB D7          	push a
0237+  0BBC DA          	push d
0238+  0BBD             gettxt_loop:
0239+  0BBD 19 01       	mov al, 1
0240+  0BBF 05 03       	syscall sys_io			; receive in AH
0241+  0BC1 B9 00       	cmp al, 0				; check error code (AL)
0242+  0BC3 C6 BD 0B    	je gettxt_loop		; if no char received, retry
0243+  0BC6 76 04       	cmp ah, 4			; EOT
0244+  0BC8 C6 06 0C    	je gettxt_end
0245+  0BCB 76 08       	cmp ah, $08			; check for backspace
0246+  0BCD C6 02 0C    	je gettxt_backspace
0247+  0BD0 76 5C       	cmp ah, $5C				; '\\'
0248+  0BD2 C6 DB 0B    	je gettxt_escape
0249+  0BD5 1A          	mov al, ah
0250+  0BD6 3E          	mov [d], al
0251+  0BD7 79          	inc d
0252+  0BD8 0A BD 0B    	jmp gettxt_loop
0253+  0BDB             gettxt_escape:
0254+  0BDB 19 01       	mov al, 1
0255+  0BDD 05 03       	syscall sys_io			; receive in AH
0256+  0BDF B9 00       	cmp al, 0				; check error code (AL)
0257+  0BE1 C6 DB 0B    	je gettxt_escape		; if no char received, retry
0258+  0BE4 76 6E       	cmp ah, 'n'
0259+  0BE6 C6 F4 0B    	je gettxt_LF
0260+  0BE9 76 72       	cmp ah, 'r'
0261+  0BEB C6 FB 0B    	je gettxt_CR
0262+  0BEE 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  0BEF 3E          	mov [d], al
0264+  0BF0 79          	inc d
0265+  0BF1 0A BD 0B    	jmp gettxt_loop
0266+  0BF4             gettxt_LF:
0267+  0BF4 19 0A       	mov al, $0A
0268+  0BF6 3E          	mov [d], al
0269+  0BF7 79          	inc d
0270+  0BF8 0A BD 0B    	jmp gettxt_loop
0271+  0BFB             gettxt_CR:
0272+  0BFB 19 0D       	mov al, $0D
0273+  0BFD 3E          	mov [d], al
0274+  0BFE 79          	inc d
0275+  0BFF 0A BD 0B    	jmp gettxt_loop
0276+  0C02             gettxt_backspace:
0277+  0C02 7F          	dec d
0278+  0C03 0A BD 0B    	jmp gettxt_loop
0279+  0C06             gettxt_end:
0280+  0C06 19 00       	mov al, 0
0281+  0C08 3E          	mov [d], al				; terminate string
0282+  0C09 E7          	pop d
0283+  0C0A E4          	pop a
0284+  0C0B 09          	ret
0285+  0C0C             
0286+  0C0C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  0C0C             ; PRINT NEW LINE
0288+  0C0C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  0C0C             printnl:
0290+  0C0C D7          	push a
0291+  0C0D 10 00 0A    	mov a, $0A00
0292+  0C10 05 03       	syscall sys_io
0293+  0C12 10 00 0D    	mov a, $0D00
0294+  0C15 05 03       	syscall sys_io
0295+  0C17 E4          	pop a
0296+  0C18 09          	ret
0297+  0C19             
0298+  0C19             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  0C19             ; strtoint
0300+  0C19             ; 4 digit hex string number in d
0301+  0C19             ; integer returned in A
0302+  0C19             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  0C19             strtointx:
0304+  0C19 D8          	push b
0305+  0C1A 32          	mov bl, [d]
0306+  0C1B 37          	mov bh, bl
0307+  0C1C 33 01 00    	mov bl, [d + 1]
0308+  0C1F 07 DA 0A    	call atoi				; convert to int in AL
0309+  0C22 23          	mov ah, al				; move to AH
0310+  0C23 33 02 00    	mov bl, [d + 2]
0311+  0C26 37          	mov bh, bl
0312+  0C27 33 03 00    	mov bl, [d + 3]
0313+  0C2A 07 DA 0A    	call atoi				; convert to int in AL
0314+  0C2D E5          	pop b
0315+  0C2E 09          	ret
0316+  0C2F             
0317+  0C2F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  0C2F             ; strtoint
0319+  0C2F             ; 5 digit base10 string number in d
0320+  0C2F             ; integer returned in A
0321+  0C2F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  0C2F             strtoint:
0323+  0C2F E2          	push si
0324+  0C30 D8          	push b
0325+  0C31 D9          	push c
0326+  0C32 DA          	push d
0327+  0C33 07 5A 0A    	call strlen			; get string length in C
0328+  0C36 7E          	dec c
0329+  0C37 FD 4E       	mov si, d
0330+  0C39 12          	mov a, c
0331+  0C3A FD 99       	shl a
0332+  0C3C 3B C2 0A    	mov d, table_power
0333+  0C3F 59          	add d, a
0334+  0C40 38 00 00    	mov c, 0
0335+  0C43             strtoint_L0:
0336+  0C43 F6          	lodsb			; load ASCII to al
0337+  0C44 B9 00       	cmp al, 0
0338+  0C46 C6 59 0C    	je strtoint_end
0339+  0C49 6F 30       	sub al, $30		; make into integer
0340+  0C4B 22 00       	mov ah, 0
0341+  0C4D 2A          	mov b, [d]
0342+  0C4E AC          	mul a, b			; result in B since it fits in 16bits
0343+  0C4F 11          	mov a, b
0344+  0C50 28          	mov b, c
0345+  0C51 54          	add a, b
0346+  0C52 39          	mov c, a
0347+  0C53 63 02 00    	sub d, 2
0348+  0C56 0A 43 0C    	jmp strtoint_L0
0349+  0C59             strtoint_end:
0350+  0C59 12          	mov a, c
0351+  0C5A E7          	pop d
0352+  0C5B E6          	pop c
0353+  0C5C E5          	pop b
0354+  0C5D EF          	pop si
0355+  0C5E 09          	ret
0356+  0C5F             
0357+  0C5F             
0358+  0C5F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  0C5F             ; PRINT NULL TERMINATED STRING
0360+  0C5F             ; pointer in D
0361+  0C5F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  0C5F             puts:
0363+  0C5F D7          	push a
0364+  0C60 DA          	push d
0365+  0C61             puts_L1:
0366+  0C61 1E          	mov al, [d]
0367+  0C62 B9 00       	cmp al, 0
0368+  0C64 C6 70 0C    	jz puts_END
0369+  0C67 23          	mov ah, al
0370+  0C68 19 00       	mov al, 0
0371+  0C6A 05 03       	syscall sys_io
0372+  0C6C 79          	inc d
0373+  0C6D 0A 61 0C    	jmp puts_L1
0374+  0C70             puts_END:
0375+  0C70 E7          	pop d
0376+  0C71 E4          	pop a
0377+  0C72 09          	ret
0378+  0C73             
0379+  0C73             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  0C73             ; PRINT N SIZE STRING
0381+  0C73             ; pointer in D
0382+  0C73             ; size in C
0383+  0C73             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  0C73             putsn:
0385+  0C73 DB          	push al
0386+  0C74 DA          	push d
0387+  0C75 D9          	push c
0388+  0C76             putsn_L0:
0389+  0C76 1E          	mov al, [d]
0390+  0C77 23          	mov ah, al
0391+  0C78 19 00       	mov al, 0
0392+  0C7A 05 03       	syscall sys_io
0393+  0C7C 79          	inc d
0394+  0C7D 7E          	dec c	
0395+  0C7E C2 00 00    	cmp c, 0
0396+  0C81 C7 76 0C    	jne putsn_L0
0397+  0C84             putsn_end:
0398+  0C84 E6          	pop c
0399+  0C85 E7          	pop d
0400+  0C86 E8          	pop al
0401+  0C87 09          	ret
0402+  0C88             
0403+  0C88             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  0C88             ; print 16bit decimal number
0405+  0C88             ; input number in A
0406+  0C88             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  0C88             print_u16d:
0408+  0C88 D7          	push a
0409+  0C89 D8          	push b
0410+  0C8A 26 10 27    	mov b, 10000
0411+  0C8D AE          	div a, b			; get 10000's coeff.
0412+  0C8E 07 B0 0C    	call print_number
0413+  0C91 11          	mov a, b
0414+  0C92 26 E8 03    	mov b, 1000
0415+  0C95 AE          	div a, b			; get 1000's coeff.
0416+  0C96 07 B0 0C    	call print_number
0417+  0C99 11          	mov a, b
0418+  0C9A 26 64 00    	mov b, 100
0419+  0C9D AE          	div a, b
0420+  0C9E 07 B0 0C    	call print_number
0421+  0CA1 11          	mov a, b
0422+  0CA2 26 0A 00    	mov b, 10
0423+  0CA5 AE          	div a, b
0424+  0CA6 07 B0 0C    	call print_number
0425+  0CA9 1B          	mov al, bl			; 1's coeff in bl
0426+  0CAA 07 B0 0C    	call print_number
0427+  0CAD E5          	pop b
0428+  0CAE E4          	pop a
0429+  0CAF 09          	ret
0430+  0CB0             
0431+  0CB0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0432+  0CB0             ; print AL
0433+  0CB0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0434+  0CB0             print_number:
0435+  0CB0 6A 30       	add al, $30
0436+  0CB2 23          	mov ah, al
0437+  0CB3 07 25 0B    	call putchar
0438+  0CB6 09          	ret
0439+  0CB7             
0440+  0CB7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0441+  0CB7             ; PRINT 16BIT HEX INTEGER
0442+  0CB7             ; integer value in reg B
0443+  0CB7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0444+  0CB7             print_u16x:
0445+  0CB7 D7          	push a
0446+  0CB8 D8          	push b
0447+  0CB9 DD          	push bl
0448+  0CBA 30          	mov bl, bh
0449+  0CBB 07 EC 0A    	call itoa				; convert bh to char in A
0450+  0CBE 2F          	mov bl, al				; save al
0451+  0CBF 19 00       	mov al, 0
0452+  0CC1 05 03       	syscall sys_io				; display AH
0453+  0CC3 24          	mov ah, bl				; retrieve al
0454+  0CC4 19 00       	mov al, 0
0455+  0CC6 05 03       	syscall sys_io				; display AL
0456+  0CC8             
0457+  0CC8 EA          	pop bl
0458+  0CC9 07 EC 0A    	call itoa				; convert bh to char in A
0459+  0CCC 2F          	mov bl, al				; save al
0460+  0CCD 19 00       	mov al, 0
0461+  0CCF 05 03       	syscall sys_io				; display AH
0462+  0CD1 24          	mov ah, bl				; retrieve al
0463+  0CD2 19 00       	mov al, 0
0464+  0CD4 05 03       	syscall sys_io				; display AL
0465+  0CD6             
0466+  0CD6 E5          	pop b
0467+  0CD7 E4          	pop a
0468+  0CD8 09          	ret
0469+  0CD9             
0470+  0CD9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0471+  0CD9             ; INPUT 16BIT HEX INTEGER
0472+  0CD9             ; read 16bit integer into A
0473+  0CD9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0474+  0CD9             scan_u16x:
0475+  0CD9 F8 10 00    	enter 16
0476+  0CDC D8          	push b
0477+  0CDD DA          	push d
0478+  0CDE             
0479+  0CDE FA F1 FF    	lea d, [bp + -15]
0480+  0CE1 07 2C 0B    	call gets				; get number
0481+  0CE4             
0482+  0CE4 32          	mov bl, [d]
0483+  0CE5 37          	mov bh, bl
0484+  0CE6 33 01 00    	mov bl, [d + 1]
0485+  0CE9 07 DA 0A    	call atoi				; convert to int in AL
0486+  0CEC 23          	mov ah, al				; move to AH
0487+  0CED             
0488+  0CED 33 02 00    	mov bl, [d + 2]
0489+  0CF0 37          	mov bh, bl
0490+  0CF1 33 03 00    	mov bl, [d + 3]
0491+  0CF4 07 DA 0A    	call atoi				; convert to int in AL
0492+  0CF7             
0493+  0CF7 E7          	pop d
0494+  0CF8 E5          	pop b
0495+  0CF9 F9          	leave
0496+  0CFA 09          	ret
0497+  0CFB             
0498+  0CFB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0499+  0CFB             ; PRINT 8bit HEX INTEGER
0500+  0CFB             ; integer value in reg bl
0501+  0CFB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0502+  0CFB             print_u8x:
0503+  0CFB D7          	push a
0504+  0CFC DD          	push bl
0505+  0CFD             
0506+  0CFD 07 EC 0A    	call itoa				; convert bl to char in A
0507+  0D00 2F          	mov bl, al				; save al
0508+  0D01 19 00       	mov al, 0
0509+  0D03 05 03       	syscall sys_io				; display AH
0510+  0D05 24          	mov ah, bl				; retrieve al
0511+  0D06 19 00       	mov al, 0
0512+  0D08 05 03       	syscall sys_io				; display AL
0513+  0D0A             
0514+  0D0A EA          	pop bl
0515+  0D0B E4          	pop a
0516+  0D0C 09          	ret
0517+  0D0D             
0518+  0D0D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0519+  0D0D             ; print 8bit decimal unsigned number
0520+  0D0D             ; input number in AL
0521+  0D0D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0522+  0D0D             print_u8d:
0523+  0D0D D7          	push a
0524+  0D0E D8          	push b
0525+  0D0F             
0526+  0D0F 22 00       	mov ah, 0
0527+  0D11 26 64 00    	mov b, 100
0528+  0D14 AE          	div a, b
0529+  0D15 D8          	push b			; save remainder
0530+  0D16 B9 00       	cmp al, 0
0531+  0D18 C6 22 0D    	je skip100
0532+  0D1B 6A 30       	add al, $30
0533+  0D1D 23          	mov ah, al
0534+  0D1E 19 00       	mov al, 0
0535+  0D20 05 03       	syscall sys_io	; print coeff
0536+  0D22             skip100:
0537+  0D22 E4          	pop a
0538+  0D23 22 00       	mov ah, 0
0539+  0D25 26 0A 00    	mov b, 10
0540+  0D28 AE          	div a, b
0541+  0D29 D8          	push b			; save remainder
0542+  0D2A B9 00       	cmp al, 0
0543+  0D2C C6 36 0D    	je skip10
0544+  0D2F 6A 30       	add al, $30
0545+  0D31 23          	mov ah, al
0546+  0D32 19 00       	mov al, 0
0547+  0D34 05 03       	syscall sys_io	; print coeff
0548+  0D36             skip10:
0549+  0D36 E4          	pop a
0550+  0D37 1B          	mov al, bl
0551+  0D38 6A 30       	add al, $30
0552+  0D3A 23          	mov ah, al
0553+  0D3B 19 00       	mov al, 0
0554+  0D3D 05 03       	syscall sys_io	; print coeff
0555+  0D3F E5          	pop b
0556+  0D40 E4          	pop a
0557+  0D41 09          	ret
0558+  0D42             
0559+  0D42             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0560+  0D42             ; INPUT 8BIT HEX INTEGER
0561+  0D42             ; read 8bit integer into AL
0562+  0D42             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0563+  0D42             scan_u8x:
0564+  0D42 F8 04 00    	enter 4
0565+  0D45 D8          	push b
0566+  0D46 DA          	push d
0567+  0D47             
0568+  0D47 FA FD FF    	lea d, [bp + -3]
0569+  0D4A 07 2C 0B    	call gets				; get number
0570+  0D4D             
0571+  0D4D 32          	mov bl, [d]
0572+  0D4E 37          	mov bh, bl
0573+  0D4F 33 01 00    	mov bl, [d + 1]
0574+  0D52 07 DA 0A    	call atoi				; convert to int in AL
0575+  0D55             
0576+  0D55 E7          	pop d
0577+  0D56 E5          	pop b
0578+  0D57 F9          	leave
0579+  0D58 09          	ret
0580+  0D59             
0581+  0D59             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0582+  0D59             ; input decimal number
0583+  0D59             ; result in A
0584+  0D59             ; 655'\0'
0585+  0D59             ; low--------high
0586+  0D59             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  0D59             scan_u16d:
0588+  0D59 F8 08 00    	enter 8
0589+  0D5C E2          	push si
0590+  0D5D D8          	push b
0591+  0D5E D9          	push c
0592+  0D5F DA          	push d
0593+  0D60 FA F9 FF    	lea d, [bp +- 7]
0594+  0D63 07 2C 0B    	call gets
0595+  0D66 07 5A 0A    	call strlen			; get string length in C
0596+  0D69 7E          	dec c
0597+  0D6A FD 4E       	mov si, d
0598+  0D6C 12          	mov a, c
0599+  0D6D FD 99       	shl a
0600+  0D6F 3B C2 0A    	mov d, table_power
0601+  0D72 59          	add d, a
0602+  0D73 38 00 00    	mov c, 0
0603+  0D76             mul_loop:
0604+  0D76 F6          	lodsb			; load ASCII to al
0605+  0D77 B9 00       	cmp al, 0
0606+  0D79 C6 8C 0D    	je mul_exit
0607+  0D7C 6F 30       	sub al, $30		; make into integer
0608+  0D7E 22 00       	mov ah, 0
0609+  0D80 2A          	mov b, [d]
0610+  0D81 AC          	mul a, b			; result in B since it fits in 16bits
0611+  0D82 11          	mov a, b
0612+  0D83 28          	mov b, c
0613+  0D84 54          	add a, b
0614+  0D85 39          	mov c, a
0615+  0D86 63 02 00    	sub d, 2
0616+  0D89 0A 76 0D    	jmp mul_loop
0617+  0D8C             mul_exit:
0618+  0D8C 12          	mov a, c
0619+  0D8D E7          	pop d
0620+  0D8E E6          	pop c
0621+  0D8F E5          	pop b
0622+  0D90 EF          	pop si
0623+  0D91 F9          	leave
0624+  0D92 09          	ret
0404   0D93             .include "ctype.asm"
0001+  0D93             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0D93             ; ctype.s
0003+  0D93             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0D93             
0005+  0D93             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  0D93             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  0D93             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  0D93             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  0D93             ;; characters are supported.
0010+  0D93             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  0D93             ;; isalnum 
0012+  0D93             ;; isalpha 
0013+  0D93             ;; islower 
0014+  0D93             ;; isupper 
0015+  0D93             ;; isdigit 
0016+  0D93             ;; isxdigit
0017+  0D93             ;; iscntrl 
0018+  0D93             ;; isgraph 
0019+  0D93             ;; isspace 
0020+  0D93             ;; isblank 
0021+  0D93             ;; isprint 
0022+  0D93             ;; ispunct 
0023+  0D93             ;; tolower 
0024+  0D93             ;; toupper
0025+  0D93             
0026+  0D93             
0027+  0D93             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  0D93             ;; IS ALPHANUMERIC
0029+  0D93             ;; sets ZF according with result
0030+  0D93             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  0D93             isalnum:
0032+  0D93 07 B0 0D    	call isalpha
0033+  0D96 C6 9C 0D    	je isalnum_exit
0034+  0D99 07 9D 0D    	call isdigit
0035+  0D9C             isalnum_exit:
0036+  0D9C 09          	ret	
0037+  0D9D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0D9D             ;; IS DIGIT
0039+  0D9D             ;; sets ZF according with result
0040+  0D9D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  0D9D             isdigit:
0042+  0D9D DB          	push al
0043+  0D9E B9 30       	cmp al, '0'
0044+  0DA0 C8 AC 0D    	jlu isdigit_false
0045+  0DA3 B9 39       	cmp al, '9'
0046+  0DA5 D1 AC 0D    	jgu isdigit_false
0047+  0DA8 87 00       	and al, 0	; set ZF
0048+  0DAA E8          	pop al
0049+  0DAB 09          	ret
0050+  0DAC             isdigit_false:
0051+  0DAC 8B 01       	or al, 1	; clear ZF
0052+  0DAE E8          	pop al
0053+  0DAF 09          	ret	
0054+  0DB0             	
0055+  0DB0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  0DB0             ;; IS ALPHA
0057+  0DB0             ;; sets ZF according with result
0058+  0DB0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  0DB0             isalpha:
0060+  0DB0 DB          	push al
0061+  0DB1 B9 5F       	cmp al, '_'
0062+  0DB3 C6 D3 0D    	je isalpha_true
0063+  0DB6 B9 2E       	cmp al, '.'
0064+  0DB8 C6 D3 0D    	je isalpha_true
0065+  0DBB B9 41       	cmp al, 'A'
0066+  0DBD C8 CF 0D    	jlu isalpha_false
0067+  0DC0 B9 7A       	cmp al, 'z'
0068+  0DC2 D1 CF 0D    	jgu isalpha_false
0069+  0DC5 B9 5A       	cmp al, 'Z'
0070+  0DC7 D0 D3 0D    	jleu isalpha_true
0071+  0DCA B9 61       	cmp al, 'a'
0072+  0DCC C9 D3 0D    	jgeu isalpha_true
0073+  0DCF             isalpha_false:
0074+  0DCF 8B 01       	or al, 1	; clear ZF
0075+  0DD1 E8          	pop al
0076+  0DD2 09          	ret
0077+  0DD3             isalpha_true:
0078+  0DD3 87 00       	and al, 0	; set ZF
0079+  0DD5 E8          	pop al
0080+  0DD6 09          	ret
0081+  0DD7             
0082+  0DD7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  0DD7             ;; IS PATH-ALPHA
0084+  0DD7             ;; sets ZF according with result
0085+  0DD7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  0DD7             ispath:
0087+  0DD7 DB          	push al
0088+  0DD8 07 9D 0D    	call isdigit
0089+  0DDB C6 05 0E    	je ispath_true
0090+  0DDE B9 5F       	cmp al, '_'
0091+  0DE0 C6 05 0E    	je ispath_true
0092+  0DE3 B9 2F       	cmp al, '/'
0093+  0DE5 C6 05 0E    	je ispath_true
0094+  0DE8 B9 2E       	cmp al, '.'
0095+  0DEA C6 05 0E    	je ispath_true
0096+  0DED B9 41       	cmp al, 'A'
0097+  0DEF C8 01 0E    	jlu ispath_false
0098+  0DF2 B9 7A       	cmp al, 'z'
0099+  0DF4 D1 01 0E    	jgu ispath_false
0100+  0DF7 B9 5A       	cmp al, 'Z'
0101+  0DF9 D0 05 0E    	jleu ispath_true
0102+  0DFC B9 61       	cmp al, 'a'
0103+  0DFE C9 05 0E    	jgeu ispath_true
0104+  0E01             ispath_false:
0105+  0E01 8B 01       	or al, 1	; clear ZF
0106+  0E03 E8          	pop al
0107+  0E04 09          	ret
0108+  0E05             ispath_true:
0109+  0E05 87 00       	and al, 0	; set ZF
0110+  0E07 E8          	pop al
0111+  0E08 09          	ret
0112+  0E09             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  0E09             ;; IS SPACE
0114+  0E09             ;; sets ZF according with result
0115+  0E09             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  0E09             isspace:
0117+  0E09 B9 20       	cmp al, $20		; ' '
0118+  0E0B C6 1F 0E    	je isspace_exit
0119+  0E0E B9 09       	cmp al, $09		; '\t'
0120+  0E10 C6 1F 0E    	je isspace_exit
0121+  0E13 B9 0A       	cmp al, $0A		; '\n'
0122+  0E15 C6 1F 0E    	je isspace_exit
0123+  0E18 B9 0D       	cmp al, $0D		; '\r'
0124+  0E1A C6 1F 0E    	je isspace_exit
0125+  0E1D B9 0B       	cmp al, $0B		; '\v'
0126+  0E1F             isspace_exit:
0127+  0E1F 09          	ret	
0128+  0E20             
0129+  0E20             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0E20             ; TO LOWER
0131+  0E20             ; input in AL
0132+  0E20             ; output in AL
0133+  0E20             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  0E20             to_lower:
0135+  0E20 B9 5A       	cmp al, 'Z'
0136+  0E22 D1 27 0E    	jgu to_lower_ret
0137+  0E25 6A 20       	add al, $20				; convert to lower case
0138+  0E27             to_lower_ret:
0139+  0E27 09          	ret
0140+  0E28             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  0E28             ; TO UPPER
0142+  0E28             ; input in AL
0143+  0E28             ; output in AL
0144+  0E28             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  0E28             to_upper:
0146+  0E28 B9 61       	cmp al, 'a'
0147+  0E2A C8 2F 0E    	jlu to_upper_ret
0148+  0E2D 6F 20       	sub al, $20			; convert to upper case
0149+  0E2F             to_upper_ret:
0150+  0E2F 09          	ret
0151+  0E30             
0405   0E30             .include "token.asm"
0001+  0E30             TOKTYP_IDENTIFIER	.equ 0
0002+  0E30             TOKTYP_KEYWORD		.equ 1
0003+  0E30             TOKTYP_DELIMITER	.equ 2
0004+  0E30             TOKTYP_STRING		.equ 3
0005+  0E30             TOKTYP_CHAR			.equ 4
0006+  0E30             TOKTYP_NUMERIC		.equ 5
0007+  0E30             TOKTYP_END			.equ 6
0008+  0E30             
0009+  0E30             TOK_NULL			.equ 0
0010+  0E30             TOK_FSLASH			.equ 1
0011+  0E30             TOK_TIMES 			.equ 2
0012+  0E30             TOK_PLUS 			.equ 3
0013+  0E30             TOK_MINUS 			.equ 4
0014+  0E30             TOK_DOT				.equ 5
0015+  0E30             TOK_SEMI			.equ 6
0016+  0E30             TOK_ANGLE			.equ 7
0017+  0E30             TOK_TILDE			.equ 8
0018+  0E30             TOK_EQUAL			.equ 9
0019+  0E30             TOK_COLON			.equ 10
0020+  0E30             TOK_COMMA			.equ 11
0021+  0E30             
0022+  0E30             TOK_END				.equ 20
0023+  0E30             
0024+  0E30             
0025+  0E30             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  0E30             ;; read a full command argment from shell input buffer
0027+  0E30             ;; argument is written into tokstr
0028+  0E30             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  0E30             get_arg:
0030+  0E30 D7          	push a
0031+  0E31 E2          	push si
0032+  0E32 E3          	push di
0033+  0E33 19 00       	mov al, 0
0034+  0E35 3D 5E 10    	mov [tokstr], al			; nullify tokstr string
0035+  0E38 14 5A 10    	mov a, [prog]
0036+  0E3B 4D          	mov si, a
0037+  0E3C FD 4F 5E 10 	mov di, tokstr
0038+  0E40             get_arg_skip_spaces:
0039+  0E40 F6          	lodsb
0040+  0E41 07 09 0E    	call isspace
0041+  0E44 C6 40 0E    	je get_arg_skip_spaces
0042+  0E47             get_arg_L0:
0043+  0E47 B9 3B       	cmp al, $3B				; check if is ';'
0044+  0E49 C6 56 0E    	je get_arg_end
0045+  0E4C B9 00       	cmp al, 0
0046+  0E4E C6 56 0E    	je get_arg_end			; check if end of input
0047+  0E51 F7          	stosb
0048+  0E52 F6          	lodsb
0049+  0E53 0A 47 0E    	jmp get_arg_L0
0050+  0E56             get_arg_end:
0051+  0E56 19 00       	mov al, 0
0052+  0E58 F7          	stosb
0053+  0E59 D5 01 00    	sub si, 1
0054+  0E5C 4E          	mov a, si
0055+  0E5D 42 5A 10    	mov [prog], a		; update pointer
0056+  0E60 F0          	pop di
0057+  0E61 EF          	pop si
0058+  0E62 E4          	pop a
0059+  0E63 09          	ret
0060+  0E64             
0061+  0E64             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  0E64             ;; read a path formation from shell input buffer
0063+  0E64             ;; path is written into tokstr
0064+  0E64             ;; /usr/bin
0065+  0E64             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  0E64             get_path:
0067+  0E64 D7          	push a
0068+  0E65 E2          	push si
0069+  0E66 E3          	push di
0070+  0E67 19 00       	mov al, 0
0071+  0E69 3D 5E 10    	mov [tokstr], al			; nullify tokstr string
0072+  0E6C 14 5A 10    	mov a, [prog]
0073+  0E6F 4D          	mov si, a
0074+  0E70 FD 4F 5E 10 	mov di, tokstr
0075+  0E74             get_path_skip_spaces:
0076+  0E74 F6          	lodsb
0077+  0E75 07 09 0E    	call isspace
0078+  0E78 C6 74 0E    	je get_path_skip_spaces
0079+  0E7B             get_path_is_pathchar:
0080+  0E7B F7          	stosb
0081+  0E7C F6          	lodsb
0082+  0E7D 07 93 0D    	call isalnum			;check if is alphanumeric
0083+  0E80 C6 7B 0E    	je get_path_is_pathchar
0084+  0E83 B9 2F       	cmp al, '/'				; check if is '/'
0085+  0E85 C6 7B 0E    	je get_path_is_pathchar
0086+  0E88 19 00       	mov al, 0
0087+  0E8A F7          	stosb
0088+  0E8B D5 01 00    	sub si, 1
0089+  0E8E 4E          	mov a, si
0090+  0E8F 42 5A 10    	mov [prog], a		; update pointer
0091+  0E92             get_path_end:
0092+  0E92 F0          	pop di
0093+  0E93 EF          	pop si
0094+  0E94 E4          	pop a
0095+  0E95 09          	ret
0096+  0E96             
0097+  0E96             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  0E96             ;; read a line
0099+  0E96             ;; line is written into tokstr
0100+  0E96             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  0E96             get_line:
0102+  0E96 D7          	push a
0103+  0E97 E2          	push si
0104+  0E98 E3          	push di
0105+  0E99 19 00       	mov al, 0
0106+  0E9B 3D 5E 10    	mov [tokstr], al			; nullify tokstr string
0107+  0E9E 14 5A 10    	mov a, [prog]
0108+  0EA1 4D          	mov si, a
0109+  0EA2 FD 4F 5E 10 	mov di, tokstr
0110+  0EA6             get_line_L0:
0111+  0EA6 F6          	lodsb
0112+  0EA7 B9 0A       	cmp al, $0A		; check for new line
0113+  0EA9 C6 B0 0E    	je get_line_exit
0114+  0EAC F7          	stosb
0115+  0EAD 0A A6 0E    	jmp get_line_L0
0116+  0EB0             get_line_exit:
0117+  0EB0 19 00       	mov al, 0
0118+  0EB2 F7          	stosb
0119+  0EB3 4E          	mov a, si
0120+  0EB4 42 5A 10    	mov [prog], a		; update pointer
0121+  0EB7 F0          	pop di
0122+  0EB8 EF          	pop si
0123+  0EB9 E4          	pop a
0124+  0EBA 09          	ret
0125+  0EBB             
0126+  0EBB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  0EBB             ;; token parser
0128+  0EBB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  0EBB             get_token:
0130+  0EBB D7          	push a
0131+  0EBC DA          	push d
0132+  0EBD E2          	push si
0133+  0EBE E3          	push di
0134+  0EBF 19 00       	mov al, 0
0135+  0EC1 3D 5E 10    	mov [tokstr], al			; nullify tokstr string
0136+  0EC4 19 00       	mov al, TOK_NULL
0137+  0EC6 3D 5D 10    	mov [tok], al				; nullify token
0138+  0EC9 14 5A 10    	mov a, [prog]
0139+  0ECC 4D          	mov si, a
0140+  0ECD FD 4F 5E 10 	mov di, tokstr
0141+  0ED1             get_tok_skip_spaces:
0142+  0ED1 F6          	lodsb
0143+  0ED2 07 09 0E    	call isspace
0144+  0ED5 C6 D1 0E    	je get_tok_skip_spaces
0145+  0ED8 B9 00       	cmp al, 0			; check for end of input (NULL)
0146+  0EDA C6 BF 0F    	je get_token_end
0147+  0EDD B9 23       	cmp al, '#'			; comments!
0148+  0EDF C6 ED 0F    	je get_tok_comment
0149+  0EE2 07 93 0D    	call isalnum
0150+  0EE5 C6 CC 0F    	jz is_alphanumeric
0151+  0EE8             ; other token types
0152+  0EE8             get_token_slash:
0153+  0EE8 B9 2F       	cmp al, '/'				; check if '/'
0154+  0EEA C7 02 0F    	jne get_token_minus
0155+  0EED F7          	stosb					; store '/' into token string
0156+  0EEE 19 00       	mov al, 0
0157+  0EF0 F7          	stosb					; terminate token string
0158+  0EF1 19 01       	mov al, TOK_FSLASH
0159+  0EF3 3D 5D 10    	mov [tok], al			
0160+  0EF6 19 02       	mov al, TOKTYP_DELIMITER
0161+  0EF8 3D 5C 10    	mov [toktyp], al
0162+  0EFB 4E          	mov a, si
0163+  0EFC 42 5A 10    	mov [prog], a		; update pointer
0164+  0EFF 0A E8 0F    	jmp get_token_return
0165+  0F02             get_token_minus:
0166+  0F02 B9 2D       	cmp al, '-'				; check if '-'
0167+  0F04 C7 1C 0F    	jne get_token_comma
0168+  0F07 F7          	stosb					; store '-' into token string
0169+  0F08 19 00       	mov al, 0
0170+  0F0A F7          	stosb					; terminate token string
0171+  0F0B 19 04       	mov al, TOK_MINUS
0172+  0F0D 3D 5D 10    	mov [tok], al			
0173+  0F10 19 02       	mov al, TOKTYP_DELIMITER
0174+  0F12 3D 5C 10    	mov [toktyp], al
0175+  0F15 4E          	mov a, si
0176+  0F16 42 5A 10    	mov [prog], a		; update pointer
0177+  0F19 0A E8 0F    	jmp get_token_return
0178+  0F1C             get_token_comma:
0179+  0F1C B9 2C       	cmp al, ','				; check if ','
0180+  0F1E C7 36 0F    	jne get_token_semi
0181+  0F21 F7          	stosb					; store ',' into token string
0182+  0F22 19 00       	mov al, 0
0183+  0F24 F7          	stosb					; terminate token string
0184+  0F25 19 0B       	mov al, TOK_COMMA
0185+  0F27 3D 5D 10    	mov [tok], al			
0186+  0F2A 19 02       	mov al, TOKTYP_DELIMITER
0187+  0F2C 3D 5C 10    	mov [toktyp], al
0188+  0F2F 4E          	mov a, si
0189+  0F30 42 5A 10    	mov [prog], a		; update pointer
0190+  0F33 0A E8 0F    	jmp get_token_return
0191+  0F36             get_token_semi:
0192+  0F36 B9 3B       	cmp al, $3B				; check if ';'
0193+  0F38 C7 50 0F    	jne get_token_colon
0194+  0F3B F7          	stosb					; store ';' into token string
0195+  0F3C 19 00       	mov al, 0
0196+  0F3E F7          	stosb					; terminate token string
0197+  0F3F 19 06       	mov al, TOK_SEMI
0198+  0F41 3D 5D 10    	mov [tok], al			
0199+  0F44 19 02       	mov al, TOKTYP_DELIMITER
0200+  0F46 3D 5C 10    	mov [toktyp], al
0201+  0F49 4E          	mov a, si
0202+  0F4A 42 5A 10    	mov [prog], a		; update pointer
0203+  0F4D 0A E8 0F    	jmp get_token_return
0204+  0F50             get_token_colon:
0205+  0F50 B9 3A       	cmp al, $3A				; check if ':'
0206+  0F52 C7 6A 0F    	jne get_token_angle
0207+  0F55 F7          	stosb					; store ':' into token string
0208+  0F56 19 00       	mov al, 0
0209+  0F58 F7          	stosb					; terminate token string
0210+  0F59 19 0A       	mov al, TOK_COLON
0211+  0F5B 3D 5D 10    	mov [tok], al			
0212+  0F5E 19 02       	mov al, TOKTYP_DELIMITER
0213+  0F60 3D 5C 10    	mov [toktyp], al
0214+  0F63 4E          	mov a, si
0215+  0F64 42 5A 10    	mov [prog], a		; update pointer
0216+  0F67 0A E8 0F    	jmp get_token_return
0217+  0F6A             get_token_angle:
0218+  0F6A B9 3E       	cmp al, $3E				; check if '>'
0219+  0F6C C7 84 0F    	jne get_token_tilde
0220+  0F6F F7          	stosb					; store '>' into token string
0221+  0F70 19 00       	mov al, 0
0222+  0F72 F7          	stosb					; terminate token string
0223+  0F73 19 07       	mov al, TOK_ANGLE
0224+  0F75 3D 5D 10    	mov [tok], al			
0225+  0F78 19 02       	mov al, TOKTYP_DELIMITER
0226+  0F7A 3D 5C 10    	mov [toktyp], al
0227+  0F7D 4E          	mov a, si
0228+  0F7E 42 5A 10    	mov [prog], a		; update pointer
0229+  0F81 0A E8 0F    	jmp get_token_return
0230+  0F84             get_token_tilde:
0231+  0F84 B9 7E       	cmp al, '~'				; check if '~'
0232+  0F86 C7 9E 0F    	jne get_token_equal
0233+  0F89 F7          	stosb					; store '~' into token string
0234+  0F8A 19 00       	mov al, 0
0235+  0F8C F7          	stosb					; terminate token string
0236+  0F8D 19 08       	mov al, TOK_TILDE
0237+  0F8F 3D 5D 10    	mov [tok], al			
0238+  0F92 19 02       	mov al, TOKTYP_DELIMITER
0239+  0F94 3D 5C 10    	mov [toktyp], al
0240+  0F97 4E          	mov a, si
0241+  0F98 42 5A 10    	mov [prog], a		; update pointer
0242+  0F9B 0A E8 0F    	jmp get_token_return
0243+  0F9E             get_token_equal:
0244+  0F9E B9 3D       	cmp al, '='				; check if '='
0245+  0FA0 C7 B8 0F    	jne get_token_skip
0246+  0FA3 F7          	stosb					; store '=' into token string
0247+  0FA4 19 00       	mov al, 0
0248+  0FA6 F7          	stosb					; terminate token string
0249+  0FA7 19 09       	mov al, TOK_EQUAL
0250+  0FA9 3D 5D 10    	mov [tok], al			
0251+  0FAC 19 02       	mov al, TOKTYP_DELIMITER
0252+  0FAE 3D 5C 10    	mov [toktyp], al
0253+  0FB1 4E          	mov a, si
0254+  0FB2 42 5A 10    	mov [prog], a		; update pointer
0255+  0FB5 0A E8 0F    	jmp get_token_return
0256+  0FB8             get_token_skip:
0257+  0FB8 4E          	mov a, si
0258+  0FB9 42 5A 10    	mov [prog], a		; update pointer
0259+  0FBC 0A E8 0F    	jmp get_token_return
0260+  0FBF             get_token_end:				; end of file token
0261+  0FBF 19 14       	mov al, TOK_END
0262+  0FC1 3D 5D 10    	mov [tok], al
0263+  0FC4 19 06       	mov al, TOKTYP_END
0264+  0FC6 3D 5C 10    	mov [toktyp], al
0265+  0FC9 0A E8 0F    	jmp get_token_return
0266+  0FCC             is_alphanumeric:
0267+  0FCC F7          	stosb
0268+  0FCD F6          	lodsb
0269+  0FCE 07 93 0D    	call isalnum			;check if is alphanumeric
0270+  0FD1 C6 CC 0F    	jz is_alphanumeric
0271+  0FD4 B9 2E       	cmp al, $2E				; check if is '.'
0272+  0FD6 C6 CC 0F    	je is_alphanumeric
0273+  0FD9 19 00       	mov al, 0
0274+  0FDB F7          	stosb
0275+  0FDC 19 00       	mov al, TOKTYP_IDENTIFIER
0276+  0FDE 3D 5C 10    	mov [toktyp], al
0277+  0FE1 D5 01 00    	sub si, 1
0278+  0FE4 4E          	mov a, si
0279+  0FE5 42 5A 10    	mov [prog], a		; update pointer
0280+  0FE8             get_token_return:
0281+  0FE8 F0          	pop di
0282+  0FE9 EF          	pop si
0283+  0FEA E7          	pop d
0284+  0FEB E4          	pop a
0285+  0FEC 09          	ret
0286+  0FED             get_tok_comment:
0287+  0FED F6          	lodsb
0288+  0FEE B9 0A       	cmp al, $0A			; new line
0289+  0FF0 C7 ED 0F    	jne get_tok_comment
0290+  0FF3 0A D1 0E    	jmp get_tok_skip_spaces
0291+  0FF6             
0292+  0FF6             
0293+  0FF6             get_number:
0294+  0FF6 D7          	push a
0295+  0FF7 DA          	push d
0296+  0FF8 E2          	push si
0297+  0FF9 E3          	push di
0298+  0FFA 19 00       	mov al, 0
0299+  0FFC 3D 5E 10    	mov [tokstr], al			; nullify tokstr string
0300+  0FFF 19 00       	mov al, TOK_NULL
0301+  1001 3D 5D 10    	mov [tok], al				; nullify token
0302+  1004 14 5A 10    	mov a, [prog]
0303+  1007 4D          	mov si, a
0304+  1008 FD 4F 5E 10 	mov di, tokstr
0305+  100C             get_number_skip_spaces:
0306+  100C F6          	lodsb
0307+  100D 07 09 0E    	call isspace
0308+  1010 C6 0C 10    	je get_number_skip_spaces
0309+  1013 B9 00       	cmp al, 0			; check for end of input (NULL)
0310+  1015 C7 25 10    	jne get_number_L0
0311+  1018 19 14       	mov al, TOK_END
0312+  101A 3D 5D 10    	mov [tok], al
0313+  101D 19 06       	mov al, TOKTYP_END
0314+  101F 3D 5C 10    	mov [toktyp], al
0315+  1022 0A 3C 10    	jmp get_number_return
0316+  1025             get_number_L0:
0317+  1025 F7          	stosb
0318+  1026 F6          	lodsb
0319+  1027 07 9D 0D    	call isdigit			;check if is numeric
0320+  102A C6 25 10    	jz get_number_L0
0321+  102D 19 00       	mov al, 0
0322+  102F F7          	stosb
0323+  1030 19 05       	mov al, TOKTYP_NUMERIC
0324+  1032 3D 5C 10    	mov [toktyp], al
0325+  1035 D5 01 00    	sub si, 1
0326+  1038 4E          	mov a, si
0327+  1039 42 5A 10    	mov [prog], a		; update pointer
0328+  103C             get_number_return:
0329+  103C F0          	pop di
0330+  103D EF          	pop si
0331+  103E E7          	pop d
0332+  103F E4          	pop a
0333+  1040 09          	ret
0334+  1041             
0335+  1041             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  1041             ;; PUT BACK TOKEN
0337+  1041             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
0338+  1041             putback:
0339+  1041 D7          	push a
0340+  1042 E2          	push si
0341+  1043 FD 4D 5E 10 	mov si, tokstr	
0342+  1047             putback_loop:
0343+  1047 F6          	lodsb
0344+  1048 B9 00       	cmp al, 0
0345+  104A C6 57 10    	je putback_end
0346+  104D 14 5A 10    	mov a, [prog]
0347+  1050 7D          	dec a
0348+  1051 42 5A 10    	mov [prog], a			; update pointer
0349+  1054 0A 47 10    	jmp putback_loop
0350+  1057             putback_end:
0351+  1057 EF          	pop si
0352+  1058 E4          	pop a
0353+  1059 09          	ret
0354+  105A             
0355+  105A             
0356+  105A             
0357+  105A             
0358+  105A 00 00       prog:		.dw 0			; pointer to current position in buffer
0359+  105C             
0360+  105C 00          toktyp: 	.db 0			; token type symbol
0361+  105D 00          tok:		.db 0			; current token symbol
0362+  105E 00 00 00 00 tokstr:		.fill 256, 0	; token as a string
0362+  1062 00 00 00 00 
0362+  1066 00 00 00 00 
0362+  106A 00 00 00 00 
0362+  106E 00 00 00 00 
0362+  1072 00 00 00 00 
0362+  1076 00 00 00 00 
0362+  107A 00 00 00 00 
0362+  107E 00 00 00 00 
0362+  1082 00 00 00 00 
0362+  1086 00 00 00 00 
0362+  108A 00 00 00 00 
0362+  108E 00 00 00 00 
0362+  1092 00 00 00 00 
0362+  1096 00 00 00 00 
0362+  109A 00 00 00 00 
0362+  109E 00 00 00 00 
0362+  10A2 00 00 00 00 
0362+  10A6 00 00 00 00 
0362+  10AA 00 00 00 00 
0362+  10AE 00 00 00 00 
0362+  10B2 00 00 00 00 
0362+  10B6 00 00 00 00 
0362+  10BA 00 00 00 00 
0362+  10BE 00 00 00 00 
0362+  10C2 00 00 00 00 
0362+  10C6 00 00 00 00 
0362+  10CA 00 00 00 00 
0362+  10CE 00 00 00 00 
0362+  10D2 00 00 00 00 
0362+  10D6 00 00 00 00 
0362+  10DA 00 00 00 00 
0362+  10DE 00 00 00 00 
0362+  10E2 00 00 00 00 
0362+  10E6 00 00 00 00 
0362+  10EA 00 00 00 00 
0362+  10EE 00 00 00 00 
0362+  10F2 00 00 00 00 
0362+  10F6 00 00 00 00 
0362+  10FA 00 00 00 00 
0362+  10FE 00 00 00 00 
0362+  1102 00 00 00 00 
0362+  1106 00 00 00 00 
0362+  110A 00 00 00 00 
0362+  110E 00 00 00 00 
0362+  1112 00 00 00 00 
0362+  1116 00 00 00 00 
0362+  111A 00 00 00 00 
0362+  111E 00 00 00 00 
0362+  1122 00 00 00 00 
0362+  1126 00 00 00 00 
0362+  112A 00 00 00 00 
0362+  112E 00 00 00 00 
0362+  1132 00 00 00 00 
0362+  1136 00 00 00 00 
0362+  113A 00 00 00 00 
0362+  113E 00 00 00 00 
0362+  1142 00 00 00 00 
0362+  1146 00 00 00 00 
0362+  114A 00 00 00 00 
0362+  114E 00 00 00 00 
0362+  1152 00 00 00 00 
0362+  1156 00 00 00 00 
0362+  115A 00 00 00 00 
0406   115E             
0407   115E 00 00 00 00 temp_data1:        .fill 256, 0
0407   1162 00 00 00 00 
0407   1166 00 00 00 00 
0407   116A 00 00 00 00 
0407   116E 00 00 00 00 
0407   1172 00 00 00 00 
0407   1176 00 00 00 00 
0407   117A 00 00 00 00 
0407   117E 00 00 00 00 
0407   1182 00 00 00 00 
0407   1186 00 00 00 00 
0407   118A 00 00 00 00 
0407   118E 00 00 00 00 
0407   1192 00 00 00 00 
0407   1196 00 00 00 00 
0407   119A 00 00 00 00 
0407   119E 00 00 00 00 
0407   11A2 00 00 00 00 
0407   11A6 00 00 00 00 
0407   11AA 00 00 00 00 
0407   11AE 00 00 00 00 
0407   11B2 00 00 00 00 
0407   11B6 00 00 00 00 
0407   11BA 00 00 00 00 
0407   11BE 00 00 00 00 
0407   11C2 00 00 00 00 
0407   11C6 00 00 00 00 
0407   11CA 00 00 00 00 
0407   11CE 00 00 00 00 
0407   11D2 00 00 00 00 
0407   11D6 00 00 00 00 
0407   11DA 00 00 00 00 
0407   11DE 00 00 00 00 
0407   11E2 00 00 00 00 
0407   11E6 00 00 00 00 
0407   11EA 00 00 00 00 
0407   11EE 00 00 00 00 
0407   11F2 00 00 00 00 
0407   11F6 00 00 00 00 
0407   11FA 00 00 00 00 
0407   11FE 00 00 00 00 
0407   1202 00 00 00 00 
0407   1206 00 00 00 00 
0407   120A 00 00 00 00 
0407   120E 00 00 00 00 
0407   1212 00 00 00 00 
0407   1216 00 00 00 00 
0407   121A 00 00 00 00 
0407   121E 00 00 00 00 
0407   1222 00 00 00 00 
0407   1226 00 00 00 00 
0407   122A 00 00 00 00 
0407   122E 00 00 00 00 
0407   1232 00 00 00 00 
0407   1236 00 00 00 00 
0407   123A 00 00 00 00 
0407   123E 00 00 00 00 
0407   1242 00 00 00 00 
0407   1246 00 00 00 00 
0407   124A 00 00 00 00 
0407   124E 00 00 00 00 
0407   1252 00 00 00 00 
0407   1256 00 00 00 00 
0407   125A 00 00 00 00 
0408   125E 00 00 00 00 temp_data:        .fill 512, 0
0408   1262 00 00 00 00 
0408   1266 00 00 00 00 
0408   126A 00 00 00 00 
0408   126E 00 00 00 00 
0408   1272 00 00 00 00 
0408   1276 00 00 00 00 
0408   127A 00 00 00 00 
0408   127E 00 00 00 00 
0408   1282 00 00 00 00 
0408   1286 00 00 00 00 
0408   128A 00 00 00 00 
0408   128E 00 00 00 00 
0408   1292 00 00 00 00 
0408   1296 00 00 00 00 
0408   129A 00 00 00 00 
0408   129E 00 00 00 00 
0408   12A2 00 00 00 00 
0408   12A6 00 00 00 00 
0408   12AA 00 00 00 00 
0408   12AE 00 00 00 00 
0408   12B2 00 00 00 00 
0408   12B6 00 00 00 00 
0408   12BA 00 00 00 00 
0408   12BE 00 00 00 00 
0408   12C2 00 00 00 00 
0408   12C6 00 00 00 00 
0408   12CA 00 00 00 00 
0408   12CE 00 00 00 00 
0408   12D2 00 00 00 00 
0408   12D6 00 00 00 00 
0408   12DA 00 00 00 00 
0408   12DE 00 00 00 00 
0408   12E2 00 00 00 00 
0408   12E6 00 00 00 00 
0408   12EA 00 00 00 00 
0408   12EE 00 00 00 00 
0408   12F2 00 00 00 00 
0408   12F6 00 00 00 00 
0408   12FA 00 00 00 00 
0408   12FE 00 00 00 00 
0408   1302 00 00 00 00 
0408   1306 00 00 00 00 
0408   130A 00 00 00 00 
0408   130E 00 00 00 00 
0408   1312 00 00 00 00 
0408   1316 00 00 00 00 
0408   131A 00 00 00 00 
0408   131E 00 00 00 00 
0408   1322 00 00 00 00 
0408   1326 00 00 00 00 
0408   132A 00 00 00 00 
0408   132E 00 00 00 00 
0408   1332 00 00 00 00 
0408   1336 00 00 00 00 
0408   133A 00 00 00 00 
0408   133E 00 00 00 00 
0408   1342 00 00 00 00 
0408   1346 00 00 00 00 
0408   134A 00 00 00 00 
0408   134E 00 00 00 00 
0408   1352 00 00 00 00 
0408   1356 00 00 00 00 
0408   135A 00 00 00 00 
0408   135E 00 00 00 00 
0408   1362 00 00 00 00 
0408   1366 00 00 00 00 
0408   136A 00 00 00 00 
0408   136E 00 00 00 00 
0408   1372 00 00 00 00 
0408   1376 00 00 00 00 
0408   137A 00 00 00 00 
0408   137E 00 00 00 00 
0408   1382 00 00 00 00 
0408   1386 00 00 00 00 
0408   138A 00 00 00 00 
0408   138E 00 00 00 00 
0408   1392 00 00 00 00 
0408   1396 00 00 00 00 
0408   139A 00 00 00 00 
0408   139E 00 00 00 00 
0408   13A2 00 00 00 00 
0408   13A6 00 00 00 00 
0408   13AA 00 00 00 00 
0408   13AE 00 00 00 00 
0408   13B2 00 00 00 00 
0408   13B6 00 00 00 00 
0408   13BA 00 00 00 00 
0408   13BE 00 00 00 00 
0408   13C2 00 00 00 00 
0408   13C6 00 00 00 00 
0408   13CA 00 00 00 00 
0408   13CE 00 00 00 00 
0408   13D2 00 00 00 00 
0408   13D6 00 00 00 00 
0408   13DA 00 00 00 00 
0408   13DE 00 00 00 00 
0408   13E2 00 00 00 00 
0408   13E6 00 00 00 00 
0408   13EA 00 00 00 00 
0408   13EE 00 00 00 00 
0408   13F2 00 00 00 00 
0408   13F6 00 00 00 00 
0408   13FA 00 00 00 00 
0408   13FE 00 00 00 00 
0408   1402 00 00 00 00 
0408   1406 00 00 00 00 
0408   140A 00 00 00 00 
0408   140E 00 00 00 00 
0408   1412 00 00 00 00 
0408   1416 00 00 00 00 
0408   141A 00 00 00 00 
0408   141E 00 00 00 00 
0408   1422 00 00 00 00 
0408   1426 00 00 00 00 
0408   142A 00 00 00 00 
0408   142E 00 00 00 00 
0408   1432 00 00 00 00 
0408   1436 00 00 00 00 
0408   143A 00 00 00 00 
0408   143E 00 00 00 00 
0408   1442 00 00 00 00 
0408   1446 00 00 00 00 
0408   144A 00 00 00 00 
0408   144E 00 00 00 00 
0408   1452 00 00 00 00 
0408   1456 00 00 00 00 
0408   145A 00 00 00 00 
0409   145E             shell_transient_area:  ; shell transient data area
0410   145E             
0411   145E             .end
tasm: Number of errors = 0
