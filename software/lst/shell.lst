0001   0000             .include "kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0002   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0003   0000             ; SHELL
0004   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0005   0000             
0006   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007   0000             ; SYSTEM CONSTANTS / EQUATIONS
0008   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0009   0000             STACK_BEGIN:  .equ $F7FF  ; beginning of stack
0010   0000             
0011   0400             .org PROC_TEXT_ORG      ; origin at 1024
0012   0400             
0013   0400             shell_main:  
0014   0400 FD 49 FF F7   mov bp, STACK_BEGIN
0015   0404 FD 47 FF F7   mov sp, STACK_BEGIN
0016   0408             
0017   0408 3B B3 08      mov d, s_prompt_config
0018   040B 07 63 0D      call puts
0019   040E             
0020   040E             ; open config file
0021   040E             ; example: PATH=/usr/bin;
0022   040E             ; read PATH config entry
0023   040E 3B AD 08      mov d, s_prompt_PATH
0024   0411 07 63 0D      call puts
0025   0414 3B 6C 08      mov d, s_etc_config        ; '/etc/sh.conf'
0026   0417 FD 4D 82 08   mov si, s_PATH          ; config entry name is "PATH"
0027   041B FD 4F DF 07   mov di, PATH          ; config value destination is the var that holds the PATH variable
0028   041F 07 E9 04      call read_config  
0029   0422 3B DF 07      mov d, PATH
0030   0425 07 63 0D      call puts
0031   0428             ; open config file
0032   0428             ; home = /usr/home/guest;
0033   0428             ; read home directory config entry
0034   0428 3B 9C 08      mov d, s_prompt_homedir
0035   042B 07 63 0D      call puts
0036   042E 3B 6C 08      mov d, s_etc_config        ; '/etc/sh.conf'
0037   0431 FD 4D 79 08   mov si, s_home          ; config entry name is "home"
0038   0435 FD 4F DF 06   mov di, homedir          ; config value destination is the var that holds the home directory path
0039   0439 07 E9 04      call read_config  
0040   043C 3B DF 06      mov d, homedir
0041   043F 07 63 0D      call puts
0042   0442             ; open config file
0043   0442             ; read manpage directory path
0044   0442 3B 87 08      mov d, s_prompt_manpages
0045   0445 07 63 0D      call puts
0046   0448 3B 6C 08      mov d, s_etc_config        ; '/etc/sh.conf'
0047   044B FD 4D 7E 08   mov si, s_man          ; config entry name is "man"
0048   044F FD 4F 5F 07   mov di, manpath        ; config value destination is the var that holds the man pages directory path
0049   0453 07 E9 04      call read_config
0050   0456 3B 5F 07      mov d, manpath
0051   0459 07 63 0D      call puts
0052   045C             
0053   045C 10 5F 08      mov a, s_etc_profile
0054   045F 42 5E 11      mov [prog], a
0055   0462 07 32 05      call cmd_ssh
0056   0465             
0057   0465             shell_L0:
0058   0465 3B 08 09      mov d, s_sol1
0059   0468 07 63 0D      call puts
0060   046B 19 12         mov al, 18
0061   046D 05 04         syscall sys_fileio        ; print current path
0062   046F 3B 02 09      mov d, s_hash
0063   0472 07 63 0D      call puts
0064   0475 3B 13 09      mov d, shell_input_buff
0065   0478 13            mov a, d
0066   0479 42 5E 11      mov [prog], a      ; reset tokenizer buffer pointer
0067   047C 07 30 0C      call gets            ; get command
0068   047F 07 85 04      call cmd_parser
0069   0482 0A 65 04      jmp shell_L0
0070   0485             
0071   0485             cmd_parser:
0072   0485 07 BF 0F      call get_token          ; get command into tokstr
0073   0488 FD 4F 9A 06   mov di, commands
0074   048C FD 10         cla
0075   048E 42 15 0B      mov [parser_index], a    ; reset commands index
0076   0491             parser_L0:
0077   0491 FD 4D 62 11   mov si, tokstr
0078   0495 07 6E 0B      call strcmp
0079   0498 C6 C0 04      je parser_cmd_equal
0080   049B             parser_L0_L0:
0081   049B FC 00 00      lea d, [di + 0]
0082   049E BD 00         cmp byte[d], 0
0083   04A0 C6 A9 04      je parser_L0_L0_exit      ; run through the keyword until finding NULL
0084   04A3 D4 01 00      add di, 1
0085   04A6 0A 9B 04      jmp parser_L0_L0
0086   04A9             parser_L0_L0_exit:
0087   04A9 D4 01 00      add di, 1        ; then skip NULL byte at the end 
0088   04AC 14 15 0B      mov a, [parser_index]
0089   04AF 53 02 00      add a, 2
0090   04B2 42 15 0B      mov [parser_index], a      ; increase commands table index
0091   04B5 FC 00 00      lea d, [di + 0]
0092   04B8 BD 00         cmp byte[d], 0
0093   04BA C6 DF 04      je parser_cmd_not_found
0094   04BD 0A 91 04      jmp parser_L0
0095   04C0             parser_cmd_equal:
0096   04C0 10 00 0D      mov a, $0D00
0097   04C3 05 03         syscall sys_io        ; print carriage return
0098   04C5 14 15 0B      mov a, [parser_index]      ; get the keyword pointer
0099   04C8 FD 07 CD 06   call [a + keyword_ptrs]    ; execute command
0100   04CC 10 00 0D      mov a, $0D00
0101   04CF 05 03         syscall sys_io        ; print carriage return
0102   04D1             parser_retry:
0103   04D1 07 BF 0F      call get_token
0104   04D4 BC 61 11 06   cmp byte[tok], TOK_SEMI
0105   04D8 C6 85 04      je cmd_parser
0106   04DB 07 45 11      call putback
0107   04DE 09            ret
0108   04DF             parser_cmd_not_found:
0109   04DF 07 45 11      call putback
0110   04E2 07 A9 05      call cmd_exec      ; execute as file/program
0111   04E5 0A D1 04      jmp parser_retry    ; check for more commands
0112   04E8 09            ret
0113   04E9             
0114   04E9             ; inputs:
0115   04E9             ; D = filename ptr
0116   04E9             ; SI = entry name ptr
0117   04E9             ; DI = output value string ptr
0118   04E9             read_config:
0119   04E9 E3            push di
0120   04EA E2            push si
0121   04EB FD 4F 62 15   mov di, shell_transient_area
0122   04EF 19 14         mov al, 20
0123   04F1 05 04         syscall sys_fileio        ; read entire config file
0124   04F3 10 62 15      mov a, shell_transient_area
0125   04F6 42 5E 11      mov [prog], a
0126   04F9 EF            pop si
0127   04FA             read_config_L0:
0128   04FA 07 BF 0F      call get_token
0129   04FD BC 61 11 14   cmp byte[tok], TOK_END
0130   0501 C6 2D 05      je read_config_EOF
0131   0504 FD 4F 62 11   mov di, tokstr
0132   0508 07 6E 0B      call strcmp
0133   050B C6 1B 05      je read_config_found_entry
0134   050E             read_config_L0_L0:
0135   050E 07 BF 0F      call get_token
0136   0511 BC 61 11 06   cmp byte[tok], TOK_SEMI
0137   0515 C6 FA 04      je read_config_L0
0138   0518 0A 0E 05      jmp read_config_L0_L0
0139   051B             read_config_found_entry:
0140   051B 07 BF 0F      call get_token      ; bypass '=' sign
0141   051E F0            pop di
0142   051F 14 5E 11      mov a, [prog]
0143   0522 4D            mov si, a
0144   0523             read_conf_L1:
0145   0523 F6            lodsb
0146   0524 B9 3B         cmp al, $3B        ; ';'
0147   0526 C6 2E 05      je read_config_EOF_2
0148   0529 F7            stosb
0149   052A 0A 23 05      jmp read_conf_L1
0150   052D             read_config_EOF:
0151   052D F0            pop di
0152   052E             read_config_EOF_2:
0153   052E 19 00         mov al, 0
0154   0530 F7            stosb          ; terminate value with NULL
0155   0531 09            ret
0156   0532             
0157   0532             ; ssh = sol shell
0158   0532             cmd_ssh:
0159   0532 07 68 0F      call get_path
0160   0535 3B 62 11      mov d, tokstr
0161   0538 FD 4F 62 15   mov di, shell_transient_area
0162   053C 19 14         mov al, 20
0163   053E 05 04         syscall sys_fileio        ; read textfile 
0164   0540               
0165   0540 3B 62 15      mov d, shell_transient_area
0166   0543 13            mov a, d
0167   0544 42 5E 11      mov [prog], a      ; reset tokenizer buffer pointer
0168   0547 07 85 04      call cmd_parser
0169   054A             
0170   054A 07 10 0D      call printnl
0171   054D 09            ret
0172   054E               
0173   054E             ; ************************************************************
0174   054E             ; GET HEX FILE
0175   054E             ; di = destination address
0176   054E             ; return length in bytes in C
0177   054E             ; ************************************************************
0178   054E             ;load_hex:
0179   054E             ;  push bp
0180   054E             ;  mov bp, sp
0181   054E             ;  push a
0182   054E             ;  push b
0183   054E             ;  push d
0184   054E             ;  push si
0185   054E             ;  push di
0186   054E             ;  sub sp, $6000        ; string data block
0187   054E             ;  mov c, 0
0188   054E             ;  
0189   054E             ;  mov a, sp
0190   054E             ;  inc a
0191   054E             ;  mov d, a        ; start of string data block
0192   054E             ;  call gets        ; get program string
0193   054E             ;  mov si, a
0194   054E             ;load_hex_loop:
0195   054E             ;  lodsb          ; load from [SI] to AL
0196   054E             ;  cmp al, 0        ; check if ASCII 0
0197   054E             ;  jz load_hex_ret
0198   054E             ;  mov bh, al
0199   054E             ;  lodsb
0200   054E             ;  mov bl, al
0201   054E             ;  call atoi        ; convert ASCII byte in B to int (to AL)
0202   054E             ;  stosb          ; store AL to [DI]
0203   054E             ;  inc c
0204   054E             ;  jmp load_hex_loop
0205   054E             ;load_hex_ret:
0206   054E             ;  add sp, $6000
0207   054E             ;  pop di
0208   054E             ;  pop si
0209   054E             ;  pop d
0210   054E             ;  pop b
0211   054E             ;  pop a
0212   054E             ;  mov sp, bp
0213   054E             ;  pop bp
0214   054E             ;  ret
0215   054E             
0216   054E             cmd_setdate:
0217   054E 19 01         mov al, 1      ; set datetime
0218   0550 05 07         syscall sys_datetime  
0219   0552 09            ret  
0220   0553               
0221   0553             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0222   0553             ;; FILE SYSTEM DATA
0223   0553             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0224   0553             ; infor for : IDE SERVICES INTERRUPT
0225   0553             ; al = option
0226   0553             ; IDE read/write sector
0227   0553             ; 512 bytes
0228   0553             ; user buffer pointer in D
0229   0553             ; AH = number of sectors
0230   0553             ; CB = LBA bytes 3..0  
0231   0553             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0232   0553             ;; FILE SYSTEM DATA STRUCTURE
0233   0553             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0234   0553             ; for a directory we have the header first, followed by metadata
0235   0553             ; header 1 sector (512 bytes)
0236   0553             ; metadata 1 sector (512 bytes)
0237   0553             ; HEADER ENTRIES:
0238   0553             ; filename (64)
0239   0553             ; parent dir LBA (2) -  to be used for faster backwards navigation...
0240   0553             ;
0241   0553             ; metadata entries:
0242   0553             ; filename (24)
0243   0553             ; attributes (1)
0244   0553             ; LBA (2)
0245   0553             ; size (2)
0246   0553             ; day (1)
0247   0553             ; month (1)
0248   0553             ; year (1)
0249   0553             ; packet size = 32 bytes
0250   0553             ;
0251   0553             ; first directory on disk is the root directory '/'
0252   0553             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0253   0553             ;; FILE SYSTEM DISK FORMATTING
0254   0553             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0255   0553             ; writes FST_TOTAL_SECTORS + FS_NBR_FILES disk sectors  with 0's
0256   0553             ; this is the file system table formating
0257   0553             cmd_mkfs:
0258   0553 19 00         mov al, 0
0259   0555 05 04         syscall sys_fileio
0260   0557 09            ret
0261   0558             
0262   0558             
0263   0558             
0264   0558             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0265   0558             ;; parse path
0266   0558             ;; 
0267   0558             ;;
0268   0558             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0269   0558             
0270   0558             
0271   0558             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272   0558             ;; CD
0273   0558             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0274   0558             ; search for given directory inside current dir
0275   0558             ; if found, read its LBA, and switch directories
0276   0558             ; example:  cd /usr/bin; ls
0277   0558             ;       cd /usr/bin;
0278   0558             ;      cd /usr/bin
0279   0558             cmd_cd:
0280   0558 07 BF 0F      call get_token
0281   055B 1D 61 11      mov al, [tok]
0282   055E B9 14         cmp al, TOK_END
0283   0560 C6 86 05      je cmd_cd_gotohome
0284   0563 B9 06         cmp al, TOK_SEMI
0285   0565 C6 86 05      je cmd_cd_gotohome
0286   0568 B9 08         cmp al, TOK_TILDE
0287   056A C6 86 05      je cmd_cd_gotohome
0288   056D 07 45 11      call putback
0289   0570 07 68 0F      call get_path    ; get the path for the cd command
0290   0573             cmd_cd_syscall:
0291   0573 3B 62 11      mov d, tokstr
0292   0576 19 13         mov al, 19
0293   0578 05 04         syscall sys_fileio  ; get dirID in A
0294   057A AF FF FF      cmp a, $FFFF
0295   057D C6 97 05      je cmd_cd_fail
0296   0580 27            mov b, a
0297   0581 19 03         mov al, 3
0298   0583 05 04         syscall sys_fileio  ; set dir to B
0299   0585 09            ret
0300   0586             cmd_cd_gotohome:
0301   0586 07 45 11      call putback
0302   0589 FD 4D DF 06   mov si, homedir
0303   058D FD 4F 62 11   mov di, tokstr
0304   0591 07 83 0B      call strcpy
0305   0594 0A 73 05      jmp cmd_cd_syscall
0306   0597             cmd_cd_fail:
0307   0597 09            ret
0308   0598             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0309   0598             ;; pad string to 32 chars
0310   0598             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0311   0598             ; count in C
0312   0598             padding:
0313   0598 D7            push a
0314   0599 10 20 00      mov a, 32
0315   059C 28            mov b, c
0316   059D 60            sub a, b
0317   059E 39            mov c, a
0318   059F             padding_L1:
0319   059F 22 20         mov ah, $20
0320   05A1 07 29 0C      call putchar
0321   05A4 A9 9F 05      loopc padding_L1
0322   05A7 E4            pop a
0323   05A8 09            ret
0324   05A9             ; file structure:
0325   05A9             ; 512 bytes header
0326   05A9             ; header used to tell whether the block is free
0327   05A9             
0328   05A9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0329   05A9             ;; EXEC/OPEN PROGRAM/FILE
0330   05A9             ;; 'filename' maps to '$path/filename'
0331   05A9             ;; './file' or '/a/directory/file' loads a file directly
0332   05A9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0333   05A9             cmd_exec:
0334   05A9 BC 61 11 14   cmp byte[tok], TOK_END
0335   05AD C6 33 06      je cmd_exec_ret    ; check for NULL input
0336   05B0 07 68 0F      call get_path    ; get file path 
0337   05B3 14 5E 11      mov a, [prog]
0338   05B6 D7            push a        ; save argument pointer
0339   05B7 FD 4D 62 11   mov si, tokstr
0340   05BB FD 4F 62 12   mov di, temp_data1
0341   05BF 07 83 0B      call strcpy      ; copy filename for later
0342   05C2 BC 62 11 2F   cmp byte[tokstr], '/'  ; check first character of path
0343   05C6 C6 24 06      je cmd_exec_abs
0344   05C9 BC 62 11 2E   cmp byte[tokstr], '.'  ; check first character of path
0345   05CD C6 24 06      je cmd_exec_abs
0346   05D0 10 DF 07      mov a, PATH
0347   05D3 42 5E 11      mov [prog], a    ; set token pointer to $PATH beginning
0348   05D6             cmd_exec_L0:
0349   05D6 07 68 0F      call get_path    ; get a path option
0350   05D9 FD 4D 62 11   mov si, tokstr
0351   05DD FD 4F 62 13   mov di, temp_data
0352   05E1 07 83 0B      call strcpy      ; firstly, form address from one of the '$PATH' addresses
0353   05E4 FD 4D 06 09   mov si, s_fslash
0354   05E8 FD 4F 62 13   mov di, temp_data
0355   05EC 07 91 0B      call strcat      ; add '/' in between $PATH component and filename
0356   05EF FD 4D 62 12   mov si, temp_data1
0357   05F3 FD 4F 62 13   mov di, temp_data
0358   05F7 07 91 0B      call strcat      ; now glue the given filename to the total path
0359   05FA 3B 62 13      mov d, temp_data
0360   05FD 19 15         mov al, 21
0361   05FF 05 04         syscall sys_fileio  ; now we check whether such a file exists. success code is given in A. if 0, file does not exist
0362   0601 AF 00 00      cmp a, 0
0363   0604 C7 14 06      jne cmd_exec_PATH_exists
0364   0607 07 BF 0F      call get_token
0365   060A BC 61 11 06   cmp byte[tok], TOK_SEMI
0366   060E C7 D6 05      jne cmd_exec_L0    ; if not ';' at the end, then token must be a separator. so try another path
0367   0611 0A 34 06      jmp cmd_exec_unknown
0368   0614             cmd_exec_PATH_exists:
0369   0614 E4            pop a        ; retrieve token pointer which points to the arguments given
0370   0615 42 5E 11      mov [prog], a
0371   0618 07 34 0F      call get_arg    ; if however, $PATH/filename was found, then we execute it
0372   061B 26 62 11      mov b, tokstr
0373   061E 3B 62 13      mov d, temp_data
0374   0621 05 05         syscall sys_fork
0375   0623 09            ret
0376   0624             cmd_exec_abs:  ; execute as absolute path
0377   0624 E4            pop a
0378   0625 42 5E 11      mov [prog], a
0379   0628 07 34 0F      call get_arg
0380   062B 26 62 11      mov b, tokstr
0381   062E 3B 62 12      mov d, temp_data1  ;original filename
0382   0631 05 05         syscall sys_fork
0383   0633             cmd_exec_ret:
0384   0633 09            ret
0385   0634             cmd_exec_unknown:
0386   0634 E4            pop a
0387   0635 09            ret
0388   0636             
0389   0636             cmd_shutdown:
0390   0636 19 01         mov al, 1
0391   0638 05 02         syscall sys_IDE
0392   063A FF            halt
0393   063B 09            ret
0394   063C             
0395   063C             cmd_reboot:
0396   063C 3B DF 08      mov d, s_rebooting
0397   063F 07 63 0D      call puts
0398   0642 05 08         syscall sys_reboot
0399   0644             
0400   0644             cmd_drtoggle:
0401   0644 0C            lodstat
0402   0645 2F            mov bl, al
0403   0646 FD 87 DF      and bl, %11011111
0404   0649 87 20         and al, %00100000
0405   064B 8F 20         xor al, %00100000
0406   064D 8C            or al, bl
0407   064E 0D            stostat
0408   064F               
0409   064F 09            ret
0410   0650             
0411   0650             cmd_man:
0412   0650 3B BE 0B      mov d, s_telnet_clear
0413   0653 07 63 0D      call puts
0414   0656 FD 4D 5F 07   mov si, manpath
0415   065A FD 4F 62 13   mov di, temp_data
0416   065E 07 83 0B      call strcpy        ; complete path with command name
0417   0661 FD 4D 06 09   mov si, s_fslash
0418   0665 FD 4F 62 13   mov di, temp_data
0419   0669 07 91 0B      call strcat        ; add '/' to the end
0420   066C 07 BF 0F      call get_token
0421   066F FD 4D 62 11   mov si, tokstr
0422   0673 FD 4F 62 13   mov di, temp_data
0423   0677 07 91 0B      call strcat        ; complete path with command name
0424   067A 3B 62 13      mov d, temp_data
0425   067D FD 4F 62 15   mov di, shell_transient_area
0426   0681 19 14         mov al, 20
0427   0683 05 04         syscall sys_fileio
0428   0685 3B 62 15      mov d, shell_transient_area
0429   0688 07 63 0D      call puts
0430   068B 07 10 0D      call printnl
0431   068E             cmd_man_fail:
0432   068E 09            ret
0433   068F             
0434   068F             cmd_fg:
0435   068F 07 BF 0F      call get_token
0436   0692 1D 62 11      mov al, [tokstr]
0437   0695 6F 30         sub al, $30
0438   0697 05 0A         syscall sys_resumeproc
0439   0699 09            ret
0440   069A             
0441   069A 6D 6B 66 73 commands:    .db "mkfs", 0
0441   069E 00 
0442   069F 63 64 00            .db "cd", 0
0443   06A2 73 64 61 74         .db "sdate", 0
0443   06A6 65 00 
0444   06A8 72 65 62 6F         .db "reboot", 0
0444   06AC 6F 74 00 
0445   06AF 73 68 75 74         .db "shutdown", 0
0445   06B3 64 6F 77 6E 
0445   06B7 00 
0446   06B8 64 72 74 6F         .db "drtoggle", 0
0446   06BC 67 67 6C 65 
0446   06C0 00 
0447   06C1 6D 61 6E 00         .db "man", 0
0448   06C5 66 67 00            .db "fg", 0
0449   06C8 73 73 68 00         .db "ssh", 0
0450   06CC 00                  .db 0
0451   06CD             
0452   06CD 53 05       keyword_ptrs:  .dw cmd_mkfs
0453   06CF 58 05               .dw cmd_cd
0454   06D1 4E 05               .dw cmd_setdate
0455   06D3 3C 06               .dw cmd_reboot
0456   06D5 36 06               .dw cmd_shutdown
0457   06D7 44 06               .dw cmd_drtoggle
0458   06D9 50 06               .dw cmd_man
0459   06DB 8F 06               .dw cmd_fg
0460   06DD 32 05               .dw cmd_ssh
0461   06DF             
0462   06DF 00 00 00 00 homedir:    .fill 128, 0
0462   06E3 00 00 00 00 
0462   06E7 00 00 00 00 
0462   06EB 00 00 00 00 
0462   06EF 00 00 00 00 
0462   06F3 00 00 00 00 
0462   06F7 00 00 00 00 
0462   06FB 00 00 00 00 
0462   06FF 00 00 00 00 
0462   0703 00 00 00 00 
0462   0707 00 00 00 00 
0462   070B 00 00 00 00 
0462   070F 00 00 00 00 
0462   0713 00 00 00 00 
0462   0717 00 00 00 00 
0462   071B 00 00 00 00 
0462   071F 00 00 00 00 
0462   0723 00 00 00 00 
0462   0727 00 00 00 00 
0462   072B 00 00 00 00 
0462   072F 00 00 00 00 
0462   0733 00 00 00 00 
0462   0737 00 00 00 00 
0462   073B 00 00 00 00 
0462   073F 00 00 00 00 
0462   0743 00 00 00 00 
0462   0747 00 00 00 00 
0462   074B 00 00 00 00 
0462   074F 00 00 00 00 
0462   0753 00 00 00 00 
0462   0757 00 00 00 00 
0462   075B 00 00 00 00 
0463   075F 00 00 00 00 manpath:    .fill 128, 0    ; man path
0463   0763 00 00 00 00 
0463   0767 00 00 00 00 
0463   076B 00 00 00 00 
0463   076F 00 00 00 00 
0463   0773 00 00 00 00 
0463   0777 00 00 00 00 
0463   077B 00 00 00 00 
0463   077F 00 00 00 00 
0463   0783 00 00 00 00 
0463   0787 00 00 00 00 
0463   078B 00 00 00 00 
0463   078F 00 00 00 00 
0463   0793 00 00 00 00 
0463   0797 00 00 00 00 
0463   079B 00 00 00 00 
0463   079F 00 00 00 00 
0463   07A3 00 00 00 00 
0463   07A7 00 00 00 00 
0463   07AB 00 00 00 00 
0463   07AF 00 00 00 00 
0463   07B3 00 00 00 00 
0463   07B7 00 00 00 00 
0463   07BB 00 00 00 00 
0463   07BF 00 00 00 00 
0463   07C3 00 00 00 00 
0463   07C7 00 00 00 00 
0463   07CB 00 00 00 00 
0463   07CF 00 00 00 00 
0463   07D3 00 00 00 00 
0463   07D7 00 00 00 00 
0463   07DB 00 00 00 00 
0464   07DF 00 00 00 00 PATH:      .fill 128, 0    ; $PATH environment variable (for now just one path)
0464   07E3 00 00 00 00 
0464   07E7 00 00 00 00 
0464   07EB 00 00 00 00 
0464   07EF 00 00 00 00 
0464   07F3 00 00 00 00 
0464   07F7 00 00 00 00 
0464   07FB 00 00 00 00 
0464   07FF 00 00 00 00 
0464   0803 00 00 00 00 
0464   0807 00 00 00 00 
0464   080B 00 00 00 00 
0464   080F 00 00 00 00 
0464   0813 00 00 00 00 
0464   0817 00 00 00 00 
0464   081B 00 00 00 00 
0464   081F 00 00 00 00 
0464   0823 00 00 00 00 
0464   0827 00 00 00 00 
0464   082B 00 00 00 00 
0464   082F 00 00 00 00 
0464   0833 00 00 00 00 
0464   0837 00 00 00 00 
0464   083B 00 00 00 00 
0464   083F 00 00 00 00 
0464   0843 00 00 00 00 
0464   0847 00 00 00 00 
0464   084B 00 00 00 00 
0464   084F 00 00 00 00 
0464   0853 00 00 00 00 
0464   0857 00 00 00 00 
0464   085B 00 00 00 00 
0465   085F             
0466   085F 2F 65 74 63 s_etc_profile:  .db "/etc/profile", 0
0466   0863 2F 70 72 6F 
0466   0867 66 69 6C 65 
0466   086B 00 
0467   086C 2F 65 74 63 s_etc_config:  .db "/etc/sh.conf", 0
0467   0870 2F 73 68 2E 
0467   0874 63 6F 6E 66 
0467   0878 00 
0468   0879 68 6F 6D 65 s_home:      .db "home", 0
0468   087D 00 
0469   087E 6D 61 6E 00 s_man:      .db "man", 0
0470   0882 50 41 54 48 s_PATH:      .db "PATH", 0
0470   0886 00 
0471   0887             
0472   0887 0A 6D 61 6E s_prompt_manpages:  .db "\nmanpages directory=", 0
0472   088B 70 61 67 65 
0472   088F 73 20 64 69 
0472   0893 72 65 63 74 
0472   0897 6F 72 79 3D 
0472   089B 00 
0473   089C 0A 68 6F 6D s_prompt_homedir:  .db "\nhome directory=", 0
0473   08A0 65 20 64 69 
0473   08A4 72 65 63 74 
0473   08A8 6F 72 79 3D 
0473   08AC 00 
0474   08AD 50 41 54 48 s_prompt_PATH:    .db "PATH=", 0
0474   08B1 3D 00 
0475   08B3 0A 72 65 61 s_prompt_config:  .db "\nreading \'/etc/sh.conf\' configuration file\n", 0
0475   08B7 64 69 6E 67 
0475   08BB 20 27 2F 65 
0475   08BF 74 63 2F 73 
0475   08C3 68 2E 63 6F 
0475   08C7 6E 66 27 20 
0475   08CB 63 6F 6E 66 
0475   08CF 69 67 75 72 
0475   08D3 61 74 69 6F 
0475   08D7 6E 20 66 69 
0475   08DB 6C 65 0A 00 
0476   08DF             
0477   08DF 1B 5B 32 4A s_rebooting:   .db 27, "[2J", 27, "[H", "rebooting", 0
0477   08E3 1B 5B 48 72 
0477   08E7 65 62 6F 6F 
0477   08EB 74 69 6E 67 
0477   08EF 00 
0478   08F0 25 20 00    s_dataentry:  .db "% ", 0
0479   08F3 0A 73 79 6E s_syntax_err:  .db "\nsyntax error\n", 0
0479   08F7 74 61 78 20 
0479   08FB 65 72 72 6F 
0479   08FF 72 0A 00 
0480   0902 20 23 20 00 s_hash:      .db " # ", 0
0481   0906 2F 00       s_fslash:    .db "/", 0
0482   0908 53 6F 6C 61 s_sol1:      .db "Solarium:", 0, 0
0482   090C 72 69 75 6D 
0482   0910 3A 00 00 
0483   0913             ; shell variables
0484   0913 00 00 00 00 shell_input_buff:  .fill 512, 0
0484   0917 00 00 00 00 
0484   091B 00 00 00 00 
0484   091F 00 00 00 00 
0484   0923 00 00 00 00 
0484   0927 00 00 00 00 
0484   092B 00 00 00 00 
0484   092F 00 00 00 00 
0484   0933 00 00 00 00 
0484   0937 00 00 00 00 
0484   093B 00 00 00 00 
0484   093F 00 00 00 00 
0484   0943 00 00 00 00 
0484   0947 00 00 00 00 
0484   094B 00 00 00 00 
0484   094F 00 00 00 00 
0484   0953 00 00 00 00 
0484   0957 00 00 00 00 
0484   095B 00 00 00 00 
0484   095F 00 00 00 00 
0484   0963 00 00 00 00 
0484   0967 00 00 00 00 
0484   096B 00 00 00 00 
0484   096F 00 00 00 00 
0484   0973 00 00 00 00 
0484   0977 00 00 00 00 
0484   097B 00 00 00 00 
0484   097F 00 00 00 00 
0484   0983 00 00 00 00 
0484   0987 00 00 00 00 
0484   098B 00 00 00 00 
0484   098F 00 00 00 00 
0484   0993 00 00 00 00 
0484   0997 00 00 00 00 
0484   099B 00 00 00 00 
0484   099F 00 00 00 00 
0484   09A3 00 00 00 00 
0484   09A7 00 00 00 00 
0484   09AB 00 00 00 00 
0484   09AF 00 00 00 00 
0484   09B3 00 00 00 00 
0484   09B7 00 00 00 00 
0484   09BB 00 00 00 00 
0484   09BF 00 00 00 00 
0484   09C3 00 00 00 00 
0484   09C7 00 00 00 00 
0484   09CB 00 00 00 00 
0484   09CF 00 00 00 00 
0484   09D3 00 00 00 00 
0484   09D7 00 00 00 00 
0484   09DB 00 00 00 00 
0484   09DF 00 00 00 00 
0484   09E3 00 00 00 00 
0484   09E7 00 00 00 00 
0484   09EB 00 00 00 00 
0484   09EF 00 00 00 00 
0484   09F3 00 00 00 00 
0484   09F7 00 00 00 00 
0484   09FB 00 00 00 00 
0484   09FF 00 00 00 00 
0484   0A03 00 00 00 00 
0484   0A07 00 00 00 00 
0484   0A0B 00 00 00 00 
0484   0A0F 00 00 00 00 
0484   0A13 00 00 00 00 
0484   0A17 00 00 00 00 
0484   0A1B 00 00 00 00 
0484   0A1F 00 00 00 00 
0484   0A23 00 00 00 00 
0484   0A27 00 00 00 00 
0484   0A2B 00 00 00 00 
0484   0A2F 00 00 00 00 
0484   0A33 00 00 00 00 
0484   0A37 00 00 00 00 
0484   0A3B 00 00 00 00 
0484   0A3F 00 00 00 00 
0484   0A43 00 00 00 00 
0484   0A47 00 00 00 00 
0484   0A4B 00 00 00 00 
0484   0A4F 00 00 00 00 
0484   0A53 00 00 00 00 
0484   0A57 00 00 00 00 
0484   0A5B 00 00 00 00 
0484   0A5F 00 00 00 00 
0484   0A63 00 00 00 00 
0484   0A67 00 00 00 00 
0484   0A6B 00 00 00 00 
0484   0A6F 00 00 00 00 
0484   0A73 00 00 00 00 
0484   0A77 00 00 00 00 
0484   0A7B 00 00 00 00 
0484   0A7F 00 00 00 00 
0484   0A83 00 00 00 00 
0484   0A87 00 00 00 00 
0484   0A8B 00 00 00 00 
0484   0A8F 00 00 00 00 
0484   0A93 00 00 00 00 
0484   0A97 00 00 00 00 
0484   0A9B 00 00 00 00 
0484   0A9F 00 00 00 00 
0484   0AA3 00 00 00 00 
0484   0AA7 00 00 00 00 
0484   0AAB 00 00 00 00 
0484   0AAF 00 00 00 00 
0484   0AB3 00 00 00 00 
0484   0AB7 00 00 00 00 
0484   0ABB 00 00 00 00 
0484   0ABF 00 00 00 00 
0484   0AC3 00 00 00 00 
0484   0AC7 00 00 00 00 
0484   0ACB 00 00 00 00 
0484   0ACF 00 00 00 00 
0484   0AD3 00 00 00 00 
0484   0AD7 00 00 00 00 
0484   0ADB 00 00 00 00 
0484   0ADF 00 00 00 00 
0484   0AE3 00 00 00 00 
0484   0AE7 00 00 00 00 
0484   0AEB 00 00 00 00 
0484   0AEF 00 00 00 00 
0484   0AF3 00 00 00 00 
0484   0AF7 00 00 00 00 
0484   0AFB 00 00 00 00 
0484   0AFF 00 00 00 00 
0484   0B03 00 00 00 00 
0484   0B07 00 00 00 00 
0484   0B0B 00 00 00 00 
0484   0B0F 00 00 00 00 
0485   0B13 00 00       shell_buff_ptr:    .dw 0
0486   0B15 00 00       parser_index:     .dw 0
0487   0B17             
0488   0B17             .include "stdio.asm"
0001+  0B17             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0B17             ; stdio.s
0003+  0B17             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0B17             .include "string.asm"
0001++ 0B17             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0B17             ; string.s
0003++ 0B17             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0B17             
0005++ 0B17             
0006++ 0B17             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0B17             ; strrev
0008++ 0B17             ; reverse a string
0009++ 0B17             ; D = string address
0010++ 0B17             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0B17             ; 01234
0012++ 0B17             strrev:
0013++ 0B17 4B          	pusha
0014++ 0B18 07 5E 0B    	call strlen	; length in C
0015++ 0B1B 12          	mov a, c
0016++ 0B1C AF 01 00    	cmp a, 1
0017++ 0B1F D0 39 0B    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0B22 7D          	dec a
0019++ 0B23 FD 4E       	mov si, d	; beginning of string
0020++ 0B25 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0B27 59          	add d, a	; end of string
0022++ 0B28 12          	mov a, c
0023++ 0B29 FD 9B       	shr a		; divide by 2
0024++ 0B2B 39          	mov c, a	; C now counts the steps
0025++ 0B2C             strrev_L0:
0026++ 0B2C 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0B2D F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0B2E 3E          	mov [d], al	; store left char into right side
0029++ 0B2F 1B          	mov al, bl
0030++ 0B30 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0B31 7E          	dec c
0032++ 0B32 7F          	dec d
0033++ 0B33 C2 00 00    	cmp c, 0
0034++ 0B36 C7 2C 0B    	jne strrev_L0
0035++ 0B39             strrev_end:
0036++ 0B39 4C          	popa
0037++ 0B3A 09          	ret
0038++ 0B3B             	
0039++ 0B3B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0B3B             ; strchr
0041++ 0B3B             ; search string in D for char in AL
0042++ 0B3B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0B3B             strchr:
0044++ 0B3B             strchr_L0:
0045++ 0B3B 32          	mov bl, [d]
0046++ 0B3C C1 00       	cmp bl, 0
0047++ 0B3E C6 49 0B    	je strchr_end
0048++ 0B41 BA          	cmp al, bl
0049++ 0B42 C6 49 0B    	je strchr_end
0050++ 0B45 79          	inc d
0051++ 0B46 0A 3B 0B    	jmp strchr_L0
0052++ 0B49             strchr_end:
0053++ 0B49 1B          	mov al, bl
0054++ 0B4A 09          	ret
0055++ 0B4B             
0056++ 0B4B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0B4B             ; strstr
0058++ 0B4B             ; find sub-string
0059++ 0B4B             ; str1 in SI
0060++ 0B4B             ; str2 in DI
0061++ 0B4B             ; SI points to end of source string
0062++ 0B4B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0B4B             strstr:
0064++ 0B4B DB          	push al
0065++ 0B4C DA          	push d
0066++ 0B4D E3          	push di
0067++ 0B4E             strstr_loop:
0068++ 0B4E F3          	cmpsb					; compare a byte of the strings
0069++ 0B4F C7 5A 0B    	jne strstr_ret
0070++ 0B52 FC 00 00    	lea d, [di + 0]
0071++ 0B55 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0B57 C7 4E 0B    	jne strstr_loop				; equal chars but not at end
0073++ 0B5A             strstr_ret:
0074++ 0B5A F0          	pop di
0075++ 0B5B E7          	pop d
0076++ 0B5C E8          	pop al
0077++ 0B5D 09          	ret
0078++ 0B5E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0B5E             ; length of null terminated string
0080++ 0B5E             ; result in C
0081++ 0B5E             ; pointer in D
0082++ 0B5E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0B5E             strlen:
0084++ 0B5E DA          	push d
0085++ 0B5F 38 00 00    	mov c, 0
0086++ 0B62             strlen_L1:
0087++ 0B62 BD 00       	cmp byte [d], 0
0088++ 0B64 C6 6C 0B    	je strlen_ret
0089++ 0B67 79          	inc d
0090++ 0B68 78          	inc c
0091++ 0B69 0A 62 0B    	jmp strlen_L1
0092++ 0B6C             strlen_ret:
0093++ 0B6C E7          	pop d
0094++ 0B6D 09          	ret
0095++ 0B6E             
0096++ 0B6E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0B6E             ; STRCMP
0098++ 0B6E             ; compare two strings
0099++ 0B6E             ; str1 in SI
0100++ 0B6E             ; str2 in DI
0101++ 0B6E             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0B6E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0B6E             strcmp:
0104++ 0B6E DB          	push al
0105++ 0B6F DA          	push d
0106++ 0B70 E3          	push di
0107++ 0B71 E2          	push si
0108++ 0B72             strcmp_loop:
0109++ 0B72 F3          	cmpsb					; compare a byte of the strings
0110++ 0B73 C7 7E 0B    	jne strcmp_ret
0111++ 0B76 FB FF FF    	lea d, [si +- 1]
0112++ 0B79 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0B7B C7 72 0B    	jne strcmp_loop				; equal chars but not at end
0114++ 0B7E             strcmp_ret:
0115++ 0B7E EF          	pop si
0116++ 0B7F F0          	pop di
0117++ 0B80 E7          	pop d
0118++ 0B81 E8          	pop al
0119++ 0B82 09          	ret
0120++ 0B83             
0121++ 0B83             
0122++ 0B83             ; STRCPY
0123++ 0B83             ; copy null terminated string from SI to DI
0124++ 0B83             ; source in SI
0125++ 0B83             ; destination in DI
0126++ 0B83             strcpy:
0127++ 0B83 E2          	push si
0128++ 0B84 E3          	push di
0129++ 0B85 DB          	push al
0130++ 0B86             strcpy_L1:
0131++ 0B86 F6          	lodsb
0132++ 0B87 F7          	stosb
0133++ 0B88 B9 00       	cmp al, 0
0134++ 0B8A C7 86 0B    	jne strcpy_L1
0135++ 0B8D             strcpy_end:
0136++ 0B8D E8          	pop al
0137++ 0B8E F0          	pop di
0138++ 0B8F EF          	pop si
0139++ 0B90 09          	ret
0140++ 0B91             
0141++ 0B91             ; STRCAT
0142++ 0B91             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0B91             ; source in SI
0144++ 0B91             ; destination in DI
0145++ 0B91             strcat:
0146++ 0B91 E2          	push si
0147++ 0B92 E3          	push di
0148++ 0B93 D7          	push a
0149++ 0B94 DA          	push d
0150++ 0B95 50          	mov a, di
0151++ 0B96 3C          	mov d, a
0152++ 0B97             strcat_goto_end_L1:
0153++ 0B97 BD 00       	cmp byte[d], 0
0154++ 0B99 C6 A0 0B    	je strcat_start
0155++ 0B9C 79          	inc d
0156++ 0B9D 0A 97 0B    	jmp strcat_goto_end_L1
0157++ 0BA0             strcat_start:
0158++ 0BA0 FD 50       	mov di, d
0159++ 0BA2             strcat_L1:
0160++ 0BA2 F6          	lodsb
0161++ 0BA3 F7          	stosb
0162++ 0BA4 B9 00       	cmp al, 0
0163++ 0BA6 C7 A2 0B    	jne strcat_L1
0164++ 0BA9             strcat_end:
0165++ 0BA9 E7          	pop d
0166++ 0BAA E4          	pop a
0167++ 0BAB F0          	pop di
0168++ 0BAC EF          	pop si
0169++ 0BAD 09          	ret
0005+  0BAE             
0006+  0BAE 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  0BB2 34 35 36 37 
0006+  0BB6 38 39 41 42 
0006+  0BBA 43 44 45 46 
0007+  0BBE 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  0BC2 1B 5B 48 00 
0008+  0BC6             
0009+  0BC6 01 00       table_power:.dw 1
0010+  0BC8 0A 00       			.dw 10
0011+  0BCA 64 00       			.dw 100
0012+  0BCC E8 03       			.dw 1000
0013+  0BCE 10 27       			.dw 10000
0014+  0BD0             
0015+  0BD0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  0BD0             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  0BD0             ; ASCII in BL
0018+  0BD0             ; result in AL
0019+  0BD0             ; ascii for F = 0100 0110
0020+  0BD0             ; ascii for 9 = 0011 1001
0021+  0BD0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  0BD0             hex_ascii_encode:
0023+  0BD0 1B          	mov al, bl
0024+  0BD1 93 40       	test al, $40				; test if letter or number
0025+  0BD3 C7 D9 0B    	jnz hex_letter
0026+  0BD6 87 0F       	and al, $0F				; get number
0027+  0BD8 09          	ret
0028+  0BD9             hex_letter:
0029+  0BD9 87 0F       	and al, $0F				; get letter
0030+  0BDB 6A 09       	add al, 9
0031+  0BDD 09          	ret
0032+  0BDE             
0033+  0BDE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  0BDE             ; ATOI
0035+  0BDE             ; 2 letter hex string in B
0036+  0BDE             ; 8bit integer returned in AL
0037+  0BDE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0BDE             atoi:
0039+  0BDE D8          	push b
0040+  0BDF 07 D0 0B    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  0BE2 30          	mov bl, bh
0042+  0BE3 DB          	push al					; save a
0043+  0BE4 07 D0 0B    	call hex_ascii_encode
0044+  0BE7 EA          	pop bl	
0045+  0BE8 FD 9E 04    	shl al, 4
0046+  0BEB 8C          	or al, bl
0047+  0BEC E5          	pop b
0048+  0BED 09          	ret	
0049+  0BEE             
0050+  0BEE             
0051+  0BEE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  0BEE             ; printf
0053+  0BEE             ; no need for explanations!
0054+  0BEE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0BEE             printf:
0056+  0BEE 09          	ret
0057+  0BEF             
0058+  0BEF             
0059+  0BEF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  0BEF             ; scanf
0061+  0BEF             ; no need for explanations!
0062+  0BEF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  0BEF             scanf:
0064+  0BEF 09          	ret
0065+  0BF0             
0066+  0BF0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  0BF0             ; ITOA
0068+  0BF0             ; 8bit value in BL
0069+  0BF0             ; 2 byte ASCII result in A
0070+  0BF0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  0BF0             itoa:
0072+  0BF0 DA          	push d
0073+  0BF1 D8          	push b
0074+  0BF2 A7 00       	mov bh, 0
0075+  0BF4 FD A4 04    	shr bl, 4	
0076+  0BF7 74          	mov d, b
0077+  0BF8 1F AE 0B    	mov al, [d + s_hex_digits]
0078+  0BFB 23          	mov ah, al
0079+  0BFC             	
0080+  0BFC E5          	pop b
0081+  0BFD D8          	push b
0082+  0BFE A7 00       	mov bh, 0
0083+  0C00 FD 87 0F    	and bl, $0F
0084+  0C03 74          	mov d, b
0085+  0C04 1F AE 0B    	mov al, [d + s_hex_digits]
0086+  0C07 E5          	pop b
0087+  0C08 E7          	pop d
0088+  0C09 09          	ret
0089+  0C0A             
0090+  0C0A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  0C0A             ; HEX STRING TO BINARY
0092+  0C0A             ; di = destination address
0093+  0C0A             ; si = source
0094+  0C0A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  0C0A             hex_to_int:
0096+  0C0A             hex_to_int_L1:
0097+  0C0A F6          	lodsb					; load from [SI] to AL
0098+  0C0B B9 00       	cmp al, 0				; check if ASCII 0
0099+  0C0D C6 1A 0C    	jz hex_to_int_ret
0100+  0C10 36          	mov bh, al
0101+  0C11 F6          	lodsb
0102+  0C12 2F          	mov bl, al
0103+  0C13 07 DE 0B    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  0C16 F7          	stosb					; store AL to [DI]
0105+  0C17 0A 0A 0C    	jmp hex_to_int_L1
0106+  0C1A             hex_to_int_ret:
0107+  0C1A 09          	ret		
0108+  0C1B             
0109+  0C1B             
0110+  0C1B             
0111+  0C1B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  0C1B             ; GETCHAR
0113+  0C1B             ; char in ah
0114+  0C1B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  0C1B             getchar:
0116+  0C1B DB          	push al
0117+  0C1C             getchar_retry:
0118+  0C1C FD 0C       	sti
0119+  0C1E 19 01       	mov al, 1
0120+  0C20 05 03       	syscall sys_io			; receive in AH
0121+  0C22 B9 00       	cmp al, 0			; check if any char was receive
0122+  0C24 C6 1C 0C    	je getchar_retry
0123+  0C27 E8          	pop al
0124+  0C28 09          	ret
0125+  0C29             
0126+  0C29             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  0C29             ; PUTCHAR
0128+  0C29             ; char in ah
0129+  0C29             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0C29             putchar:
0131+  0C29 D7          	push a
0132+  0C2A 19 00       	mov al, 0
0133+  0C2C 05 03       	syscall sys_io			; char in AH
0134+  0C2E E4          	pop a
0135+  0C2F 09          	ret
0136+  0C30             
0137+  0C30             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  0C30             ;; INPUT A STRING
0139+  0C30             ;; terminates with null
0140+  0C30             ;; pointer in D
0141+  0C30             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  0C30             gets:
0143+  0C30 D7          	push a
0144+  0C31 DA          	push d
0145+  0C32             gets_loop:
0146+  0C32 FD 0C       	sti
0147+  0C34 19 01       	mov al, 1
0148+  0C36 05 03       	syscall sys_io			; receive in AH
0149+  0C38 B9 00       	cmp al, 0				; check error code (AL)
0150+  0C3A C6 32 0C    	je gets_loop			; if no char received, retry
0151+  0C3D             
0152+  0C3D 76 1B       	cmp ah, 27
0153+  0C3F C6 60 0C    	je gets_telnet_escape
0154+  0C42 76 0A       	cmp ah, $0A				; LF
0155+  0C44 C6 B9 0C    	je gets_end
0156+  0C47 76 0D       	cmp ah, $0D				; CR
0157+  0C49 C6 B9 0C    	je gets_end
0158+  0C4C 76 5C       	cmp ah, $5C				; '\\'
0159+  0C4E C6 90 0C    	je gets_escape
0160+  0C51             	
0161+  0C51 76 08       	cmp ah, $08			; check for backspace
0162+  0C53 C6 5C 0C    	je gets_backspace
0163+  0C56             
0164+  0C56 1A          	mov al, ah
0165+  0C57 3E          	mov [d], al
0166+  0C58 79          	inc d
0167+  0C59 0A 32 0C    	jmp gets_loop
0168+  0C5C             gets_backspace:
0169+  0C5C 7F          	dec d
0170+  0C5D 0A 32 0C    	jmp gets_loop
0171+  0C60             gets_telnet_escape:
0172+  0C60 FD 0C       	sti
0173+  0C62 19 01       	mov al, 1
0174+  0C64 05 03       	syscall sys_io				; receive in AH without echo
0175+  0C66 B9 00       	cmp al, 0					; check error code (AL)
0176+  0C68 C6 60 0C    	je gets_telnet_escape		; if no char received, retry
0177+  0C6B 76 5B       	cmp ah, '['
0178+  0C6D C7 32 0C    	jne gets_loop
0179+  0C70             gets_telnet_escape_phase2:
0180+  0C70 FD 0C       	sti
0181+  0C72 19 01       	mov al, 1
0182+  0C74 05 03       	syscall sys_io					; receive in AH without echo
0183+  0C76 B9 00       	cmp al, 0						; check error code (AL)
0184+  0C78 C6 70 0C    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  0C7B 76 44       	cmp ah, 'D'
0186+  0C7D C6 88 0C    	je gets_left_arrow
0187+  0C80 76 43       	cmp ah, 'C'
0188+  0C82 C6 8C 0C    	je gets_right_arrow
0189+  0C85 0A 32 0C    	jmp gets_loop
0190+  0C88             gets_left_arrow:
0191+  0C88 7F          	dec d
0192+  0C89 0A 32 0C    	jmp gets_loop
0193+  0C8C             gets_right_arrow:
0194+  0C8C 79          	inc d
0195+  0C8D 0A 32 0C    	jmp gets_loop
0196+  0C90             gets_escape:
0197+  0C90 FD 0C       	sti
0198+  0C92 19 01       	mov al, 1
0199+  0C94 05 03       	syscall sys_io			; receive in AH
0200+  0C96 B9 00       	cmp al, 0				; check error code (AL)
0201+  0C98 C6 90 0C    	je gets_escape			; if no char received, retry
0202+  0C9B 76 6E       	cmp ah, 'n'
0203+  0C9D C6 AB 0C    	je gets_LF
0204+  0CA0 76 72       	cmp ah, 'r'
0205+  0CA2 C6 B2 0C    	je gets_CR
0206+  0CA5 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  0CA6 3E          	mov [d], al
0208+  0CA7 79          	inc d
0209+  0CA8 0A 32 0C    	jmp gets_loop
0210+  0CAB             gets_LF:
0211+  0CAB 19 0A       	mov al, $0A
0212+  0CAD 3E          	mov [d], al
0213+  0CAE 79          	inc d
0214+  0CAF 0A 32 0C    	jmp gets_loop
0215+  0CB2             gets_CR:
0216+  0CB2 19 0D       	mov al, $0D
0217+  0CB4 3E          	mov [d], al
0218+  0CB5 79          	inc d
0219+  0CB6 0A 32 0C    	jmp gets_loop
0220+  0CB9             gets_end:
0221+  0CB9 19 00       	mov al, 0
0222+  0CBB 3E          	mov [d], al				; terminate string
0223+  0CBC E7          	pop d
0224+  0CBD E4          	pop a
0225+  0CBE 09          	ret
0226+  0CBF             
0227+  0CBF             
0228+  0CBF             
0229+  0CBF             
0230+  0CBF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  0CBF             ;; INPUT TEXT
0232+  0CBF             ;; terminated with CTRL+D
0233+  0CBF             ;; pointer in D
0234+  0CBF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  0CBF             gettxt:
0236+  0CBF D7          	push a
0237+  0CC0 DA          	push d
0238+  0CC1             gettxt_loop:
0239+  0CC1 19 01       	mov al, 1
0240+  0CC3 05 03       	syscall sys_io			; receive in AH
0241+  0CC5 B9 00       	cmp al, 0				; check error code (AL)
0242+  0CC7 C6 C1 0C    	je gettxt_loop		; if no char received, retry
0243+  0CCA 76 04       	cmp ah, 4			; EOT
0244+  0CCC C6 0A 0D    	je gettxt_end
0245+  0CCF 76 08       	cmp ah, $08			; check for backspace
0246+  0CD1 C6 06 0D    	je gettxt_backspace
0247+  0CD4 76 5C       	cmp ah, $5C				; '\\'
0248+  0CD6 C6 DF 0C    	je gettxt_escape
0249+  0CD9 1A          	mov al, ah
0250+  0CDA 3E          	mov [d], al
0251+  0CDB 79          	inc d
0252+  0CDC 0A C1 0C    	jmp gettxt_loop
0253+  0CDF             gettxt_escape:
0254+  0CDF 19 01       	mov al, 1
0255+  0CE1 05 03       	syscall sys_io			; receive in AH
0256+  0CE3 B9 00       	cmp al, 0				; check error code (AL)
0257+  0CE5 C6 DF 0C    	je gettxt_escape		; if no char received, retry
0258+  0CE8 76 6E       	cmp ah, 'n'
0259+  0CEA C6 F8 0C    	je gettxt_LF
0260+  0CED 76 72       	cmp ah, 'r'
0261+  0CEF C6 FF 0C    	je gettxt_CR
0262+  0CF2 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  0CF3 3E          	mov [d], al
0264+  0CF4 79          	inc d
0265+  0CF5 0A C1 0C    	jmp gettxt_loop
0266+  0CF8             gettxt_LF:
0267+  0CF8 19 0A       	mov al, $0A
0268+  0CFA 3E          	mov [d], al
0269+  0CFB 79          	inc d
0270+  0CFC 0A C1 0C    	jmp gettxt_loop
0271+  0CFF             gettxt_CR:
0272+  0CFF 19 0D       	mov al, $0D
0273+  0D01 3E          	mov [d], al
0274+  0D02 79          	inc d
0275+  0D03 0A C1 0C    	jmp gettxt_loop
0276+  0D06             gettxt_backspace:
0277+  0D06 7F          	dec d
0278+  0D07 0A C1 0C    	jmp gettxt_loop
0279+  0D0A             gettxt_end:
0280+  0D0A 19 00       	mov al, 0
0281+  0D0C 3E          	mov [d], al				; terminate string
0282+  0D0D E7          	pop d
0283+  0D0E E4          	pop a
0284+  0D0F 09          	ret
0285+  0D10             
0286+  0D10             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  0D10             ; PRINT NEW LINE
0288+  0D10             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  0D10             printnl:
0290+  0D10 D7          	push a
0291+  0D11 10 00 0A    	mov a, $0A00
0292+  0D14 05 03       	syscall sys_io
0293+  0D16 10 00 0D    	mov a, $0D00
0294+  0D19 05 03       	syscall sys_io
0295+  0D1B E4          	pop a
0296+  0D1C 09          	ret
0297+  0D1D             
0298+  0D1D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  0D1D             ; strtoint
0300+  0D1D             ; 4 digit hex string number in d
0301+  0D1D             ; integer returned in A
0302+  0D1D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  0D1D             strtointx:
0304+  0D1D D8          	push b
0305+  0D1E 32          	mov bl, [d]
0306+  0D1F 37          	mov bh, bl
0307+  0D20 33 01 00    	mov bl, [d + 1]
0308+  0D23 07 DE 0B    	call atoi				; convert to int in AL
0309+  0D26 23          	mov ah, al				; move to AH
0310+  0D27 33 02 00    	mov bl, [d + 2]
0311+  0D2A 37          	mov bh, bl
0312+  0D2B 33 03 00    	mov bl, [d + 3]
0313+  0D2E 07 DE 0B    	call atoi				; convert to int in AL
0314+  0D31 E5          	pop b
0315+  0D32 09          	ret
0316+  0D33             
0317+  0D33             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  0D33             ; strtoint
0319+  0D33             ; 5 digit base10 string number in d
0320+  0D33             ; integer returned in A
0321+  0D33             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  0D33             strtoint:
0323+  0D33 E2          	push si
0324+  0D34 D8          	push b
0325+  0D35 D9          	push c
0326+  0D36 DA          	push d
0327+  0D37 07 5E 0B    	call strlen			; get string length in C
0328+  0D3A 7E          	dec c
0329+  0D3B FD 4E       	mov si, d
0330+  0D3D 12          	mov a, c
0331+  0D3E FD 99       	shl a
0332+  0D40 3B C6 0B    	mov d, table_power
0333+  0D43 59          	add d, a
0334+  0D44 38 00 00    	mov c, 0
0335+  0D47             strtoint_L0:
0336+  0D47 F6          	lodsb			; load ASCII to al
0337+  0D48 B9 00       	cmp al, 0
0338+  0D4A C6 5D 0D    	je strtoint_end
0339+  0D4D 6F 30       	sub al, $30		; make into integer
0340+  0D4F 22 00       	mov ah, 0
0341+  0D51 2A          	mov b, [d]
0342+  0D52 AC          	mul a, b			; result in B since it fits in 16bits
0343+  0D53 11          	mov a, b
0344+  0D54 28          	mov b, c
0345+  0D55 54          	add a, b
0346+  0D56 39          	mov c, a
0347+  0D57 63 02 00    	sub d, 2
0348+  0D5A 0A 47 0D    	jmp strtoint_L0
0349+  0D5D             strtoint_end:
0350+  0D5D 12          	mov a, c
0351+  0D5E E7          	pop d
0352+  0D5F E6          	pop c
0353+  0D60 E5          	pop b
0354+  0D61 EF          	pop si
0355+  0D62 09          	ret
0356+  0D63             
0357+  0D63             
0358+  0D63             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  0D63             ; PRINT NULL TERMINATED STRING
0360+  0D63             ; pointer in D
0361+  0D63             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  0D63             puts:
0363+  0D63 D7          	push a
0364+  0D64 DA          	push d
0365+  0D65             puts_L1:
0366+  0D65 1E          	mov al, [d]
0367+  0D66 B9 00       	cmp al, 0
0368+  0D68 C6 74 0D    	jz puts_END
0369+  0D6B 23          	mov ah, al
0370+  0D6C 19 00       	mov al, 0
0371+  0D6E 05 03       	syscall sys_io
0372+  0D70 79          	inc d
0373+  0D71 0A 65 0D    	jmp puts_L1
0374+  0D74             puts_END:
0375+  0D74 E7          	pop d
0376+  0D75 E4          	pop a
0377+  0D76 09          	ret
0378+  0D77             
0379+  0D77             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  0D77             ; PRINT N SIZE STRING
0381+  0D77             ; pointer in D
0382+  0D77             ; size in C
0383+  0D77             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  0D77             putsn:
0385+  0D77 DB          	push al
0386+  0D78 DA          	push d
0387+  0D79 D9          	push c
0388+  0D7A             putsn_L0:
0389+  0D7A 1E          	mov al, [d]
0390+  0D7B 23          	mov ah, al
0391+  0D7C 19 00       	mov al, 0
0392+  0D7E 05 03       	syscall sys_io
0393+  0D80 79          	inc d
0394+  0D81 7E          	dec c	
0395+  0D82 C2 00 00    	cmp c, 0
0396+  0D85 C7 7A 0D    	jne putsn_L0
0397+  0D88             putsn_end:
0398+  0D88 E6          	pop c
0399+  0D89 E7          	pop d
0400+  0D8A E8          	pop al
0401+  0D8B 09          	ret
0402+  0D8C             
0403+  0D8C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  0D8C             ; print 16bit decimal number
0405+  0D8C             ; input number in A
0406+  0D8C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  0D8C             print_u16d:
0408+  0D8C D7          	push a
0409+  0D8D D8          	push b
0410+  0D8E 26 10 27    	mov b, 10000
0411+  0D91 AE          	div a, b			; get 10000's coeff.
0412+  0D92 07 B4 0D    	call print_number
0413+  0D95 11          	mov a, b
0414+  0D96 26 E8 03    	mov b, 1000
0415+  0D99 AE          	div a, b			; get 1000's coeff.
0416+  0D9A 07 B4 0D    	call print_number
0417+  0D9D 11          	mov a, b
0418+  0D9E 26 64 00    	mov b, 100
0419+  0DA1 AE          	div a, b
0420+  0DA2 07 B4 0D    	call print_number
0421+  0DA5 11          	mov a, b
0422+  0DA6 26 0A 00    	mov b, 10
0423+  0DA9 AE          	div a, b
0424+  0DAA 07 B4 0D    	call print_number
0425+  0DAD 1B          	mov al, bl			; 1's coeff in bl
0426+  0DAE 07 B4 0D    	call print_number
0427+  0DB1 E5          	pop b
0428+  0DB2 E4          	pop a
0429+  0DB3 09          	ret
0430+  0DB4             
0431+  0DB4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0432+  0DB4             ; print AL
0433+  0DB4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0434+  0DB4             print_number:
0435+  0DB4 6A 30       	add al, $30
0436+  0DB6 23          	mov ah, al
0437+  0DB7 07 29 0C    	call putchar
0438+  0DBA 09          	ret
0439+  0DBB             
0440+  0DBB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0441+  0DBB             ; PRINT 16BIT HEX INTEGER
0442+  0DBB             ; integer value in reg B
0443+  0DBB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0444+  0DBB             print_u16x:
0445+  0DBB D7          	push a
0446+  0DBC D8          	push b
0447+  0DBD DD          	push bl
0448+  0DBE 30          	mov bl, bh
0449+  0DBF 07 F0 0B    	call itoa				; convert bh to char in A
0450+  0DC2 2F          	mov bl, al				; save al
0451+  0DC3 19 00       	mov al, 0
0452+  0DC5 05 03       	syscall sys_io				; display AH
0453+  0DC7 24          	mov ah, bl				; retrieve al
0454+  0DC8 19 00       	mov al, 0
0455+  0DCA 05 03       	syscall sys_io				; display AL
0456+  0DCC             
0457+  0DCC EA          	pop bl
0458+  0DCD 07 F0 0B    	call itoa				; convert bh to char in A
0459+  0DD0 2F          	mov bl, al				; save al
0460+  0DD1 19 00       	mov al, 0
0461+  0DD3 05 03       	syscall sys_io				; display AH
0462+  0DD5 24          	mov ah, bl				; retrieve al
0463+  0DD6 19 00       	mov al, 0
0464+  0DD8 05 03       	syscall sys_io				; display AL
0465+  0DDA             
0466+  0DDA E5          	pop b
0467+  0DDB E4          	pop a
0468+  0DDC 09          	ret
0469+  0DDD             
0470+  0DDD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0471+  0DDD             ; INPUT 16BIT HEX INTEGER
0472+  0DDD             ; read 16bit integer into A
0473+  0DDD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0474+  0DDD             scan_u16x:
0475+  0DDD F8 10 00    	enter 16
0476+  0DE0 D8          	push b
0477+  0DE1 DA          	push d
0478+  0DE2             
0479+  0DE2 FA F1 FF    	lea d, [bp + -15]
0480+  0DE5 07 30 0C    	call gets				; get number
0481+  0DE8             
0482+  0DE8 32          	mov bl, [d]
0483+  0DE9 37          	mov bh, bl
0484+  0DEA 33 01 00    	mov bl, [d + 1]
0485+  0DED 07 DE 0B    	call atoi				; convert to int in AL
0486+  0DF0 23          	mov ah, al				; move to AH
0487+  0DF1             
0488+  0DF1 33 02 00    	mov bl, [d + 2]
0489+  0DF4 37          	mov bh, bl
0490+  0DF5 33 03 00    	mov bl, [d + 3]
0491+  0DF8 07 DE 0B    	call atoi				; convert to int in AL
0492+  0DFB             
0493+  0DFB E7          	pop d
0494+  0DFC E5          	pop b
0495+  0DFD F9          	leave
0496+  0DFE 09          	ret
0497+  0DFF             
0498+  0DFF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0499+  0DFF             ; PRINT 8bit HEX INTEGER
0500+  0DFF             ; integer value in reg bl
0501+  0DFF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0502+  0DFF             print_u8x:
0503+  0DFF D7          	push a
0504+  0E00 DD          	push bl
0505+  0E01             
0506+  0E01 07 F0 0B    	call itoa				; convert bl to char in A
0507+  0E04 2F          	mov bl, al				; save al
0508+  0E05 19 00       	mov al, 0
0509+  0E07 05 03       	syscall sys_io				; display AH
0510+  0E09 24          	mov ah, bl				; retrieve al
0511+  0E0A 19 00       	mov al, 0
0512+  0E0C 05 03       	syscall sys_io				; display AL
0513+  0E0E             
0514+  0E0E EA          	pop bl
0515+  0E0F E4          	pop a
0516+  0E10 09          	ret
0517+  0E11             
0518+  0E11             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0519+  0E11             ; print 8bit decimal unsigned number
0520+  0E11             ; input number in AL
0521+  0E11             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0522+  0E11             print_u8d:
0523+  0E11 D7          	push a
0524+  0E12 D8          	push b
0525+  0E13             
0526+  0E13 22 00       	mov ah, 0
0527+  0E15 26 64 00    	mov b, 100
0528+  0E18 AE          	div a, b
0529+  0E19 D8          	push b			; save remainder
0530+  0E1A B9 00       	cmp al, 0
0531+  0E1C C6 26 0E    	je skip100
0532+  0E1F 6A 30       	add al, $30
0533+  0E21 23          	mov ah, al
0534+  0E22 19 00       	mov al, 0
0535+  0E24 05 03       	syscall sys_io	; print coeff
0536+  0E26             skip100:
0537+  0E26 E4          	pop a
0538+  0E27 22 00       	mov ah, 0
0539+  0E29 26 0A 00    	mov b, 10
0540+  0E2C AE          	div a, b
0541+  0E2D D8          	push b			; save remainder
0542+  0E2E B9 00       	cmp al, 0
0543+  0E30 C6 3A 0E    	je skip10
0544+  0E33 6A 30       	add al, $30
0545+  0E35 23          	mov ah, al
0546+  0E36 19 00       	mov al, 0
0547+  0E38 05 03       	syscall sys_io	; print coeff
0548+  0E3A             skip10:
0549+  0E3A E4          	pop a
0550+  0E3B 1B          	mov al, bl
0551+  0E3C 6A 30       	add al, $30
0552+  0E3E 23          	mov ah, al
0553+  0E3F 19 00       	mov al, 0
0554+  0E41 05 03       	syscall sys_io	; print coeff
0555+  0E43 E5          	pop b
0556+  0E44 E4          	pop a
0557+  0E45 09          	ret
0558+  0E46             
0559+  0E46             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0560+  0E46             ; INPUT 8BIT HEX INTEGER
0561+  0E46             ; read 8bit integer into AL
0562+  0E46             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0563+  0E46             scan_u8x:
0564+  0E46 F8 04 00    	enter 4
0565+  0E49 D8          	push b
0566+  0E4A DA          	push d
0567+  0E4B             
0568+  0E4B FA FD FF    	lea d, [bp + -3]
0569+  0E4E 07 30 0C    	call gets				; get number
0570+  0E51             
0571+  0E51 32          	mov bl, [d]
0572+  0E52 37          	mov bh, bl
0573+  0E53 33 01 00    	mov bl, [d + 1]
0574+  0E56 07 DE 0B    	call atoi				; convert to int in AL
0575+  0E59             
0576+  0E59 E7          	pop d
0577+  0E5A E5          	pop b
0578+  0E5B F9          	leave
0579+  0E5C 09          	ret
0580+  0E5D             
0581+  0E5D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0582+  0E5D             ; input decimal number
0583+  0E5D             ; result in A
0584+  0E5D             ; 655'\0'
0585+  0E5D             ; low--------high
0586+  0E5D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  0E5D             scan_u16d:
0588+  0E5D F8 08 00    	enter 8
0589+  0E60 E2          	push si
0590+  0E61 D8          	push b
0591+  0E62 D9          	push c
0592+  0E63 DA          	push d
0593+  0E64 FA F9 FF    	lea d, [bp +- 7]
0594+  0E67 07 30 0C    	call gets
0595+  0E6A 07 5E 0B    	call strlen			; get string length in C
0596+  0E6D 7E          	dec c
0597+  0E6E FD 4E       	mov si, d
0598+  0E70 12          	mov a, c
0599+  0E71 FD 99       	shl a
0600+  0E73 3B C6 0B    	mov d, table_power
0601+  0E76 59          	add d, a
0602+  0E77 38 00 00    	mov c, 0
0603+  0E7A             mul_loop:
0604+  0E7A F6          	lodsb			; load ASCII to al
0605+  0E7B B9 00       	cmp al, 0
0606+  0E7D C6 90 0E    	je mul_exit
0607+  0E80 6F 30       	sub al, $30		; make into integer
0608+  0E82 22 00       	mov ah, 0
0609+  0E84 2A          	mov b, [d]
0610+  0E85 AC          	mul a, b			; result in B since it fits in 16bits
0611+  0E86 11          	mov a, b
0612+  0E87 28          	mov b, c
0613+  0E88 54          	add a, b
0614+  0E89 39          	mov c, a
0615+  0E8A 63 02 00    	sub d, 2
0616+  0E8D 0A 7A 0E    	jmp mul_loop
0617+  0E90             mul_exit:
0618+  0E90 12          	mov a, c
0619+  0E91 E7          	pop d
0620+  0E92 E6          	pop c
0621+  0E93 E5          	pop b
0622+  0E94 EF          	pop si
0623+  0E95 F9          	leave
0624+  0E96 09          	ret
0489   0E97             .include "ctype.asm"
0001+  0E97             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0E97             ; ctype.s
0003+  0E97             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0E97             
0005+  0E97             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  0E97             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  0E97             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  0E97             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  0E97             ;; characters are supported.
0010+  0E97             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  0E97             ;; isalnum 
0012+  0E97             ;; isalpha 
0013+  0E97             ;; islower 
0014+  0E97             ;; isupper 
0015+  0E97             ;; isdigit 
0016+  0E97             ;; isxdigit
0017+  0E97             ;; iscntrl 
0018+  0E97             ;; isgraph 
0019+  0E97             ;; isspace 
0020+  0E97             ;; isblank 
0021+  0E97             ;; isprint 
0022+  0E97             ;; ispunct 
0023+  0E97             ;; tolower 
0024+  0E97             ;; toupper
0025+  0E97             
0026+  0E97             
0027+  0E97             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  0E97             ;; IS ALPHANUMERIC
0029+  0E97             ;; sets ZF according with result
0030+  0E97             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  0E97             isalnum:
0032+  0E97 07 B4 0E    	call isalpha
0033+  0E9A C6 A0 0E    	je isalnum_exit
0034+  0E9D 07 A1 0E    	call isdigit
0035+  0EA0             isalnum_exit:
0036+  0EA0 09          	ret	
0037+  0EA1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0EA1             ;; IS DIGIT
0039+  0EA1             ;; sets ZF according with result
0040+  0EA1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  0EA1             isdigit:
0042+  0EA1 DB          	push al
0043+  0EA2 B9 30       	cmp al, '0'
0044+  0EA4 C8 B0 0E    	jlu isdigit_false
0045+  0EA7 B9 39       	cmp al, '9'
0046+  0EA9 D1 B0 0E    	jgu isdigit_false
0047+  0EAC 87 00       	and al, 0	; set ZF
0048+  0EAE E8          	pop al
0049+  0EAF 09          	ret
0050+  0EB0             isdigit_false:
0051+  0EB0 8B 01       	or al, 1	; clear ZF
0052+  0EB2 E8          	pop al
0053+  0EB3 09          	ret	
0054+  0EB4             	
0055+  0EB4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  0EB4             ;; IS ALPHA
0057+  0EB4             ;; sets ZF according with result
0058+  0EB4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  0EB4             isalpha:
0060+  0EB4 DB          	push al
0061+  0EB5 B9 5F       	cmp al, '_'
0062+  0EB7 C6 D7 0E    	je isalpha_true
0063+  0EBA B9 2E       	cmp al, '.'
0064+  0EBC C6 D7 0E    	je isalpha_true
0065+  0EBF B9 41       	cmp al, 'A'
0066+  0EC1 C8 D3 0E    	jlu isalpha_false
0067+  0EC4 B9 7A       	cmp al, 'z'
0068+  0EC6 D1 D3 0E    	jgu isalpha_false
0069+  0EC9 B9 5A       	cmp al, 'Z'
0070+  0ECB D0 D7 0E    	jleu isalpha_true
0071+  0ECE B9 61       	cmp al, 'a'
0072+  0ED0 C9 D7 0E    	jgeu isalpha_true
0073+  0ED3             isalpha_false:
0074+  0ED3 8B 01       	or al, 1	; clear ZF
0075+  0ED5 E8          	pop al
0076+  0ED6 09          	ret
0077+  0ED7             isalpha_true:
0078+  0ED7 87 00       	and al, 0	; set ZF
0079+  0ED9 E8          	pop al
0080+  0EDA 09          	ret
0081+  0EDB             
0082+  0EDB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  0EDB             ;; IS PATH-ALPHA
0084+  0EDB             ;; sets ZF according with result
0085+  0EDB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  0EDB             ispath:
0087+  0EDB DB          	push al
0088+  0EDC 07 A1 0E    	call isdigit
0089+  0EDF C6 09 0F    	je ispath_true
0090+  0EE2 B9 5F       	cmp al, '_'
0091+  0EE4 C6 09 0F    	je ispath_true
0092+  0EE7 B9 2F       	cmp al, '/'
0093+  0EE9 C6 09 0F    	je ispath_true
0094+  0EEC B9 2E       	cmp al, '.'
0095+  0EEE C6 09 0F    	je ispath_true
0096+  0EF1 B9 41       	cmp al, 'A'
0097+  0EF3 C8 05 0F    	jlu ispath_false
0098+  0EF6 B9 7A       	cmp al, 'z'
0099+  0EF8 D1 05 0F    	jgu ispath_false
0100+  0EFB B9 5A       	cmp al, 'Z'
0101+  0EFD D0 09 0F    	jleu ispath_true
0102+  0F00 B9 61       	cmp al, 'a'
0103+  0F02 C9 09 0F    	jgeu ispath_true
0104+  0F05             ispath_false:
0105+  0F05 8B 01       	or al, 1	; clear ZF
0106+  0F07 E8          	pop al
0107+  0F08 09          	ret
0108+  0F09             ispath_true:
0109+  0F09 87 00       	and al, 0	; set ZF
0110+  0F0B E8          	pop al
0111+  0F0C 09          	ret
0112+  0F0D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  0F0D             ;; IS SPACE
0114+  0F0D             ;; sets ZF according with result
0115+  0F0D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  0F0D             isspace:
0117+  0F0D B9 20       	cmp al, $20		; ' '
0118+  0F0F C6 23 0F    	je isspace_exit
0119+  0F12 B9 09       	cmp al, $09		; '\t'
0120+  0F14 C6 23 0F    	je isspace_exit
0121+  0F17 B9 0A       	cmp al, $0A		; '\n'
0122+  0F19 C6 23 0F    	je isspace_exit
0123+  0F1C B9 0D       	cmp al, $0D		; '\r'
0124+  0F1E C6 23 0F    	je isspace_exit
0125+  0F21 B9 0B       	cmp al, $0B		; '\v'
0126+  0F23             isspace_exit:
0127+  0F23 09          	ret	
0128+  0F24             
0129+  0F24             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0F24             ; TO LOWER
0131+  0F24             ; input in AL
0132+  0F24             ; output in AL
0133+  0F24             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  0F24             to_lower:
0135+  0F24 B9 5A       	cmp al, 'Z'
0136+  0F26 D1 2B 0F    	jgu to_lower_ret
0137+  0F29 6A 20       	add al, $20				; convert to lower case
0138+  0F2B             to_lower_ret:
0139+  0F2B 09          	ret
0140+  0F2C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  0F2C             ; TO UPPER
0142+  0F2C             ; input in AL
0143+  0F2C             ; output in AL
0144+  0F2C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  0F2C             to_upper:
0146+  0F2C B9 61       	cmp al, 'a'
0147+  0F2E C8 33 0F    	jlu to_upper_ret
0148+  0F31 6F 20       	sub al, $20			; convert to upper case
0149+  0F33             to_upper_ret:
0150+  0F33 09          	ret
0151+  0F34             
0490   0F34             .include "token.asm"
0001+  0F34             TOKTYP_IDENTIFIER	.equ 0
0002+  0F34             TOKTYP_KEYWORD		.equ 1
0003+  0F34             TOKTYP_DELIMITER	.equ 2
0004+  0F34             TOKTYP_STRING		.equ 3
0005+  0F34             TOKTYP_CHAR			.equ 4
0006+  0F34             TOKTYP_NUMERIC		.equ 5
0007+  0F34             TOKTYP_END			.equ 6
0008+  0F34             
0009+  0F34             TOK_NULL			.equ 0
0010+  0F34             TOK_FSLASH			.equ 1
0011+  0F34             TOK_TIMES 			.equ 2
0012+  0F34             TOK_PLUS 			.equ 3
0013+  0F34             TOK_MINUS 			.equ 4
0014+  0F34             TOK_DOT				.equ 5
0015+  0F34             TOK_SEMI			.equ 6
0016+  0F34             TOK_ANGLE			.equ 7
0017+  0F34             TOK_TILDE			.equ 8
0018+  0F34             TOK_EQUAL			.equ 9
0019+  0F34             TOK_COLON			.equ 10
0020+  0F34             TOK_COMMA			.equ 11
0021+  0F34             
0022+  0F34             TOK_END				.equ 20
0023+  0F34             
0024+  0F34             
0025+  0F34             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  0F34             ;; read a full command argment from shell input buffer
0027+  0F34             ;; argument is written into tokstr
0028+  0F34             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  0F34             get_arg:
0030+  0F34 D7          	push a
0031+  0F35 E2          	push si
0032+  0F36 E3          	push di
0033+  0F37 19 00       	mov al, 0
0034+  0F39 3D 62 11    	mov [tokstr], al			; nullify tokstr string
0035+  0F3C 14 5E 11    	mov a, [prog]
0036+  0F3F 4D          	mov si, a
0037+  0F40 FD 4F 62 11 	mov di, tokstr
0038+  0F44             get_arg_skip_spaces:
0039+  0F44 F6          	lodsb
0040+  0F45 07 0D 0F    	call isspace
0041+  0F48 C6 44 0F    	je get_arg_skip_spaces
0042+  0F4B             get_arg_L0:
0043+  0F4B B9 3B       	cmp al, $3B				; check if is ';'
0044+  0F4D C6 5A 0F    	je get_arg_end
0045+  0F50 B9 00       	cmp al, 0
0046+  0F52 C6 5A 0F    	je get_arg_end			; check if end of input
0047+  0F55 F7          	stosb
0048+  0F56 F6          	lodsb
0049+  0F57 0A 4B 0F    	jmp get_arg_L0
0050+  0F5A             get_arg_end:
0051+  0F5A 19 00       	mov al, 0
0052+  0F5C F7          	stosb
0053+  0F5D D5 01 00    	sub si, 1
0054+  0F60 4E          	mov a, si
0055+  0F61 42 5E 11    	mov [prog], a		; update pointer
0056+  0F64 F0          	pop di
0057+  0F65 EF          	pop si
0058+  0F66 E4          	pop a
0059+  0F67 09          	ret
0060+  0F68             
0061+  0F68             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  0F68             ;; read a path formation from shell input buffer
0063+  0F68             ;; path is written into tokstr
0064+  0F68             ;; /usr/bin
0065+  0F68             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  0F68             get_path:
0067+  0F68 D7          	push a
0068+  0F69 E2          	push si
0069+  0F6A E3          	push di
0070+  0F6B 19 00       	mov al, 0
0071+  0F6D 3D 62 11    	mov [tokstr], al			; nullify tokstr string
0072+  0F70 14 5E 11    	mov a, [prog]
0073+  0F73 4D          	mov si, a
0074+  0F74 FD 4F 62 11 	mov di, tokstr
0075+  0F78             get_path_skip_spaces:
0076+  0F78 F6          	lodsb
0077+  0F79 07 0D 0F    	call isspace
0078+  0F7C C6 78 0F    	je get_path_skip_spaces
0079+  0F7F             get_path_is_pathchar:
0080+  0F7F F7          	stosb
0081+  0F80 F6          	lodsb
0082+  0F81 07 97 0E    	call isalnum			;check if is alphanumeric
0083+  0F84 C6 7F 0F    	je get_path_is_pathchar
0084+  0F87 B9 2F       	cmp al, '/'				; check if is '/'
0085+  0F89 C6 7F 0F    	je get_path_is_pathchar
0086+  0F8C 19 00       	mov al, 0
0087+  0F8E F7          	stosb
0088+  0F8F D5 01 00    	sub si, 1
0089+  0F92 4E          	mov a, si
0090+  0F93 42 5E 11    	mov [prog], a		; update pointer
0091+  0F96             get_path_end:
0092+  0F96 F0          	pop di
0093+  0F97 EF          	pop si
0094+  0F98 E4          	pop a
0095+  0F99 09          	ret
0096+  0F9A             
0097+  0F9A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  0F9A             ;; read a line
0099+  0F9A             ;; line is written into tokstr
0100+  0F9A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  0F9A             get_line:
0102+  0F9A D7          	push a
0103+  0F9B E2          	push si
0104+  0F9C E3          	push di
0105+  0F9D 19 00       	mov al, 0
0106+  0F9F 3D 62 11    	mov [tokstr], al			; nullify tokstr string
0107+  0FA2 14 5E 11    	mov a, [prog]
0108+  0FA5 4D          	mov si, a
0109+  0FA6 FD 4F 62 11 	mov di, tokstr
0110+  0FAA             get_line_L0:
0111+  0FAA F6          	lodsb
0112+  0FAB B9 0A       	cmp al, $0A		; check for new line
0113+  0FAD C6 B4 0F    	je get_line_exit
0114+  0FB0 F7          	stosb
0115+  0FB1 0A AA 0F    	jmp get_line_L0
0116+  0FB4             get_line_exit:
0117+  0FB4 19 00       	mov al, 0
0118+  0FB6 F7          	stosb
0119+  0FB7 4E          	mov a, si
0120+  0FB8 42 5E 11    	mov [prog], a		; update pointer
0121+  0FBB F0          	pop di
0122+  0FBC EF          	pop si
0123+  0FBD E4          	pop a
0124+  0FBE 09          	ret
0125+  0FBF             
0126+  0FBF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  0FBF             ;; token parser
0128+  0FBF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  0FBF             get_token:
0130+  0FBF D7          	push a
0131+  0FC0 DA          	push d
0132+  0FC1 E2          	push si
0133+  0FC2 E3          	push di
0134+  0FC3 19 00       	mov al, 0
0135+  0FC5 3D 62 11    	mov [tokstr], al			; nullify tokstr string
0136+  0FC8 19 00       	mov al, TOK_NULL
0137+  0FCA 3D 61 11    	mov [tok], al				; nullify token
0138+  0FCD 14 5E 11    	mov a, [prog]
0139+  0FD0 4D          	mov si, a
0140+  0FD1 FD 4F 62 11 	mov di, tokstr
0141+  0FD5             get_tok_skip_spaces:
0142+  0FD5 F6          	lodsb
0143+  0FD6 07 0D 0F    	call isspace
0144+  0FD9 C6 D5 0F    	je get_tok_skip_spaces
0145+  0FDC B9 00       	cmp al, 0			; check for end of input (NULL)
0146+  0FDE C6 C3 10    	je get_token_end
0147+  0FE1 B9 23       	cmp al, '#'			; comments!
0148+  0FE3 C6 F1 10    	je get_tok_comment
0149+  0FE6 07 97 0E    	call isalnum
0150+  0FE9 C6 D0 10    	jz is_alphanumeric
0151+  0FEC             ; other token types
0152+  0FEC             get_token_slash:
0153+  0FEC B9 2F       	cmp al, '/'				; check if '/'
0154+  0FEE C7 06 10    	jne get_token_minus
0155+  0FF1 F7          	stosb					; store '/' into token string
0156+  0FF2 19 00       	mov al, 0
0157+  0FF4 F7          	stosb					; terminate token string
0158+  0FF5 19 01       	mov al, TOK_FSLASH
0159+  0FF7 3D 61 11    	mov [tok], al			
0160+  0FFA 19 02       	mov al, TOKTYP_DELIMITER
0161+  0FFC 3D 60 11    	mov [toktyp], al
0162+  0FFF 4E          	mov a, si
0163+  1000 42 5E 11    	mov [prog], a		; update pointer
0164+  1003 0A EC 10    	jmp get_token_return
0165+  1006             get_token_minus:
0166+  1006 B9 2D       	cmp al, '-'				; check if '-'
0167+  1008 C7 20 10    	jne get_token_comma
0168+  100B F7          	stosb					; store '-' into token string
0169+  100C 19 00       	mov al, 0
0170+  100E F7          	stosb					; terminate token string
0171+  100F 19 04       	mov al, TOK_MINUS
0172+  1011 3D 61 11    	mov [tok], al			
0173+  1014 19 02       	mov al, TOKTYP_DELIMITER
0174+  1016 3D 60 11    	mov [toktyp], al
0175+  1019 4E          	mov a, si
0176+  101A 42 5E 11    	mov [prog], a		; update pointer
0177+  101D 0A EC 10    	jmp get_token_return
0178+  1020             get_token_comma:
0179+  1020 B9 2C       	cmp al, ','				; check if ','
0180+  1022 C7 3A 10    	jne get_token_semi
0181+  1025 F7          	stosb					; store ',' into token string
0182+  1026 19 00       	mov al, 0
0183+  1028 F7          	stosb					; terminate token string
0184+  1029 19 0B       	mov al, TOK_COMMA
0185+  102B 3D 61 11    	mov [tok], al			
0186+  102E 19 02       	mov al, TOKTYP_DELIMITER
0187+  1030 3D 60 11    	mov [toktyp], al
0188+  1033 4E          	mov a, si
0189+  1034 42 5E 11    	mov [prog], a		; update pointer
0190+  1037 0A EC 10    	jmp get_token_return
0191+  103A             get_token_semi:
0192+  103A B9 3B       	cmp al, $3B				; check if ';'
0193+  103C C7 54 10    	jne get_token_colon
0194+  103F F7          	stosb					; store ';' into token string
0195+  1040 19 00       	mov al, 0
0196+  1042 F7          	stosb					; terminate token string
0197+  1043 19 06       	mov al, TOK_SEMI
0198+  1045 3D 61 11    	mov [tok], al			
0199+  1048 19 02       	mov al, TOKTYP_DELIMITER
0200+  104A 3D 60 11    	mov [toktyp], al
0201+  104D 4E          	mov a, si
0202+  104E 42 5E 11    	mov [prog], a		; update pointer
0203+  1051 0A EC 10    	jmp get_token_return
0204+  1054             get_token_colon:
0205+  1054 B9 3A       	cmp al, $3A				; check if ':'
0206+  1056 C7 6E 10    	jne get_token_angle
0207+  1059 F7          	stosb					; store ':' into token string
0208+  105A 19 00       	mov al, 0
0209+  105C F7          	stosb					; terminate token string
0210+  105D 19 0A       	mov al, TOK_COLON
0211+  105F 3D 61 11    	mov [tok], al			
0212+  1062 19 02       	mov al, TOKTYP_DELIMITER
0213+  1064 3D 60 11    	mov [toktyp], al
0214+  1067 4E          	mov a, si
0215+  1068 42 5E 11    	mov [prog], a		; update pointer
0216+  106B 0A EC 10    	jmp get_token_return
0217+  106E             get_token_angle:
0218+  106E B9 3E       	cmp al, $3E				; check if '>'
0219+  1070 C7 88 10    	jne get_token_tilde
0220+  1073 F7          	stosb					; store '>' into token string
0221+  1074 19 00       	mov al, 0
0222+  1076 F7          	stosb					; terminate token string
0223+  1077 19 07       	mov al, TOK_ANGLE
0224+  1079 3D 61 11    	mov [tok], al			
0225+  107C 19 02       	mov al, TOKTYP_DELIMITER
0226+  107E 3D 60 11    	mov [toktyp], al
0227+  1081 4E          	mov a, si
0228+  1082 42 5E 11    	mov [prog], a		; update pointer
0229+  1085 0A EC 10    	jmp get_token_return
0230+  1088             get_token_tilde:
0231+  1088 B9 7E       	cmp al, '~'				; check if '~'
0232+  108A C7 A2 10    	jne get_token_equal
0233+  108D F7          	stosb					; store '~' into token string
0234+  108E 19 00       	mov al, 0
0235+  1090 F7          	stosb					; terminate token string
0236+  1091 19 08       	mov al, TOK_TILDE
0237+  1093 3D 61 11    	mov [tok], al			
0238+  1096 19 02       	mov al, TOKTYP_DELIMITER
0239+  1098 3D 60 11    	mov [toktyp], al
0240+  109B 4E          	mov a, si
0241+  109C 42 5E 11    	mov [prog], a		; update pointer
0242+  109F 0A EC 10    	jmp get_token_return
0243+  10A2             get_token_equal:
0244+  10A2 B9 3D       	cmp al, '='				; check if '='
0245+  10A4 C7 BC 10    	jne get_token_skip
0246+  10A7 F7          	stosb					; store '=' into token string
0247+  10A8 19 00       	mov al, 0
0248+  10AA F7          	stosb					; terminate token string
0249+  10AB 19 09       	mov al, TOK_EQUAL
0250+  10AD 3D 61 11    	mov [tok], al			
0251+  10B0 19 02       	mov al, TOKTYP_DELIMITER
0252+  10B2 3D 60 11    	mov [toktyp], al
0253+  10B5 4E          	mov a, si
0254+  10B6 42 5E 11    	mov [prog], a		; update pointer
0255+  10B9 0A EC 10    	jmp get_token_return
0256+  10BC             get_token_skip:
0257+  10BC 4E          	mov a, si
0258+  10BD 42 5E 11    	mov [prog], a		; update pointer
0259+  10C0 0A EC 10    	jmp get_token_return
0260+  10C3             get_token_end:				; end of file token
0261+  10C3 19 14       	mov al, TOK_END
0262+  10C5 3D 61 11    	mov [tok], al
0263+  10C8 19 06       	mov al, TOKTYP_END
0264+  10CA 3D 60 11    	mov [toktyp], al
0265+  10CD 0A EC 10    	jmp get_token_return
0266+  10D0             is_alphanumeric:
0267+  10D0 F7          	stosb
0268+  10D1 F6          	lodsb
0269+  10D2 07 97 0E    	call isalnum			;check if is alphanumeric
0270+  10D5 C6 D0 10    	jz is_alphanumeric
0271+  10D8 B9 2E       	cmp al, $2E				; check if is '.'
0272+  10DA C6 D0 10    	je is_alphanumeric
0273+  10DD 19 00       	mov al, 0
0274+  10DF F7          	stosb
0275+  10E0 19 00       	mov al, TOKTYP_IDENTIFIER
0276+  10E2 3D 60 11    	mov [toktyp], al
0277+  10E5 D5 01 00    	sub si, 1
0278+  10E8 4E          	mov a, si
0279+  10E9 42 5E 11    	mov [prog], a		; update pointer
0280+  10EC             get_token_return:
0281+  10EC F0          	pop di
0282+  10ED EF          	pop si
0283+  10EE E7          	pop d
0284+  10EF E4          	pop a
0285+  10F0 09          	ret
0286+  10F1             get_tok_comment:
0287+  10F1 F6          	lodsb
0288+  10F2 B9 0A       	cmp al, $0A			; new line
0289+  10F4 C7 F1 10    	jne get_tok_comment
0290+  10F7 0A D5 0F    	jmp get_tok_skip_spaces
0291+  10FA             
0292+  10FA             
0293+  10FA             get_number:
0294+  10FA D7          	push a
0295+  10FB DA          	push d
0296+  10FC E2          	push si
0297+  10FD E3          	push di
0298+  10FE 19 00       	mov al, 0
0299+  1100 3D 62 11    	mov [tokstr], al			; nullify tokstr string
0300+  1103 19 00       	mov al, TOK_NULL
0301+  1105 3D 61 11    	mov [tok], al				; nullify token
0302+  1108 14 5E 11    	mov a, [prog]
0303+  110B 4D          	mov si, a
0304+  110C FD 4F 62 11 	mov di, tokstr
0305+  1110             get_number_skip_spaces:
0306+  1110 F6          	lodsb
0307+  1111 07 0D 0F    	call isspace
0308+  1114 C6 10 11    	je get_number_skip_spaces
0309+  1117 B9 00       	cmp al, 0			; check for end of input (NULL)
0310+  1119 C7 29 11    	jne get_number_L0
0311+  111C 19 14       	mov al, TOK_END
0312+  111E 3D 61 11    	mov [tok], al
0313+  1121 19 06       	mov al, TOKTYP_END
0314+  1123 3D 60 11    	mov [toktyp], al
0315+  1126 0A 40 11    	jmp get_number_return
0316+  1129             get_number_L0:
0317+  1129 F7          	stosb
0318+  112A F6          	lodsb
0319+  112B 07 A1 0E    	call isdigit			;check if is numeric
0320+  112E C6 29 11    	jz get_number_L0
0321+  1131 19 00       	mov al, 0
0322+  1133 F7          	stosb
0323+  1134 19 05       	mov al, TOKTYP_NUMERIC
0324+  1136 3D 60 11    	mov [toktyp], al
0325+  1139 D5 01 00    	sub si, 1
0326+  113C 4E          	mov a, si
0327+  113D 42 5E 11    	mov [prog], a		; update pointer
0328+  1140             get_number_return:
0329+  1140 F0          	pop di
0330+  1141 EF          	pop si
0331+  1142 E7          	pop d
0332+  1143 E4          	pop a
0333+  1144 09          	ret
0334+  1145             
0335+  1145             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  1145             ;; PUT BACK TOKEN
0337+  1145             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
0338+  1145             putback:
0339+  1145 D7          	push a
0340+  1146 E2          	push si
0341+  1147 FD 4D 62 11 	mov si, tokstr	
0342+  114B             putback_loop:
0343+  114B F6          	lodsb
0344+  114C B9 00       	cmp al, 0
0345+  114E C6 5B 11    	je putback_end
0346+  1151 14 5E 11    	mov a, [prog]
0347+  1154 7D          	dec a
0348+  1155 42 5E 11    	mov [prog], a			; update pointer
0349+  1158 0A 4B 11    	jmp putback_loop
0350+  115B             putback_end:
0351+  115B EF          	pop si
0352+  115C E4          	pop a
0353+  115D 09          	ret
0354+  115E             
0355+  115E             
0356+  115E             
0357+  115E             
0358+  115E 00 00       prog:		.dw 0			; pointer to current position in buffer
0359+  1160             
0360+  1160 00          toktyp: 	.db 0			; token type symbol
0361+  1161 00          tok:		.db 0			; current token symbol
0362+  1162 00 00 00 00 tokstr:		.fill 256, 0	; token as a string
0362+  1166 00 00 00 00 
0362+  116A 00 00 00 00 
0362+  116E 00 00 00 00 
0362+  1172 00 00 00 00 
0362+  1176 00 00 00 00 
0362+  117A 00 00 00 00 
0362+  117E 00 00 00 00 
0362+  1182 00 00 00 00 
0362+  1186 00 00 00 00 
0362+  118A 00 00 00 00 
0362+  118E 00 00 00 00 
0362+  1192 00 00 00 00 
0362+  1196 00 00 00 00 
0362+  119A 00 00 00 00 
0362+  119E 00 00 00 00 
0362+  11A2 00 00 00 00 
0362+  11A6 00 00 00 00 
0362+  11AA 00 00 00 00 
0362+  11AE 00 00 00 00 
0362+  11B2 00 00 00 00 
0362+  11B6 00 00 00 00 
0362+  11BA 00 00 00 00 
0362+  11BE 00 00 00 00 
0362+  11C2 00 00 00 00 
0362+  11C6 00 00 00 00 
0362+  11CA 00 00 00 00 
0362+  11CE 00 00 00 00 
0362+  11D2 00 00 00 00 
0362+  11D6 00 00 00 00 
0362+  11DA 00 00 00 00 
0362+  11DE 00 00 00 00 
0362+  11E2 00 00 00 00 
0362+  11E6 00 00 00 00 
0362+  11EA 00 00 00 00 
0362+  11EE 00 00 00 00 
0362+  11F2 00 00 00 00 
0362+  11F6 00 00 00 00 
0362+  11FA 00 00 00 00 
0362+  11FE 00 00 00 00 
0362+  1202 00 00 00 00 
0362+  1206 00 00 00 00 
0362+  120A 00 00 00 00 
0362+  120E 00 00 00 00 
0362+  1212 00 00 00 00 
0362+  1216 00 00 00 00 
0362+  121A 00 00 00 00 
0362+  121E 00 00 00 00 
0362+  1222 00 00 00 00 
0362+  1226 00 00 00 00 
0362+  122A 00 00 00 00 
0362+  122E 00 00 00 00 
0362+  1232 00 00 00 00 
0362+  1236 00 00 00 00 
0362+  123A 00 00 00 00 
0362+  123E 00 00 00 00 
0362+  1242 00 00 00 00 
0362+  1246 00 00 00 00 
0362+  124A 00 00 00 00 
0362+  124E 00 00 00 00 
0362+  1252 00 00 00 00 
0362+  1256 00 00 00 00 
0362+  125A 00 00 00 00 
0362+  125E 00 00 00 00 
0491   1262             
0492   1262 00 00 00 00 temp_data1:        .fill 256, 0
0492   1266 00 00 00 00 
0492   126A 00 00 00 00 
0492   126E 00 00 00 00 
0492   1272 00 00 00 00 
0492   1276 00 00 00 00 
0492   127A 00 00 00 00 
0492   127E 00 00 00 00 
0492   1282 00 00 00 00 
0492   1286 00 00 00 00 
0492   128A 00 00 00 00 
0492   128E 00 00 00 00 
0492   1292 00 00 00 00 
0492   1296 00 00 00 00 
0492   129A 00 00 00 00 
0492   129E 00 00 00 00 
0492   12A2 00 00 00 00 
0492   12A6 00 00 00 00 
0492   12AA 00 00 00 00 
0492   12AE 00 00 00 00 
0492   12B2 00 00 00 00 
0492   12B6 00 00 00 00 
0492   12BA 00 00 00 00 
0492   12BE 00 00 00 00 
0492   12C2 00 00 00 00 
0492   12C6 00 00 00 00 
0492   12CA 00 00 00 00 
0492   12CE 00 00 00 00 
0492   12D2 00 00 00 00 
0492   12D6 00 00 00 00 
0492   12DA 00 00 00 00 
0492   12DE 00 00 00 00 
0492   12E2 00 00 00 00 
0492   12E6 00 00 00 00 
0492   12EA 00 00 00 00 
0492   12EE 00 00 00 00 
0492   12F2 00 00 00 00 
0492   12F6 00 00 00 00 
0492   12FA 00 00 00 00 
0492   12FE 00 00 00 00 
0492   1302 00 00 00 00 
0492   1306 00 00 00 00 
0492   130A 00 00 00 00 
0492   130E 00 00 00 00 
0492   1312 00 00 00 00 
0492   1316 00 00 00 00 
0492   131A 00 00 00 00 
0492   131E 00 00 00 00 
0492   1322 00 00 00 00 
0492   1326 00 00 00 00 
0492   132A 00 00 00 00 
0492   132E 00 00 00 00 
0492   1332 00 00 00 00 
0492   1336 00 00 00 00 
0492   133A 00 00 00 00 
0492   133E 00 00 00 00 
0492   1342 00 00 00 00 
0492   1346 00 00 00 00 
0492   134A 00 00 00 00 
0492   134E 00 00 00 00 
0492   1352 00 00 00 00 
0492   1356 00 00 00 00 
0492   135A 00 00 00 00 
0492   135E 00 00 00 00 
0493   1362 00 00 00 00 temp_data:        .fill 512, 0
0493   1366 00 00 00 00 
0493   136A 00 00 00 00 
0493   136E 00 00 00 00 
0493   1372 00 00 00 00 
0493   1376 00 00 00 00 
0493   137A 00 00 00 00 
0493   137E 00 00 00 00 
0493   1382 00 00 00 00 
0493   1386 00 00 00 00 
0493   138A 00 00 00 00 
0493   138E 00 00 00 00 
0493   1392 00 00 00 00 
0493   1396 00 00 00 00 
0493   139A 00 00 00 00 
0493   139E 00 00 00 00 
0493   13A2 00 00 00 00 
0493   13A6 00 00 00 00 
0493   13AA 00 00 00 00 
0493   13AE 00 00 00 00 
0493   13B2 00 00 00 00 
0493   13B6 00 00 00 00 
0493   13BA 00 00 00 00 
0493   13BE 00 00 00 00 
0493   13C2 00 00 00 00 
0493   13C6 00 00 00 00 
0493   13CA 00 00 00 00 
0493   13CE 00 00 00 00 
0493   13D2 00 00 00 00 
0493   13D6 00 00 00 00 
0493   13DA 00 00 00 00 
0493   13DE 00 00 00 00 
0493   13E2 00 00 00 00 
0493   13E6 00 00 00 00 
0493   13EA 00 00 00 00 
0493   13EE 00 00 00 00 
0493   13F2 00 00 00 00 
0493   13F6 00 00 00 00 
0493   13FA 00 00 00 00 
0493   13FE 00 00 00 00 
0493   1402 00 00 00 00 
0493   1406 00 00 00 00 
0493   140A 00 00 00 00 
0493   140E 00 00 00 00 
0493   1412 00 00 00 00 
0493   1416 00 00 00 00 
0493   141A 00 00 00 00 
0493   141E 00 00 00 00 
0493   1422 00 00 00 00 
0493   1426 00 00 00 00 
0493   142A 00 00 00 00 
0493   142E 00 00 00 00 
0493   1432 00 00 00 00 
0493   1436 00 00 00 00 
0493   143A 00 00 00 00 
0493   143E 00 00 00 00 
0493   1442 00 00 00 00 
0493   1446 00 00 00 00 
0493   144A 00 00 00 00 
0493   144E 00 00 00 00 
0493   1452 00 00 00 00 
0493   1456 00 00 00 00 
0493   145A 00 00 00 00 
0493   145E 00 00 00 00 
0493   1462 00 00 00 00 
0493   1466 00 00 00 00 
0493   146A 00 00 00 00 
0493   146E 00 00 00 00 
0493   1472 00 00 00 00 
0493   1476 00 00 00 00 
0493   147A 00 00 00 00 
0493   147E 00 00 00 00 
0493   1482 00 00 00 00 
0493   1486 00 00 00 00 
0493   148A 00 00 00 00 
0493   148E 00 00 00 00 
0493   1492 00 00 00 00 
0493   1496 00 00 00 00 
0493   149A 00 00 00 00 
0493   149E 00 00 00 00 
0493   14A2 00 00 00 00 
0493   14A6 00 00 00 00 
0493   14AA 00 00 00 00 
0493   14AE 00 00 00 00 
0493   14B2 00 00 00 00 
0493   14B6 00 00 00 00 
0493   14BA 00 00 00 00 
0493   14BE 00 00 00 00 
0493   14C2 00 00 00 00 
0493   14C6 00 00 00 00 
0493   14CA 00 00 00 00 
0493   14CE 00 00 00 00 
0493   14D2 00 00 00 00 
0493   14D6 00 00 00 00 
0493   14DA 00 00 00 00 
0493   14DE 00 00 00 00 
0493   14E2 00 00 00 00 
0493   14E6 00 00 00 00 
0493   14EA 00 00 00 00 
0493   14EE 00 00 00 00 
0493   14F2 00 00 00 00 
0493   14F6 00 00 00 00 
0493   14FA 00 00 00 00 
0493   14FE 00 00 00 00 
0493   1502 00 00 00 00 
0493   1506 00 00 00 00 
0493   150A 00 00 00 00 
0493   150E 00 00 00 00 
0493   1512 00 00 00 00 
0493   1516 00 00 00 00 
0493   151A 00 00 00 00 
0493   151E 00 00 00 00 
0493   1522 00 00 00 00 
0493   1526 00 00 00 00 
0493   152A 00 00 00 00 
0493   152E 00 00 00 00 
0493   1532 00 00 00 00 
0493   1536 00 00 00 00 
0493   153A 00 00 00 00 
0493   153E 00 00 00 00 
0493   1542 00 00 00 00 
0493   1546 00 00 00 00 
0493   154A 00 00 00 00 
0493   154E 00 00 00 00 
0493   1552 00 00 00 00 
0493   1556 00 00 00 00 
0493   155A 00 00 00 00 
0493   155E 00 00 00 00 
0494   1562             shell_transient_area:  ; shell transient data area
0495   1562             
0496   1562             .end
tasm: Number of errors = 0
