0001   0000             .include "kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0002   0000             
0003   0400             .org PROC_TEXT_ORG			; origin at 1024
0004   0400             
0005   0400             WIDTH:	.equ	110		; must be even
0006   0400             
0007   0400             menu:
0008   0400 F8 00 02    	enter 512	
0009   0403             __get_math_choice:
0010   0403 3B 25 0A    	mov d, s_menu
0011   0406 07 1B 07    	call puts
0012   0409 FA 01 FE    	lea d, [bp +- 511]
0013   040C 07 E8 05    	call gets						; get choice
0014   040F 1E          	mov al, [d]
0015   0410 6F 30       	sub al, 30h
0016   0412 B9 02       	cmp al, 2
0017   0414 C6 29 04    	je _math_quit
0018   0417 D1 03 04    	jgu __get_math_choice				; check bounds
0019   041A FD 9E 01    	shl al, 1
0020   041D 22 00       	mov ah, 0
0021   041F FD 07 2C 04 	call [a + __math_menu_jump_table]
0022   0423             
0023   0423 07 C8 06    	call printnl
0024   0426 0A 03 04    	jmp __get_math_choice
0025   0429             _math_quit:
0026   0429 F9          	leave
0027   042A 05 0B       	syscall sys_terminate_proc
0028   042C             
0029   042C             ; ***********************************************************************************
0030   042C             ; MATHS JUMP TABLE
0031   042C             ; ***********************************************************************************
0032   042C             __math_menu_jump_table:
0033   042C 30 04       	.dw automaton
0034   042E B6 04       	.dw chg_rules
0035   0430             	
0036   0430             automaton:
0037   0430 F8 02 00    	enter 2
0038   0433 3B 56 08    	mov d, s_steps
0039   0436 07 1B 07    	call puts
0040   0439 07 15 08    	call scan_u16d
0041   043C 45 FF FF    	mov [bp +- 1], a
0042   043F 07 C8 06    	call printnl
0043   0442             ; reset initial state
0044   0442 FD 4D 60 08 	mov si, init_state
0045   0446 FD 4F CF 08 	mov di, prev_state
0046   044A 38 6F 00    	mov c, (WIDTH+1)
0047   044D FD F5       	rep movsb	
0048   044F             auto_L1:
0049   044F 38 01 00    	mov c, 1	
0050   0452 17 FF FF    	mov a, [bp + -1]
0051   0455 AF 00 00    	cmp a, 0
0052   0458 C6 B4 04    	je automaton_ret
0053   045B 7D          	dec a
0054   045C 45 FF FF    	mov [bp + -1], a
0055   045F             auto_L2:	
0056   045F 12          	mov a, c
0057   0460 3C          	mov d, a
0058   0461 FD 10       	cla
0059   0463 79          	inc d
0060   0464 33 CF 08    	mov bl, [d + prev_state]
0061   0467 6B          	add al, bl
0062   0468 7F          	dec d
0063   0469 33 CF 08    	mov bl, [d + prev_state]
0064   046C             	
0065   046C FD A0 01    	shl bl, 1
0066   046F 6B          	add al, bl
0067   0470 7F          	dec d
0068   0471 33 CF 08    	mov bl, [d + prev_state]
0069   0474 FD A0 02    	shl bl, 2
0070   0477 6B          	add al, bl					; now al has the number for the table
0071   0478             	
0072   0478 B7 1D 0A    	mov a, [a + automaton_table]
0073   047B 79          	inc d
0074   047C 3F 3E 09    	mov [d + state], al
0075   047F 78          	inc c
0076   0480 C2 6E 00    	cmp c, WIDTH
0077   0483 C8 5F 04    	jlu auto_L2
0078   0486             	
0079   0486             ; here we finished updating the current state, now we copy the current state to
0080   0486             ; the previous state
0081   0486 FD 4D 3E 09 	mov si, state
0082   048A FD 4F CF 08 	mov di, prev_state
0083   048E 38 6F 00    	mov c, (WIDTH+1)
0084   0491 FD F5       	rep movsb
0085   0493             	
0086   0493             ; now print the current state on the screen
0087   0493 FD 4D 3E 09 	mov si, state
0088   0497 FD 4F AD 09 	mov di, state_chars
0089   049B 38 6F 00    	mov c, (WIDTH+1)
0090   049E             state_convert_loop:
0091   049E F6          	lodsb
0092   049F 22 00       	mov ah, 0
0093   04A1 B7 5E 08    	mov a, [a + table_translate]
0094   04A4 F7          	stosb
0095   04A5 A9 9E 04    	loopc state_convert_loop
0096   04A8             	
0097   04A8 3B AD 09    	mov d, state_chars
0098   04AB 07 1B 07    	call puts
0099   04AE             	
0100   04AE 07 C8 06    	call printnl
0101   04B1 0A 4F 04    	jmp auto_L1	
0102   04B4             automaton_ret:
0103   04B4 F9          	leave
0104   04B5             	
0105   04B5 09          	ret
0106   04B6             	
0107   04B6             chg_rules:
0108   04B6 3B 4F 08    	mov d, s_rule
0109   04B9 07 1B 07    	call puts
0110   04BC 3B 00 00    	mov d, 0
0111   04BF 38 04 00    	mov c, 4
0112   04C2             chg_rule_L1:
0113   04C2 07 95 07    	call scan_u16x
0114   04C5 44 1D 0A    	mov [d + automaton_table], a
0115   04C8 58 02 00    	add d, 2
0116   04CB A9 C2 04    	loopc chg_rule_L1
0117   04CE 09          	ret
0118   04CF             	
0119   04CF             .include "stdio.asm"
0001+  04CF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  04CF             ; stdio.s
0003+  04CF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  04CF             .include "string.asm"
0001++ 04CF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 04CF             ; string.s
0003++ 04CF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 04CF             
0005++ 04CF             
0006++ 04CF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 04CF             ; strrev
0008++ 04CF             ; reverse a string
0009++ 04CF             ; D = string address
0010++ 04CF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 04CF             ; 01234
0012++ 04CF             strrev:
0013++ 04CF 4B          	pusha
0014++ 04D0 07 16 05    	call strlen	; length in C
0015++ 04D3 12          	mov a, c
0016++ 04D4 AF 01 00    	cmp a, 1
0017++ 04D7 D0 F1 04    	jleu strrev_end	; check string length. string len must be > 1
0018++ 04DA 7D          	dec a
0019++ 04DB FD 4E       	mov si, d	; beginning of string
0020++ 04DD FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 04DF 59          	add d, a	; end of string
0022++ 04E0 12          	mov a, c
0023++ 04E1 FD 9B       	shr a		; divide by 2
0024++ 04E3 39          	mov c, a	; C now counts the steps
0025++ 04E4             strrev_L0:
0026++ 04E4 32          	mov bl, [d]	; save load right-side char into BL
0027++ 04E5 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 04E6 3E          	mov [d], al	; store left char into right side
0029++ 04E7 1B          	mov al, bl
0030++ 04E8 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 04E9 7E          	dec c
0032++ 04EA 7F          	dec d
0033++ 04EB C2 00 00    	cmp c, 0
0034++ 04EE C7 E4 04    	jne strrev_L0
0035++ 04F1             strrev_end:
0036++ 04F1 4C          	popa
0037++ 04F2 09          	ret
0038++ 04F3             	
0039++ 04F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 04F3             ; strchr
0041++ 04F3             ; search string in D for char in AL
0042++ 04F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 04F3             strchr:
0044++ 04F3             strchr_L0:
0045++ 04F3 32          	mov bl, [d]
0046++ 04F4 C1 00       	cmp bl, 0
0047++ 04F6 C6 01 05    	je strchr_end
0048++ 04F9 BA          	cmp al, bl
0049++ 04FA C6 01 05    	je strchr_end
0050++ 04FD 79          	inc d
0051++ 04FE 0A F3 04    	jmp strchr_L0
0052++ 0501             strchr_end:
0053++ 0501 1B          	mov al, bl
0054++ 0502 09          	ret
0055++ 0503             
0056++ 0503             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0503             ; strstr
0058++ 0503             ; find sub-string
0059++ 0503             ; str1 in SI
0060++ 0503             ; str2 in DI
0061++ 0503             ; SI points to end of source string
0062++ 0503             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0503             strstr:
0064++ 0503 DB          	push al
0065++ 0504 DA          	push d
0066++ 0505 E3          	push di
0067++ 0506             strstr_loop:
0068++ 0506 F3          	cmpsb					; compare a byte of the strings
0069++ 0507 C7 12 05    	jne strstr_ret
0070++ 050A FC 00 00    	lea d, [di + 0]
0071++ 050D BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 050F C7 06 05    	jne strstr_loop				; equal chars but not at end
0073++ 0512             strstr_ret:
0074++ 0512 F0          	pop di
0075++ 0513 E7          	pop d
0076++ 0514 E8          	pop al
0077++ 0515 09          	ret
0078++ 0516             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0516             ; length of null terminated string
0080++ 0516             ; result in C
0081++ 0516             ; pointer in D
0082++ 0516             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0516             strlen:
0084++ 0516 DA          	push d
0085++ 0517 38 00 00    	mov c, 0
0086++ 051A             strlen_L1:
0087++ 051A BD 00       	cmp byte [d], 0
0088++ 051C C6 24 05    	je strlen_ret
0089++ 051F 79          	inc d
0090++ 0520 78          	inc c
0091++ 0521 0A 1A 05    	jmp strlen_L1
0092++ 0524             strlen_ret:
0093++ 0524 E7          	pop d
0094++ 0525 09          	ret
0095++ 0526             
0096++ 0526             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0526             ; STRCMP
0098++ 0526             ; compare two strings
0099++ 0526             ; str1 in SI
0100++ 0526             ; str2 in DI
0101++ 0526             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0526             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0526             strcmp:
0104++ 0526 DB          	push al
0105++ 0527 DA          	push d
0106++ 0528 E3          	push di
0107++ 0529 E2          	push si
0108++ 052A             strcmp_loop:
0109++ 052A F3          	cmpsb					; compare a byte of the strings
0110++ 052B C7 36 05    	jne strcmp_ret
0111++ 052E FB FF FF    	lea d, [si +- 1]
0112++ 0531 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0533 C7 2A 05    	jne strcmp_loop				; equal chars but not at end
0114++ 0536             strcmp_ret:
0115++ 0536 EF          	pop si
0116++ 0537 F0          	pop di
0117++ 0538 E7          	pop d
0118++ 0539 E8          	pop al
0119++ 053A 09          	ret
0120++ 053B             
0121++ 053B             
0122++ 053B             ; STRCPY
0123++ 053B             ; copy null terminated string from SI to DI
0124++ 053B             ; source in SI
0125++ 053B             ; destination in DI
0126++ 053B             strcpy:
0127++ 053B E2          	push si
0128++ 053C E3          	push di
0129++ 053D DB          	push al
0130++ 053E             strcpy_L1:
0131++ 053E F6          	lodsb
0132++ 053F F7          	stosb
0133++ 0540 B9 00       	cmp al, 0
0134++ 0542 C7 3E 05    	jne strcpy_L1
0135++ 0545             strcpy_end:
0136++ 0545 E8          	pop al
0137++ 0546 F0          	pop di
0138++ 0547 EF          	pop si
0139++ 0548 09          	ret
0140++ 0549             
0141++ 0549             ; STRCAT
0142++ 0549             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0549             ; source in SI
0144++ 0549             ; destination in DI
0145++ 0549             strcat:
0146++ 0549 E2          	push si
0147++ 054A E3          	push di
0148++ 054B D7          	push a
0149++ 054C DA          	push d
0150++ 054D 50          	mov a, di
0151++ 054E 3C          	mov d, a
0152++ 054F             strcat_goto_end_L1:
0153++ 054F BD 00       	cmp byte[d], 0
0154++ 0551 C6 58 05    	je strcat_start
0155++ 0554 79          	inc d
0156++ 0555 0A 4F 05    	jmp strcat_goto_end_L1
0157++ 0558             strcat_start:
0158++ 0558 FD 50       	mov di, d
0159++ 055A             strcat_L1:
0160++ 055A F6          	lodsb
0161++ 055B F7          	stosb
0162++ 055C B9 00       	cmp al, 0
0163++ 055E C7 5A 05    	jne strcat_L1
0164++ 0561             strcat_end:
0165++ 0561 E7          	pop d
0166++ 0562 E4          	pop a
0167++ 0563 F0          	pop di
0168++ 0564 EF          	pop si
0169++ 0565 09          	ret
0005+  0566             
0006+  0566 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  056A 34 35 36 37 
0006+  056E 38 39 41 42 
0006+  0572 43 44 45 46 
0007+  0576 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  057A 1B 5B 48 00 
0008+  057E             
0009+  057E 01 00       table_power:.dw 1
0010+  0580 0A 00       			.dw 10
0011+  0582 64 00       			.dw 100
0012+  0584 E8 03       			.dw 1000
0013+  0586 10 27       			.dw 10000
0014+  0588             
0015+  0588             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  0588             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  0588             ; ASCII in BL
0018+  0588             ; result in AL
0019+  0588             ; ascii for F = 0100 0110
0020+  0588             ; ascii for 9 = 0011 1001
0021+  0588             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  0588             hex_ascii_encode:
0023+  0588 1B          	mov al, bl
0024+  0589 93 40       	test al, $40				; test if letter or number
0025+  058B C7 91 05    	jnz hex_letter
0026+  058E 87 0F       	and al, $0F				; get number
0027+  0590 09          	ret
0028+  0591             hex_letter:
0029+  0591 87 0F       	and al, $0F				; get letter
0030+  0593 6A 09       	add al, 9
0031+  0595 09          	ret
0032+  0596             
0033+  0596             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  0596             ; ATOI
0035+  0596             ; 2 letter hex string in B
0036+  0596             ; 8bit integer returned in AL
0037+  0596             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0596             atoi:
0039+  0596 D8          	push b
0040+  0597 07 88 05    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  059A 30          	mov bl, bh
0042+  059B DB          	push al					; save a
0043+  059C 07 88 05    	call hex_ascii_encode
0044+  059F EA          	pop bl	
0045+  05A0 FD 9E 04    	shl al, 4
0046+  05A3 8C          	or al, bl
0047+  05A4 E5          	pop b
0048+  05A5 09          	ret	
0049+  05A6             
0050+  05A6             
0051+  05A6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  05A6             ; printf
0053+  05A6             ; no need for explanations!
0054+  05A6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  05A6             printf:
0056+  05A6 09          	ret
0057+  05A7             
0058+  05A7             
0059+  05A7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  05A7             ; scanf
0061+  05A7             ; no need for explanations!
0062+  05A7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  05A7             scanf:
0064+  05A7 09          	ret
0065+  05A8             
0066+  05A8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  05A8             ; ITOA
0068+  05A8             ; 8bit value in BL
0069+  05A8             ; 2 byte ASCII result in A
0070+  05A8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  05A8             itoa:
0072+  05A8 DA          	push d
0073+  05A9 D8          	push b
0074+  05AA A7 00       	mov bh, 0
0075+  05AC FD A4 04    	shr bl, 4	
0076+  05AF 74          	mov d, b
0077+  05B0 1F 66 05    	mov al, [d + s_hex_digits]
0078+  05B3 23          	mov ah, al
0079+  05B4             	
0080+  05B4 E5          	pop b
0081+  05B5 D8          	push b
0082+  05B6 A7 00       	mov bh, 0
0083+  05B8 FD 87 0F    	and bl, $0F
0084+  05BB 74          	mov d, b
0085+  05BC 1F 66 05    	mov al, [d + s_hex_digits]
0086+  05BF E5          	pop b
0087+  05C0 E7          	pop d
0088+  05C1 09          	ret
0089+  05C2             
0090+  05C2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  05C2             ; HEX STRING TO BINARY
0092+  05C2             ; di = destination address
0093+  05C2             ; si = source
0094+  05C2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  05C2             hex_to_int:
0096+  05C2             hex_to_int_L1:
0097+  05C2 F6          	lodsb					; load from [SI] to AL
0098+  05C3 B9 00       	cmp al, 0				; check if ASCII 0
0099+  05C5 C6 D2 05    	jz hex_to_int_ret
0100+  05C8 36          	mov bh, al
0101+  05C9 F6          	lodsb
0102+  05CA 2F          	mov bl, al
0103+  05CB 07 96 05    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  05CE F7          	stosb					; store AL to [DI]
0105+  05CF 0A C2 05    	jmp hex_to_int_L1
0106+  05D2             hex_to_int_ret:
0107+  05D2 09          	ret		
0108+  05D3             
0109+  05D3             
0110+  05D3             
0111+  05D3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  05D3             ; GETCHAR
0113+  05D3             ; char in ah
0114+  05D3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  05D3             getchar:
0116+  05D3 DB          	push al
0117+  05D4             getchar_retry:
0118+  05D4 FD 0C       	sti
0119+  05D6 19 01       	mov al, 1
0120+  05D8 05 03       	syscall sys_io			; receive in AH
0121+  05DA B9 00       	cmp al, 0			; check if any char was receive
0122+  05DC C6 D4 05    	je getchar_retry
0123+  05DF E8          	pop al
0124+  05E0 09          	ret
0125+  05E1             
0126+  05E1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  05E1             ; PUTCHAR
0128+  05E1             ; char in ah
0129+  05E1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  05E1             putchar:
0131+  05E1 D7          	push a
0132+  05E2 19 00       	mov al, 0
0133+  05E4 05 03       	syscall sys_io			; char in AH
0134+  05E6 E4          	pop a
0135+  05E7 09          	ret
0136+  05E8             
0137+  05E8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  05E8             ;; INPUT A STRING
0139+  05E8             ;; terminates with null
0140+  05E8             ;; pointer in D
0141+  05E8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  05E8             gets:
0143+  05E8 D7          	push a
0144+  05E9 DA          	push d
0145+  05EA             gets_loop:
0146+  05EA FD 0C       	sti
0147+  05EC 19 01       	mov al, 1
0148+  05EE 05 03       	syscall sys_io			; receive in AH
0149+  05F0 B9 00       	cmp al, 0				; check error code (AL)
0150+  05F2 C6 EA 05    	je gets_loop			; if no char received, retry
0151+  05F5             
0152+  05F5 76 1B       	cmp ah, 27
0153+  05F7 C6 18 06    	je gets_telnet_escape
0154+  05FA 76 0A       	cmp ah, $0A				; LF
0155+  05FC C6 71 06    	je gets_end
0156+  05FF 76 0D       	cmp ah, $0D				; CR
0157+  0601 C6 71 06    	je gets_end
0158+  0604 76 5C       	cmp ah, $5C				; '\\'
0159+  0606 C6 48 06    	je gets_escape
0160+  0609             	
0161+  0609 76 08       	cmp ah, $08			; check for backspace
0162+  060B C6 14 06    	je gets_backspace
0163+  060E             
0164+  060E 1A          	mov al, ah
0165+  060F 3E          	mov [d], al
0166+  0610 79          	inc d
0167+  0611 0A EA 05    	jmp gets_loop
0168+  0614             gets_backspace:
0169+  0614 7F          	dec d
0170+  0615 0A EA 05    	jmp gets_loop
0171+  0618             gets_telnet_escape:
0172+  0618 FD 0C       	sti
0173+  061A 19 01       	mov al, 1
0174+  061C 05 03       	syscall sys_io				; receive in AH without echo
0175+  061E B9 00       	cmp al, 0					; check error code (AL)
0176+  0620 C6 18 06    	je gets_telnet_escape		; if no char received, retry
0177+  0623 76 5B       	cmp ah, '['
0178+  0625 C7 EA 05    	jne gets_loop
0179+  0628             gets_telnet_escape_phase2:
0180+  0628 FD 0C       	sti
0181+  062A 19 01       	mov al, 1
0182+  062C 05 03       	syscall sys_io					; receive in AH without echo
0183+  062E B9 00       	cmp al, 0						; check error code (AL)
0184+  0630 C6 28 06    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  0633 76 44       	cmp ah, 'D'
0186+  0635 C6 40 06    	je gets_left_arrow
0187+  0638 76 43       	cmp ah, 'C'
0188+  063A C6 44 06    	je gets_right_arrow
0189+  063D 0A EA 05    	jmp gets_loop
0190+  0640             gets_left_arrow:
0191+  0640 7F          	dec d
0192+  0641 0A EA 05    	jmp gets_loop
0193+  0644             gets_right_arrow:
0194+  0644 79          	inc d
0195+  0645 0A EA 05    	jmp gets_loop
0196+  0648             gets_escape:
0197+  0648 FD 0C       	sti
0198+  064A 19 01       	mov al, 1
0199+  064C 05 03       	syscall sys_io			; receive in AH
0200+  064E B9 00       	cmp al, 0				; check error code (AL)
0201+  0650 C6 48 06    	je gets_escape			; if no char received, retry
0202+  0653 76 6E       	cmp ah, 'n'
0203+  0655 C6 63 06    	je gets_LF
0204+  0658 76 72       	cmp ah, 'r'
0205+  065A C6 6A 06    	je gets_CR
0206+  065D 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  065E 3E          	mov [d], al
0208+  065F 79          	inc d
0209+  0660 0A EA 05    	jmp gets_loop
0210+  0663             gets_LF:
0211+  0663 19 0A       	mov al, $0A
0212+  0665 3E          	mov [d], al
0213+  0666 79          	inc d
0214+  0667 0A EA 05    	jmp gets_loop
0215+  066A             gets_CR:
0216+  066A 19 0D       	mov al, $0D
0217+  066C 3E          	mov [d], al
0218+  066D 79          	inc d
0219+  066E 0A EA 05    	jmp gets_loop
0220+  0671             gets_end:
0221+  0671 19 00       	mov al, 0
0222+  0673 3E          	mov [d], al				; terminate string
0223+  0674 E7          	pop d
0224+  0675 E4          	pop a
0225+  0676 09          	ret
0226+  0677             
0227+  0677             
0228+  0677             
0229+  0677             
0230+  0677             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  0677             ;; INPUT TEXT
0232+  0677             ;; terminated with CTRL+D
0233+  0677             ;; pointer in D
0234+  0677             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  0677             gettxt:
0236+  0677 D7          	push a
0237+  0678 DA          	push d
0238+  0679             gettxt_loop:
0239+  0679 19 01       	mov al, 1
0240+  067B 05 03       	syscall sys_io			; receive in AH
0241+  067D B9 00       	cmp al, 0				; check error code (AL)
0242+  067F C6 79 06    	je gettxt_loop		; if no char received, retry
0243+  0682 76 04       	cmp ah, 4			; EOT
0244+  0684 C6 C2 06    	je gettxt_end
0245+  0687 76 08       	cmp ah, $08			; check for backspace
0246+  0689 C6 BE 06    	je gettxt_backspace
0247+  068C 76 5C       	cmp ah, $5C				; '\\'
0248+  068E C6 97 06    	je gettxt_escape
0249+  0691 1A          	mov al, ah
0250+  0692 3E          	mov [d], al
0251+  0693 79          	inc d
0252+  0694 0A 79 06    	jmp gettxt_loop
0253+  0697             gettxt_escape:
0254+  0697 19 01       	mov al, 1
0255+  0699 05 03       	syscall sys_io			; receive in AH
0256+  069B B9 00       	cmp al, 0				; check error code (AL)
0257+  069D C6 97 06    	je gettxt_escape		; if no char received, retry
0258+  06A0 76 6E       	cmp ah, 'n'
0259+  06A2 C6 B0 06    	je gettxt_LF
0260+  06A5 76 72       	cmp ah, 'r'
0261+  06A7 C6 B7 06    	je gettxt_CR
0262+  06AA 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  06AB 3E          	mov [d], al
0264+  06AC 79          	inc d
0265+  06AD 0A 79 06    	jmp gettxt_loop
0266+  06B0             gettxt_LF:
0267+  06B0 19 0A       	mov al, $0A
0268+  06B2 3E          	mov [d], al
0269+  06B3 79          	inc d
0270+  06B4 0A 79 06    	jmp gettxt_loop
0271+  06B7             gettxt_CR:
0272+  06B7 19 0D       	mov al, $0D
0273+  06B9 3E          	mov [d], al
0274+  06BA 79          	inc d
0275+  06BB 0A 79 06    	jmp gettxt_loop
0276+  06BE             gettxt_backspace:
0277+  06BE 7F          	dec d
0278+  06BF 0A 79 06    	jmp gettxt_loop
0279+  06C2             gettxt_end:
0280+  06C2 19 00       	mov al, 0
0281+  06C4 3E          	mov [d], al				; terminate string
0282+  06C5 E7          	pop d
0283+  06C6 E4          	pop a
0284+  06C7 09          	ret
0285+  06C8             
0286+  06C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  06C8             ; PRINT NEW LINE
0288+  06C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  06C8             printnl:
0290+  06C8 D7          	push a
0291+  06C9 10 00 0A    	mov a, $0A00
0292+  06CC 05 03       	syscall sys_io
0293+  06CE 10 00 0D    	mov a, $0D00
0294+  06D1 05 03       	syscall sys_io
0295+  06D3 E4          	pop a
0296+  06D4 09          	ret
0297+  06D5             
0298+  06D5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  06D5             ; strtoint
0300+  06D5             ; 4 digit hex string number in d
0301+  06D5             ; integer returned in A
0302+  06D5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  06D5             strtointx:
0304+  06D5 D8          	push b
0305+  06D6 32          	mov bl, [d]
0306+  06D7 37          	mov bh, bl
0307+  06D8 33 01 00    	mov bl, [d + 1]
0308+  06DB 07 96 05    	call atoi				; convert to int in AL
0309+  06DE 23          	mov ah, al				; move to AH
0310+  06DF 33 02 00    	mov bl, [d + 2]
0311+  06E2 37          	mov bh, bl
0312+  06E3 33 03 00    	mov bl, [d + 3]
0313+  06E6 07 96 05    	call atoi				; convert to int in AL
0314+  06E9 E5          	pop b
0315+  06EA 09          	ret
0316+  06EB             
0317+  06EB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  06EB             ; strtoint
0319+  06EB             ; 5 digit base10 string number in d
0320+  06EB             ; integer returned in A
0321+  06EB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  06EB             strtoint:
0323+  06EB E2          	push si
0324+  06EC D8          	push b
0325+  06ED D9          	push c
0326+  06EE DA          	push d
0327+  06EF 07 16 05    	call strlen			; get string length in C
0328+  06F2 7E          	dec c
0329+  06F3 FD 4E       	mov si, d
0330+  06F5 12          	mov a, c
0331+  06F6 FD 99       	shl a
0332+  06F8 3B 7E 05    	mov d, table_power
0333+  06FB 59          	add d, a
0334+  06FC 38 00 00    	mov c, 0
0335+  06FF             strtoint_L0:
0336+  06FF F6          	lodsb			; load ASCII to al
0337+  0700 B9 00       	cmp al, 0
0338+  0702 C6 15 07    	je strtoint_end
0339+  0705 6F 30       	sub al, $30		; make into integer
0340+  0707 22 00       	mov ah, 0
0341+  0709 2A          	mov b, [d]
0342+  070A AC          	mul a, b			; result in B since it fits in 16bits
0343+  070B 11          	mov a, b
0344+  070C 28          	mov b, c
0345+  070D 54          	add a, b
0346+  070E 39          	mov c, a
0347+  070F 63 02 00    	sub d, 2
0348+  0712 0A FF 06    	jmp strtoint_L0
0349+  0715             strtoint_end:
0350+  0715 12          	mov a, c
0351+  0716 E7          	pop d
0352+  0717 E6          	pop c
0353+  0718 E5          	pop b
0354+  0719 EF          	pop si
0355+  071A 09          	ret
0356+  071B             
0357+  071B             
0358+  071B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  071B             ; PRINT NULL TERMINATED STRING
0360+  071B             ; pointer in D
0361+  071B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  071B             puts:
0363+  071B D7          	push a
0364+  071C DA          	push d
0365+  071D             puts_L1:
0366+  071D 1E          	mov al, [d]
0367+  071E B9 00       	cmp al, 0
0368+  0720 C6 2C 07    	jz puts_END
0369+  0723 23          	mov ah, al
0370+  0724 19 00       	mov al, 0
0371+  0726 05 03       	syscall sys_io
0372+  0728 79          	inc d
0373+  0729 0A 1D 07    	jmp puts_L1
0374+  072C             puts_END:
0375+  072C E7          	pop d
0376+  072D E4          	pop a
0377+  072E 09          	ret
0378+  072F             
0379+  072F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  072F             ; PRINT N SIZE STRING
0381+  072F             ; pointer in D
0382+  072F             ; size in C
0383+  072F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  072F             putsn:
0385+  072F DB          	push al
0386+  0730 DA          	push d
0387+  0731 D9          	push c
0388+  0732             putsn_L0:
0389+  0732 1E          	mov al, [d]
0390+  0733 23          	mov ah, al
0391+  0734 19 00       	mov al, 0
0392+  0736 05 03       	syscall sys_io
0393+  0738 79          	inc d
0394+  0739 7E          	dec c	
0395+  073A C2 00 00    	cmp c, 0
0396+  073D C7 32 07    	jne putsn_L0
0397+  0740             putsn_end:
0398+  0740 E6          	pop c
0399+  0741 E7          	pop d
0400+  0742 E8          	pop al
0401+  0743 09          	ret
0402+  0744             
0403+  0744             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  0744             ; print 16bit decimal number
0405+  0744             ; input number in A
0406+  0744             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  0744             print_u16d:
0408+  0744 D7          	push a
0409+  0745 D8          	push b
0410+  0746 26 10 27    	mov b, 10000
0411+  0749 AE          	div a, b			; get 10000's coeff.
0412+  074A 07 6C 07    	call print_number
0413+  074D 11          	mov a, b
0414+  074E 26 E8 03    	mov b, 1000
0415+  0751 AE          	div a, b			; get 1000's coeff.
0416+  0752 07 6C 07    	call print_number
0417+  0755 11          	mov a, b
0418+  0756 26 64 00    	mov b, 100
0419+  0759 AE          	div a, b
0420+  075A 07 6C 07    	call print_number
0421+  075D 11          	mov a, b
0422+  075E 26 0A 00    	mov b, 10
0423+  0761 AE          	div a, b
0424+  0762 07 6C 07    	call print_number
0425+  0765 1B          	mov al, bl			; 1's coeff in bl
0426+  0766 07 6C 07    	call print_number
0427+  0769 E5          	pop b
0428+  076A E4          	pop a
0429+  076B 09          	ret
0430+  076C             
0431+  076C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0432+  076C             ; print AL
0433+  076C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0434+  076C             print_number:
0435+  076C 6A 30       	add al, $30
0436+  076E 23          	mov ah, al
0437+  076F 07 E1 05    	call putchar
0438+  0772 09          	ret
0439+  0773             
0440+  0773             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0441+  0773             ; PRINT 16BIT HEX INTEGER
0442+  0773             ; integer value in reg B
0443+  0773             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0444+  0773             print_u16x:
0445+  0773 D7          	push a
0446+  0774 D8          	push b
0447+  0775 DD          	push bl
0448+  0776 30          	mov bl, bh
0449+  0777 07 A8 05    	call itoa				; convert bh to char in A
0450+  077A 2F          	mov bl, al				; save al
0451+  077B 19 00       	mov al, 0
0452+  077D 05 03       	syscall sys_io				; display AH
0453+  077F 24          	mov ah, bl				; retrieve al
0454+  0780 19 00       	mov al, 0
0455+  0782 05 03       	syscall sys_io				; display AL
0456+  0784             
0457+  0784 EA          	pop bl
0458+  0785 07 A8 05    	call itoa				; convert bh to char in A
0459+  0788 2F          	mov bl, al				; save al
0460+  0789 19 00       	mov al, 0
0461+  078B 05 03       	syscall sys_io				; display AH
0462+  078D 24          	mov ah, bl				; retrieve al
0463+  078E 19 00       	mov al, 0
0464+  0790 05 03       	syscall sys_io				; display AL
0465+  0792             
0466+  0792 E5          	pop b
0467+  0793 E4          	pop a
0468+  0794 09          	ret
0469+  0795             
0470+  0795             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0471+  0795             ; INPUT 16BIT HEX INTEGER
0472+  0795             ; read 16bit integer into A
0473+  0795             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0474+  0795             scan_u16x:
0475+  0795 F8 10 00    	enter 16
0476+  0798 D8          	push b
0477+  0799 DA          	push d
0478+  079A             
0479+  079A FA F1 FF    	lea d, [bp + -15]
0480+  079D 07 E8 05    	call gets				; get number
0481+  07A0             
0482+  07A0 32          	mov bl, [d]
0483+  07A1 37          	mov bh, bl
0484+  07A2 33 01 00    	mov bl, [d + 1]
0485+  07A5 07 96 05    	call atoi				; convert to int in AL
0486+  07A8 23          	mov ah, al				; move to AH
0487+  07A9             
0488+  07A9 33 02 00    	mov bl, [d + 2]
0489+  07AC 37          	mov bh, bl
0490+  07AD 33 03 00    	mov bl, [d + 3]
0491+  07B0 07 96 05    	call atoi				; convert to int in AL
0492+  07B3             
0493+  07B3 E7          	pop d
0494+  07B4 E5          	pop b
0495+  07B5 F9          	leave
0496+  07B6 09          	ret
0497+  07B7             
0498+  07B7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0499+  07B7             ; PRINT 8bit HEX INTEGER
0500+  07B7             ; integer value in reg bl
0501+  07B7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0502+  07B7             print_u8x:
0503+  07B7 D7          	push a
0504+  07B8 DD          	push bl
0505+  07B9             
0506+  07B9 07 A8 05    	call itoa				; convert bl to char in A
0507+  07BC 2F          	mov bl, al				; save al
0508+  07BD 19 00       	mov al, 0
0509+  07BF 05 03       	syscall sys_io				; display AH
0510+  07C1 24          	mov ah, bl				; retrieve al
0511+  07C2 19 00       	mov al, 0
0512+  07C4 05 03       	syscall sys_io				; display AL
0513+  07C6             
0514+  07C6 EA          	pop bl
0515+  07C7 E4          	pop a
0516+  07C8 09          	ret
0517+  07C9             
0518+  07C9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0519+  07C9             ; print 8bit decimal unsigned number
0520+  07C9             ; input number in AL
0521+  07C9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0522+  07C9             print_u8d:
0523+  07C9 D7          	push a
0524+  07CA D8          	push b
0525+  07CB             
0526+  07CB 22 00       	mov ah, 0
0527+  07CD 26 64 00    	mov b, 100
0528+  07D0 AE          	div a, b
0529+  07D1 D8          	push b			; save remainder
0530+  07D2 B9 00       	cmp al, 0
0531+  07D4 C6 DE 07    	je skip100
0532+  07D7 6A 30       	add al, $30
0533+  07D9 23          	mov ah, al
0534+  07DA 19 00       	mov al, 0
0535+  07DC 05 03       	syscall sys_io	; print coeff
0536+  07DE             skip100:
0537+  07DE E4          	pop a
0538+  07DF 22 00       	mov ah, 0
0539+  07E1 26 0A 00    	mov b, 10
0540+  07E4 AE          	div a, b
0541+  07E5 D8          	push b			; save remainder
0542+  07E6 B9 00       	cmp al, 0
0543+  07E8 C6 F2 07    	je skip10
0544+  07EB 6A 30       	add al, $30
0545+  07ED 23          	mov ah, al
0546+  07EE 19 00       	mov al, 0
0547+  07F0 05 03       	syscall sys_io	; print coeff
0548+  07F2             skip10:
0549+  07F2 E4          	pop a
0550+  07F3 1B          	mov al, bl
0551+  07F4 6A 30       	add al, $30
0552+  07F6 23          	mov ah, al
0553+  07F7 19 00       	mov al, 0
0554+  07F9 05 03       	syscall sys_io	; print coeff
0555+  07FB E5          	pop b
0556+  07FC E4          	pop a
0557+  07FD 09          	ret
0558+  07FE             
0559+  07FE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0560+  07FE             ; INPUT 8BIT HEX INTEGER
0561+  07FE             ; read 8bit integer into AL
0562+  07FE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0563+  07FE             scan_u8x:
0564+  07FE F8 04 00    	enter 4
0565+  0801 D8          	push b
0566+  0802 DA          	push d
0567+  0803             
0568+  0803 FA FD FF    	lea d, [bp + -3]
0569+  0806 07 E8 05    	call gets				; get number
0570+  0809             
0571+  0809 32          	mov bl, [d]
0572+  080A 37          	mov bh, bl
0573+  080B 33 01 00    	mov bl, [d + 1]
0574+  080E 07 96 05    	call atoi				; convert to int in AL
0575+  0811             
0576+  0811 E7          	pop d
0577+  0812 E5          	pop b
0578+  0813 F9          	leave
0579+  0814 09          	ret
0580+  0815             
0581+  0815             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0582+  0815             ; input decimal number
0583+  0815             ; result in A
0584+  0815             ; 655'\0'
0585+  0815             ; low--------high
0586+  0815             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  0815             scan_u16d:
0588+  0815 F8 08 00    	enter 8
0589+  0818 E2          	push si
0590+  0819 D8          	push b
0591+  081A D9          	push c
0592+  081B DA          	push d
0593+  081C FA F9 FF    	lea d, [bp +- 7]
0594+  081F 07 E8 05    	call gets
0595+  0822 07 16 05    	call strlen			; get string length in C
0596+  0825 7E          	dec c
0597+  0826 FD 4E       	mov si, d
0598+  0828 12          	mov a, c
0599+  0829 FD 99       	shl a
0600+  082B 3B 7E 05    	mov d, table_power
0601+  082E 59          	add d, a
0602+  082F 38 00 00    	mov c, 0
0603+  0832             mul_loop:
0604+  0832 F6          	lodsb			; load ASCII to al
0605+  0833 B9 00       	cmp al, 0
0606+  0835 C6 48 08    	je mul_exit
0607+  0838 6F 30       	sub al, $30		; make into integer
0608+  083A 22 00       	mov ah, 0
0609+  083C 2A          	mov b, [d]
0610+  083D AC          	mul a, b			; result in B since it fits in 16bits
0611+  083E 11          	mov a, b
0612+  083F 28          	mov b, c
0613+  0840 54          	add a, b
0614+  0841 39          	mov c, a
0615+  0842 63 02 00    	sub d, 2
0616+  0845 0A 32 08    	jmp mul_loop
0617+  0848             mul_exit:
0618+  0848 12          	mov a, c
0619+  0849 E7          	pop d
0620+  084A E6          	pop c
0621+  084B E5          	pop b
0622+  084C EF          	pop si
0623+  084D F9          	leave
0624+  084E 09          	ret
0120   084F             
0121   084F             
0122   084F             	
0123   084F 52 75 6C 65 s_rule:		.db "Rule: ", 0
0123   0853 3A 20 00 
0124   0856 53 74 65 70 s_steps:	.db "Steps: ", 0
0124   085A 73 3A 20 00 
0125   085E             
0126   085E 20          table_translate:	.db ' '
0127   085F 76          					.db 'v'
0128   0860             	
0129   0860 00 00 00 00 init_state: 	.fill (WIDTH/2), 0
0129   0864 00 00 00 00 
0129   0868 00 00 00 00 
0129   086C 00 00 00 00 
0129   0870 00 00 00 00 
0129   0874 00 00 00 00 
0129   0878 00 00 00 00 
0129   087C 00 00 00 00 
0129   0880 00 00 00 00 
0129   0884 00 00 00 00 
0129   0888 00 00 00 00 
0129   088C 00 00 00 00 
0129   0890 00 00 00 00 
0129   0894 00 00 00 
0130   0897 01          				.db 1 
0131   0898 00 00 00 00 				.fill (WIDTH/2), 0
0131   089C 00 00 00 00 
0131   08A0 00 00 00 00 
0131   08A4 00 00 00 00 
0131   08A8 00 00 00 00 
0131   08AC 00 00 00 00 
0131   08B0 00 00 00 00 
0131   08B4 00 00 00 00 
0131   08B8 00 00 00 00 
0131   08BC 00 00 00 00 
0131   08C0 00 00 00 00 
0131   08C4 00 00 00 00 
0131   08C8 00 00 00 00 
0131   08CC 00 00 00 
0132   08CF             
0133   08CF 00 00 00 00 prev_state: 	.fill (WIDTH/2), 0
0133   08D3 00 00 00 00 
0133   08D7 00 00 00 00 
0133   08DB 00 00 00 00 
0133   08DF 00 00 00 00 
0133   08E3 00 00 00 00 
0133   08E7 00 00 00 00 
0133   08EB 00 00 00 00 
0133   08EF 00 00 00 00 
0133   08F3 00 00 00 00 
0133   08F7 00 00 00 00 
0133   08FB 00 00 00 00 
0133   08FF 00 00 00 00 
0133   0903 00 00 00 
0134   0906 01          				.db 1 
0135   0907 00 00 00 00 				.fill (WIDTH/2), 0
0135   090B 00 00 00 00 
0135   090F 00 00 00 00 
0135   0913 00 00 00 00 
0135   0917 00 00 00 00 
0135   091B 00 00 00 00 
0135   091F 00 00 00 00 
0135   0923 00 00 00 00 
0135   0927 00 00 00 00 
0135   092B 00 00 00 00 
0135   092F 00 00 00 00 
0135   0933 00 00 00 00 
0135   0937 00 00 00 00 
0135   093B 00 00 00 
0136   093E             		
0137   093E 00 00 00 00 state: 			.fill (WIDTH+1), 0
0137   0942 00 00 00 00 
0137   0946 00 00 00 00 
0137   094A 00 00 00 00 
0137   094E 00 00 00 00 
0137   0952 00 00 00 00 
0137   0956 00 00 00 00 
0137   095A 00 00 00 00 
0137   095E 00 00 00 00 
0137   0962 00 00 00 00 
0137   0966 00 00 00 00 
0137   096A 00 00 00 00 
0137   096E 00 00 00 00 
0137   0972 00 00 00 00 
0137   0976 00 00 00 00 
0137   097A 00 00 00 00 
0137   097E 00 00 00 00 
0137   0982 00 00 00 00 
0137   0986 00 00 00 00 
0137   098A 00 00 00 00 
0137   098E 00 00 00 00 
0137   0992 00 00 00 00 
0137   0996 00 00 00 00 
0137   099A 00 00 00 00 
0137   099E 00 00 00 00 
0137   09A2 00 00 00 00 
0137   09A6 00 00 00 00 
0137   09AA 00 00 00 
0138   09AD             
0139   09AD 20 20 20 20 state_chars:	.fill (WIDTH+1), ' '
0139   09B1 20 20 20 20 
0139   09B5 20 20 20 20 
0139   09B9 20 20 20 20 
0139   09BD 20 20 20 20 
0139   09C1 20 20 20 20 
0139   09C5 20 20 20 20 
0139   09C9 20 20 20 20 
0139   09CD 20 20 20 20 
0139   09D1 20 20 20 20 
0139   09D5 20 20 20 20 
0139   09D9 20 20 20 20 
0139   09DD 20 20 20 20 
0139   09E1 20 20 20 20 
0139   09E5 20 20 20 20 
0139   09E9 20 20 20 20 
0139   09ED 20 20 20 20 
0139   09F1 20 20 20 20 
0139   09F5 20 20 20 20 
0139   09F9 20 20 20 20 
0139   09FD 20 20 20 20 
0139   0A01 20 20 20 20 
0139   0A05 20 20 20 20 
0139   0A09 20 20 20 20 
0139   0A0D 20 20 20 20 
0139   0A11 20 20 20 20 
0139   0A15 20 20 20 20 
0139   0A19 20 20 20 
0140   0A1C 00          				.db 0
0141   0A1D             
0142   0A1D             automaton_table:
0143   0A1D 01          	.db 1		; 000
0144   0A1E 00          	.db 0		; 001
0145   0A1F 01          	.db 1		; 010
0146   0A20 00          	.db 0		; 011
0147   0A21 00          	.db 0		; 100
0148   0A22 01          	.db 1		; 101
0149   0A23 00          	.db 0		; 110
0150   0A24 01          	.db 1		; 111
0151   0A25             					
0152   0A25             
0153   0A25 0A 0D       s_menu:		.db "\n\r"
0154   0A27 30 2E 20 52 			.db "0. Run automaton\n\r"
0154   0A2B 75 6E 20 61 
0154   0A2F 75 74 6F 6D 
0154   0A33 61 74 6F 6E 
0154   0A37 0A 0D 
0155   0A39 31 2E 20 43 			.db "1. Change rule\n\r"
0155   0A3D 68 61 6E 67 
0155   0A41 65 20 72 75 
0155   0A45 6C 65 0A 0D 
0156   0A49 32 2E 20 51 			.db "2. Quit\n\r"
0156   0A4D 75 69 74 0A 
0156   0A51 0D 
0157   0A52 25 20 00    			.db "% ", 0
0158   0A55             				
0159   0A55             .end
tasm: Number of errors = 0
