0001   0000             .include "kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0002   0000             
0003   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0005   0000             
0006   0400             .org PROC_TEXT_ORG			; origin at 1024
0007   0400             
0008   0400             ; when running the installer, we need to be inside /boot because the mkbin system call
0009   0400             ; creates all binary files inside whatever is the current directory
0010   0400             ; and we want the kernel to live inside /boot
0011   0400             bootloader_installer:
0012   0400             ;; create the kernel file
0013   0400 3B 36 04      mov d, s_warning
0014   0403 07 53 07      call puts
0015   0406 3B 6F 04      mov d, s_enter_filename
0016   0409 07 53 07      call puts
0017   040C 3B 81 04      mov d, kernel_filename
0018   040F 07 20 06      call gets
0019   0412             
0020   0412 3B 6C 04      mov d, s_prompt 
0021   0415 07 53 07      call puts
0022   0418 3B 81 04    	mov d, kernel_filename
0023   041B 19 06       	mov al, 6               ; mkbin
0024   041D 05 04       	syscall sys_fileio      ; create the binary file for the kernel
0025   041F                                       ; we need to be on '/boot' here
0026   041F             
0027   041F FD 4D 81 04   mov si, kernel_filename
0028   0423 FD 4F C1 04   mov di, kernel_fullpath
0029   0427 07 81 05      call strcat             ; form full pathname for the kernel file
0030   042A 3B C1 04    	mov d, kernel_fullpath
0031   042D 19 13       	mov al, 19
0032   042F 05 04       	syscall sys_fileio		; obtain dirID for kernel file, in A
0033   0431 77          	inc a					; increment LBA because data starts after the header sector
0034   0432 05 0D       	syscall sys_boot_install
0035   0434             
0036   0434 05 0B       	syscall sys_terminate_proc
0037   0436             
0038   0436             
0039   0436             
0040   0436 4D 61 6B 65 s_warning:        .db "Make sure you are in "
0040   043A 20 73 75 72 
0040   043E 65 20 79 6F 
0040   0442 75 20 61 72 
0040   0446 65 20 69 6E 
0040   044A 20 
0041   044B 2F 62 6F 6F 									.db "/boot before creating "
0041   044F 74 20 62 65 
0041   0453 66 6F 72 65 
0041   0457 20 63 72 65 
0041   045B 61 74 69 6E 
0041   045F 67 20 
0042   0461 74 68 65 20 									.db "the file.\n", 0
0042   0465 66 69 6C 65 
0042   0469 2E 0A 00 
0043   046C             
0044   046C 25 20 00    s_prompt:         .db "% ", 0
0045   046F 4B 65 72 6E s_enter_filename: .db "Kernel filename: ", 0
0045   0473 65 6C 20 66 
0045   0477 69 6C 65 6E 
0045   047B 61 6D 65 3A 
0045   047F 20 00 
0046   0481 00 00 00 00 kernel_filename:    .fill 64, 0
0046   0485 00 00 00 00 
0046   0489 00 00 00 00 
0046   048D 00 00 00 00 
0046   0491 00 00 00 00 
0046   0495 00 00 00 00 
0046   0499 00 00 00 00 
0046   049D 00 00 00 00 
0046   04A1 00 00 00 00 
0046   04A5 00 00 00 00 
0046   04A9 00 00 00 00 
0046   04AD 00 00 00 00 
0046   04B1 00 00 00 00 
0046   04B5 00 00 00 00 
0046   04B9 00 00 00 00 
0046   04BD 00 00 00 00 
0047   04C1 2F 62 6F 6F kernel_fullpath:  	.db "/boot/"
0047   04C5 74 2F 
0048   04C7 00 00 00 00                     .fill 64, 0
0048   04CB 00 00 00 00 
0048   04CF 00 00 00 00 
0048   04D3 00 00 00 00 
0048   04D7 00 00 00 00 
0048   04DB 00 00 00 00 
0048   04DF 00 00 00 00 
0048   04E3 00 00 00 00 
0048   04E7 00 00 00 00 
0048   04EB 00 00 00 00 
0048   04EF 00 00 00 00 
0048   04F3 00 00 00 00 
0048   04F7 00 00 00 00 
0048   04FB 00 00 00 00 
0048   04FF 00 00 00 00 
0048   0503 00 00 00 00 
0049   0507             
0050   0507             .include "stdio.asm"
0001+  0507             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0507             ; stdio.s
0003+  0507             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0507             .include "string.asm"
0001++ 0507             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0507             ; string.s
0003++ 0507             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0507             
0005++ 0507             
0006++ 0507             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0507             ; strrev
0008++ 0507             ; reverse a string
0009++ 0507             ; D = string address
0010++ 0507             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0507             ; 01234
0012++ 0507             strrev:
0013++ 0507 4B          	pusha
0014++ 0508 07 4E 05    	call strlen	; length in C
0015++ 050B 12          	mov a, c
0016++ 050C AF 01 00    	cmp a, 1
0017++ 050F D0 29 05    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0512 7D          	dec a
0019++ 0513 FD 4E       	mov si, d	; beginning of string
0020++ 0515 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0517 59          	add d, a	; end of string
0022++ 0518 12          	mov a, c
0023++ 0519 FD 9B       	shr a		; divide by 2
0024++ 051B 39          	mov c, a	; C now counts the steps
0025++ 051C             strrev_L0:
0026++ 051C 32          	mov bl, [d]	; save load right-side char into BL
0027++ 051D F6          	lodsb		; load left-side char into AL; increase SI
0028++ 051E 3E          	mov [d], al	; store left char into right side
0029++ 051F 1B          	mov al, bl
0030++ 0520 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0521 7E          	dec c
0032++ 0522 7F          	dec d
0033++ 0523 C2 00 00    	cmp c, 0
0034++ 0526 C7 1C 05    	jne strrev_L0
0035++ 0529             strrev_end:
0036++ 0529 4C          	popa
0037++ 052A 09          	ret
0038++ 052B             	
0039++ 052B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 052B             ; strchr
0041++ 052B             ; search string in D for char in AL
0042++ 052B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 052B             strchr:
0044++ 052B             strchr_L0:
0045++ 052B 32          	mov bl, [d]
0046++ 052C C1 00       	cmp bl, 0
0047++ 052E C6 39 05    	je strchr_end
0048++ 0531 BA          	cmp al, bl
0049++ 0532 C6 39 05    	je strchr_end
0050++ 0535 79          	inc d
0051++ 0536 0A 2B 05    	jmp strchr_L0
0052++ 0539             strchr_end:
0053++ 0539 1B          	mov al, bl
0054++ 053A 09          	ret
0055++ 053B             
0056++ 053B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 053B             ; strstr
0058++ 053B             ; find sub-string
0059++ 053B             ; str1 in SI
0060++ 053B             ; str2 in DI
0061++ 053B             ; SI points to end of source string
0062++ 053B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 053B             strstr:
0064++ 053B DB          	push al
0065++ 053C DA          	push d
0066++ 053D E3          	push di
0067++ 053E             strstr_loop:
0068++ 053E F3          	cmpsb					; compare a byte of the strings
0069++ 053F C7 4A 05    	jne strstr_ret
0070++ 0542 FC 00 00    	lea d, [di + 0]
0071++ 0545 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0547 C7 3E 05    	jne strstr_loop				; equal chars but not at end
0073++ 054A             strstr_ret:
0074++ 054A F0          	pop di
0075++ 054B E7          	pop d
0076++ 054C E8          	pop al
0077++ 054D 09          	ret
0078++ 054E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 054E             ; length of null terminated string
0080++ 054E             ; result in C
0081++ 054E             ; pointer in D
0082++ 054E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 054E             strlen:
0084++ 054E DA          	push d
0085++ 054F 38 00 00    	mov c, 0
0086++ 0552             strlen_L1:
0087++ 0552 BD 00       	cmp byte [d], 0
0088++ 0554 C6 5C 05    	je strlen_ret
0089++ 0557 79          	inc d
0090++ 0558 78          	inc c
0091++ 0559 0A 52 05    	jmp strlen_L1
0092++ 055C             strlen_ret:
0093++ 055C E7          	pop d
0094++ 055D 09          	ret
0095++ 055E             
0096++ 055E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 055E             ; STRCMP
0098++ 055E             ; compare two strings
0099++ 055E             ; str1 in SI
0100++ 055E             ; str2 in DI
0101++ 055E             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 055E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 055E             strcmp:
0104++ 055E DB          	push al
0105++ 055F DA          	push d
0106++ 0560 E3          	push di
0107++ 0561 E2          	push si
0108++ 0562             strcmp_loop:
0109++ 0562 F3          	cmpsb					; compare a byte of the strings
0110++ 0563 C7 6E 05    	jne strcmp_ret
0111++ 0566 FB FF FF    	lea d, [si +- 1]
0112++ 0569 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 056B C7 62 05    	jne strcmp_loop				; equal chars but not at end
0114++ 056E             strcmp_ret:
0115++ 056E EF          	pop si
0116++ 056F F0          	pop di
0117++ 0570 E7          	pop d
0118++ 0571 E8          	pop al
0119++ 0572 09          	ret
0120++ 0573             
0121++ 0573             
0122++ 0573             ; STRCPY
0123++ 0573             ; copy null terminated string from SI to DI
0124++ 0573             ; source in SI
0125++ 0573             ; destination in DI
0126++ 0573             strcpy:
0127++ 0573 E2          	push si
0128++ 0574 E3          	push di
0129++ 0575 DB          	push al
0130++ 0576             strcpy_L1:
0131++ 0576 F6          	lodsb
0132++ 0577 F7          	stosb
0133++ 0578 B9 00       	cmp al, 0
0134++ 057A C7 76 05    	jne strcpy_L1
0135++ 057D             strcpy_end:
0136++ 057D E8          	pop al
0137++ 057E F0          	pop di
0138++ 057F EF          	pop si
0139++ 0580 09          	ret
0140++ 0581             
0141++ 0581             ; STRCAT
0142++ 0581             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0581             ; source in SI
0144++ 0581             ; destination in DI
0145++ 0581             strcat:
0146++ 0581 E2          	push si
0147++ 0582 E3          	push di
0148++ 0583 D7          	push a
0149++ 0584 DA          	push d
0150++ 0585 50          	mov a, di
0151++ 0586 3C          	mov d, a
0152++ 0587             strcat_goto_end_L1:
0153++ 0587 BD 00       	cmp byte[d], 0
0154++ 0589 C6 90 05    	je strcat_start
0155++ 058C 79          	inc d
0156++ 058D 0A 87 05    	jmp strcat_goto_end_L1
0157++ 0590             strcat_start:
0158++ 0590 FD 50       	mov di, d
0159++ 0592             strcat_L1:
0160++ 0592 F6          	lodsb
0161++ 0593 F7          	stosb
0162++ 0594 B9 00       	cmp al, 0
0163++ 0596 C7 92 05    	jne strcat_L1
0164++ 0599             strcat_end:
0165++ 0599 E7          	pop d
0166++ 059A E4          	pop a
0167++ 059B F0          	pop di
0168++ 059C EF          	pop si
0169++ 059D 09          	ret
0005+  059E             
0006+  059E 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  05A2 34 35 36 37 
0006+  05A6 38 39 41 42 
0006+  05AA 43 44 45 46 
0007+  05AE 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  05B2 1B 5B 48 00 
0008+  05B6             
0009+  05B6 01 00       table_power:.dw 1
0010+  05B8 0A 00       			.dw 10
0011+  05BA 64 00       			.dw 100
0012+  05BC E8 03       			.dw 1000
0013+  05BE 10 27       			.dw 10000
0014+  05C0             
0015+  05C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  05C0             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  05C0             ; ASCII in BL
0018+  05C0             ; result in AL
0019+  05C0             ; ascii for F = 0100 0110
0020+  05C0             ; ascii for 9 = 0011 1001
0021+  05C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  05C0             hex_ascii_encode:
0023+  05C0 1B          	mov al, bl
0024+  05C1 93 40       	test al, $40				; test if letter or number
0025+  05C3 C7 C9 05    	jnz hex_letter
0026+  05C6 87 0F       	and al, $0F				; get number
0027+  05C8 09          	ret
0028+  05C9             hex_letter:
0029+  05C9 87 0F       	and al, $0F				; get letter
0030+  05CB 6A 09       	add al, 9
0031+  05CD 09          	ret
0032+  05CE             
0033+  05CE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  05CE             ; ATOI
0035+  05CE             ; 2 letter hex string in B
0036+  05CE             ; 8bit integer returned in AL
0037+  05CE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  05CE             atoi:
0039+  05CE D8          	push b
0040+  05CF 07 C0 05    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  05D2 30          	mov bl, bh
0042+  05D3 DB          	push al					; save a
0043+  05D4 07 C0 05    	call hex_ascii_encode
0044+  05D7 EA          	pop bl	
0045+  05D8 FD 9E 04    	shl al, 4
0046+  05DB 8C          	or al, bl
0047+  05DC E5          	pop b
0048+  05DD 09          	ret	
0049+  05DE             
0050+  05DE             
0051+  05DE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  05DE             ; printf
0053+  05DE             ; no need for explanations!
0054+  05DE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  05DE             printf:
0056+  05DE 09          	ret
0057+  05DF             
0058+  05DF             
0059+  05DF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  05DF             ; scanf
0061+  05DF             ; no need for explanations!
0062+  05DF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  05DF             scanf:
0064+  05DF 09          	ret
0065+  05E0             
0066+  05E0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  05E0             ; ITOA
0068+  05E0             ; 8bit value in BL
0069+  05E0             ; 2 byte ASCII result in A
0070+  05E0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  05E0             itoa:
0072+  05E0 DA          	push d
0073+  05E1 D8          	push b
0074+  05E2 A7 00       	mov bh, 0
0075+  05E4 FD A4 04    	shr bl, 4	
0076+  05E7 74          	mov d, b
0077+  05E8 1F 9E 05    	mov al, [d + s_hex_digits]
0078+  05EB 23          	mov ah, al
0079+  05EC             	
0080+  05EC E5          	pop b
0081+  05ED D8          	push b
0082+  05EE A7 00       	mov bh, 0
0083+  05F0 FD 87 0F    	and bl, $0F
0084+  05F3 74          	mov d, b
0085+  05F4 1F 9E 05    	mov al, [d + s_hex_digits]
0086+  05F7 E5          	pop b
0087+  05F8 E7          	pop d
0088+  05F9 09          	ret
0089+  05FA             
0090+  05FA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  05FA             ; HEX STRING TO BINARY
0092+  05FA             ; di = destination address
0093+  05FA             ; si = source
0094+  05FA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  05FA             hex_to_int:
0096+  05FA             hex_to_int_L1:
0097+  05FA F6          	lodsb					; load from [SI] to AL
0098+  05FB B9 00       	cmp al, 0				; check if ASCII 0
0099+  05FD C6 0A 06    	jz hex_to_int_ret
0100+  0600 36          	mov bh, al
0101+  0601 F6          	lodsb
0102+  0602 2F          	mov bl, al
0103+  0603 07 CE 05    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  0606 F7          	stosb					; store AL to [DI]
0105+  0607 0A FA 05    	jmp hex_to_int_L1
0106+  060A             hex_to_int_ret:
0107+  060A 09          	ret		
0108+  060B             
0109+  060B             
0110+  060B             
0111+  060B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  060B             ; GETCHAR
0113+  060B             ; char in ah
0114+  060B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  060B             getchar:
0116+  060B DB          	push al
0117+  060C             getchar_retry:
0118+  060C FD 0C       	sti
0119+  060E 19 01       	mov al, 1
0120+  0610 05 03       	syscall sys_io			; receive in AH
0121+  0612 B9 00       	cmp al, 0			; check if any char was receive
0122+  0614 C6 0C 06    	je getchar_retry
0123+  0617 E8          	pop al
0124+  0618 09          	ret
0125+  0619             
0126+  0619             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  0619             ; PUTCHAR
0128+  0619             ; char in ah
0129+  0619             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0619             putchar:
0131+  0619 D7          	push a
0132+  061A 19 00       	mov al, 0
0133+  061C 05 03       	syscall sys_io			; char in AH
0134+  061E E4          	pop a
0135+  061F 09          	ret
0136+  0620             
0137+  0620             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  0620             ;; INPUT A STRING
0139+  0620             ;; terminates with null
0140+  0620             ;; pointer in D
0141+  0620             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  0620             gets:
0143+  0620 D7          	push a
0144+  0621 DA          	push d
0145+  0622             gets_loop:
0146+  0622 FD 0C       	sti
0147+  0624 19 01       	mov al, 1
0148+  0626 05 03       	syscall sys_io			; receive in AH
0149+  0628 B9 00       	cmp al, 0				; check error code (AL)
0150+  062A C6 22 06    	je gets_loop			; if no char received, retry
0151+  062D             
0152+  062D 76 1B       	cmp ah, 27
0153+  062F C6 50 06    	je gets_telnet_escape
0154+  0632 76 0A       	cmp ah, $0A				; LF
0155+  0634 C6 A9 06    	je gets_end
0156+  0637 76 0D       	cmp ah, $0D				; CR
0157+  0639 C6 A9 06    	je gets_end
0158+  063C 76 5C       	cmp ah, $5C				; '\\'
0159+  063E C6 80 06    	je gets_escape
0160+  0641             	
0161+  0641 76 08       	cmp ah, $08			; check for backspace
0162+  0643 C6 4C 06    	je gets_backspace
0163+  0646             
0164+  0646 1A          	mov al, ah
0165+  0647 3E          	mov [d], al
0166+  0648 79          	inc d
0167+  0649 0A 22 06    	jmp gets_loop
0168+  064C             gets_backspace:
0169+  064C 7F          	dec d
0170+  064D 0A 22 06    	jmp gets_loop
0171+  0650             gets_telnet_escape:
0172+  0650 FD 0C       	sti
0173+  0652 19 01       	mov al, 1
0174+  0654 05 03       	syscall sys_io				; receive in AH without echo
0175+  0656 B9 00       	cmp al, 0					; check error code (AL)
0176+  0658 C6 50 06    	je gets_telnet_escape		; if no char received, retry
0177+  065B 76 5B       	cmp ah, '['
0178+  065D C7 22 06    	jne gets_loop
0179+  0660             gets_telnet_escape_phase2:
0180+  0660 FD 0C       	sti
0181+  0662 19 01       	mov al, 1
0182+  0664 05 03       	syscall sys_io					; receive in AH without echo
0183+  0666 B9 00       	cmp al, 0						; check error code (AL)
0184+  0668 C6 60 06    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  066B 76 44       	cmp ah, 'D'
0186+  066D C6 78 06    	je gets_left_arrow
0187+  0670 76 43       	cmp ah, 'C'
0188+  0672 C6 7C 06    	je gets_right_arrow
0189+  0675 0A 22 06    	jmp gets_loop
0190+  0678             gets_left_arrow:
0191+  0678 7F          	dec d
0192+  0679 0A 22 06    	jmp gets_loop
0193+  067C             gets_right_arrow:
0194+  067C 79          	inc d
0195+  067D 0A 22 06    	jmp gets_loop
0196+  0680             gets_escape:
0197+  0680 FD 0C       	sti
0198+  0682 19 01       	mov al, 1
0199+  0684 05 03       	syscall sys_io			; receive in AH
0200+  0686 B9 00       	cmp al, 0				; check error code (AL)
0201+  0688 C6 80 06    	je gets_escape			; if no char received, retry
0202+  068B 76 6E       	cmp ah, 'n'
0203+  068D C6 9B 06    	je gets_LF
0204+  0690 76 72       	cmp ah, 'r'
0205+  0692 C6 A2 06    	je gets_CR
0206+  0695 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  0696 3E          	mov [d], al
0208+  0697 79          	inc d
0209+  0698 0A 22 06    	jmp gets_loop
0210+  069B             gets_LF:
0211+  069B 19 0A       	mov al, $0A
0212+  069D 3E          	mov [d], al
0213+  069E 79          	inc d
0214+  069F 0A 22 06    	jmp gets_loop
0215+  06A2             gets_CR:
0216+  06A2 19 0D       	mov al, $0D
0217+  06A4 3E          	mov [d], al
0218+  06A5 79          	inc d
0219+  06A6 0A 22 06    	jmp gets_loop
0220+  06A9             gets_end:
0221+  06A9 19 00       	mov al, 0
0222+  06AB 3E          	mov [d], al				; terminate string
0223+  06AC E7          	pop d
0224+  06AD E4          	pop a
0225+  06AE 09          	ret
0226+  06AF             
0227+  06AF             
0228+  06AF             
0229+  06AF             
0230+  06AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  06AF             ;; INPUT TEXT
0232+  06AF             ;; terminated with CTRL+D
0233+  06AF             ;; pointer in D
0234+  06AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  06AF             gettxt:
0236+  06AF D7          	push a
0237+  06B0 DA          	push d
0238+  06B1             gettxt_loop:
0239+  06B1 19 01       	mov al, 1
0240+  06B3 05 03       	syscall sys_io			; receive in AH
0241+  06B5 B9 00       	cmp al, 0				; check error code (AL)
0242+  06B7 C6 B1 06    	je gettxt_loop		; if no char received, retry
0243+  06BA 76 04       	cmp ah, 4			; EOT
0244+  06BC C6 FA 06    	je gettxt_end
0245+  06BF 76 08       	cmp ah, $08			; check for backspace
0246+  06C1 C6 F6 06    	je gettxt_backspace
0247+  06C4 76 5C       	cmp ah, $5C				; '\\'
0248+  06C6 C6 CF 06    	je gettxt_escape
0249+  06C9 1A          	mov al, ah
0250+  06CA 3E          	mov [d], al
0251+  06CB 79          	inc d
0252+  06CC 0A B1 06    	jmp gettxt_loop
0253+  06CF             gettxt_escape:
0254+  06CF 19 01       	mov al, 1
0255+  06D1 05 03       	syscall sys_io			; receive in AH
0256+  06D3 B9 00       	cmp al, 0				; check error code (AL)
0257+  06D5 C6 CF 06    	je gettxt_escape		; if no char received, retry
0258+  06D8 76 6E       	cmp ah, 'n'
0259+  06DA C6 E8 06    	je gettxt_LF
0260+  06DD 76 72       	cmp ah, 'r'
0261+  06DF C6 EF 06    	je gettxt_CR
0262+  06E2 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  06E3 3E          	mov [d], al
0264+  06E4 79          	inc d
0265+  06E5 0A B1 06    	jmp gettxt_loop
0266+  06E8             gettxt_LF:
0267+  06E8 19 0A       	mov al, $0A
0268+  06EA 3E          	mov [d], al
0269+  06EB 79          	inc d
0270+  06EC 0A B1 06    	jmp gettxt_loop
0271+  06EF             gettxt_CR:
0272+  06EF 19 0D       	mov al, $0D
0273+  06F1 3E          	mov [d], al
0274+  06F2 79          	inc d
0275+  06F3 0A B1 06    	jmp gettxt_loop
0276+  06F6             gettxt_backspace:
0277+  06F6 7F          	dec d
0278+  06F7 0A B1 06    	jmp gettxt_loop
0279+  06FA             gettxt_end:
0280+  06FA 19 00       	mov al, 0
0281+  06FC 3E          	mov [d], al				; terminate string
0282+  06FD E7          	pop d
0283+  06FE E4          	pop a
0284+  06FF 09          	ret
0285+  0700             
0286+  0700             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  0700             ; PRINT NEW LINE
0288+  0700             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  0700             printnl:
0290+  0700 D7          	push a
0291+  0701 10 00 0A    	mov a, $0A00
0292+  0704 05 03       	syscall sys_io
0293+  0706 10 00 0D    	mov a, $0D00
0294+  0709 05 03       	syscall sys_io
0295+  070B E4          	pop a
0296+  070C 09          	ret
0297+  070D             
0298+  070D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  070D             ; strtoint
0300+  070D             ; 4 digit hex string number in d
0301+  070D             ; integer returned in A
0302+  070D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  070D             strtointx:
0304+  070D D8          	push b
0305+  070E 32          	mov bl, [d]
0306+  070F 37          	mov bh, bl
0307+  0710 33 01 00    	mov bl, [d + 1]
0308+  0713 07 CE 05    	call atoi				; convert to int in AL
0309+  0716 23          	mov ah, al				; move to AH
0310+  0717 33 02 00    	mov bl, [d + 2]
0311+  071A 37          	mov bh, bl
0312+  071B 33 03 00    	mov bl, [d + 3]
0313+  071E 07 CE 05    	call atoi				; convert to int in AL
0314+  0721 E5          	pop b
0315+  0722 09          	ret
0316+  0723             
0317+  0723             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  0723             ; strtoint
0319+  0723             ; 5 digit base10 string number in d
0320+  0723             ; integer returned in A
0321+  0723             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  0723             strtoint:
0323+  0723 E2          	push si
0324+  0724 D8          	push b
0325+  0725 D9          	push c
0326+  0726 DA          	push d
0327+  0727 07 4E 05    	call strlen			; get string length in C
0328+  072A 7E          	dec c
0329+  072B FD 4E       	mov si, d
0330+  072D 12          	mov a, c
0331+  072E FD 99       	shl a
0332+  0730 3B B6 05    	mov d, table_power
0333+  0733 59          	add d, a
0334+  0734 38 00 00    	mov c, 0
0335+  0737             strtoint_L0:
0336+  0737 F6          	lodsb			; load ASCII to al
0337+  0738 B9 00       	cmp al, 0
0338+  073A C6 4D 07    	je strtoint_end
0339+  073D 6F 30       	sub al, $30		; make into integer
0340+  073F 22 00       	mov ah, 0
0341+  0741 2A          	mov b, [d]
0342+  0742 AC          	mul a, b			; result in B since it fits in 16bits
0343+  0743 11          	mov a, b
0344+  0744 28          	mov b, c
0345+  0745 54          	add a, b
0346+  0746 39          	mov c, a
0347+  0747 63 02 00    	sub d, 2
0348+  074A 0A 37 07    	jmp strtoint_L0
0349+  074D             strtoint_end:
0350+  074D 12          	mov a, c
0351+  074E E7          	pop d
0352+  074F E6          	pop c
0353+  0750 E5          	pop b
0354+  0751 EF          	pop si
0355+  0752 09          	ret
0356+  0753             
0357+  0753             
0358+  0753             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  0753             ; PRINT NULL TERMINATED STRING
0360+  0753             ; pointer in D
0361+  0753             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  0753             puts:
0363+  0753 D7          	push a
0364+  0754 DA          	push d
0365+  0755             puts_L1:
0366+  0755 1E          	mov al, [d]
0367+  0756 B9 00       	cmp al, 0
0368+  0758 C6 64 07    	jz puts_END
0369+  075B 23          	mov ah, al
0370+  075C 19 00       	mov al, 0
0371+  075E 05 03       	syscall sys_io
0372+  0760 79          	inc d
0373+  0761 0A 55 07    	jmp puts_L1
0374+  0764             puts_END:
0375+  0764 E7          	pop d
0376+  0765 E4          	pop a
0377+  0766 09          	ret
0378+  0767             
0379+  0767             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  0767             ; PRINT N SIZE STRING
0381+  0767             ; pointer in D
0382+  0767             ; size in C
0383+  0767             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  0767             putsn:
0385+  0767 DB          	push al
0386+  0768 DA          	push d
0387+  0769 D9          	push c
0388+  076A             putsn_L0:
0389+  076A 1E          	mov al, [d]
0390+  076B 23          	mov ah, al
0391+  076C 19 00       	mov al, 0
0392+  076E 05 03       	syscall sys_io
0393+  0770 79          	inc d
0394+  0771 7E          	dec c	
0395+  0772 C2 00 00    	cmp c, 0
0396+  0775 C7 6A 07    	jne putsn_L0
0397+  0778             putsn_end:
0398+  0778 E6          	pop c
0399+  0779 E7          	pop d
0400+  077A E8          	pop al
0401+  077B 09          	ret
0402+  077C             
0403+  077C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  077C             ; print 16bit decimal number
0405+  077C             ; input number in A
0406+  077C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  077C             print_u16d:
0408+  077C D7          	push a
0409+  077D D8          	push b
0410+  077E 26 10 27    	mov b, 10000
0411+  0781 AE          	div a, b			; get 10000's coeff.
0412+  0782 07 A4 07    	call print_number
0413+  0785 11          	mov a, b
0414+  0786 26 E8 03    	mov b, 1000
0415+  0789 AE          	div a, b			; get 1000's coeff.
0416+  078A 07 A4 07    	call print_number
0417+  078D 11          	mov a, b
0418+  078E 26 64 00    	mov b, 100
0419+  0791 AE          	div a, b
0420+  0792 07 A4 07    	call print_number
0421+  0795 11          	mov a, b
0422+  0796 26 0A 00    	mov b, 10
0423+  0799 AE          	div a, b
0424+  079A 07 A4 07    	call print_number
0425+  079D 1B          	mov al, bl			; 1's coeff in bl
0426+  079E 07 A4 07    	call print_number
0427+  07A1 E5          	pop b
0428+  07A2 E4          	pop a
0429+  07A3 09          	ret
0430+  07A4             
0431+  07A4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0432+  07A4             ; print AL
0433+  07A4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0434+  07A4             print_number:
0435+  07A4 6A 30       	add al, $30
0436+  07A6 23          	mov ah, al
0437+  07A7 07 19 06    	call putchar
0438+  07AA 09          	ret
0439+  07AB             
0440+  07AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0441+  07AB             ; PRINT 16BIT HEX INTEGER
0442+  07AB             ; integer value in reg B
0443+  07AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0444+  07AB             print_u16x:
0445+  07AB D7          	push a
0446+  07AC D8          	push b
0447+  07AD DD          	push bl
0448+  07AE 30          	mov bl, bh
0449+  07AF 07 E0 05    	call itoa				; convert bh to char in A
0450+  07B2 2F          	mov bl, al				; save al
0451+  07B3 19 00       	mov al, 0
0452+  07B5 05 03       	syscall sys_io				; display AH
0453+  07B7 24          	mov ah, bl				; retrieve al
0454+  07B8 19 00       	mov al, 0
0455+  07BA 05 03       	syscall sys_io				; display AL
0456+  07BC             
0457+  07BC EA          	pop bl
0458+  07BD 07 E0 05    	call itoa				; convert bh to char in A
0459+  07C0 2F          	mov bl, al				; save al
0460+  07C1 19 00       	mov al, 0
0461+  07C3 05 03       	syscall sys_io				; display AH
0462+  07C5 24          	mov ah, bl				; retrieve al
0463+  07C6 19 00       	mov al, 0
0464+  07C8 05 03       	syscall sys_io				; display AL
0465+  07CA             
0466+  07CA E5          	pop b
0467+  07CB E4          	pop a
0468+  07CC 09          	ret
0469+  07CD             
0470+  07CD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0471+  07CD             ; INPUT 16BIT HEX INTEGER
0472+  07CD             ; read 16bit integer into A
0473+  07CD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0474+  07CD             scan_u16x:
0475+  07CD F8 10 00    	enter 16
0476+  07D0 D8          	push b
0477+  07D1 DA          	push d
0478+  07D2             
0479+  07D2 FA F1 FF    	lea d, [bp + -15]
0480+  07D5 07 20 06    	call gets				; get number
0481+  07D8             
0482+  07D8 32          	mov bl, [d]
0483+  07D9 37          	mov bh, bl
0484+  07DA 33 01 00    	mov bl, [d + 1]
0485+  07DD 07 CE 05    	call atoi				; convert to int in AL
0486+  07E0 23          	mov ah, al				; move to AH
0487+  07E1             
0488+  07E1 33 02 00    	mov bl, [d + 2]
0489+  07E4 37          	mov bh, bl
0490+  07E5 33 03 00    	mov bl, [d + 3]
0491+  07E8 07 CE 05    	call atoi				; convert to int in AL
0492+  07EB             
0493+  07EB E7          	pop d
0494+  07EC E5          	pop b
0495+  07ED F9          	leave
0496+  07EE 09          	ret
0497+  07EF             
0498+  07EF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0499+  07EF             ; PRINT 8bit HEX INTEGER
0500+  07EF             ; integer value in reg bl
0501+  07EF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0502+  07EF             print_u8x:
0503+  07EF D7          	push a
0504+  07F0 DD          	push bl
0505+  07F1             
0506+  07F1 07 E0 05    	call itoa				; convert bl to char in A
0507+  07F4 2F          	mov bl, al				; save al
0508+  07F5 19 00       	mov al, 0
0509+  07F7 05 03       	syscall sys_io				; display AH
0510+  07F9 24          	mov ah, bl				; retrieve al
0511+  07FA 19 00       	mov al, 0
0512+  07FC 05 03       	syscall sys_io				; display AL
0513+  07FE             
0514+  07FE EA          	pop bl
0515+  07FF E4          	pop a
0516+  0800 09          	ret
0517+  0801             
0518+  0801             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0519+  0801             ; print 8bit decimal unsigned number
0520+  0801             ; input number in AL
0521+  0801             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0522+  0801             print_u8d:
0523+  0801 D7          	push a
0524+  0802 D8          	push b
0525+  0803             
0526+  0803 22 00       	mov ah, 0
0527+  0805 26 64 00    	mov b, 100
0528+  0808 AE          	div a, b
0529+  0809 D8          	push b			; save remainder
0530+  080A B9 00       	cmp al, 0
0531+  080C C6 16 08    	je skip100
0532+  080F 6A 30       	add al, $30
0533+  0811 23          	mov ah, al
0534+  0812 19 00       	mov al, 0
0535+  0814 05 03       	syscall sys_io	; print coeff
0536+  0816             skip100:
0537+  0816 E4          	pop a
0538+  0817 22 00       	mov ah, 0
0539+  0819 26 0A 00    	mov b, 10
0540+  081C AE          	div a, b
0541+  081D D8          	push b			; save remainder
0542+  081E B9 00       	cmp al, 0
0543+  0820 C6 2A 08    	je skip10
0544+  0823 6A 30       	add al, $30
0545+  0825 23          	mov ah, al
0546+  0826 19 00       	mov al, 0
0547+  0828 05 03       	syscall sys_io	; print coeff
0548+  082A             skip10:
0549+  082A E4          	pop a
0550+  082B 1B          	mov al, bl
0551+  082C 6A 30       	add al, $30
0552+  082E 23          	mov ah, al
0553+  082F 19 00       	mov al, 0
0554+  0831 05 03       	syscall sys_io	; print coeff
0555+  0833 E5          	pop b
0556+  0834 E4          	pop a
0557+  0835 09          	ret
0558+  0836             
0559+  0836             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0560+  0836             ; INPUT 8BIT HEX INTEGER
0561+  0836             ; read 8bit integer into AL
0562+  0836             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0563+  0836             scan_u8x:
0564+  0836 F8 04 00    	enter 4
0565+  0839 D8          	push b
0566+  083A DA          	push d
0567+  083B             
0568+  083B FA FD FF    	lea d, [bp + -3]
0569+  083E 07 20 06    	call gets				; get number
0570+  0841             
0571+  0841 32          	mov bl, [d]
0572+  0842 37          	mov bh, bl
0573+  0843 33 01 00    	mov bl, [d + 1]
0574+  0846 07 CE 05    	call atoi				; convert to int in AL
0575+  0849             
0576+  0849 E7          	pop d
0577+  084A E5          	pop b
0578+  084B F9          	leave
0579+  084C 09          	ret
0580+  084D             
0581+  084D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0582+  084D             ; input decimal number
0583+  084D             ; result in A
0584+  084D             ; 655'\0'
0585+  084D             ; low--------high
0586+  084D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  084D             scan_u16d:
0588+  084D F8 08 00    	enter 8
0589+  0850 E2          	push si
0590+  0851 D8          	push b
0591+  0852 D9          	push c
0592+  0853 DA          	push d
0593+  0854 FA F9 FF    	lea d, [bp +- 7]
0594+  0857 07 20 06    	call gets
0595+  085A 07 4E 05    	call strlen			; get string length in C
0596+  085D 7E          	dec c
0597+  085E FD 4E       	mov si, d
0598+  0860 12          	mov a, c
0599+  0861 FD 99       	shl a
0600+  0863 3B B6 05    	mov d, table_power
0601+  0866 59          	add d, a
0602+  0867 38 00 00    	mov c, 0
0603+  086A             mul_loop:
0604+  086A F6          	lodsb			; load ASCII to al
0605+  086B B9 00       	cmp al, 0
0606+  086D C6 80 08    	je mul_exit
0607+  0870 6F 30       	sub al, $30		; make into integer
0608+  0872 22 00       	mov ah, 0
0609+  0874 2A          	mov b, [d]
0610+  0875 AC          	mul a, b			; result in B since it fits in 16bits
0611+  0876 11          	mov a, b
0612+  0877 28          	mov b, c
0613+  0878 54          	add a, b
0614+  0879 39          	mov c, a
0615+  087A 63 02 00    	sub d, 2
0616+  087D 0A 6A 08    	jmp mul_loop
0617+  0880             mul_exit:
0618+  0880 12          	mov a, c
0619+  0881 E7          	pop d
0620+  0882 E6          	pop c
0621+  0883 E5          	pop b
0622+  0884 EF          	pop si
0623+  0885 F9          	leave
0624+  0886 09          	ret
0051   0887             
0052   0887             
0053   0887             .end
0054   0887             
0055   0887             
0056   0887             
tasm: Number of errors = 0
