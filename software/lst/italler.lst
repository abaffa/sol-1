0001   0000             .include "kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0002   0000             
0003   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0005   0000             
0006   0400             .org PROC_TEXT_ORG			; origin at 1024
0007   0400             
0008   0400             ; when running the installer, we need to be inside /boot because the mkbin system call
0009   0400             ; creates all binary files inside whatever is the current directory
0010   0400             ; and we want the kernel to live inside /boot
0011   0400             bootloader_installer:
0012   0400             ;; create the kernel file
0013   0400 3B 36 04      mov d, s_warning
0014   0403 07 4B 07      call puts
0015   0406 3B 6F 04      mov d, s_enter_filename
0016   0409 07 4B 07      call puts
0017   040C 3B 81 04      mov d, kernel_filename
0018   040F 07 18 06      call gets
0019   0412             
0020   0412 3B 6C 04      mov d, s_prompt 
0021   0415 07 4B 07      call puts
0022   0418 3B 81 04    	mov d, kernel_filename
0023   041B 19 06       	mov al, 6               ; mkbin
0024   041D 05 04       	syscall sys_fileio      ; create the binary file for the kernel
0025   041F                                       ; we need to be on '/boot' here
0026   041F             
0027   041F FD 4D 81 04   mov si, kernel_filename
0028   0423 FD 4F C1 04   mov di, kernel_fullpath
0029   0427 07 81 05      call strcat             ; form full pathname for the kernel file
0030   042A 3B C1 04    	mov d, kernel_fullpath
0031   042D 19 13       	mov al, 19
0032   042F 05 04       	syscall sys_fileio		; obtain dirID for kernel file, in A
0033   0431 77          	inc a					; increment LBA because data starts after the header sector
0034   0432 05 0D       	syscall sys_boot_install
0035   0434             
0036   0434 05 0B       	syscall sys_terminate_proc
0037   0436             
0038   0436             
0039   0436             
0040   0436 4D 61 6B 65 s_warning:        .db "Make sure you are in "
0040   043A 20 73 75 72 
0040   043E 65 20 79 6F 
0040   0442 75 20 61 72 
0040   0446 65 20 69 6E 
0040   044A 20 
0041   044B 2F 62 6F 6F 									.db "/boot before creating "
0041   044F 74 20 62 65 
0041   0453 66 6F 72 65 
0041   0457 20 63 72 65 
0041   045B 61 74 69 6E 
0041   045F 67 20 
0042   0461 74 68 65 20 									.db "the file.\n", 0
0042   0465 66 69 6C 65 
0042   0469 2E 0A 00 
0043   046C             
0044   046C 25 20 00    s_prompt:         .db "% ", 0
0045   046F 4B 65 72 6E s_enter_filename: .db "Kernel filename: ", 0
0045   0473 65 6C 20 66 
0045   0477 69 6C 65 6E 
0045   047B 61 6D 65 3A 
0045   047F 20 00 
0046   0481 00 00 00 00 kernel_filename:    .fill 64, 0
0046   0485 00 00 00 00 
0046   0489 00 00 00 00 
0046   048D 00 00 00 00 
0046   0491 00 00 00 00 
0046   0495 00 00 00 00 
0046   0499 00 00 00 00 
0046   049D 00 00 00 00 
0046   04A1 00 00 00 00 
0046   04A5 00 00 00 00 
0046   04A9 00 00 00 00 
0046   04AD 00 00 00 00 
0046   04B1 00 00 00 00 
0046   04B5 00 00 00 00 
0046   04B9 00 00 00 00 
0046   04BD 00 00 00 00 
0047   04C1 2F 62 6F 6F kernel_fullpath:  	.db "/boot/"
0047   04C5 74 2F 
0048   04C7 00 00 00 00                     .fill 64, 0
0048   04CB 00 00 00 00 
0048   04CF 00 00 00 00 
0048   04D3 00 00 00 00 
0048   04D7 00 00 00 00 
0048   04DB 00 00 00 00 
0048   04DF 00 00 00 00 
0048   04E3 00 00 00 00 
0048   04E7 00 00 00 00 
0048   04EB 00 00 00 00 
0048   04EF 00 00 00 00 
0048   04F3 00 00 00 00 
0048   04F7 00 00 00 00 
0048   04FB 00 00 00 00 
0048   04FF 00 00 00 00 
0048   0503 00 00 00 00 
0049   0507             
0050   0507             .include "stdio.asm"
0001+  0507             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0507             ; stdio.s
0003+  0507             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0507             .include "string.asm"
0001++ 0507             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0507             ; string.s
0003++ 0507             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0507             
0005++ 0507             
0006++ 0507             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0507             ; strrev
0008++ 0507             ; reverse a string
0009++ 0507             ; D = string address
0010++ 0507             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0507             ; 01234
0012++ 0507             strrev:
0013++ 0507 4B          	pusha
0014++ 0508 07 4E 05    	call strlen	; length in C
0015++ 050B 12          	mov a, c
0016++ 050C AF 01 00    	cmp a, 1
0017++ 050F D0 29 05    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0512 7D          	dec a
0019++ 0513 FD 4E       	mov si, d	; beginning of string
0020++ 0515 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0517 59          	add d, a	; end of string
0022++ 0518 12          	mov a, c
0023++ 0519 FD 9B       	shr a		; divide by 2
0024++ 051B 39          	mov c, a	; C now counts the steps
0025++ 051C             strrev_L0:
0026++ 051C 32          	mov bl, [d]	; save load right-side char into BL
0027++ 051D F6          	lodsb		; load left-side char into AL; increase SI
0028++ 051E 3E          	mov [d], al	; store left char into right side
0029++ 051F 1B          	mov al, bl
0030++ 0520 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0521 7E          	dec c
0032++ 0522 7F          	dec d
0033++ 0523 C2 00 00    	cmp c, 0
0034++ 0526 C7 1C 05    	jne strrev_L0
0035++ 0529             strrev_end:
0036++ 0529 4C          	popa
0037++ 052A 09          	ret
0038++ 052B             	
0039++ 052B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 052B             ; strchr
0041++ 052B             ; search string in D for char in AL
0042++ 052B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 052B             strchr:
0044++ 052B             strchr_L0:
0045++ 052B 32          	mov bl, [d]
0046++ 052C C1 00       	cmp bl, 0
0047++ 052E C6 39 05    	je strchr_end
0048++ 0531 BA          	cmp al, bl
0049++ 0532 C6 39 05    	je strchr_end
0050++ 0535 79          	inc d
0051++ 0536 0A 2B 05    	jmp strchr_L0
0052++ 0539             strchr_end:
0053++ 0539 1B          	mov al, bl
0054++ 053A 09          	ret
0055++ 053B             
0056++ 053B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 053B             ; strstr
0058++ 053B             ; find sub-string
0059++ 053B             ; str1 in SI
0060++ 053B             ; str2 in DI
0061++ 053B             ; SI points to end of source string
0062++ 053B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 053B             strstr:
0064++ 053B DB          	push al
0065++ 053C DA          	push d
0066++ 053D E3          	push di
0067++ 053E             strstr_loop:
0068++ 053E F3          	cmpsb					; compare a byte of the strings
0069++ 053F C7 4A 05    	jne strstr_ret
0070++ 0542 FC 00 00    	lea d, [di + 0]
0071++ 0545 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0547 C7 3E 05    	jne strstr_loop				; equal chars but not at end
0073++ 054A             strstr_ret:
0074++ 054A F0          	pop di
0075++ 054B E7          	pop d
0076++ 054C E8          	pop al
0077++ 054D 09          	ret
0078++ 054E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 054E             ; length of null terminated string
0080++ 054E             ; result in C
0081++ 054E             ; pointer in D
0082++ 054E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 054E             strlen:
0084++ 054E DA          	push d
0085++ 054F 38 00 00    	mov c, 0
0086++ 0552             strlen_L1:
0087++ 0552 BD 00       	cmp byte [d], 0
0088++ 0554 C6 5C 05    	je strlen_ret
0089++ 0557 79          	inc d
0090++ 0558 78          	inc c
0091++ 0559 0A 52 05    	jmp strlen_L1
0092++ 055C             strlen_ret:
0093++ 055C E7          	pop d
0094++ 055D 09          	ret
0095++ 055E             
0096++ 055E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 055E             ; STRCMP
0098++ 055E             ; compare two strings
0099++ 055E             ; str1 in SI
0100++ 055E             ; str2 in DI
0101++ 055E             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 055E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 055E             strcmp:
0104++ 055E DB          	push al
0105++ 055F DA          	push d
0106++ 0560 E3          	push di
0107++ 0561 E2          	push si
0108++ 0562             strcmp_loop:
0109++ 0562 F3          	cmpsb					; compare a byte of the strings
0110++ 0563 C7 6E 05    	jne strcmp_ret
0111++ 0566 FB FF FF    	lea d, [si +- 1]
0112++ 0569 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 056B C7 62 05    	jne strcmp_loop				; equal chars but not at end
0114++ 056E             strcmp_ret:
0115++ 056E EF          	pop si
0116++ 056F F0          	pop di
0117++ 0570 E7          	pop d
0118++ 0571 E8          	pop al
0119++ 0572 09          	ret
0120++ 0573             
0121++ 0573             
0122++ 0573             ; STRCPY
0123++ 0573             ; copy null terminated string from SI to DI
0124++ 0573             ; source in SI
0125++ 0573             ; destination in DI
0126++ 0573             strcpy:
0127++ 0573 E2          	push si
0128++ 0574 E3          	push di
0129++ 0575 DB          	push al
0130++ 0576             strcpy_L1:
0131++ 0576 F6          	lodsb
0132++ 0577 F7          	stosb
0133++ 0578 B9 00       	cmp al, 0
0134++ 057A C7 76 05    	jne strcpy_L1
0135++ 057D             strcpy_end:
0136++ 057D E8          	pop al
0137++ 057E F0          	pop di
0138++ 057F EF          	pop si
0139++ 0580 09          	ret
0140++ 0581             
0141++ 0581             ; STRCAT
0142++ 0581             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0581             ; source in SI
0144++ 0581             ; destination in DI
0145++ 0581             strcat:
0146++ 0581 E2          	push si
0147++ 0582 E3          	push di
0148++ 0583 D7          	push a
0149++ 0584 DA          	push d
0150++ 0585 50          	mov a, di
0151++ 0586 3C          	mov d, a
0152++ 0587             strcat_goto_end_L1:
0153++ 0587 BD 00       	cmp byte[d], 0
0154++ 0589 C6 90 05    	je strcat_start
0155++ 058C 79          	inc d
0156++ 058D 0A 87 05    	jmp strcat_goto_end_L1
0157++ 0590             strcat_start:
0158++ 0590 FD 50       	mov di, d
0159++ 0592             strcat_L1:
0160++ 0592 F6          	lodsb
0161++ 0593 F7          	stosb
0162++ 0594 B9 00       	cmp al, 0
0163++ 0596 C7 92 05    	jne strcat_L1
0164++ 0599             strcat_end:
0165++ 0599 E7          	pop d
0166++ 059A E4          	pop a
0167++ 059B F0          	pop di
0168++ 059C EF          	pop si
0169++ 059D 09          	ret
0005+  059E             
0006+  059E 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  05A2 34 35 36 37 
0006+  05A6 38 39 41 42 
0006+  05AA 43 44 45 46 
0007+  05AE             
0008+  05AE 01 00       table_power:.dw 1
0009+  05B0 0A 00       			.dw 10
0010+  05B2 64 00       			.dw 100
0011+  05B4 E8 03       			.dw 1000
0012+  05B6 10 27       			.dw 10000
0013+  05B8             
0014+  05B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0015+  05B8             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0016+  05B8             ; ASCII in BL
0017+  05B8             ; result in AL
0018+  05B8             ; ascii for F = 0100 0110
0019+  05B8             ; ascii for 9 = 0011 1001
0020+  05B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0021+  05B8             hex_ascii_encode:
0022+  05B8 1B          	mov al, bl
0023+  05B9 93 40       	test al, $40				; test if letter or number
0024+  05BB C7 C1 05    	jnz hex_letter
0025+  05BE 87 0F       	and al, $0F				; get number
0026+  05C0 09          	ret
0027+  05C1             hex_letter:
0028+  05C1 87 0F       	and al, $0F				; get letter
0029+  05C3 6A 09       	add al, 9
0030+  05C5 09          	ret
0031+  05C6             
0032+  05C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0033+  05C6             ; ATOI
0034+  05C6             ; 2 letter hex string in B
0035+  05C6             ; 8bit integer returned in AL
0036+  05C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0037+  05C6             atoi:
0038+  05C6 D8          	push b
0039+  05C7 07 B8 05    	call hex_ascii_encode			; convert BL to 4bit code in AL
0040+  05CA 30          	mov bl, bh
0041+  05CB DB          	push al					; save a
0042+  05CC 07 B8 05    	call hex_ascii_encode
0043+  05CF EA          	pop bl	
0044+  05D0 FD 9E 04    	shl al, 4
0045+  05D3 8C          	or al, bl
0046+  05D4 E5          	pop b
0047+  05D5 09          	ret	
0048+  05D6             
0049+  05D6             
0050+  05D6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  05D6             ; printf
0052+  05D6             ; no need for explanations!
0053+  05D6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0054+  05D6             printf:
0055+  05D6 09          	ret
0056+  05D7             
0057+  05D7             
0058+  05D7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  05D7             ; scanf
0060+  05D7             ; no need for explanations!
0061+  05D7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  05D7             scanf:
0063+  05D7 09          	ret
0064+  05D8             
0065+  05D8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  05D8             ; ITOA
0067+  05D8             ; 8bit value in BL
0068+  05D8             ; 2 byte ASCII result in A
0069+  05D8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0070+  05D8             itoa:
0071+  05D8 DA          	push d
0072+  05D9 D8          	push b
0073+  05DA A7 00       	mov bh, 0
0074+  05DC FD A4 04    	shr bl, 4	
0075+  05DF 74          	mov d, b
0076+  05E0 1F 9E 05    	mov al, [d + s_hex_digits]
0077+  05E3 23          	mov ah, al
0078+  05E4             	
0079+  05E4 E5          	pop b
0080+  05E5 D8          	push b
0081+  05E6 A7 00       	mov bh, 0
0082+  05E8 FD 87 0F    	and bl, $0F
0083+  05EB 74          	mov d, b
0084+  05EC 1F 9E 05    	mov al, [d + s_hex_digits]
0085+  05EF E5          	pop b
0086+  05F0 E7          	pop d
0087+  05F1 09          	ret
0088+  05F2             
0089+  05F2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0090+  05F2             ; HEX STRING TO BINARY
0091+  05F2             ; di = destination address
0092+  05F2             ; si = source
0093+  05F2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0094+  05F2             hex_to_int:
0095+  05F2             hex_to_int_L1:
0096+  05F2 F6          	lodsb					; load from [SI] to AL
0097+  05F3 B9 00       	cmp al, 0				; check if ASCII 0
0098+  05F5 C6 02 06    	jz hex_to_int_ret
0099+  05F8 36          	mov bh, al
0100+  05F9 F6          	lodsb
0101+  05FA 2F          	mov bl, al
0102+  05FB 07 C6 05    	call atoi				; convert ASCII byte in B to int (to AL)
0103+  05FE F7          	stosb					; store AL to [DI]
0104+  05FF 0A F2 05    	jmp hex_to_int_L1
0105+  0602             hex_to_int_ret:
0106+  0602 09          	ret		
0107+  0603             
0108+  0603             
0109+  0603             
0110+  0603             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  0603             ; GETCHAR
0112+  0603             ; char in ah
0113+  0603             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0114+  0603             getchar:
0115+  0603 DB          	push al
0116+  0604             getchar_retry:
0117+  0604 FD 0C       	sti
0118+  0606 19 01       	mov al, 1
0119+  0608 05 03       	syscall sys_io			; receive in AH
0120+  060A B9 00       	cmp al, 0			; check if any char was receive
0121+  060C C6 04 06    	je getchar_retry
0122+  060F E8          	pop al
0123+  0610 09          	ret
0124+  0611             
0125+  0611             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0126+  0611             ; PUTCHAR
0127+  0611             ; char in ah
0128+  0611             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  0611             putchar:
0130+  0611 D7          	push a
0131+  0612 19 00       	mov al, 0
0132+  0614 05 03       	syscall sys_io			; char in AH
0133+  0616 E4          	pop a
0134+  0617 09          	ret
0135+  0618             
0136+  0618             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0137+  0618             ;; INPUT A STRING
0138+  0618             ;; terminates with null
0139+  0618             ;; pointer in D
0140+  0618             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  0618             gets:
0142+  0618 D7          	push a
0143+  0619 DA          	push d
0144+  061A             gets_loop:
0145+  061A FD 0C       	sti
0146+  061C 19 01       	mov al, 1
0147+  061E 05 03       	syscall sys_io			; receive in AH
0148+  0620 B9 00       	cmp al, 0				; check error code (AL)
0149+  0622 C6 1A 06    	je gets_loop			; if no char received, retry
0150+  0625             
0151+  0625 76 1B       	cmp ah, 27
0152+  0627 C6 48 06    	je gets_telnet_escape
0153+  062A 76 0A       	cmp ah, $0A				; LF
0154+  062C C6 A1 06    	je gets_end
0155+  062F 76 0D       	cmp ah, $0D				; CR
0156+  0631 C6 A1 06    	je gets_end
0157+  0634 76 5C       	cmp ah, $5C				; '\\'
0158+  0636 C6 78 06    	je gets_escape
0159+  0639             	
0160+  0639 76 08       	cmp ah, $08			; check for backspace
0161+  063B C6 44 06    	je gets_backspace
0162+  063E             
0163+  063E 1A          	mov al, ah
0164+  063F 3E          	mov [d], al
0165+  0640 79          	inc d
0166+  0641 0A 1A 06    	jmp gets_loop
0167+  0644             gets_backspace:
0168+  0644 7F          	dec d
0169+  0645 0A 1A 06    	jmp gets_loop
0170+  0648             gets_telnet_escape:
0171+  0648 FD 0C       	sti
0172+  064A 19 01       	mov al, 1
0173+  064C 05 03       	syscall sys_io				; receive in AH without echo
0174+  064E B9 00       	cmp al, 0					; check error code (AL)
0175+  0650 C6 48 06    	je gets_telnet_escape		; if no char received, retry
0176+  0653 76 5B       	cmp ah, '['
0177+  0655 C7 1A 06    	jne gets_loop
0178+  0658             gets_telnet_escape_phase2:
0179+  0658 FD 0C       	sti
0180+  065A 19 01       	mov al, 1
0181+  065C 05 03       	syscall sys_io					; receive in AH without echo
0182+  065E B9 00       	cmp al, 0						; check error code (AL)
0183+  0660 C6 58 06    	je gets_telnet_escape_phase2	; if no char received, retry
0184+  0663 76 44       	cmp ah, 'D'
0185+  0665 C6 70 06    	je gets_left_arrow
0186+  0668 76 43       	cmp ah, 'C'
0187+  066A C6 74 06    	je gets_right_arrow
0188+  066D 0A 1A 06    	jmp gets_loop
0189+  0670             gets_left_arrow:
0190+  0670 7F          	dec d
0191+  0671 0A 1A 06    	jmp gets_loop
0192+  0674             gets_right_arrow:
0193+  0674 79          	inc d
0194+  0675 0A 1A 06    	jmp gets_loop
0195+  0678             gets_escape:
0196+  0678 FD 0C       	sti
0197+  067A 19 01       	mov al, 1
0198+  067C 05 03       	syscall sys_io			; receive in AH
0199+  067E B9 00       	cmp al, 0				; check error code (AL)
0200+  0680 C6 78 06    	je gets_escape			; if no char received, retry
0201+  0683 76 6E       	cmp ah, 'n'
0202+  0685 C6 93 06    	je gets_LF
0203+  0688 76 72       	cmp ah, 'r'
0204+  068A C6 9A 06    	je gets_CR
0205+  068D 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0206+  068E 3E          	mov [d], al
0207+  068F 79          	inc d
0208+  0690 0A 1A 06    	jmp gets_loop
0209+  0693             gets_LF:
0210+  0693 19 0A       	mov al, $0A
0211+  0695 3E          	mov [d], al
0212+  0696 79          	inc d
0213+  0697 0A 1A 06    	jmp gets_loop
0214+  069A             gets_CR:
0215+  069A 19 0D       	mov al, $0D
0216+  069C 3E          	mov [d], al
0217+  069D 79          	inc d
0218+  069E 0A 1A 06    	jmp gets_loop
0219+  06A1             gets_end:
0220+  06A1 19 00       	mov al, 0
0221+  06A3 3E          	mov [d], al				; terminate string
0222+  06A4 E7          	pop d
0223+  06A5 E4          	pop a
0224+  06A6 09          	ret
0225+  06A7             
0226+  06A7             
0227+  06A7             
0228+  06A7             
0229+  06A7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0230+  06A7             ;; INPUT TEXT
0231+  06A7             ;; terminated with CTRL+D
0232+  06A7             ;; pointer in D
0233+  06A7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0234+  06A7             gettxt:
0235+  06A7 D7          	push a
0236+  06A8 DA          	push d
0237+  06A9             gettxt_loop:
0238+  06A9 19 01       	mov al, 1
0239+  06AB 05 03       	syscall sys_io			; receive in AH
0240+  06AD B9 00       	cmp al, 0				; check error code (AL)
0241+  06AF C6 A9 06    	je gettxt_loop		; if no char received, retry
0242+  06B2 76 04       	cmp ah, 4			; EOT
0243+  06B4 C6 F2 06    	je gettxt_end
0244+  06B7 76 08       	cmp ah, $08			; check for backspace
0245+  06B9 C6 EE 06    	je gettxt_backspace
0246+  06BC 76 5C       	cmp ah, $5C				; '\\'
0247+  06BE C6 C7 06    	je gettxt_escape
0248+  06C1 1A          	mov al, ah
0249+  06C2 3E          	mov [d], al
0250+  06C3 79          	inc d
0251+  06C4 0A A9 06    	jmp gettxt_loop
0252+  06C7             gettxt_escape:
0253+  06C7 19 01       	mov al, 1
0254+  06C9 05 03       	syscall sys_io			; receive in AH
0255+  06CB B9 00       	cmp al, 0				; check error code (AL)
0256+  06CD C6 C7 06    	je gettxt_escape		; if no char received, retry
0257+  06D0 76 6E       	cmp ah, 'n'
0258+  06D2 C6 E0 06    	je gettxt_LF
0259+  06D5 76 72       	cmp ah, 'r'
0260+  06D7 C6 E7 06    	je gettxt_CR
0261+  06DA 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0262+  06DB 3E          	mov [d], al
0263+  06DC 79          	inc d
0264+  06DD 0A A9 06    	jmp gettxt_loop
0265+  06E0             gettxt_LF:
0266+  06E0 19 0A       	mov al, $0A
0267+  06E2 3E          	mov [d], al
0268+  06E3 79          	inc d
0269+  06E4 0A A9 06    	jmp gettxt_loop
0270+  06E7             gettxt_CR:
0271+  06E7 19 0D       	mov al, $0D
0272+  06E9 3E          	mov [d], al
0273+  06EA 79          	inc d
0274+  06EB 0A A9 06    	jmp gettxt_loop
0275+  06EE             gettxt_backspace:
0276+  06EE 7F          	dec d
0277+  06EF 0A A9 06    	jmp gettxt_loop
0278+  06F2             gettxt_end:
0279+  06F2 19 00       	mov al, 0
0280+  06F4 3E          	mov [d], al				; terminate string
0281+  06F5 E7          	pop d
0282+  06F6 E4          	pop a
0283+  06F7 09          	ret
0284+  06F8             
0285+  06F8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0286+  06F8             ; PRINT NEW LINE
0287+  06F8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  06F8             printnl:
0289+  06F8 D7          	push a
0290+  06F9 10 00 0A    	mov a, $0A00
0291+  06FC 05 03       	syscall sys_io
0292+  06FE 10 00 0D    	mov a, $0D00
0293+  0701 05 03       	syscall sys_io
0294+  0703 E4          	pop a
0295+  0704 09          	ret
0296+  0705             
0297+  0705             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0298+  0705             ; strtoint
0299+  0705             ; 4 digit hex string number in d
0300+  0705             ; integer returned in A
0301+  0705             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0302+  0705             strtointx:
0303+  0705 D8          	push b
0304+  0706 32          	mov bl, [d]
0305+  0707 37          	mov bh, bl
0306+  0708 33 01 00    	mov bl, [d + 1]
0307+  070B 07 C6 05    	call atoi				; convert to int in AL
0308+  070E 23          	mov ah, al				; move to AH
0309+  070F 33 02 00    	mov bl, [d + 2]
0310+  0712 37          	mov bh, bl
0311+  0713 33 03 00    	mov bl, [d + 3]
0312+  0716 07 C6 05    	call atoi				; convert to int in AL
0313+  0719 E5          	pop b
0314+  071A 09          	ret
0315+  071B             
0316+  071B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0317+  071B             ; strtoint
0318+  071B             ; 5 digit base10 string number in d
0319+  071B             ; integer returned in A
0320+  071B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0321+  071B             strtoint:
0322+  071B E2          	push si
0323+  071C D8          	push b
0324+  071D D9          	push c
0325+  071E DA          	push d
0326+  071F 07 4E 05    	call strlen			; get string length in C
0327+  0722 7E          	dec c
0328+  0723 FD 4E       	mov si, d
0329+  0725 12          	mov a, c
0330+  0726 FD 99       	shl a
0331+  0728 3B AE 05    	mov d, table_power
0332+  072B 59          	add d, a
0333+  072C 38 00 00    	mov c, 0
0334+  072F             strtoint_L0:
0335+  072F F6          	lodsb			; load ASCII to al
0336+  0730 B9 00       	cmp al, 0
0337+  0732 C6 45 07    	je strtoint_end
0338+  0735 6F 30       	sub al, $30		; make into integer
0339+  0737 22 00       	mov ah, 0
0340+  0739 2A          	mov b, [d]
0341+  073A AC          	mul a, b			; result in B since it fits in 16bits
0342+  073B 11          	mov a, b
0343+  073C 28          	mov b, c
0344+  073D 54          	add a, b
0345+  073E 39          	mov c, a
0346+  073F 63 02 00    	sub d, 2
0347+  0742 0A 2F 07    	jmp strtoint_L0
0348+  0745             strtoint_end:
0349+  0745 12          	mov a, c
0350+  0746 E7          	pop d
0351+  0747 E6          	pop c
0352+  0748 E5          	pop b
0353+  0749 EF          	pop si
0354+  074A 09          	ret
0355+  074B             
0356+  074B             
0357+  074B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0358+  074B             ; PRINT NULL TERMINATED STRING
0359+  074B             ; pointer in D
0360+  074B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0361+  074B             puts:
0362+  074B D7          	push a
0363+  074C DA          	push d
0364+  074D             puts_L1:
0365+  074D 1E          	mov al, [d]
0366+  074E B9 00       	cmp al, 0
0367+  0750 C6 5C 07    	jz puts_END
0368+  0753 23          	mov ah, al
0369+  0754 19 00       	mov al, 0
0370+  0756 05 03       	syscall sys_io
0371+  0758 79          	inc d
0372+  0759 0A 4D 07    	jmp puts_L1
0373+  075C             puts_END:
0374+  075C E7          	pop d
0375+  075D E4          	pop a
0376+  075E 09          	ret
0377+  075F             
0378+  075F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  075F             ; PRINT N SIZE STRING
0380+  075F             ; pointer in D
0381+  075F             ; size in C
0382+  075F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0383+  075F             putsn:
0384+  075F DB          	push al
0385+  0760 DA          	push d
0386+  0761 D9          	push c
0387+  0762             putsn_L0:
0388+  0762 1E          	mov al, [d]
0389+  0763 23          	mov ah, al
0390+  0764 19 00       	mov al, 0
0391+  0766 05 03       	syscall sys_io
0392+  0768 79          	inc d
0393+  0769 7E          	dec c	
0394+  076A C2 00 00    	cmp c, 0
0395+  076D C7 62 07    	jne putsn_L0
0396+  0770             putsn_end:
0397+  0770 E6          	pop c
0398+  0771 E7          	pop d
0399+  0772 E8          	pop al
0400+  0773 09          	ret
0401+  0774             
0402+  0774             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0403+  0774             ; print 16bit decimal number
0404+  0774             ; input number in A
0405+  0774             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  0774             print_u16d:
0407+  0774 D7          	push a
0408+  0775 D8          	push b
0409+  0776 26 10 27    	mov b, 10000
0410+  0779 AE          	div a, b			; get 10000 coeff.
0411+  077A 07 A0 07    	call print_number
0412+  077D 11          	mov a, b
0413+  077E 26 E8 03    	mov b, 1000
0414+  0781 AE          	div a, b			; get 10000 coeff.
0415+  0782 07 A0 07    	call print_number
0416+  0785 11          	mov a, b
0417+  0786 26 64 00    	mov b, 100
0418+  0789 AE          	div a, b
0419+  078A 07 A0 07    	call print_number
0420+  078D 11          	mov a, b
0421+  078E 26 0A 00    	mov b, 10
0422+  0791 AE          	div a, b
0423+  0792 07 A0 07    	call print_number
0424+  0795 11          	mov a, b
0425+  0796 6A 30       	add al, $30
0426+  0798 23          	mov ah, al
0427+  0799 19 00       	mov al, 0
0428+  079B 05 03       	syscall sys_io	; print coeff
0429+  079D E5          	pop b
0430+  079E E4          	pop a
0431+  079F 09          	ret
0432+  07A0             
0433+  07A0             
0434+  07A0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0435+  07A0             ; if A == 0, print space
0436+  07A0             ; else print A
0437+  07A0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0438+  07A0             print_number:
0439+  07A0 6A 30       	add al, $30
0440+  07A2 23          	mov ah, al
0441+  07A3 07 11 06    	call putchar
0442+  07A6 09          	ret
0443+  07A7             
0444+  07A7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  07A7             ; PRINT 16BIT HEX INTEGER
0446+  07A7             ; integer value in reg B
0447+  07A7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  07A7             print_u16x:
0449+  07A7 D7          	push a
0450+  07A8 D8          	push b
0451+  07A9 DD          	push bl
0452+  07AA 30          	mov bl, bh
0453+  07AB 07 D8 05    	call itoa				; convert bh to char in A
0454+  07AE 2F          	mov bl, al				; save al
0455+  07AF 19 00       	mov al, 0
0456+  07B1 05 03       	syscall sys_io				; display AH
0457+  07B3 24          	mov ah, bl				; retrieve al
0458+  07B4 19 00       	mov al, 0
0459+  07B6 05 03       	syscall sys_io				; display AL
0460+  07B8             
0461+  07B8 EA          	pop bl
0462+  07B9 07 D8 05    	call itoa				; convert bh to char in A
0463+  07BC 2F          	mov bl, al				; save al
0464+  07BD 19 00       	mov al, 0
0465+  07BF 05 03       	syscall sys_io				; display AH
0466+  07C1 24          	mov ah, bl				; retrieve al
0467+  07C2 19 00       	mov al, 0
0468+  07C4 05 03       	syscall sys_io				; display AL
0469+  07C6             
0470+  07C6 E5          	pop b
0471+  07C7 E4          	pop a
0472+  07C8 09          	ret
0473+  07C9             
0474+  07C9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0475+  07C9             ; INPUT 16BIT HEX INTEGER
0476+  07C9             ; read 16bit integer into A
0477+  07C9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0478+  07C9             scan_u16x:
0479+  07C9 F8 10 00    	enter 16
0480+  07CC D8          	push b
0481+  07CD DA          	push d
0482+  07CE             
0483+  07CE FA F1 FF    	lea d, [bp + -15]
0484+  07D1 07 18 06    	call gets				; get number
0485+  07D4             
0486+  07D4 32          	mov bl, [d]
0487+  07D5 37          	mov bh, bl
0488+  07D6 33 01 00    	mov bl, [d + 1]
0489+  07D9 07 C6 05    	call atoi				; convert to int in AL
0490+  07DC 23          	mov ah, al				; move to AH
0491+  07DD             
0492+  07DD 33 02 00    	mov bl, [d + 2]
0493+  07E0 37          	mov bh, bl
0494+  07E1 33 03 00    	mov bl, [d + 3]
0495+  07E4 07 C6 05    	call atoi				; convert to int in AL
0496+  07E7             
0497+  07E7 E7          	pop d
0498+  07E8 E5          	pop b
0499+  07E9 F9          	leave
0500+  07EA 09          	ret
0501+  07EB             
0502+  07EB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0503+  07EB             ; PRINT 8bit HEX INTEGER
0504+  07EB             ; integer value in reg bl
0505+  07EB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0506+  07EB             print_u8x:
0507+  07EB D7          	push a
0508+  07EC DD          	push bl
0509+  07ED             
0510+  07ED 07 D8 05    	call itoa				; convert bl to char in A
0511+  07F0 2F          	mov bl, al				; save al
0512+  07F1 19 00       	mov al, 0
0513+  07F3 05 03       	syscall sys_io				; display AH
0514+  07F5 24          	mov ah, bl				; retrieve al
0515+  07F6 19 00       	mov al, 0
0516+  07F8 05 03       	syscall sys_io				; display AL
0517+  07FA             
0518+  07FA EA          	pop bl
0519+  07FB E4          	pop a
0520+  07FC 09          	ret
0521+  07FD             
0522+  07FD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0523+  07FD             ; print 8bit decimal unsigned number
0524+  07FD             ; input number in AL
0525+  07FD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0526+  07FD             print_u8d:
0527+  07FD D7          	push a
0528+  07FE D8          	push b
0529+  07FF             
0530+  07FF 22 00       	mov ah, 0
0531+  0801 26 64 00    	mov b, 100
0532+  0804 AE          	div a, b
0533+  0805 D8          	push b			; save remainder
0534+  0806 B9 00       	cmp al, 0
0535+  0808 C6 12 08    	je skip100
0536+  080B 6A 30       	add al, $30
0537+  080D 23          	mov ah, al
0538+  080E 19 00       	mov al, 0
0539+  0810 05 03       	syscall sys_io	; print coeff
0540+  0812             skip100:
0541+  0812 E4          	pop a
0542+  0813 22 00       	mov ah, 0
0543+  0815 26 0A 00    	mov b, 10
0544+  0818 AE          	div a, b
0545+  0819 D8          	push b			; save remainder
0546+  081A B9 00       	cmp al, 0
0547+  081C C6 26 08    	je skip10
0548+  081F 6A 30       	add al, $30
0549+  0821 23          	mov ah, al
0550+  0822 19 00       	mov al, 0
0551+  0824 05 03       	syscall sys_io	; print coeff
0552+  0826             skip10:
0553+  0826 E4          	pop a
0554+  0827 1B          	mov al, bl
0555+  0828 6A 30       	add al, $30
0556+  082A 23          	mov ah, al
0557+  082B 19 00       	mov al, 0
0558+  082D 05 03       	syscall sys_io	; print coeff
0559+  082F E5          	pop b
0560+  0830 E4          	pop a
0561+  0831 09          	ret
0562+  0832             
0563+  0832             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0564+  0832             ; INPUT 8BIT HEX INTEGER
0565+  0832             ; read 8bit integer into AL
0566+  0832             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0567+  0832             scan_u8x:
0568+  0832 F8 04 00    	enter 4
0569+  0835 D8          	push b
0570+  0836 DA          	push d
0571+  0837             
0572+  0837 FA FD FF    	lea d, [bp + -3]
0573+  083A 07 18 06    	call gets				; get number
0574+  083D             
0575+  083D 32          	mov bl, [d]
0576+  083E 37          	mov bh, bl
0577+  083F 33 01 00    	mov bl, [d + 1]
0578+  0842 07 C6 05    	call atoi				; convert to int in AL
0579+  0845             
0580+  0845 E7          	pop d
0581+  0846 E5          	pop b
0582+  0847 F9          	leave
0583+  0848 09          	ret
0584+  0849             
0585+  0849             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0586+  0849             ; input decimal number
0587+  0849             ; result in A
0588+  0849             ; 655'\0'
0589+  0849             ; low--------high
0590+  0849             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0591+  0849             scan_u16d:
0592+  0849 F8 08 00    	enter 8
0593+  084C E2          	push si
0594+  084D D8          	push b
0595+  084E D9          	push c
0596+  084F DA          	push d
0597+  0850 FA F9 FF    	lea d, [bp +- 7]
0598+  0853 07 18 06    	call gets
0599+  0856 07 4E 05    	call strlen			; get string length in C
0600+  0859 7E          	dec c
0601+  085A FD 4E       	mov si, d
0602+  085C 12          	mov a, c
0603+  085D FD 99       	shl a
0604+  085F 3B AE 05    	mov d, table_power
0605+  0862 59          	add d, a
0606+  0863 38 00 00    	mov c, 0
0607+  0866             mul_loop:
0608+  0866 F6          	lodsb			; load ASCII to al
0609+  0867 B9 00       	cmp al, 0
0610+  0869 C6 7C 08    	je mul_exit
0611+  086C 6F 30       	sub al, $30		; make into integer
0612+  086E 22 00       	mov ah, 0
0613+  0870 2A          	mov b, [d]
0614+  0871 AC          	mul a, b			; result in B since it fits in 16bits
0615+  0872 11          	mov a, b
0616+  0873 28          	mov b, c
0617+  0874 54          	add a, b
0618+  0875 39          	mov c, a
0619+  0876 63 02 00    	sub d, 2
0620+  0879 0A 66 08    	jmp mul_loop
0621+  087C             mul_exit:
0622+  087C 12          	mov a, c
0623+  087D E7          	pop d
0624+  087E E6          	pop c
0625+  087F E5          	pop b
0626+  0880 EF          	pop si
0627+  0881 F9          	leave
0628+  0882 09          	ret
0051   0883             
0052   0883             
0053   0883             .end
0054   0883             
0055   0883             
0056   0883             
tasm: Number of errors = 0
