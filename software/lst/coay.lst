0001   0000             .include "kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0002   0000             
0003   0400             .org PROC_TEXT_ORG			; origin at 1024
0004   0400             
0005   0400             cowsay:
0006   0400 07 A8 09    	call printnl
0007   0403 10 00 00    	mov a, 0
0008   0406 42 AB 06    	mov [prog], a			; move tokennizer pointer to the beginning of the arguments area (address 0)
0009   0409 07 81 04    	call get_arg			; read argument line
0010   040C 3B AF 06    	mov d, tokstr
0011   040F 07 FB 09    	call puts
0012   0412 07 A8 09    	call printnl
0013   0415 3B 1D 04    	mov d, cow
0014   0418 07 FB 09    	call puts
0015   041B 05 0B       	syscall sys_terminate_proc
0016   041D             
0017   041D 20 20 20 20 cow: .db "    \\  ^__^\n"
0017   0421 5C 20 20 5E 
0017   0425 5F 5F 5E 0A 
0018   0429 20 20 20 20      .db "     \\ (oo)\\_______\n"
0018   042D 20 5C 20 28 
0018   0431 6F 6F 29 5C 
0018   0435 5F 5F 5F 5F 
0018   0439 5F 5F 5F 0A 
0019   043D 20 20 20 20      .db "       (__)\\       )\\/\\\n"
0019   0441 20 20 20 28 
0019   0445 5F 5F 29 5C 
0019   0449 20 20 20 20 
0019   044D 20 20 20 29 
0019   0451 5C 2F 5C 0A 
0020   0455 20 20 20 20      .db "           ||----w |\n"
0020   0459 20 20 20 20 
0020   045D 20 20 20 7C 
0020   0461 7C 2D 2D 2D 
0020   0465 2D 77 20 7C 
0020   0469 0A 
0021   046A 20 20 20 20      .db "           ||     ||\n\n", 0
0021   046E 20 20 20 20 
0021   0472 20 20 20 7C 
0021   0476 7C 20 20 20 
0021   047A 20 20 7C 7C 
0021   047E 0A 0A 00 
0022   0481             
0023   0481             .include "token.asm"
0001+  0481             TOKTYP_IDENTIFIER	.equ 0
0002+  0481             TOKTYP_KEYWORD		.equ 1
0003+  0481             TOKTYP_DELIMITER	.equ 2
0004+  0481             TOKTYP_STRING		.equ 3
0005+  0481             TOKTYP_CHAR			.equ 4
0006+  0481             TOKTYP_NUMERIC		.equ 5
0007+  0481             TOKTYP_END			.equ 6
0008+  0481             
0009+  0481             TOK_NULL			.equ 0
0010+  0481             TOK_FSLASH			.equ 1
0011+  0481             TOK_TIMES 			.equ 2
0012+  0481             TOK_PLUS 			.equ 3
0013+  0481             TOK_MINUS 			.equ 4
0014+  0481             TOK_DOT				.equ 5
0015+  0481             TOK_SEMI			.equ 6
0016+  0481             TOK_ANGLE			.equ 7
0017+  0481             TOK_TILDE			.equ 8
0018+  0481             TOK_EQUAL			.equ 9
0019+  0481             TOK_COLON			.equ 10
0020+  0481             TOK_COMMA			.equ 11
0021+  0481             
0022+  0481             TOK_END				.equ 20
0023+  0481             
0024+  0481             
0025+  0481             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  0481             ;; read a full command argment from shell input buffer
0027+  0481             ;; argument is written into tokstr
0028+  0481             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  0481             get_arg:
0030+  0481 D7          	push a
0031+  0482 E2          	push si
0032+  0483 E3          	push di
0033+  0484 19 00       	mov al, 0
0034+  0486 3D AF 06    	mov [tokstr], al			; nullify tokstr string
0035+  0489 14 AB 06    	mov a, [prog]
0036+  048C 4D          	mov si, a
0037+  048D FD 4F AF 06 	mov di, tokstr
0038+  0491             get_arg_skip_spaces:
0039+  0491 F6          	lodsb
0040+  0492 07 A9 0B    	call isspace
0041+  0495 C6 91 04    	je get_arg_skip_spaces
0042+  0498             get_arg_L0:
0043+  0498 B9 3B       	cmp al, $3B				; check if is ';'
0044+  049A C6 A7 04    	je get_arg_end
0045+  049D B9 00       	cmp al, 0
0046+  049F C6 A7 04    	je get_arg_end			; check if end of input
0047+  04A2 F7          	stosb
0048+  04A3 F6          	lodsb
0049+  04A4 0A 98 04    	jmp get_arg_L0
0050+  04A7             get_arg_end:
0051+  04A7 19 00       	mov al, 0
0052+  04A9 F7          	stosb
0053+  04AA D5 01 00    	sub si, 1
0054+  04AD 4E          	mov a, si
0055+  04AE 42 AB 06    	mov [prog], a		; update pointer
0056+  04B1 F0          	pop di
0057+  04B2 EF          	pop si
0058+  04B3 E4          	pop a
0059+  04B4 09          	ret
0060+  04B5             
0061+  04B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  04B5             ;; read a path formation from shell input buffer
0063+  04B5             ;; path is written into tokstr
0064+  04B5             ;; /usr/bin
0065+  04B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  04B5             get_path:
0067+  04B5 D7          	push a
0068+  04B6 E2          	push si
0069+  04B7 E3          	push di
0070+  04B8 19 00       	mov al, 0
0071+  04BA 3D AF 06    	mov [tokstr], al			; nullify tokstr string
0072+  04BD 14 AB 06    	mov a, [prog]
0073+  04C0 4D          	mov si, a
0074+  04C1 FD 4F AF 06 	mov di, tokstr
0075+  04C5             get_path_skip_spaces:
0076+  04C5 F6          	lodsb
0077+  04C6 07 A9 0B    	call isspace
0078+  04C9 C6 C5 04    	je get_path_skip_spaces
0079+  04CC             get_path_is_pathchar:
0080+  04CC F7          	stosb
0081+  04CD F6          	lodsb
0082+  04CE 07 33 0B    	call isalnum			;check if is alphanumeric
0083+  04D1 C6 CC 04    	je get_path_is_pathchar
0084+  04D4 B9 2F       	cmp al, '/'				; check if is '/'
0085+  04D6 C6 CC 04    	je get_path_is_pathchar
0086+  04D9 19 00       	mov al, 0
0087+  04DB F7          	stosb
0088+  04DC D5 01 00    	sub si, 1
0089+  04DF 4E          	mov a, si
0090+  04E0 42 AB 06    	mov [prog], a		; update pointer
0091+  04E3             get_path_end:
0092+  04E3 F0          	pop di
0093+  04E4 EF          	pop si
0094+  04E5 E4          	pop a
0095+  04E6 09          	ret
0096+  04E7             
0097+  04E7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  04E7             ;; read a line
0099+  04E7             ;; line is written into tokstr
0100+  04E7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  04E7             get_line:
0102+  04E7 D7          	push a
0103+  04E8 E2          	push si
0104+  04E9 E3          	push di
0105+  04EA 19 00       	mov al, 0
0106+  04EC 3D AF 06    	mov [tokstr], al			; nullify tokstr string
0107+  04EF 14 AB 06    	mov a, [prog]
0108+  04F2 4D          	mov si, a
0109+  04F3 FD 4F AF 06 	mov di, tokstr
0110+  04F7             get_line_L0:
0111+  04F7 F6          	lodsb
0112+  04F8 B9 0A       	cmp al, $0A		; check for new line
0113+  04FA C6 01 05    	je get_line_exit
0114+  04FD F7          	stosb
0115+  04FE 0A F7 04    	jmp get_line_L0
0116+  0501             get_line_exit:
0117+  0501 19 00       	mov al, 0
0118+  0503 F7          	stosb
0119+  0504 4E          	mov a, si
0120+  0505 42 AB 06    	mov [prog], a		; update pointer
0121+  0508 F0          	pop di
0122+  0509 EF          	pop si
0123+  050A E4          	pop a
0124+  050B 09          	ret
0125+  050C             
0126+  050C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  050C             ;; token parser
0128+  050C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  050C             get_token:
0130+  050C D7          	push a
0131+  050D DA          	push d
0132+  050E E2          	push si
0133+  050F E3          	push di
0134+  0510 19 00       	mov al, 0
0135+  0512 3D AF 06    	mov [tokstr], al			; nullify tokstr string
0136+  0515 19 00       	mov al, TOK_NULL
0137+  0517 3D AE 06    	mov [tok], al				; nullify token
0138+  051A 14 AB 06    	mov a, [prog]
0139+  051D 4D          	mov si, a
0140+  051E FD 4F AF 06 	mov di, tokstr
0141+  0522             get_tok_skip_spaces:
0142+  0522 F6          	lodsb
0143+  0523 07 A9 0B    	call isspace
0144+  0526 C6 22 05    	je get_tok_skip_spaces
0145+  0529 B9 00       	cmp al, 0			; check for end of input (NULL)
0146+  052B C6 10 06    	je get_token_end
0147+  052E B9 23       	cmp al, '#'			; comments!
0148+  0530 C6 3E 06    	je get_tok_comment
0149+  0533 07 33 0B    	call isalnum
0150+  0536 C6 1D 06    	jz is_alphanumeric
0151+  0539             ; other token types
0152+  0539             get_token_slash:
0153+  0539 B9 2F       	cmp al, '/'				; check if '/'
0154+  053B C7 53 05    	jne get_token_minus
0155+  053E F7          	stosb					; store '/' into token string
0156+  053F 19 00       	mov al, 0
0157+  0541 F7          	stosb					; terminate token string
0158+  0542 19 01       	mov al, TOK_FSLASH
0159+  0544 3D AE 06    	mov [tok], al			
0160+  0547 19 02       	mov al, TOKTYP_DELIMITER
0161+  0549 3D AD 06    	mov [toktyp], al
0162+  054C 4E          	mov a, si
0163+  054D 42 AB 06    	mov [prog], a		; update pointer
0164+  0550 0A 39 06    	jmp get_token_return
0165+  0553             get_token_minus:
0166+  0553 B9 2D       	cmp al, '-'				; check if '-'
0167+  0555 C7 6D 05    	jne get_token_comma
0168+  0558 F7          	stosb					; store '-' into token string
0169+  0559 19 00       	mov al, 0
0170+  055B F7          	stosb					; terminate token string
0171+  055C 19 04       	mov al, TOK_MINUS
0172+  055E 3D AE 06    	mov [tok], al			
0173+  0561 19 02       	mov al, TOKTYP_DELIMITER
0174+  0563 3D AD 06    	mov [toktyp], al
0175+  0566 4E          	mov a, si
0176+  0567 42 AB 06    	mov [prog], a		; update pointer
0177+  056A 0A 39 06    	jmp get_token_return
0178+  056D             get_token_comma:
0179+  056D B9 2C       	cmp al, ','				; check if ','
0180+  056F C7 87 05    	jne get_token_semi
0181+  0572 F7          	stosb					; store ',' into token string
0182+  0573 19 00       	mov al, 0
0183+  0575 F7          	stosb					; terminate token string
0184+  0576 19 0B       	mov al, TOK_COMMA
0185+  0578 3D AE 06    	mov [tok], al			
0186+  057B 19 02       	mov al, TOKTYP_DELIMITER
0187+  057D 3D AD 06    	mov [toktyp], al
0188+  0580 4E          	mov a, si
0189+  0581 42 AB 06    	mov [prog], a		; update pointer
0190+  0584 0A 39 06    	jmp get_token_return
0191+  0587             get_token_semi:
0192+  0587 B9 3B       	cmp al, $3B				; check if ';'
0193+  0589 C7 A1 05    	jne get_token_colon
0194+  058C F7          	stosb					; store ';' into token string
0195+  058D 19 00       	mov al, 0
0196+  058F F7          	stosb					; terminate token string
0197+  0590 19 06       	mov al, TOK_SEMI
0198+  0592 3D AE 06    	mov [tok], al			
0199+  0595 19 02       	mov al, TOKTYP_DELIMITER
0200+  0597 3D AD 06    	mov [toktyp], al
0201+  059A 4E          	mov a, si
0202+  059B 42 AB 06    	mov [prog], a		; update pointer
0203+  059E 0A 39 06    	jmp get_token_return
0204+  05A1             get_token_colon:
0205+  05A1 B9 3A       	cmp al, $3A				; check if ':'
0206+  05A3 C7 BB 05    	jne get_token_angle
0207+  05A6 F7          	stosb					; store ':' into token string
0208+  05A7 19 00       	mov al, 0
0209+  05A9 F7          	stosb					; terminate token string
0210+  05AA 19 0A       	mov al, TOK_COLON
0211+  05AC 3D AE 06    	mov [tok], al			
0212+  05AF 19 02       	mov al, TOKTYP_DELIMITER
0213+  05B1 3D AD 06    	mov [toktyp], al
0214+  05B4 4E          	mov a, si
0215+  05B5 42 AB 06    	mov [prog], a		; update pointer
0216+  05B8 0A 39 06    	jmp get_token_return
0217+  05BB             get_token_angle:
0218+  05BB B9 3E       	cmp al, $3E				; check if '>'
0219+  05BD C7 D5 05    	jne get_token_tilde
0220+  05C0 F7          	stosb					; store '>' into token string
0221+  05C1 19 00       	mov al, 0
0222+  05C3 F7          	stosb					; terminate token string
0223+  05C4 19 07       	mov al, TOK_ANGLE
0224+  05C6 3D AE 06    	mov [tok], al			
0225+  05C9 19 02       	mov al, TOKTYP_DELIMITER
0226+  05CB 3D AD 06    	mov [toktyp], al
0227+  05CE 4E          	mov a, si
0228+  05CF 42 AB 06    	mov [prog], a		; update pointer
0229+  05D2 0A 39 06    	jmp get_token_return
0230+  05D5             get_token_tilde:
0231+  05D5 B9 7E       	cmp al, '~'				; check if '~'
0232+  05D7 C7 EF 05    	jne get_token_equal
0233+  05DA F7          	stosb					; store '~' into token string
0234+  05DB 19 00       	mov al, 0
0235+  05DD F7          	stosb					; terminate token string
0236+  05DE 19 08       	mov al, TOK_TILDE
0237+  05E0 3D AE 06    	mov [tok], al			
0238+  05E3 19 02       	mov al, TOKTYP_DELIMITER
0239+  05E5 3D AD 06    	mov [toktyp], al
0240+  05E8 4E          	mov a, si
0241+  05E9 42 AB 06    	mov [prog], a		; update pointer
0242+  05EC 0A 39 06    	jmp get_token_return
0243+  05EF             get_token_equal:
0244+  05EF B9 3D       	cmp al, '='				; check if '='
0245+  05F1 C7 09 06    	jne get_token_skip
0246+  05F4 F7          	stosb					; store '=' into token string
0247+  05F5 19 00       	mov al, 0
0248+  05F7 F7          	stosb					; terminate token string
0249+  05F8 19 09       	mov al, TOK_EQUAL
0250+  05FA 3D AE 06    	mov [tok], al			
0251+  05FD 19 02       	mov al, TOKTYP_DELIMITER
0252+  05FF 3D AD 06    	mov [toktyp], al
0253+  0602 4E          	mov a, si
0254+  0603 42 AB 06    	mov [prog], a		; update pointer
0255+  0606 0A 39 06    	jmp get_token_return
0256+  0609             get_token_skip:
0257+  0609 4E          	mov a, si
0258+  060A 42 AB 06    	mov [prog], a		; update pointer
0259+  060D 0A 39 06    	jmp get_token_return
0260+  0610             get_token_end:				; end of file token
0261+  0610 19 14       	mov al, TOK_END
0262+  0612 3D AE 06    	mov [tok], al
0263+  0615 19 06       	mov al, TOKTYP_END
0264+  0617 3D AD 06    	mov [toktyp], al
0265+  061A 0A 39 06    	jmp get_token_return
0266+  061D             is_alphanumeric:
0267+  061D F7          	stosb
0268+  061E F6          	lodsb
0269+  061F 07 33 0B    	call isalnum			;check if is alphanumeric
0270+  0622 C6 1D 06    	jz is_alphanumeric
0271+  0625 B9 2E       	cmp al, $2E				; check if is '.'
0272+  0627 C6 1D 06    	je is_alphanumeric
0273+  062A 19 00       	mov al, 0
0274+  062C F7          	stosb
0275+  062D 19 00       	mov al, TOKTYP_IDENTIFIER
0276+  062F 3D AD 06    	mov [toktyp], al
0277+  0632 D5 01 00    	sub si, 1
0278+  0635 4E          	mov a, si
0279+  0636 42 AB 06    	mov [prog], a		; update pointer
0280+  0639             get_token_return:
0281+  0639 F0          	pop di
0282+  063A EF          	pop si
0283+  063B E7          	pop d
0284+  063C E4          	pop a
0285+  063D 09          	ret
0286+  063E             get_tok_comment:
0287+  063E F6          	lodsb
0288+  063F B9 0A       	cmp al, $0A			; new line
0289+  0641 C7 3E 06    	jne get_tok_comment
0290+  0644 0A 22 05    	jmp get_tok_skip_spaces
0291+  0647             
0292+  0647             
0293+  0647             get_number:
0294+  0647 D7          	push a
0295+  0648 DA          	push d
0296+  0649 E2          	push si
0297+  064A E3          	push di
0298+  064B 19 00       	mov al, 0
0299+  064D 3D AF 06    	mov [tokstr], al			; nullify tokstr string
0300+  0650 19 00       	mov al, TOK_NULL
0301+  0652 3D AE 06    	mov [tok], al				; nullify token
0302+  0655 14 AB 06    	mov a, [prog]
0303+  0658 4D          	mov si, a
0304+  0659 FD 4F AF 06 	mov di, tokstr
0305+  065D             get_number_skip_spaces:
0306+  065D F6          	lodsb
0307+  065E 07 A9 0B    	call isspace
0308+  0661 C6 5D 06    	je get_number_skip_spaces
0309+  0664 B9 00       	cmp al, 0			; check for end of input (NULL)
0310+  0666 C7 76 06    	jne get_number_L0
0311+  0669 19 14       	mov al, TOK_END
0312+  066B 3D AE 06    	mov [tok], al
0313+  066E 19 06       	mov al, TOKTYP_END
0314+  0670 3D AD 06    	mov [toktyp], al
0315+  0673 0A 8D 06    	jmp get_number_return
0316+  0676             get_number_L0:
0317+  0676 F7          	stosb
0318+  0677 F6          	lodsb
0319+  0678 07 3D 0B    	call isdigit			;check if is numeric
0320+  067B C6 76 06    	jz get_number_L0
0321+  067E 19 00       	mov al, 0
0322+  0680 F7          	stosb
0323+  0681 19 05       	mov al, TOKTYP_NUMERIC
0324+  0683 3D AD 06    	mov [toktyp], al
0325+  0686 D5 01 00    	sub si, 1
0326+  0689 4E          	mov a, si
0327+  068A 42 AB 06    	mov [prog], a		; update pointer
0328+  068D             get_number_return:
0329+  068D F0          	pop di
0330+  068E EF          	pop si
0331+  068F E7          	pop d
0332+  0690 E4          	pop a
0333+  0691 09          	ret
0334+  0692             
0335+  0692             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  0692             ;; PUT BACK TOKEN
0337+  0692             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
0338+  0692             putback:
0339+  0692 D7          	push a
0340+  0693 E2          	push si
0341+  0694 FD 4D AF 06 	mov si, tokstr	
0342+  0698             putback_loop:
0343+  0698 F6          	lodsb
0344+  0699 B9 00       	cmp al, 0
0345+  069B C6 A8 06    	je putback_end
0346+  069E 14 AB 06    	mov a, [prog]
0347+  06A1 7D          	dec a
0348+  06A2 42 AB 06    	mov [prog], a			; update pointer
0349+  06A5 0A 98 06    	jmp putback_loop
0350+  06A8             putback_end:
0351+  06A8 EF          	pop si
0352+  06A9 E4          	pop a
0353+  06AA 09          	ret
0354+  06AB             
0355+  06AB             
0356+  06AB             
0357+  06AB             
0358+  06AB 00 00       prog:		.dw 0			; pointer to current position in buffer
0359+  06AD             
0360+  06AD 00          toktyp: 	.db 0			; token type symbol
0361+  06AE 00          tok:		.db 0			; current token symbol
0362+  06AF 00 00 00 00 tokstr:		.fill 256, 0	; token as a string
0362+  06B3 00 00 00 00 
0362+  06B7 00 00 00 00 
0362+  06BB 00 00 00 00 
0362+  06BF 00 00 00 00 
0362+  06C3 00 00 00 00 
0362+  06C7 00 00 00 00 
0362+  06CB 00 00 00 00 
0362+  06CF 00 00 00 00 
0362+  06D3 00 00 00 00 
0362+  06D7 00 00 00 00 
0362+  06DB 00 00 00 00 
0362+  06DF 00 00 00 00 
0362+  06E3 00 00 00 00 
0362+  06E7 00 00 00 00 
0362+  06EB 00 00 00 00 
0362+  06EF 00 00 00 00 
0362+  06F3 00 00 00 00 
0362+  06F7 00 00 00 00 
0362+  06FB 00 00 00 00 
0362+  06FF 00 00 00 00 
0362+  0703 00 00 00 00 
0362+  0707 00 00 00 00 
0362+  070B 00 00 00 00 
0362+  070F 00 00 00 00 
0362+  0713 00 00 00 00 
0362+  0717 00 00 00 00 
0362+  071B 00 00 00 00 
0362+  071F 00 00 00 00 
0362+  0723 00 00 00 00 
0362+  0727 00 00 00 00 
0362+  072B 00 00 00 00 
0362+  072F 00 00 00 00 
0362+  0733 00 00 00 00 
0362+  0737 00 00 00 00 
0362+  073B 00 00 00 00 
0362+  073F 00 00 00 00 
0362+  0743 00 00 00 00 
0362+  0747 00 00 00 00 
0362+  074B 00 00 00 00 
0362+  074F 00 00 00 00 
0362+  0753 00 00 00 00 
0362+  0757 00 00 00 00 
0362+  075B 00 00 00 00 
0362+  075F 00 00 00 00 
0362+  0763 00 00 00 00 
0362+  0767 00 00 00 00 
0362+  076B 00 00 00 00 
0362+  076F 00 00 00 00 
0362+  0773 00 00 00 00 
0362+  0777 00 00 00 00 
0362+  077B 00 00 00 00 
0362+  077F 00 00 00 00 
0362+  0783 00 00 00 00 
0362+  0787 00 00 00 00 
0362+  078B 00 00 00 00 
0362+  078F 00 00 00 00 
0362+  0793 00 00 00 00 
0362+  0797 00 00 00 00 
0362+  079B 00 00 00 00 
0362+  079F 00 00 00 00 
0362+  07A3 00 00 00 00 
0362+  07A7 00 00 00 00 
0362+  07AB 00 00 00 00 
0024   07AF             .include "stdio.asm"
0001+  07AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  07AF             ; stdio.s
0003+  07AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  07AF             .include "string.asm"
0001++ 07AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 07AF             ; string.s
0003++ 07AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 07AF             
0005++ 07AF             
0006++ 07AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 07AF             ; strrev
0008++ 07AF             ; reverse a string
0009++ 07AF             ; D = string address
0010++ 07AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 07AF             ; 01234
0012++ 07AF             strrev:
0013++ 07AF 4B          	pusha
0014++ 07B0 07 F6 07    	call strlen	; length in C
0015++ 07B3 12          	mov a, c
0016++ 07B4 AF 01 00    	cmp a, 1
0017++ 07B7 D0 D1 07    	jleu strrev_end	; check string length. string len must be > 1
0018++ 07BA 7D          	dec a
0019++ 07BB FD 4E       	mov si, d	; beginning of string
0020++ 07BD FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 07BF 59          	add d, a	; end of string
0022++ 07C0 12          	mov a, c
0023++ 07C1 FD 9B       	shr a		; divide by 2
0024++ 07C3 39          	mov c, a	; C now counts the steps
0025++ 07C4             strrev_L0:
0026++ 07C4 32          	mov bl, [d]	; save load right-side char into BL
0027++ 07C5 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 07C6 3E          	mov [d], al	; store left char into right side
0029++ 07C7 1B          	mov al, bl
0030++ 07C8 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 07C9 7E          	dec c
0032++ 07CA 7F          	dec d
0033++ 07CB C2 00 00    	cmp c, 0
0034++ 07CE C7 C4 07    	jne strrev_L0
0035++ 07D1             strrev_end:
0036++ 07D1 4C          	popa
0037++ 07D2 09          	ret
0038++ 07D3             	
0039++ 07D3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 07D3             ; strchr
0041++ 07D3             ; search string in D for char in AL
0042++ 07D3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 07D3             strchr:
0044++ 07D3             strchr_L0:
0045++ 07D3 32          	mov bl, [d]
0046++ 07D4 C1 00       	cmp bl, 0
0047++ 07D6 C6 E1 07    	je strchr_end
0048++ 07D9 BA          	cmp al, bl
0049++ 07DA C6 E1 07    	je strchr_end
0050++ 07DD 79          	inc d
0051++ 07DE 0A D3 07    	jmp strchr_L0
0052++ 07E1             strchr_end:
0053++ 07E1 1B          	mov al, bl
0054++ 07E2 09          	ret
0055++ 07E3             
0056++ 07E3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 07E3             ; strstr
0058++ 07E3             ; find sub-string
0059++ 07E3             ; str1 in SI
0060++ 07E3             ; str2 in DI
0061++ 07E3             ; SI points to end of source string
0062++ 07E3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 07E3             strstr:
0064++ 07E3 DB          	push al
0065++ 07E4 DA          	push d
0066++ 07E5 E3          	push di
0067++ 07E6             strstr_loop:
0068++ 07E6 F3          	cmpsb					; compare a byte of the strings
0069++ 07E7 C7 F2 07    	jne strstr_ret
0070++ 07EA FC 00 00    	lea d, [di + 0]
0071++ 07ED BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 07EF C7 E6 07    	jne strstr_loop				; equal chars but not at end
0073++ 07F2             strstr_ret:
0074++ 07F2 F0          	pop di
0075++ 07F3 E7          	pop d
0076++ 07F4 E8          	pop al
0077++ 07F5 09          	ret
0078++ 07F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 07F6             ; length of null terminated string
0080++ 07F6             ; result in C
0081++ 07F6             ; pointer in D
0082++ 07F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 07F6             strlen:
0084++ 07F6 DA          	push d
0085++ 07F7 38 00 00    	mov c, 0
0086++ 07FA             strlen_L1:
0087++ 07FA BD 00       	cmp byte [d], 0
0088++ 07FC C6 04 08    	je strlen_ret
0089++ 07FF 79          	inc d
0090++ 0800 78          	inc c
0091++ 0801 0A FA 07    	jmp strlen_L1
0092++ 0804             strlen_ret:
0093++ 0804 E7          	pop d
0094++ 0805 09          	ret
0095++ 0806             
0096++ 0806             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0806             ; STRCMP
0098++ 0806             ; compare two strings
0099++ 0806             ; str1 in SI
0100++ 0806             ; str2 in DI
0101++ 0806             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0806             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0806             strcmp:
0104++ 0806 DB          	push al
0105++ 0807 DA          	push d
0106++ 0808 E3          	push di
0107++ 0809 E2          	push si
0108++ 080A             strcmp_loop:
0109++ 080A F3          	cmpsb					; compare a byte of the strings
0110++ 080B C7 16 08    	jne strcmp_ret
0111++ 080E FB FF FF    	lea d, [si +- 1]
0112++ 0811 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0813 C7 0A 08    	jne strcmp_loop				; equal chars but not at end
0114++ 0816             strcmp_ret:
0115++ 0816 EF          	pop si
0116++ 0817 F0          	pop di
0117++ 0818 E7          	pop d
0118++ 0819 E8          	pop al
0119++ 081A 09          	ret
0120++ 081B             
0121++ 081B             
0122++ 081B             ; STRCPY
0123++ 081B             ; copy null terminated string from SI to DI
0124++ 081B             ; source in SI
0125++ 081B             ; destination in DI
0126++ 081B             strcpy:
0127++ 081B E2          	push si
0128++ 081C E3          	push di
0129++ 081D DB          	push al
0130++ 081E             strcpy_L1:
0131++ 081E F6          	lodsb
0132++ 081F F7          	stosb
0133++ 0820 B9 00       	cmp al, 0
0134++ 0822 C7 1E 08    	jne strcpy_L1
0135++ 0825             strcpy_end:
0136++ 0825 E8          	pop al
0137++ 0826 F0          	pop di
0138++ 0827 EF          	pop si
0139++ 0828 09          	ret
0140++ 0829             
0141++ 0829             ; STRCAT
0142++ 0829             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0829             ; source in SI
0144++ 0829             ; destination in DI
0145++ 0829             strcat:
0146++ 0829 E2          	push si
0147++ 082A E3          	push di
0148++ 082B D7          	push a
0149++ 082C DA          	push d
0150++ 082D 50          	mov a, di
0151++ 082E 3C          	mov d, a
0152++ 082F             strcat_goto_end_L1:
0153++ 082F BD 00       	cmp byte[d], 0
0154++ 0831 C6 38 08    	je strcat_start
0155++ 0834 79          	inc d
0156++ 0835 0A 2F 08    	jmp strcat_goto_end_L1
0157++ 0838             strcat_start:
0158++ 0838 FD 50       	mov di, d
0159++ 083A             strcat_L1:
0160++ 083A F6          	lodsb
0161++ 083B F7          	stosb
0162++ 083C B9 00       	cmp al, 0
0163++ 083E C7 3A 08    	jne strcat_L1
0164++ 0841             strcat_end:
0165++ 0841 E7          	pop d
0166++ 0842 E4          	pop a
0167++ 0843 F0          	pop di
0168++ 0844 EF          	pop si
0169++ 0845 09          	ret
0005+  0846             
0006+  0846 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  084A 34 35 36 37 
0006+  084E 38 39 41 42 
0006+  0852 43 44 45 46 
0007+  0856 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  085A 1B 5B 48 00 
0008+  085E             
0009+  085E 01 00       table_power:.dw 1
0010+  0860 0A 00       			.dw 10
0011+  0862 64 00       			.dw 100
0012+  0864 E8 03       			.dw 1000
0013+  0866 10 27       			.dw 10000
0014+  0868             
0015+  0868             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  0868             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  0868             ; ASCII in BL
0018+  0868             ; result in AL
0019+  0868             ; ascii for F = 0100 0110
0020+  0868             ; ascii for 9 = 0011 1001
0021+  0868             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  0868             hex_ascii_encode:
0023+  0868 1B          	mov al, bl
0024+  0869 93 40       	test al, $40				; test if letter or number
0025+  086B C7 71 08    	jnz hex_letter
0026+  086E 87 0F       	and al, $0F				; get number
0027+  0870 09          	ret
0028+  0871             hex_letter:
0029+  0871 87 0F       	and al, $0F				; get letter
0030+  0873 6A 09       	add al, 9
0031+  0875 09          	ret
0032+  0876             
0033+  0876             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  0876             ; ATOI
0035+  0876             ; 2 letter hex string in B
0036+  0876             ; 8bit integer returned in AL
0037+  0876             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0876             atoi:
0039+  0876 D8          	push b
0040+  0877 07 68 08    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  087A 30          	mov bl, bh
0042+  087B DB          	push al					; save a
0043+  087C 07 68 08    	call hex_ascii_encode
0044+  087F EA          	pop bl	
0045+  0880 FD 9E 04    	shl al, 4
0046+  0883 8C          	or al, bl
0047+  0884 E5          	pop b
0048+  0885 09          	ret	
0049+  0886             
0050+  0886             
0051+  0886             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  0886             ; printf
0053+  0886             ; no need for explanations!
0054+  0886             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0886             printf:
0056+  0886 09          	ret
0057+  0887             
0058+  0887             
0059+  0887             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  0887             ; scanf
0061+  0887             ; no need for explanations!
0062+  0887             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  0887             scanf:
0064+  0887 09          	ret
0065+  0888             
0066+  0888             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  0888             ; ITOA
0068+  0888             ; 8bit value in BL
0069+  0888             ; 2 byte ASCII result in A
0070+  0888             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  0888             itoa:
0072+  0888 DA          	push d
0073+  0889 D8          	push b
0074+  088A A7 00       	mov bh, 0
0075+  088C FD A4 04    	shr bl, 4	
0076+  088F 74          	mov d, b
0077+  0890 1F 46 08    	mov al, [d + s_hex_digits]
0078+  0893 23          	mov ah, al
0079+  0894             	
0080+  0894 E5          	pop b
0081+  0895 D8          	push b
0082+  0896 A7 00       	mov bh, 0
0083+  0898 FD 87 0F    	and bl, $0F
0084+  089B 74          	mov d, b
0085+  089C 1F 46 08    	mov al, [d + s_hex_digits]
0086+  089F E5          	pop b
0087+  08A0 E7          	pop d
0088+  08A1 09          	ret
0089+  08A2             
0090+  08A2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  08A2             ; HEX STRING TO BINARY
0092+  08A2             ; di = destination address
0093+  08A2             ; si = source
0094+  08A2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  08A2             hex_to_int:
0096+  08A2             hex_to_int_L1:
0097+  08A2 F6          	lodsb					; load from [SI] to AL
0098+  08A3 B9 00       	cmp al, 0				; check if ASCII 0
0099+  08A5 C6 B2 08    	jz hex_to_int_ret
0100+  08A8 36          	mov bh, al
0101+  08A9 F6          	lodsb
0102+  08AA 2F          	mov bl, al
0103+  08AB 07 76 08    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  08AE F7          	stosb					; store AL to [DI]
0105+  08AF 0A A2 08    	jmp hex_to_int_L1
0106+  08B2             hex_to_int_ret:
0107+  08B2 09          	ret		
0108+  08B3             
0109+  08B3             
0110+  08B3             
0111+  08B3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  08B3             ; GETCHAR
0113+  08B3             ; char in ah
0114+  08B3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  08B3             getchar:
0116+  08B3 DB          	push al
0117+  08B4             getchar_retry:
0118+  08B4 FD 0C       	sti
0119+  08B6 19 01       	mov al, 1
0120+  08B8 05 03       	syscall sys_io			; receive in AH
0121+  08BA B9 00       	cmp al, 0			; check if any char was receive
0122+  08BC C6 B4 08    	je getchar_retry
0123+  08BF E8          	pop al
0124+  08C0 09          	ret
0125+  08C1             
0126+  08C1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  08C1             ; PUTCHAR
0128+  08C1             ; char in ah
0129+  08C1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  08C1             putchar:
0131+  08C1 D7          	push a
0132+  08C2 19 00       	mov al, 0
0133+  08C4 05 03       	syscall sys_io			; char in AH
0134+  08C6 E4          	pop a
0135+  08C7 09          	ret
0136+  08C8             
0137+  08C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  08C8             ;; INPUT A STRING
0139+  08C8             ;; terminates with null
0140+  08C8             ;; pointer in D
0141+  08C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  08C8             gets:
0143+  08C8 D7          	push a
0144+  08C9 DA          	push d
0145+  08CA             gets_loop:
0146+  08CA FD 0C       	sti
0147+  08CC 19 01       	mov al, 1
0148+  08CE 05 03       	syscall sys_io			; receive in AH
0149+  08D0 B9 00       	cmp al, 0				; check error code (AL)
0150+  08D2 C6 CA 08    	je gets_loop			; if no char received, retry
0151+  08D5             
0152+  08D5 76 1B       	cmp ah, 27
0153+  08D7 C6 F8 08    	je gets_telnet_escape
0154+  08DA 76 0A       	cmp ah, $0A				; LF
0155+  08DC C6 51 09    	je gets_end
0156+  08DF 76 0D       	cmp ah, $0D				; CR
0157+  08E1 C6 51 09    	je gets_end
0158+  08E4 76 5C       	cmp ah, $5C				; '\\'
0159+  08E6 C6 28 09    	je gets_escape
0160+  08E9             	
0161+  08E9 76 08       	cmp ah, $08			; check for backspace
0162+  08EB C6 F4 08    	je gets_backspace
0163+  08EE             
0164+  08EE 1A          	mov al, ah
0165+  08EF 3E          	mov [d], al
0166+  08F0 79          	inc d
0167+  08F1 0A CA 08    	jmp gets_loop
0168+  08F4             gets_backspace:
0169+  08F4 7F          	dec d
0170+  08F5 0A CA 08    	jmp gets_loop
0171+  08F8             gets_telnet_escape:
0172+  08F8 FD 0C       	sti
0173+  08FA 19 01       	mov al, 1
0174+  08FC 05 03       	syscall sys_io				; receive in AH without echo
0175+  08FE B9 00       	cmp al, 0					; check error code (AL)
0176+  0900 C6 F8 08    	je gets_telnet_escape		; if no char received, retry
0177+  0903 76 5B       	cmp ah, '['
0178+  0905 C7 CA 08    	jne gets_loop
0179+  0908             gets_telnet_escape_phase2:
0180+  0908 FD 0C       	sti
0181+  090A 19 01       	mov al, 1
0182+  090C 05 03       	syscall sys_io					; receive in AH without echo
0183+  090E B9 00       	cmp al, 0						; check error code (AL)
0184+  0910 C6 08 09    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  0913 76 44       	cmp ah, 'D'
0186+  0915 C6 20 09    	je gets_left_arrow
0187+  0918 76 43       	cmp ah, 'C'
0188+  091A C6 24 09    	je gets_right_arrow
0189+  091D 0A CA 08    	jmp gets_loop
0190+  0920             gets_left_arrow:
0191+  0920 7F          	dec d
0192+  0921 0A CA 08    	jmp gets_loop
0193+  0924             gets_right_arrow:
0194+  0924 79          	inc d
0195+  0925 0A CA 08    	jmp gets_loop
0196+  0928             gets_escape:
0197+  0928 FD 0C       	sti
0198+  092A 19 01       	mov al, 1
0199+  092C 05 03       	syscall sys_io			; receive in AH
0200+  092E B9 00       	cmp al, 0				; check error code (AL)
0201+  0930 C6 28 09    	je gets_escape			; if no char received, retry
0202+  0933 76 6E       	cmp ah, 'n'
0203+  0935 C6 43 09    	je gets_LF
0204+  0938 76 72       	cmp ah, 'r'
0205+  093A C6 4A 09    	je gets_CR
0206+  093D 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  093E 3E          	mov [d], al
0208+  093F 79          	inc d
0209+  0940 0A CA 08    	jmp gets_loop
0210+  0943             gets_LF:
0211+  0943 19 0A       	mov al, $0A
0212+  0945 3E          	mov [d], al
0213+  0946 79          	inc d
0214+  0947 0A CA 08    	jmp gets_loop
0215+  094A             gets_CR:
0216+  094A 19 0D       	mov al, $0D
0217+  094C 3E          	mov [d], al
0218+  094D 79          	inc d
0219+  094E 0A CA 08    	jmp gets_loop
0220+  0951             gets_end:
0221+  0951 19 00       	mov al, 0
0222+  0953 3E          	mov [d], al				; terminate string
0223+  0954 E7          	pop d
0224+  0955 E4          	pop a
0225+  0956 09          	ret
0226+  0957             
0227+  0957             
0228+  0957             
0229+  0957             
0230+  0957             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  0957             ;; INPUT TEXT
0232+  0957             ;; terminated with CTRL+D
0233+  0957             ;; pointer in D
0234+  0957             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  0957             gettxt:
0236+  0957 D7          	push a
0237+  0958 DA          	push d
0238+  0959             gettxt_loop:
0239+  0959 19 01       	mov al, 1
0240+  095B 05 03       	syscall sys_io			; receive in AH
0241+  095D B9 00       	cmp al, 0				; check error code (AL)
0242+  095F C6 59 09    	je gettxt_loop		; if no char received, retry
0243+  0962 76 04       	cmp ah, 4			; EOT
0244+  0964 C6 A2 09    	je gettxt_end
0245+  0967 76 08       	cmp ah, $08			; check for backspace
0246+  0969 C6 9E 09    	je gettxt_backspace
0247+  096C 76 5C       	cmp ah, $5C				; '\\'
0248+  096E C6 77 09    	je gettxt_escape
0249+  0971 1A          	mov al, ah
0250+  0972 3E          	mov [d], al
0251+  0973 79          	inc d
0252+  0974 0A 59 09    	jmp gettxt_loop
0253+  0977             gettxt_escape:
0254+  0977 19 01       	mov al, 1
0255+  0979 05 03       	syscall sys_io			; receive in AH
0256+  097B B9 00       	cmp al, 0				; check error code (AL)
0257+  097D C6 77 09    	je gettxt_escape		; if no char received, retry
0258+  0980 76 6E       	cmp ah, 'n'
0259+  0982 C6 90 09    	je gettxt_LF
0260+  0985 76 72       	cmp ah, 'r'
0261+  0987 C6 97 09    	je gettxt_CR
0262+  098A 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  098B 3E          	mov [d], al
0264+  098C 79          	inc d
0265+  098D 0A 59 09    	jmp gettxt_loop
0266+  0990             gettxt_LF:
0267+  0990 19 0A       	mov al, $0A
0268+  0992 3E          	mov [d], al
0269+  0993 79          	inc d
0270+  0994 0A 59 09    	jmp gettxt_loop
0271+  0997             gettxt_CR:
0272+  0997 19 0D       	mov al, $0D
0273+  0999 3E          	mov [d], al
0274+  099A 79          	inc d
0275+  099B 0A 59 09    	jmp gettxt_loop
0276+  099E             gettxt_backspace:
0277+  099E 7F          	dec d
0278+  099F 0A 59 09    	jmp gettxt_loop
0279+  09A2             gettxt_end:
0280+  09A2 19 00       	mov al, 0
0281+  09A4 3E          	mov [d], al				; terminate string
0282+  09A5 E7          	pop d
0283+  09A6 E4          	pop a
0284+  09A7 09          	ret
0285+  09A8             
0286+  09A8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  09A8             ; PRINT NEW LINE
0288+  09A8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  09A8             printnl:
0290+  09A8 D7          	push a
0291+  09A9 10 00 0A    	mov a, $0A00
0292+  09AC 05 03       	syscall sys_io
0293+  09AE 10 00 0D    	mov a, $0D00
0294+  09B1 05 03       	syscall sys_io
0295+  09B3 E4          	pop a
0296+  09B4 09          	ret
0297+  09B5             
0298+  09B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  09B5             ; strtoint
0300+  09B5             ; 4 digit hex string number in d
0301+  09B5             ; integer returned in A
0302+  09B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  09B5             strtointx:
0304+  09B5 D8          	push b
0305+  09B6 32          	mov bl, [d]
0306+  09B7 37          	mov bh, bl
0307+  09B8 33 01 00    	mov bl, [d + 1]
0308+  09BB 07 76 08    	call atoi				; convert to int in AL
0309+  09BE 23          	mov ah, al				; move to AH
0310+  09BF 33 02 00    	mov bl, [d + 2]
0311+  09C2 37          	mov bh, bl
0312+  09C3 33 03 00    	mov bl, [d + 3]
0313+  09C6 07 76 08    	call atoi				; convert to int in AL
0314+  09C9 E5          	pop b
0315+  09CA 09          	ret
0316+  09CB             
0317+  09CB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  09CB             ; strtoint
0319+  09CB             ; 5 digit base10 string number in d
0320+  09CB             ; integer returned in A
0321+  09CB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  09CB             strtoint:
0323+  09CB E2          	push si
0324+  09CC D8          	push b
0325+  09CD D9          	push c
0326+  09CE DA          	push d
0327+  09CF 07 F6 07    	call strlen			; get string length in C
0328+  09D2 7E          	dec c
0329+  09D3 FD 4E       	mov si, d
0330+  09D5 12          	mov a, c
0331+  09D6 FD 99       	shl a
0332+  09D8 3B 5E 08    	mov d, table_power
0333+  09DB 59          	add d, a
0334+  09DC 38 00 00    	mov c, 0
0335+  09DF             strtoint_L0:
0336+  09DF F6          	lodsb			; load ASCII to al
0337+  09E0 B9 00       	cmp al, 0
0338+  09E2 C6 F5 09    	je strtoint_end
0339+  09E5 6F 30       	sub al, $30		; make into integer
0340+  09E7 22 00       	mov ah, 0
0341+  09E9 2A          	mov b, [d]
0342+  09EA AC          	mul a, b			; result in B since it fits in 16bits
0343+  09EB 11          	mov a, b
0344+  09EC 28          	mov b, c
0345+  09ED 54          	add a, b
0346+  09EE 39          	mov c, a
0347+  09EF 63 02 00    	sub d, 2
0348+  09F2 0A DF 09    	jmp strtoint_L0
0349+  09F5             strtoint_end:
0350+  09F5 12          	mov a, c
0351+  09F6 E7          	pop d
0352+  09F7 E6          	pop c
0353+  09F8 E5          	pop b
0354+  09F9 EF          	pop si
0355+  09FA 09          	ret
0356+  09FB             
0357+  09FB             
0358+  09FB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  09FB             ; PRINT NULL TERMINATED STRING
0360+  09FB             ; pointer in D
0361+  09FB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  09FB             puts:
0363+  09FB D7          	push a
0364+  09FC DA          	push d
0365+  09FD             puts_L1:
0366+  09FD 1E          	mov al, [d]
0367+  09FE B9 00       	cmp al, 0
0368+  0A00 C6 0C 0A    	jz puts_END
0369+  0A03 23          	mov ah, al
0370+  0A04 19 00       	mov al, 0
0371+  0A06 05 03       	syscall sys_io
0372+  0A08 79          	inc d
0373+  0A09 0A FD 09    	jmp puts_L1
0374+  0A0C             puts_END:
0375+  0A0C E7          	pop d
0376+  0A0D E4          	pop a
0377+  0A0E 09          	ret
0378+  0A0F             
0379+  0A0F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  0A0F             ; PRINT N SIZE STRING
0381+  0A0F             ; pointer in D
0382+  0A0F             ; size in C
0383+  0A0F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  0A0F             putsn:
0385+  0A0F DB          	push al
0386+  0A10 DA          	push d
0387+  0A11 D9          	push c
0388+  0A12             putsn_L0:
0389+  0A12 1E          	mov al, [d]
0390+  0A13 23          	mov ah, al
0391+  0A14 19 00       	mov al, 0
0392+  0A16 05 03       	syscall sys_io
0393+  0A18 79          	inc d
0394+  0A19 7E          	dec c	
0395+  0A1A C2 00 00    	cmp c, 0
0396+  0A1D C7 12 0A    	jne putsn_L0
0397+  0A20             putsn_end:
0398+  0A20 E6          	pop c
0399+  0A21 E7          	pop d
0400+  0A22 E8          	pop al
0401+  0A23 09          	ret
0402+  0A24             
0403+  0A24             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  0A24             ; print 16bit decimal number
0405+  0A24             ; input number in A
0406+  0A24             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  0A24             print_u16d:
0408+  0A24 D7          	push a
0409+  0A25 D8          	push b
0410+  0A26 26 10 27    	mov b, 10000
0411+  0A29 AE          	div a, b			; get 10000 coeff.
0412+  0A2A 07 50 0A    	call print_number
0413+  0A2D 11          	mov a, b
0414+  0A2E 26 E8 03    	mov b, 1000
0415+  0A31 AE          	div a, b			; get 10000 coeff.
0416+  0A32 07 50 0A    	call print_number
0417+  0A35 11          	mov a, b
0418+  0A36 26 64 00    	mov b, 100
0419+  0A39 AE          	div a, b
0420+  0A3A 07 50 0A    	call print_number
0421+  0A3D 11          	mov a, b
0422+  0A3E 26 0A 00    	mov b, 10
0423+  0A41 AE          	div a, b
0424+  0A42 07 50 0A    	call print_number
0425+  0A45 11          	mov a, b
0426+  0A46 6A 30       	add al, $30
0427+  0A48 23          	mov ah, al
0428+  0A49 19 00       	mov al, 0
0429+  0A4B 05 03       	syscall sys_io	; print coeff
0430+  0A4D E5          	pop b
0431+  0A4E E4          	pop a
0432+  0A4F 09          	ret
0433+  0A50             
0434+  0A50             
0435+  0A50             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  0A50             ; if A == 0, print space
0437+  0A50             ; else print A
0438+  0A50             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0439+  0A50             print_number:
0440+  0A50 6A 30       	add al, $30
0441+  0A52 23          	mov ah, al
0442+  0A53 07 C1 08    	call putchar
0443+  0A56 09          	ret
0444+  0A57             
0445+  0A57             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0446+  0A57             ; PRINT 16BIT HEX INTEGER
0447+  0A57             ; integer value in reg B
0448+  0A57             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  0A57             print_u16x:
0450+  0A57 D7          	push a
0451+  0A58 D8          	push b
0452+  0A59 DD          	push bl
0453+  0A5A 30          	mov bl, bh
0454+  0A5B 07 88 08    	call itoa				; convert bh to char in A
0455+  0A5E 2F          	mov bl, al				; save al
0456+  0A5F 19 00       	mov al, 0
0457+  0A61 05 03       	syscall sys_io				; display AH
0458+  0A63 24          	mov ah, bl				; retrieve al
0459+  0A64 19 00       	mov al, 0
0460+  0A66 05 03       	syscall sys_io				; display AL
0461+  0A68             
0462+  0A68 EA          	pop bl
0463+  0A69 07 88 08    	call itoa				; convert bh to char in A
0464+  0A6C 2F          	mov bl, al				; save al
0465+  0A6D 19 00       	mov al, 0
0466+  0A6F 05 03       	syscall sys_io				; display AH
0467+  0A71 24          	mov ah, bl				; retrieve al
0468+  0A72 19 00       	mov al, 0
0469+  0A74 05 03       	syscall sys_io				; display AL
0470+  0A76             
0471+  0A76 E5          	pop b
0472+  0A77 E4          	pop a
0473+  0A78 09          	ret
0474+  0A79             
0475+  0A79             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  0A79             ; INPUT 16BIT HEX INTEGER
0477+  0A79             ; read 16bit integer into A
0478+  0A79             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  0A79             scan_u16x:
0480+  0A79 F8 10 00    	enter 16
0481+  0A7C D8          	push b
0482+  0A7D DA          	push d
0483+  0A7E             
0484+  0A7E FA F1 FF    	lea d, [bp + -15]
0485+  0A81 07 C8 08    	call gets				; get number
0486+  0A84             
0487+  0A84 32          	mov bl, [d]
0488+  0A85 37          	mov bh, bl
0489+  0A86 33 01 00    	mov bl, [d + 1]
0490+  0A89 07 76 08    	call atoi				; convert to int in AL
0491+  0A8C 23          	mov ah, al				; move to AH
0492+  0A8D             
0493+  0A8D 33 02 00    	mov bl, [d + 2]
0494+  0A90 37          	mov bh, bl
0495+  0A91 33 03 00    	mov bl, [d + 3]
0496+  0A94 07 76 08    	call atoi				; convert to int in AL
0497+  0A97             
0498+  0A97 E7          	pop d
0499+  0A98 E5          	pop b
0500+  0A99 F9          	leave
0501+  0A9A 09          	ret
0502+  0A9B             
0503+  0A9B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0504+  0A9B             ; PRINT 8bit HEX INTEGER
0505+  0A9B             ; integer value in reg bl
0506+  0A9B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  0A9B             print_u8x:
0508+  0A9B D7          	push a
0509+  0A9C DD          	push bl
0510+  0A9D             
0511+  0A9D 07 88 08    	call itoa				; convert bl to char in A
0512+  0AA0 2F          	mov bl, al				; save al
0513+  0AA1 19 00       	mov al, 0
0514+  0AA3 05 03       	syscall sys_io				; display AH
0515+  0AA5 24          	mov ah, bl				; retrieve al
0516+  0AA6 19 00       	mov al, 0
0517+  0AA8 05 03       	syscall sys_io				; display AL
0518+  0AAA             
0519+  0AAA EA          	pop bl
0520+  0AAB E4          	pop a
0521+  0AAC 09          	ret
0522+  0AAD             
0523+  0AAD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0524+  0AAD             ; print 8bit decimal unsigned number
0525+  0AAD             ; input number in AL
0526+  0AAD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  0AAD             print_u8d:
0528+  0AAD D7          	push a
0529+  0AAE D8          	push b
0530+  0AAF             
0531+  0AAF 22 00       	mov ah, 0
0532+  0AB1 26 64 00    	mov b, 100
0533+  0AB4 AE          	div a, b
0534+  0AB5 D8          	push b			; save remainder
0535+  0AB6 B9 00       	cmp al, 0
0536+  0AB8 C6 C2 0A    	je skip100
0537+  0ABB 6A 30       	add al, $30
0538+  0ABD 23          	mov ah, al
0539+  0ABE 19 00       	mov al, 0
0540+  0AC0 05 03       	syscall sys_io	; print coeff
0541+  0AC2             skip100:
0542+  0AC2 E4          	pop a
0543+  0AC3 22 00       	mov ah, 0
0544+  0AC5 26 0A 00    	mov b, 10
0545+  0AC8 AE          	div a, b
0546+  0AC9 D8          	push b			; save remainder
0547+  0ACA B9 00       	cmp al, 0
0548+  0ACC C6 D6 0A    	je skip10
0549+  0ACF 6A 30       	add al, $30
0550+  0AD1 23          	mov ah, al
0551+  0AD2 19 00       	mov al, 0
0552+  0AD4 05 03       	syscall sys_io	; print coeff
0553+  0AD6             skip10:
0554+  0AD6 E4          	pop a
0555+  0AD7 1B          	mov al, bl
0556+  0AD8 6A 30       	add al, $30
0557+  0ADA 23          	mov ah, al
0558+  0ADB 19 00       	mov al, 0
0559+  0ADD 05 03       	syscall sys_io	; print coeff
0560+  0ADF E5          	pop b
0561+  0AE0 E4          	pop a
0562+  0AE1 09          	ret
0563+  0AE2             
0564+  0AE2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0565+  0AE2             ; INPUT 8BIT HEX INTEGER
0566+  0AE2             ; read 8bit integer into AL
0567+  0AE2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  0AE2             scan_u8x:
0569+  0AE2 F8 04 00    	enter 4
0570+  0AE5 D8          	push b
0571+  0AE6 DA          	push d
0572+  0AE7             
0573+  0AE7 FA FD FF    	lea d, [bp + -3]
0574+  0AEA 07 C8 08    	call gets				; get number
0575+  0AED             
0576+  0AED 32          	mov bl, [d]
0577+  0AEE 37          	mov bh, bl
0578+  0AEF 33 01 00    	mov bl, [d + 1]
0579+  0AF2 07 76 08    	call atoi				; convert to int in AL
0580+  0AF5             
0581+  0AF5 E7          	pop d
0582+  0AF6 E5          	pop b
0583+  0AF7 F9          	leave
0584+  0AF8 09          	ret
0585+  0AF9             
0586+  0AF9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  0AF9             ; input decimal number
0588+  0AF9             ; result in A
0589+  0AF9             ; 655'\0'
0590+  0AF9             ; low--------high
0591+  0AF9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0592+  0AF9             scan_u16d:
0593+  0AF9 F8 08 00    	enter 8
0594+  0AFC E2          	push si
0595+  0AFD D8          	push b
0596+  0AFE D9          	push c
0597+  0AFF DA          	push d
0598+  0B00 FA F9 FF    	lea d, [bp +- 7]
0599+  0B03 07 C8 08    	call gets
0600+  0B06 07 F6 07    	call strlen			; get string length in C
0601+  0B09 7E          	dec c
0602+  0B0A FD 4E       	mov si, d
0603+  0B0C 12          	mov a, c
0604+  0B0D FD 99       	shl a
0605+  0B0F 3B 5E 08    	mov d, table_power
0606+  0B12 59          	add d, a
0607+  0B13 38 00 00    	mov c, 0
0608+  0B16             mul_loop:
0609+  0B16 F6          	lodsb			; load ASCII to al
0610+  0B17 B9 00       	cmp al, 0
0611+  0B19 C6 2C 0B    	je mul_exit
0612+  0B1C 6F 30       	sub al, $30		; make into integer
0613+  0B1E 22 00       	mov ah, 0
0614+  0B20 2A          	mov b, [d]
0615+  0B21 AC          	mul a, b			; result in B since it fits in 16bits
0616+  0B22 11          	mov a, b
0617+  0B23 28          	mov b, c
0618+  0B24 54          	add a, b
0619+  0B25 39          	mov c, a
0620+  0B26 63 02 00    	sub d, 2
0621+  0B29 0A 16 0B    	jmp mul_loop
0622+  0B2C             mul_exit:
0623+  0B2C 12          	mov a, c
0624+  0B2D E7          	pop d
0625+  0B2E E6          	pop c
0626+  0B2F E5          	pop b
0627+  0B30 EF          	pop si
0628+  0B31 F9          	leave
0629+  0B32 09          	ret
0025   0B33             .include "ctype.asm"
0001+  0B33             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0B33             ; ctype.s
0003+  0B33             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0B33             
0005+  0B33             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  0B33             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  0B33             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  0B33             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  0B33             ;; characters are supported.
0010+  0B33             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  0B33             ;; isalnum 
0012+  0B33             ;; isalpha 
0013+  0B33             ;; islower 
0014+  0B33             ;; isupper 
0015+  0B33             ;; isdigit 
0016+  0B33             ;; isxdigit
0017+  0B33             ;; iscntrl 
0018+  0B33             ;; isgraph 
0019+  0B33             ;; isspace 
0020+  0B33             ;; isblank 
0021+  0B33             ;; isprint 
0022+  0B33             ;; ispunct 
0023+  0B33             ;; tolower 
0024+  0B33             ;; toupper
0025+  0B33             
0026+  0B33             
0027+  0B33             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  0B33             ;; IS ALPHANUMERIC
0029+  0B33             ;; sets ZF according with result
0030+  0B33             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  0B33             isalnum:
0032+  0B33 07 50 0B    	call isalpha
0033+  0B36 C6 3C 0B    	je isalnum_exit
0034+  0B39 07 3D 0B    	call isdigit
0035+  0B3C             isalnum_exit:
0036+  0B3C 09          	ret	
0037+  0B3D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0B3D             ;; IS DIGIT
0039+  0B3D             ;; sets ZF according with result
0040+  0B3D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  0B3D             isdigit:
0042+  0B3D DB          	push al
0043+  0B3E B9 30       	cmp al, '0'
0044+  0B40 C8 4C 0B    	jlu isdigit_false
0045+  0B43 B9 39       	cmp al, '9'
0046+  0B45 D1 4C 0B    	jgu isdigit_false
0047+  0B48 87 00       	and al, 0	; set ZF
0048+  0B4A E8          	pop al
0049+  0B4B 09          	ret
0050+  0B4C             isdigit_false:
0051+  0B4C 8B 01       	or al, 1	; clear ZF
0052+  0B4E E8          	pop al
0053+  0B4F 09          	ret	
0054+  0B50             	
0055+  0B50             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  0B50             ;; IS ALPHA
0057+  0B50             ;; sets ZF according with result
0058+  0B50             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  0B50             isalpha:
0060+  0B50 DB          	push al
0061+  0B51 B9 5F       	cmp al, '_'
0062+  0B53 C6 73 0B    	je isalpha_true
0063+  0B56 B9 2E       	cmp al, '.'
0064+  0B58 C6 73 0B    	je isalpha_true
0065+  0B5B B9 41       	cmp al, 'A'
0066+  0B5D C8 6F 0B    	jlu isalpha_false
0067+  0B60 B9 7A       	cmp al, 'z'
0068+  0B62 D1 6F 0B    	jgu isalpha_false
0069+  0B65 B9 5A       	cmp al, 'Z'
0070+  0B67 D0 73 0B    	jleu isalpha_true
0071+  0B6A B9 61       	cmp al, 'a'
0072+  0B6C C9 73 0B    	jgeu isalpha_true
0073+  0B6F             isalpha_false:
0074+  0B6F 8B 01       	or al, 1	; clear ZF
0075+  0B71 E8          	pop al
0076+  0B72 09          	ret
0077+  0B73             isalpha_true:
0078+  0B73 87 00       	and al, 0	; set ZF
0079+  0B75 E8          	pop al
0080+  0B76 09          	ret
0081+  0B77             
0082+  0B77             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  0B77             ;; IS PATH-ALPHA
0084+  0B77             ;; sets ZF according with result
0085+  0B77             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  0B77             ispath:
0087+  0B77 DB          	push al
0088+  0B78 07 3D 0B    	call isdigit
0089+  0B7B C6 A5 0B    	je ispath_true
0090+  0B7E B9 5F       	cmp al, '_'
0091+  0B80 C6 A5 0B    	je ispath_true
0092+  0B83 B9 2F       	cmp al, '/'
0093+  0B85 C6 A5 0B    	je ispath_true
0094+  0B88 B9 2E       	cmp al, '.'
0095+  0B8A C6 A5 0B    	je ispath_true
0096+  0B8D B9 41       	cmp al, 'A'
0097+  0B8F C8 A1 0B    	jlu ispath_false
0098+  0B92 B9 7A       	cmp al, 'z'
0099+  0B94 D1 A1 0B    	jgu ispath_false
0100+  0B97 B9 5A       	cmp al, 'Z'
0101+  0B99 D0 A5 0B    	jleu ispath_true
0102+  0B9C B9 61       	cmp al, 'a'
0103+  0B9E C9 A5 0B    	jgeu ispath_true
0104+  0BA1             ispath_false:
0105+  0BA1 8B 01       	or al, 1	; clear ZF
0106+  0BA3 E8          	pop al
0107+  0BA4 09          	ret
0108+  0BA5             ispath_true:
0109+  0BA5 87 00       	and al, 0	; set ZF
0110+  0BA7 E8          	pop al
0111+  0BA8 09          	ret
0112+  0BA9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  0BA9             ;; IS SPACE
0114+  0BA9             ;; sets ZF according with result
0115+  0BA9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  0BA9             isspace:
0117+  0BA9 B9 20       	cmp al, $20		; ' '
0118+  0BAB C6 BF 0B    	je isspace_exit
0119+  0BAE B9 09       	cmp al, $09		; '\t'
0120+  0BB0 C6 BF 0B    	je isspace_exit
0121+  0BB3 B9 0A       	cmp al, $0A		; '\n'
0122+  0BB5 C6 BF 0B    	je isspace_exit
0123+  0BB8 B9 0D       	cmp al, $0D		; '\r'
0124+  0BBA C6 BF 0B    	je isspace_exit
0125+  0BBD B9 0B       	cmp al, $0B		; '\v'
0126+  0BBF             isspace_exit:
0127+  0BBF 09          	ret	
0128+  0BC0             
0129+  0BC0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0BC0             ; TO LOWER
0131+  0BC0             ; input in AL
0132+  0BC0             ; output in AL
0133+  0BC0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  0BC0             to_lower:
0135+  0BC0 B9 5A       	cmp al, 'Z'
0136+  0BC2 D1 C7 0B    	jgu to_lower_ret
0137+  0BC5 6A 20       	add al, $20				; convert to lower case
0138+  0BC7             to_lower_ret:
0139+  0BC7 09          	ret
0140+  0BC8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  0BC8             ; TO UPPER
0142+  0BC8             ; input in AL
0143+  0BC8             ; output in AL
0144+  0BC8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  0BC8             to_upper:
0146+  0BC8 B9 61       	cmp al, 'a'
0147+  0BCA C8 CF 0B    	jlu to_upper_ret
0148+  0BCD 6F 20       	sub al, $20			; convert to upper case
0149+  0BCF             to_upper_ret:
0150+  0BCF 09          	ret
0151+  0BD0             
0026   0BD0             
0027   0BD0             .end
0028   0BD0             
0029   0BD0             
tasm: Number of errors = 0
