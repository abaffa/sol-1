0001   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002   0000             ; ADVENTURE
0003   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004   0000             
0005   0000             .include "kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0006   0000             
0007   0400             .org PROC_TEXT_ORG			; origin at 1024
0008   0400             
0009   0400             adventure:
0010   0400 3B 1B 0C    	mov d, s_telnet_clear
0011   0403 07 C0 0D    	call puts
0012   0406 3B 54 06    	mov d, s_adv_instr
0013   0409 07 C0 0D    	call puts
0014   040C             
0015   040C             adv_start:
0016   040C 07 6D 0D    	call printnl
0017   040F 19 00       	mov al, 0
0018   0411 3D AB 04    	mov [player_location], al		; reset position
0019   0414 3B B9 06    	mov d, s_adv_0
0020   0417 07 6D 0D    	call printnl
0021   041A 07 C0 0D    	call puts
0022   041D 07 6D 0D    	call printnl
0023   0420             
0024   0420             adv_loop:
0025   0420 3B AC 04    	mov d, player_command
0026   0423 07 8D 0C    	call gets			; get command
0027   0426             
0028   0426 1E          	mov al, [d]
0029   0427 23          	mov ah, al
0030   0428 07 8D 0F    	call to_upper
0031   042B B9 51       	cmp al, 'Q'
0032   042D C6 A9 04    	je adv_ret			; quit game
0033   0430 B9 58       	cmp al, 'X'
0034   0432 C6 74 04    	je examine_command
0035   0435 07 24 06    	call adv_map_dir		; convert NESW to 0123 in AL
0036   0438 B9 04       	cmp al, 4
0037   043A C6 6B 04    	je unknown_command		; other keywords
0038   043D             move_command:
0039   043D 2F          	mov bl, al			; save converted movement value
0040   043E 1D AB 04    	mov al, [player_location]		; get current pos
0041   0441 3A 02       	mov cl, 2
0042   0443 9E          	shl al, cl			; multiply pos by 4, for table conversion
0043   0444 6B          	add al, bl			; get new position table index
0044   0445 22 00       	mov ah, 0
0045   0447 53 FC 05    	add a, adv_pos_table
0046   044A 3C          	mov d, a
0047   044B 1E          	mov al, [d]
0048   044C 3D AB 04    	mov [player_location], al		; save new position
0049   044F 07 55 04    	call print_location_description
0050   0452 0A 20 04    	jmp adv_loop			; back to main loop
0051   0455             
0052   0455             print_location_description:
0053   0455 1D AB 04    	mov al, [player_location]		; get position
0054   0458 22 00       	mov ah, 0
0055   045A 3A 01       	mov cl, 1
0056   045C 9D          	shl a, cl			; times 2
0057   045D B7 40 06    	mov a, [a + adv_text_table]	; get text description for new position
0058   0460 3C          	mov d, a
0059   0461 07 6D 0D    	call printnl
0060   0464 07 C0 0D    	call puts
0061   0467 07 6D 0D    	call printnl
0062   046A 09          	ret
0063   046B             
0064   046B             unknown_command:
0065   046B 3B 1B 0B    	mov d, s_unknown_command
0066   046E 07 C0 0D    	call puts
0067   0471 0A 20 04    	jmp adv_loop
0068   0474             
0069   0474             examine_command:
0070   0474 3B 53 0B    	mov d, s_items_here
0071   0477 07 C0 0D    	call puts
0072   047A 3B AC 05    	mov d, item_list
0073   047D             examine_command_L0:
0074   047D 16 01 00    	mov a, [d + 1]
0075   0480 AF 00 00    	cmp a, 0
0076   0483 C6 A6 04    	je examine_command_end
0077   0486 1E          	mov al, [d]
0078   0487 31 AB 04    	mov bl, [player_location]
0079   048A BA          	cmp al, bl
0080   048B C6 94 04    	je examine_command_item_here
0081   048E 58 04 00    	add d, 4
0082   0491 0A 7D 04    	jmp examine_command_L0
0083   0494             examine_command_item_here:
0084   0494 DA          	push d
0085   0495 16 01 00    	mov a, [d+1]	; get pointer
0086   0498 3C          	mov d, a
0087   0499 07 C0 0D    	call puts
0088   049C E7          	pop d
0089   049D 58 04 00    	add d, 4
0090   04A0 07 6D 0D    	call printnl
0091   04A3 0A 7D 04    	jmp examine_command_L0
0092   04A6             examine_command_end:
0093   04A6 0A 20 04    	jmp adv_loop
0094   04A9             
0095   04A9             adv_ret:
0096   04A9 05 0B       	syscall sys_terminate_proc			; return to shell
0097   04AB             
0098   04AB 00          player_location:	.db 0
0099   04AC 00 00 00 00 player_command:		.fill 256, 0
0099   04B0 00 00 00 00 
0099   04B4 00 00 00 00 
0099   04B8 00 00 00 00 
0099   04BC 00 00 00 00 
0099   04C0 00 00 00 00 
0099   04C4 00 00 00 00 
0099   04C8 00 00 00 00 
0099   04CC 00 00 00 00 
0099   04D0 00 00 00 00 
0099   04D4 00 00 00 00 
0099   04D8 00 00 00 00 
0099   04DC 00 00 00 00 
0099   04E0 00 00 00 00 
0099   04E4 00 00 00 00 
0099   04E8 00 00 00 00 
0099   04EC 00 00 00 00 
0099   04F0 00 00 00 00 
0099   04F4 00 00 00 00 
0099   04F8 00 00 00 00 
0099   04FC 00 00 00 00 
0099   0500 00 00 00 00 
0099   0504 00 00 00 00 
0099   0508 00 00 00 00 
0099   050C 00 00 00 00 
0099   0510 00 00 00 00 
0099   0514 00 00 00 00 
0099   0518 00 00 00 00 
0099   051C 00 00 00 00 
0099   0520 00 00 00 00 
0099   0524 00 00 00 00 
0099   0528 00 00 00 00 
0099   052C 00 00 00 00 
0099   0530 00 00 00 00 
0099   0534 00 00 00 00 
0099   0538 00 00 00 00 
0099   053C 00 00 00 00 
0099   0540 00 00 00 00 
0099   0544 00 00 00 00 
0099   0548 00 00 00 00 
0099   054C 00 00 00 00 
0099   0550 00 00 00 00 
0099   0554 00 00 00 00 
0099   0558 00 00 00 00 
0099   055C 00 00 00 00 
0099   0560 00 00 00 00 
0099   0564 00 00 00 00 
0099   0568 00 00 00 00 
0099   056C 00 00 00 00 
0099   0570 00 00 00 00 
0099   0574 00 00 00 00 
0099   0578 00 00 00 00 
0099   057C 00 00 00 00 
0099   0580 00 00 00 00 
0099   0584 00 00 00 00 
0099   0588 00 00 00 00 
0099   058C 00 00 00 00 
0099   0590 00 00 00 00 
0099   0594 00 00 00 00 
0099   0598 00 00 00 00 
0099   059C 00 00 00 00 
0099   05A0 00 00 00 00 
0099   05A4 00 00 00 00 
0099   05A8 00 00 00 00 
0100   05AC             
0101   05AC             
0102   05AC             ; location(1), 255 = with player
0103   05AC             ; pointer to item name (2)
0104   05AC             ; flags(1)
0105   05AC             ;
0106   05AC             item_list:
0107   05AC 00          	.db 0
0108   05AD C0 05       	.dw item0
0109   05AF 00          	.db 0
0110   05B0 00          	.db 0
0111   05B1 D5 05       	.dw item1
0112   05B3 00          	.db 0
0113   05B4 01          	.db 1
0114   05B5 E1 05       	.dw item2
0115   05B7 00          	.db 0
0116   05B8 01          	.db 1
0117   05B9 F1 05       	.dw item3
0118   05BB 00          	.db 0
0119   05BC             ; end of list
0120   05BC 00          	.db 0
0121   05BD 00 00       	.dw 0
0122   05BF 00          	.db 0
0123   05C0             	
0124   05C0             item_names:	
0125   05C0 61 6E 20 6F item0:	.db "an old brass lantern", 0
0125   05C4 6C 64 20 62 
0125   05C8 72 61 73 73 
0125   05CC 20 6C 61 6E 
0125   05D0 74 65 72 6E 
0125   05D4 00 
0126   05D5 61 20 73 6D item1:	.db "a small key", 0
0126   05D9 61 6C 6C 20 
0126   05DD 6B 65 79 00 
0127   05E1 61 6E 20 65 item2:	.db "an empty bottle", 0
0127   05E5 6D 70 74 79 
0127   05E9 20 62 6F 74 
0127   05ED 74 6C 65 00 
0128   05F1 61 6E 20 6F item3:	.db "an old axe", 0
0128   05F5 6C 64 20 61 
0128   05F9 78 65 00 
0129   05FC             
0130   05FC             adv_pos_table:
0131   05FC             	; pos 0, beginning
0132   05FC 01          	.db 1			; N
0133   05FD 02          	.db 2			; E
0134   05FE 03          	.db 3			; S
0135   05FF 04          	.db 4			; W
0136   0600             	; pos 1
0137   0600 06          	.db 6			
0138   0601 01          	.db 1			
0139   0602 00          	.db 0			
0140   0603 01          	.db 1	
0141   0604             	; pos 2
0142   0604 02          	.db 2
0143   0605 02          	.db 2
0144   0606 03          	.db 3
0145   0607 00          	.db 0	
0146   0608             	; pos 3
0147   0608 00          	.db 0
0148   0609 02          	.db 2
0149   060A 03          	.db 3
0150   060B 04          	.db 4
0151   060C             	; pos 4
0152   060C 05          	.db 5
0153   060D 00          	.db 0
0154   060E 03          	.db 3
0155   060F 04          	.db 4
0156   0610             	; pos 5
0157   0610 05          	.db 5
0158   0611 05          	.db 5
0159   0612 04          	.db 4
0160   0613 05          	.db 5
0161   0614             	; pos 6
0162   0614 07          	.db 7
0163   0615 06          	.db 6
0164   0616 01          	.db 1
0165   0617 06          	.db 6
0166   0618             	; pos 7
0167   0618 08          	.db 8
0168   0619 07          	.db 7
0169   061A 06          	.db 6
0170   061B 07          	.db 7
0171   061C             	; pos 8
0172   061C 09          	.db 9
0173   061D 08          	.db 8
0174   061E 07          	.db 7
0175   061F 08          	.db 8
0176   0620             	; pos 9
0177   0620 09          	.db 9
0178   0621 09          	.db 9
0179   0622 08          	.db 8
0180   0623 09          	.db 9
0181   0624             
0182   0624             
0183   0624             ; dir char in AL
0184   0624             ; output in AL
0185   0624             adv_map_dir:
0186   0624 23          	mov ah, al
0187   0625 19 00       	mov al, 0
0188   0627 76 4E       	cmp ah, 'N'
0189   0629 C6 3F 06    	je dir_ret
0190   062C 7A          	inc al
0191   062D 76 45       	cmp ah, 'E'
0192   062F C6 3F 06    	je dir_ret
0193   0632 7A          	inc al
0194   0633 76 53       	cmp ah, 'S'
0195   0635 C6 3F 06    	je dir_ret
0196   0638 7A          	inc al
0197   0639 76 57       	cmp ah, 'W'
0198   063B C6 3F 06    	je dir_ret
0199   063E 7A          	inc al			
0200   063F             dir_ret:
0201   063F 09          	ret
0202   0640             	
0203   0640             	
0204   0640             adv_text_table:
0205   0640 B9 06       	.dw s_adv_0
0206   0642 C9 07       	.dw s_adv_1
0207   0644 09 08       	.dw s_adv_2
0208   0646 BC 08       	.dw s_adv_3
0209   0648 F5 08       	.dw s_adv_4
0210   064A 11 09       	.dw s_adv_5
0211   064C 62 09       	.dw s_adv_6
0212   064E AF 09       	.dw s_adv_7
0213   0650 EF 09       	.dw s_adv_8
0214   0652 96 0A       	.dw s_adv_9	
0215   0654             	
0216   0654             
0217   0654             
0218   0654 49 4E 53 54 s_adv_instr:	.db "INSTRUCTIONS:\n"
0218   0658 52 55 43 54 
0218   065C 49 4F 4E 53 
0218   0660 3A 0A 
0219   0662 6E 3A 20 67 				.db "n: go north\n"
0219   0666 6F 20 6E 6F 
0219   066A 72 74 68 0A 
0220   066E 73 3A 20 67 				.db "s: go south\n"
0220   0672 6F 20 73 6F 
0220   0676 75 74 68 0A 
0221   067A 77 3A 20 67 				.db "w: go west\n"
0221   067E 6F 20 77 65 
0221   0682 73 74 0A 
0222   0685 65 3A 20 67 				.db "e: go east\n"
0222   0689 6F 20 65 61 
0222   068D 73 74 0A 
0223   0690 78 3A 20 65 				.db "x: examine location\n"
0223   0694 78 61 6D 69 
0223   0698 6E 65 20 6C 
0223   069C 6F 63 61 74 
0223   06A0 69 6F 6E 0A 
0224   06A4 74 3A 20 74 				.db "t: take item\n"
0224   06A8 61 6B 65 20 
0224   06AC 69 74 65 6D 
0224   06B0 0A 
0225   06B1 71 3A 20 71 				.db "q: quit", 0
0225   06B5 75 69 74 00 
0226   06B9             
0227   06B9             s_adv_0:
0228   06B9 49 74 20 69 	.db "It is around 9am, and you find yourself in a forest.\n"
0228   06BD 73 20 61 72 
0228   06C1 6F 75 6E 64 
0228   06C5 20 39 61 6D 
0228   06C9 2C 20 61 6E 
0228   06CD 64 20 79 6F 
0228   06D1 75 20 66 69 
0228   06D5 6E 64 20 79 
0228   06D9 6F 75 72 73 
0228   06DD 65 6C 66 20 
0228   06E1 69 6E 20 61 
0228   06E5 20 66 6F 72 
0228   06E9 65 73 74 2E 
0228   06ED 0A 
0229   06EE 54 68 65 72 	.db "There is an old wooden cabin north of you.\n"
0229   06F2 65 20 69 73 
0229   06F6 20 61 6E 20 
0229   06FA 6F 6C 64 20 
0229   06FE 77 6F 6F 64 
0229   0702 65 6E 20 63 
0229   0706 61 62 69 6E 
0229   070A 20 6E 6F 72 
0229   070E 74 68 20 6F 
0229   0712 66 20 79 6F 
0229   0716 75 2E 0A 
0230   0719 54 68 65 20 	.db "The cabin looks very old and seems abandoned. It has two windows and a door at the front.\n"
0230   071D 63 61 62 69 
0230   0721 6E 20 6C 6F 
0230   0725 6F 6B 73 20 
0230   0729 76 65 72 79 
0230   072D 20 6F 6C 64 
0230   0731 20 61 6E 64 
0230   0735 20 73 65 65 
0230   0739 6D 73 20 61 
0230   073D 62 61 6E 64 
0230   0741 6F 6E 65 64 
0230   0745 2E 20 49 74 
0230   0749 20 68 61 73 
0230   074D 20 74 77 6F 
0230   0751 20 77 69 6E 
0230   0755 64 6F 77 73 
0230   0759 20 61 6E 64 
0230   075D 20 61 20 64 
0230   0761 6F 6F 72 20 
0230   0765 61 74 20 74 
0230   0769 68 65 20 66 
0230   076D 72 6F 6E 74 
0230   0771 2E 0A 
0231   0773 59 6F 75 20 	.db "You can see through the windows and the sunlight illuminates the inside of the cabin.", 0
0231   0777 63 61 6E 20 
0231   077B 73 65 65 20 
0231   077F 74 68 72 6F 
0231   0783 75 67 68 20 
0231   0787 74 68 65 20 
0231   078B 77 69 6E 64 
0231   078F 6F 77 73 20 
0231   0793 61 6E 64 20 
0231   0797 74 68 65 20 
0231   079B 73 75 6E 6C 
0231   079F 69 67 68 74 
0231   07A3 20 69 6C 6C 
0231   07A7 75 6D 69 6E 
0231   07AB 61 74 65 73 
0231   07AF 20 74 68 65 
0231   07B3 20 69 6E 73 
0231   07B7 69 64 65 20 
0231   07BB 6F 66 20 74 
0231   07BF 68 65 20 63 
0231   07C3 61 62 69 6E 
0231   07C7 2E 00 
0232   07C9             
0233   07C9             s_adv_1:
0234   07C9 59 6F 75 20 	.db "You are at the entrance door to the cabin. The door is locked.\n", 0
0234   07CD 61 72 65 20 
0234   07D1 61 74 20 74 
0234   07D5 68 65 20 65 
0234   07D9 6E 74 72 61 
0234   07DD 6E 63 65 20 
0234   07E1 64 6F 6F 72 
0234   07E5 20 74 6F 20 
0234   07E9 74 68 65 20 
0234   07ED 63 61 62 69 
0234   07F1 6E 2E 20 54 
0234   07F5 68 65 20 64 
0234   07F9 6F 6F 72 20 
0234   07FD 69 73 20 6C 
0234   0801 6F 63 6B 65 
0234   0805 64 2E 0A 00 
0235   0809             
0236   0809             s_adv_2:
0237   0809 59 6F 75 20 	.db "You are in a clearing. Small trees encircle you. The grass is short and there are a few big rocks on the ground.\n"
0237   080D 61 72 65 20 
0237   0811 69 6E 20 61 
0237   0815 20 63 6C 65 
0237   0819 61 72 69 6E 
0237   081D 67 2E 20 53 
0237   0821 6D 61 6C 6C 
0237   0825 20 74 72 65 
0237   0829 65 73 20 65 
0237   082D 6E 63 69 72 
0237   0831 63 6C 65 20 
0237   0835 79 6F 75 2E 
0237   0839 20 54 68 65 
0237   083D 20 67 72 61 
0237   0841 73 73 20 69 
0237   0845 73 20 73 68 
0237   0849 6F 72 74 20 
0237   084D 61 6E 64 20 
0237   0851 74 68 65 72 
0237   0855 65 20 61 72 
0237   0859 65 20 61 20 
0237   085D 66 65 77 20 
0237   0861 62 69 67 20 
0237   0865 72 6F 63 6B 
0237   0869 73 20 6F 6E 
0237   086D 20 74 68 65 
0237   0871 20 67 72 6F 
0237   0875 75 6E 64 2E 
0237   0879 0A 
0238   087A 54 68 65 20 	.db "The sky is a deep blue with big white puffy clouds flying calmly.", 0
0238   087E 73 6B 79 20 
0238   0882 69 73 20 61 
0238   0886 20 64 65 65 
0238   088A 70 20 62 6C 
0238   088E 75 65 20 77 
0238   0892 69 74 68 20 
0238   0896 62 69 67 20 
0238   089A 77 68 69 74 
0238   089E 65 20 70 75 
0238   08A2 66 66 79 20 
0238   08A6 63 6C 6F 75 
0238   08AA 64 73 20 66 
0238   08AE 6C 79 69 6E 
0238   08B2 67 20 63 61 
0238   08B6 6C 6D 6C 79 
0238   08BA 2E 00 
0239   08BC             
0240   08BC             s_adv_3:
0241   08BC 59 6F 75 20 	.db "You are in a deep forest. Big trees block the way south.", 0
0241   08C0 61 72 65 20 
0241   08C4 69 6E 20 61 
0241   08C8 20 64 65 65 
0241   08CC 70 20 66 6F 
0241   08D0 72 65 73 74 
0241   08D4 2E 20 42 69 
0241   08D8 67 20 74 72 
0241   08DC 65 65 73 20 
0241   08E0 62 6C 6F 63 
0241   08E4 6B 20 74 68 
0241   08E8 65 20 77 61 
0241   08EC 79 20 73 6F 
0241   08F0 75 74 68 2E 
0241   08F4 00 
0242   08F5             
0243   08F5             s_adv_4:
0244   08F5 59 6F 75 20 	.db "You are on a rocky plateau.", 0
0244   08F9 61 72 65 20 
0244   08FD 6F 6E 20 61 
0244   0901 20 72 6F 63 
0244   0905 6B 79 20 70 
0244   0909 6C 61 74 65 
0244   090D 61 75 2E 00 
0245   0911             
0246   0911             s_adv_5:
0247   0911 59 6F 75 20 	.db "You are at the top of the plateau. Looking down the mountain you see a big lake.", 0
0247   0915 61 72 65 20 
0247   0919 61 74 20 74 
0247   091D 68 65 20 74 
0247   0921 6F 70 20 6F 
0247   0925 66 20 74 68 
0247   0929 65 20 70 6C 
0247   092D 61 74 65 61 
0247   0931 75 2E 20 4C 
0247   0935 6F 6F 6B 69 
0247   0939 6E 67 20 64 
0247   093D 6F 77 6E 20 
0247   0941 74 68 65 20 
0247   0945 6D 6F 75 6E 
0247   0949 74 61 69 6E 
0247   094D 20 79 6F 75 
0247   0951 20 73 65 65 
0247   0955 20 61 20 62 
0247   0959 69 67 20 6C 
0247   095D 61 6B 65 2E 
0247   0961 00 
0248   0962             
0249   0962             s_adv_6:
0250   0962 59 6F 75 20 	.db "You are north of the cabin. There is a path through the trees leading north.", 0
0250   0966 61 72 65 20 
0250   096A 6E 6F 72 74 
0250   096E 68 20 6F 66 
0250   0972 20 74 68 65 
0250   0976 20 63 61 62 
0250   097A 69 6E 2E 20 
0250   097E 54 68 65 72 
0250   0982 65 20 69 73 
0250   0986 20 61 20 70 
0250   098A 61 74 68 20 
0250   098E 74 68 72 6F 
0250   0992 75 67 68 20 
0250   0996 74 68 65 20 
0250   099A 74 72 65 65 
0250   099E 73 20 6C 65 
0250   09A2 61 64 69 6E 
0250   09A6 67 20 6E 6F 
0250   09AA 72 74 68 2E 
0250   09AE 00 
0251   09AF             
0252   09AF             s_adv_7:
0253   09AF 59 6F 75 20 	.db "You are in a forest path. There is a small stream north of you.", 0
0253   09B3 61 72 65 20 
0253   09B7 69 6E 20 61 
0253   09BB 20 66 6F 72 
0253   09BF 65 73 74 20 
0253   09C3 70 61 74 68 
0253   09C7 2E 20 54 68 
0253   09CB 65 72 65 20 
0253   09CF 69 73 20 61 
0253   09D3 20 73 6D 61 
0253   09D7 6C 6C 20 73 
0253   09DB 74 72 65 61 
0253   09DF 6D 20 6E 6F 
0253   09E3 72 74 68 20 
0253   09E7 6F 66 20 79 
0253   09EB 6F 75 2E 00 
0254   09EF             
0255   09EF             s_adv_8:
0256   09EF 59 6F 75 20 	.db "You are in a rocky floored water spring. "
0256   09F3 61 72 65 20 
0256   09F7 69 6E 20 61 
0256   09FB 20 72 6F 63 
0256   09FF 6B 79 20 66 
0256   0A03 6C 6F 6F 72 
0256   0A07 65 64 20 77 
0256   0A0B 61 74 65 72 
0256   0A0F 20 73 70 72 
0256   0A13 69 6E 67 2E 
0256   0A17 20 
0257   0A18 43 6C 65 61 	.db "Clear water flows out of a small spring amidst the rocks. "
0257   0A1C 72 20 77 61 
0257   0A20 74 65 72 20 
0257   0A24 66 6C 6F 77 
0257   0A28 73 20 6F 75 
0257   0A2C 74 20 6F 66 
0257   0A30 20 61 20 73 
0257   0A34 6D 61 6C 6C 
0257   0A38 20 73 70 72 
0257   0A3C 69 6E 67 20 
0257   0A40 61 6D 69 64 
0257   0A44 73 74 20 74 
0257   0A48 68 65 20 72 
0257   0A4C 6F 63 6B 73 
0257   0A50 2E 20 
0258   0A52 57 65 74 20 	.db "Wet and muddy grass encircles the spring. A bird is singing nearby.", 0
0258   0A56 61 6E 64 20 
0258   0A5A 6D 75 64 64 
0258   0A5E 79 20 67 72 
0258   0A62 61 73 73 20 
0258   0A66 65 6E 63 69 
0258   0A6A 72 63 6C 65 
0258   0A6E 73 20 74 68 
0258   0A72 65 20 73 70 
0258   0A76 72 69 6E 67 
0258   0A7A 2E 20 41 20 
0258   0A7E 62 69 72 64 
0258   0A82 20 69 73 20 
0258   0A86 73 69 6E 67 
0258   0A8A 69 6E 67 20 
0258   0A8E 6E 65 61 72 
0258   0A92 62 79 2E 00 
0259   0A96             
0260   0A96             s_adv_9:
0261   0A96 59 6F 75 20 	.db "You are in a bog. The water reaches up to your knees.\n"
0261   0A9A 61 72 65 20 
0261   0A9E 69 6E 20 61 
0261   0AA2 20 62 6F 67 
0261   0AA6 2E 20 54 68 
0261   0AAA 65 20 77 61 
0261   0AAE 74 65 72 20 
0261   0AB2 72 65 61 63 
0261   0AB6 68 65 73 20 
0261   0ABA 75 70 20 74 
0261   0ABE 6F 20 79 6F 
0261   0AC2 75 72 20 6B 
0261   0AC6 6E 65 65 73 
0261   0ACA 2E 0A 
0262   0ACC 54 68 65 20 	.db "The ground feels like quick sand and it is difficult to move around.", 0
0262   0AD0 67 72 6F 75 
0262   0AD4 6E 64 20 66 
0262   0AD8 65 65 6C 73 
0262   0ADC 20 6C 69 6B 
0262   0AE0 65 20 71 75 
0262   0AE4 69 63 6B 20 
0262   0AE8 73 61 6E 64 
0262   0AEC 20 61 6E 64 
0262   0AF0 20 69 74 20 
0262   0AF4 69 73 20 64 
0262   0AF8 69 66 66 69 
0262   0AFC 63 75 6C 74 
0262   0B00 20 74 6F 20 
0262   0B04 6D 6F 76 65 
0262   0B08 20 61 72 6F 
0262   0B0C 75 6E 64 2E 
0262   0B10 00 
0263   0B11             
0264   0B11             s_adv_restart:
0265   0B11 52 65 73 74 	.db "Restart? ", 0
0265   0B15 61 72 74 3F 
0265   0B19 20 00 
0266   0B1B             	
0267   0B1B             s_unknown_command:
0268   0B1B 49 20 64 6F 	.db "I do not understand that word.\n", 0
0268   0B1F 20 6E 6F 74 
0268   0B23 20 75 6E 64 
0268   0B27 65 72 73 74 
0268   0B2B 61 6E 64 20 
0268   0B2F 74 68 61 74 
0268   0B33 20 77 6F 72 
0268   0B37 64 2E 0A 00 
0269   0B3B             	
0270   0B3B             s_adv_exam:
0271   0B3B 54 68 65 72 	.db "There is nothing here.\n", 0
0271   0B3F 65 20 69 73 
0271   0B43 20 6E 6F 74 
0271   0B47 68 69 6E 67 
0271   0B4B 20 68 65 72 
0271   0B4F 65 2E 0A 00 
0272   0B53             	
0273   0B53             s_items_here:
0274   0B53 49 74 65 6D 	.db "Items found at this location...\n", 0
0274   0B57 73 20 66 6F 
0274   0B5B 75 6E 64 20 
0274   0B5F 61 74 20 74 
0274   0B63 68 69 73 20 
0274   0B67 6C 6F 63 61 
0274   0B6B 74 69 6F 6E 
0274   0B6F 2E 2E 2E 0A 
0274   0B73 00 
0275   0B74             
0276   0B74             p_itemlist:
0277   0B74             
0278   0B74             
0279   0B74             .include "stdio.asm"
0001+  0B74             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0B74             ; stdio.s
0003+  0B74             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0B74             .include "string.asm"
0001++ 0B74             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0B74             ; string.s
0003++ 0B74             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0B74             
0005++ 0B74             
0006++ 0B74             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0B74             ; strrev
0008++ 0B74             ; reverse a string
0009++ 0B74             ; D = string address
0010++ 0B74             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0B74             ; 01234
0012++ 0B74             strrev:
0013++ 0B74 4B          	pusha
0014++ 0B75 07 BB 0B    	call strlen	; length in C
0015++ 0B78 12          	mov a, c
0016++ 0B79 AF 01 00    	cmp a, 1
0017++ 0B7C D0 96 0B    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0B7F 7D          	dec a
0019++ 0B80 FD 4E       	mov si, d	; beginning of string
0020++ 0B82 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0B84 59          	add d, a	; end of string
0022++ 0B85 12          	mov a, c
0023++ 0B86 FD 9B       	shr a		; divide by 2
0024++ 0B88 39          	mov c, a	; C now counts the steps
0025++ 0B89             strrev_L0:
0026++ 0B89 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0B8A F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0B8B 3E          	mov [d], al	; store left char into right side
0029++ 0B8C 1B          	mov al, bl
0030++ 0B8D F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0B8E 7E          	dec c
0032++ 0B8F 7F          	dec d
0033++ 0B90 C2 00 00    	cmp c, 0
0034++ 0B93 C7 89 0B    	jne strrev_L0
0035++ 0B96             strrev_end:
0036++ 0B96 4C          	popa
0037++ 0B97 09          	ret
0038++ 0B98             	
0039++ 0B98             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0B98             ; strchr
0041++ 0B98             ; search string in D for char in AL
0042++ 0B98             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0B98             strchr:
0044++ 0B98             strchr_L0:
0045++ 0B98 32          	mov bl, [d]
0046++ 0B99 C1 00       	cmp bl, 0
0047++ 0B9B C6 A6 0B    	je strchr_end
0048++ 0B9E BA          	cmp al, bl
0049++ 0B9F C6 A6 0B    	je strchr_end
0050++ 0BA2 79          	inc d
0051++ 0BA3 0A 98 0B    	jmp strchr_L0
0052++ 0BA6             strchr_end:
0053++ 0BA6 1B          	mov al, bl
0054++ 0BA7 09          	ret
0055++ 0BA8             
0056++ 0BA8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0BA8             ; strstr
0058++ 0BA8             ; find sub-string
0059++ 0BA8             ; str1 in SI
0060++ 0BA8             ; str2 in DI
0061++ 0BA8             ; SI points to end of source string
0062++ 0BA8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0BA8             strstr:
0064++ 0BA8 DB          	push al
0065++ 0BA9 DA          	push d
0066++ 0BAA E3          	push di
0067++ 0BAB             strstr_loop:
0068++ 0BAB F3          	cmpsb					; compare a byte of the strings
0069++ 0BAC C7 B7 0B    	jne strstr_ret
0070++ 0BAF FC 00 00    	lea d, [di + 0]
0071++ 0BB2 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0BB4 C7 AB 0B    	jne strstr_loop				; equal chars but not at end
0073++ 0BB7             strstr_ret:
0074++ 0BB7 F0          	pop di
0075++ 0BB8 E7          	pop d
0076++ 0BB9 E8          	pop al
0077++ 0BBA 09          	ret
0078++ 0BBB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0BBB             ; length of null terminated string
0080++ 0BBB             ; result in C
0081++ 0BBB             ; pointer in D
0082++ 0BBB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0BBB             strlen:
0084++ 0BBB DA          	push d
0085++ 0BBC 38 00 00    	mov c, 0
0086++ 0BBF             strlen_L1:
0087++ 0BBF BD 00       	cmp byte [d], 0
0088++ 0BC1 C6 C9 0B    	je strlen_ret
0089++ 0BC4 79          	inc d
0090++ 0BC5 78          	inc c
0091++ 0BC6 0A BF 0B    	jmp strlen_L1
0092++ 0BC9             strlen_ret:
0093++ 0BC9 E7          	pop d
0094++ 0BCA 09          	ret
0095++ 0BCB             
0096++ 0BCB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0BCB             ; STRCMP
0098++ 0BCB             ; compare two strings
0099++ 0BCB             ; str1 in SI
0100++ 0BCB             ; str2 in DI
0101++ 0BCB             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0BCB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0BCB             strcmp:
0104++ 0BCB DB          	push al
0105++ 0BCC DA          	push d
0106++ 0BCD E3          	push di
0107++ 0BCE E2          	push si
0108++ 0BCF             strcmp_loop:
0109++ 0BCF F3          	cmpsb					; compare a byte of the strings
0110++ 0BD0 C7 DB 0B    	jne strcmp_ret
0111++ 0BD3 FB FF FF    	lea d, [si +- 1]
0112++ 0BD6 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0BD8 C7 CF 0B    	jne strcmp_loop				; equal chars but not at end
0114++ 0BDB             strcmp_ret:
0115++ 0BDB EF          	pop si
0116++ 0BDC F0          	pop di
0117++ 0BDD E7          	pop d
0118++ 0BDE E8          	pop al
0119++ 0BDF 09          	ret
0120++ 0BE0             
0121++ 0BE0             
0122++ 0BE0             ; STRCPY
0123++ 0BE0             ; copy null terminated string from SI to DI
0124++ 0BE0             ; source in SI
0125++ 0BE0             ; destination in DI
0126++ 0BE0             strcpy:
0127++ 0BE0 E2          	push si
0128++ 0BE1 E3          	push di
0129++ 0BE2 DB          	push al
0130++ 0BE3             strcpy_L1:
0131++ 0BE3 F6          	lodsb
0132++ 0BE4 F7          	stosb
0133++ 0BE5 B9 00       	cmp al, 0
0134++ 0BE7 C7 E3 0B    	jne strcpy_L1
0135++ 0BEA             strcpy_end:
0136++ 0BEA E8          	pop al
0137++ 0BEB F0          	pop di
0138++ 0BEC EF          	pop si
0139++ 0BED 09          	ret
0140++ 0BEE             
0141++ 0BEE             ; STRCAT
0142++ 0BEE             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0BEE             ; source in SI
0144++ 0BEE             ; destination in DI
0145++ 0BEE             strcat:
0146++ 0BEE E2          	push si
0147++ 0BEF E3          	push di
0148++ 0BF0 D7          	push a
0149++ 0BF1 DA          	push d
0150++ 0BF2 50          	mov a, di
0151++ 0BF3 3C          	mov d, a
0152++ 0BF4             strcat_goto_end_L1:
0153++ 0BF4 BD 00       	cmp byte[d], 0
0154++ 0BF6 C6 FD 0B    	je strcat_start
0155++ 0BF9 79          	inc d
0156++ 0BFA 0A F4 0B    	jmp strcat_goto_end_L1
0157++ 0BFD             strcat_start:
0158++ 0BFD FD 50       	mov di, d
0159++ 0BFF             strcat_L1:
0160++ 0BFF F6          	lodsb
0161++ 0C00 F7          	stosb
0162++ 0C01 B9 00       	cmp al, 0
0163++ 0C03 C7 FF 0B    	jne strcat_L1
0164++ 0C06             strcat_end:
0165++ 0C06 E7          	pop d
0166++ 0C07 E4          	pop a
0167++ 0C08 F0          	pop di
0168++ 0C09 EF          	pop si
0169++ 0C0A 09          	ret
0005+  0C0B             
0006+  0C0B 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  0C0F 34 35 36 37 
0006+  0C13 38 39 41 42 
0006+  0C17 43 44 45 46 
0007+  0C1B 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  0C1F 1B 5B 48 00 
0008+  0C23             
0009+  0C23 01 00       table_power:.dw 1
0010+  0C25 0A 00       			.dw 10
0011+  0C27 64 00       			.dw 100
0012+  0C29 E8 03       			.dw 1000
0013+  0C2B 10 27       			.dw 10000
0014+  0C2D             
0015+  0C2D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  0C2D             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  0C2D             ; ASCII in BL
0018+  0C2D             ; result in AL
0019+  0C2D             ; ascii for F = 0100 0110
0020+  0C2D             ; ascii for 9 = 0011 1001
0021+  0C2D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  0C2D             hex_ascii_encode:
0023+  0C2D 1B          	mov al, bl
0024+  0C2E 93 40       	test al, $40				; test if letter or number
0025+  0C30 C7 36 0C    	jnz hex_letter
0026+  0C33 87 0F       	and al, $0F				; get number
0027+  0C35 09          	ret
0028+  0C36             hex_letter:
0029+  0C36 87 0F       	and al, $0F				; get letter
0030+  0C38 6A 09       	add al, 9
0031+  0C3A 09          	ret
0032+  0C3B             
0033+  0C3B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  0C3B             ; ATOI
0035+  0C3B             ; 2 letter hex string in B
0036+  0C3B             ; 8bit integer returned in AL
0037+  0C3B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0C3B             atoi:
0039+  0C3B D8          	push b
0040+  0C3C 07 2D 0C    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  0C3F 30          	mov bl, bh
0042+  0C40 DB          	push al					; save a
0043+  0C41 07 2D 0C    	call hex_ascii_encode
0044+  0C44 EA          	pop bl	
0045+  0C45 FD 9E 04    	shl al, 4
0046+  0C48 8C          	or al, bl
0047+  0C49 E5          	pop b
0048+  0C4A 09          	ret	
0049+  0C4B             
0050+  0C4B             
0051+  0C4B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  0C4B             ; printf
0053+  0C4B             ; no need for explanations!
0054+  0C4B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0C4B             printf:
0056+  0C4B 09          	ret
0057+  0C4C             
0058+  0C4C             
0059+  0C4C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  0C4C             ; scanf
0061+  0C4C             ; no need for explanations!
0062+  0C4C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  0C4C             scanf:
0064+  0C4C 09          	ret
0065+  0C4D             
0066+  0C4D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  0C4D             ; ITOA
0068+  0C4D             ; 8bit value in BL
0069+  0C4D             ; 2 byte ASCII result in A
0070+  0C4D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  0C4D             itoa:
0072+  0C4D DA          	push d
0073+  0C4E D8          	push b
0074+  0C4F A7 00       	mov bh, 0
0075+  0C51 FD A4 04    	shr bl, 4	
0076+  0C54 74          	mov d, b
0077+  0C55 1F 0B 0C    	mov al, [d + s_hex_digits]
0078+  0C58 23          	mov ah, al
0079+  0C59             	
0080+  0C59 E5          	pop b
0081+  0C5A D8          	push b
0082+  0C5B A7 00       	mov bh, 0
0083+  0C5D FD 87 0F    	and bl, $0F
0084+  0C60 74          	mov d, b
0085+  0C61 1F 0B 0C    	mov al, [d + s_hex_digits]
0086+  0C64 E5          	pop b
0087+  0C65 E7          	pop d
0088+  0C66 09          	ret
0089+  0C67             
0090+  0C67             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  0C67             ; HEX STRING TO BINARY
0092+  0C67             ; di = destination address
0093+  0C67             ; si = source
0094+  0C67             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  0C67             hex_to_int:
0096+  0C67             hex_to_int_L1:
0097+  0C67 F6          	lodsb					; load from [SI] to AL
0098+  0C68 B9 00       	cmp al, 0				; check if ASCII 0
0099+  0C6A C6 77 0C    	jz hex_to_int_ret
0100+  0C6D 36          	mov bh, al
0101+  0C6E F6          	lodsb
0102+  0C6F 2F          	mov bl, al
0103+  0C70 07 3B 0C    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  0C73 F7          	stosb					; store AL to [DI]
0105+  0C74 0A 67 0C    	jmp hex_to_int_L1
0106+  0C77             hex_to_int_ret:
0107+  0C77 09          	ret		
0108+  0C78             
0109+  0C78             
0110+  0C78             
0111+  0C78             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  0C78             ; GETCHAR
0113+  0C78             ; char in ah
0114+  0C78             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  0C78             getchar:
0116+  0C78 DB          	push al
0117+  0C79             getchar_retry:
0118+  0C79 FD 0C       	sti
0119+  0C7B 19 01       	mov al, 1
0120+  0C7D 05 03       	syscall sys_io			; receive in AH
0121+  0C7F B9 00       	cmp al, 0			; check if any char was receive
0122+  0C81 C6 79 0C    	je getchar_retry
0123+  0C84 E8          	pop al
0124+  0C85 09          	ret
0125+  0C86             
0126+  0C86             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  0C86             ; PUTCHAR
0128+  0C86             ; char in ah
0129+  0C86             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0C86             putchar:
0131+  0C86 D7          	push a
0132+  0C87 19 00       	mov al, 0
0133+  0C89 05 03       	syscall sys_io			; char in AH
0134+  0C8B E4          	pop a
0135+  0C8C 09          	ret
0136+  0C8D             
0137+  0C8D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  0C8D             ;; INPUT A STRING
0139+  0C8D             ;; terminates with null
0140+  0C8D             ;; pointer in D
0141+  0C8D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  0C8D             gets:
0143+  0C8D D7          	push a
0144+  0C8E DA          	push d
0145+  0C8F             gets_loop:
0146+  0C8F FD 0C       	sti
0147+  0C91 19 01       	mov al, 1
0148+  0C93 05 03       	syscall sys_io			; receive in AH
0149+  0C95 B9 00       	cmp al, 0				; check error code (AL)
0150+  0C97 C6 8F 0C    	je gets_loop			; if no char received, retry
0151+  0C9A             
0152+  0C9A 76 1B       	cmp ah, 27
0153+  0C9C C6 BD 0C    	je gets_telnet_escape
0154+  0C9F 76 0A       	cmp ah, $0A				; LF
0155+  0CA1 C6 16 0D    	je gets_end
0156+  0CA4 76 0D       	cmp ah, $0D				; CR
0157+  0CA6 C6 16 0D    	je gets_end
0158+  0CA9 76 5C       	cmp ah, $5C				; '\\'
0159+  0CAB C6 ED 0C    	je gets_escape
0160+  0CAE             	
0161+  0CAE 76 08       	cmp ah, $08			; check for backspace
0162+  0CB0 C6 B9 0C    	je gets_backspace
0163+  0CB3             
0164+  0CB3 1A          	mov al, ah
0165+  0CB4 3E          	mov [d], al
0166+  0CB5 79          	inc d
0167+  0CB6 0A 8F 0C    	jmp gets_loop
0168+  0CB9             gets_backspace:
0169+  0CB9 7F          	dec d
0170+  0CBA 0A 8F 0C    	jmp gets_loop
0171+  0CBD             gets_telnet_escape:
0172+  0CBD FD 0C       	sti
0173+  0CBF 19 01       	mov al, 1
0174+  0CC1 05 03       	syscall sys_io				; receive in AH without echo
0175+  0CC3 B9 00       	cmp al, 0					; check error code (AL)
0176+  0CC5 C6 BD 0C    	je gets_telnet_escape		; if no char received, retry
0177+  0CC8 76 5B       	cmp ah, '['
0178+  0CCA C7 8F 0C    	jne gets_loop
0179+  0CCD             gets_telnet_escape_phase2:
0180+  0CCD FD 0C       	sti
0181+  0CCF 19 01       	mov al, 1
0182+  0CD1 05 03       	syscall sys_io					; receive in AH without echo
0183+  0CD3 B9 00       	cmp al, 0						; check error code (AL)
0184+  0CD5 C6 CD 0C    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  0CD8 76 44       	cmp ah, 'D'
0186+  0CDA C6 E5 0C    	je gets_left_arrow
0187+  0CDD 76 43       	cmp ah, 'C'
0188+  0CDF C6 E9 0C    	je gets_right_arrow
0189+  0CE2 0A 8F 0C    	jmp gets_loop
0190+  0CE5             gets_left_arrow:
0191+  0CE5 7F          	dec d
0192+  0CE6 0A 8F 0C    	jmp gets_loop
0193+  0CE9             gets_right_arrow:
0194+  0CE9 79          	inc d
0195+  0CEA 0A 8F 0C    	jmp gets_loop
0196+  0CED             gets_escape:
0197+  0CED FD 0C       	sti
0198+  0CEF 19 01       	mov al, 1
0199+  0CF1 05 03       	syscall sys_io			; receive in AH
0200+  0CF3 B9 00       	cmp al, 0				; check error code (AL)
0201+  0CF5 C6 ED 0C    	je gets_escape			; if no char received, retry
0202+  0CF8 76 6E       	cmp ah, 'n'
0203+  0CFA C6 08 0D    	je gets_LF
0204+  0CFD 76 72       	cmp ah, 'r'
0205+  0CFF C6 0F 0D    	je gets_CR
0206+  0D02 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  0D03 3E          	mov [d], al
0208+  0D04 79          	inc d
0209+  0D05 0A 8F 0C    	jmp gets_loop
0210+  0D08             gets_LF:
0211+  0D08 19 0A       	mov al, $0A
0212+  0D0A 3E          	mov [d], al
0213+  0D0B 79          	inc d
0214+  0D0C 0A 8F 0C    	jmp gets_loop
0215+  0D0F             gets_CR:
0216+  0D0F 19 0D       	mov al, $0D
0217+  0D11 3E          	mov [d], al
0218+  0D12 79          	inc d
0219+  0D13 0A 8F 0C    	jmp gets_loop
0220+  0D16             gets_end:
0221+  0D16 19 00       	mov al, 0
0222+  0D18 3E          	mov [d], al				; terminate string
0223+  0D19 E7          	pop d
0224+  0D1A E4          	pop a
0225+  0D1B 09          	ret
0226+  0D1C             
0227+  0D1C             
0228+  0D1C             
0229+  0D1C             
0230+  0D1C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  0D1C             ;; INPUT TEXT
0232+  0D1C             ;; terminated with CTRL+D
0233+  0D1C             ;; pointer in D
0234+  0D1C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  0D1C             gettxt:
0236+  0D1C D7          	push a
0237+  0D1D DA          	push d
0238+  0D1E             gettxt_loop:
0239+  0D1E 19 01       	mov al, 1
0240+  0D20 05 03       	syscall sys_io			; receive in AH
0241+  0D22 B9 00       	cmp al, 0				; check error code (AL)
0242+  0D24 C6 1E 0D    	je gettxt_loop		; if no char received, retry
0243+  0D27 76 04       	cmp ah, 4			; EOT
0244+  0D29 C6 67 0D    	je gettxt_end
0245+  0D2C 76 08       	cmp ah, $08			; check for backspace
0246+  0D2E C6 63 0D    	je gettxt_backspace
0247+  0D31 76 5C       	cmp ah, $5C				; '\\'
0248+  0D33 C6 3C 0D    	je gettxt_escape
0249+  0D36 1A          	mov al, ah
0250+  0D37 3E          	mov [d], al
0251+  0D38 79          	inc d
0252+  0D39 0A 1E 0D    	jmp gettxt_loop
0253+  0D3C             gettxt_escape:
0254+  0D3C 19 01       	mov al, 1
0255+  0D3E 05 03       	syscall sys_io			; receive in AH
0256+  0D40 B9 00       	cmp al, 0				; check error code (AL)
0257+  0D42 C6 3C 0D    	je gettxt_escape		; if no char received, retry
0258+  0D45 76 6E       	cmp ah, 'n'
0259+  0D47 C6 55 0D    	je gettxt_LF
0260+  0D4A 76 72       	cmp ah, 'r'
0261+  0D4C C6 5C 0D    	je gettxt_CR
0262+  0D4F 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  0D50 3E          	mov [d], al
0264+  0D51 79          	inc d
0265+  0D52 0A 1E 0D    	jmp gettxt_loop
0266+  0D55             gettxt_LF:
0267+  0D55 19 0A       	mov al, $0A
0268+  0D57 3E          	mov [d], al
0269+  0D58 79          	inc d
0270+  0D59 0A 1E 0D    	jmp gettxt_loop
0271+  0D5C             gettxt_CR:
0272+  0D5C 19 0D       	mov al, $0D
0273+  0D5E 3E          	mov [d], al
0274+  0D5F 79          	inc d
0275+  0D60 0A 1E 0D    	jmp gettxt_loop
0276+  0D63             gettxt_backspace:
0277+  0D63 7F          	dec d
0278+  0D64 0A 1E 0D    	jmp gettxt_loop
0279+  0D67             gettxt_end:
0280+  0D67 19 00       	mov al, 0
0281+  0D69 3E          	mov [d], al				; terminate string
0282+  0D6A E7          	pop d
0283+  0D6B E4          	pop a
0284+  0D6C 09          	ret
0285+  0D6D             
0286+  0D6D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  0D6D             ; PRINT NEW LINE
0288+  0D6D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  0D6D             printnl:
0290+  0D6D D7          	push a
0291+  0D6E 10 00 0A    	mov a, $0A00
0292+  0D71 05 03       	syscall sys_io
0293+  0D73 10 00 0D    	mov a, $0D00
0294+  0D76 05 03       	syscall sys_io
0295+  0D78 E4          	pop a
0296+  0D79 09          	ret
0297+  0D7A             
0298+  0D7A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  0D7A             ; strtoint
0300+  0D7A             ; 4 digit hex string number in d
0301+  0D7A             ; integer returned in A
0302+  0D7A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  0D7A             strtointx:
0304+  0D7A D8          	push b
0305+  0D7B 32          	mov bl, [d]
0306+  0D7C 37          	mov bh, bl
0307+  0D7D 33 01 00    	mov bl, [d + 1]
0308+  0D80 07 3B 0C    	call atoi				; convert to int in AL
0309+  0D83 23          	mov ah, al				; move to AH
0310+  0D84 33 02 00    	mov bl, [d + 2]
0311+  0D87 37          	mov bh, bl
0312+  0D88 33 03 00    	mov bl, [d + 3]
0313+  0D8B 07 3B 0C    	call atoi				; convert to int in AL
0314+  0D8E E5          	pop b
0315+  0D8F 09          	ret
0316+  0D90             
0317+  0D90             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  0D90             ; strtoint
0319+  0D90             ; 5 digit base10 string number in d
0320+  0D90             ; integer returned in A
0321+  0D90             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  0D90             strtoint:
0323+  0D90 E2          	push si
0324+  0D91 D8          	push b
0325+  0D92 D9          	push c
0326+  0D93 DA          	push d
0327+  0D94 07 BB 0B    	call strlen			; get string length in C
0328+  0D97 7E          	dec c
0329+  0D98 FD 4E       	mov si, d
0330+  0D9A 12          	mov a, c
0331+  0D9B FD 99       	shl a
0332+  0D9D 3B 23 0C    	mov d, table_power
0333+  0DA0 59          	add d, a
0334+  0DA1 38 00 00    	mov c, 0
0335+  0DA4             strtoint_L0:
0336+  0DA4 F6          	lodsb			; load ASCII to al
0337+  0DA5 B9 00       	cmp al, 0
0338+  0DA7 C6 BA 0D    	je strtoint_end
0339+  0DAA 6F 30       	sub al, $30		; make into integer
0340+  0DAC 22 00       	mov ah, 0
0341+  0DAE 2A          	mov b, [d]
0342+  0DAF AC          	mul a, b			; result in B since it fits in 16bits
0343+  0DB0 11          	mov a, b
0344+  0DB1 28          	mov b, c
0345+  0DB2 54          	add a, b
0346+  0DB3 39          	mov c, a
0347+  0DB4 63 02 00    	sub d, 2
0348+  0DB7 0A A4 0D    	jmp strtoint_L0
0349+  0DBA             strtoint_end:
0350+  0DBA 12          	mov a, c
0351+  0DBB E7          	pop d
0352+  0DBC E6          	pop c
0353+  0DBD E5          	pop b
0354+  0DBE EF          	pop si
0355+  0DBF 09          	ret
0356+  0DC0             
0357+  0DC0             
0358+  0DC0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  0DC0             ; PRINT NULL TERMINATED STRING
0360+  0DC0             ; pointer in D
0361+  0DC0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  0DC0             puts:
0363+  0DC0 D7          	push a
0364+  0DC1 DA          	push d
0365+  0DC2             puts_L1:
0366+  0DC2 1E          	mov al, [d]
0367+  0DC3 B9 00       	cmp al, 0
0368+  0DC5 C6 D1 0D    	jz puts_END
0369+  0DC8 23          	mov ah, al
0370+  0DC9 19 00       	mov al, 0
0371+  0DCB 05 03       	syscall sys_io
0372+  0DCD 79          	inc d
0373+  0DCE 0A C2 0D    	jmp puts_L1
0374+  0DD1             puts_END:
0375+  0DD1 E7          	pop d
0376+  0DD2 E4          	pop a
0377+  0DD3 09          	ret
0378+  0DD4             
0379+  0DD4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  0DD4             ; PRINT N SIZE STRING
0381+  0DD4             ; pointer in D
0382+  0DD4             ; size in C
0383+  0DD4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  0DD4             putsn:
0385+  0DD4 DB          	push al
0386+  0DD5 DA          	push d
0387+  0DD6 D9          	push c
0388+  0DD7             putsn_L0:
0389+  0DD7 1E          	mov al, [d]
0390+  0DD8 23          	mov ah, al
0391+  0DD9 19 00       	mov al, 0
0392+  0DDB 05 03       	syscall sys_io
0393+  0DDD 79          	inc d
0394+  0DDE 7E          	dec c	
0395+  0DDF C2 00 00    	cmp c, 0
0396+  0DE2 C7 D7 0D    	jne putsn_L0
0397+  0DE5             putsn_end:
0398+  0DE5 E6          	pop c
0399+  0DE6 E7          	pop d
0400+  0DE7 E8          	pop al
0401+  0DE8 09          	ret
0402+  0DE9             
0403+  0DE9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  0DE9             ; print 16bit decimal number
0405+  0DE9             ; input number in A
0406+  0DE9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  0DE9             print_u16d:
0408+  0DE9 D7          	push a
0409+  0DEA D8          	push b
0410+  0DEB 26 10 27    	mov b, 10000
0411+  0DEE AE          	div a, b			; get 10000 coeff.
0412+  0DEF 07 15 0E    	call print_number
0413+  0DF2 11          	mov a, b
0414+  0DF3 26 E8 03    	mov b, 1000
0415+  0DF6 AE          	div a, b			; get 10000 coeff.
0416+  0DF7 07 15 0E    	call print_number
0417+  0DFA 11          	mov a, b
0418+  0DFB 26 64 00    	mov b, 100
0419+  0DFE AE          	div a, b
0420+  0DFF 07 15 0E    	call print_number
0421+  0E02 11          	mov a, b
0422+  0E03 26 0A 00    	mov b, 10
0423+  0E06 AE          	div a, b
0424+  0E07 07 15 0E    	call print_number
0425+  0E0A 11          	mov a, b
0426+  0E0B 6A 30       	add al, $30
0427+  0E0D 23          	mov ah, al
0428+  0E0E 19 00       	mov al, 0
0429+  0E10 05 03       	syscall sys_io	; print coeff
0430+  0E12 E5          	pop b
0431+  0E13 E4          	pop a
0432+  0E14 09          	ret
0433+  0E15             
0434+  0E15             
0435+  0E15             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  0E15             ; if A == 0, print space
0437+  0E15             ; else print A
0438+  0E15             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0439+  0E15             print_number:
0440+  0E15 6A 30       	add al, $30
0441+  0E17 23          	mov ah, al
0442+  0E18 07 86 0C    	call putchar
0443+  0E1B 09          	ret
0444+  0E1C             
0445+  0E1C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0446+  0E1C             ; PRINT 16BIT HEX INTEGER
0447+  0E1C             ; integer value in reg B
0448+  0E1C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  0E1C             print_u16x:
0450+  0E1C D7          	push a
0451+  0E1D D8          	push b
0452+  0E1E DD          	push bl
0453+  0E1F 30          	mov bl, bh
0454+  0E20 07 4D 0C    	call itoa				; convert bh to char in A
0455+  0E23 2F          	mov bl, al				; save al
0456+  0E24 19 00       	mov al, 0
0457+  0E26 05 03       	syscall sys_io				; display AH
0458+  0E28 24          	mov ah, bl				; retrieve al
0459+  0E29 19 00       	mov al, 0
0460+  0E2B 05 03       	syscall sys_io				; display AL
0461+  0E2D             
0462+  0E2D EA          	pop bl
0463+  0E2E 07 4D 0C    	call itoa				; convert bh to char in A
0464+  0E31 2F          	mov bl, al				; save al
0465+  0E32 19 00       	mov al, 0
0466+  0E34 05 03       	syscall sys_io				; display AH
0467+  0E36 24          	mov ah, bl				; retrieve al
0468+  0E37 19 00       	mov al, 0
0469+  0E39 05 03       	syscall sys_io				; display AL
0470+  0E3B             
0471+  0E3B E5          	pop b
0472+  0E3C E4          	pop a
0473+  0E3D 09          	ret
0474+  0E3E             
0475+  0E3E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  0E3E             ; INPUT 16BIT HEX INTEGER
0477+  0E3E             ; read 16bit integer into A
0478+  0E3E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  0E3E             scan_u16x:
0480+  0E3E F8 10 00    	enter 16
0481+  0E41 D8          	push b
0482+  0E42 DA          	push d
0483+  0E43             
0484+  0E43 FA F1 FF    	lea d, [bp + -15]
0485+  0E46 07 8D 0C    	call gets				; get number
0486+  0E49             
0487+  0E49 32          	mov bl, [d]
0488+  0E4A 37          	mov bh, bl
0489+  0E4B 33 01 00    	mov bl, [d + 1]
0490+  0E4E 07 3B 0C    	call atoi				; convert to int in AL
0491+  0E51 23          	mov ah, al				; move to AH
0492+  0E52             
0493+  0E52 33 02 00    	mov bl, [d + 2]
0494+  0E55 37          	mov bh, bl
0495+  0E56 33 03 00    	mov bl, [d + 3]
0496+  0E59 07 3B 0C    	call atoi				; convert to int in AL
0497+  0E5C             
0498+  0E5C E7          	pop d
0499+  0E5D E5          	pop b
0500+  0E5E F9          	leave
0501+  0E5F 09          	ret
0502+  0E60             
0503+  0E60             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0504+  0E60             ; PRINT 8bit HEX INTEGER
0505+  0E60             ; integer value in reg bl
0506+  0E60             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  0E60             print_u8x:
0508+  0E60 D7          	push a
0509+  0E61 DD          	push bl
0510+  0E62             
0511+  0E62 07 4D 0C    	call itoa				; convert bl to char in A
0512+  0E65 2F          	mov bl, al				; save al
0513+  0E66 19 00       	mov al, 0
0514+  0E68 05 03       	syscall sys_io				; display AH
0515+  0E6A 24          	mov ah, bl				; retrieve al
0516+  0E6B 19 00       	mov al, 0
0517+  0E6D 05 03       	syscall sys_io				; display AL
0518+  0E6F             
0519+  0E6F EA          	pop bl
0520+  0E70 E4          	pop a
0521+  0E71 09          	ret
0522+  0E72             
0523+  0E72             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0524+  0E72             ; print 8bit decimal unsigned number
0525+  0E72             ; input number in AL
0526+  0E72             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  0E72             print_u8d:
0528+  0E72 D7          	push a
0529+  0E73 D8          	push b
0530+  0E74             
0531+  0E74 22 00       	mov ah, 0
0532+  0E76 26 64 00    	mov b, 100
0533+  0E79 AE          	div a, b
0534+  0E7A D8          	push b			; save remainder
0535+  0E7B B9 00       	cmp al, 0
0536+  0E7D C6 87 0E    	je skip100
0537+  0E80 6A 30       	add al, $30
0538+  0E82 23          	mov ah, al
0539+  0E83 19 00       	mov al, 0
0540+  0E85 05 03       	syscall sys_io	; print coeff
0541+  0E87             skip100:
0542+  0E87 E4          	pop a
0543+  0E88 22 00       	mov ah, 0
0544+  0E8A 26 0A 00    	mov b, 10
0545+  0E8D AE          	div a, b
0546+  0E8E D8          	push b			; save remainder
0547+  0E8F B9 00       	cmp al, 0
0548+  0E91 C6 9B 0E    	je skip10
0549+  0E94 6A 30       	add al, $30
0550+  0E96 23          	mov ah, al
0551+  0E97 19 00       	mov al, 0
0552+  0E99 05 03       	syscall sys_io	; print coeff
0553+  0E9B             skip10:
0554+  0E9B E4          	pop a
0555+  0E9C 1B          	mov al, bl
0556+  0E9D 6A 30       	add al, $30
0557+  0E9F 23          	mov ah, al
0558+  0EA0 19 00       	mov al, 0
0559+  0EA2 05 03       	syscall sys_io	; print coeff
0560+  0EA4 E5          	pop b
0561+  0EA5 E4          	pop a
0562+  0EA6 09          	ret
0563+  0EA7             
0564+  0EA7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0565+  0EA7             ; INPUT 8BIT HEX INTEGER
0566+  0EA7             ; read 8bit integer into AL
0567+  0EA7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  0EA7             scan_u8x:
0569+  0EA7 F8 04 00    	enter 4
0570+  0EAA D8          	push b
0571+  0EAB DA          	push d
0572+  0EAC             
0573+  0EAC FA FD FF    	lea d, [bp + -3]
0574+  0EAF 07 8D 0C    	call gets				; get number
0575+  0EB2             
0576+  0EB2 32          	mov bl, [d]
0577+  0EB3 37          	mov bh, bl
0578+  0EB4 33 01 00    	mov bl, [d + 1]
0579+  0EB7 07 3B 0C    	call atoi				; convert to int in AL
0580+  0EBA             
0581+  0EBA E7          	pop d
0582+  0EBB E5          	pop b
0583+  0EBC F9          	leave
0584+  0EBD 09          	ret
0585+  0EBE             
0586+  0EBE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  0EBE             ; input decimal number
0588+  0EBE             ; result in A
0589+  0EBE             ; 655'\0'
0590+  0EBE             ; low--------high
0591+  0EBE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0592+  0EBE             scan_u16d:
0593+  0EBE F8 08 00    	enter 8
0594+  0EC1 E2          	push si
0595+  0EC2 D8          	push b
0596+  0EC3 D9          	push c
0597+  0EC4 DA          	push d
0598+  0EC5 FA F9 FF    	lea d, [bp +- 7]
0599+  0EC8 07 8D 0C    	call gets
0600+  0ECB 07 BB 0B    	call strlen			; get string length in C
0601+  0ECE 7E          	dec c
0602+  0ECF FD 4E       	mov si, d
0603+  0ED1 12          	mov a, c
0604+  0ED2 FD 99       	shl a
0605+  0ED4 3B 23 0C    	mov d, table_power
0606+  0ED7 59          	add d, a
0607+  0ED8 38 00 00    	mov c, 0
0608+  0EDB             mul_loop:
0609+  0EDB F6          	lodsb			; load ASCII to al
0610+  0EDC B9 00       	cmp al, 0
0611+  0EDE C6 F1 0E    	je mul_exit
0612+  0EE1 6F 30       	sub al, $30		; make into integer
0613+  0EE3 22 00       	mov ah, 0
0614+  0EE5 2A          	mov b, [d]
0615+  0EE6 AC          	mul a, b			; result in B since it fits in 16bits
0616+  0EE7 11          	mov a, b
0617+  0EE8 28          	mov b, c
0618+  0EE9 54          	add a, b
0619+  0EEA 39          	mov c, a
0620+  0EEB 63 02 00    	sub d, 2
0621+  0EEE 0A DB 0E    	jmp mul_loop
0622+  0EF1             mul_exit:
0623+  0EF1 12          	mov a, c
0624+  0EF2 E7          	pop d
0625+  0EF3 E6          	pop c
0626+  0EF4 E5          	pop b
0627+  0EF5 EF          	pop si
0628+  0EF6 F9          	leave
0629+  0EF7 09          	ret
0280   0EF8             .include "ctype.asm"
0001+  0EF8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0EF8             ; ctype.s
0003+  0EF8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0EF8             
0005+  0EF8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  0EF8             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  0EF8             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  0EF8             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  0EF8             ;; characters are supported.
0010+  0EF8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  0EF8             ;; isalnum 
0012+  0EF8             ;; isalpha 
0013+  0EF8             ;; islower 
0014+  0EF8             ;; isupper 
0015+  0EF8             ;; isdigit 
0016+  0EF8             ;; isxdigit
0017+  0EF8             ;; iscntrl 
0018+  0EF8             ;; isgraph 
0019+  0EF8             ;; isspace 
0020+  0EF8             ;; isblank 
0021+  0EF8             ;; isprint 
0022+  0EF8             ;; ispunct 
0023+  0EF8             ;; tolower 
0024+  0EF8             ;; toupper
0025+  0EF8             
0026+  0EF8             
0027+  0EF8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  0EF8             ;; IS ALPHANUMERIC
0029+  0EF8             ;; sets ZF according with result
0030+  0EF8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  0EF8             isalnum:
0032+  0EF8 07 15 0F    	call isalpha
0033+  0EFB C6 01 0F    	je isalnum_exit
0034+  0EFE 07 02 0F    	call isdigit
0035+  0F01             isalnum_exit:
0036+  0F01 09          	ret	
0037+  0F02             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0F02             ;; IS DIGIT
0039+  0F02             ;; sets ZF according with result
0040+  0F02             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  0F02             isdigit:
0042+  0F02 DB          	push al
0043+  0F03 B9 30       	cmp al, '0'
0044+  0F05 C8 11 0F    	jlu isdigit_false
0045+  0F08 B9 39       	cmp al, '9'
0046+  0F0A D1 11 0F    	jgu isdigit_false
0047+  0F0D 87 00       	and al, 0	; set ZF
0048+  0F0F E8          	pop al
0049+  0F10 09          	ret
0050+  0F11             isdigit_false:
0051+  0F11 8B 01       	or al, 1	; clear ZF
0052+  0F13 E8          	pop al
0053+  0F14 09          	ret	
0054+  0F15             	
0055+  0F15             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  0F15             ;; IS ALPHA
0057+  0F15             ;; sets ZF according with result
0058+  0F15             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  0F15             isalpha:
0060+  0F15 DB          	push al
0061+  0F16 B9 5F       	cmp al, '_'
0062+  0F18 C6 38 0F    	je isalpha_true
0063+  0F1B B9 2E       	cmp al, '.'
0064+  0F1D C6 38 0F    	je isalpha_true
0065+  0F20 B9 41       	cmp al, 'A'
0066+  0F22 C8 34 0F    	jlu isalpha_false
0067+  0F25 B9 7A       	cmp al, 'z'
0068+  0F27 D1 34 0F    	jgu isalpha_false
0069+  0F2A B9 5A       	cmp al, 'Z'
0070+  0F2C D0 38 0F    	jleu isalpha_true
0071+  0F2F B9 61       	cmp al, 'a'
0072+  0F31 C9 38 0F    	jgeu isalpha_true
0073+  0F34             isalpha_false:
0074+  0F34 8B 01       	or al, 1	; clear ZF
0075+  0F36 E8          	pop al
0076+  0F37 09          	ret
0077+  0F38             isalpha_true:
0078+  0F38 87 00       	and al, 0	; set ZF
0079+  0F3A E8          	pop al
0080+  0F3B 09          	ret
0081+  0F3C             
0082+  0F3C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  0F3C             ;; IS PATH-ALPHA
0084+  0F3C             ;; sets ZF according with result
0085+  0F3C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  0F3C             ispath:
0087+  0F3C DB          	push al
0088+  0F3D 07 02 0F    	call isdigit
0089+  0F40 C6 6A 0F    	je ispath_true
0090+  0F43 B9 5F       	cmp al, '_'
0091+  0F45 C6 6A 0F    	je ispath_true
0092+  0F48 B9 2F       	cmp al, '/'
0093+  0F4A C6 6A 0F    	je ispath_true
0094+  0F4D B9 2E       	cmp al, '.'
0095+  0F4F C6 6A 0F    	je ispath_true
0096+  0F52 B9 41       	cmp al, 'A'
0097+  0F54 C8 66 0F    	jlu ispath_false
0098+  0F57 B9 7A       	cmp al, 'z'
0099+  0F59 D1 66 0F    	jgu ispath_false
0100+  0F5C B9 5A       	cmp al, 'Z'
0101+  0F5E D0 6A 0F    	jleu ispath_true
0102+  0F61 B9 61       	cmp al, 'a'
0103+  0F63 C9 6A 0F    	jgeu ispath_true
0104+  0F66             ispath_false:
0105+  0F66 8B 01       	or al, 1	; clear ZF
0106+  0F68 E8          	pop al
0107+  0F69 09          	ret
0108+  0F6A             ispath_true:
0109+  0F6A 87 00       	and al, 0	; set ZF
0110+  0F6C E8          	pop al
0111+  0F6D 09          	ret
0112+  0F6E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  0F6E             ;; IS SPACE
0114+  0F6E             ;; sets ZF according with result
0115+  0F6E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  0F6E             isspace:
0117+  0F6E B9 20       	cmp al, $20		; ' '
0118+  0F70 C6 84 0F    	je isspace_exit
0119+  0F73 B9 09       	cmp al, $09		; '\t'
0120+  0F75 C6 84 0F    	je isspace_exit
0121+  0F78 B9 0A       	cmp al, $0A		; '\n'
0122+  0F7A C6 84 0F    	je isspace_exit
0123+  0F7D B9 0D       	cmp al, $0D		; '\r'
0124+  0F7F C6 84 0F    	je isspace_exit
0125+  0F82 B9 0B       	cmp al, $0B		; '\v'
0126+  0F84             isspace_exit:
0127+  0F84 09          	ret	
0128+  0F85             
0129+  0F85             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0F85             ; TO LOWER
0131+  0F85             ; input in AL
0132+  0F85             ; output in AL
0133+  0F85             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  0F85             to_lower:
0135+  0F85 B9 5A       	cmp al, 'Z'
0136+  0F87 D1 8C 0F    	jgu to_lower_ret
0137+  0F8A 6A 20       	add al, $20				; convert to lower case
0138+  0F8C             to_lower_ret:
0139+  0F8C 09          	ret
0140+  0F8D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  0F8D             ; TO UPPER
0142+  0F8D             ; input in AL
0143+  0F8D             ; output in AL
0144+  0F8D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  0F8D             to_upper:
0146+  0F8D B9 61       	cmp al, 'a'
0147+  0F8F C8 94 0F    	jlu to_upper_ret
0148+  0F92 6F 20       	sub al, $20			; convert to upper case
0149+  0F94             to_upper_ret:
0150+  0F94 09          	ret
0151+  0F95             
0281   0F95             .include "token.asm"
0001+  0F95             TOKTYP_IDENTIFIER	.equ 0
0002+  0F95             TOKTYP_KEYWORD		.equ 1
0003+  0F95             TOKTYP_DELIMITER	.equ 2
0004+  0F95             TOKTYP_STRING		.equ 3
0005+  0F95             TOKTYP_CHAR			.equ 4
0006+  0F95             TOKTYP_NUMERIC		.equ 5
0007+  0F95             TOKTYP_END			.equ 6
0008+  0F95             
0009+  0F95             TOK_NULL			.equ 0
0010+  0F95             TOK_FSLASH			.equ 1
0011+  0F95             TOK_TIMES 			.equ 2
0012+  0F95             TOK_PLUS 			.equ 3
0013+  0F95             TOK_MINUS 			.equ 4
0014+  0F95             TOK_DOT				.equ 5
0015+  0F95             TOK_SEMI			.equ 6
0016+  0F95             TOK_ANGLE			.equ 7
0017+  0F95             TOK_TILDE			.equ 8
0018+  0F95             TOK_EQUAL			.equ 9
0019+  0F95             TOK_COLON			.equ 10
0020+  0F95             TOK_COMMA			.equ 11
0021+  0F95             
0022+  0F95             TOK_END				.equ 20
0023+  0F95             
0024+  0F95             
0025+  0F95             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  0F95             ;; read a full command argment from shell input buffer
0027+  0F95             ;; argument is written into tokstr
0028+  0F95             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  0F95             get_arg:
0030+  0F95 D7          	push a
0031+  0F96 E2          	push si
0032+  0F97 E3          	push di
0033+  0F98 19 00       	mov al, 0
0034+  0F9A 3D C3 11    	mov [tokstr], al			; nullify tokstr string
0035+  0F9D 14 BF 11    	mov a, [prog]
0036+  0FA0 4D          	mov si, a
0037+  0FA1 FD 4F C3 11 	mov di, tokstr
0038+  0FA5             get_arg_skip_spaces:
0039+  0FA5 F6          	lodsb
0040+  0FA6 07 6E 0F    	call isspace
0041+  0FA9 C6 A5 0F    	je get_arg_skip_spaces
0042+  0FAC             get_arg_L0:
0043+  0FAC B9 3B       	cmp al, $3B				; check if is ';'
0044+  0FAE C6 BB 0F    	je get_arg_end
0045+  0FB1 B9 00       	cmp al, 0
0046+  0FB3 C6 BB 0F    	je get_arg_end			; check if end of input
0047+  0FB6 F7          	stosb
0048+  0FB7 F6          	lodsb
0049+  0FB8 0A AC 0F    	jmp get_arg_L0
0050+  0FBB             get_arg_end:
0051+  0FBB 19 00       	mov al, 0
0052+  0FBD F7          	stosb
0053+  0FBE D5 01 00    	sub si, 1
0054+  0FC1 4E          	mov a, si
0055+  0FC2 42 BF 11    	mov [prog], a		; update pointer
0056+  0FC5 F0          	pop di
0057+  0FC6 EF          	pop si
0058+  0FC7 E4          	pop a
0059+  0FC8 09          	ret
0060+  0FC9             
0061+  0FC9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  0FC9             ;; read a path formation from shell input buffer
0063+  0FC9             ;; path is written into tokstr
0064+  0FC9             ;; /usr/bin
0065+  0FC9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  0FC9             get_path:
0067+  0FC9 D7          	push a
0068+  0FCA E2          	push si
0069+  0FCB E3          	push di
0070+  0FCC 19 00       	mov al, 0
0071+  0FCE 3D C3 11    	mov [tokstr], al			; nullify tokstr string
0072+  0FD1 14 BF 11    	mov a, [prog]
0073+  0FD4 4D          	mov si, a
0074+  0FD5 FD 4F C3 11 	mov di, tokstr
0075+  0FD9             get_path_skip_spaces:
0076+  0FD9 F6          	lodsb
0077+  0FDA 07 6E 0F    	call isspace
0078+  0FDD C6 D9 0F    	je get_path_skip_spaces
0079+  0FE0             get_path_is_pathchar:
0080+  0FE0 F7          	stosb
0081+  0FE1 F6          	lodsb
0082+  0FE2 07 F8 0E    	call isalnum			;check if is alphanumeric
0083+  0FE5 C6 E0 0F    	je get_path_is_pathchar
0084+  0FE8 B9 2F       	cmp al, '/'				; check if is '/'
0085+  0FEA C6 E0 0F    	je get_path_is_pathchar
0086+  0FED 19 00       	mov al, 0
0087+  0FEF F7          	stosb
0088+  0FF0 D5 01 00    	sub si, 1
0089+  0FF3 4E          	mov a, si
0090+  0FF4 42 BF 11    	mov [prog], a		; update pointer
0091+  0FF7             get_path_end:
0092+  0FF7 F0          	pop di
0093+  0FF8 EF          	pop si
0094+  0FF9 E4          	pop a
0095+  0FFA 09          	ret
0096+  0FFB             
0097+  0FFB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  0FFB             ;; read a line
0099+  0FFB             ;; line is written into tokstr
0100+  0FFB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  0FFB             get_line:
0102+  0FFB D7          	push a
0103+  0FFC E2          	push si
0104+  0FFD E3          	push di
0105+  0FFE 19 00       	mov al, 0
0106+  1000 3D C3 11    	mov [tokstr], al			; nullify tokstr string
0107+  1003 14 BF 11    	mov a, [prog]
0108+  1006 4D          	mov si, a
0109+  1007 FD 4F C3 11 	mov di, tokstr
0110+  100B             get_line_L0:
0111+  100B F6          	lodsb
0112+  100C B9 0A       	cmp al, $0A		; check for new line
0113+  100E C6 15 10    	je get_line_exit
0114+  1011 F7          	stosb
0115+  1012 0A 0B 10    	jmp get_line_L0
0116+  1015             get_line_exit:
0117+  1015 19 00       	mov al, 0
0118+  1017 F7          	stosb
0119+  1018 4E          	mov a, si
0120+  1019 42 BF 11    	mov [prog], a		; update pointer
0121+  101C F0          	pop di
0122+  101D EF          	pop si
0123+  101E E4          	pop a
0124+  101F 09          	ret
0125+  1020             
0126+  1020             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  1020             ;; token parser
0128+  1020             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  1020             get_token:
0130+  1020 D7          	push a
0131+  1021 DA          	push d
0132+  1022 E2          	push si
0133+  1023 E3          	push di
0134+  1024 19 00       	mov al, 0
0135+  1026 3D C3 11    	mov [tokstr], al			; nullify tokstr string
0136+  1029 19 00       	mov al, TOK_NULL
0137+  102B 3D C2 11    	mov [tok], al				; nullify token
0138+  102E 14 BF 11    	mov a, [prog]
0139+  1031 4D          	mov si, a
0140+  1032 FD 4F C3 11 	mov di, tokstr
0141+  1036             get_tok_skip_spaces:
0142+  1036 F6          	lodsb
0143+  1037 07 6E 0F    	call isspace
0144+  103A C6 36 10    	je get_tok_skip_spaces
0145+  103D B9 00       	cmp al, 0			; check for end of input (NULL)
0146+  103F C6 24 11    	je get_token_end
0147+  1042 B9 23       	cmp al, '#'			; comments!
0148+  1044 C6 52 11    	je get_tok_comment
0149+  1047 07 F8 0E    	call isalnum
0150+  104A C6 31 11    	jz is_alphanumeric
0151+  104D             ; other token types
0152+  104D             get_token_slash:
0153+  104D B9 2F       	cmp al, '/'				; check if '/'
0154+  104F C7 67 10    	jne get_token_minus
0155+  1052 F7          	stosb					; store '/' into token string
0156+  1053 19 00       	mov al, 0
0157+  1055 F7          	stosb					; terminate token string
0158+  1056 19 01       	mov al, TOK_FSLASH
0159+  1058 3D C2 11    	mov [tok], al			
0160+  105B 19 02       	mov al, TOKTYP_DELIMITER
0161+  105D 3D C1 11    	mov [toktyp], al
0162+  1060 4E          	mov a, si
0163+  1061 42 BF 11    	mov [prog], a		; update pointer
0164+  1064 0A 4D 11    	jmp get_token_return
0165+  1067             get_token_minus:
0166+  1067 B9 2D       	cmp al, '-'				; check if '-'
0167+  1069 C7 81 10    	jne get_token_comma
0168+  106C F7          	stosb					; store '-' into token string
0169+  106D 19 00       	mov al, 0
0170+  106F F7          	stosb					; terminate token string
0171+  1070 19 04       	mov al, TOK_MINUS
0172+  1072 3D C2 11    	mov [tok], al			
0173+  1075 19 02       	mov al, TOKTYP_DELIMITER
0174+  1077 3D C1 11    	mov [toktyp], al
0175+  107A 4E          	mov a, si
0176+  107B 42 BF 11    	mov [prog], a		; update pointer
0177+  107E 0A 4D 11    	jmp get_token_return
0178+  1081             get_token_comma:
0179+  1081 B9 2C       	cmp al, ','				; check if ','
0180+  1083 C7 9B 10    	jne get_token_semi
0181+  1086 F7          	stosb					; store ',' into token string
0182+  1087 19 00       	mov al, 0
0183+  1089 F7          	stosb					; terminate token string
0184+  108A 19 0B       	mov al, TOK_COMMA
0185+  108C 3D C2 11    	mov [tok], al			
0186+  108F 19 02       	mov al, TOKTYP_DELIMITER
0187+  1091 3D C1 11    	mov [toktyp], al
0188+  1094 4E          	mov a, si
0189+  1095 42 BF 11    	mov [prog], a		; update pointer
0190+  1098 0A 4D 11    	jmp get_token_return
0191+  109B             get_token_semi:
0192+  109B B9 3B       	cmp al, $3B				; check if ';'
0193+  109D C7 B5 10    	jne get_token_colon
0194+  10A0 F7          	stosb					; store ';' into token string
0195+  10A1 19 00       	mov al, 0
0196+  10A3 F7          	stosb					; terminate token string
0197+  10A4 19 06       	mov al, TOK_SEMI
0198+  10A6 3D C2 11    	mov [tok], al			
0199+  10A9 19 02       	mov al, TOKTYP_DELIMITER
0200+  10AB 3D C1 11    	mov [toktyp], al
0201+  10AE 4E          	mov a, si
0202+  10AF 42 BF 11    	mov [prog], a		; update pointer
0203+  10B2 0A 4D 11    	jmp get_token_return
0204+  10B5             get_token_colon:
0205+  10B5 B9 3A       	cmp al, $3A				; check if ':'
0206+  10B7 C7 CF 10    	jne get_token_angle
0207+  10BA F7          	stosb					; store ':' into token string
0208+  10BB 19 00       	mov al, 0
0209+  10BD F7          	stosb					; terminate token string
0210+  10BE 19 0A       	mov al, TOK_COLON
0211+  10C0 3D C2 11    	mov [tok], al			
0212+  10C3 19 02       	mov al, TOKTYP_DELIMITER
0213+  10C5 3D C1 11    	mov [toktyp], al
0214+  10C8 4E          	mov a, si
0215+  10C9 42 BF 11    	mov [prog], a		; update pointer
0216+  10CC 0A 4D 11    	jmp get_token_return
0217+  10CF             get_token_angle:
0218+  10CF B9 3E       	cmp al, $3E				; check if '>'
0219+  10D1 C7 E9 10    	jne get_token_tilde
0220+  10D4 F7          	stosb					; store '>' into token string
0221+  10D5 19 00       	mov al, 0
0222+  10D7 F7          	stosb					; terminate token string
0223+  10D8 19 07       	mov al, TOK_ANGLE
0224+  10DA 3D C2 11    	mov [tok], al			
0225+  10DD 19 02       	mov al, TOKTYP_DELIMITER
0226+  10DF 3D C1 11    	mov [toktyp], al
0227+  10E2 4E          	mov a, si
0228+  10E3 42 BF 11    	mov [prog], a		; update pointer
0229+  10E6 0A 4D 11    	jmp get_token_return
0230+  10E9             get_token_tilde:
0231+  10E9 B9 7E       	cmp al, '~'				; check if '~'
0232+  10EB C7 03 11    	jne get_token_equal
0233+  10EE F7          	stosb					; store '~' into token string
0234+  10EF 19 00       	mov al, 0
0235+  10F1 F7          	stosb					; terminate token string
0236+  10F2 19 08       	mov al, TOK_TILDE
0237+  10F4 3D C2 11    	mov [tok], al			
0238+  10F7 19 02       	mov al, TOKTYP_DELIMITER
0239+  10F9 3D C1 11    	mov [toktyp], al
0240+  10FC 4E          	mov a, si
0241+  10FD 42 BF 11    	mov [prog], a		; update pointer
0242+  1100 0A 4D 11    	jmp get_token_return
0243+  1103             get_token_equal:
0244+  1103 B9 3D       	cmp al, '='				; check if '='
0245+  1105 C7 1D 11    	jne get_token_skip
0246+  1108 F7          	stosb					; store '=' into token string
0247+  1109 19 00       	mov al, 0
0248+  110B F7          	stosb					; terminate token string
0249+  110C 19 09       	mov al, TOK_EQUAL
0250+  110E 3D C2 11    	mov [tok], al			
0251+  1111 19 02       	mov al, TOKTYP_DELIMITER
0252+  1113 3D C1 11    	mov [toktyp], al
0253+  1116 4E          	mov a, si
0254+  1117 42 BF 11    	mov [prog], a		; update pointer
0255+  111A 0A 4D 11    	jmp get_token_return
0256+  111D             get_token_skip:
0257+  111D 4E          	mov a, si
0258+  111E 42 BF 11    	mov [prog], a		; update pointer
0259+  1121 0A 4D 11    	jmp get_token_return
0260+  1124             get_token_end:				; end of file token
0261+  1124 19 14       	mov al, TOK_END
0262+  1126 3D C2 11    	mov [tok], al
0263+  1129 19 06       	mov al, TOKTYP_END
0264+  112B 3D C1 11    	mov [toktyp], al
0265+  112E 0A 4D 11    	jmp get_token_return
0266+  1131             is_alphanumeric:
0267+  1131 F7          	stosb
0268+  1132 F6          	lodsb
0269+  1133 07 F8 0E    	call isalnum			;check if is alphanumeric
0270+  1136 C6 31 11    	jz is_alphanumeric
0271+  1139 B9 2E       	cmp al, $2E				; check if is '.'
0272+  113B C6 31 11    	je is_alphanumeric
0273+  113E 19 00       	mov al, 0
0274+  1140 F7          	stosb
0275+  1141 19 00       	mov al, TOKTYP_IDENTIFIER
0276+  1143 3D C1 11    	mov [toktyp], al
0277+  1146 D5 01 00    	sub si, 1
0278+  1149 4E          	mov a, si
0279+  114A 42 BF 11    	mov [prog], a		; update pointer
0280+  114D             get_token_return:
0281+  114D F0          	pop di
0282+  114E EF          	pop si
0283+  114F E7          	pop d
0284+  1150 E4          	pop a
0285+  1151 09          	ret
0286+  1152             get_tok_comment:
0287+  1152 F6          	lodsb
0288+  1153 B9 0A       	cmp al, $0A			; new line
0289+  1155 C7 52 11    	jne get_tok_comment
0290+  1158 0A 36 10    	jmp get_tok_skip_spaces
0291+  115B             
0292+  115B             
0293+  115B             get_number:
0294+  115B D7          	push a
0295+  115C DA          	push d
0296+  115D E2          	push si
0297+  115E E3          	push di
0298+  115F 19 00       	mov al, 0
0299+  1161 3D C3 11    	mov [tokstr], al			; nullify tokstr string
0300+  1164 19 00       	mov al, TOK_NULL
0301+  1166 3D C2 11    	mov [tok], al				; nullify token
0302+  1169 14 BF 11    	mov a, [prog]
0303+  116C 4D          	mov si, a
0304+  116D FD 4F C3 11 	mov di, tokstr
0305+  1171             get_number_skip_spaces:
0306+  1171 F6          	lodsb
0307+  1172 07 6E 0F    	call isspace
0308+  1175 C6 71 11    	je get_number_skip_spaces
0309+  1178 B9 00       	cmp al, 0			; check for end of input (NULL)
0310+  117A C7 8A 11    	jne get_number_L0
0311+  117D 19 14       	mov al, TOK_END
0312+  117F 3D C2 11    	mov [tok], al
0313+  1182 19 06       	mov al, TOKTYP_END
0314+  1184 3D C1 11    	mov [toktyp], al
0315+  1187 0A A1 11    	jmp get_number_return
0316+  118A             get_number_L0:
0317+  118A F7          	stosb
0318+  118B F6          	lodsb
0319+  118C 07 02 0F    	call isdigit			;check if is numeric
0320+  118F C6 8A 11    	jz get_number_L0
0321+  1192 19 00       	mov al, 0
0322+  1194 F7          	stosb
0323+  1195 19 05       	mov al, TOKTYP_NUMERIC
0324+  1197 3D C1 11    	mov [toktyp], al
0325+  119A D5 01 00    	sub si, 1
0326+  119D 4E          	mov a, si
0327+  119E 42 BF 11    	mov [prog], a		; update pointer
0328+  11A1             get_number_return:
0329+  11A1 F0          	pop di
0330+  11A2 EF          	pop si
0331+  11A3 E7          	pop d
0332+  11A4 E4          	pop a
0333+  11A5 09          	ret
0334+  11A6             
0335+  11A6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  11A6             ;; PUT BACK TOKEN
0337+  11A6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
0338+  11A6             putback:
0339+  11A6 D7          	push a
0340+  11A7 E2          	push si
0341+  11A8 FD 4D C3 11 	mov si, tokstr	
0342+  11AC             putback_loop:
0343+  11AC F6          	lodsb
0344+  11AD B9 00       	cmp al, 0
0345+  11AF C6 BC 11    	je putback_end
0346+  11B2 14 BF 11    	mov a, [prog]
0347+  11B5 7D          	dec a
0348+  11B6 42 BF 11    	mov [prog], a			; update pointer
0349+  11B9 0A AC 11    	jmp putback_loop
0350+  11BC             putback_end:
0351+  11BC EF          	pop si
0352+  11BD E4          	pop a
0353+  11BE 09          	ret
0354+  11BF             
0355+  11BF             
0356+  11BF             
0357+  11BF             
0358+  11BF 00 00       prog:		.dw 0			; pointer to current position in buffer
0359+  11C1             
0360+  11C1 00          toktyp: 	.db 0			; token type symbol
0361+  11C2 00          tok:		.db 0			; current token symbol
0362+  11C3 00 00 00 00 tokstr:		.fill 256, 0	; token as a string
0362+  11C7 00 00 00 00 
0362+  11CB 00 00 00 00 
0362+  11CF 00 00 00 00 
0362+  11D3 00 00 00 00 
0362+  11D7 00 00 00 00 
0362+  11DB 00 00 00 00 
0362+  11DF 00 00 00 00 
0362+  11E3 00 00 00 00 
0362+  11E7 00 00 00 00 
0362+  11EB 00 00 00 00 
0362+  11EF 00 00 00 00 
0362+  11F3 00 00 00 00 
0362+  11F7 00 00 00 00 
0362+  11FB 00 00 00 00 
0362+  11FF 00 00 00 00 
0362+  1203 00 00 00 00 
0362+  1207 00 00 00 00 
0362+  120B 00 00 00 00 
0362+  120F 00 00 00 00 
0362+  1213 00 00 00 00 
0362+  1217 00 00 00 00 
0362+  121B 00 00 00 00 
0362+  121F 00 00 00 00 
0362+  1223 00 00 00 00 
0362+  1227 00 00 00 00 
0362+  122B 00 00 00 00 
0362+  122F 00 00 00 00 
0362+  1233 00 00 00 00 
0362+  1237 00 00 00 00 
0362+  123B 00 00 00 00 
0362+  123F 00 00 00 00 
0362+  1243 00 00 00 00 
0362+  1247 00 00 00 00 
0362+  124B 00 00 00 00 
0362+  124F 00 00 00 00 
0362+  1253 00 00 00 00 
0362+  1257 00 00 00 00 
0362+  125B 00 00 00 00 
0362+  125F 00 00 00 00 
0362+  1263 00 00 00 00 
0362+  1267 00 00 00 00 
0362+  126B 00 00 00 00 
0362+  126F 00 00 00 00 
0362+  1273 00 00 00 00 
0362+  1277 00 00 00 00 
0362+  127B 00 00 00 00 
0362+  127F 00 00 00 00 
0362+  1283 00 00 00 00 
0362+  1287 00 00 00 00 
0362+  128B 00 00 00 00 
0362+  128F 00 00 00 00 
0362+  1293 00 00 00 00 
0362+  1297 00 00 00 00 
0362+  129B 00 00 00 00 
0362+  129F 00 00 00 00 
0362+  12A3 00 00 00 00 
0362+  12A7 00 00 00 00 
0362+  12AB 00 00 00 00 
0362+  12AF 00 00 00 00 
0362+  12B3 00 00 00 00 
0362+  12B7 00 00 00 00 
0362+  12BB 00 00 00 00 
0362+  12BF 00 00 00 00 
0282   12C3             
0283   12C3             .end
tasm: Number of errors = 0
