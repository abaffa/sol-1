0001   0000             .include "kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0002   0000             
0003   0400             .org PROC_TEXT_ORG			; origin at 1024
0004   0400             
0005   0400             cmd_man:
0006   0400 3B 2A 0A      mov d, s_telnet_clear
0007   0403 07 CF 0B      call puts
0008   0406 10 00 00      mov a, 0
0009   0409 42 7F 08      mov [prog], a			; move tokennizer pointer to the beginning of the arguments area (address 0)
0010   040C 07 E0 06      call get_token
0011   040F 1D 82 08      mov al, [tok]
0012   0412 B9 14         cmp al, TOK_END
0013   0414 C6 41 04      je cmd_man_fail
0014   0417             
0015   0417 FD 4D 43 04   mov si, manpath
0016   041B FD 4F 53 04   mov di, temp_data
0017   041F 07 EF 09      call strcpy        ; complete path with command name
0018   0422 FD 4D 83 08   mov si, tokstr
0019   0426 FD 4F 53 04   mov di, temp_data
0020   042A 07 FD 09      call strcat        ; complete path with command name
0021   042D 3B 53 04      mov d, temp_data
0022   0430 FD 4F A0 0D   mov di, transient_area
0023   0434 19 14         mov al, 20
0024   0436 05 04         syscall sys_filesystem
0025   0438 3B A0 0D      mov d, transient_area
0026   043B 07 CF 0B      call puts
0027   043E 07 7C 0B      call printnl
0028   0441             cmd_man_fail:
0029   0441 05 0B       	syscall sys_terminate_proc
0030   0443             
0031   0443 2F 75 73 72 manpath:  .db "/usr/share/man/", 0
0031   0447 2F 73 68 61 
0031   044B 72 65 2F 6D 
0031   044F 61 6E 2F 00 
0032   0453 00 00 00 00 temp_data: .fill 512, 0
0032   0457 00 00 00 00 
0032   045B 00 00 00 00 
0032   045F 00 00 00 00 
0032   0463 00 00 00 00 
0032   0467 00 00 00 00 
0032   046B 00 00 00 00 
0032   046F 00 00 00 00 
0032   0473 00 00 00 00 
0032   0477 00 00 00 00 
0032   047B 00 00 00 00 
0032   047F 00 00 00 00 
0032   0483 00 00 00 00 
0032   0487 00 00 00 00 
0032   048B 00 00 00 00 
0032   048F 00 00 00 00 
0032   0493 00 00 00 00 
0032   0497 00 00 00 00 
0032   049B 00 00 00 00 
0032   049F 00 00 00 00 
0032   04A3 00 00 00 00 
0032   04A7 00 00 00 00 
0032   04AB 00 00 00 00 
0032   04AF 00 00 00 00 
0032   04B3 00 00 00 00 
0032   04B7 00 00 00 00 
0032   04BB 00 00 00 00 
0032   04BF 00 00 00 00 
0032   04C3 00 00 00 00 
0032   04C7 00 00 00 00 
0032   04CB 00 00 00 00 
0032   04CF 00 00 00 00 
0032   04D3 00 00 00 00 
0032   04D7 00 00 00 00 
0032   04DB 00 00 00 00 
0032   04DF 00 00 00 00 
0032   04E3 00 00 00 00 
0032   04E7 00 00 00 00 
0032   04EB 00 00 00 00 
0032   04EF 00 00 00 00 
0032   04F3 00 00 00 00 
0032   04F7 00 00 00 00 
0032   04FB 00 00 00 00 
0032   04FF 00 00 00 00 
0032   0503 00 00 00 00 
0032   0507 00 00 00 00 
0032   050B 00 00 00 00 
0032   050F 00 00 00 00 
0032   0513 00 00 00 00 
0032   0517 00 00 00 00 
0032   051B 00 00 00 00 
0032   051F 00 00 00 00 
0032   0523 00 00 00 00 
0032   0527 00 00 00 00 
0032   052B 00 00 00 00 
0032   052F 00 00 00 00 
0032   0533 00 00 00 00 
0032   0537 00 00 00 00 
0032   053B 00 00 00 00 
0032   053F 00 00 00 00 
0032   0543 00 00 00 00 
0032   0547 00 00 00 00 
0032   054B 00 00 00 00 
0032   054F 00 00 00 00 
0032   0553 00 00 00 00 
0032   0557 00 00 00 00 
0032   055B 00 00 00 00 
0032   055F 00 00 00 00 
0032   0563 00 00 00 00 
0032   0567 00 00 00 00 
0032   056B 00 00 00 00 
0032   056F 00 00 00 00 
0032   0573 00 00 00 00 
0032   0577 00 00 00 00 
0032   057B 00 00 00 00 
0032   057F 00 00 00 00 
0032   0583 00 00 00 00 
0032   0587 00 00 00 00 
0032   058B 00 00 00 00 
0032   058F 00 00 00 00 
0032   0593 00 00 00 00 
0032   0597 00 00 00 00 
0032   059B 00 00 00 00 
0032   059F 00 00 00 00 
0032   05A3 00 00 00 00 
0032   05A7 00 00 00 00 
0032   05AB 00 00 00 00 
0032   05AF 00 00 00 00 
0032   05B3 00 00 00 00 
0032   05B7 00 00 00 00 
0032   05BB 00 00 00 00 
0032   05BF 00 00 00 00 
0032   05C3 00 00 00 00 
0032   05C7 00 00 00 00 
0032   05CB 00 00 00 00 
0032   05CF 00 00 00 00 
0032   05D3 00 00 00 00 
0032   05D7 00 00 00 00 
0032   05DB 00 00 00 00 
0032   05DF 00 00 00 00 
0032   05E3 00 00 00 00 
0032   05E7 00 00 00 00 
0032   05EB 00 00 00 00 
0032   05EF 00 00 00 00 
0032   05F3 00 00 00 00 
0032   05F7 00 00 00 00 
0032   05FB 00 00 00 00 
0032   05FF 00 00 00 00 
0032   0603 00 00 00 00 
0032   0607 00 00 00 00 
0032   060B 00 00 00 00 
0032   060F 00 00 00 00 
0032   0613 00 00 00 00 
0032   0617 00 00 00 00 
0032   061B 00 00 00 00 
0032   061F 00 00 00 00 
0032   0623 00 00 00 00 
0032   0627 00 00 00 00 
0032   062B 00 00 00 00 
0032   062F 00 00 00 00 
0032   0633 00 00 00 00 
0032   0637 00 00 00 00 
0032   063B 00 00 00 00 
0032   063F 00 00 00 00 
0032   0643 00 00 00 00 
0032   0647 00 00 00 00 
0032   064B 00 00 00 00 
0032   064F 00 00 00 00 
0033   0653 2F 00       s_fslash:  .db "/", 0
0034   0655             
0035   0655             .include "token.asm"
0001+  0655             TOKTYP_IDENTIFIER	.equ 0
0002+  0655             TOKTYP_KEYWORD		.equ 1
0003+  0655             TOKTYP_DELIMITER	.equ 2
0004+  0655             TOKTYP_STRING		.equ 3
0005+  0655             TOKTYP_CHAR			.equ 4
0006+  0655             TOKTYP_NUMERIC		.equ 5
0007+  0655             TOKTYP_END			.equ 6
0008+  0655             
0009+  0655             TOK_NULL			.equ 0
0010+  0655             TOK_FSLASH			.equ 1
0011+  0655             TOK_TIMES 			.equ 2
0012+  0655             TOK_PLUS 			.equ 3
0013+  0655             TOK_MINUS 			.equ 4
0014+  0655             TOK_DOT				.equ 5
0015+  0655             TOK_SEMI			.equ 6
0016+  0655             TOK_ANGLE			.equ 7
0017+  0655             TOK_TILDE			.equ 8
0018+  0655             TOK_EQUAL			.equ 9
0019+  0655             TOK_COLON			.equ 10
0020+  0655             TOK_COMMA			.equ 11
0021+  0655             
0022+  0655             TOK_END				.equ 20
0023+  0655             
0024+  0655             
0025+  0655             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  0655             ;; read a full command argment from shell input buffer
0027+  0655             ;; argument is written into tokstr
0028+  0655             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  0655             get_arg:
0030+  0655 D7          	push a
0031+  0656 E2          	push si
0032+  0657 E3          	push di
0033+  0658 19 00       	mov al, 0
0034+  065A 3D 83 08    	mov [tokstr], al			; nullify tokstr string
0035+  065D 14 7F 08    	mov a, [prog]
0036+  0660 4D          	mov si, a
0037+  0661 FD 4F 83 08 	mov di, tokstr
0038+  0665             get_arg_skip_spaces:
0039+  0665 F6          	lodsb
0040+  0666 07 79 0D    	call isspace
0041+  0669 C6 65 06    	je get_arg_skip_spaces
0042+  066C             get_arg_L0:
0043+  066C B9 3B       	cmp al, $3B				; check if is ';'
0044+  066E C6 7B 06    	je get_arg_end
0045+  0671 B9 00       	cmp al, 0
0046+  0673 C6 7B 06    	je get_arg_end			; check if end of input
0047+  0676 F7          	stosb
0048+  0677 F6          	lodsb
0049+  0678 0A 6C 06    	jmp get_arg_L0
0050+  067B             get_arg_end:
0051+  067B 19 00       	mov al, 0
0052+  067D F7          	stosb
0053+  067E D5 01 00    	sub si, 1
0054+  0681 4E          	mov a, si
0055+  0682 42 7F 08    	mov [prog], a		; update pointer
0056+  0685 F0          	pop di
0057+  0686 EF          	pop si
0058+  0687 E4          	pop a
0059+  0688 09          	ret
0060+  0689             
0061+  0689             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  0689             ;; read a path formation from shell input buffer
0063+  0689             ;; path is written into tokstr
0064+  0689             ;; /usr/bin
0065+  0689             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  0689             get_path:
0067+  0689 D7          	push a
0068+  068A E2          	push si
0069+  068B E3          	push di
0070+  068C 19 00       	mov al, 0
0071+  068E 3D 83 08    	mov [tokstr], al			; nullify tokstr string
0072+  0691 14 7F 08    	mov a, [prog]
0073+  0694 4D          	mov si, a
0074+  0695 FD 4F 83 08 	mov di, tokstr
0075+  0699             get_path_skip_spaces:
0076+  0699 F6          	lodsb
0077+  069A 07 79 0D    	call isspace
0078+  069D C6 99 06    	je get_path_skip_spaces
0079+  06A0             get_path_is_pathchar:
0080+  06A0 F7          	stosb
0081+  06A1 F6          	lodsb
0082+  06A2 07 03 0D    	call isalnum			;check if is alphanumeric
0083+  06A5 C6 A0 06    	je get_path_is_pathchar
0084+  06A8 B9 2F       	cmp al, '/'				; check if is '/'
0085+  06AA C6 A0 06    	je get_path_is_pathchar
0086+  06AD 19 00       	mov al, 0
0087+  06AF F7          	stosb
0088+  06B0 D5 01 00    	sub si, 1
0089+  06B3 4E          	mov a, si
0090+  06B4 42 7F 08    	mov [prog], a		; update pointer
0091+  06B7             get_path_end:
0092+  06B7 F0          	pop di
0093+  06B8 EF          	pop si
0094+  06B9 E4          	pop a
0095+  06BA 09          	ret
0096+  06BB             
0097+  06BB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  06BB             ;; read a line
0099+  06BB             ;; line is written into tokstr
0100+  06BB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  06BB             get_line:
0102+  06BB D7          	push a
0103+  06BC E2          	push si
0104+  06BD E3          	push di
0105+  06BE 19 00       	mov al, 0
0106+  06C0 3D 83 08    	mov [tokstr], al			; nullify tokstr string
0107+  06C3 14 7F 08    	mov a, [prog]
0108+  06C6 4D          	mov si, a
0109+  06C7 FD 4F 83 08 	mov di, tokstr
0110+  06CB             get_line_L0:
0111+  06CB F6          	lodsb
0112+  06CC B9 0A       	cmp al, $0A		; check for new line
0113+  06CE C6 D5 06    	je get_line_exit
0114+  06D1 F7          	stosb
0115+  06D2 0A CB 06    	jmp get_line_L0
0116+  06D5             get_line_exit:
0117+  06D5 19 00       	mov al, 0
0118+  06D7 F7          	stosb
0119+  06D8 4E          	mov a, si
0120+  06D9 42 7F 08    	mov [prog], a		; update pointer
0121+  06DC F0          	pop di
0122+  06DD EF          	pop si
0123+  06DE E4          	pop a
0124+  06DF 09          	ret
0125+  06E0             
0126+  06E0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  06E0             ;; token parser
0128+  06E0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  06E0             get_token:
0130+  06E0 D7          	push a
0131+  06E1 DA          	push d
0132+  06E2 E2          	push si
0133+  06E3 E3          	push di
0134+  06E4 19 00       	mov al, 0
0135+  06E6 3D 83 08    	mov [tokstr], al			; nullify tokstr string
0136+  06E9 19 00       	mov al, TOK_NULL
0137+  06EB 3D 82 08    	mov [tok], al				; nullify token
0138+  06EE 14 7F 08    	mov a, [prog]
0139+  06F1 4D          	mov si, a
0140+  06F2 FD 4F 83 08 	mov di, tokstr
0141+  06F6             get_tok_skip_spaces:
0142+  06F6 F6          	lodsb
0143+  06F7 07 79 0D    	call isspace
0144+  06FA C6 F6 06    	je get_tok_skip_spaces
0145+  06FD B9 00       	cmp al, 0			; check for end of input (NULL)
0146+  06FF C6 E4 07    	je get_token_end
0147+  0702 B9 23       	cmp al, '#'			; comments!
0148+  0704 C6 12 08    	je get_tok_comment
0149+  0707 07 03 0D    	call isalnum
0150+  070A C6 F1 07    	jz is_alphanumeric
0151+  070D             ; other token types
0152+  070D             get_token_slash:
0153+  070D B9 2F       	cmp al, '/'				; check if '/'
0154+  070F C7 27 07    	jne get_token_minus
0155+  0712 F7          	stosb					; store '/' into token string
0156+  0713 19 00       	mov al, 0
0157+  0715 F7          	stosb					; terminate token string
0158+  0716 19 01       	mov al, TOK_FSLASH
0159+  0718 3D 82 08    	mov [tok], al			
0160+  071B 19 02       	mov al, TOKTYP_DELIMITER
0161+  071D 3D 81 08    	mov [toktyp], al
0162+  0720 4E          	mov a, si
0163+  0721 42 7F 08    	mov [prog], a		; update pointer
0164+  0724 0A 0D 08    	jmp get_token_return
0165+  0727             get_token_minus:
0166+  0727 B9 2D       	cmp al, '-'				; check if '-'
0167+  0729 C7 41 07    	jne get_token_comma
0168+  072C F7          	stosb					; store '-' into token string
0169+  072D 19 00       	mov al, 0
0170+  072F F7          	stosb					; terminate token string
0171+  0730 19 04       	mov al, TOK_MINUS
0172+  0732 3D 82 08    	mov [tok], al			
0173+  0735 19 02       	mov al, TOKTYP_DELIMITER
0174+  0737 3D 81 08    	mov [toktyp], al
0175+  073A 4E          	mov a, si
0176+  073B 42 7F 08    	mov [prog], a		; update pointer
0177+  073E 0A 0D 08    	jmp get_token_return
0178+  0741             get_token_comma:
0179+  0741 B9 2C       	cmp al, ','				; check if ','
0180+  0743 C7 5B 07    	jne get_token_semi
0181+  0746 F7          	stosb					; store ',' into token string
0182+  0747 19 00       	mov al, 0
0183+  0749 F7          	stosb					; terminate token string
0184+  074A 19 0B       	mov al, TOK_COMMA
0185+  074C 3D 82 08    	mov [tok], al			
0186+  074F 19 02       	mov al, TOKTYP_DELIMITER
0187+  0751 3D 81 08    	mov [toktyp], al
0188+  0754 4E          	mov a, si
0189+  0755 42 7F 08    	mov [prog], a		; update pointer
0190+  0758 0A 0D 08    	jmp get_token_return
0191+  075B             get_token_semi:
0192+  075B B9 3B       	cmp al, $3B				; check if ';'
0193+  075D C7 75 07    	jne get_token_colon
0194+  0760 F7          	stosb					; store ';' into token string
0195+  0761 19 00       	mov al, 0
0196+  0763 F7          	stosb					; terminate token string
0197+  0764 19 06       	mov al, TOK_SEMI
0198+  0766 3D 82 08    	mov [tok], al			
0199+  0769 19 02       	mov al, TOKTYP_DELIMITER
0200+  076B 3D 81 08    	mov [toktyp], al
0201+  076E 4E          	mov a, si
0202+  076F 42 7F 08    	mov [prog], a		; update pointer
0203+  0772 0A 0D 08    	jmp get_token_return
0204+  0775             get_token_colon:
0205+  0775 B9 3A       	cmp al, $3A				; check if ':'
0206+  0777 C7 8F 07    	jne get_token_angle
0207+  077A F7          	stosb					; store ':' into token string
0208+  077B 19 00       	mov al, 0
0209+  077D F7          	stosb					; terminate token string
0210+  077E 19 0A       	mov al, TOK_COLON
0211+  0780 3D 82 08    	mov [tok], al			
0212+  0783 19 02       	mov al, TOKTYP_DELIMITER
0213+  0785 3D 81 08    	mov [toktyp], al
0214+  0788 4E          	mov a, si
0215+  0789 42 7F 08    	mov [prog], a		; update pointer
0216+  078C 0A 0D 08    	jmp get_token_return
0217+  078F             get_token_angle:
0218+  078F B9 3E       	cmp al, $3E				; check if '>'
0219+  0791 C7 A9 07    	jne get_token_tilde
0220+  0794 F7          	stosb					; store '>' into token string
0221+  0795 19 00       	mov al, 0
0222+  0797 F7          	stosb					; terminate token string
0223+  0798 19 07       	mov al, TOK_ANGLE
0224+  079A 3D 82 08    	mov [tok], al			
0225+  079D 19 02       	mov al, TOKTYP_DELIMITER
0226+  079F 3D 81 08    	mov [toktyp], al
0227+  07A2 4E          	mov a, si
0228+  07A3 42 7F 08    	mov [prog], a		; update pointer
0229+  07A6 0A 0D 08    	jmp get_token_return
0230+  07A9             get_token_tilde:
0231+  07A9 B9 7E       	cmp al, '~'				; check if '~'
0232+  07AB C7 C3 07    	jne get_token_equal
0233+  07AE F7          	stosb					; store '~' into token string
0234+  07AF 19 00       	mov al, 0
0235+  07B1 F7          	stosb					; terminate token string
0236+  07B2 19 08       	mov al, TOK_TILDE
0237+  07B4 3D 82 08    	mov [tok], al			
0238+  07B7 19 02       	mov al, TOKTYP_DELIMITER
0239+  07B9 3D 81 08    	mov [toktyp], al
0240+  07BC 4E          	mov a, si
0241+  07BD 42 7F 08    	mov [prog], a		; update pointer
0242+  07C0 0A 0D 08    	jmp get_token_return
0243+  07C3             get_token_equal:
0244+  07C3 B9 3D       	cmp al, '='				; check if '='
0245+  07C5 C7 DD 07    	jne get_token_skip
0246+  07C8 F7          	stosb					; store '=' into token string
0247+  07C9 19 00       	mov al, 0
0248+  07CB F7          	stosb					; terminate token string
0249+  07CC 19 09       	mov al, TOK_EQUAL
0250+  07CE 3D 82 08    	mov [tok], al			
0251+  07D1 19 02       	mov al, TOKTYP_DELIMITER
0252+  07D3 3D 81 08    	mov [toktyp], al
0253+  07D6 4E          	mov a, si
0254+  07D7 42 7F 08    	mov [prog], a		; update pointer
0255+  07DA 0A 0D 08    	jmp get_token_return
0256+  07DD             get_token_skip:
0257+  07DD 4E          	mov a, si
0258+  07DE 42 7F 08    	mov [prog], a		; update pointer
0259+  07E1 0A 0D 08    	jmp get_token_return
0260+  07E4             get_token_end:				; end of file token
0261+  07E4 19 14       	mov al, TOK_END
0262+  07E6 3D 82 08    	mov [tok], al
0263+  07E9 19 06       	mov al, TOKTYP_END
0264+  07EB 3D 81 08    	mov [toktyp], al
0265+  07EE 0A 0D 08    	jmp get_token_return
0266+  07F1             is_alphanumeric:
0267+  07F1 F7          	stosb
0268+  07F2 F6          	lodsb
0269+  07F3 07 03 0D    	call isalnum			;check if is alphanumeric
0270+  07F6 C6 F1 07    	jz is_alphanumeric
0271+  07F9 B9 2E       	cmp al, $2E				; check if is '.'
0272+  07FB C6 F1 07    	je is_alphanumeric
0273+  07FE 19 00       	mov al, 0
0274+  0800 F7          	stosb
0275+  0801 19 00       	mov al, TOKTYP_IDENTIFIER
0276+  0803 3D 81 08    	mov [toktyp], al
0277+  0806 D5 01 00    	sub si, 1
0278+  0809 4E          	mov a, si
0279+  080A 42 7F 08    	mov [prog], a		; update pointer
0280+  080D             get_token_return:
0281+  080D F0          	pop di
0282+  080E EF          	pop si
0283+  080F E7          	pop d
0284+  0810 E4          	pop a
0285+  0811 09          	ret
0286+  0812             get_tok_comment:
0287+  0812 F6          	lodsb
0288+  0813 B9 0A       	cmp al, $0A			; new line
0289+  0815 C7 12 08    	jne get_tok_comment
0290+  0818 0A F6 06    	jmp get_tok_skip_spaces
0291+  081B             
0292+  081B             
0293+  081B             get_number:
0294+  081B D7          	push a
0295+  081C DA          	push d
0296+  081D E2          	push si
0297+  081E E3          	push di
0298+  081F 19 00       	mov al, 0
0299+  0821 3D 83 08    	mov [tokstr], al			; nullify tokstr string
0300+  0824 19 00       	mov al, TOK_NULL
0301+  0826 3D 82 08    	mov [tok], al				; nullify token
0302+  0829 14 7F 08    	mov a, [prog]
0303+  082C 4D          	mov si, a
0304+  082D FD 4F 83 08 	mov di, tokstr
0305+  0831             get_number_skip_spaces:
0306+  0831 F6          	lodsb
0307+  0832 07 79 0D    	call isspace
0308+  0835 C6 31 08    	je get_number_skip_spaces
0309+  0838 B9 00       	cmp al, 0			; check for end of input (NULL)
0310+  083A C7 4A 08    	jne get_number_L0
0311+  083D 19 14       	mov al, TOK_END
0312+  083F 3D 82 08    	mov [tok], al
0313+  0842 19 06       	mov al, TOKTYP_END
0314+  0844 3D 81 08    	mov [toktyp], al
0315+  0847 0A 61 08    	jmp get_number_return
0316+  084A             get_number_L0:
0317+  084A F7          	stosb
0318+  084B F6          	lodsb
0319+  084C 07 0D 0D    	call isdigit			;check if is numeric
0320+  084F C6 4A 08    	jz get_number_L0
0321+  0852 19 00       	mov al, 0
0322+  0854 F7          	stosb
0323+  0855 19 05       	mov al, TOKTYP_NUMERIC
0324+  0857 3D 81 08    	mov [toktyp], al
0325+  085A D5 01 00    	sub si, 1
0326+  085D 4E          	mov a, si
0327+  085E 42 7F 08    	mov [prog], a		; update pointer
0328+  0861             get_number_return:
0329+  0861 F0          	pop di
0330+  0862 EF          	pop si
0331+  0863 E7          	pop d
0332+  0864 E4          	pop a
0333+  0865 09          	ret
0334+  0866             
0335+  0866             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  0866             ;; PUT BACK TOKEN
0337+  0866             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
0338+  0866             putback:
0339+  0866 D7          	push a
0340+  0867 E2          	push si
0341+  0868 FD 4D 83 08 	mov si, tokstr	
0342+  086C             putback_loop:
0343+  086C F6          	lodsb
0344+  086D B9 00       	cmp al, 0
0345+  086F C6 7C 08    	je putback_end
0346+  0872 14 7F 08    	mov a, [prog]
0347+  0875 7D          	dec a
0348+  0876 42 7F 08    	mov [prog], a			; update pointer
0349+  0879 0A 6C 08    	jmp putback_loop
0350+  087C             putback_end:
0351+  087C EF          	pop si
0352+  087D E4          	pop a
0353+  087E 09          	ret
0354+  087F             
0355+  087F             
0356+  087F             
0357+  087F             
0358+  087F 00 00       prog:		.dw 0			; pointer to current position in buffer
0359+  0881             
0360+  0881 00          toktyp: 	.db 0			; token type symbol
0361+  0882 00          tok:		.db 0			; current token symbol
0362+  0883 00 00 00 00 tokstr:		.fill 256, 0	; token as a string
0362+  0887 00 00 00 00 
0362+  088B 00 00 00 00 
0362+  088F 00 00 00 00 
0362+  0893 00 00 00 00 
0362+  0897 00 00 00 00 
0362+  089B 00 00 00 00 
0362+  089F 00 00 00 00 
0362+  08A3 00 00 00 00 
0362+  08A7 00 00 00 00 
0362+  08AB 00 00 00 00 
0362+  08AF 00 00 00 00 
0362+  08B3 00 00 00 00 
0362+  08B7 00 00 00 00 
0362+  08BB 00 00 00 00 
0362+  08BF 00 00 00 00 
0362+  08C3 00 00 00 00 
0362+  08C7 00 00 00 00 
0362+  08CB 00 00 00 00 
0362+  08CF 00 00 00 00 
0362+  08D3 00 00 00 00 
0362+  08D7 00 00 00 00 
0362+  08DB 00 00 00 00 
0362+  08DF 00 00 00 00 
0362+  08E3 00 00 00 00 
0362+  08E7 00 00 00 00 
0362+  08EB 00 00 00 00 
0362+  08EF 00 00 00 00 
0362+  08F3 00 00 00 00 
0362+  08F7 00 00 00 00 
0362+  08FB 00 00 00 00 
0362+  08FF 00 00 00 00 
0362+  0903 00 00 00 00 
0362+  0907 00 00 00 00 
0362+  090B 00 00 00 00 
0362+  090F 00 00 00 00 
0362+  0913 00 00 00 00 
0362+  0917 00 00 00 00 
0362+  091B 00 00 00 00 
0362+  091F 00 00 00 00 
0362+  0923 00 00 00 00 
0362+  0927 00 00 00 00 
0362+  092B 00 00 00 00 
0362+  092F 00 00 00 00 
0362+  0933 00 00 00 00 
0362+  0937 00 00 00 00 
0362+  093B 00 00 00 00 
0362+  093F 00 00 00 00 
0362+  0943 00 00 00 00 
0362+  0947 00 00 00 00 
0362+  094B 00 00 00 00 
0362+  094F 00 00 00 00 
0362+  0953 00 00 00 00 
0362+  0957 00 00 00 00 
0362+  095B 00 00 00 00 
0362+  095F 00 00 00 00 
0362+  0963 00 00 00 00 
0362+  0967 00 00 00 00 
0362+  096B 00 00 00 00 
0362+  096F 00 00 00 00 
0362+  0973 00 00 00 00 
0362+  0977 00 00 00 00 
0362+  097B 00 00 00 00 
0362+  097F 00 00 00 00 
0036   0983             .include "stdio.asm"
0001+  0983             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0983             ; stdio.s
0003+  0983             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0983             .include "string.asm"
0001++ 0983             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0983             ; string.s
0003++ 0983             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0983             
0005++ 0983             
0006++ 0983             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0983             ; strrev
0008++ 0983             ; reverse a string
0009++ 0983             ; D = string address
0010++ 0983             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0983             ; 01234
0012++ 0983             strrev:
0013++ 0983 4B          	pusha
0014++ 0984 07 CA 09    	call strlen	; length in C
0015++ 0987 12          	mov a, c
0016++ 0988 AF 01 00    	cmp a, 1
0017++ 098B D0 A5 09    	jleu strrev_end	; check string length. string len must be > 1
0018++ 098E 7D          	dec a
0019++ 098F FD 4E       	mov si, d	; beginning of string
0020++ 0991 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0993 59          	add d, a	; end of string
0022++ 0994 12          	mov a, c
0023++ 0995 FD 9B       	shr a		; divide by 2
0024++ 0997 39          	mov c, a	; C now counts the steps
0025++ 0998             strrev_L0:
0026++ 0998 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0999 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 099A 3E          	mov [d], al	; store left char into right side
0029++ 099B 1B          	mov al, bl
0030++ 099C F7          	stosb		; store right-side char into left-side; increase DI
0031++ 099D 7E          	dec c
0032++ 099E 7F          	dec d
0033++ 099F C2 00 00    	cmp c, 0
0034++ 09A2 C7 98 09    	jne strrev_L0
0035++ 09A5             strrev_end:
0036++ 09A5 4C          	popa
0037++ 09A6 09          	ret
0038++ 09A7             	
0039++ 09A7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 09A7             ; strchr
0041++ 09A7             ; search string in D for char in AL
0042++ 09A7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 09A7             strchr:
0044++ 09A7             strchr_L0:
0045++ 09A7 32          	mov bl, [d]
0046++ 09A8 C1 00       	cmp bl, 0
0047++ 09AA C6 B5 09    	je strchr_end
0048++ 09AD BA          	cmp al, bl
0049++ 09AE C6 B5 09    	je strchr_end
0050++ 09B1 79          	inc d
0051++ 09B2 0A A7 09    	jmp strchr_L0
0052++ 09B5             strchr_end:
0053++ 09B5 1B          	mov al, bl
0054++ 09B6 09          	ret
0055++ 09B7             
0056++ 09B7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 09B7             ; strstr
0058++ 09B7             ; find sub-string
0059++ 09B7             ; str1 in SI
0060++ 09B7             ; str2 in DI
0061++ 09B7             ; SI points to end of source string
0062++ 09B7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 09B7             strstr:
0064++ 09B7 DB          	push al
0065++ 09B8 DA          	push d
0066++ 09B9 E3          	push di
0067++ 09BA             strstr_loop:
0068++ 09BA F3          	cmpsb					; compare a byte of the strings
0069++ 09BB C7 C6 09    	jne strstr_ret
0070++ 09BE FC 00 00    	lea d, [di + 0]
0071++ 09C1 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 09C3 C7 BA 09    	jne strstr_loop				; equal chars but not at end
0073++ 09C6             strstr_ret:
0074++ 09C6 F0          	pop di
0075++ 09C7 E7          	pop d
0076++ 09C8 E8          	pop al
0077++ 09C9 09          	ret
0078++ 09CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 09CA             ; length of null terminated string
0080++ 09CA             ; result in C
0081++ 09CA             ; pointer in D
0082++ 09CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 09CA             strlen:
0084++ 09CA DA          	push d
0085++ 09CB 38 00 00    	mov c, 0
0086++ 09CE             strlen_L1:
0087++ 09CE BD 00       	cmp byte [d], 0
0088++ 09D0 C6 D8 09    	je strlen_ret
0089++ 09D3 79          	inc d
0090++ 09D4 78          	inc c
0091++ 09D5 0A CE 09    	jmp strlen_L1
0092++ 09D8             strlen_ret:
0093++ 09D8 E7          	pop d
0094++ 09D9 09          	ret
0095++ 09DA             
0096++ 09DA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 09DA             ; STRCMP
0098++ 09DA             ; compare two strings
0099++ 09DA             ; str1 in SI
0100++ 09DA             ; str2 in DI
0101++ 09DA             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 09DA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 09DA             strcmp:
0104++ 09DA DB          	push al
0105++ 09DB DA          	push d
0106++ 09DC E3          	push di
0107++ 09DD E2          	push si
0108++ 09DE             strcmp_loop:
0109++ 09DE F3          	cmpsb					; compare a byte of the strings
0110++ 09DF C7 EA 09    	jne strcmp_ret
0111++ 09E2 FB FF FF    	lea d, [si +- 1]
0112++ 09E5 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 09E7 C7 DE 09    	jne strcmp_loop				; equal chars but not at end
0114++ 09EA             strcmp_ret:
0115++ 09EA EF          	pop si
0116++ 09EB F0          	pop di
0117++ 09EC E7          	pop d
0118++ 09ED E8          	pop al
0119++ 09EE 09          	ret
0120++ 09EF             
0121++ 09EF             
0122++ 09EF             ; STRCPY
0123++ 09EF             ; copy null terminated string from SI to DI
0124++ 09EF             ; source in SI
0125++ 09EF             ; destination in DI
0126++ 09EF             strcpy:
0127++ 09EF E2          	push si
0128++ 09F0 E3          	push di
0129++ 09F1 DB          	push al
0130++ 09F2             strcpy_L1:
0131++ 09F2 F6          	lodsb
0132++ 09F3 F7          	stosb
0133++ 09F4 B9 00       	cmp al, 0
0134++ 09F6 C7 F2 09    	jne strcpy_L1
0135++ 09F9             strcpy_end:
0136++ 09F9 E8          	pop al
0137++ 09FA F0          	pop di
0138++ 09FB EF          	pop si
0139++ 09FC 09          	ret
0140++ 09FD             
0141++ 09FD             ; STRCAT
0142++ 09FD             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 09FD             ; source in SI
0144++ 09FD             ; destination in DI
0145++ 09FD             strcat:
0146++ 09FD E2          	push si
0147++ 09FE E3          	push di
0148++ 09FF D7          	push a
0149++ 0A00 DA          	push d
0150++ 0A01 50          	mov a, di
0151++ 0A02 3C          	mov d, a
0152++ 0A03             strcat_goto_end_L1:
0153++ 0A03 BD 00       	cmp byte[d], 0
0154++ 0A05 C6 0C 0A    	je strcat_start
0155++ 0A08 79          	inc d
0156++ 0A09 0A 03 0A    	jmp strcat_goto_end_L1
0157++ 0A0C             strcat_start:
0158++ 0A0C FD 50       	mov di, d
0159++ 0A0E             strcat_L1:
0160++ 0A0E F6          	lodsb
0161++ 0A0F F7          	stosb
0162++ 0A10 B9 00       	cmp al, 0
0163++ 0A12 C7 0E 0A    	jne strcat_L1
0164++ 0A15             strcat_end:
0165++ 0A15 E7          	pop d
0166++ 0A16 E4          	pop a
0167++ 0A17 F0          	pop di
0168++ 0A18 EF          	pop si
0169++ 0A19 09          	ret
0005+  0A1A             
0006+  0A1A 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  0A1E 34 35 36 37 
0006+  0A22 38 39 41 42 
0006+  0A26 43 44 45 46 
0007+  0A2A 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  0A2E 1B 5B 48 00 
0008+  0A32             
0009+  0A32 01 00       table_power:.dw 1
0010+  0A34 0A 00       			.dw 10
0011+  0A36 64 00       			.dw 100
0012+  0A38 E8 03       			.dw 1000
0013+  0A3A 10 27       			.dw 10000
0014+  0A3C             
0015+  0A3C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  0A3C             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  0A3C             ; ASCII in BL
0018+  0A3C             ; result in AL
0019+  0A3C             ; ascii for F = 0100 0110
0020+  0A3C             ; ascii for 9 = 0011 1001
0021+  0A3C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  0A3C             hex_ascii_encode:
0023+  0A3C 1B          	mov al, bl
0024+  0A3D 93 40       	test al, $40				; test if letter or number
0025+  0A3F C7 45 0A    	jnz hex_letter
0026+  0A42 87 0F       	and al, $0F				; get number
0027+  0A44 09          	ret
0028+  0A45             hex_letter:
0029+  0A45 87 0F       	and al, $0F				; get letter
0030+  0A47 6A 09       	add al, 9
0031+  0A49 09          	ret
0032+  0A4A             
0033+  0A4A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  0A4A             ; ATOI
0035+  0A4A             ; 2 letter hex string in B
0036+  0A4A             ; 8bit integer returned in AL
0037+  0A4A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0A4A             atoi:
0039+  0A4A D8          	push b
0040+  0A4B 07 3C 0A    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  0A4E 30          	mov bl, bh
0042+  0A4F DB          	push al					; save a
0043+  0A50 07 3C 0A    	call hex_ascii_encode
0044+  0A53 EA          	pop bl	
0045+  0A54 FD 9E 04    	shl al, 4
0046+  0A57 8C          	or al, bl
0047+  0A58 E5          	pop b
0048+  0A59 09          	ret	
0049+  0A5A             
0050+  0A5A             
0051+  0A5A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  0A5A             ; printf
0053+  0A5A             ; no need for explanations!
0054+  0A5A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0A5A             printf:
0056+  0A5A 09          	ret
0057+  0A5B             
0058+  0A5B             
0059+  0A5B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  0A5B             ; scanf
0061+  0A5B             ; no need for explanations!
0062+  0A5B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  0A5B             scanf:
0064+  0A5B 09          	ret
0065+  0A5C             
0066+  0A5C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  0A5C             ; ITOA
0068+  0A5C             ; 8bit value in BL
0069+  0A5C             ; 2 byte ASCII result in A
0070+  0A5C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  0A5C             itoa:
0072+  0A5C DA          	push d
0073+  0A5D D8          	push b
0074+  0A5E A7 00       	mov bh, 0
0075+  0A60 FD A4 04    	shr bl, 4	
0076+  0A63 74          	mov d, b
0077+  0A64 1F 1A 0A    	mov al, [d + s_hex_digits]
0078+  0A67 23          	mov ah, al
0079+  0A68             	
0080+  0A68 E5          	pop b
0081+  0A69 D8          	push b
0082+  0A6A A7 00       	mov bh, 0
0083+  0A6C FD 87 0F    	and bl, $0F
0084+  0A6F 74          	mov d, b
0085+  0A70 1F 1A 0A    	mov al, [d + s_hex_digits]
0086+  0A73 E5          	pop b
0087+  0A74 E7          	pop d
0088+  0A75 09          	ret
0089+  0A76             
0090+  0A76             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  0A76             ; HEX STRING TO BINARY
0092+  0A76             ; di = destination address
0093+  0A76             ; si = source
0094+  0A76             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  0A76             hex_to_int:
0096+  0A76             hex_to_int_L1:
0097+  0A76 F6          	lodsb					; load from [SI] to AL
0098+  0A77 B9 00       	cmp al, 0				; check if ASCII 0
0099+  0A79 C6 86 0A    	jz hex_to_int_ret
0100+  0A7C 36          	mov bh, al
0101+  0A7D F6          	lodsb
0102+  0A7E 2F          	mov bl, al
0103+  0A7F 07 4A 0A    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  0A82 F7          	stosb					; store AL to [DI]
0105+  0A83 0A 76 0A    	jmp hex_to_int_L1
0106+  0A86             hex_to_int_ret:
0107+  0A86 09          	ret		
0108+  0A87             
0109+  0A87             
0110+  0A87             
0111+  0A87             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  0A87             ; GETCHAR
0113+  0A87             ; char in ah
0114+  0A87             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  0A87             getchar:
0116+  0A87 DB          	push al
0117+  0A88             getchar_retry:
0118+  0A88 FD 0C       	sti
0119+  0A8A 19 01       	mov al, 1
0120+  0A8C 05 03       	syscall sys_io			; receive in AH
0121+  0A8E B9 00       	cmp al, 0			; check if any char was receive
0122+  0A90 C6 88 0A    	je getchar_retry
0123+  0A93 E8          	pop al
0124+  0A94 09          	ret
0125+  0A95             
0126+  0A95             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  0A95             ; PUTCHAR
0128+  0A95             ; char in ah
0129+  0A95             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0A95             putchar:
0131+  0A95 D7          	push a
0132+  0A96 19 00       	mov al, 0
0133+  0A98 05 03       	syscall sys_io			; char in AH
0134+  0A9A E4          	pop a
0135+  0A9B 09          	ret
0136+  0A9C             
0137+  0A9C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  0A9C             ;; INPUT A STRING
0139+  0A9C             ;; terminates with null
0140+  0A9C             ;; pointer in D
0141+  0A9C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  0A9C             gets:
0143+  0A9C D7          	push a
0144+  0A9D DA          	push d
0145+  0A9E             gets_loop:
0146+  0A9E FD 0C       	sti
0147+  0AA0 19 01       	mov al, 1
0148+  0AA2 05 03       	syscall sys_io			; receive in AH
0149+  0AA4 B9 00       	cmp al, 0				; check error code (AL)
0150+  0AA6 C6 9E 0A    	je gets_loop			; if no char received, retry
0151+  0AA9             
0152+  0AA9 76 1B       	cmp ah, 27
0153+  0AAB C6 CC 0A    	je gets_telnet_escape
0154+  0AAE 76 0A       	cmp ah, $0A				; LF
0155+  0AB0 C6 25 0B    	je gets_end
0156+  0AB3 76 0D       	cmp ah, $0D				; CR
0157+  0AB5 C6 25 0B    	je gets_end
0158+  0AB8 76 5C       	cmp ah, $5C				; '\\'
0159+  0ABA C6 FC 0A    	je gets_escape
0160+  0ABD             	
0161+  0ABD 76 08       	cmp ah, $08			; check for backspace
0162+  0ABF C6 C8 0A    	je gets_backspace
0163+  0AC2             
0164+  0AC2 1A          	mov al, ah
0165+  0AC3 3E          	mov [d], al
0166+  0AC4 79          	inc d
0167+  0AC5 0A 9E 0A    	jmp gets_loop
0168+  0AC8             gets_backspace:
0169+  0AC8 7F          	dec d
0170+  0AC9 0A 9E 0A    	jmp gets_loop
0171+  0ACC             gets_telnet_escape:
0172+  0ACC FD 0C       	sti
0173+  0ACE 19 01       	mov al, 1
0174+  0AD0 05 03       	syscall sys_io				; receive in AH without echo
0175+  0AD2 B9 00       	cmp al, 0					; check error code (AL)
0176+  0AD4 C6 CC 0A    	je gets_telnet_escape		; if no char received, retry
0177+  0AD7 76 5B       	cmp ah, '['
0178+  0AD9 C7 9E 0A    	jne gets_loop
0179+  0ADC             gets_telnet_escape_phase2:
0180+  0ADC FD 0C       	sti
0181+  0ADE 19 01       	mov al, 1
0182+  0AE0 05 03       	syscall sys_io					; receive in AH without echo
0183+  0AE2 B9 00       	cmp al, 0						; check error code (AL)
0184+  0AE4 C6 DC 0A    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  0AE7 76 44       	cmp ah, 'D'
0186+  0AE9 C6 F4 0A    	je gets_left_arrow
0187+  0AEC 76 43       	cmp ah, 'C'
0188+  0AEE C6 F8 0A    	je gets_right_arrow
0189+  0AF1 0A 9E 0A    	jmp gets_loop
0190+  0AF4             gets_left_arrow:
0191+  0AF4 7F          	dec d
0192+  0AF5 0A 9E 0A    	jmp gets_loop
0193+  0AF8             gets_right_arrow:
0194+  0AF8 79          	inc d
0195+  0AF9 0A 9E 0A    	jmp gets_loop
0196+  0AFC             gets_escape:
0197+  0AFC FD 0C       	sti
0198+  0AFE 19 01       	mov al, 1
0199+  0B00 05 03       	syscall sys_io			; receive in AH
0200+  0B02 B9 00       	cmp al, 0				; check error code (AL)
0201+  0B04 C6 FC 0A    	je gets_escape			; if no char received, retry
0202+  0B07 76 6E       	cmp ah, 'n'
0203+  0B09 C6 17 0B    	je gets_LF
0204+  0B0C 76 72       	cmp ah, 'r'
0205+  0B0E C6 1E 0B    	je gets_CR
0206+  0B11 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  0B12 3E          	mov [d], al
0208+  0B13 79          	inc d
0209+  0B14 0A 9E 0A    	jmp gets_loop
0210+  0B17             gets_LF:
0211+  0B17 19 0A       	mov al, $0A
0212+  0B19 3E          	mov [d], al
0213+  0B1A 79          	inc d
0214+  0B1B 0A 9E 0A    	jmp gets_loop
0215+  0B1E             gets_CR:
0216+  0B1E 19 0D       	mov al, $0D
0217+  0B20 3E          	mov [d], al
0218+  0B21 79          	inc d
0219+  0B22 0A 9E 0A    	jmp gets_loop
0220+  0B25             gets_end:
0221+  0B25 19 00       	mov al, 0
0222+  0B27 3E          	mov [d], al				; terminate string
0223+  0B28 E7          	pop d
0224+  0B29 E4          	pop a
0225+  0B2A 09          	ret
0226+  0B2B             
0227+  0B2B             
0228+  0B2B             
0229+  0B2B             
0230+  0B2B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  0B2B             ;; INPUT TEXT
0232+  0B2B             ;; terminated with CTRL+D
0233+  0B2B             ;; pointer in D
0234+  0B2B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  0B2B             gettxt:
0236+  0B2B D7          	push a
0237+  0B2C DA          	push d
0238+  0B2D             gettxt_loop:
0239+  0B2D 19 01       	mov al, 1
0240+  0B2F 05 03       	syscall sys_io			; receive in AH
0241+  0B31 B9 00       	cmp al, 0				; check error code (AL)
0242+  0B33 C6 2D 0B    	je gettxt_loop		; if no char received, retry
0243+  0B36 76 04       	cmp ah, 4			; EOT
0244+  0B38 C6 76 0B    	je gettxt_end
0245+  0B3B 76 08       	cmp ah, $08			; check for backspace
0246+  0B3D C6 72 0B    	je gettxt_backspace
0247+  0B40 76 5C       	cmp ah, $5C				; '\\'
0248+  0B42 C6 4B 0B    	je gettxt_escape
0249+  0B45 1A          	mov al, ah
0250+  0B46 3E          	mov [d], al
0251+  0B47 79          	inc d
0252+  0B48 0A 2D 0B    	jmp gettxt_loop
0253+  0B4B             gettxt_escape:
0254+  0B4B 19 01       	mov al, 1
0255+  0B4D 05 03       	syscall sys_io			; receive in AH
0256+  0B4F B9 00       	cmp al, 0				; check error code (AL)
0257+  0B51 C6 4B 0B    	je gettxt_escape		; if no char received, retry
0258+  0B54 76 6E       	cmp ah, 'n'
0259+  0B56 C6 64 0B    	je gettxt_LF
0260+  0B59 76 72       	cmp ah, 'r'
0261+  0B5B C6 6B 0B    	je gettxt_CR
0262+  0B5E 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  0B5F 3E          	mov [d], al
0264+  0B60 79          	inc d
0265+  0B61 0A 2D 0B    	jmp gettxt_loop
0266+  0B64             gettxt_LF:
0267+  0B64 19 0A       	mov al, $0A
0268+  0B66 3E          	mov [d], al
0269+  0B67 79          	inc d
0270+  0B68 0A 2D 0B    	jmp gettxt_loop
0271+  0B6B             gettxt_CR:
0272+  0B6B 19 0D       	mov al, $0D
0273+  0B6D 3E          	mov [d], al
0274+  0B6E 79          	inc d
0275+  0B6F 0A 2D 0B    	jmp gettxt_loop
0276+  0B72             gettxt_backspace:
0277+  0B72 7F          	dec d
0278+  0B73 0A 2D 0B    	jmp gettxt_loop
0279+  0B76             gettxt_end:
0280+  0B76 19 00       	mov al, 0
0281+  0B78 3E          	mov [d], al				; terminate string
0282+  0B79 E7          	pop d
0283+  0B7A E4          	pop a
0284+  0B7B 09          	ret
0285+  0B7C             
0286+  0B7C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  0B7C             ; PRINT NEW LINE
0288+  0B7C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  0B7C             printnl:
0290+  0B7C D7          	push a
0291+  0B7D 10 00 0A    	mov a, $0A00
0292+  0B80 05 03       	syscall sys_io
0293+  0B82 10 00 0D    	mov a, $0D00
0294+  0B85 05 03       	syscall sys_io
0295+  0B87 E4          	pop a
0296+  0B88 09          	ret
0297+  0B89             
0298+  0B89             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  0B89             ; strtoint
0300+  0B89             ; 4 digit hex string number in d
0301+  0B89             ; integer returned in A
0302+  0B89             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  0B89             strtointx:
0304+  0B89 D8          	push b
0305+  0B8A 32          	mov bl, [d]
0306+  0B8B 37          	mov bh, bl
0307+  0B8C 33 01 00    	mov bl, [d + 1]
0308+  0B8F 07 4A 0A    	call atoi				; convert to int in AL
0309+  0B92 23          	mov ah, al				; move to AH
0310+  0B93 33 02 00    	mov bl, [d + 2]
0311+  0B96 37          	mov bh, bl
0312+  0B97 33 03 00    	mov bl, [d + 3]
0313+  0B9A 07 4A 0A    	call atoi				; convert to int in AL
0314+  0B9D E5          	pop b
0315+  0B9E 09          	ret
0316+  0B9F             
0317+  0B9F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  0B9F             ; strtoint
0319+  0B9F             ; 5 digit base10 string number in d
0320+  0B9F             ; integer returned in A
0321+  0B9F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  0B9F             strtoint:
0323+  0B9F E2          	push si
0324+  0BA0 D8          	push b
0325+  0BA1 D9          	push c
0326+  0BA2 DA          	push d
0327+  0BA3 07 CA 09    	call strlen			; get string length in C
0328+  0BA6 7E          	dec c
0329+  0BA7 FD 4E       	mov si, d
0330+  0BA9 12          	mov a, c
0331+  0BAA FD 99       	shl a
0332+  0BAC 3B 32 0A    	mov d, table_power
0333+  0BAF 59          	add d, a
0334+  0BB0 38 00 00    	mov c, 0
0335+  0BB3             strtoint_L0:
0336+  0BB3 F6          	lodsb			; load ASCII to al
0337+  0BB4 B9 00       	cmp al, 0
0338+  0BB6 C6 C9 0B    	je strtoint_end
0339+  0BB9 6F 30       	sub al, $30		; make into integer
0340+  0BBB 22 00       	mov ah, 0
0341+  0BBD 2A          	mov b, [d]
0342+  0BBE AC          	mul a, b			; result in B since it fits in 16bits
0343+  0BBF 11          	mov a, b
0344+  0BC0 28          	mov b, c
0345+  0BC1 54          	add a, b
0346+  0BC2 39          	mov c, a
0347+  0BC3 63 02 00    	sub d, 2
0348+  0BC6 0A B3 0B    	jmp strtoint_L0
0349+  0BC9             strtoint_end:
0350+  0BC9 12          	mov a, c
0351+  0BCA E7          	pop d
0352+  0BCB E6          	pop c
0353+  0BCC E5          	pop b
0354+  0BCD EF          	pop si
0355+  0BCE 09          	ret
0356+  0BCF             
0357+  0BCF             
0358+  0BCF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  0BCF             ; PRINT NULL TERMINATED STRING
0360+  0BCF             ; pointer in D
0361+  0BCF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  0BCF             puts:
0363+  0BCF D7          	push a
0364+  0BD0 DA          	push d
0365+  0BD1             puts_L1:
0366+  0BD1 1E          	mov al, [d]
0367+  0BD2 B9 00       	cmp al, 0
0368+  0BD4 C6 E0 0B    	jz puts_END
0369+  0BD7 23          	mov ah, al
0370+  0BD8 19 00       	mov al, 0
0371+  0BDA 05 03       	syscall sys_io
0372+  0BDC 79          	inc d
0373+  0BDD 0A D1 0B    	jmp puts_L1
0374+  0BE0             puts_END:
0375+  0BE0 E7          	pop d
0376+  0BE1 E4          	pop a
0377+  0BE2 09          	ret
0378+  0BE3             
0379+  0BE3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  0BE3             ; PRINT N SIZE STRING
0381+  0BE3             ; pointer in D
0382+  0BE3             ; size in C
0383+  0BE3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  0BE3             putsn:
0385+  0BE3 DB          	push al
0386+  0BE4 DA          	push d
0387+  0BE5 D9          	push c
0388+  0BE6             putsn_L0:
0389+  0BE6 1E          	mov al, [d]
0390+  0BE7 23          	mov ah, al
0391+  0BE8 19 00       	mov al, 0
0392+  0BEA 05 03       	syscall sys_io
0393+  0BEC 79          	inc d
0394+  0BED 7E          	dec c	
0395+  0BEE C2 00 00    	cmp c, 0
0396+  0BF1 C7 E6 0B    	jne putsn_L0
0397+  0BF4             putsn_end:
0398+  0BF4 E6          	pop c
0399+  0BF5 E7          	pop d
0400+  0BF6 E8          	pop al
0401+  0BF7 09          	ret
0402+  0BF8             
0403+  0BF8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  0BF8             ; print 16bit decimal number
0405+  0BF8             ; input number in A
0406+  0BF8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  0BF8             print_u16d:
0408+  0BF8 D7          	push a
0409+  0BF9 D8          	push b
0410+  0BFA 26 10 27    	mov b, 10000
0411+  0BFD AE          	div a, b			; get 10000's coeff.
0412+  0BFE 07 20 0C    	call print_number
0413+  0C01 11          	mov a, b
0414+  0C02 26 E8 03    	mov b, 1000
0415+  0C05 AE          	div a, b			; get 1000's coeff.
0416+  0C06 07 20 0C    	call print_number
0417+  0C09 11          	mov a, b
0418+  0C0A 26 64 00    	mov b, 100
0419+  0C0D AE          	div a, b
0420+  0C0E 07 20 0C    	call print_number
0421+  0C11 11          	mov a, b
0422+  0C12 26 0A 00    	mov b, 10
0423+  0C15 AE          	div a, b
0424+  0C16 07 20 0C    	call print_number
0425+  0C19 1B          	mov al, bl			; 1's coeff in bl
0426+  0C1A 07 20 0C    	call print_number
0427+  0C1D E5          	pop b
0428+  0C1E E4          	pop a
0429+  0C1F 09          	ret
0430+  0C20             
0431+  0C20             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0432+  0C20             ; print AL
0433+  0C20             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0434+  0C20             print_number:
0435+  0C20 6A 30       	add al, $30
0436+  0C22 23          	mov ah, al
0437+  0C23 07 95 0A    	call putchar
0438+  0C26 09          	ret
0439+  0C27             
0440+  0C27             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0441+  0C27             ; PRINT 16BIT HEX INTEGER
0442+  0C27             ; integer value in reg B
0443+  0C27             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0444+  0C27             print_u16x:
0445+  0C27 D7          	push a
0446+  0C28 D8          	push b
0447+  0C29 DD          	push bl
0448+  0C2A 30          	mov bl, bh
0449+  0C2B 07 5C 0A    	call itoa				; convert bh to char in A
0450+  0C2E 2F          	mov bl, al				; save al
0451+  0C2F 19 00       	mov al, 0
0452+  0C31 05 03       	syscall sys_io				; display AH
0453+  0C33 24          	mov ah, bl				; retrieve al
0454+  0C34 19 00       	mov al, 0
0455+  0C36 05 03       	syscall sys_io				; display AL
0456+  0C38             
0457+  0C38 EA          	pop bl
0458+  0C39 07 5C 0A    	call itoa				; convert bh to char in A
0459+  0C3C 2F          	mov bl, al				; save al
0460+  0C3D 19 00       	mov al, 0
0461+  0C3F 05 03       	syscall sys_io				; display AH
0462+  0C41 24          	mov ah, bl				; retrieve al
0463+  0C42 19 00       	mov al, 0
0464+  0C44 05 03       	syscall sys_io				; display AL
0465+  0C46             
0466+  0C46 E5          	pop b
0467+  0C47 E4          	pop a
0468+  0C48 09          	ret
0469+  0C49             
0470+  0C49             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0471+  0C49             ; INPUT 16BIT HEX INTEGER
0472+  0C49             ; read 16bit integer into A
0473+  0C49             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0474+  0C49             scan_u16x:
0475+  0C49 F8 10 00    	enter 16
0476+  0C4C D8          	push b
0477+  0C4D DA          	push d
0478+  0C4E             
0479+  0C4E FA F1 FF    	lea d, [bp + -15]
0480+  0C51 07 9C 0A    	call gets				; get number
0481+  0C54             
0482+  0C54 32          	mov bl, [d]
0483+  0C55 37          	mov bh, bl
0484+  0C56 33 01 00    	mov bl, [d + 1]
0485+  0C59 07 4A 0A    	call atoi				; convert to int in AL
0486+  0C5C 23          	mov ah, al				; move to AH
0487+  0C5D             
0488+  0C5D 33 02 00    	mov bl, [d + 2]
0489+  0C60 37          	mov bh, bl
0490+  0C61 33 03 00    	mov bl, [d + 3]
0491+  0C64 07 4A 0A    	call atoi				; convert to int in AL
0492+  0C67             
0493+  0C67 E7          	pop d
0494+  0C68 E5          	pop b
0495+  0C69 F9          	leave
0496+  0C6A 09          	ret
0497+  0C6B             
0498+  0C6B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0499+  0C6B             ; PRINT 8bit HEX INTEGER
0500+  0C6B             ; integer value in reg bl
0501+  0C6B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0502+  0C6B             print_u8x:
0503+  0C6B D7          	push a
0504+  0C6C DD          	push bl
0505+  0C6D             
0506+  0C6D 07 5C 0A    	call itoa				; convert bl to char in A
0507+  0C70 2F          	mov bl, al				; save al
0508+  0C71 19 00       	mov al, 0
0509+  0C73 05 03       	syscall sys_io				; display AH
0510+  0C75 24          	mov ah, bl				; retrieve al
0511+  0C76 19 00       	mov al, 0
0512+  0C78 05 03       	syscall sys_io				; display AL
0513+  0C7A             
0514+  0C7A EA          	pop bl
0515+  0C7B E4          	pop a
0516+  0C7C 09          	ret
0517+  0C7D             
0518+  0C7D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0519+  0C7D             ; print 8bit decimal unsigned number
0520+  0C7D             ; input number in AL
0521+  0C7D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0522+  0C7D             print_u8d:
0523+  0C7D D7          	push a
0524+  0C7E D8          	push b
0525+  0C7F             
0526+  0C7F 22 00       	mov ah, 0
0527+  0C81 26 64 00    	mov b, 100
0528+  0C84 AE          	div a, b
0529+  0C85 D8          	push b			; save remainder
0530+  0C86 B9 00       	cmp al, 0
0531+  0C88 C6 92 0C    	je skip100
0532+  0C8B 6A 30       	add al, $30
0533+  0C8D 23          	mov ah, al
0534+  0C8E 19 00       	mov al, 0
0535+  0C90 05 03       	syscall sys_io	; print coeff
0536+  0C92             skip100:
0537+  0C92 E4          	pop a
0538+  0C93 22 00       	mov ah, 0
0539+  0C95 26 0A 00    	mov b, 10
0540+  0C98 AE          	div a, b
0541+  0C99 D8          	push b			; save remainder
0542+  0C9A B9 00       	cmp al, 0
0543+  0C9C C6 A6 0C    	je skip10
0544+  0C9F 6A 30       	add al, $30
0545+  0CA1 23          	mov ah, al
0546+  0CA2 19 00       	mov al, 0
0547+  0CA4 05 03       	syscall sys_io	; print coeff
0548+  0CA6             skip10:
0549+  0CA6 E4          	pop a
0550+  0CA7 1B          	mov al, bl
0551+  0CA8 6A 30       	add al, $30
0552+  0CAA 23          	mov ah, al
0553+  0CAB 19 00       	mov al, 0
0554+  0CAD 05 03       	syscall sys_io	; print coeff
0555+  0CAF E5          	pop b
0556+  0CB0 E4          	pop a
0557+  0CB1 09          	ret
0558+  0CB2             
0559+  0CB2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0560+  0CB2             ; INPUT 8BIT HEX INTEGER
0561+  0CB2             ; read 8bit integer into AL
0562+  0CB2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0563+  0CB2             scan_u8x:
0564+  0CB2 F8 04 00    	enter 4
0565+  0CB5 D8          	push b
0566+  0CB6 DA          	push d
0567+  0CB7             
0568+  0CB7 FA FD FF    	lea d, [bp + -3]
0569+  0CBA 07 9C 0A    	call gets				; get number
0570+  0CBD             
0571+  0CBD 32          	mov bl, [d]
0572+  0CBE 37          	mov bh, bl
0573+  0CBF 33 01 00    	mov bl, [d + 1]
0574+  0CC2 07 4A 0A    	call atoi				; convert to int in AL
0575+  0CC5             
0576+  0CC5 E7          	pop d
0577+  0CC6 E5          	pop b
0578+  0CC7 F9          	leave
0579+  0CC8 09          	ret
0580+  0CC9             
0581+  0CC9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0582+  0CC9             ; input decimal number
0583+  0CC9             ; result in A
0584+  0CC9             ; 655'\0'
0585+  0CC9             ; low--------high
0586+  0CC9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  0CC9             scan_u16d:
0588+  0CC9 F8 08 00    	enter 8
0589+  0CCC E2          	push si
0590+  0CCD D8          	push b
0591+  0CCE D9          	push c
0592+  0CCF DA          	push d
0593+  0CD0 FA F9 FF    	lea d, [bp +- 7]
0594+  0CD3 07 9C 0A    	call gets
0595+  0CD6 07 CA 09    	call strlen			; get string length in C
0596+  0CD9 7E          	dec c
0597+  0CDA FD 4E       	mov si, d
0598+  0CDC 12          	mov a, c
0599+  0CDD FD 99       	shl a
0600+  0CDF 3B 32 0A    	mov d, table_power
0601+  0CE2 59          	add d, a
0602+  0CE3 38 00 00    	mov c, 0
0603+  0CE6             mul_loop:
0604+  0CE6 F6          	lodsb			; load ASCII to al
0605+  0CE7 B9 00       	cmp al, 0
0606+  0CE9 C6 FC 0C    	je mul_exit
0607+  0CEC 6F 30       	sub al, $30		; make into integer
0608+  0CEE 22 00       	mov ah, 0
0609+  0CF0 2A          	mov b, [d]
0610+  0CF1 AC          	mul a, b			; result in B since it fits in 16bits
0611+  0CF2 11          	mov a, b
0612+  0CF3 28          	mov b, c
0613+  0CF4 54          	add a, b
0614+  0CF5 39          	mov c, a
0615+  0CF6 63 02 00    	sub d, 2
0616+  0CF9 0A E6 0C    	jmp mul_loop
0617+  0CFC             mul_exit:
0618+  0CFC 12          	mov a, c
0619+  0CFD E7          	pop d
0620+  0CFE E6          	pop c
0621+  0CFF E5          	pop b
0622+  0D00 EF          	pop si
0623+  0D01 F9          	leave
0624+  0D02 09          	ret
0037   0D03             .include "ctype.asm"
0001+  0D03             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0D03             ; ctype.s
0003+  0D03             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0D03             
0005+  0D03             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  0D03             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  0D03             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  0D03             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  0D03             ;; characters are supported.
0010+  0D03             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  0D03             ;; isalnum 
0012+  0D03             ;; isalpha 
0013+  0D03             ;; islower 
0014+  0D03             ;; isupper 
0015+  0D03             ;; isdigit 
0016+  0D03             ;; isxdigit
0017+  0D03             ;; iscntrl 
0018+  0D03             ;; isgraph 
0019+  0D03             ;; isspace 
0020+  0D03             ;; isblank 
0021+  0D03             ;; isprint 
0022+  0D03             ;; ispunct 
0023+  0D03             ;; tolower 
0024+  0D03             ;; toupper
0025+  0D03             
0026+  0D03             
0027+  0D03             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  0D03             ;; IS ALPHANUMERIC
0029+  0D03             ;; sets ZF according with result
0030+  0D03             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  0D03             isalnum:
0032+  0D03 07 20 0D    	call isalpha
0033+  0D06 C6 0C 0D    	je isalnum_exit
0034+  0D09 07 0D 0D    	call isdigit
0035+  0D0C             isalnum_exit:
0036+  0D0C 09          	ret	
0037+  0D0D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0D0D             ;; IS DIGIT
0039+  0D0D             ;; sets ZF according with result
0040+  0D0D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  0D0D             isdigit:
0042+  0D0D DB          	push al
0043+  0D0E B9 30       	cmp al, '0'
0044+  0D10 C8 1C 0D    	jlu isdigit_false
0045+  0D13 B9 39       	cmp al, '9'
0046+  0D15 D1 1C 0D    	jgu isdigit_false
0047+  0D18 87 00       	and al, 0	; set ZF
0048+  0D1A E8          	pop al
0049+  0D1B 09          	ret
0050+  0D1C             isdigit_false:
0051+  0D1C 8B 01       	or al, 1	; clear ZF
0052+  0D1E E8          	pop al
0053+  0D1F 09          	ret	
0054+  0D20             	
0055+  0D20             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  0D20             ;; IS ALPHA
0057+  0D20             ;; sets ZF according with result
0058+  0D20             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  0D20             isalpha:
0060+  0D20 DB          	push al
0061+  0D21 B9 5F       	cmp al, '_'
0062+  0D23 C6 43 0D    	je isalpha_true
0063+  0D26 B9 2E       	cmp al, '.'
0064+  0D28 C6 43 0D    	je isalpha_true
0065+  0D2B B9 41       	cmp al, 'A'
0066+  0D2D C8 3F 0D    	jlu isalpha_false
0067+  0D30 B9 7A       	cmp al, 'z'
0068+  0D32 D1 3F 0D    	jgu isalpha_false
0069+  0D35 B9 5A       	cmp al, 'Z'
0070+  0D37 D0 43 0D    	jleu isalpha_true
0071+  0D3A B9 61       	cmp al, 'a'
0072+  0D3C C9 43 0D    	jgeu isalpha_true
0073+  0D3F             isalpha_false:
0074+  0D3F 8B 01       	or al, 1	; clear ZF
0075+  0D41 E8          	pop al
0076+  0D42 09          	ret
0077+  0D43             isalpha_true:
0078+  0D43 87 00       	and al, 0	; set ZF
0079+  0D45 E8          	pop al
0080+  0D46 09          	ret
0081+  0D47             
0082+  0D47             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  0D47             ;; IS PATH-ALPHA
0084+  0D47             ;; sets ZF according with result
0085+  0D47             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  0D47             ispath:
0087+  0D47 DB          	push al
0088+  0D48 07 0D 0D    	call isdigit
0089+  0D4B C6 75 0D    	je ispath_true
0090+  0D4E B9 5F       	cmp al, '_'
0091+  0D50 C6 75 0D    	je ispath_true
0092+  0D53 B9 2F       	cmp al, '/'
0093+  0D55 C6 75 0D    	je ispath_true
0094+  0D58 B9 2E       	cmp al, '.'
0095+  0D5A C6 75 0D    	je ispath_true
0096+  0D5D B9 41       	cmp al, 'A'
0097+  0D5F C8 71 0D    	jlu ispath_false
0098+  0D62 B9 7A       	cmp al, 'z'
0099+  0D64 D1 71 0D    	jgu ispath_false
0100+  0D67 B9 5A       	cmp al, 'Z'
0101+  0D69 D0 75 0D    	jleu ispath_true
0102+  0D6C B9 61       	cmp al, 'a'
0103+  0D6E C9 75 0D    	jgeu ispath_true
0104+  0D71             ispath_false:
0105+  0D71 8B 01       	or al, 1	; clear ZF
0106+  0D73 E8          	pop al
0107+  0D74 09          	ret
0108+  0D75             ispath_true:
0109+  0D75 87 00       	and al, 0	; set ZF
0110+  0D77 E8          	pop al
0111+  0D78 09          	ret
0112+  0D79             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  0D79             ;; IS SPACE
0114+  0D79             ;; sets ZF according with result
0115+  0D79             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  0D79             isspace:
0117+  0D79 B9 20       	cmp al, $20		; ' '
0118+  0D7B C6 8F 0D    	je isspace_exit
0119+  0D7E B9 09       	cmp al, $09		; '\t'
0120+  0D80 C6 8F 0D    	je isspace_exit
0121+  0D83 B9 0A       	cmp al, $0A		; '\n'
0122+  0D85 C6 8F 0D    	je isspace_exit
0123+  0D88 B9 0D       	cmp al, $0D		; '\r'
0124+  0D8A C6 8F 0D    	je isspace_exit
0125+  0D8D B9 0B       	cmp al, $0B		; '\v'
0126+  0D8F             isspace_exit:
0127+  0D8F 09          	ret	
0128+  0D90             
0129+  0D90             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0D90             ; TO LOWER
0131+  0D90             ; input in AL
0132+  0D90             ; output in AL
0133+  0D90             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  0D90             to_lower:
0135+  0D90 B9 5A       	cmp al, 'Z'
0136+  0D92 D1 97 0D    	jgu to_lower_ret
0137+  0D95 6A 20       	add al, $20				; convert to lower case
0138+  0D97             to_lower_ret:
0139+  0D97 09          	ret
0140+  0D98             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  0D98             ; TO UPPER
0142+  0D98             ; input in AL
0143+  0D98             ; output in AL
0144+  0D98             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  0D98             to_upper:
0146+  0D98 B9 61       	cmp al, 'a'
0147+  0D9A C8 9F 0D    	jlu to_upper_ret
0148+  0D9D 6F 20       	sub al, $20			; convert to upper case
0149+  0D9F             to_upper_ret:
0150+  0D9F 09          	ret
0151+  0DA0             
0038   0DA0             
0039   0DA0             transient_area:
0040   0DA0             
0041   0DA0             .endtasm: Number of errors = 0
