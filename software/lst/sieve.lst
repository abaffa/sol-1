0001   0000             .include "kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0002   0000             
0003   0400             .org PROC_TEXT_ORG			; origin at 1024
0004   0400             
0005   0400             TRUE:	.equ 1
0006   0400             FALSE:	.equ 0
0007   0400             SIZE:	.equ 8190
0008   0400             SIZEP1:	.equ 8191
0009   0400             
0010   0400             main:
0011   0400 3B A2 04    	mov d, s_title
0012   0403 07 E0 07    	call puts
0013   0406             
0014   0406 10 01 00    	mov a, 1
0015   0409 42 92 05    	mov [iter], a
0016   040C             L0:
0017   040C FD 10       	cla
0018   040E 42 90 05    	mov [count], a
0019   0411 42 8A 05    	mov [i], a
0020   0414             L0_0:
0021   0414 14 8A 05    	mov a, [i]
0022   0417 3C          	mov d, a
0023   0418 19 01       	mov al, TRUE
0024   041A 3F 14 09    	mov [d + flags], al
0025   041D 14 8A 05    	mov a, [i]
0026   0420 77          	inc a
0027   0421 42 8A 05    	mov [i], a
0028   0424 AF FE 1F    	cmp a, SIZE
0029   0427 D0 14 04    	jleu L0_0	
0030   042A             
0031   042A 10 00 00    	mov a, 0
0032   042D 42 8A 05    	mov [i], a
0033   0430             L0_1:
0034   0430 14 8A 05    	mov a, [i]
0035   0433 3C          	mov d, a
0036   0434 1F 14 09    	mov al, [d + flags]
0037   0437 B9 01       	cmp al, TRUE
0038   0439 C6 59 04    	je IF_0_TRUE
0039   043C             L0_1_COND:	
0040   043C 14 8A 05    	mov a, [i]
0041   043F 77          	inc a
0042   0440 42 8A 05    	mov [i], a
0043   0443 AF FE 1F    	cmp a, SIZE
0044   0446 D0 30 04    	jleu L0_1	
0045   0449             L0_COND:
0046   0449 14 92 05    	mov a, [iter]
0047   044C 77          	inc a
0048   044D 42 92 05    	mov [iter], a
0049   0450 AF 0A 00    	cmp a, 10
0050   0453 D0 0C 04    	jleu L0
0051   0456 0A 94 04    	jmp L0_EXIT
0052   0459             IF_0_TRUE:
0053   0459 29 8A 05    	mov b, [i]
0054   045C 14 8A 05    	mov a, [i]
0055   045F 54          	add a, b
0056   0460 53 03 00    	add a, 3
0057   0463 42 8C 05    	mov [prime], a		; prime = i + i + 3
0058   0466 54          	add a, b
0059   0467 42 8E 05    	mov [k], a			; k = i + prime	
0060   046A             WHILE:
0061   046A 14 8E 05    	mov a, [k]
0062   046D 26 FE 1F    	mov b, SIZE
0063   0470 B0          	cmp a, b
0064   0471 D1 8A 04    	jgu WHILE_EXIT
0065   0474 14 8E 05    	mov a, [k]
0066   0477 3C          	mov d, a
0067   0478 19 00       	mov al, FALSE
0068   047A 3F 14 09    	mov [d + flags], al
0069   047D 14 8E 05    	mov a, [k]
0070   0480 29 8C 05    	mov b, [prime]
0071   0483 54          	add a, b
0072   0484 42 8E 05    	mov [k], a
0073   0487 0A 6A 04    	jmp WHILE
0074   048A             WHILE_EXIT:	
0075   048A 14 90 05    	mov a, [count]
0076   048D 77          	inc a
0077   048E 42 90 05    	mov [count], a	
0078   0491 0A 3C 04    	jmp L0_1_COND
0079   0494             
0080   0494             L0_EXIT:
0081   0494 14 90 05    	mov a, [count]
0082   0497 07 09 08    	call print_u16d
0083   049A 3B 4D 05    	mov d, s_result
0084   049D 07 E0 07    	call puts
0085   04A0             
0086   04A0 05 0B       	syscall sys_terminate_proc
0087   04A2             
0088   04A2 2D 2D 2D 2D s_title:	.db "-----------------------------------------------\n"
0088   04A6 2D 2D 2D 2D 
0088   04AA 2D 2D 2D 2D 
0088   04AE 2D 2D 2D 2D 
0088   04B2 2D 2D 2D 2D 
0088   04B6 2D 2D 2D 2D 
0088   04BA 2D 2D 2D 2D 
0088   04BE 2D 2D 2D 2D 
0088   04C2 2D 2D 2D 2D 
0088   04C6 2D 2D 2D 2D 
0088   04CA 2D 2D 2D 2D 
0088   04CE 2D 2D 2D 0A 
0089   04D2 42 79 74 65 			.db "Byte Magazine\'s Sieve of Erastothenes Benchmark\n"
0089   04D6 20 4D 61 67 
0089   04DA 61 7A 69 6E 
0089   04DE 65 27 73 20 
0089   04E2 53 69 65 76 
0089   04E6 65 20 6F 66 
0089   04EA 20 45 72 61 
0089   04EE 73 74 6F 74 
0089   04F2 68 65 6E 65 
0089   04F6 73 20 42 65 
0089   04FA 6E 63 68 6D 
0089   04FE 61 72 6B 0A 
0090   0502 53 69 7A 65 			.db "Size: 8192\n"
0090   0506 3A 20 38 31 
0090   050A 39 32 0A 
0091   050D 49 74 65 72 			.db "Iterations: 10\n"
0091   0511 61 74 69 6F 
0091   0515 6E 73 3A 20 
0091   0519 31 30 0A 
0092   051C 2D 2D 2D 2D 			.db "-----------------------------------------------\n", 0
0092   0520 2D 2D 2D 2D 
0092   0524 2D 2D 2D 2D 
0092   0528 2D 2D 2D 2D 
0092   052C 2D 2D 2D 2D 
0092   0530 2D 2D 2D 2D 
0092   0534 2D 2D 2D 2D 
0092   0538 2D 2D 2D 2D 
0092   053C 2D 2D 2D 2D 
0092   0540 2D 2D 2D 2D 
0092   0544 2D 2D 2D 2D 
0092   0548 2D 2D 2D 0A 
0092   054C 00 
0093   054D             
0094   054D 20 70 72 69 s_result:	.db " primes.\n"
0094   0551 6D 65 73 2E 
0094   0555 0A 
0095   0556 2D 2D 2D 2D 			.db "-----------------------------------------------\n", 0
0095   055A 2D 2D 2D 2D 
0095   055E 2D 2D 2D 2D 
0095   0562 2D 2D 2D 2D 
0095   0566 2D 2D 2D 2D 
0095   056A 2D 2D 2D 2D 
0095   056E 2D 2D 2D 2D 
0095   0572 2D 2D 2D 2D 
0095   0576 2D 2D 2D 2D 
0095   057A 2D 2D 2D 2D 
0095   057E 2D 2D 2D 2D 
0095   0582 2D 2D 2D 0A 
0095   0586 00 
0096   0587             
0097   0587 2C 20 00    s_comma:	.db ", ", 0
0098   058A             
0099   058A 00 00       i:		.dw
0100   058C 00 00       prime:	.dw
0101   058E 00 00       k:		.dw
0102   0590 00 00       count:	.dw
0103   0592 00 00       iter:	.dw
0104   0594             
0105   0594             
0106   0594             .include "stdio.asm"
0001+  0594             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0594             ; stdio.s
0003+  0594             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0594             .include "string.asm"
0001++ 0594             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0594             ; string.s
0003++ 0594             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0594             
0005++ 0594             
0006++ 0594             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0594             ; strrev
0008++ 0594             ; reverse a string
0009++ 0594             ; D = string address
0010++ 0594             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0594             ; 01234
0012++ 0594             strrev:
0013++ 0594 4B          	pusha
0014++ 0595 07 DB 05    	call strlen	; length in C
0015++ 0598 12          	mov a, c
0016++ 0599 AF 01 00    	cmp a, 1
0017++ 059C D0 B6 05    	jleu strrev_end	; check string length. string len must be > 1
0018++ 059F 7D          	dec a
0019++ 05A0 FD 4E       	mov si, d	; beginning of string
0020++ 05A2 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 05A4 59          	add d, a	; end of string
0022++ 05A5 12          	mov a, c
0023++ 05A6 FD 9B       	shr a		; divide by 2
0024++ 05A8 39          	mov c, a	; C now counts the steps
0025++ 05A9             strrev_L0:
0026++ 05A9 32          	mov bl, [d]	; save load right-side char into BL
0027++ 05AA F6          	lodsb		; load left-side char into AL; increase SI
0028++ 05AB 3E          	mov [d], al	; store left char into right side
0029++ 05AC 1B          	mov al, bl
0030++ 05AD F7          	stosb		; store right-side char into left-side; increase DI
0031++ 05AE 7E          	dec c
0032++ 05AF 7F          	dec d
0033++ 05B0 C2 00 00    	cmp c, 0
0034++ 05B3 C7 A9 05    	jne strrev_L0
0035++ 05B6             strrev_end:
0036++ 05B6 4C          	popa
0037++ 05B7 09          	ret
0038++ 05B8             	
0039++ 05B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 05B8             ; strchr
0041++ 05B8             ; search string in D for char in AL
0042++ 05B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 05B8             strchr:
0044++ 05B8             strchr_L0:
0045++ 05B8 32          	mov bl, [d]
0046++ 05B9 C1 00       	cmp bl, 0
0047++ 05BB C6 C6 05    	je strchr_end
0048++ 05BE BA          	cmp al, bl
0049++ 05BF C6 C6 05    	je strchr_end
0050++ 05C2 79          	inc d
0051++ 05C3 0A B8 05    	jmp strchr_L0
0052++ 05C6             strchr_end:
0053++ 05C6 1B          	mov al, bl
0054++ 05C7 09          	ret
0055++ 05C8             
0056++ 05C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 05C8             ; strstr
0058++ 05C8             ; find sub-string
0059++ 05C8             ; str1 in SI
0060++ 05C8             ; str2 in DI
0061++ 05C8             ; SI points to end of source string
0062++ 05C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 05C8             strstr:
0064++ 05C8 DB          	push al
0065++ 05C9 DA          	push d
0066++ 05CA E3          	push di
0067++ 05CB             strstr_loop:
0068++ 05CB F3          	cmpsb					; compare a byte of the strings
0069++ 05CC C7 D7 05    	jne strstr_ret
0070++ 05CF FC 00 00    	lea d, [di + 0]
0071++ 05D2 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 05D4 C7 CB 05    	jne strstr_loop				; equal chars but not at end
0073++ 05D7             strstr_ret:
0074++ 05D7 F0          	pop di
0075++ 05D8 E7          	pop d
0076++ 05D9 E8          	pop al
0077++ 05DA 09          	ret
0078++ 05DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 05DB             ; length of null terminated string
0080++ 05DB             ; result in C
0081++ 05DB             ; pointer in D
0082++ 05DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 05DB             strlen:
0084++ 05DB DA          	push d
0085++ 05DC 38 00 00    	mov c, 0
0086++ 05DF             strlen_L1:
0087++ 05DF BD 00       	cmp byte [d], 0
0088++ 05E1 C6 E9 05    	je strlen_ret
0089++ 05E4 79          	inc d
0090++ 05E5 78          	inc c
0091++ 05E6 0A DF 05    	jmp strlen_L1
0092++ 05E9             strlen_ret:
0093++ 05E9 E7          	pop d
0094++ 05EA 09          	ret
0095++ 05EB             
0096++ 05EB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 05EB             ; STRCMP
0098++ 05EB             ; compare two strings
0099++ 05EB             ; str1 in SI
0100++ 05EB             ; str2 in DI
0101++ 05EB             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 05EB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 05EB             strcmp:
0104++ 05EB DB          	push al
0105++ 05EC DA          	push d
0106++ 05ED E3          	push di
0107++ 05EE E2          	push si
0108++ 05EF             strcmp_loop:
0109++ 05EF F3          	cmpsb					; compare a byte of the strings
0110++ 05F0 C7 FB 05    	jne strcmp_ret
0111++ 05F3 FB FF FF    	lea d, [si +- 1]
0112++ 05F6 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 05F8 C7 EF 05    	jne strcmp_loop				; equal chars but not at end
0114++ 05FB             strcmp_ret:
0115++ 05FB EF          	pop si
0116++ 05FC F0          	pop di
0117++ 05FD E7          	pop d
0118++ 05FE E8          	pop al
0119++ 05FF 09          	ret
0120++ 0600             
0121++ 0600             
0122++ 0600             ; STRCPY
0123++ 0600             ; copy null terminated string from SI to DI
0124++ 0600             ; source in SI
0125++ 0600             ; destination in DI
0126++ 0600             strcpy:
0127++ 0600 E2          	push si
0128++ 0601 E3          	push di
0129++ 0602 DB          	push al
0130++ 0603             strcpy_L1:
0131++ 0603 F6          	lodsb
0132++ 0604 F7          	stosb
0133++ 0605 B9 00       	cmp al, 0
0134++ 0607 C7 03 06    	jne strcpy_L1
0135++ 060A             strcpy_end:
0136++ 060A E8          	pop al
0137++ 060B F0          	pop di
0138++ 060C EF          	pop si
0139++ 060D 09          	ret
0140++ 060E             
0141++ 060E             ; STRCAT
0142++ 060E             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 060E             ; source in SI
0144++ 060E             ; destination in DI
0145++ 060E             strcat:
0146++ 060E E2          	push si
0147++ 060F E3          	push di
0148++ 0610 D7          	push a
0149++ 0611 DA          	push d
0150++ 0612 50          	mov a, di
0151++ 0613 3C          	mov d, a
0152++ 0614             strcat_goto_end_L1:
0153++ 0614 BD 00       	cmp byte[d], 0
0154++ 0616 C6 1D 06    	je strcat_start
0155++ 0619 79          	inc d
0156++ 061A 0A 14 06    	jmp strcat_goto_end_L1
0157++ 061D             strcat_start:
0158++ 061D FD 50       	mov di, d
0159++ 061F             strcat_L1:
0160++ 061F F6          	lodsb
0161++ 0620 F7          	stosb
0162++ 0621 B9 00       	cmp al, 0
0163++ 0623 C7 1F 06    	jne strcat_L1
0164++ 0626             strcat_end:
0165++ 0626 E7          	pop d
0166++ 0627 E4          	pop a
0167++ 0628 F0          	pop di
0168++ 0629 EF          	pop si
0169++ 062A 09          	ret
0005+  062B             
0006+  062B 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  062F 34 35 36 37 
0006+  0633 38 39 41 42 
0006+  0637 43 44 45 46 
0007+  063B 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  063F 1B 5B 48 00 
0008+  0643             
0009+  0643 01 00       table_power:.dw 1
0010+  0645 0A 00       			.dw 10
0011+  0647 64 00       			.dw 100
0012+  0649 E8 03       			.dw 1000
0013+  064B 10 27       			.dw 10000
0014+  064D             
0015+  064D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  064D             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  064D             ; ASCII in BL
0018+  064D             ; result in AL
0019+  064D             ; ascii for F = 0100 0110
0020+  064D             ; ascii for 9 = 0011 1001
0021+  064D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  064D             hex_ascii_encode:
0023+  064D 1B          	mov al, bl
0024+  064E 93 40       	test al, $40				; test if letter or number
0025+  0650 C7 56 06    	jnz hex_letter
0026+  0653 87 0F       	and al, $0F				; get number
0027+  0655 09          	ret
0028+  0656             hex_letter:
0029+  0656 87 0F       	and al, $0F				; get letter
0030+  0658 6A 09       	add al, 9
0031+  065A 09          	ret
0032+  065B             
0033+  065B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  065B             ; ATOI
0035+  065B             ; 2 letter hex string in B
0036+  065B             ; 8bit integer returned in AL
0037+  065B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  065B             atoi:
0039+  065B D8          	push b
0040+  065C 07 4D 06    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  065F 30          	mov bl, bh
0042+  0660 DB          	push al					; save a
0043+  0661 07 4D 06    	call hex_ascii_encode
0044+  0664 EA          	pop bl	
0045+  0665 FD 9E 04    	shl al, 4
0046+  0668 8C          	or al, bl
0047+  0669 E5          	pop b
0048+  066A 09          	ret	
0049+  066B             
0050+  066B             
0051+  066B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  066B             ; printf
0053+  066B             ; no need for explanations!
0054+  066B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  066B             printf:
0056+  066B 09          	ret
0057+  066C             
0058+  066C             
0059+  066C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  066C             ; scanf
0061+  066C             ; no need for explanations!
0062+  066C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  066C             scanf:
0064+  066C 09          	ret
0065+  066D             
0066+  066D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  066D             ; ITOA
0068+  066D             ; 8bit value in BL
0069+  066D             ; 2 byte ASCII result in A
0070+  066D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  066D             itoa:
0072+  066D DA          	push d
0073+  066E D8          	push b
0074+  066F A7 00       	mov bh, 0
0075+  0671 FD A4 04    	shr bl, 4	
0076+  0674 74          	mov d, b
0077+  0675 1F 2B 06    	mov al, [d + s_hex_digits]
0078+  0678 23          	mov ah, al
0079+  0679             	
0080+  0679 E5          	pop b
0081+  067A D8          	push b
0082+  067B A7 00       	mov bh, 0
0083+  067D FD 87 0F    	and bl, $0F
0084+  0680 74          	mov d, b
0085+  0681 1F 2B 06    	mov al, [d + s_hex_digits]
0086+  0684 E5          	pop b
0087+  0685 E7          	pop d
0088+  0686 09          	ret
0089+  0687             
0090+  0687             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  0687             ; HEX STRING TO BINARY
0092+  0687             ; di = destination address
0093+  0687             ; si = source
0094+  0687             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  0687             hex_to_int:
0096+  0687             hex_to_int_L1:
0097+  0687 F6          	lodsb					; load from [SI] to AL
0098+  0688 B9 00       	cmp al, 0				; check if ASCII 0
0099+  068A C6 97 06    	jz hex_to_int_ret
0100+  068D 36          	mov bh, al
0101+  068E F6          	lodsb
0102+  068F 2F          	mov bl, al
0103+  0690 07 5B 06    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  0693 F7          	stosb					; store AL to [DI]
0105+  0694 0A 87 06    	jmp hex_to_int_L1
0106+  0697             hex_to_int_ret:
0107+  0697 09          	ret		
0108+  0698             
0109+  0698             
0110+  0698             
0111+  0698             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  0698             ; GETCHAR
0113+  0698             ; char in ah
0114+  0698             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  0698             getchar:
0116+  0698 DB          	push al
0117+  0699             getchar_retry:
0118+  0699 FD 0C       	sti
0119+  069B 19 01       	mov al, 1
0120+  069D 05 03       	syscall sys_io			; receive in AH
0121+  069F B9 00       	cmp al, 0			; check if any char was receive
0122+  06A1 C6 99 06    	je getchar_retry
0123+  06A4 E8          	pop al
0124+  06A5 09          	ret
0125+  06A6             
0126+  06A6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  06A6             ; PUTCHAR
0128+  06A6             ; char in ah
0129+  06A6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  06A6             putchar:
0131+  06A6 D7          	push a
0132+  06A7 19 00       	mov al, 0
0133+  06A9 05 03       	syscall sys_io			; char in AH
0134+  06AB E4          	pop a
0135+  06AC 09          	ret
0136+  06AD             
0137+  06AD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  06AD             ;; INPUT A STRING
0139+  06AD             ;; terminates with null
0140+  06AD             ;; pointer in D
0141+  06AD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  06AD             gets:
0143+  06AD D7          	push a
0144+  06AE DA          	push d
0145+  06AF             gets_loop:
0146+  06AF FD 0C       	sti
0147+  06B1 19 01       	mov al, 1
0148+  06B3 05 03       	syscall sys_io			; receive in AH
0149+  06B5 B9 00       	cmp al, 0				; check error code (AL)
0150+  06B7 C6 AF 06    	je gets_loop			; if no char received, retry
0151+  06BA             
0152+  06BA 76 1B       	cmp ah, 27
0153+  06BC C6 DD 06    	je gets_telnet_escape
0154+  06BF 76 0A       	cmp ah, $0A				; LF
0155+  06C1 C6 36 07    	je gets_end
0156+  06C4 76 0D       	cmp ah, $0D				; CR
0157+  06C6 C6 36 07    	je gets_end
0158+  06C9 76 5C       	cmp ah, $5C				; '\\'
0159+  06CB C6 0D 07    	je gets_escape
0160+  06CE             	
0161+  06CE 76 08       	cmp ah, $08			; check for backspace
0162+  06D0 C6 D9 06    	je gets_backspace
0163+  06D3             
0164+  06D3 1A          	mov al, ah
0165+  06D4 3E          	mov [d], al
0166+  06D5 79          	inc d
0167+  06D6 0A AF 06    	jmp gets_loop
0168+  06D9             gets_backspace:
0169+  06D9 7F          	dec d
0170+  06DA 0A AF 06    	jmp gets_loop
0171+  06DD             gets_telnet_escape:
0172+  06DD FD 0C       	sti
0173+  06DF 19 01       	mov al, 1
0174+  06E1 05 03       	syscall sys_io				; receive in AH without echo
0175+  06E3 B9 00       	cmp al, 0					; check error code (AL)
0176+  06E5 C6 DD 06    	je gets_telnet_escape		; if no char received, retry
0177+  06E8 76 5B       	cmp ah, '['
0178+  06EA C7 AF 06    	jne gets_loop
0179+  06ED             gets_telnet_escape_phase2:
0180+  06ED FD 0C       	sti
0181+  06EF 19 01       	mov al, 1
0182+  06F1 05 03       	syscall sys_io					; receive in AH without echo
0183+  06F3 B9 00       	cmp al, 0						; check error code (AL)
0184+  06F5 C6 ED 06    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  06F8 76 44       	cmp ah, 'D'
0186+  06FA C6 05 07    	je gets_left_arrow
0187+  06FD 76 43       	cmp ah, 'C'
0188+  06FF C6 09 07    	je gets_right_arrow
0189+  0702 0A AF 06    	jmp gets_loop
0190+  0705             gets_left_arrow:
0191+  0705 7F          	dec d
0192+  0706 0A AF 06    	jmp gets_loop
0193+  0709             gets_right_arrow:
0194+  0709 79          	inc d
0195+  070A 0A AF 06    	jmp gets_loop
0196+  070D             gets_escape:
0197+  070D FD 0C       	sti
0198+  070F 19 01       	mov al, 1
0199+  0711 05 03       	syscall sys_io			; receive in AH
0200+  0713 B9 00       	cmp al, 0				; check error code (AL)
0201+  0715 C6 0D 07    	je gets_escape			; if no char received, retry
0202+  0718 76 6E       	cmp ah, 'n'
0203+  071A C6 28 07    	je gets_LF
0204+  071D 76 72       	cmp ah, 'r'
0205+  071F C6 2F 07    	je gets_CR
0206+  0722 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  0723 3E          	mov [d], al
0208+  0724 79          	inc d
0209+  0725 0A AF 06    	jmp gets_loop
0210+  0728             gets_LF:
0211+  0728 19 0A       	mov al, $0A
0212+  072A 3E          	mov [d], al
0213+  072B 79          	inc d
0214+  072C 0A AF 06    	jmp gets_loop
0215+  072F             gets_CR:
0216+  072F 19 0D       	mov al, $0D
0217+  0731 3E          	mov [d], al
0218+  0732 79          	inc d
0219+  0733 0A AF 06    	jmp gets_loop
0220+  0736             gets_end:
0221+  0736 19 00       	mov al, 0
0222+  0738 3E          	mov [d], al				; terminate string
0223+  0739 E7          	pop d
0224+  073A E4          	pop a
0225+  073B 09          	ret
0226+  073C             
0227+  073C             
0228+  073C             
0229+  073C             
0230+  073C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  073C             ;; INPUT TEXT
0232+  073C             ;; terminated with CTRL+D
0233+  073C             ;; pointer in D
0234+  073C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  073C             gettxt:
0236+  073C D7          	push a
0237+  073D DA          	push d
0238+  073E             gettxt_loop:
0239+  073E 19 01       	mov al, 1
0240+  0740 05 03       	syscall sys_io			; receive in AH
0241+  0742 B9 00       	cmp al, 0				; check error code (AL)
0242+  0744 C6 3E 07    	je gettxt_loop		; if no char received, retry
0243+  0747 76 04       	cmp ah, 4			; EOT
0244+  0749 C6 87 07    	je gettxt_end
0245+  074C 76 08       	cmp ah, $08			; check for backspace
0246+  074E C6 83 07    	je gettxt_backspace
0247+  0751 76 5C       	cmp ah, $5C				; '\\'
0248+  0753 C6 5C 07    	je gettxt_escape
0249+  0756 1A          	mov al, ah
0250+  0757 3E          	mov [d], al
0251+  0758 79          	inc d
0252+  0759 0A 3E 07    	jmp gettxt_loop
0253+  075C             gettxt_escape:
0254+  075C 19 01       	mov al, 1
0255+  075E 05 03       	syscall sys_io			; receive in AH
0256+  0760 B9 00       	cmp al, 0				; check error code (AL)
0257+  0762 C6 5C 07    	je gettxt_escape		; if no char received, retry
0258+  0765 76 6E       	cmp ah, 'n'
0259+  0767 C6 75 07    	je gettxt_LF
0260+  076A 76 72       	cmp ah, 'r'
0261+  076C C6 7C 07    	je gettxt_CR
0262+  076F 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  0770 3E          	mov [d], al
0264+  0771 79          	inc d
0265+  0772 0A 3E 07    	jmp gettxt_loop
0266+  0775             gettxt_LF:
0267+  0775 19 0A       	mov al, $0A
0268+  0777 3E          	mov [d], al
0269+  0778 79          	inc d
0270+  0779 0A 3E 07    	jmp gettxt_loop
0271+  077C             gettxt_CR:
0272+  077C 19 0D       	mov al, $0D
0273+  077E 3E          	mov [d], al
0274+  077F 79          	inc d
0275+  0780 0A 3E 07    	jmp gettxt_loop
0276+  0783             gettxt_backspace:
0277+  0783 7F          	dec d
0278+  0784 0A 3E 07    	jmp gettxt_loop
0279+  0787             gettxt_end:
0280+  0787 19 00       	mov al, 0
0281+  0789 3E          	mov [d], al				; terminate string
0282+  078A E7          	pop d
0283+  078B E4          	pop a
0284+  078C 09          	ret
0285+  078D             
0286+  078D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  078D             ; PRINT NEW LINE
0288+  078D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  078D             printnl:
0290+  078D D7          	push a
0291+  078E 10 00 0A    	mov a, $0A00
0292+  0791 05 03       	syscall sys_io
0293+  0793 10 00 0D    	mov a, $0D00
0294+  0796 05 03       	syscall sys_io
0295+  0798 E4          	pop a
0296+  0799 09          	ret
0297+  079A             
0298+  079A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  079A             ; strtoint
0300+  079A             ; 4 digit hex string number in d
0301+  079A             ; integer returned in A
0302+  079A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  079A             strtointx:
0304+  079A D8          	push b
0305+  079B 32          	mov bl, [d]
0306+  079C 37          	mov bh, bl
0307+  079D 33 01 00    	mov bl, [d + 1]
0308+  07A0 07 5B 06    	call atoi				; convert to int in AL
0309+  07A3 23          	mov ah, al				; move to AH
0310+  07A4 33 02 00    	mov bl, [d + 2]
0311+  07A7 37          	mov bh, bl
0312+  07A8 33 03 00    	mov bl, [d + 3]
0313+  07AB 07 5B 06    	call atoi				; convert to int in AL
0314+  07AE E5          	pop b
0315+  07AF 09          	ret
0316+  07B0             
0317+  07B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  07B0             ; strtoint
0319+  07B0             ; 5 digit base10 string number in d
0320+  07B0             ; integer returned in A
0321+  07B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  07B0             strtoint:
0323+  07B0 E2          	push si
0324+  07B1 D8          	push b
0325+  07B2 D9          	push c
0326+  07B3 DA          	push d
0327+  07B4 07 DB 05    	call strlen			; get string length in C
0328+  07B7 7E          	dec c
0329+  07B8 FD 4E       	mov si, d
0330+  07BA 12          	mov a, c
0331+  07BB FD 99       	shl a
0332+  07BD 3B 43 06    	mov d, table_power
0333+  07C0 59          	add d, a
0334+  07C1 38 00 00    	mov c, 0
0335+  07C4             strtoint_L0:
0336+  07C4 F6          	lodsb			; load ASCII to al
0337+  07C5 B9 00       	cmp al, 0
0338+  07C7 C6 DA 07    	je strtoint_end
0339+  07CA 6F 30       	sub al, $30		; make into integer
0340+  07CC 22 00       	mov ah, 0
0341+  07CE 2A          	mov b, [d]
0342+  07CF AC          	mul a, b			; result in B since it fits in 16bits
0343+  07D0 11          	mov a, b
0344+  07D1 28          	mov b, c
0345+  07D2 54          	add a, b
0346+  07D3 39          	mov c, a
0347+  07D4 63 02 00    	sub d, 2
0348+  07D7 0A C4 07    	jmp strtoint_L0
0349+  07DA             strtoint_end:
0350+  07DA 12          	mov a, c
0351+  07DB E7          	pop d
0352+  07DC E6          	pop c
0353+  07DD E5          	pop b
0354+  07DE EF          	pop si
0355+  07DF 09          	ret
0356+  07E0             
0357+  07E0             
0358+  07E0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  07E0             ; PRINT NULL TERMINATED STRING
0360+  07E0             ; pointer in D
0361+  07E0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  07E0             puts:
0363+  07E0 D7          	push a
0364+  07E1 DA          	push d
0365+  07E2             puts_L1:
0366+  07E2 1E          	mov al, [d]
0367+  07E3 B9 00       	cmp al, 0
0368+  07E5 C6 F1 07    	jz puts_END
0369+  07E8 23          	mov ah, al
0370+  07E9 19 00       	mov al, 0
0371+  07EB 05 03       	syscall sys_io
0372+  07ED 79          	inc d
0373+  07EE 0A E2 07    	jmp puts_L1
0374+  07F1             puts_END:
0375+  07F1 E7          	pop d
0376+  07F2 E4          	pop a
0377+  07F3 09          	ret
0378+  07F4             
0379+  07F4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  07F4             ; PRINT N SIZE STRING
0381+  07F4             ; pointer in D
0382+  07F4             ; size in C
0383+  07F4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  07F4             putsn:
0385+  07F4 DB          	push al
0386+  07F5 DA          	push d
0387+  07F6 D9          	push c
0388+  07F7             putsn_L0:
0389+  07F7 1E          	mov al, [d]
0390+  07F8 23          	mov ah, al
0391+  07F9 19 00       	mov al, 0
0392+  07FB 05 03       	syscall sys_io
0393+  07FD 79          	inc d
0394+  07FE 7E          	dec c	
0395+  07FF C2 00 00    	cmp c, 0
0396+  0802 C7 F7 07    	jne putsn_L0
0397+  0805             putsn_end:
0398+  0805 E6          	pop c
0399+  0806 E7          	pop d
0400+  0807 E8          	pop al
0401+  0808 09          	ret
0402+  0809             
0403+  0809             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  0809             ; print 16bit decimal number
0405+  0809             ; input number in A
0406+  0809             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  0809             print_u16d:
0408+  0809 D7          	push a
0409+  080A D8          	push b
0410+  080B 26 10 27    	mov b, 10000
0411+  080E AE          	div a, b			; get 10000's coeff.
0412+  080F 07 31 08    	call print_number
0413+  0812 11          	mov a, b
0414+  0813 26 E8 03    	mov b, 1000
0415+  0816 AE          	div a, b			; get 1000's coeff.
0416+  0817 07 31 08    	call print_number
0417+  081A 11          	mov a, b
0418+  081B 26 64 00    	mov b, 100
0419+  081E AE          	div a, b
0420+  081F 07 31 08    	call print_number
0421+  0822 11          	mov a, b
0422+  0823 26 0A 00    	mov b, 10
0423+  0826 AE          	div a, b
0424+  0827 07 31 08    	call print_number
0425+  082A 1B          	mov al, bl			; 1's coeff in bl
0426+  082B 07 31 08    	call print_number
0427+  082E E5          	pop b
0428+  082F E4          	pop a
0429+  0830 09          	ret
0430+  0831             
0431+  0831             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0432+  0831             ; print AL
0433+  0831             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0434+  0831             print_number:
0435+  0831 6A 30       	add al, $30
0436+  0833 23          	mov ah, al
0437+  0834 07 A6 06    	call putchar
0438+  0837 09          	ret
0439+  0838             
0440+  0838             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0441+  0838             ; PRINT 16BIT HEX INTEGER
0442+  0838             ; integer value in reg B
0443+  0838             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0444+  0838             print_u16x:
0445+  0838 D7          	push a
0446+  0839 D8          	push b
0447+  083A DD          	push bl
0448+  083B 30          	mov bl, bh
0449+  083C 07 6D 06    	call itoa				; convert bh to char in A
0450+  083F 2F          	mov bl, al				; save al
0451+  0840 19 00       	mov al, 0
0452+  0842 05 03       	syscall sys_io				; display AH
0453+  0844 24          	mov ah, bl				; retrieve al
0454+  0845 19 00       	mov al, 0
0455+  0847 05 03       	syscall sys_io				; display AL
0456+  0849             
0457+  0849 EA          	pop bl
0458+  084A 07 6D 06    	call itoa				; convert bh to char in A
0459+  084D 2F          	mov bl, al				; save al
0460+  084E 19 00       	mov al, 0
0461+  0850 05 03       	syscall sys_io				; display AH
0462+  0852 24          	mov ah, bl				; retrieve al
0463+  0853 19 00       	mov al, 0
0464+  0855 05 03       	syscall sys_io				; display AL
0465+  0857             
0466+  0857 E5          	pop b
0467+  0858 E4          	pop a
0468+  0859 09          	ret
0469+  085A             
0470+  085A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0471+  085A             ; INPUT 16BIT HEX INTEGER
0472+  085A             ; read 16bit integer into A
0473+  085A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0474+  085A             scan_u16x:
0475+  085A F8 10 00    	enter 16
0476+  085D D8          	push b
0477+  085E DA          	push d
0478+  085F             
0479+  085F FA F1 FF    	lea d, [bp + -15]
0480+  0862 07 AD 06    	call gets				; get number
0481+  0865             
0482+  0865 32          	mov bl, [d]
0483+  0866 37          	mov bh, bl
0484+  0867 33 01 00    	mov bl, [d + 1]
0485+  086A 07 5B 06    	call atoi				; convert to int in AL
0486+  086D 23          	mov ah, al				; move to AH
0487+  086E             
0488+  086E 33 02 00    	mov bl, [d + 2]
0489+  0871 37          	mov bh, bl
0490+  0872 33 03 00    	mov bl, [d + 3]
0491+  0875 07 5B 06    	call atoi				; convert to int in AL
0492+  0878             
0493+  0878 E7          	pop d
0494+  0879 E5          	pop b
0495+  087A F9          	leave
0496+  087B 09          	ret
0497+  087C             
0498+  087C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0499+  087C             ; PRINT 8bit HEX INTEGER
0500+  087C             ; integer value in reg bl
0501+  087C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0502+  087C             print_u8x:
0503+  087C D7          	push a
0504+  087D DD          	push bl
0505+  087E             
0506+  087E 07 6D 06    	call itoa				; convert bl to char in A
0507+  0881 2F          	mov bl, al				; save al
0508+  0882 19 00       	mov al, 0
0509+  0884 05 03       	syscall sys_io				; display AH
0510+  0886 24          	mov ah, bl				; retrieve al
0511+  0887 19 00       	mov al, 0
0512+  0889 05 03       	syscall sys_io				; display AL
0513+  088B             
0514+  088B EA          	pop bl
0515+  088C E4          	pop a
0516+  088D 09          	ret
0517+  088E             
0518+  088E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0519+  088E             ; print 8bit decimal unsigned number
0520+  088E             ; input number in AL
0521+  088E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0522+  088E             print_u8d:
0523+  088E D7          	push a
0524+  088F D8          	push b
0525+  0890             
0526+  0890 22 00       	mov ah, 0
0527+  0892 26 64 00    	mov b, 100
0528+  0895 AE          	div a, b
0529+  0896 D8          	push b			; save remainder
0530+  0897 B9 00       	cmp al, 0
0531+  0899 C6 A3 08    	je skip100
0532+  089C 6A 30       	add al, $30
0533+  089E 23          	mov ah, al
0534+  089F 19 00       	mov al, 0
0535+  08A1 05 03       	syscall sys_io	; print coeff
0536+  08A3             skip100:
0537+  08A3 E4          	pop a
0538+  08A4 22 00       	mov ah, 0
0539+  08A6 26 0A 00    	mov b, 10
0540+  08A9 AE          	div a, b
0541+  08AA D8          	push b			; save remainder
0542+  08AB B9 00       	cmp al, 0
0543+  08AD C6 B7 08    	je skip10
0544+  08B0 6A 30       	add al, $30
0545+  08B2 23          	mov ah, al
0546+  08B3 19 00       	mov al, 0
0547+  08B5 05 03       	syscall sys_io	; print coeff
0548+  08B7             skip10:
0549+  08B7 E4          	pop a
0550+  08B8 1B          	mov al, bl
0551+  08B9 6A 30       	add al, $30
0552+  08BB 23          	mov ah, al
0553+  08BC 19 00       	mov al, 0
0554+  08BE 05 03       	syscall sys_io	; print coeff
0555+  08C0 E5          	pop b
0556+  08C1 E4          	pop a
0557+  08C2 09          	ret
0558+  08C3             
0559+  08C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0560+  08C3             ; INPUT 8BIT HEX INTEGER
0561+  08C3             ; read 8bit integer into AL
0562+  08C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0563+  08C3             scan_u8x:
0564+  08C3 F8 04 00    	enter 4
0565+  08C6 D8          	push b
0566+  08C7 DA          	push d
0567+  08C8             
0568+  08C8 FA FD FF    	lea d, [bp + -3]
0569+  08CB 07 AD 06    	call gets				; get number
0570+  08CE             
0571+  08CE 32          	mov bl, [d]
0572+  08CF 37          	mov bh, bl
0573+  08D0 33 01 00    	mov bl, [d + 1]
0574+  08D3 07 5B 06    	call atoi				; convert to int in AL
0575+  08D6             
0576+  08D6 E7          	pop d
0577+  08D7 E5          	pop b
0578+  08D8 F9          	leave
0579+  08D9 09          	ret
0580+  08DA             
0581+  08DA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0582+  08DA             ; input decimal number
0583+  08DA             ; result in A
0584+  08DA             ; 655'\0'
0585+  08DA             ; low--------high
0586+  08DA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  08DA             scan_u16d:
0588+  08DA F8 08 00    	enter 8
0589+  08DD E2          	push si
0590+  08DE D8          	push b
0591+  08DF D9          	push c
0592+  08E0 DA          	push d
0593+  08E1 FA F9 FF    	lea d, [bp +- 7]
0594+  08E4 07 AD 06    	call gets
0595+  08E7 07 DB 05    	call strlen			; get string length in C
0596+  08EA 7E          	dec c
0597+  08EB FD 4E       	mov si, d
0598+  08ED 12          	mov a, c
0599+  08EE FD 99       	shl a
0600+  08F0 3B 43 06    	mov d, table_power
0601+  08F3 59          	add d, a
0602+  08F4 38 00 00    	mov c, 0
0603+  08F7             mul_loop:
0604+  08F7 F6          	lodsb			; load ASCII to al
0605+  08F8 B9 00       	cmp al, 0
0606+  08FA C6 0D 09    	je mul_exit
0607+  08FD 6F 30       	sub al, $30		; make into integer
0608+  08FF 22 00       	mov ah, 0
0609+  0901 2A          	mov b, [d]
0610+  0902 AC          	mul a, b			; result in B since it fits in 16bits
0611+  0903 11          	mov a, b
0612+  0904 28          	mov b, c
0613+  0905 54          	add a, b
0614+  0906 39          	mov c, a
0615+  0907 63 02 00    	sub d, 2
0616+  090A 0A F7 08    	jmp mul_loop
0617+  090D             mul_exit:
0618+  090D 12          	mov a, c
0619+  090E E7          	pop d
0620+  090F E6          	pop c
0621+  0910 E5          	pop b
0622+  0911 EF          	pop si
0623+  0912 F9          	leave
0624+  0913 09          	ret
0107   0914             
0108   0914 00          flags:	.db
0109   0915             
0110   0915             .end
0111   0915             
tasm: Number of errors = 0
