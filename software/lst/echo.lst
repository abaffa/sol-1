0001   0000             .include "kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0002   0000             
0003   0400             .org PROC_TEXT_ORG			; origin at 1024
0004   0400             
0005   0400             cmd_echo:
0006   0400 10 00 00    	mov a, 0
0007   0403 42 3E 06    	mov [prog], a			; move tokennizer pointer to the beginning of the arguments area (address 0)
0008   0406 07 14 04    	call get_arg			; read argument line
0009   0409 3B 42 06    	mov d, tokstr
0010   040C 07 8E 09    	call puts
0011   040F 07 3B 09    	call printnl
0012   0412 05 0B       	syscall sys_terminate_proc
0013   0414             
0014   0414             
0015   0414             .include "token.asm"
0001+  0414             TOKTYP_IDENTIFIER	.equ 0
0002+  0414             TOKTYP_KEYWORD		.equ 1
0003+  0414             TOKTYP_DELIMITER	.equ 2
0004+  0414             TOKTYP_STRING		.equ 3
0005+  0414             TOKTYP_CHAR			.equ 4
0006+  0414             TOKTYP_NUMERIC		.equ 5
0007+  0414             TOKTYP_END			.equ 6
0008+  0414             
0009+  0414             TOK_NULL			.equ 0
0010+  0414             TOK_FSLASH			.equ 1
0011+  0414             TOK_TIMES 			.equ 2
0012+  0414             TOK_PLUS 			.equ 3
0013+  0414             TOK_MINUS 			.equ 4
0014+  0414             TOK_DOT				.equ 5
0015+  0414             TOK_SEMI			.equ 6
0016+  0414             TOK_ANGLE			.equ 7
0017+  0414             TOK_TILDE			.equ 8
0018+  0414             TOK_EQUAL			.equ 9
0019+  0414             TOK_COLON			.equ 10
0020+  0414             TOK_COMMA			.equ 11
0021+  0414             
0022+  0414             TOK_END				.equ 20
0023+  0414             
0024+  0414             
0025+  0414             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  0414             ;; read a full command argment from shell input buffer
0027+  0414             ;; argument is written into tokstr
0028+  0414             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  0414             get_arg:
0030+  0414 D7          	push a
0031+  0415 E2          	push si
0032+  0416 E3          	push di
0033+  0417 19 00       	mov al, 0
0034+  0419 3D 42 06    	mov [tokstr], al			; nullify tokstr string
0035+  041C 14 3E 06    	mov a, [prog]
0036+  041F 4D          	mov si, a
0037+  0420 FD 4F 42 06 	mov di, tokstr
0038+  0424             get_arg_skip_spaces:
0039+  0424 F6          	lodsb
0040+  0425 07 38 0B    	call isspace
0041+  0428 C6 24 04    	je get_arg_skip_spaces
0042+  042B             get_arg_L0:
0043+  042B B9 3B       	cmp al, $3B				; check if is ';'
0044+  042D C6 3A 04    	je get_arg_end
0045+  0430 B9 00       	cmp al, 0
0046+  0432 C6 3A 04    	je get_arg_end			; check if end of input
0047+  0435 F7          	stosb
0048+  0436 F6          	lodsb
0049+  0437 0A 2B 04    	jmp get_arg_L0
0050+  043A             get_arg_end:
0051+  043A 19 00       	mov al, 0
0052+  043C F7          	stosb
0053+  043D D5 01 00    	sub si, 1
0054+  0440 4E          	mov a, si
0055+  0441 42 3E 06    	mov [prog], a		; update pointer
0056+  0444 F0          	pop di
0057+  0445 EF          	pop si
0058+  0446 E4          	pop a
0059+  0447 09          	ret
0060+  0448             
0061+  0448             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  0448             ;; read a path formation from shell input buffer
0063+  0448             ;; path is written into tokstr
0064+  0448             ;; /usr/bin
0065+  0448             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  0448             get_path:
0067+  0448 D7          	push a
0068+  0449 E2          	push si
0069+  044A E3          	push di
0070+  044B 19 00       	mov al, 0
0071+  044D 3D 42 06    	mov [tokstr], al			; nullify tokstr string
0072+  0450 14 3E 06    	mov a, [prog]
0073+  0453 4D          	mov si, a
0074+  0454 FD 4F 42 06 	mov di, tokstr
0075+  0458             get_path_skip_spaces:
0076+  0458 F6          	lodsb
0077+  0459 07 38 0B    	call isspace
0078+  045C C6 58 04    	je get_path_skip_spaces
0079+  045F             get_path_is_pathchar:
0080+  045F F7          	stosb
0081+  0460 F6          	lodsb
0082+  0461 07 C2 0A    	call isalnum			;check if is alphanumeric
0083+  0464 C6 5F 04    	je get_path_is_pathchar
0084+  0467 B9 2F       	cmp al, '/'				; check if is '/'
0085+  0469 C6 5F 04    	je get_path_is_pathchar
0086+  046C 19 00       	mov al, 0
0087+  046E F7          	stosb
0088+  046F D5 01 00    	sub si, 1
0089+  0472 4E          	mov a, si
0090+  0473 42 3E 06    	mov [prog], a		; update pointer
0091+  0476             get_path_end:
0092+  0476 F0          	pop di
0093+  0477 EF          	pop si
0094+  0478 E4          	pop a
0095+  0479 09          	ret
0096+  047A             
0097+  047A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  047A             ;; read a line
0099+  047A             ;; line is written into tokstr
0100+  047A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  047A             get_line:
0102+  047A D7          	push a
0103+  047B E2          	push si
0104+  047C E3          	push di
0105+  047D 19 00       	mov al, 0
0106+  047F 3D 42 06    	mov [tokstr], al			; nullify tokstr string
0107+  0482 14 3E 06    	mov a, [prog]
0108+  0485 4D          	mov si, a
0109+  0486 FD 4F 42 06 	mov di, tokstr
0110+  048A             get_line_L0:
0111+  048A F6          	lodsb
0112+  048B B9 0A       	cmp al, $0A		; check for new line
0113+  048D C6 94 04    	je get_line_exit
0114+  0490 F7          	stosb
0115+  0491 0A 8A 04    	jmp get_line_L0
0116+  0494             get_line_exit:
0117+  0494 19 00       	mov al, 0
0118+  0496 F7          	stosb
0119+  0497 4E          	mov a, si
0120+  0498 42 3E 06    	mov [prog], a		; update pointer
0121+  049B F0          	pop di
0122+  049C EF          	pop si
0123+  049D E4          	pop a
0124+  049E 09          	ret
0125+  049F             
0126+  049F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  049F             ;; token parser
0128+  049F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  049F             get_token:
0130+  049F D7          	push a
0131+  04A0 DA          	push d
0132+  04A1 E2          	push si
0133+  04A2 E3          	push di
0134+  04A3 19 00       	mov al, 0
0135+  04A5 3D 42 06    	mov [tokstr], al			; nullify tokstr string
0136+  04A8 19 00       	mov al, TOK_NULL
0137+  04AA 3D 41 06    	mov [tok], al				; nullify token
0138+  04AD 14 3E 06    	mov a, [prog]
0139+  04B0 4D          	mov si, a
0140+  04B1 FD 4F 42 06 	mov di, tokstr
0141+  04B5             get_tok_skip_spaces:
0142+  04B5 F6          	lodsb
0143+  04B6 07 38 0B    	call isspace
0144+  04B9 C6 B5 04    	je get_tok_skip_spaces
0145+  04BC B9 00       	cmp al, 0			; check for end of input (NULL)
0146+  04BE C6 A3 05    	je get_token_end
0147+  04C1 B9 23       	cmp al, '#'			; comments!
0148+  04C3 C6 D1 05    	je get_tok_comment
0149+  04C6 07 C2 0A    	call isalnum
0150+  04C9 C6 B0 05    	jz is_alphanumeric
0151+  04CC             ; other token types
0152+  04CC             get_token_slash:
0153+  04CC B9 2F       	cmp al, '/'				; check if '/'
0154+  04CE C7 E6 04    	jne get_token_minus
0155+  04D1 F7          	stosb					; store '/' into token string
0156+  04D2 19 00       	mov al, 0
0157+  04D4 F7          	stosb					; terminate token string
0158+  04D5 19 01       	mov al, TOK_FSLASH
0159+  04D7 3D 41 06    	mov [tok], al			
0160+  04DA 19 02       	mov al, TOKTYP_DELIMITER
0161+  04DC 3D 40 06    	mov [toktyp], al
0162+  04DF 4E          	mov a, si
0163+  04E0 42 3E 06    	mov [prog], a		; update pointer
0164+  04E3 0A CC 05    	jmp get_token_return
0165+  04E6             get_token_minus:
0166+  04E6 B9 2D       	cmp al, '-'				; check if '-'
0167+  04E8 C7 00 05    	jne get_token_comma
0168+  04EB F7          	stosb					; store '-' into token string
0169+  04EC 19 00       	mov al, 0
0170+  04EE F7          	stosb					; terminate token string
0171+  04EF 19 04       	mov al, TOK_MINUS
0172+  04F1 3D 41 06    	mov [tok], al			
0173+  04F4 19 02       	mov al, TOKTYP_DELIMITER
0174+  04F6 3D 40 06    	mov [toktyp], al
0175+  04F9 4E          	mov a, si
0176+  04FA 42 3E 06    	mov [prog], a		; update pointer
0177+  04FD 0A CC 05    	jmp get_token_return
0178+  0500             get_token_comma:
0179+  0500 B9 2C       	cmp al, ','				; check if ','
0180+  0502 C7 1A 05    	jne get_token_semi
0181+  0505 F7          	stosb					; store ',' into token string
0182+  0506 19 00       	mov al, 0
0183+  0508 F7          	stosb					; terminate token string
0184+  0509 19 0B       	mov al, TOK_COMMA
0185+  050B 3D 41 06    	mov [tok], al			
0186+  050E 19 02       	mov al, TOKTYP_DELIMITER
0187+  0510 3D 40 06    	mov [toktyp], al
0188+  0513 4E          	mov a, si
0189+  0514 42 3E 06    	mov [prog], a		; update pointer
0190+  0517 0A CC 05    	jmp get_token_return
0191+  051A             get_token_semi:
0192+  051A B9 3B       	cmp al, $3B				; check if ';'
0193+  051C C7 34 05    	jne get_token_colon
0194+  051F F7          	stosb					; store ';' into token string
0195+  0520 19 00       	mov al, 0
0196+  0522 F7          	stosb					; terminate token string
0197+  0523 19 06       	mov al, TOK_SEMI
0198+  0525 3D 41 06    	mov [tok], al			
0199+  0528 19 02       	mov al, TOKTYP_DELIMITER
0200+  052A 3D 40 06    	mov [toktyp], al
0201+  052D 4E          	mov a, si
0202+  052E 42 3E 06    	mov [prog], a		; update pointer
0203+  0531 0A CC 05    	jmp get_token_return
0204+  0534             get_token_colon:
0205+  0534 B9 3A       	cmp al, $3A				; check if ':'
0206+  0536 C7 4E 05    	jne get_token_angle
0207+  0539 F7          	stosb					; store ':' into token string
0208+  053A 19 00       	mov al, 0
0209+  053C F7          	stosb					; terminate token string
0210+  053D 19 0A       	mov al, TOK_COLON
0211+  053F 3D 41 06    	mov [tok], al			
0212+  0542 19 02       	mov al, TOKTYP_DELIMITER
0213+  0544 3D 40 06    	mov [toktyp], al
0214+  0547 4E          	mov a, si
0215+  0548 42 3E 06    	mov [prog], a		; update pointer
0216+  054B 0A CC 05    	jmp get_token_return
0217+  054E             get_token_angle:
0218+  054E B9 3E       	cmp al, $3E				; check if '>'
0219+  0550 C7 68 05    	jne get_token_tilde
0220+  0553 F7          	stosb					; store '>' into token string
0221+  0554 19 00       	mov al, 0
0222+  0556 F7          	stosb					; terminate token string
0223+  0557 19 07       	mov al, TOK_ANGLE
0224+  0559 3D 41 06    	mov [tok], al			
0225+  055C 19 02       	mov al, TOKTYP_DELIMITER
0226+  055E 3D 40 06    	mov [toktyp], al
0227+  0561 4E          	mov a, si
0228+  0562 42 3E 06    	mov [prog], a		; update pointer
0229+  0565 0A CC 05    	jmp get_token_return
0230+  0568             get_token_tilde:
0231+  0568 B9 7E       	cmp al, '~'				; check if '~'
0232+  056A C7 82 05    	jne get_token_equal
0233+  056D F7          	stosb					; store '~' into token string
0234+  056E 19 00       	mov al, 0
0235+  0570 F7          	stosb					; terminate token string
0236+  0571 19 08       	mov al, TOK_TILDE
0237+  0573 3D 41 06    	mov [tok], al			
0238+  0576 19 02       	mov al, TOKTYP_DELIMITER
0239+  0578 3D 40 06    	mov [toktyp], al
0240+  057B 4E          	mov a, si
0241+  057C 42 3E 06    	mov [prog], a		; update pointer
0242+  057F 0A CC 05    	jmp get_token_return
0243+  0582             get_token_equal:
0244+  0582 B9 3D       	cmp al, '='				; check if '='
0245+  0584 C7 9C 05    	jne get_token_skip
0246+  0587 F7          	stosb					; store '=' into token string
0247+  0588 19 00       	mov al, 0
0248+  058A F7          	stosb					; terminate token string
0249+  058B 19 09       	mov al, TOK_EQUAL
0250+  058D 3D 41 06    	mov [tok], al			
0251+  0590 19 02       	mov al, TOKTYP_DELIMITER
0252+  0592 3D 40 06    	mov [toktyp], al
0253+  0595 4E          	mov a, si
0254+  0596 42 3E 06    	mov [prog], a		; update pointer
0255+  0599 0A CC 05    	jmp get_token_return
0256+  059C             get_token_skip:
0257+  059C 4E          	mov a, si
0258+  059D 42 3E 06    	mov [prog], a		; update pointer
0259+  05A0 0A CC 05    	jmp get_token_return
0260+  05A3             get_token_end:				; end of file token
0261+  05A3 19 14       	mov al, TOK_END
0262+  05A5 3D 41 06    	mov [tok], al
0263+  05A8 19 06       	mov al, TOKTYP_END
0264+  05AA 3D 40 06    	mov [toktyp], al
0265+  05AD 0A CC 05    	jmp get_token_return
0266+  05B0             is_alphanumeric:
0267+  05B0 F7          	stosb
0268+  05B1 F6          	lodsb
0269+  05B2 07 C2 0A    	call isalnum			;check if is alphanumeric
0270+  05B5 C6 B0 05    	jz is_alphanumeric
0271+  05B8 B9 2E       	cmp al, $2E				; check if is '.'
0272+  05BA C6 B0 05    	je is_alphanumeric
0273+  05BD 19 00       	mov al, 0
0274+  05BF F7          	stosb
0275+  05C0 19 00       	mov al, TOKTYP_IDENTIFIER
0276+  05C2 3D 40 06    	mov [toktyp], al
0277+  05C5 D5 01 00    	sub si, 1
0278+  05C8 4E          	mov a, si
0279+  05C9 42 3E 06    	mov [prog], a		; update pointer
0280+  05CC             get_token_return:
0281+  05CC F0          	pop di
0282+  05CD EF          	pop si
0283+  05CE E7          	pop d
0284+  05CF E4          	pop a
0285+  05D0 09          	ret
0286+  05D1             get_tok_comment:
0287+  05D1 F6          	lodsb
0288+  05D2 B9 0A       	cmp al, $0A			; new line
0289+  05D4 C7 D1 05    	jne get_tok_comment
0290+  05D7 0A B5 04    	jmp get_tok_skip_spaces
0291+  05DA             
0292+  05DA             
0293+  05DA             get_number:
0294+  05DA D7          	push a
0295+  05DB DA          	push d
0296+  05DC E2          	push si
0297+  05DD E3          	push di
0298+  05DE 19 00       	mov al, 0
0299+  05E0 3D 42 06    	mov [tokstr], al			; nullify tokstr string
0300+  05E3 19 00       	mov al, TOK_NULL
0301+  05E5 3D 41 06    	mov [tok], al				; nullify token
0302+  05E8 14 3E 06    	mov a, [prog]
0303+  05EB 4D          	mov si, a
0304+  05EC FD 4F 42 06 	mov di, tokstr
0305+  05F0             get_number_skip_spaces:
0306+  05F0 F6          	lodsb
0307+  05F1 07 38 0B    	call isspace
0308+  05F4 C6 F0 05    	je get_number_skip_spaces
0309+  05F7 B9 00       	cmp al, 0			; check for end of input (NULL)
0310+  05F9 C7 09 06    	jne get_number_L0
0311+  05FC 19 14       	mov al, TOK_END
0312+  05FE 3D 41 06    	mov [tok], al
0313+  0601 19 06       	mov al, TOKTYP_END
0314+  0603 3D 40 06    	mov [toktyp], al
0315+  0606 0A 20 06    	jmp get_number_return
0316+  0609             get_number_L0:
0317+  0609 F7          	stosb
0318+  060A F6          	lodsb
0319+  060B 07 CC 0A    	call isdigit			;check if is numeric
0320+  060E C6 09 06    	jz get_number_L0
0321+  0611 19 00       	mov al, 0
0322+  0613 F7          	stosb
0323+  0614 19 05       	mov al, TOKTYP_NUMERIC
0324+  0616 3D 40 06    	mov [toktyp], al
0325+  0619 D5 01 00    	sub si, 1
0326+  061C 4E          	mov a, si
0327+  061D 42 3E 06    	mov [prog], a		; update pointer
0328+  0620             get_number_return:
0329+  0620 F0          	pop di
0330+  0621 EF          	pop si
0331+  0622 E7          	pop d
0332+  0623 E4          	pop a
0333+  0624 09          	ret
0334+  0625             
0335+  0625             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  0625             ;; PUT BACK TOKEN
0337+  0625             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
0338+  0625             putback:
0339+  0625 D7          	push a
0340+  0626 E2          	push si
0341+  0627 FD 4D 42 06 	mov si, tokstr	
0342+  062B             putback_loop:
0343+  062B F6          	lodsb
0344+  062C B9 00       	cmp al, 0
0345+  062E C6 3B 06    	je putback_end
0346+  0631 14 3E 06    	mov a, [prog]
0347+  0634 7D          	dec a
0348+  0635 42 3E 06    	mov [prog], a			; update pointer
0349+  0638 0A 2B 06    	jmp putback_loop
0350+  063B             putback_end:
0351+  063B EF          	pop si
0352+  063C E4          	pop a
0353+  063D 09          	ret
0354+  063E             
0355+  063E             
0356+  063E             
0357+  063E             
0358+  063E 00 00       prog:		.dw 0			; pointer to current position in buffer
0359+  0640             
0360+  0640 00          toktyp: 	.db 0			; token type symbol
0361+  0641 00          tok:		.db 0			; current token symbol
0362+  0642 00 00 00 00 tokstr:		.fill 256, 0	; token as a string
0362+  0646 00 00 00 00 
0362+  064A 00 00 00 00 
0362+  064E 00 00 00 00 
0362+  0652 00 00 00 00 
0362+  0656 00 00 00 00 
0362+  065A 00 00 00 00 
0362+  065E 00 00 00 00 
0362+  0662 00 00 00 00 
0362+  0666 00 00 00 00 
0362+  066A 00 00 00 00 
0362+  066E 00 00 00 00 
0362+  0672 00 00 00 00 
0362+  0676 00 00 00 00 
0362+  067A 00 00 00 00 
0362+  067E 00 00 00 00 
0362+  0682 00 00 00 00 
0362+  0686 00 00 00 00 
0362+  068A 00 00 00 00 
0362+  068E 00 00 00 00 
0362+  0692 00 00 00 00 
0362+  0696 00 00 00 00 
0362+  069A 00 00 00 00 
0362+  069E 00 00 00 00 
0362+  06A2 00 00 00 00 
0362+  06A6 00 00 00 00 
0362+  06AA 00 00 00 00 
0362+  06AE 00 00 00 00 
0362+  06B2 00 00 00 00 
0362+  06B6 00 00 00 00 
0362+  06BA 00 00 00 00 
0362+  06BE 00 00 00 00 
0362+  06C2 00 00 00 00 
0362+  06C6 00 00 00 00 
0362+  06CA 00 00 00 00 
0362+  06CE 00 00 00 00 
0362+  06D2 00 00 00 00 
0362+  06D6 00 00 00 00 
0362+  06DA 00 00 00 00 
0362+  06DE 00 00 00 00 
0362+  06E2 00 00 00 00 
0362+  06E6 00 00 00 00 
0362+  06EA 00 00 00 00 
0362+  06EE 00 00 00 00 
0362+  06F2 00 00 00 00 
0362+  06F6 00 00 00 00 
0362+  06FA 00 00 00 00 
0362+  06FE 00 00 00 00 
0362+  0702 00 00 00 00 
0362+  0706 00 00 00 00 
0362+  070A 00 00 00 00 
0362+  070E 00 00 00 00 
0362+  0712 00 00 00 00 
0362+  0716 00 00 00 00 
0362+  071A 00 00 00 00 
0362+  071E 00 00 00 00 
0362+  0722 00 00 00 00 
0362+  0726 00 00 00 00 
0362+  072A 00 00 00 00 
0362+  072E 00 00 00 00 
0362+  0732 00 00 00 00 
0362+  0736 00 00 00 00 
0362+  073A 00 00 00 00 
0362+  073E 00 00 00 00 
0016   0742             .include "stdio.asm"
0001+  0742             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0742             ; stdio.s
0003+  0742             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0742             .include "string.asm"
0001++ 0742             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0742             ; string.s
0003++ 0742             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0742             
0005++ 0742             
0006++ 0742             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0742             ; strrev
0008++ 0742             ; reverse a string
0009++ 0742             ; D = string address
0010++ 0742             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0742             ; 01234
0012++ 0742             strrev:
0013++ 0742 4B          	pusha
0014++ 0743 07 89 07    	call strlen	; length in C
0015++ 0746 12          	mov a, c
0016++ 0747 AF 01 00    	cmp a, 1
0017++ 074A D0 64 07    	jleu strrev_end	; check string length. string len must be > 1
0018++ 074D 7D          	dec a
0019++ 074E FD 4E       	mov si, d	; beginning of string
0020++ 0750 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0752 59          	add d, a	; end of string
0022++ 0753 12          	mov a, c
0023++ 0754 FD 9B       	shr a		; divide by 2
0024++ 0756 39          	mov c, a	; C now counts the steps
0025++ 0757             strrev_L0:
0026++ 0757 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0758 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0759 3E          	mov [d], al	; store left char into right side
0029++ 075A 1B          	mov al, bl
0030++ 075B F7          	stosb		; store right-side char into left-side; increase DI
0031++ 075C 7E          	dec c
0032++ 075D 7F          	dec d
0033++ 075E C2 00 00    	cmp c, 0
0034++ 0761 C7 57 07    	jne strrev_L0
0035++ 0764             strrev_end:
0036++ 0764 4C          	popa
0037++ 0765 09          	ret
0038++ 0766             	
0039++ 0766             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0766             ; strchr
0041++ 0766             ; search string in D for char in AL
0042++ 0766             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0766             strchr:
0044++ 0766             strchr_L0:
0045++ 0766 32          	mov bl, [d]
0046++ 0767 C1 00       	cmp bl, 0
0047++ 0769 C6 74 07    	je strchr_end
0048++ 076C BA          	cmp al, bl
0049++ 076D C6 74 07    	je strchr_end
0050++ 0770 79          	inc d
0051++ 0771 0A 66 07    	jmp strchr_L0
0052++ 0774             strchr_end:
0053++ 0774 1B          	mov al, bl
0054++ 0775 09          	ret
0055++ 0776             
0056++ 0776             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0776             ; strstr
0058++ 0776             ; find sub-string
0059++ 0776             ; str1 in SI
0060++ 0776             ; str2 in DI
0061++ 0776             ; SI points to end of source string
0062++ 0776             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0776             strstr:
0064++ 0776 DB          	push al
0065++ 0777 DA          	push d
0066++ 0778 E3          	push di
0067++ 0779             strstr_loop:
0068++ 0779 F3          	cmpsb					; compare a byte of the strings
0069++ 077A C7 85 07    	jne strstr_ret
0070++ 077D FC 00 00    	lea d, [di + 0]
0071++ 0780 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0782 C7 79 07    	jne strstr_loop				; equal chars but not at end
0073++ 0785             strstr_ret:
0074++ 0785 F0          	pop di
0075++ 0786 E7          	pop d
0076++ 0787 E8          	pop al
0077++ 0788 09          	ret
0078++ 0789             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0789             ; length of null terminated string
0080++ 0789             ; result in C
0081++ 0789             ; pointer in D
0082++ 0789             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0789             strlen:
0084++ 0789 DA          	push d
0085++ 078A 38 00 00    	mov c, 0
0086++ 078D             strlen_L1:
0087++ 078D BD 00       	cmp byte [d], 0
0088++ 078F C6 97 07    	je strlen_ret
0089++ 0792 79          	inc d
0090++ 0793 78          	inc c
0091++ 0794 0A 8D 07    	jmp strlen_L1
0092++ 0797             strlen_ret:
0093++ 0797 E7          	pop d
0094++ 0798 09          	ret
0095++ 0799             
0096++ 0799             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0799             ; STRCMP
0098++ 0799             ; compare two strings
0099++ 0799             ; str1 in SI
0100++ 0799             ; str2 in DI
0101++ 0799             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0799             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0799             strcmp:
0104++ 0799 DB          	push al
0105++ 079A DA          	push d
0106++ 079B E3          	push di
0107++ 079C E2          	push si
0108++ 079D             strcmp_loop:
0109++ 079D F3          	cmpsb					; compare a byte of the strings
0110++ 079E C7 A9 07    	jne strcmp_ret
0111++ 07A1 FB FF FF    	lea d, [si +- 1]
0112++ 07A4 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 07A6 C7 9D 07    	jne strcmp_loop				; equal chars but not at end
0114++ 07A9             strcmp_ret:
0115++ 07A9 EF          	pop si
0116++ 07AA F0          	pop di
0117++ 07AB E7          	pop d
0118++ 07AC E8          	pop al
0119++ 07AD 09          	ret
0120++ 07AE             
0121++ 07AE             
0122++ 07AE             ; STRCPY
0123++ 07AE             ; copy null terminated string from SI to DI
0124++ 07AE             ; source in SI
0125++ 07AE             ; destination in DI
0126++ 07AE             strcpy:
0127++ 07AE E2          	push si
0128++ 07AF E3          	push di
0129++ 07B0 DB          	push al
0130++ 07B1             strcpy_L1:
0131++ 07B1 F6          	lodsb
0132++ 07B2 F7          	stosb
0133++ 07B3 B9 00       	cmp al, 0
0134++ 07B5 C7 B1 07    	jne strcpy_L1
0135++ 07B8             strcpy_end:
0136++ 07B8 E8          	pop al
0137++ 07B9 F0          	pop di
0138++ 07BA EF          	pop si
0139++ 07BB 09          	ret
0140++ 07BC             
0141++ 07BC             ; STRCAT
0142++ 07BC             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 07BC             ; source in SI
0144++ 07BC             ; destination in DI
0145++ 07BC             strcat:
0146++ 07BC E2          	push si
0147++ 07BD E3          	push di
0148++ 07BE D7          	push a
0149++ 07BF DA          	push d
0150++ 07C0 50          	mov a, di
0151++ 07C1 3C          	mov d, a
0152++ 07C2             strcat_goto_end_L1:
0153++ 07C2 BD 00       	cmp byte[d], 0
0154++ 07C4 C6 CB 07    	je strcat_start
0155++ 07C7 79          	inc d
0156++ 07C8 0A C2 07    	jmp strcat_goto_end_L1
0157++ 07CB             strcat_start:
0158++ 07CB FD 50       	mov di, d
0159++ 07CD             strcat_L1:
0160++ 07CD F6          	lodsb
0161++ 07CE F7          	stosb
0162++ 07CF B9 00       	cmp al, 0
0163++ 07D1 C7 CD 07    	jne strcat_L1
0164++ 07D4             strcat_end:
0165++ 07D4 E7          	pop d
0166++ 07D5 E4          	pop a
0167++ 07D6 F0          	pop di
0168++ 07D7 EF          	pop si
0169++ 07D8 09          	ret
0005+  07D9             
0006+  07D9 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  07DD 34 35 36 37 
0006+  07E1 38 39 41 42 
0006+  07E5 43 44 45 46 
0007+  07E9 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  07ED 1B 5B 48 00 
0008+  07F1             
0009+  07F1 01 00       table_power:.dw 1
0010+  07F3 0A 00       			.dw 10
0011+  07F5 64 00       			.dw 100
0012+  07F7 E8 03       			.dw 1000
0013+  07F9 10 27       			.dw 10000
0014+  07FB             
0015+  07FB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  07FB             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  07FB             ; ASCII in BL
0018+  07FB             ; result in AL
0019+  07FB             ; ascii for F = 0100 0110
0020+  07FB             ; ascii for 9 = 0011 1001
0021+  07FB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  07FB             hex_ascii_encode:
0023+  07FB 1B          	mov al, bl
0024+  07FC 93 40       	test al, $40				; test if letter or number
0025+  07FE C7 04 08    	jnz hex_letter
0026+  0801 87 0F       	and al, $0F				; get number
0027+  0803 09          	ret
0028+  0804             hex_letter:
0029+  0804 87 0F       	and al, $0F				; get letter
0030+  0806 6A 09       	add al, 9
0031+  0808 09          	ret
0032+  0809             
0033+  0809             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  0809             ; ATOI
0035+  0809             ; 2 letter hex string in B
0036+  0809             ; 8bit integer returned in AL
0037+  0809             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0809             atoi:
0039+  0809 D8          	push b
0040+  080A 07 FB 07    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  080D 30          	mov bl, bh
0042+  080E DB          	push al					; save a
0043+  080F 07 FB 07    	call hex_ascii_encode
0044+  0812 EA          	pop bl	
0045+  0813 FD 9E 04    	shl al, 4
0046+  0816 8C          	or al, bl
0047+  0817 E5          	pop b
0048+  0818 09          	ret	
0049+  0819             
0050+  0819             
0051+  0819             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  0819             ; printf
0053+  0819             ; no need for explanations!
0054+  0819             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0819             printf:
0056+  0819 09          	ret
0057+  081A             
0058+  081A             
0059+  081A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  081A             ; scanf
0061+  081A             ; no need for explanations!
0062+  081A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  081A             scanf:
0064+  081A 09          	ret
0065+  081B             
0066+  081B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  081B             ; ITOA
0068+  081B             ; 8bit value in BL
0069+  081B             ; 2 byte ASCII result in A
0070+  081B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  081B             itoa:
0072+  081B DA          	push d
0073+  081C D8          	push b
0074+  081D A7 00       	mov bh, 0
0075+  081F FD A4 04    	shr bl, 4	
0076+  0822 74          	mov d, b
0077+  0823 1F D9 07    	mov al, [d + s_hex_digits]
0078+  0826 23          	mov ah, al
0079+  0827             	
0080+  0827 E5          	pop b
0081+  0828 D8          	push b
0082+  0829 A7 00       	mov bh, 0
0083+  082B FD 87 0F    	and bl, $0F
0084+  082E 74          	mov d, b
0085+  082F 1F D9 07    	mov al, [d + s_hex_digits]
0086+  0832 E5          	pop b
0087+  0833 E7          	pop d
0088+  0834 09          	ret
0089+  0835             
0090+  0835             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  0835             ; HEX STRING TO BINARY
0092+  0835             ; di = destination address
0093+  0835             ; si = source
0094+  0835             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  0835             hex_to_int:
0096+  0835             hex_to_int_L1:
0097+  0835 F6          	lodsb					; load from [SI] to AL
0098+  0836 B9 00       	cmp al, 0				; check if ASCII 0
0099+  0838 C6 45 08    	jz hex_to_int_ret
0100+  083B 36          	mov bh, al
0101+  083C F6          	lodsb
0102+  083D 2F          	mov bl, al
0103+  083E 07 09 08    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  0841 F7          	stosb					; store AL to [DI]
0105+  0842 0A 35 08    	jmp hex_to_int_L1
0106+  0845             hex_to_int_ret:
0107+  0845 09          	ret		
0108+  0846             
0109+  0846             
0110+  0846             
0111+  0846             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  0846             ; GETCHAR
0113+  0846             ; char in ah
0114+  0846             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  0846             getchar:
0116+  0846 DB          	push al
0117+  0847             getchar_retry:
0118+  0847 FD 0C       	sti
0119+  0849 19 01       	mov al, 1
0120+  084B 05 03       	syscall sys_io			; receive in AH
0121+  084D B9 00       	cmp al, 0			; check if any char was receive
0122+  084F C6 47 08    	je getchar_retry
0123+  0852 E8          	pop al
0124+  0853 09          	ret
0125+  0854             
0126+  0854             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  0854             ; PUTCHAR
0128+  0854             ; char in ah
0129+  0854             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0854             putchar:
0131+  0854 D7          	push a
0132+  0855 19 00       	mov al, 0
0133+  0857 05 03       	syscall sys_io			; char in AH
0134+  0859 E4          	pop a
0135+  085A 09          	ret
0136+  085B             
0137+  085B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  085B             ;; INPUT A STRING
0139+  085B             ;; terminates with null
0140+  085B             ;; pointer in D
0141+  085B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  085B             gets:
0143+  085B D7          	push a
0144+  085C DA          	push d
0145+  085D             gets_loop:
0146+  085D FD 0C       	sti
0147+  085F 19 01       	mov al, 1
0148+  0861 05 03       	syscall sys_io			; receive in AH
0149+  0863 B9 00       	cmp al, 0				; check error code (AL)
0150+  0865 C6 5D 08    	je gets_loop			; if no char received, retry
0151+  0868             
0152+  0868 76 1B       	cmp ah, 27
0153+  086A C6 8B 08    	je gets_telnet_escape
0154+  086D 76 0A       	cmp ah, $0A				; LF
0155+  086F C6 E4 08    	je gets_end
0156+  0872 76 0D       	cmp ah, $0D				; CR
0157+  0874 C6 E4 08    	je gets_end
0158+  0877 76 5C       	cmp ah, $5C				; '\\'
0159+  0879 C6 BB 08    	je gets_escape
0160+  087C             	
0161+  087C 76 08       	cmp ah, $08			; check for backspace
0162+  087E C6 87 08    	je gets_backspace
0163+  0881             
0164+  0881 1A          	mov al, ah
0165+  0882 3E          	mov [d], al
0166+  0883 79          	inc d
0167+  0884 0A 5D 08    	jmp gets_loop
0168+  0887             gets_backspace:
0169+  0887 7F          	dec d
0170+  0888 0A 5D 08    	jmp gets_loop
0171+  088B             gets_telnet_escape:
0172+  088B FD 0C       	sti
0173+  088D 19 01       	mov al, 1
0174+  088F 05 03       	syscall sys_io				; receive in AH without echo
0175+  0891 B9 00       	cmp al, 0					; check error code (AL)
0176+  0893 C6 8B 08    	je gets_telnet_escape		; if no char received, retry
0177+  0896 76 5B       	cmp ah, '['
0178+  0898 C7 5D 08    	jne gets_loop
0179+  089B             gets_telnet_escape_phase2:
0180+  089B FD 0C       	sti
0181+  089D 19 01       	mov al, 1
0182+  089F 05 03       	syscall sys_io					; receive in AH without echo
0183+  08A1 B9 00       	cmp al, 0						; check error code (AL)
0184+  08A3 C6 9B 08    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  08A6 76 44       	cmp ah, 'D'
0186+  08A8 C6 B3 08    	je gets_left_arrow
0187+  08AB 76 43       	cmp ah, 'C'
0188+  08AD C6 B7 08    	je gets_right_arrow
0189+  08B0 0A 5D 08    	jmp gets_loop
0190+  08B3             gets_left_arrow:
0191+  08B3 7F          	dec d
0192+  08B4 0A 5D 08    	jmp gets_loop
0193+  08B7             gets_right_arrow:
0194+  08B7 79          	inc d
0195+  08B8 0A 5D 08    	jmp gets_loop
0196+  08BB             gets_escape:
0197+  08BB FD 0C       	sti
0198+  08BD 19 01       	mov al, 1
0199+  08BF 05 03       	syscall sys_io			; receive in AH
0200+  08C1 B9 00       	cmp al, 0				; check error code (AL)
0201+  08C3 C6 BB 08    	je gets_escape			; if no char received, retry
0202+  08C6 76 6E       	cmp ah, 'n'
0203+  08C8 C6 D6 08    	je gets_LF
0204+  08CB 76 72       	cmp ah, 'r'
0205+  08CD C6 DD 08    	je gets_CR
0206+  08D0 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  08D1 3E          	mov [d], al
0208+  08D2 79          	inc d
0209+  08D3 0A 5D 08    	jmp gets_loop
0210+  08D6             gets_LF:
0211+  08D6 19 0A       	mov al, $0A
0212+  08D8 3E          	mov [d], al
0213+  08D9 79          	inc d
0214+  08DA 0A 5D 08    	jmp gets_loop
0215+  08DD             gets_CR:
0216+  08DD 19 0D       	mov al, $0D
0217+  08DF 3E          	mov [d], al
0218+  08E0 79          	inc d
0219+  08E1 0A 5D 08    	jmp gets_loop
0220+  08E4             gets_end:
0221+  08E4 19 00       	mov al, 0
0222+  08E6 3E          	mov [d], al				; terminate string
0223+  08E7 E7          	pop d
0224+  08E8 E4          	pop a
0225+  08E9 09          	ret
0226+  08EA             
0227+  08EA             
0228+  08EA             
0229+  08EA             
0230+  08EA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  08EA             ;; INPUT TEXT
0232+  08EA             ;; terminated with CTRL+D
0233+  08EA             ;; pointer in D
0234+  08EA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  08EA             gettxt:
0236+  08EA D7          	push a
0237+  08EB DA          	push d
0238+  08EC             gettxt_loop:
0239+  08EC 19 01       	mov al, 1
0240+  08EE 05 03       	syscall sys_io			; receive in AH
0241+  08F0 B9 00       	cmp al, 0				; check error code (AL)
0242+  08F2 C6 EC 08    	je gettxt_loop		; if no char received, retry
0243+  08F5 76 04       	cmp ah, 4			; EOT
0244+  08F7 C6 35 09    	je gettxt_end
0245+  08FA 76 08       	cmp ah, $08			; check for backspace
0246+  08FC C6 31 09    	je gettxt_backspace
0247+  08FF 76 5C       	cmp ah, $5C				; '\\'
0248+  0901 C6 0A 09    	je gettxt_escape
0249+  0904 1A          	mov al, ah
0250+  0905 3E          	mov [d], al
0251+  0906 79          	inc d
0252+  0907 0A EC 08    	jmp gettxt_loop
0253+  090A             gettxt_escape:
0254+  090A 19 01       	mov al, 1
0255+  090C 05 03       	syscall sys_io			; receive in AH
0256+  090E B9 00       	cmp al, 0				; check error code (AL)
0257+  0910 C6 0A 09    	je gettxt_escape		; if no char received, retry
0258+  0913 76 6E       	cmp ah, 'n'
0259+  0915 C6 23 09    	je gettxt_LF
0260+  0918 76 72       	cmp ah, 'r'
0261+  091A C6 2A 09    	je gettxt_CR
0262+  091D 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  091E 3E          	mov [d], al
0264+  091F 79          	inc d
0265+  0920 0A EC 08    	jmp gettxt_loop
0266+  0923             gettxt_LF:
0267+  0923 19 0A       	mov al, $0A
0268+  0925 3E          	mov [d], al
0269+  0926 79          	inc d
0270+  0927 0A EC 08    	jmp gettxt_loop
0271+  092A             gettxt_CR:
0272+  092A 19 0D       	mov al, $0D
0273+  092C 3E          	mov [d], al
0274+  092D 79          	inc d
0275+  092E 0A EC 08    	jmp gettxt_loop
0276+  0931             gettxt_backspace:
0277+  0931 7F          	dec d
0278+  0932 0A EC 08    	jmp gettxt_loop
0279+  0935             gettxt_end:
0280+  0935 19 00       	mov al, 0
0281+  0937 3E          	mov [d], al				; terminate string
0282+  0938 E7          	pop d
0283+  0939 E4          	pop a
0284+  093A 09          	ret
0285+  093B             
0286+  093B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  093B             ; PRINT NEW LINE
0288+  093B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  093B             printnl:
0290+  093B D7          	push a
0291+  093C 10 00 0A    	mov a, $0A00
0292+  093F 05 03       	syscall sys_io
0293+  0941 10 00 0D    	mov a, $0D00
0294+  0944 05 03       	syscall sys_io
0295+  0946 E4          	pop a
0296+  0947 09          	ret
0297+  0948             
0298+  0948             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  0948             ; strtoint
0300+  0948             ; 4 digit hex string number in d
0301+  0948             ; integer returned in A
0302+  0948             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  0948             strtointx:
0304+  0948 D8          	push b
0305+  0949 32          	mov bl, [d]
0306+  094A 37          	mov bh, bl
0307+  094B 33 01 00    	mov bl, [d + 1]
0308+  094E 07 09 08    	call atoi				; convert to int in AL
0309+  0951 23          	mov ah, al				; move to AH
0310+  0952 33 02 00    	mov bl, [d + 2]
0311+  0955 37          	mov bh, bl
0312+  0956 33 03 00    	mov bl, [d + 3]
0313+  0959 07 09 08    	call atoi				; convert to int in AL
0314+  095C E5          	pop b
0315+  095D 09          	ret
0316+  095E             
0317+  095E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  095E             ; strtoint
0319+  095E             ; 5 digit base10 string number in d
0320+  095E             ; integer returned in A
0321+  095E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  095E             strtoint:
0323+  095E E2          	push si
0324+  095F D8          	push b
0325+  0960 D9          	push c
0326+  0961 DA          	push d
0327+  0962 07 89 07    	call strlen			; get string length in C
0328+  0965 7E          	dec c
0329+  0966 FD 4E       	mov si, d
0330+  0968 12          	mov a, c
0331+  0969 FD 99       	shl a
0332+  096B 3B F1 07    	mov d, table_power
0333+  096E 59          	add d, a
0334+  096F 38 00 00    	mov c, 0
0335+  0972             strtoint_L0:
0336+  0972 F6          	lodsb			; load ASCII to al
0337+  0973 B9 00       	cmp al, 0
0338+  0975 C6 88 09    	je strtoint_end
0339+  0978 6F 30       	sub al, $30		; make into integer
0340+  097A 22 00       	mov ah, 0
0341+  097C 2A          	mov b, [d]
0342+  097D AC          	mul a, b			; result in B since it fits in 16bits
0343+  097E 11          	mov a, b
0344+  097F 28          	mov b, c
0345+  0980 54          	add a, b
0346+  0981 39          	mov c, a
0347+  0982 63 02 00    	sub d, 2
0348+  0985 0A 72 09    	jmp strtoint_L0
0349+  0988             strtoint_end:
0350+  0988 12          	mov a, c
0351+  0989 E7          	pop d
0352+  098A E6          	pop c
0353+  098B E5          	pop b
0354+  098C EF          	pop si
0355+  098D 09          	ret
0356+  098E             
0357+  098E             
0358+  098E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  098E             ; PRINT NULL TERMINATED STRING
0360+  098E             ; pointer in D
0361+  098E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  098E             puts:
0363+  098E D7          	push a
0364+  098F DA          	push d
0365+  0990             puts_L1:
0366+  0990 1E          	mov al, [d]
0367+  0991 B9 00       	cmp al, 0
0368+  0993 C6 9F 09    	jz puts_END
0369+  0996 23          	mov ah, al
0370+  0997 19 00       	mov al, 0
0371+  0999 05 03       	syscall sys_io
0372+  099B 79          	inc d
0373+  099C 0A 90 09    	jmp puts_L1
0374+  099F             puts_END:
0375+  099F E7          	pop d
0376+  09A0 E4          	pop a
0377+  09A1 09          	ret
0378+  09A2             
0379+  09A2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  09A2             ; PRINT N SIZE STRING
0381+  09A2             ; pointer in D
0382+  09A2             ; size in C
0383+  09A2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  09A2             putsn:
0385+  09A2 DB          	push al
0386+  09A3 DA          	push d
0387+  09A4 D9          	push c
0388+  09A5             putsn_L0:
0389+  09A5 1E          	mov al, [d]
0390+  09A6 23          	mov ah, al
0391+  09A7 19 00       	mov al, 0
0392+  09A9 05 03       	syscall sys_io
0393+  09AB 79          	inc d
0394+  09AC 7E          	dec c	
0395+  09AD C2 00 00    	cmp c, 0
0396+  09B0 C7 A5 09    	jne putsn_L0
0397+  09B3             putsn_end:
0398+  09B3 E6          	pop c
0399+  09B4 E7          	pop d
0400+  09B5 E8          	pop al
0401+  09B6 09          	ret
0402+  09B7             
0403+  09B7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  09B7             ; print 16bit decimal number
0405+  09B7             ; input number in A
0406+  09B7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  09B7             print_u16d:
0408+  09B7 D7          	push a
0409+  09B8 D8          	push b
0410+  09B9 26 10 27    	mov b, 10000
0411+  09BC AE          	div a, b			; get 10000's coeff.
0412+  09BD 07 DF 09    	call print_number
0413+  09C0 11          	mov a, b
0414+  09C1 26 E8 03    	mov b, 1000
0415+  09C4 AE          	div a, b			; get 1000's coeff.
0416+  09C5 07 DF 09    	call print_number
0417+  09C8 11          	mov a, b
0418+  09C9 26 64 00    	mov b, 100
0419+  09CC AE          	div a, b
0420+  09CD 07 DF 09    	call print_number
0421+  09D0 11          	mov a, b
0422+  09D1 26 0A 00    	mov b, 10
0423+  09D4 AE          	div a, b
0424+  09D5 07 DF 09    	call print_number
0425+  09D8 1B          	mov al, bl			; 1's coeff in bl
0426+  09D9 07 DF 09    	call print_number
0427+  09DC E5          	pop b
0428+  09DD E4          	pop a
0429+  09DE 09          	ret
0430+  09DF             
0431+  09DF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0432+  09DF             ; print AL
0433+  09DF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0434+  09DF             print_number:
0435+  09DF 6A 30       	add al, $30
0436+  09E1 23          	mov ah, al
0437+  09E2 07 54 08    	call putchar
0438+  09E5 09          	ret
0439+  09E6             
0440+  09E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0441+  09E6             ; PRINT 16BIT HEX INTEGER
0442+  09E6             ; integer value in reg B
0443+  09E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0444+  09E6             print_u16x:
0445+  09E6 D7          	push a
0446+  09E7 D8          	push b
0447+  09E8 DD          	push bl
0448+  09E9 30          	mov bl, bh
0449+  09EA 07 1B 08    	call itoa				; convert bh to char in A
0450+  09ED 2F          	mov bl, al				; save al
0451+  09EE 19 00       	mov al, 0
0452+  09F0 05 03       	syscall sys_io				; display AH
0453+  09F2 24          	mov ah, bl				; retrieve al
0454+  09F3 19 00       	mov al, 0
0455+  09F5 05 03       	syscall sys_io				; display AL
0456+  09F7             
0457+  09F7 EA          	pop bl
0458+  09F8 07 1B 08    	call itoa				; convert bh to char in A
0459+  09FB 2F          	mov bl, al				; save al
0460+  09FC 19 00       	mov al, 0
0461+  09FE 05 03       	syscall sys_io				; display AH
0462+  0A00 24          	mov ah, bl				; retrieve al
0463+  0A01 19 00       	mov al, 0
0464+  0A03 05 03       	syscall sys_io				; display AL
0465+  0A05             
0466+  0A05 E5          	pop b
0467+  0A06 E4          	pop a
0468+  0A07 09          	ret
0469+  0A08             
0470+  0A08             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0471+  0A08             ; INPUT 16BIT HEX INTEGER
0472+  0A08             ; read 16bit integer into A
0473+  0A08             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0474+  0A08             scan_u16x:
0475+  0A08 F8 10 00    	enter 16
0476+  0A0B D8          	push b
0477+  0A0C DA          	push d
0478+  0A0D             
0479+  0A0D FA F1 FF    	lea d, [bp + -15]
0480+  0A10 07 5B 08    	call gets				; get number
0481+  0A13             
0482+  0A13 32          	mov bl, [d]
0483+  0A14 37          	mov bh, bl
0484+  0A15 33 01 00    	mov bl, [d + 1]
0485+  0A18 07 09 08    	call atoi				; convert to int in AL
0486+  0A1B 23          	mov ah, al				; move to AH
0487+  0A1C             
0488+  0A1C 33 02 00    	mov bl, [d + 2]
0489+  0A1F 37          	mov bh, bl
0490+  0A20 33 03 00    	mov bl, [d + 3]
0491+  0A23 07 09 08    	call atoi				; convert to int in AL
0492+  0A26             
0493+  0A26 E7          	pop d
0494+  0A27 E5          	pop b
0495+  0A28 F9          	leave
0496+  0A29 09          	ret
0497+  0A2A             
0498+  0A2A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0499+  0A2A             ; PRINT 8bit HEX INTEGER
0500+  0A2A             ; integer value in reg bl
0501+  0A2A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0502+  0A2A             print_u8x:
0503+  0A2A D7          	push a
0504+  0A2B DD          	push bl
0505+  0A2C             
0506+  0A2C 07 1B 08    	call itoa				; convert bl to char in A
0507+  0A2F 2F          	mov bl, al				; save al
0508+  0A30 19 00       	mov al, 0
0509+  0A32 05 03       	syscall sys_io				; display AH
0510+  0A34 24          	mov ah, bl				; retrieve al
0511+  0A35 19 00       	mov al, 0
0512+  0A37 05 03       	syscall sys_io				; display AL
0513+  0A39             
0514+  0A39 EA          	pop bl
0515+  0A3A E4          	pop a
0516+  0A3B 09          	ret
0517+  0A3C             
0518+  0A3C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0519+  0A3C             ; print 8bit decimal unsigned number
0520+  0A3C             ; input number in AL
0521+  0A3C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0522+  0A3C             print_u8d:
0523+  0A3C D7          	push a
0524+  0A3D D8          	push b
0525+  0A3E             
0526+  0A3E 22 00       	mov ah, 0
0527+  0A40 26 64 00    	mov b, 100
0528+  0A43 AE          	div a, b
0529+  0A44 D8          	push b			; save remainder
0530+  0A45 B9 00       	cmp al, 0
0531+  0A47 C6 51 0A    	je skip100
0532+  0A4A 6A 30       	add al, $30
0533+  0A4C 23          	mov ah, al
0534+  0A4D 19 00       	mov al, 0
0535+  0A4F 05 03       	syscall sys_io	; print coeff
0536+  0A51             skip100:
0537+  0A51 E4          	pop a
0538+  0A52 22 00       	mov ah, 0
0539+  0A54 26 0A 00    	mov b, 10
0540+  0A57 AE          	div a, b
0541+  0A58 D8          	push b			; save remainder
0542+  0A59 B9 00       	cmp al, 0
0543+  0A5B C6 65 0A    	je skip10
0544+  0A5E 6A 30       	add al, $30
0545+  0A60 23          	mov ah, al
0546+  0A61 19 00       	mov al, 0
0547+  0A63 05 03       	syscall sys_io	; print coeff
0548+  0A65             skip10:
0549+  0A65 E4          	pop a
0550+  0A66 1B          	mov al, bl
0551+  0A67 6A 30       	add al, $30
0552+  0A69 23          	mov ah, al
0553+  0A6A 19 00       	mov al, 0
0554+  0A6C 05 03       	syscall sys_io	; print coeff
0555+  0A6E E5          	pop b
0556+  0A6F E4          	pop a
0557+  0A70 09          	ret
0558+  0A71             
0559+  0A71             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0560+  0A71             ; INPUT 8BIT HEX INTEGER
0561+  0A71             ; read 8bit integer into AL
0562+  0A71             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0563+  0A71             scan_u8x:
0564+  0A71 F8 04 00    	enter 4
0565+  0A74 D8          	push b
0566+  0A75 DA          	push d
0567+  0A76             
0568+  0A76 FA FD FF    	lea d, [bp + -3]
0569+  0A79 07 5B 08    	call gets				; get number
0570+  0A7C             
0571+  0A7C 32          	mov bl, [d]
0572+  0A7D 37          	mov bh, bl
0573+  0A7E 33 01 00    	mov bl, [d + 1]
0574+  0A81 07 09 08    	call atoi				; convert to int in AL
0575+  0A84             
0576+  0A84 E7          	pop d
0577+  0A85 E5          	pop b
0578+  0A86 F9          	leave
0579+  0A87 09          	ret
0580+  0A88             
0581+  0A88             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0582+  0A88             ; input decimal number
0583+  0A88             ; result in A
0584+  0A88             ; 655'\0'
0585+  0A88             ; low--------high
0586+  0A88             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  0A88             scan_u16d:
0588+  0A88 F8 08 00    	enter 8
0589+  0A8B E2          	push si
0590+  0A8C D8          	push b
0591+  0A8D D9          	push c
0592+  0A8E DA          	push d
0593+  0A8F FA F9 FF    	lea d, [bp +- 7]
0594+  0A92 07 5B 08    	call gets
0595+  0A95 07 89 07    	call strlen			; get string length in C
0596+  0A98 7E          	dec c
0597+  0A99 FD 4E       	mov si, d
0598+  0A9B 12          	mov a, c
0599+  0A9C FD 99       	shl a
0600+  0A9E 3B F1 07    	mov d, table_power
0601+  0AA1 59          	add d, a
0602+  0AA2 38 00 00    	mov c, 0
0603+  0AA5             mul_loop:
0604+  0AA5 F6          	lodsb			; load ASCII to al
0605+  0AA6 B9 00       	cmp al, 0
0606+  0AA8 C6 BB 0A    	je mul_exit
0607+  0AAB 6F 30       	sub al, $30		; make into integer
0608+  0AAD 22 00       	mov ah, 0
0609+  0AAF 2A          	mov b, [d]
0610+  0AB0 AC          	mul a, b			; result in B since it fits in 16bits
0611+  0AB1 11          	mov a, b
0612+  0AB2 28          	mov b, c
0613+  0AB3 54          	add a, b
0614+  0AB4 39          	mov c, a
0615+  0AB5 63 02 00    	sub d, 2
0616+  0AB8 0A A5 0A    	jmp mul_loop
0617+  0ABB             mul_exit:
0618+  0ABB 12          	mov a, c
0619+  0ABC E7          	pop d
0620+  0ABD E6          	pop c
0621+  0ABE E5          	pop b
0622+  0ABF EF          	pop si
0623+  0AC0 F9          	leave
0624+  0AC1 09          	ret
0017   0AC2             .include "ctype.asm"
0001+  0AC2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0AC2             ; ctype.s
0003+  0AC2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0AC2             
0005+  0AC2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  0AC2             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  0AC2             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  0AC2             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  0AC2             ;; characters are supported.
0010+  0AC2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  0AC2             ;; isalnum 
0012+  0AC2             ;; isalpha 
0013+  0AC2             ;; islower 
0014+  0AC2             ;; isupper 
0015+  0AC2             ;; isdigit 
0016+  0AC2             ;; isxdigit
0017+  0AC2             ;; iscntrl 
0018+  0AC2             ;; isgraph 
0019+  0AC2             ;; isspace 
0020+  0AC2             ;; isblank 
0021+  0AC2             ;; isprint 
0022+  0AC2             ;; ispunct 
0023+  0AC2             ;; tolower 
0024+  0AC2             ;; toupper
0025+  0AC2             
0026+  0AC2             
0027+  0AC2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  0AC2             ;; IS ALPHANUMERIC
0029+  0AC2             ;; sets ZF according with result
0030+  0AC2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  0AC2             isalnum:
0032+  0AC2 07 DF 0A    	call isalpha
0033+  0AC5 C6 CB 0A    	je isalnum_exit
0034+  0AC8 07 CC 0A    	call isdigit
0035+  0ACB             isalnum_exit:
0036+  0ACB 09          	ret	
0037+  0ACC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0ACC             ;; IS DIGIT
0039+  0ACC             ;; sets ZF according with result
0040+  0ACC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  0ACC             isdigit:
0042+  0ACC DB          	push al
0043+  0ACD B9 30       	cmp al, '0'
0044+  0ACF C8 DB 0A    	jlu isdigit_false
0045+  0AD2 B9 39       	cmp al, '9'
0046+  0AD4 D1 DB 0A    	jgu isdigit_false
0047+  0AD7 87 00       	and al, 0	; set ZF
0048+  0AD9 E8          	pop al
0049+  0ADA 09          	ret
0050+  0ADB             isdigit_false:
0051+  0ADB 8B 01       	or al, 1	; clear ZF
0052+  0ADD E8          	pop al
0053+  0ADE 09          	ret	
0054+  0ADF             	
0055+  0ADF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  0ADF             ;; IS ALPHA
0057+  0ADF             ;; sets ZF according with result
0058+  0ADF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  0ADF             isalpha:
0060+  0ADF DB          	push al
0061+  0AE0 B9 5F       	cmp al, '_'
0062+  0AE2 C6 02 0B    	je isalpha_true
0063+  0AE5 B9 2E       	cmp al, '.'
0064+  0AE7 C6 02 0B    	je isalpha_true
0065+  0AEA B9 41       	cmp al, 'A'
0066+  0AEC C8 FE 0A    	jlu isalpha_false
0067+  0AEF B9 7A       	cmp al, 'z'
0068+  0AF1 D1 FE 0A    	jgu isalpha_false
0069+  0AF4 B9 5A       	cmp al, 'Z'
0070+  0AF6 D0 02 0B    	jleu isalpha_true
0071+  0AF9 B9 61       	cmp al, 'a'
0072+  0AFB C9 02 0B    	jgeu isalpha_true
0073+  0AFE             isalpha_false:
0074+  0AFE 8B 01       	or al, 1	; clear ZF
0075+  0B00 E8          	pop al
0076+  0B01 09          	ret
0077+  0B02             isalpha_true:
0078+  0B02 87 00       	and al, 0	; set ZF
0079+  0B04 E8          	pop al
0080+  0B05 09          	ret
0081+  0B06             
0082+  0B06             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  0B06             ;; IS PATH-ALPHA
0084+  0B06             ;; sets ZF according with result
0085+  0B06             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  0B06             ispath:
0087+  0B06 DB          	push al
0088+  0B07 07 CC 0A    	call isdigit
0089+  0B0A C6 34 0B    	je ispath_true
0090+  0B0D B9 5F       	cmp al, '_'
0091+  0B0F C6 34 0B    	je ispath_true
0092+  0B12 B9 2F       	cmp al, '/'
0093+  0B14 C6 34 0B    	je ispath_true
0094+  0B17 B9 2E       	cmp al, '.'
0095+  0B19 C6 34 0B    	je ispath_true
0096+  0B1C B9 41       	cmp al, 'A'
0097+  0B1E C8 30 0B    	jlu ispath_false
0098+  0B21 B9 7A       	cmp al, 'z'
0099+  0B23 D1 30 0B    	jgu ispath_false
0100+  0B26 B9 5A       	cmp al, 'Z'
0101+  0B28 D0 34 0B    	jleu ispath_true
0102+  0B2B B9 61       	cmp al, 'a'
0103+  0B2D C9 34 0B    	jgeu ispath_true
0104+  0B30             ispath_false:
0105+  0B30 8B 01       	or al, 1	; clear ZF
0106+  0B32 E8          	pop al
0107+  0B33 09          	ret
0108+  0B34             ispath_true:
0109+  0B34 87 00       	and al, 0	; set ZF
0110+  0B36 E8          	pop al
0111+  0B37 09          	ret
0112+  0B38             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  0B38             ;; IS SPACE
0114+  0B38             ;; sets ZF according with result
0115+  0B38             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  0B38             isspace:
0117+  0B38 B9 20       	cmp al, $20		; ' '
0118+  0B3A C6 4E 0B    	je isspace_exit
0119+  0B3D B9 09       	cmp al, $09		; '\t'
0120+  0B3F C6 4E 0B    	je isspace_exit
0121+  0B42 B9 0A       	cmp al, $0A		; '\n'
0122+  0B44 C6 4E 0B    	je isspace_exit
0123+  0B47 B9 0D       	cmp al, $0D		; '\r'
0124+  0B49 C6 4E 0B    	je isspace_exit
0125+  0B4C B9 0B       	cmp al, $0B		; '\v'
0126+  0B4E             isspace_exit:
0127+  0B4E 09          	ret	
0128+  0B4F             
0129+  0B4F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0B4F             ; TO LOWER
0131+  0B4F             ; input in AL
0132+  0B4F             ; output in AL
0133+  0B4F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  0B4F             to_lower:
0135+  0B4F B9 5A       	cmp al, 'Z'
0136+  0B51 D1 56 0B    	jgu to_lower_ret
0137+  0B54 6A 20       	add al, $20				; convert to lower case
0138+  0B56             to_lower_ret:
0139+  0B56 09          	ret
0140+  0B57             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  0B57             ; TO UPPER
0142+  0B57             ; input in AL
0143+  0B57             ; output in AL
0144+  0B57             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  0B57             to_upper:
0146+  0B57 B9 61       	cmp al, 'a'
0147+  0B59 C8 5E 0B    	jlu to_upper_ret
0148+  0B5C 6F 20       	sub al, $20			; convert to upper case
0149+  0B5E             to_upper_ret:
0150+  0B5E 09          	ret
0151+  0B5F             
0018   0B5F             
0019   0B5F             .end
0020   0B5F             
0021   0B5F             
tasm: Number of errors = 0
