0001   0000             ;Code for division of floating point numbers
0002   0000             ;Performs fp_a divided by fp_b (that is, fp_a is dividend, fp_b is divisor)
0003   0000             ;Uses long_a, long_b, long_c and long_d to perform calculation
0004   0000             ;Quotient returned in fp_c
0005   0000             ;Does not check for zero divisor
0006   0000             			.include "kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0007   0400             			.org	1024
0008   0400             
0009   0400             ;First gets fp_a and fp_b from input
0010   0400             ;Get fp_a as an ascii hex string
0011   0400 07 07 0A    			call	printnl
0012   0403 3B 54 07    			mov	d,enter_fp_A_string
0013   0406 07 5A 0A    			call	puts
0014   0409 3B E6 07    			mov	d,buffer
0015   040C 07 27 09    			call	gets
0016   040F             ;Now parse string and put in fp_a
0017   040F 29 E6 07    			mov	b,[buffer]		;gets two ascii hex char values
0018   0412 FD AB       			swp	b			;mov gets little-endian, so need to swap bytes
0019   0414 07 D5 08    			call	atoi			;converts ascii hex pair in B to value in AL
0020   0417 3D B4 07    			mov	[fp_a],al
0021   041A 29 E8 07    			mov	b,[buffer+2]
0022   041D FD AB       			swp	b
0023   041F 07 D5 08    			call	atoi
0024   0422 3D B5 07    			mov	[fp_a+1],al
0025   0425 29 EA 07    			mov	b,[buffer+4]
0026   0428 FD AB       			swp	b
0027   042A 07 D5 08    			call	atoi
0028   042D 3D B6 07    			mov	[fp_a+2],al
0029   0430 29 EC 07    			mov	b,[buffer+6]
0030   0433 FD AB       			swp	b
0031   0435 07 D5 08    			call	atoi
0032   0438 3D B7 07    			mov	[fp_a+3],al
0033   043B             ;Get fp_b as an ascii hex string
0034   043B 07 07 0A    			call	printnl
0035   043E 3B 6E 07    			mov	d,enter_fp_B_string
0036   0441 07 5A 0A    			call	puts
0037   0444 3B E6 07    			mov	d,buffer
0038   0447 07 27 09    			call	gets
0039   044A             ;Now parse string and put in fp_b
0040   044A 29 E6 07    			mov	b,[buffer]		;gets two ascii hex char values
0041   044D FD AB       			swp	b			;mov gets little-endian, so need to swap bytes
0042   044F 07 D5 08    			call	atoi			;converts ascii hex pair in B to value in AL
0043   0452 3D B8 07    			mov	[fp_b],al
0044   0455 29 E8 07    			mov	b,[buffer+2]
0045   0458 FD AB       			swp	b
0046   045A 07 D5 08    			call	atoi
0047   045D 3D B9 07    			mov	[fp_b+1],al
0048   0460 29 EA 07    			mov	b,[buffer+4]
0049   0463 FD AB       			swp	b
0050   0465 07 D5 08    			call	atoi
0051   0468 3D BA 07    			mov	[fp_b+2],al
0052   046B 29 EC 07    			mov	b,[buffer+6]
0053   046E FD AB       			swp	b
0054   0470 07 D5 08    			call	atoi
0055   0473 3D BB 07    			mov	[fp_b+3],al
0056   0476             
0057   0476             divide_float:					
0058   0476             			
0059   0476             ;Calculate sign of quotient first (same as in multiplication)							
0060   0476 1D B4 07    			mov	al,[fp_a]
0061   0479 2F          			mov	bl,al
0062   047A 1D B8 07    			mov	al,[fp_b]
0063   047D 90          			xor	al,bl		;sign of result is XOR of signs of products
0064   047E 2F          			mov	bl,al
0065   047F 19 80       			mov	al,10000000b	;mask of remainder of bits
0066   0481 88          			and	al,bl
0067   0482 3D C0 07    			mov	[sign],al	;(sign) is 8-bit mask used to OR-in the sign bit
0068   0485             			
0069   0485             			
0070   0485             ;Calculate exponent of quotient (same as in multiplication, except subtract exp of fp_b from exp fp_a
0071   0485             ;Get exponent of a
0072   0485 1D B4 07    			mov	al,[fp_a]	;need to get bit 0 of exponent from bit 7 of
0073   0488 FD 9E 01    			shl	al,1		;fp_a+1 and combine with the rest of the
0074   048B 2F          			mov	bl,al		;exponent from fp_a
0075   048C 1D B5 07    			mov	al,[fp_a+1]	;is bit 7 one?
0076   048F 87 80       			and	al,10000000b
0077   0491 C7 98 04    			jnz	dfp_next_1	;yes, OR-in a 1 in bit 0 of exponent byte
0078   0494 1B          			mov	al,bl
0079   0495 0A 9B 04    			jmp	dfp_next_2	;no, skip OR-in (will have a zero from shift)
0080   0498 19 01       dfp_next_1:		mov	al,00000001b
0081   049A 8C          			or	al,bl
0082   049B             			
0083   049B             ;Remove exponent bias and save
0084   049B 6F 7F       dfp_next_2:		sub	al,127		;al now has unbiased exponent of a
0085   049D 3D C1 07    			mov	[exponent_a],al
0086   04A0             			
0087   04A0             ;Get exponent of b
0088   04A0 1D B8 07    			mov	al,[fp_b]	;need to get bit 0 of exponent from bit 7 of
0089   04A3 FD 9E 01    			shl	al,1		;fp_a+1 and combine with the rest of the
0090   04A6 2F          			mov	bl,al		;exponent from fp_a
0091   04A7 1D B9 07    			mov	al,[fp_b+1]	;is bit 7 one?
0092   04AA 87 80       			and	al,10000000b
0093   04AC C7 B3 04    			jnz	dfp_next_3	;yes, OR-in a 1 in bit 0 of exponent byte
0094   04AF 1B          			mov	al,bl
0095   04B0 0A B6 04    			jmp	dfp_next_4	;no, skip OR-in (will have a zero from shift)
0096   04B3 19 01       dfp_next_3:		mov	al,00000001b
0097   04B5 8C          			or	al,bl
0098   04B6             			
0099   04B6             ;Remove exponent bias and save
0100   04B6 6F 7F       dfp_next_4:		sub	al,127		;al now has unbiased exponent of b
0101   04B8 3D C2 07    			mov	[exponent_b],al
0102   04BB             			
0103   04BB             ;Subtract unbiased exponent b from a and save
0104   04BB 2F          			mov	bl,al		;temp store unbiased exp b
0105   04BC 1D C1 07    			mov	al,[exponent_a]
0106   04BF 70          			sub	al,bl		;unbiased exponent a - unbiased exponent b
0107   04C0 3D C3 07    			mov	[exponent_c],al	;exponent_c has unbiased exponent of result
0108   04C3             
0109   04C3             ;Divide significands
0110   04C3             ;Unpack and divide
0111   04C3 1D B5 07    			mov	al,[fp_a+1]	;need to set leftmost bit of significand to one
0112   04C6 2F          			mov	bl,al		;this bit is implied but not stored in fp
0113   04C7 19 80       			mov	al,10000000b
0114   04C9 8C          			or	al,bl
0115   04CA 3D C4 07    			mov	[long_a],al
0116   04CD 1D B6 07    			mov	al,[fp_a+2]
0117   04D0 3D C5 07    			mov	[long_a+1],al
0118   04D3 1D B7 07    			mov	al,[fp_a+3]
0119   04D6 3D C6 07    			mov	[long_a+2],al
0120   04D9 1D B9 07    			mov	al,[fp_b+1]
0121   04DC 2F          			mov	bl,al
0122   04DD 19 80       			mov	al,10000000b
0123   04DF 8C          			or	al,bl
0124   04E0 3D C7 07    			mov	[long_b],al
0125   04E3 1D BA 07    			mov	al,[fp_b+2]
0126   04E6 3D C8 07    			mov	[long_b+1],al
0127   04E9 1D BB 07    			mov	al,[fp_b+3]
0128   04EC 3D C9 07    			mov	[long_b+2],al
0129   04EF 07 5B 05    			call	divide_long
0130   04F2             			
0131   04F2             ;Normalize quotient		
0132   04F2 1D CA 07    dfp_loop_1:		mov	al,[long_c]	;check leftmost bit of quotient
0133   04F5 2F          			mov	bl,al
0134   04F6 19 80       			mov	al,10000000b
0135   04F8 88          			and	al,bl			;test leftmost bit of quotient
0136   04F9 C7 09 05    			jnz	dfp_next_5		;normalized, assemble final fp
0137   04FC 07 39 07    			call	shift_left_long_c	;not normalized, shift left and dec exponent
0138   04FF 1D C3 07    			mov	al,[exponent_c]
0139   0502 80          			dec	al
0140   0503 3D C3 07    			mov	[exponent_c],al
0141   0506 0A F2 04    			jmp	dfp_loop_1			
0142   0509             
0143   0509             ;Assemble final fp 
0144   0509 1D C3 07    dfp_next_5:		mov	al,[exponent_c]	;First byte is sign bit and bits 7 to 1
0145   050C 6A 7F       			add	al,127			;restore bias
0146   050E 3D C3 07    			mov	[exponent_c],al	;exponent_c now has biased exponent
0147   0511 FD A2 01    			shr	al,1
0148   0514 31 C0 07    			mov	bl,[sign]		;move over for sign bit
0149   0517 8C          			or	al,bl			;put sign bit in
0150   0518 3D BC 07    			mov	[fp_c],al		;First byte done
0151   051B 1D CA 07    			mov	al,[long_c]		;get first byte of mantissa
0152   051E 3D BD 07    			mov	[fp_c+1],al		;store in second byte of fp
0153   0521 1D C3 07    			mov	al,[exponent_c]	;check bit 0 of biased exponent
0154   0524 87 01       			and	al,00000001b		;test bit 0 of exponent
0155   0526 C7 31 05    			jnz	dfp_next_6		;bit is one, leave one in bit 7 of fp_c+1
0156   0529 1D BD 07    			mov	al,[fp_c+1]		;bit is 0, mask off bit 7 of fp_c+1
0157   052C 87 7F       			and	al,01111111b
0158   052E 3D BD 07    			mov	[fp_c+1],al
0159   0531 1D CB 07    dfp_next_6:		mov	al,[long_c+1]		;get second and third product bytes
0160   0534 3D BE 07    			mov	[fp_c+2],al
0161   0537 1D CC 07    			mov	al,[long_c+2]
0162   053A 3D BF 07    			mov	[fp_c+3],al		;complete fp product now assembled in fp_c
0163   053D             
0164   053D             ;Insert rounding code here -- check leftmost bits of double_long_a+4, and increment mantissa if rounding
0165   053D             
0166   053D             ;Print result
0167   053D 07 07 0A    			call	printnl
0168   0540 3B 88 07    			mov	d,result_string
0169   0543 07 5A 0A    			call	puts
0170   0546 29 BC 07    			mov	b,[fp_c]
0171   0549 FD AB       			swp	b
0172   054B 07 B2 0A    			call	print_u16x
0173   054E 29 BE 07    			mov	b,[fp_c+2]
0174   0551 FD AB       			swp	b
0175   0553 07 B2 0A    			call	print_u16x
0176   0556 07 07 0A    			call	printnl
0177   0559             
0178   0559 05 0B       			syscall sys_terminate_proc	;special call to return to OS
0179   055B             			
0180   055B             ;Subroutines
0181   055B             
0182   055B             ;Divide_long subroutine
0183   055B             ;Subroutine for 24-bit division
0184   055B             ;Dividend passed in long_a
0185   055B             ;Divisor passed in long_b
0186   055B             ;Divisor and dividend words must be left-aligned before passing
0187   055B             ;Does not check for zero divisor
0188   055B             ;Uses double_long_a, b and c and long_d for calculation
0189   055B             ;Quotient returned in long_c
0190   055B             ;Remainder returned in long_r
0191   055B             
0192   055B 19 00       divide_long:		mov	al,0			;clear variables used in calculation
0193   055D 3D D3 07    			mov	[double_long_a],al
0194   0560 3D D4 07    			mov	[double_long_a+1],al
0195   0563 3D D5 07    			mov	[double_long_a+2],al
0196   0566 3D D6 07    			mov	[double_long_a+3],al
0197   0569 3D D7 07    			mov	[double_long_a+4],al
0198   056C 3D D8 07    			mov	[double_long_a+5],al
0199   056F 3D D9 07    			mov	[double_long_b],al
0200   0572 3D DA 07    			mov	[double_long_b+1],al
0201   0575 3D DB 07    			mov	[double_long_b+2],al
0202   0578 3D DC 07    			mov	[double_long_b+3],al
0203   057B 3D DD 07    			mov	[double_long_b+4],al
0204   057E 3D DE 07    			mov	[double_long_b+5],al
0205   0581 3D DF 07    			mov	[double_long_c],al
0206   0584 3D E0 07    			mov	[double_long_c+1],al
0207   0587 3D E1 07    			mov	[double_long_c+2],al
0208   058A 3D E2 07    			mov	[double_long_c+3],al
0209   058D 3D E3 07    			mov	[double_long_c+4],al
0210   0590 3D E4 07    			mov	[double_long_c+5],al
0211   0593 3D CA 07    			mov	[long_c],al		;clear quotient
0212   0596 3D CB 07    			mov	[long_c+1],al
0213   0599 3D CC 07    			mov	[long_c+2],al
0214   059C 19 80       			mov	al,10000000b		;Set up mask to OR-in quotient bits
0215   059E 3D CD 07    			mov	[long_d],al
0216   05A1 19 00       			mov	al,0
0217   05A3 3D CE 07    			mov	[long_d+1],al
0218   05A6 3D CF 07    			mov	[long_d+2],al
0219   05A9 19 18       			mov	al,24
0220   05AB 3D E5 07    			mov	[divide_rounds],al	;Maximum 24 rounds of division
0221   05AE 1D C4 07    			mov	al,[long_a]		;set up divisor and dividend in 48-bit words
0222   05B1 3D D3 07    			mov	[double_long_a],al	;dividend
0223   05B4 1D C5 07    			mov	al,[long_a+1]
0224   05B7 3D D4 07    			mov	[double_long_a+1],al
0225   05BA 1D C6 07    			mov	al,[long_a+2]
0226   05BD 3D D5 07    			mov	[double_long_a+2],al
0227   05C0 1D C7 07    			mov	al,[long_b]		;divisor
0228   05C3 3D D9 07    			mov	[double_long_b],al
0229   05C6 1D C8 07    			mov	al,[long_b+1]
0230   05C9 3D DA 07    			mov	[double_long_b+1],al
0231   05CC 1D C9 07    			mov	al,[long_b+2]
0232   05CF 3D DB 07    			mov	[double_long_b+2],al
0233   05D2             						
0234   05D2 14 D7 07    long_divide_loop:	mov	a,[double_long_a+4]	;48-bit subtraction of divisor from dividend
0235   05D5 29 DD 07    			mov	b,[double_long_b+4]	;Divisor in double_long_b to reg b
0236   05D8 FD AA       			swp	a			;Dividend in double_long_a to reg a
0237   05DA FD AB       			swp	b
0238   05DC 60          			sub	a,b			;Reg A - Reg B is dividend - divisor
0239   05DD FD AA       			swp	a						
0240   05DF 42 E3 07    			mov	[double_long_c+4],a	;result placed in double_long_c
0241   05E2 14 D5 07    			mov	a,[double_long_a+2]	;move through bytes right to left
0242   05E5 29 DB 07    			mov	b,[double_long_b+2]
0243   05E8 FD AA       			swp	a
0244   05EA FD AB       			swp	b
0245   05EC 67          			sbb	a,b
0246   05ED FD AA       			swp	a
0247   05EF 42 E1 07    			mov	[double_long_c+2],a
0248   05F2 14 D3 07    			mov	a,[double_long_a]
0249   05F5 29 D9 07    			mov	b,[double_long_b]
0250   05F8 FD AA       			swp	a
0251   05FA FD AB       			swp	b
0252   05FC 67          			sbb	a,b
0253   05FD FD AA       			swp	a
0254   05FF 42 DF 07    			mov	[double_long_c],a	;double_long_c now has result of subtraction
0255   0602 C9 15 06    			jnc	long_quotient_one	;no borrow, put 1 in quotient and replace dividend
0256   0605 1D E5 07    			mov	al,[divide_rounds]	;borrow, leave 0 in quotient
0257   0608 80          			dec	al			;check if reached divide limit
0258   0609 C6 84 06    			jz	long_divide_done	;24 rounds done, quit
0259   060C 3D E5 07    			mov	[divide_rounds],al	;more rounds to do, go on
0260   060F 07 F5 06    			call	shift_right_long_d	;shift mask in long_d right one
0261   0612 0A 7E 06    			jmp	long_divisor_shift	;do not replace dividend, shift divisor
0262   0615             
0263   0615 1D CA 07    long_quotient_one:	mov	al,[long_c]		;place a one in quotient word
0264   0618 31 CD 07    			mov	bl,[long_d]
0265   061B 8C          			or	al,bl			;uses long_d as mask for quotient bits
0266   061C 3D CA 07    			mov	[long_c],al
0267   061F 1D CB 07    			mov	al,[long_c+1]
0268   0622 31 CE 07    			mov	bl,[long_d+1]
0269   0625 8C          			or	al,bl
0270   0626 3D CB 07    			mov	[long_c+1],al
0271   0629 1D CC 07    			mov	al,[long_c+2]
0272   062C 31 CF 07    			mov	bl,[long_d+2]
0273   062F 8C          			or	al,bl
0274   0630 3D CC 07    			mov	[long_c+2],al
0275   0633             
0276   0633 1D DF 07    			mov	al,[double_long_c]	;replace dividend with subtracted dividend
0277   0636 3D D3 07    			mov	[double_long_a],al
0278   0639 1D E0 07    			mov	al,[double_long_c+1]
0279   063C 3D D4 07    			mov	[double_long_a+1],al
0280   063F 1D E1 07    			mov	al,[double_long_c+2]
0281   0642 3D D5 07    			mov	[double_long_a+2],al
0282   0645 1D E2 07    			mov	al,[double_long_c+3]
0283   0648 3D D6 07    			mov	[double_long_a+3],al
0284   064B 1D E3 07    			mov	al,[double_long_c+4]
0285   064E 3D D7 07    			mov	[double_long_a+4],al
0286   0651 1D E4 07    			mov	al,[double_long_c+5]
0287   0654 3D D8 07    			mov	[double_long_a+5],al
0288   0657             
0289   0657             			
0290   0657 1D D3 07    			mov	al,[double_long_a]	;check if remainder zero
0291   065A 31 D4 07    			mov	bl,[double_long_a+1]
0292   065D 8C          			or	al,bl
0293   065E 31 D5 07    			mov	bl,[double_long_a+2]
0294   0661 8C          			or	al,bl
0295   0662 31 D6 07    			mov	bl,[double_long_a+3]
0296   0665 8C          			or	al,bl
0297   0666 31 D7 07    			mov	bl,[double_long_a+4]
0298   0669 8C          			or	al,bl
0299   066A 31 D8 07    			mov	bl,[double_long_a+5]
0300   066D 8C          			or	al,bl
0301   066E C6 84 06    			jz	long_divide_done	;remainder zero, quit
0302   0671 1D E5 07    			mov	al,[divide_rounds]	;remainder not zero, check if reached divide limit
0303   0674 80          			dec	al
0304   0675 C6 84 06    			jz	long_divide_done	;24 rounds done, quit
0305   0678 3D E5 07    			mov	[divide_rounds],al	;more rounds to do, go on
0306   067B 07 F5 06    			call	shift_right_long_d	;subroutine shifts mask in long_d one right
0307   067E             									
0308   067E 07 10 07    long_divisor_shift:	call	shift_right_double_long_b	;shift divisor in double_long_b one position
0309   0681 0A D2 05    			jmp	long_divide_loop
0310   0684             
0311   0684 1D E4 07    long_divide_done:	mov	al,[double_long_c+5]	;put remainder in long_r
0312   0687 3D D2 07    			mov	[long_r+2],al
0313   068A 1D E3 07    			mov	al,[double_long_c+4]
0314   068D 3D D1 07    			mov	[long_r+1],al
0315   0690 1D E2 07    			mov	al,[double_long_c+3]
0316   0693 3D D0 07    			mov	[long_r],al
0317   0696             			
0318   0696             ;Rounding code here. If remainder not zero, do one more round of division
0319   0696             ;If no borrow on this extra round of division, add 1 to quotient
0320   0696             
0321   0696 1D D0 07    			mov	al,[long_r]		;check if remainder zero
0322   0699 31 D1 07    			mov	bl,[long_r+1]
0323   069C 8C          			or	al,bl
0324   069D 31 D2 07    			mov	bl,[long_r+2]
0325   06A0 8C          			or	al,bl
0326   06A1 C6 F4 06    			jz	rounding_done		;If remainder zero, no need to round
0327   06A4             			
0328   06A4             ;Remainder not zero, do another round of division
0329   06A4 07 10 07    			call	shift_right_double_long_b
0330   06A7 14 D7 07    			mov	a,[double_long_a+4]	;48-bit subtraction of divisor from dividend
0331   06AA 29 DD 07    			mov	b,[double_long_b+4]	;Divisor in double_long_b to reg b
0332   06AD FD AA       			swp	a			;Dividend in double_long_a to reg a
0333   06AF FD AB       			swp	b
0334   06B1 60          			sub	a,b			;Reg A - Reg B is dividend - divisor
0335   06B2 FD AA       			swp	a						
0336   06B4 42 E3 07    			mov	[double_long_c+4],a	;result placed in double_long_c
0337   06B7 14 D5 07    			mov	a,[double_long_a+2]	;move through bytes right to left
0338   06BA 29 DB 07    			mov	b,[double_long_b+2]
0339   06BD FD AA       			swp	a
0340   06BF FD AB       			swp	b
0341   06C1 67          			sbb	a,b
0342   06C2 FD AA       			swp	a
0343   06C4 42 E1 07    			mov	[double_long_c+2],a
0344   06C7 14 D3 07    			mov	a,[double_long_a]
0345   06CA 29 D9 07    			mov	b,[double_long_b]
0346   06CD FD AA       			swp	a
0347   06CF FD AB       			swp	b
0348   06D1 67          			sbb	a,b
0349   06D2 FD AA       			swp	a
0350   06D4 42 DF 07    			mov	[double_long_c],a	;double_long_c now has result of subtraction
0351   06D7 C8 F4 06    			jc	rounding_done		;borrow, leave quotient alone
0352   06DA             							
0353   06DA 14 CB 07    			mov	a,[long_c+1]		;no borrow, round up
0354   06DD FD AA       			swp	a			;16-bit additions for 24-bit add one to quotient
0355   06DF 53 01 00    			add	a,1			
0356   06E2 FD AA       			swp	a				
0357   06E4 42 CB 07    			mov	[long_c+1],a
0358   06E7 14 C9 07    			mov	a,[long_c-1]		;uppermost byte will be garbage
0359   06EA FD AA       			swp	a
0360   06EC 5B 00 00    			adc	a,0
0361   06EF FD AA       			swp	a
0362   06F1 3D C9 07    			mov	[long_c-1],al
0363   06F4             			
0364   06F4 09          rounding_done:		ret
0365   06F5             		
0366   06F5 14 CD 07    shift_right_long_d:	mov	a,[long_d]	;16-bit load, little endian
0367   06F8 FD AA       			swp	a		;swap to make it fit the big-endian mantissa
0368   06FA FD 9B       			shr	a
0369   06FC FD AA       			swp	a
0370   06FE 42 CD 07    			mov	[long_d],a
0371   0701 14 CF 07    			mov	a,[long_d+2]	;16-bit load, but high byte in memory is garbage
0372   0704 3A 01       			mov	cl, 1
0373   0706 FD AA       			swp	a
0374   0708 FD E4       			rrc	a, cl
0375   070A FD AA       			swp	a
0376   070C 3D CF 07    			mov	[long_d+2],al	;discard high byte which is garbage
0377   070F 09          			ret
0378   0710             
0379   0710             shift_right_double_long_b:	
0380   0710 14 D9 07    			mov	a,[double_long_b]
0381   0713 FD AA       			swp	a
0382   0715 FD 9B       			shr	a
0383   0717 FD AA       			swp	a
0384   0719 42 D9 07    			mov	[double_long_b],a
0385   071C 14 DB 07    			mov	a,[double_long_b+2]
0386   071F 3A 01       			mov	cl, 1
0387   0721 FD AA       			swp	a
0388   0723 FD E4       			rrc	a, cl
0389   0725 FD AA       			swp	a
0390   0727 42 DB 07    			mov	[double_long_b+2],a
0391   072A 14 DD 07    			mov	a,[double_long_b+4]
0392   072D 3A 01       			mov	cl, 1
0393   072F FD AA       			swp	a
0394   0731 FD E4       			rrc	a, cl
0395   0733 FD AA       			swp	a
0396   0735 42 DD 07    			mov	[double_long_b+4],a
0397   0738 09          			ret
0398   0739             
0399   0739             ;Subroutine to shift left one a 24-bit value
0400   0739             ;24-bit value in long_c
0401   0739 14 CB 07    shift_left_long_c:	mov	a,[long_c+1]	;16-bit load, little endian
0402   073C FD AA       			swp	a		;swap to make it fit the big-endian mantissa
0403   073E FD 99       			shl	a
0404   0740 FD AA       			swp	a
0405   0742 42 CB 07    			mov	[long_c+1],a
0406   0745 14 C9 07    			mov	a,[long_c-1]	;16-bit load, low byte in memory is garbage
0407   0748 3A 01       			mov	cl, 1
0408   074A FD AA       			swp	a
0409   074C FD E0       			rlc	a, cl
0410   074E FD AA       			swp	a
0411   0750 42 C9 07    			mov	[long_c-1],a	;discard high byte which is garbage
0412   0753 09          			ret
0413   0754             ;Strings
0414   0754 45 6E 74 65 enter_fp_A_string:	.db	"Enter fp_A (32-bit hex): ",0
0414   0758 72 20 66 70 
0414   075C 5F 41 20 28 
0414   0760 33 32 2D 62 
0414   0764 69 74 20 68 
0414   0768 65 78 29 3A 
0414   076C 20 00 
0415   076E 45 6E 74 65 enter_fp_B_string:	.db	"Enter fp_B (32-bit hex): ",0
0415   0772 72 20 66 70 
0415   0776 5F 42 20 28 
0415   077A 33 32 2D 62 
0415   077E 69 74 20 68 
0415   0782 65 78 29 3A 
0415   0786 20 00 
0416   0788 52 65 73 75 result_string:		.db	"Result (quotient) of fp_A divided by fp_B: ",0			
0416   078C 6C 74 20 28 
0416   0790 71 75 6F 74 
0416   0794 69 65 6E 74 
0416   0798 29 20 6F 66 
0416   079C 20 66 70 5F 
0416   07A0 41 20 64 69 
0416   07A4 76 69 64 65 
0416   07A8 64 20 62 79 
0416   07AC 20 66 70 5F 
0416   07B0 42 3A 20 00 
0417   07B4             
0418   07B4             ;Variables
0419   07B4             			
0420   07B4 41 B2 CA C1 fp_a			.db	041h,0b2h,0cah,0c1h	;Dividend IEEE 754 float 0x41b2cac1 = decimal 22.349			
0421   07B8 42 9A 00 00 fp_b			.db	42h,9ah,00h,00h	;Divisor IEEE 754 float 0x429a0000 = decimal 77.0			
0422   07BC 00 00 00 00 fp_c			.db	0,0,0,0		;Quotient IEEE 754 float 0x3e949b39 = decimal 0.290246753			
0423   07C0 00          sign			.db	0			
0424   07C1 00          exponent_a		.db	0			
0425   07C2 00          exponent_b		.db	0			
0426   07C3 00          exponent_c		.db	0			
0427   07C4 00 00 00    long_a			.db	0,0,0		;Significand dividend			
0428   07C7 00 00 00    long_b			.db	0,0,0		;Significand divisor			
0429   07CA 00 00 00    long_c			.db	0,0,0		;Significand quotient			
0430   07CD 00 00 00    long_d			.db	0,0,0			
0431   07D0 00 00 00    long_r			.db	0,0,0		;Significand remainder			
0432   07D3 00 00 00 00 double_long_a		.db	0,0,0,0,0,0	;48-bit integer			
0432   07D7 00 00 
0433   07D9 00 00 00 00 double_long_b		.db	0,0,0,0,0,0	;48-bit interger			
0433   07DD 00 00 
0434   07DF 00 00 00 00 double_long_c		.db	0,0,0,0,0,0			
0434   07E3 00 00 
0435   07E5 00          divide_rounds		.db	0
0436   07E6             
0437   07E6             ;Input buffer		
0438   07E6 00 00 00 00 buffer:		.fill	40,0
0438   07EA 00 00 00 00 
0438   07EE 00 00 00 00 
0438   07F2 00 00 00 00 
0438   07F6 00 00 00 00 
0438   07FA 00 00 00 00 
0438   07FE 00 00 00 00 
0438   0802 00 00 00 00 
0438   0806 00 00 00 00 
0438   080A 00 00 00 00 
0439   080E             
0440   080E             			.include "stdio.asm"
0001+  080E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  080E             ; stdio.s
0003+  080E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  080E             .include "string.asm"
0001++ 080E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 080E             ; string.s
0003++ 080E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 080E             
0005++ 080E             
0006++ 080E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 080E             ; strrev
0008++ 080E             ; reverse a string
0009++ 080E             ; D = string address
0010++ 080E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 080E             ; 01234
0012++ 080E             strrev:
0013++ 080E 4B          	pusha
0014++ 080F 07 55 08    	call strlen	; length in C
0015++ 0812 12          	mov a, c
0016++ 0813 AF 01 00    	cmp a, 1
0017++ 0816 D0 30 08    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0819 7D          	dec a
0019++ 081A FD 4E       	mov si, d	; beginning of string
0020++ 081C FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 081E 59          	add d, a	; end of string
0022++ 081F 12          	mov a, c
0023++ 0820 FD 9B       	shr a		; divide by 2
0024++ 0822 39          	mov c, a	; C now counts the steps
0025++ 0823             strrev_L0:
0026++ 0823 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0824 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0825 3E          	mov [d], al	; store left char into right side
0029++ 0826 1B          	mov al, bl
0030++ 0827 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0828 7E          	dec c
0032++ 0829 7F          	dec d
0033++ 082A C2 00 00    	cmp c, 0
0034++ 082D C7 23 08    	jne strrev_L0
0035++ 0830             strrev_end:
0036++ 0830 4C          	popa
0037++ 0831 09          	ret
0038++ 0832             	
0039++ 0832             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0832             ; strchr
0041++ 0832             ; search string in D for char in AL
0042++ 0832             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0832             strchr:
0044++ 0832             strchr_L0:
0045++ 0832 32          	mov bl, [d]
0046++ 0833 C1 00       	cmp bl, 0
0047++ 0835 C6 40 08    	je strchr_end
0048++ 0838 BA          	cmp al, bl
0049++ 0839 C6 40 08    	je strchr_end
0050++ 083C 79          	inc d
0051++ 083D 0A 32 08    	jmp strchr_L0
0052++ 0840             strchr_end:
0053++ 0840 1B          	mov al, bl
0054++ 0841 09          	ret
0055++ 0842             
0056++ 0842             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0842             ; strstr
0058++ 0842             ; find sub-string
0059++ 0842             ; str1 in SI
0060++ 0842             ; str2 in DI
0061++ 0842             ; SI points to end of source string
0062++ 0842             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0842             strstr:
0064++ 0842 DB          	push al
0065++ 0843 DA          	push d
0066++ 0844 E3          	push di
0067++ 0845             strstr_loop:
0068++ 0845 F3          	cmpsb					; compare a byte of the strings
0069++ 0846 C7 51 08    	jne strstr_ret
0070++ 0849 FC 00 00    	lea d, [di + 0]
0071++ 084C BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 084E C7 45 08    	jne strstr_loop				; equal chars but not at end
0073++ 0851             strstr_ret:
0074++ 0851 F0          	pop di
0075++ 0852 E7          	pop d
0076++ 0853 E8          	pop al
0077++ 0854 09          	ret
0078++ 0855             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0855             ; length of null terminated string
0080++ 0855             ; result in C
0081++ 0855             ; pointer in D
0082++ 0855             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0855             strlen:
0084++ 0855 DA          	push d
0085++ 0856 38 00 00    	mov c, 0
0086++ 0859             strlen_L1:
0087++ 0859 BD 00       	cmp byte [d], 0
0088++ 085B C6 63 08    	je strlen_ret
0089++ 085E 79          	inc d
0090++ 085F 78          	inc c
0091++ 0860 0A 59 08    	jmp strlen_L1
0092++ 0863             strlen_ret:
0093++ 0863 E7          	pop d
0094++ 0864 09          	ret
0095++ 0865             
0096++ 0865             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0865             ; STRCMP
0098++ 0865             ; compare two strings
0099++ 0865             ; str1 in SI
0100++ 0865             ; str2 in DI
0101++ 0865             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0865             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0865             strcmp:
0104++ 0865 DB          	push al
0105++ 0866 DA          	push d
0106++ 0867 E3          	push di
0107++ 0868 E2          	push si
0108++ 0869             strcmp_loop:
0109++ 0869 F3          	cmpsb					; compare a byte of the strings
0110++ 086A C7 75 08    	jne strcmp_ret
0111++ 086D FB FF FF    	lea d, [si +- 1]
0112++ 0870 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0872 C7 69 08    	jne strcmp_loop				; equal chars but not at end
0114++ 0875             strcmp_ret:
0115++ 0875 EF          	pop si
0116++ 0876 F0          	pop di
0117++ 0877 E7          	pop d
0118++ 0878 E8          	pop al
0119++ 0879 09          	ret
0120++ 087A             
0121++ 087A             
0122++ 087A             ; STRCPY
0123++ 087A             ; copy null terminated string from SI to DI
0124++ 087A             ; source in SI
0125++ 087A             ; destination in DI
0126++ 087A             strcpy:
0127++ 087A E2          	push si
0128++ 087B E3          	push di
0129++ 087C DB          	push al
0130++ 087D             strcpy_L1:
0131++ 087D F6          	lodsb
0132++ 087E F7          	stosb
0133++ 087F B9 00       	cmp al, 0
0134++ 0881 C7 7D 08    	jne strcpy_L1
0135++ 0884             strcpy_end:
0136++ 0884 E8          	pop al
0137++ 0885 F0          	pop di
0138++ 0886 EF          	pop si
0139++ 0887 09          	ret
0140++ 0888             
0141++ 0888             ; STRCAT
0142++ 0888             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0888             ; source in SI
0144++ 0888             ; destination in DI
0145++ 0888             strcat:
0146++ 0888 E2          	push si
0147++ 0889 E3          	push di
0148++ 088A D7          	push a
0149++ 088B DA          	push d
0150++ 088C 50          	mov a, di
0151++ 088D 3C          	mov d, a
0152++ 088E             strcat_goto_end_L1:
0153++ 088E BD 00       	cmp byte[d], 0
0154++ 0890 C6 97 08    	je strcat_start
0155++ 0893 79          	inc d
0156++ 0894 0A 8E 08    	jmp strcat_goto_end_L1
0157++ 0897             strcat_start:
0158++ 0897 FD 50       	mov di, d
0159++ 0899             strcat_L1:
0160++ 0899 F6          	lodsb
0161++ 089A F7          	stosb
0162++ 089B B9 00       	cmp al, 0
0163++ 089D C7 99 08    	jne strcat_L1
0164++ 08A0             strcat_end:
0165++ 08A0 E7          	pop d
0166++ 08A1 E4          	pop a
0167++ 08A2 F0          	pop di
0168++ 08A3 EF          	pop si
0169++ 08A4 09          	ret
0005+  08A5             
0006+  08A5 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  08A9 34 35 36 37 
0006+  08AD 38 39 41 42 
0006+  08B1 43 44 45 46 
0007+  08B5 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  08B9 1B 5B 48 00 
0008+  08BD             
0009+  08BD 01 00       table_power:.dw 1
0010+  08BF 0A 00       			.dw 10
0011+  08C1 64 00       			.dw 100
0012+  08C3 E8 03       			.dw 1000
0013+  08C5 10 27       			.dw 10000
0014+  08C7             
0015+  08C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  08C7             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  08C7             ; ASCII in BL
0018+  08C7             ; result in AL
0019+  08C7             ; ascii for F = 0100 0110
0020+  08C7             ; ascii for 9 = 0011 1001
0021+  08C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  08C7             hex_ascii_encode:
0023+  08C7 1B          	mov al, bl
0024+  08C8 93 40       	test al, $40				; test if letter or number
0025+  08CA C7 D0 08    	jnz hex_letter
0026+  08CD 87 0F       	and al, $0F				; get number
0027+  08CF 09          	ret
0028+  08D0             hex_letter:
0029+  08D0 87 0F       	and al, $0F				; get letter
0030+  08D2 6A 09       	add al, 9
0031+  08D4 09          	ret
0032+  08D5             
0033+  08D5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  08D5             ; ATOI
0035+  08D5             ; 2 letter hex string in B
0036+  08D5             ; 8bit integer returned in AL
0037+  08D5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  08D5             atoi:
0039+  08D5 D8          	push b
0040+  08D6 07 C7 08    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  08D9 30          	mov bl, bh
0042+  08DA DB          	push al					; save a
0043+  08DB 07 C7 08    	call hex_ascii_encode
0044+  08DE EA          	pop bl	
0045+  08DF FD 9E 04    	shl al, 4
0046+  08E2 8C          	or al, bl
0047+  08E3 E5          	pop b
0048+  08E4 09          	ret	
0049+  08E5             
0050+  08E5             
0051+  08E5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  08E5             ; printf
0053+  08E5             ; no need for explanations!
0054+  08E5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  08E5             printf:
0056+  08E5 09          	ret
0057+  08E6             
0058+  08E6             
0059+  08E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  08E6             ; scanf
0061+  08E6             ; no need for explanations!
0062+  08E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  08E6             scanf:
0064+  08E6 09          	ret
0065+  08E7             
0066+  08E7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  08E7             ; ITOA
0068+  08E7             ; 8bit value in BL
0069+  08E7             ; 2 byte ASCII result in A
0070+  08E7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  08E7             itoa:
0072+  08E7 DA          	push d
0073+  08E8 D8          	push b
0074+  08E9 A7 00       	mov bh, 0
0075+  08EB FD A4 04    	shr bl, 4	
0076+  08EE 74          	mov d, b
0077+  08EF 1F A5 08    	mov al, [d + s_hex_digits]
0078+  08F2 23          	mov ah, al
0079+  08F3             	
0080+  08F3 E5          	pop b
0081+  08F4 D8          	push b
0082+  08F5 A7 00       	mov bh, 0
0083+  08F7 FD 87 0F    	and bl, $0F
0084+  08FA 74          	mov d, b
0085+  08FB 1F A5 08    	mov al, [d + s_hex_digits]
0086+  08FE E5          	pop b
0087+  08FF E7          	pop d
0088+  0900 09          	ret
0089+  0901             
0090+  0901             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  0901             ; HEX STRING TO BINARY
0092+  0901             ; di = destination address
0093+  0901             ; si = source
0094+  0901             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  0901             hex_to_int:
0096+  0901             hex_to_int_L1:
0097+  0901 F6          	lodsb					; load from [SI] to AL
0098+  0902 B9 00       	cmp al, 0				; check if ASCII 0
0099+  0904 C6 11 09    	jz hex_to_int_ret
0100+  0907 36          	mov bh, al
0101+  0908 F6          	lodsb
0102+  0909 2F          	mov bl, al
0103+  090A 07 D5 08    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  090D F7          	stosb					; store AL to [DI]
0105+  090E 0A 01 09    	jmp hex_to_int_L1
0106+  0911             hex_to_int_ret:
0107+  0911 09          	ret		
0108+  0912             
0109+  0912             
0110+  0912             
0111+  0912             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  0912             ; GETCHAR
0113+  0912             ; char in ah
0114+  0912             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  0912             getchar:
0116+  0912 DB          	push al
0117+  0913             getchar_retry:
0118+  0913 FD 0C       	sti
0119+  0915 19 01       	mov al, 1
0120+  0917 05 03       	syscall sys_io			; receive in AH
0121+  0919 B9 00       	cmp al, 0			; check if any char was receive
0122+  091B C6 13 09    	je getchar_retry
0123+  091E E8          	pop al
0124+  091F 09          	ret
0125+  0920             
0126+  0920             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  0920             ; PUTCHAR
0128+  0920             ; char in ah
0129+  0920             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0920             putchar:
0131+  0920 D7          	push a
0132+  0921 19 00       	mov al, 0
0133+  0923 05 03       	syscall sys_io			; char in AH
0134+  0925 E4          	pop a
0135+  0926 09          	ret
0136+  0927             
0137+  0927             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  0927             ;; INPUT A STRING
0139+  0927             ;; terminates with null
0140+  0927             ;; pointer in D
0141+  0927             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  0927             gets:
0143+  0927 D7          	push a
0144+  0928 DA          	push d
0145+  0929             gets_loop:
0146+  0929 FD 0C       	sti
0147+  092B 19 01       	mov al, 1
0148+  092D 05 03       	syscall sys_io			; receive in AH
0149+  092F B9 00       	cmp al, 0				; check error code (AL)
0150+  0931 C6 29 09    	je gets_loop			; if no char received, retry
0151+  0934             
0152+  0934 76 1B       	cmp ah, 27
0153+  0936 C6 57 09    	je gets_telnet_escape
0154+  0939 76 0A       	cmp ah, $0A				; LF
0155+  093B C6 B0 09    	je gets_end
0156+  093E 76 0D       	cmp ah, $0D				; CR
0157+  0940 C6 B0 09    	je gets_end
0158+  0943 76 5C       	cmp ah, $5C				; '\\'
0159+  0945 C6 87 09    	je gets_escape
0160+  0948             	
0161+  0948 76 08       	cmp ah, $08			; check for backspace
0162+  094A C6 53 09    	je gets_backspace
0163+  094D             
0164+  094D 1A          	mov al, ah
0165+  094E 3E          	mov [d], al
0166+  094F 79          	inc d
0167+  0950 0A 29 09    	jmp gets_loop
0168+  0953             gets_backspace:
0169+  0953 7F          	dec d
0170+  0954 0A 29 09    	jmp gets_loop
0171+  0957             gets_telnet_escape:
0172+  0957 FD 0C       	sti
0173+  0959 19 01       	mov al, 1
0174+  095B 05 03       	syscall sys_io				; receive in AH without echo
0175+  095D B9 00       	cmp al, 0					; check error code (AL)
0176+  095F C6 57 09    	je gets_telnet_escape		; if no char received, retry
0177+  0962 76 5B       	cmp ah, '['
0178+  0964 C7 29 09    	jne gets_loop
0179+  0967             gets_telnet_escape_phase2:
0180+  0967 FD 0C       	sti
0181+  0969 19 01       	mov al, 1
0182+  096B 05 03       	syscall sys_io					; receive in AH without echo
0183+  096D B9 00       	cmp al, 0						; check error code (AL)
0184+  096F C6 67 09    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  0972 76 44       	cmp ah, 'D'
0186+  0974 C6 7F 09    	je gets_left_arrow
0187+  0977 76 43       	cmp ah, 'C'
0188+  0979 C6 83 09    	je gets_right_arrow
0189+  097C 0A 29 09    	jmp gets_loop
0190+  097F             gets_left_arrow:
0191+  097F 7F          	dec d
0192+  0980 0A 29 09    	jmp gets_loop
0193+  0983             gets_right_arrow:
0194+  0983 79          	inc d
0195+  0984 0A 29 09    	jmp gets_loop
0196+  0987             gets_escape:
0197+  0987 FD 0C       	sti
0198+  0989 19 01       	mov al, 1
0199+  098B 05 03       	syscall sys_io			; receive in AH
0200+  098D B9 00       	cmp al, 0				; check error code (AL)
0201+  098F C6 87 09    	je gets_escape			; if no char received, retry
0202+  0992 76 6E       	cmp ah, 'n'
0203+  0994 C6 A2 09    	je gets_LF
0204+  0997 76 72       	cmp ah, 'r'
0205+  0999 C6 A9 09    	je gets_CR
0206+  099C 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  099D 3E          	mov [d], al
0208+  099E 79          	inc d
0209+  099F 0A 29 09    	jmp gets_loop
0210+  09A2             gets_LF:
0211+  09A2 19 0A       	mov al, $0A
0212+  09A4 3E          	mov [d], al
0213+  09A5 79          	inc d
0214+  09A6 0A 29 09    	jmp gets_loop
0215+  09A9             gets_CR:
0216+  09A9 19 0D       	mov al, $0D
0217+  09AB 3E          	mov [d], al
0218+  09AC 79          	inc d
0219+  09AD 0A 29 09    	jmp gets_loop
0220+  09B0             gets_end:
0221+  09B0 19 00       	mov al, 0
0222+  09B2 3E          	mov [d], al				; terminate string
0223+  09B3 E7          	pop d
0224+  09B4 E4          	pop a
0225+  09B5 09          	ret
0226+  09B6             
0227+  09B6             
0228+  09B6             
0229+  09B6             
0230+  09B6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  09B6             ;; INPUT TEXT
0232+  09B6             ;; terminated with CTRL+D
0233+  09B6             ;; pointer in D
0234+  09B6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  09B6             gettxt:
0236+  09B6 D7          	push a
0237+  09B7 DA          	push d
0238+  09B8             gettxt_loop:
0239+  09B8 19 01       	mov al, 1
0240+  09BA 05 03       	syscall sys_io			; receive in AH
0241+  09BC B9 00       	cmp al, 0				; check error code (AL)
0242+  09BE C6 B8 09    	je gettxt_loop		; if no char received, retry
0243+  09C1 76 04       	cmp ah, 4			; EOT
0244+  09C3 C6 01 0A    	je gettxt_end
0245+  09C6 76 08       	cmp ah, $08			; check for backspace
0246+  09C8 C6 FD 09    	je gettxt_backspace
0247+  09CB 76 5C       	cmp ah, $5C				; '\\'
0248+  09CD C6 D6 09    	je gettxt_escape
0249+  09D0 1A          	mov al, ah
0250+  09D1 3E          	mov [d], al
0251+  09D2 79          	inc d
0252+  09D3 0A B8 09    	jmp gettxt_loop
0253+  09D6             gettxt_escape:
0254+  09D6 19 01       	mov al, 1
0255+  09D8 05 03       	syscall sys_io			; receive in AH
0256+  09DA B9 00       	cmp al, 0				; check error code (AL)
0257+  09DC C6 D6 09    	je gettxt_escape		; if no char received, retry
0258+  09DF 76 6E       	cmp ah, 'n'
0259+  09E1 C6 EF 09    	je gettxt_LF
0260+  09E4 76 72       	cmp ah, 'r'
0261+  09E6 C6 F6 09    	je gettxt_CR
0262+  09E9 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  09EA 3E          	mov [d], al
0264+  09EB 79          	inc d
0265+  09EC 0A B8 09    	jmp gettxt_loop
0266+  09EF             gettxt_LF:
0267+  09EF 19 0A       	mov al, $0A
0268+  09F1 3E          	mov [d], al
0269+  09F2 79          	inc d
0270+  09F3 0A B8 09    	jmp gettxt_loop
0271+  09F6             gettxt_CR:
0272+  09F6 19 0D       	mov al, $0D
0273+  09F8 3E          	mov [d], al
0274+  09F9 79          	inc d
0275+  09FA 0A B8 09    	jmp gettxt_loop
0276+  09FD             gettxt_backspace:
0277+  09FD 7F          	dec d
0278+  09FE 0A B8 09    	jmp gettxt_loop
0279+  0A01             gettxt_end:
0280+  0A01 19 00       	mov al, 0
0281+  0A03 3E          	mov [d], al				; terminate string
0282+  0A04 E7          	pop d
0283+  0A05 E4          	pop a
0284+  0A06 09          	ret
0285+  0A07             
0286+  0A07             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  0A07             ; PRINT NEW LINE
0288+  0A07             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  0A07             printnl:
0290+  0A07 D7          	push a
0291+  0A08 10 00 0A    	mov a, $0A00
0292+  0A0B 05 03       	syscall sys_io
0293+  0A0D 10 00 0D    	mov a, $0D00
0294+  0A10 05 03       	syscall sys_io
0295+  0A12 E4          	pop a
0296+  0A13 09          	ret
0297+  0A14             
0298+  0A14             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  0A14             ; strtoint
0300+  0A14             ; 4 digit hex string number in d
0301+  0A14             ; integer returned in A
0302+  0A14             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  0A14             strtointx:
0304+  0A14 D8          	push b
0305+  0A15 32          	mov bl, [d]
0306+  0A16 37          	mov bh, bl
0307+  0A17 33 01 00    	mov bl, [d + 1]
0308+  0A1A 07 D5 08    	call atoi				; convert to int in AL
0309+  0A1D 23          	mov ah, al				; move to AH
0310+  0A1E 33 02 00    	mov bl, [d + 2]
0311+  0A21 37          	mov bh, bl
0312+  0A22 33 03 00    	mov bl, [d + 3]
0313+  0A25 07 D5 08    	call atoi				; convert to int in AL
0314+  0A28 E5          	pop b
0315+  0A29 09          	ret
0316+  0A2A             
0317+  0A2A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  0A2A             ; strtoint
0319+  0A2A             ; 5 digit base10 string number in d
0320+  0A2A             ; integer returned in A
0321+  0A2A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  0A2A             strtoint:
0323+  0A2A E2          	push si
0324+  0A2B D8          	push b
0325+  0A2C D9          	push c
0326+  0A2D DA          	push d
0327+  0A2E 07 55 08    	call strlen			; get string length in C
0328+  0A31 7E          	dec c
0329+  0A32 FD 4E       	mov si, d
0330+  0A34 12          	mov a, c
0331+  0A35 FD 99       	shl a
0332+  0A37 3B BD 08    	mov d, table_power
0333+  0A3A 59          	add d, a
0334+  0A3B 38 00 00    	mov c, 0
0335+  0A3E             strtoint_L0:
0336+  0A3E F6          	lodsb			; load ASCII to al
0337+  0A3F B9 00       	cmp al, 0
0338+  0A41 C6 54 0A    	je strtoint_end
0339+  0A44 6F 30       	sub al, $30		; make into integer
0340+  0A46 22 00       	mov ah, 0
0341+  0A48 2A          	mov b, [d]
0342+  0A49 AC          	mul a, b			; result in B since it fits in 16bits
0343+  0A4A 11          	mov a, b
0344+  0A4B 28          	mov b, c
0345+  0A4C 54          	add a, b
0346+  0A4D 39          	mov c, a
0347+  0A4E 63 02 00    	sub d, 2
0348+  0A51 0A 3E 0A    	jmp strtoint_L0
0349+  0A54             strtoint_end:
0350+  0A54 12          	mov a, c
0351+  0A55 E7          	pop d
0352+  0A56 E6          	pop c
0353+  0A57 E5          	pop b
0354+  0A58 EF          	pop si
0355+  0A59 09          	ret
0356+  0A5A             
0357+  0A5A             
0358+  0A5A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  0A5A             ; PRINT NULL TERMINATED STRING
0360+  0A5A             ; pointer in D
0361+  0A5A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  0A5A             puts:
0363+  0A5A D7          	push a
0364+  0A5B DA          	push d
0365+  0A5C             puts_L1:
0366+  0A5C 1E          	mov al, [d]
0367+  0A5D B9 00       	cmp al, 0
0368+  0A5F C6 6B 0A    	jz puts_END
0369+  0A62 23          	mov ah, al
0370+  0A63 19 00       	mov al, 0
0371+  0A65 05 03       	syscall sys_io
0372+  0A67 79          	inc d
0373+  0A68 0A 5C 0A    	jmp puts_L1
0374+  0A6B             puts_END:
0375+  0A6B E7          	pop d
0376+  0A6C E4          	pop a
0377+  0A6D 09          	ret
0378+  0A6E             
0379+  0A6E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  0A6E             ; PRINT N SIZE STRING
0381+  0A6E             ; pointer in D
0382+  0A6E             ; size in C
0383+  0A6E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  0A6E             putsn:
0385+  0A6E DB          	push al
0386+  0A6F DA          	push d
0387+  0A70 D9          	push c
0388+  0A71             putsn_L0:
0389+  0A71 1E          	mov al, [d]
0390+  0A72 23          	mov ah, al
0391+  0A73 19 00       	mov al, 0
0392+  0A75 05 03       	syscall sys_io
0393+  0A77 79          	inc d
0394+  0A78 7E          	dec c	
0395+  0A79 C2 00 00    	cmp c, 0
0396+  0A7C C7 71 0A    	jne putsn_L0
0397+  0A7F             putsn_end:
0398+  0A7F E6          	pop c
0399+  0A80 E7          	pop d
0400+  0A81 E8          	pop al
0401+  0A82 09          	ret
0402+  0A83             
0403+  0A83             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  0A83             ; print 16bit decimal number
0405+  0A83             ; input number in A
0406+  0A83             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  0A83             print_u16d:
0408+  0A83 D7          	push a
0409+  0A84 D8          	push b
0410+  0A85 26 10 27    	mov b, 10000
0411+  0A88 AE          	div a, b			; get 10000's coeff.
0412+  0A89 07 AB 0A    	call print_number
0413+  0A8C 11          	mov a, b
0414+  0A8D 26 E8 03    	mov b, 1000
0415+  0A90 AE          	div a, b			; get 1000's coeff.
0416+  0A91 07 AB 0A    	call print_number
0417+  0A94 11          	mov a, b
0418+  0A95 26 64 00    	mov b, 100
0419+  0A98 AE          	div a, b
0420+  0A99 07 AB 0A    	call print_number
0421+  0A9C 11          	mov a, b
0422+  0A9D 26 0A 00    	mov b, 10
0423+  0AA0 AE          	div a, b
0424+  0AA1 07 AB 0A    	call print_number
0425+  0AA4 1B          	mov al, bl			; 1's coeff in bl
0426+  0AA5 07 AB 0A    	call print_number
0427+  0AA8 E5          	pop b
0428+  0AA9 E4          	pop a
0429+  0AAA 09          	ret
0430+  0AAB             
0431+  0AAB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0432+  0AAB             ; print AL
0433+  0AAB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0434+  0AAB             print_number:
0435+  0AAB 6A 30       	add al, $30
0436+  0AAD 23          	mov ah, al
0437+  0AAE 07 20 09    	call putchar
0438+  0AB1 09          	ret
0439+  0AB2             
0440+  0AB2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0441+  0AB2             ; PRINT 16BIT HEX INTEGER
0442+  0AB2             ; integer value in reg B
0443+  0AB2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0444+  0AB2             print_u16x:
0445+  0AB2 D7          	push a
0446+  0AB3 D8          	push b
0447+  0AB4 DD          	push bl
0448+  0AB5 30          	mov bl, bh
0449+  0AB6 07 E7 08    	call itoa				; convert bh to char in A
0450+  0AB9 2F          	mov bl, al				; save al
0451+  0ABA 19 00       	mov al, 0
0452+  0ABC 05 03       	syscall sys_io				; display AH
0453+  0ABE 24          	mov ah, bl				; retrieve al
0454+  0ABF 19 00       	mov al, 0
0455+  0AC1 05 03       	syscall sys_io				; display AL
0456+  0AC3             
0457+  0AC3 EA          	pop bl
0458+  0AC4 07 E7 08    	call itoa				; convert bh to char in A
0459+  0AC7 2F          	mov bl, al				; save al
0460+  0AC8 19 00       	mov al, 0
0461+  0ACA 05 03       	syscall sys_io				; display AH
0462+  0ACC 24          	mov ah, bl				; retrieve al
0463+  0ACD 19 00       	mov al, 0
0464+  0ACF 05 03       	syscall sys_io				; display AL
0465+  0AD1             
0466+  0AD1 E5          	pop b
0467+  0AD2 E4          	pop a
0468+  0AD3 09          	ret
0469+  0AD4             
0470+  0AD4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0471+  0AD4             ; INPUT 16BIT HEX INTEGER
0472+  0AD4             ; read 16bit integer into A
0473+  0AD4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0474+  0AD4             scan_u16x:
0475+  0AD4 F8 10 00    	enter 16
0476+  0AD7 D8          	push b
0477+  0AD8 DA          	push d
0478+  0AD9             
0479+  0AD9 FA F1 FF    	lea d, [bp + -15]
0480+  0ADC 07 27 09    	call gets				; get number
0481+  0ADF             
0482+  0ADF 32          	mov bl, [d]
0483+  0AE0 37          	mov bh, bl
0484+  0AE1 33 01 00    	mov bl, [d + 1]
0485+  0AE4 07 D5 08    	call atoi				; convert to int in AL
0486+  0AE7 23          	mov ah, al				; move to AH
0487+  0AE8             
0488+  0AE8 33 02 00    	mov bl, [d + 2]
0489+  0AEB 37          	mov bh, bl
0490+  0AEC 33 03 00    	mov bl, [d + 3]
0491+  0AEF 07 D5 08    	call atoi				; convert to int in AL
0492+  0AF2             
0493+  0AF2 E7          	pop d
0494+  0AF3 E5          	pop b
0495+  0AF4 F9          	leave
0496+  0AF5 09          	ret
0497+  0AF6             
0498+  0AF6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0499+  0AF6             ; PRINT 8bit HEX INTEGER
0500+  0AF6             ; integer value in reg bl
0501+  0AF6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0502+  0AF6             print_u8x:
0503+  0AF6 D7          	push a
0504+  0AF7 DD          	push bl
0505+  0AF8             
0506+  0AF8 07 E7 08    	call itoa				; convert bl to char in A
0507+  0AFB 2F          	mov bl, al				; save al
0508+  0AFC 19 00       	mov al, 0
0509+  0AFE 05 03       	syscall sys_io				; display AH
0510+  0B00 24          	mov ah, bl				; retrieve al
0511+  0B01 19 00       	mov al, 0
0512+  0B03 05 03       	syscall sys_io				; display AL
0513+  0B05             
0514+  0B05 EA          	pop bl
0515+  0B06 E4          	pop a
0516+  0B07 09          	ret
0517+  0B08             
0518+  0B08             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0519+  0B08             ; print 8bit decimal unsigned number
0520+  0B08             ; input number in AL
0521+  0B08             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0522+  0B08             print_u8d:
0523+  0B08 D7          	push a
0524+  0B09 D8          	push b
0525+  0B0A             
0526+  0B0A 22 00       	mov ah, 0
0527+  0B0C 26 64 00    	mov b, 100
0528+  0B0F AE          	div a, b
0529+  0B10 D8          	push b			; save remainder
0530+  0B11 B9 00       	cmp al, 0
0531+  0B13 C6 1D 0B    	je skip100
0532+  0B16 6A 30       	add al, $30
0533+  0B18 23          	mov ah, al
0534+  0B19 19 00       	mov al, 0
0535+  0B1B 05 03       	syscall sys_io	; print coeff
0536+  0B1D             skip100:
0537+  0B1D E4          	pop a
0538+  0B1E 22 00       	mov ah, 0
0539+  0B20 26 0A 00    	mov b, 10
0540+  0B23 AE          	div a, b
0541+  0B24 D8          	push b			; save remainder
0542+  0B25 B9 00       	cmp al, 0
0543+  0B27 C6 31 0B    	je skip10
0544+  0B2A 6A 30       	add al, $30
0545+  0B2C 23          	mov ah, al
0546+  0B2D 19 00       	mov al, 0
0547+  0B2F 05 03       	syscall sys_io	; print coeff
0548+  0B31             skip10:
0549+  0B31 E4          	pop a
0550+  0B32 1B          	mov al, bl
0551+  0B33 6A 30       	add al, $30
0552+  0B35 23          	mov ah, al
0553+  0B36 19 00       	mov al, 0
0554+  0B38 05 03       	syscall sys_io	; print coeff
0555+  0B3A E5          	pop b
0556+  0B3B E4          	pop a
0557+  0B3C 09          	ret
0558+  0B3D             
0559+  0B3D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0560+  0B3D             ; INPUT 8BIT HEX INTEGER
0561+  0B3D             ; read 8bit integer into AL
0562+  0B3D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0563+  0B3D             scan_u8x:
0564+  0B3D F8 04 00    	enter 4
0565+  0B40 D8          	push b
0566+  0B41 DA          	push d
0567+  0B42             
0568+  0B42 FA FD FF    	lea d, [bp + -3]
0569+  0B45 07 27 09    	call gets				; get number
0570+  0B48             
0571+  0B48 32          	mov bl, [d]
0572+  0B49 37          	mov bh, bl
0573+  0B4A 33 01 00    	mov bl, [d + 1]
0574+  0B4D 07 D5 08    	call atoi				; convert to int in AL
0575+  0B50             
0576+  0B50 E7          	pop d
0577+  0B51 E5          	pop b
0578+  0B52 F9          	leave
0579+  0B53 09          	ret
0580+  0B54             
0581+  0B54             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0582+  0B54             ; input decimal number
0583+  0B54             ; result in A
0584+  0B54             ; 655'\0'
0585+  0B54             ; low--------high
0586+  0B54             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  0B54             scan_u16d:
0588+  0B54 F8 08 00    	enter 8
0589+  0B57 E2          	push si
0590+  0B58 D8          	push b
0591+  0B59 D9          	push c
0592+  0B5A DA          	push d
0593+  0B5B FA F9 FF    	lea d, [bp +- 7]
0594+  0B5E 07 27 09    	call gets
0595+  0B61 07 55 08    	call strlen			; get string length in C
0596+  0B64 7E          	dec c
0597+  0B65 FD 4E       	mov si, d
0598+  0B67 12          	mov a, c
0599+  0B68 FD 99       	shl a
0600+  0B6A 3B BD 08    	mov d, table_power
0601+  0B6D 59          	add d, a
0602+  0B6E 38 00 00    	mov c, 0
0603+  0B71             mul_loop:
0604+  0B71 F6          	lodsb			; load ASCII to al
0605+  0B72 B9 00       	cmp al, 0
0606+  0B74 C6 87 0B    	je mul_exit
0607+  0B77 6F 30       	sub al, $30		; make into integer
0608+  0B79 22 00       	mov ah, 0
0609+  0B7B 2A          	mov b, [d]
0610+  0B7C AC          	mul a, b			; result in B since it fits in 16bits
0611+  0B7D 11          	mov a, b
0612+  0B7E 28          	mov b, c
0613+  0B7F 54          	add a, b
0614+  0B80 39          	mov c, a
0615+  0B81 63 02 00    	sub d, 2
0616+  0B84 0A 71 0B    	jmp mul_loop
0617+  0B87             mul_exit:
0618+  0B87 12          	mov a, c
0619+  0B88 E7          	pop d
0620+  0B89 E6          	pop c
0621+  0B8A E5          	pop b
0622+  0B8B EF          	pop si
0623+  0B8C F9          	leave
0624+  0B8D 09          	ret
0441   0B8E             
0442   0B8E             		
0443   0B8E             			.end
0444   0B8E             			
0445   0B8E             
tasm: Number of errors = 0
