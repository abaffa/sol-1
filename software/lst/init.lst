0001   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0002   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0003   0000             ; SHELL
0004   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0005   0000             
0006   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007   0000             ; SYSTEM CONSTANTS / EQUATIONS
0008   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0009   0000             STACK_BEGIN:	.equ $F7FF	; beginning of stack
0010   0000             
0011   0400             .org PROC_TEXT_ORG			; origin at 1024
0012   0400             
0013   0400             shell_main:	
0014   0400 FD 49 FF F7 	mov bp, STACK_BEGIN
0015   0404 FD 47 FF F7 	mov sp, STACK_BEGIN
0016   0408             
0017   0408 3B 44 04    	mov d, s_prompt_init
0018   040B 07 9F 06    	call puts
0019   040E             
0020   040E 3B 25 04    	mov d, s_prompt_shell
0021   0411 07 9F 06    	call puts
0022   0414 3B 19 04    	mov d, s_shell_path
0023   0417 05 05       	syscall sys_fork
0024   0419             
0025   0419 2F 75 73 72 s_shell_path:	.db "/usr/bin/sh", 0
0025   041D 2F 62 69 6E 
0025   0421 2F 73 68 00 
0026   0425             
0027   0425 6C 61 75 6E s_prompt_shell:	.db "launching a shell session...\n\r", 0
0027   0429 63 68 69 6E 
0027   042D 67 20 61 20 
0027   0431 73 68 65 6C 
0027   0435 6C 20 73 65 
0027   0439 73 73 69 6F 
0027   043D 6E 2E 2E 2E 
0027   0441 0A 0D 00 
0028   0444             
0029   0444 69 6E 69 74 s_prompt_init:	.db "init started\n\r", 0
0029   0448 20 73 74 61 
0029   044C 72 74 65 64 
0029   0450 0A 0D 00 
0030   0453             
0031   0453             .include "lib/stdio.asm"
0001+  0453             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0453             ; stdio.s
0003+  0453             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0453             .include "lib/string.asm"
0001++ 0453             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0453             ; string.s
0003++ 0453             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0453             
0005++ 0453             
0006++ 0453             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0453             ; strrev
0008++ 0453             ; reverse a string
0009++ 0453             ; D = string address
0010++ 0453             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0453             ; 01234
0012++ 0453             strrev:
0013++ 0453 4B          	pusha
0014++ 0454 07 9A 04    	call strlen	; length in C
0015++ 0457 12          	mov a, c
0016++ 0458 AF 01 00    	cmp a, 1
0017++ 045B D0 75 04    	jleu strrev_end	; check string length. string len must be > 1
0018++ 045E 7D          	dec a
0019++ 045F FD 4E       	mov si, d	; beginning of string
0020++ 0461 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0463 59          	add d, a	; end of string
0022++ 0464 12          	mov a, c
0023++ 0465 FD 9B       	shr a		; divide by 2
0024++ 0467 39          	mov c, a	; C now counts the steps
0025++ 0468             strrev_L0:
0026++ 0468 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0469 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 046A 3E          	mov [d], al	; store left char into right side
0029++ 046B 1B          	mov al, bl
0030++ 046C F7          	stosb		; store right-side char into left-side; increase DI
0031++ 046D 7E          	dec c
0032++ 046E 7F          	dec d
0033++ 046F C2 00 00    	cmp c, 0
0034++ 0472 C7 68 04    	jne strrev_L0
0035++ 0475             strrev_end:
0036++ 0475 4C          	popa
0037++ 0476 09          	ret
0038++ 0477             	
0039++ 0477             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0477             ; strchr
0041++ 0477             ; search string in D for char in AL
0042++ 0477             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0477             strchr:
0044++ 0477             strchr_L0:
0045++ 0477 32          	mov bl, [d]
0046++ 0478 C1 00       	cmp bl, 0
0047++ 047A C6 85 04    	je strchr_end
0048++ 047D BA          	cmp al, bl
0049++ 047E C6 85 04    	je strchr_end
0050++ 0481 79          	inc d
0051++ 0482 0A 77 04    	jmp strchr_L0
0052++ 0485             strchr_end:
0053++ 0485 1B          	mov al, bl
0054++ 0486 09          	ret
0055++ 0487             
0056++ 0487             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0487             ; strstr
0058++ 0487             ; find sub-string
0059++ 0487             ; str1 in SI
0060++ 0487             ; str2 in DI
0061++ 0487             ; SI points to end of source string
0062++ 0487             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0487             strstr:
0064++ 0487 DB          	push al
0065++ 0488 DA          	push d
0066++ 0489 E3          	push di
0067++ 048A             strstr_loop:
0068++ 048A F3          	cmpsb					; compare a byte of the strings
0069++ 048B C7 96 04    	jne strstr_ret
0070++ 048E FC 00 00    	lea d, [di + 0]
0071++ 0491 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0493 C7 8A 04    	jne strstr_loop				; equal chars but not at end
0073++ 0496             strstr_ret:
0074++ 0496 F0          	pop di
0075++ 0497 E7          	pop d
0076++ 0498 E8          	pop al
0077++ 0499 09          	ret
0078++ 049A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 049A             ; length of null terminated string
0080++ 049A             ; result in C
0081++ 049A             ; pointer in D
0082++ 049A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 049A             strlen:
0084++ 049A DA          	push d
0085++ 049B 38 00 00    	mov c, 0
0086++ 049E             strlen_L1:
0087++ 049E BD 00       	cmp byte [d], 0
0088++ 04A0 C6 A8 04    	je strlen_ret
0089++ 04A3 79          	inc d
0090++ 04A4 78          	inc c
0091++ 04A5 0A 9E 04    	jmp strlen_L1
0092++ 04A8             strlen_ret:
0093++ 04A8 E7          	pop d
0094++ 04A9 09          	ret
0095++ 04AA             
0096++ 04AA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 04AA             ; STRCMP
0098++ 04AA             ; compare two strings
0099++ 04AA             ; str1 in SI
0100++ 04AA             ; str2 in DI
0101++ 04AA             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 04AA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 04AA             strcmp:
0104++ 04AA DB          	push al
0105++ 04AB DA          	push d
0106++ 04AC E3          	push di
0107++ 04AD E2          	push si
0108++ 04AE             strcmp_loop:
0109++ 04AE F3          	cmpsb					; compare a byte of the strings
0110++ 04AF C7 BA 04    	jne strcmp_ret
0111++ 04B2 FB FF FF    	lea d, [si +- 1]
0112++ 04B5 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 04B7 C7 AE 04    	jne strcmp_loop				; equal chars but not at end
0114++ 04BA             strcmp_ret:
0115++ 04BA EF          	pop si
0116++ 04BB F0          	pop di
0117++ 04BC E7          	pop d
0118++ 04BD E8          	pop al
0119++ 04BE 09          	ret
0120++ 04BF             
0121++ 04BF             
0122++ 04BF             ; STRCPY
0123++ 04BF             ; copy null terminated string from SI to DI
0124++ 04BF             ; source in SI
0125++ 04BF             ; destination in DI
0126++ 04BF             strcpy:
0127++ 04BF E2          	push si
0128++ 04C0 E3          	push di
0129++ 04C1 DB          	push al
0130++ 04C2             strcpy_L1:
0131++ 04C2 F6          	lodsb
0132++ 04C3 F7          	stosb
0133++ 04C4 B9 00       	cmp al, 0
0134++ 04C6 C7 C2 04    	jne strcpy_L1
0135++ 04C9             strcpy_end:
0136++ 04C9 E8          	pop al
0137++ 04CA F0          	pop di
0138++ 04CB EF          	pop si
0139++ 04CC 09          	ret
0140++ 04CD             
0141++ 04CD             ; STRCAT
0142++ 04CD             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 04CD             ; source in SI
0144++ 04CD             ; destination in DI
0145++ 04CD             strcat:
0146++ 04CD E2          	push si
0147++ 04CE E3          	push di
0148++ 04CF D7          	push a
0149++ 04D0 DA          	push d
0150++ 04D1 50          	mov a, di
0151++ 04D2 3C          	mov d, a
0152++ 04D3             strcat_goto_end_L1:
0153++ 04D3 BD 00       	cmp byte[d], 0
0154++ 04D5 C6 DC 04    	je strcat_start
0155++ 04D8 79          	inc d
0156++ 04D9 0A D3 04    	jmp strcat_goto_end_L1
0157++ 04DC             strcat_start:
0158++ 04DC FD 50       	mov di, d
0159++ 04DE             strcat_L1:
0160++ 04DE F6          	lodsb
0161++ 04DF F7          	stosb
0162++ 04E0 B9 00       	cmp al, 0
0163++ 04E2 C7 DE 04    	jne strcat_L1
0164++ 04E5             strcat_end:
0165++ 04E5 E7          	pop d
0166++ 04E6 E4          	pop a
0167++ 04E7 F0          	pop di
0168++ 04E8 EF          	pop si
0169++ 04E9 09          	ret
0005+  04EA             
0006+  04EA 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  04EE 34 35 36 37 
0006+  04F2 38 39 41 42 
0006+  04F6 43 44 45 46 
0007+  04FA 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  04FE 1B 5B 48 00 
0008+  0502             
0009+  0502 01 00       table_power:.dw 1
0010+  0504 0A 00       			.dw 10
0011+  0506 64 00       			.dw 100
0012+  0508 E8 03       			.dw 1000
0013+  050A 10 27       			.dw 10000
0014+  050C             
0015+  050C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  050C             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  050C             ; ASCII in BL
0018+  050C             ; result in AL
0019+  050C             ; ascii for F = 0100 0110
0020+  050C             ; ascii for 9 = 0011 1001
0021+  050C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  050C             hex_ascii_encode:
0023+  050C 1B          	mov al, bl
0024+  050D 93 40       	test al, $40				; test if letter or number
0025+  050F C7 15 05    	jnz hex_letter
0026+  0512 87 0F       	and al, $0F				; get number
0027+  0514 09          	ret
0028+  0515             hex_letter:
0029+  0515 87 0F       	and al, $0F				; get letter
0030+  0517 6A 09       	add al, 9
0031+  0519 09          	ret
0032+  051A             
0033+  051A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  051A             ; ATOI
0035+  051A             ; 2 letter hex string in B
0036+  051A             ; 8bit integer returned in AL
0037+  051A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  051A             atoi:
0039+  051A D8          	push b
0040+  051B 07 0C 05    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  051E 30          	mov bl, bh
0042+  051F DB          	push al					; save a
0043+  0520 07 0C 05    	call hex_ascii_encode
0044+  0523 EA          	pop bl	
0045+  0524 FD 9E 04    	shl al, 4
0046+  0527 8C          	or al, bl
0047+  0528 E5          	pop b
0048+  0529 09          	ret	
0049+  052A             
0050+  052A             
0051+  052A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  052A             ; printf
0053+  052A             ; no need for explanations!
0054+  052A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  052A             printf:
0056+  052A 09          	ret
0057+  052B             
0058+  052B             
0059+  052B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  052B             ; scanf
0061+  052B             ; no need for explanations!
0062+  052B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  052B             scanf:
0064+  052B 09          	ret
0065+  052C             
0066+  052C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  052C             ; ITOA
0068+  052C             ; 8bit value in BL
0069+  052C             ; 2 byte ASCII result in A
0070+  052C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  052C             itoa:
0072+  052C DA          	push d
0073+  052D D8          	push b
0074+  052E A7 00       	mov bh, 0
0075+  0530 FD A4 04    	shr bl, 4	
0076+  0533 74          	mov d, b
0077+  0534 1F EA 04    	mov al, [d + s_hex_digits]
0078+  0537 23          	mov ah, al
0079+  0538             	
0080+  0538 E5          	pop b
0081+  0539 D8          	push b
0082+  053A A7 00       	mov bh, 0
0083+  053C FD 87 0F    	and bl, $0F
0084+  053F 74          	mov d, b
0085+  0540 1F EA 04    	mov al, [d + s_hex_digits]
0086+  0543 E5          	pop b
0087+  0544 E7          	pop d
0088+  0545 09          	ret
0089+  0546             
0090+  0546             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  0546             ; HEX STRING TO BINARY
0092+  0546             ; di = destination address
0093+  0546             ; si = source
0094+  0546             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  0546             hex_to_int:
0096+  0546             hex_to_int_L1:
0097+  0546 F6          	lodsb					; load from [SI] to AL
0098+  0547 B9 00       	cmp al, 0				; check if ASCII 0
0099+  0549 C6 56 05    	jz hex_to_int_ret
0100+  054C 36          	mov bh, al
0101+  054D F6          	lodsb
0102+  054E 2F          	mov bl, al
0103+  054F 07 1A 05    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  0552 F7          	stosb					; store AL to [DI]
0105+  0553 0A 46 05    	jmp hex_to_int_L1
0106+  0556             hex_to_int_ret:
0107+  0556 09          	ret		
0108+  0557             
0109+  0557             
0110+  0557             
0111+  0557             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  0557             ; GETCHAR
0113+  0557             ; char in ah
0114+  0557             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  0557             getchar:
0116+  0557 DB          	push al
0117+  0558             getchar_retry:
0118+  0558 FD 0C       	sti
0119+  055A 19 01       	mov al, 1
0120+  055C 05 03       	syscall sys_io			; receive in AH
0121+  055E B9 00       	cmp al, 0			; check if any char was receive
0122+  0560 C6 58 05    	je getchar_retry
0123+  0563 E8          	pop al
0124+  0564 09          	ret
0125+  0565             
0126+  0565             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  0565             ; PUTCHAR
0128+  0565             ; char in ah
0129+  0565             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0565             putchar:
0131+  0565 D7          	push a
0132+  0566 19 00       	mov al, 0
0133+  0568 05 03       	syscall sys_io			; char in AH
0134+  056A E4          	pop a
0135+  056B 09          	ret
0136+  056C             
0137+  056C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  056C             ;; INPUT A STRING
0139+  056C             ;; terminates with null
0140+  056C             ;; pointer in D
0141+  056C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  056C             gets:
0143+  056C D7          	push a
0144+  056D DA          	push d
0145+  056E             gets_loop:
0146+  056E FD 0C       	sti
0147+  0570 19 01       	mov al, 1
0148+  0572 05 03       	syscall sys_io			; receive in AH
0149+  0574 B9 00       	cmp al, 0				; check error code (AL)
0150+  0576 C6 6E 05    	je gets_loop			; if no char received, retry
0151+  0579             
0152+  0579 76 1B       	cmp ah, 27
0153+  057B C6 9C 05    	je gets_telnet_escape
0154+  057E 76 0A       	cmp ah, $0A				; LF
0155+  0580 C6 F5 05    	je gets_end
0156+  0583 76 0D       	cmp ah, $0D				; CR
0157+  0585 C6 F5 05    	je gets_end
0158+  0588 76 5C       	cmp ah, $5C				; '\\'
0159+  058A C6 CC 05    	je gets_escape
0160+  058D             	
0161+  058D 76 08       	cmp ah, $08			; check for backspace
0162+  058F C6 98 05    	je gets_backspace
0163+  0592             
0164+  0592 1A          	mov al, ah
0165+  0593 3E          	mov [d], al
0166+  0594 79          	inc d
0167+  0595 0A 6E 05    	jmp gets_loop
0168+  0598             gets_backspace:
0169+  0598 7F          	dec d
0170+  0599 0A 6E 05    	jmp gets_loop
0171+  059C             gets_telnet_escape:
0172+  059C FD 0C       	sti
0173+  059E 19 01       	mov al, 1
0174+  05A0 05 03       	syscall sys_io				; receive in AH without echo
0175+  05A2 B9 00       	cmp al, 0					; check error code (AL)
0176+  05A4 C6 9C 05    	je gets_telnet_escape		; if no char received, retry
0177+  05A7 76 5B       	cmp ah, '['
0178+  05A9 C7 6E 05    	jne gets_loop
0179+  05AC             gets_telnet_escape_phase2:
0180+  05AC FD 0C       	sti
0181+  05AE 19 01       	mov al, 1
0182+  05B0 05 03       	syscall sys_io					; receive in AH without echo
0183+  05B2 B9 00       	cmp al, 0						; check error code (AL)
0184+  05B4 C6 AC 05    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  05B7 76 44       	cmp ah, 'D'
0186+  05B9 C6 C4 05    	je gets_left_arrow
0187+  05BC 76 43       	cmp ah, 'C'
0188+  05BE C6 C8 05    	je gets_right_arrow
0189+  05C1 0A 6E 05    	jmp gets_loop
0190+  05C4             gets_left_arrow:
0191+  05C4 7F          	dec d
0192+  05C5 0A 6E 05    	jmp gets_loop
0193+  05C8             gets_right_arrow:
0194+  05C8 79          	inc d
0195+  05C9 0A 6E 05    	jmp gets_loop
0196+  05CC             gets_escape:
0197+  05CC FD 0C       	sti
0198+  05CE 19 01       	mov al, 1
0199+  05D0 05 03       	syscall sys_io			; receive in AH
0200+  05D2 B9 00       	cmp al, 0				; check error code (AL)
0201+  05D4 C6 CC 05    	je gets_escape			; if no char received, retry
0202+  05D7 76 6E       	cmp ah, 'n'
0203+  05D9 C6 E7 05    	je gets_LF
0204+  05DC 76 72       	cmp ah, 'r'
0205+  05DE C6 EE 05    	je gets_CR
0206+  05E1 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  05E2 3E          	mov [d], al
0208+  05E3 79          	inc d
0209+  05E4 0A 6E 05    	jmp gets_loop
0210+  05E7             gets_LF:
0211+  05E7 19 0A       	mov al, $0A
0212+  05E9 3E          	mov [d], al
0213+  05EA 79          	inc d
0214+  05EB 0A 6E 05    	jmp gets_loop
0215+  05EE             gets_CR:
0216+  05EE 19 0D       	mov al, $0D
0217+  05F0 3E          	mov [d], al
0218+  05F1 79          	inc d
0219+  05F2 0A 6E 05    	jmp gets_loop
0220+  05F5             gets_end:
0221+  05F5 19 00       	mov al, 0
0222+  05F7 3E          	mov [d], al				; terminate string
0223+  05F8 E7          	pop d
0224+  05F9 E4          	pop a
0225+  05FA 09          	ret
0226+  05FB             
0227+  05FB             
0228+  05FB             
0229+  05FB             
0230+  05FB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  05FB             ;; INPUT TEXT
0232+  05FB             ;; terminated with CTRL+D
0233+  05FB             ;; pointer in D
0234+  05FB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  05FB             gettxt:
0236+  05FB D7          	push a
0237+  05FC DA          	push d
0238+  05FD             gettxt_loop:
0239+  05FD 19 01       	mov al, 1
0240+  05FF 05 03       	syscall sys_io			; receive in AH
0241+  0601 B9 00       	cmp al, 0				; check error code (AL)
0242+  0603 C6 FD 05    	je gettxt_loop		; if no char received, retry
0243+  0606 76 04       	cmp ah, 4			; EOT
0244+  0608 C6 46 06    	je gettxt_end
0245+  060B 76 08       	cmp ah, $08			; check for backspace
0246+  060D C6 42 06    	je gettxt_backspace
0247+  0610 76 5C       	cmp ah, $5C				; '\\'
0248+  0612 C6 1B 06    	je gettxt_escape
0249+  0615 1A          	mov al, ah
0250+  0616 3E          	mov [d], al
0251+  0617 79          	inc d
0252+  0618 0A FD 05    	jmp gettxt_loop
0253+  061B             gettxt_escape:
0254+  061B 19 01       	mov al, 1
0255+  061D 05 03       	syscall sys_io			; receive in AH
0256+  061F B9 00       	cmp al, 0				; check error code (AL)
0257+  0621 C6 1B 06    	je gettxt_escape		; if no char received, retry
0258+  0624 76 6E       	cmp ah, 'n'
0259+  0626 C6 34 06    	je gettxt_LF
0260+  0629 76 72       	cmp ah, 'r'
0261+  062B C6 3B 06    	je gettxt_CR
0262+  062E 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  062F 3E          	mov [d], al
0264+  0630 79          	inc d
0265+  0631 0A FD 05    	jmp gettxt_loop
0266+  0634             gettxt_LF:
0267+  0634 19 0A       	mov al, $0A
0268+  0636 3E          	mov [d], al
0269+  0637 79          	inc d
0270+  0638 0A FD 05    	jmp gettxt_loop
0271+  063B             gettxt_CR:
0272+  063B 19 0D       	mov al, $0D
0273+  063D 3E          	mov [d], al
0274+  063E 79          	inc d
0275+  063F 0A FD 05    	jmp gettxt_loop
0276+  0642             gettxt_backspace:
0277+  0642 7F          	dec d
0278+  0643 0A FD 05    	jmp gettxt_loop
0279+  0646             gettxt_end:
0280+  0646 19 00       	mov al, 0
0281+  0648 3E          	mov [d], al				; terminate string
0282+  0649 E7          	pop d
0283+  064A E4          	pop a
0284+  064B 09          	ret
0285+  064C             
0286+  064C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  064C             ; PRINT NEW LINE
0288+  064C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  064C             printnl:
0290+  064C D7          	push a
0291+  064D 10 00 0A    	mov a, $0A00
0292+  0650 05 03       	syscall sys_io
0293+  0652 10 00 0D    	mov a, $0D00
0294+  0655 05 03       	syscall sys_io
0295+  0657 E4          	pop a
0296+  0658 09          	ret
0297+  0659             
0298+  0659             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  0659             ; strtoint
0300+  0659             ; 4 digit hex string number in d
0301+  0659             ; integer returned in A
0302+  0659             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  0659             strtointx:
0304+  0659 D8          	push b
0305+  065A 32          	mov bl, [d]
0306+  065B 37          	mov bh, bl
0307+  065C 33 01 00    	mov bl, [d + 1]
0308+  065F 07 1A 05    	call atoi				; convert to int in AL
0309+  0662 23          	mov ah, al				; move to AH
0310+  0663 33 02 00    	mov bl, [d + 2]
0311+  0666 37          	mov bh, bl
0312+  0667 33 03 00    	mov bl, [d + 3]
0313+  066A 07 1A 05    	call atoi				; convert to int in AL
0314+  066D E5          	pop b
0315+  066E 09          	ret
0316+  066F             
0317+  066F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  066F             ; strtoint
0319+  066F             ; 5 digit base10 string number in d
0320+  066F             ; integer returned in A
0321+  066F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  066F             strtoint:
0323+  066F E2          	push si
0324+  0670 D8          	push b
0325+  0671 D9          	push c
0326+  0672 DA          	push d
0327+  0673 07 9A 04    	call strlen			; get string length in C
0328+  0676 7E          	dec c
0329+  0677 FD 4E       	mov si, d
0330+  0679 12          	mov a, c
0331+  067A FD 99       	shl a
0332+  067C 3B 02 05    	mov d, table_power
0333+  067F 59          	add d, a
0334+  0680 38 00 00    	mov c, 0
0335+  0683             strtoint_L0:
0336+  0683 F6          	lodsb			; load ASCII to al
0337+  0684 B9 00       	cmp al, 0
0338+  0686 C6 99 06    	je strtoint_end
0339+  0689 6F 30       	sub al, $30		; make into integer
0340+  068B 22 00       	mov ah, 0
0341+  068D 2A          	mov b, [d]
0342+  068E AC          	mul a, b			; result in B since it fits in 16bits
0343+  068F 11          	mov a, b
0344+  0690 28          	mov b, c
0345+  0691 54          	add a, b
0346+  0692 39          	mov c, a
0347+  0693 63 02 00    	sub d, 2
0348+  0696 0A 83 06    	jmp strtoint_L0
0349+  0699             strtoint_end:
0350+  0699 12          	mov a, c
0351+  069A E7          	pop d
0352+  069B E6          	pop c
0353+  069C E5          	pop b
0354+  069D EF          	pop si
0355+  069E 09          	ret
0356+  069F             
0357+  069F             
0358+  069F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  069F             ; PRINT NULL TERMINATED STRING
0360+  069F             ; pointer in D
0361+  069F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  069F             puts:
0363+  069F D7          	push a
0364+  06A0 DA          	push d
0365+  06A1             puts_L1:
0366+  06A1 1E          	mov al, [d]
0367+  06A2 B9 00       	cmp al, 0
0368+  06A4 C6 B0 06    	jz puts_END
0369+  06A7 23          	mov ah, al
0370+  06A8 19 00       	mov al, 0
0371+  06AA 05 03       	syscall sys_io
0372+  06AC 79          	inc d
0373+  06AD 0A A1 06    	jmp puts_L1
0374+  06B0             puts_END:
0375+  06B0 E7          	pop d
0376+  06B1 E4          	pop a
0377+  06B2 09          	ret
0378+  06B3             
0379+  06B3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  06B3             ; PRINT N SIZE STRING
0381+  06B3             ; pointer in D
0382+  06B3             ; size in C
0383+  06B3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  06B3             putsn:
0385+  06B3 DB          	push al
0386+  06B4 DA          	push d
0387+  06B5 D9          	push c
0388+  06B6             putsn_L0:
0389+  06B6 1E          	mov al, [d]
0390+  06B7 23          	mov ah, al
0391+  06B8 19 00       	mov al, 0
0392+  06BA 05 03       	syscall sys_io
0393+  06BC 79          	inc d
0394+  06BD 7E          	dec c	
0395+  06BE C2 00 00    	cmp c, 0
0396+  06C1 C7 B6 06    	jne putsn_L0
0397+  06C4             putsn_end:
0398+  06C4 E6          	pop c
0399+  06C5 E7          	pop d
0400+  06C6 E8          	pop al
0401+  06C7 09          	ret
0402+  06C8             
0403+  06C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  06C8             ; print 16bit decimal number
0405+  06C8             ; input number in A
0406+  06C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  06C8             print_u16d:
0408+  06C8 D7          	push a
0409+  06C9 D8          	push b
0410+  06CA 26 10 27    	mov b, 10000
0411+  06CD AE          	div a, b			; get 10000's coeff.
0412+  06CE 07 F0 06    	call print_number
0413+  06D1 11          	mov a, b
0414+  06D2 26 E8 03    	mov b, 1000
0415+  06D5 AE          	div a, b			; get 1000's coeff.
0416+  06D6 07 F0 06    	call print_number
0417+  06D9 11          	mov a, b
0418+  06DA 26 64 00    	mov b, 100
0419+  06DD AE          	div a, b
0420+  06DE 07 F0 06    	call print_number
0421+  06E1 11          	mov a, b
0422+  06E2 26 0A 00    	mov b, 10
0423+  06E5 AE          	div a, b
0424+  06E6 07 F0 06    	call print_number
0425+  06E9 1B          	mov al, bl			; 1's coeff in bl
0426+  06EA 07 F0 06    	call print_number
0427+  06ED E5          	pop b
0428+  06EE E4          	pop a
0429+  06EF 09          	ret
0430+  06F0             
0431+  06F0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0432+  06F0             ; print AL
0433+  06F0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0434+  06F0             print_number:
0435+  06F0 6A 30       	add al, $30
0436+  06F2 23          	mov ah, al
0437+  06F3 07 65 05    	call putchar
0438+  06F6 09          	ret
0439+  06F7             
0440+  06F7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0441+  06F7             ; PRINT 16BIT HEX INTEGER
0442+  06F7             ; integer value in reg B
0443+  06F7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0444+  06F7             print_u16x:
0445+  06F7 D7          	push a
0446+  06F8 D8          	push b
0447+  06F9 DD          	push bl
0448+  06FA 30          	mov bl, bh
0449+  06FB 07 2C 05    	call itoa				; convert bh to char in A
0450+  06FE 2F          	mov bl, al				; save al
0451+  06FF 19 00       	mov al, 0
0452+  0701 05 03       	syscall sys_io				; display AH
0453+  0703 24          	mov ah, bl				; retrieve al
0454+  0704 19 00       	mov al, 0
0455+  0706 05 03       	syscall sys_io				; display AL
0456+  0708             
0457+  0708 EA          	pop bl
0458+  0709 07 2C 05    	call itoa				; convert bh to char in A
0459+  070C 2F          	mov bl, al				; save al
0460+  070D 19 00       	mov al, 0
0461+  070F 05 03       	syscall sys_io				; display AH
0462+  0711 24          	mov ah, bl				; retrieve al
0463+  0712 19 00       	mov al, 0
0464+  0714 05 03       	syscall sys_io				; display AL
0465+  0716             
0466+  0716 E5          	pop b
0467+  0717 E4          	pop a
0468+  0718 09          	ret
0469+  0719             
0470+  0719             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0471+  0719             ; INPUT 16BIT HEX INTEGER
0472+  0719             ; read 16bit integer into A
0473+  0719             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0474+  0719             scan_u16x:
0475+  0719 F8 10 00    	enter 16
0476+  071C D8          	push b
0477+  071D DA          	push d
0478+  071E             
0479+  071E FA F1 FF    	lea d, [bp + -15]
0480+  0721 07 6C 05    	call gets				; get number
0481+  0724             
0482+  0724 32          	mov bl, [d]
0483+  0725 37          	mov bh, bl
0484+  0726 33 01 00    	mov bl, [d + 1]
0485+  0729 07 1A 05    	call atoi				; convert to int in AL
0486+  072C 23          	mov ah, al				; move to AH
0487+  072D             
0488+  072D 33 02 00    	mov bl, [d + 2]
0489+  0730 37          	mov bh, bl
0490+  0731 33 03 00    	mov bl, [d + 3]
0491+  0734 07 1A 05    	call atoi				; convert to int in AL
0492+  0737             
0493+  0737 E7          	pop d
0494+  0738 E5          	pop b
0495+  0739 F9          	leave
0496+  073A 09          	ret
0497+  073B             
0498+  073B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0499+  073B             ; PRINT 8bit HEX INTEGER
0500+  073B             ; integer value in reg bl
0501+  073B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0502+  073B             print_u8x:
0503+  073B D7          	push a
0504+  073C DD          	push bl
0505+  073D             
0506+  073D 07 2C 05    	call itoa				; convert bl to char in A
0507+  0740 2F          	mov bl, al				; save al
0508+  0741 19 00       	mov al, 0
0509+  0743 05 03       	syscall sys_io				; display AH
0510+  0745 24          	mov ah, bl				; retrieve al
0511+  0746 19 00       	mov al, 0
0512+  0748 05 03       	syscall sys_io				; display AL
0513+  074A             
0514+  074A EA          	pop bl
0515+  074B E4          	pop a
0516+  074C 09          	ret
0517+  074D             
0518+  074D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0519+  074D             ; print 8bit decimal unsigned number
0520+  074D             ; input number in AL
0521+  074D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0522+  074D             print_u8d:
0523+  074D D7          	push a
0524+  074E D8          	push b
0525+  074F             
0526+  074F 22 00       	mov ah, 0
0527+  0751 26 64 00    	mov b, 100
0528+  0754 AE          	div a, b
0529+  0755 D8          	push b			; save remainder
0530+  0756 B9 00       	cmp al, 0
0531+  0758 C6 62 07    	je skip100
0532+  075B 6A 30       	add al, $30
0533+  075D 23          	mov ah, al
0534+  075E 19 00       	mov al, 0
0535+  0760 05 03       	syscall sys_io	; print coeff
0536+  0762             skip100:
0537+  0762 E4          	pop a
0538+  0763 22 00       	mov ah, 0
0539+  0765 26 0A 00    	mov b, 10
0540+  0768 AE          	div a, b
0541+  0769 D8          	push b			; save remainder
0542+  076A B9 00       	cmp al, 0
0543+  076C C6 76 07    	je skip10
0544+  076F 6A 30       	add al, $30
0545+  0771 23          	mov ah, al
0546+  0772 19 00       	mov al, 0
0547+  0774 05 03       	syscall sys_io	; print coeff
0548+  0776             skip10:
0549+  0776 E4          	pop a
0550+  0777 1B          	mov al, bl
0551+  0778 6A 30       	add al, $30
0552+  077A 23          	mov ah, al
0553+  077B 19 00       	mov al, 0
0554+  077D 05 03       	syscall sys_io	; print coeff
0555+  077F E5          	pop b
0556+  0780 E4          	pop a
0557+  0781 09          	ret
0558+  0782             
0559+  0782             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0560+  0782             ; INPUT 8BIT HEX INTEGER
0561+  0782             ; read 8bit integer into AL
0562+  0782             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0563+  0782             scan_u8x:
0564+  0782 F8 04 00    	enter 4
0565+  0785 D8          	push b
0566+  0786 DA          	push d
0567+  0787             
0568+  0787 FA FD FF    	lea d, [bp + -3]
0569+  078A 07 6C 05    	call gets				; get number
0570+  078D             
0571+  078D 32          	mov bl, [d]
0572+  078E 37          	mov bh, bl
0573+  078F 33 01 00    	mov bl, [d + 1]
0574+  0792 07 1A 05    	call atoi				; convert to int in AL
0575+  0795             
0576+  0795 E7          	pop d
0577+  0796 E5          	pop b
0578+  0797 F9          	leave
0579+  0798 09          	ret
0580+  0799             
0581+  0799             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0582+  0799             ; input decimal number
0583+  0799             ; result in A
0584+  0799             ; 655'\0'
0585+  0799             ; low--------high
0586+  0799             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  0799             scan_u16d:
0588+  0799 F8 08 00    	enter 8
0589+  079C E2          	push si
0590+  079D D8          	push b
0591+  079E D9          	push c
0592+  079F DA          	push d
0593+  07A0 FA F9 FF    	lea d, [bp +- 7]
0594+  07A3 07 6C 05    	call gets
0595+  07A6 07 9A 04    	call strlen			; get string length in C
0596+  07A9 7E          	dec c
0597+  07AA FD 4E       	mov si, d
0598+  07AC 12          	mov a, c
0599+  07AD FD 99       	shl a
0600+  07AF 3B 02 05    	mov d, table_power
0601+  07B2 59          	add d, a
0602+  07B3 38 00 00    	mov c, 0
0603+  07B6             mul_loop:
0604+  07B6 F6          	lodsb			; load ASCII to al
0605+  07B7 B9 00       	cmp al, 0
0606+  07B9 C6 CC 07    	je mul_exit
0607+  07BC 6F 30       	sub al, $30		; make into integer
0608+  07BE 22 00       	mov ah, 0
0609+  07C0 2A          	mov b, [d]
0610+  07C1 AC          	mul a, b			; result in B since it fits in 16bits
0611+  07C2 11          	mov a, b
0612+  07C3 28          	mov b, c
0613+  07C4 54          	add a, b
0614+  07C5 39          	mov c, a
0615+  07C6 63 02 00    	sub d, 2
0616+  07C9 0A B6 07    	jmp mul_loop
0617+  07CC             mul_exit:
0618+  07CC 12          	mov a, c
0619+  07CD E7          	pop d
0620+  07CE E6          	pop c
0621+  07CF E5          	pop b
0622+  07D0 EF          	pop si
0623+  07D1 F9          	leave
0624+  07D2 09          	ret
0032   07D3             
0033   07D3             .end
tasm: Number of errors = 0
