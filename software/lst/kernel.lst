0001   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002   0000             ; KERNEL
0003   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0005   0000             ; MEMORY MAP
0006   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007   0000             ; 0000		ROM BEGIN
0008   0000             ; ....
0009   0000             ; 7FFF		ROM END
0010   0000             ;
0011   0000             ; 8000		RAM begin
0012   0000             ; ....
0013   0000             ; F7FF		Stack root
0014   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0015   0000             ; I/O MAP
0016   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0017   0000             ; FF80		UART 0		(16550)
0018   0000             ; FF90		UART 1		(16550)
0019   0000             ; FFA0		RTC		(M48T02)
0020   0000             ; FFB0		PIO 0		(8255)
0021   0000             ; FFC0		PIO 1		(8255)
0022   0000             ; FFD0		IDE		(Compact Flash / PATA)
0023   0000             ; FFE0		Timer		(8253)
0024   0000             ; FFF0		BIOS CONFIGURATION NV-RAM STORE AREA
0025   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026   0000             ; SYSTEM CONSTANTS / EQUATIONS
0027   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028   0000             _UART0_DATA			.equ $FF80				; data
0029   0000             _UART0_DLAB_0		.equ $FF80				; divisor latch low byte
0030   0000             _UART0_DLAB_1		.equ $FF81				; divisor latch high byte
0031   0000             _UART0_IER			.equ $FF81				; Interrupt enable register
0032   0000             _UART0_FCR			.equ $FF82				; FIFO control register
0033   0000             _UART0_LCR			.equ $FF83				; line control register
0034   0000             _UART0_LSR			.equ $FF85				; line status register
0035   0000             
0036   0000             _IDE_BASE			.equ $FFD0				; IDE BASE
0037   0000             _IDE_R0				.equ _IDE_BASE + 0		; DATA PORT
0038   0000             _IDE_R1				.equ _IDE_BASE + 1		; READ: ERROR CODE, WRITE: FEATURE
0039   0000             _IDE_R2				.equ _IDE_BASE + 2		; NUMBER OF SECTORS TO TRANSFER
0040   0000             _IDE_R3				.equ _IDE_BASE + 3		; SECTOR ADDRESS LBA 0 [0:7]
0041   0000             _IDE_R4				.equ _IDE_BASE + 4		; SECTOR ADDRESS LBA 1 [8:15]
0042   0000             _IDE_R5				.equ _IDE_BASE + 5		; SECTOR ADDRESS LBA 2 [16:23]
0043   0000             _IDE_R6				.equ _IDE_BASE + 6		; SECTOR ADDRESS LBA 3 [24:27 (LSB)]
0044   0000             _IDE_R7				.equ _IDE_BASE + 7		; READ: STATUS, WRITE: COMMAND
0045   0000             
0046   0000             _7SEG_DISPLAY		.equ $FFB0				; BIOS POST CODE HEX DISPLAY (2 DIGITS)
0047   0000             _BIOS_POST_CTRL		.equ $FFB3				; BIOS POST DISPLAY CONTROL REGISTER, 80h = As Output
0048   0000             _PIO_A				.equ $FFB0		
0049   0000             _PIO_B				.equ $FFB1
0050   0000             _PIO_C				.equ $FFB2
0051   0000             _PIO_CONTROL		.equ $FFB3				; PIO CONTROL PORT
0052   0000             
0053   0000             _TIMER_C_0			.equ $FFE0				; TIMER COUNTER 0
0054   0000             _TIMER_C_1			.equ $FFE1				; TIMER COUNTER 1
0055   0000             _TIMER_C_2			.equ $FFE2				; TIMER COUNTER 2
0056   0000             _TIMER_CTRL			.equ $FFE3				; TIMER CONTROL REGISTER
0057   0000             
0058   0000             STACK_BEGIN			.equ $F7FF				; beginning of stack
0059   0000             FIFO_SIZE			.equ (1024*2)
0060   0000             
0061   0000             PROC_TEXT_ORG		.equ $400
0062   0000             NULL				.equ 0
0063   0000             
0064   0000             
0065   0000             ; for the next iteration:
0066   0000             ; boot-sector(1) | kernel-sectors(32) | inode-bitmap | rawdata-bitmap | inode-table | raw-disk-data
0067   0000             ;
0068   0000             ; inode-table format:
0069   0000             ;	file-type(f, d)
0070   0000             ;	permissons
0071   0000             ;	link-count
0072   0000             ;	filesize
0073   0000             ;	time-stamps
0074   0000             ;	15 data block pointers
0075   0000             ;	single-indirect pointer
0076   0000             ;
0077   0000             
0078   0000             ; for now:
0079   0000             ; boot-sector(1) | kernel-sectors(32) | rawdata-bitmap() | raw-disk-data
0080   0000             ;
0081   0000             ; filename (24)
0082   0000             ; attributes (1) 			:|0|0|file_type(3bits)|x|w|r|
0083   0000             ; LBA (2)					: location of raw data for file entry, or dirID for directory entry
0084   0000             ; size (2)					: filesize
0085   0000             ; day (1)					 
0086   0000             ; month (1)
0087   0000             ; year (1)
0088   0000             ; packet size = 32 bytes	: total packet size in bytes
0089   0000             ;
0090   0000             FST_ENTRY_SIZE			.equ 32
0091   0000             FST_FILES_PER_SECT		.equ (512 / FST_ENTRY_SIZE)
0092   0000             FST_FILES_PER_DIR		.equ 16
0093   0000             FST_NBR_DIRECTORIES		.equ 64
0094   0000             						; 1 sector for header, the rest is for the list of files/dirs
0095   0000             FST_SECTORS_PER_DIR		.equ (1 + (FST_ENTRY_SIZE * FST_FILES_PER_DIR / 512))		
0096   0000             FST_TOTAL_SECTORS		.equ (FST_SECTORS_PER_DIR * FST_NBR_DIRECTORIES)
0097   0000             FST_LBA_START			.equ 32
0098   0000             FST_LBA_END				.equ (FST_LBA_START + FST_TOTAL_SECTORS - 1)
0099   0000             
0100   0000             FS_NBR_FILES 			.equ (FST_NBR_DIRECTORIES * FST_FILES_PER_DIR)
0101   0000             FS_SECTORS_PER_FILE		.equ 32				; the first sector is always a header with a NULL parameter (first byte)
0102   0000             											; so that we know which blocks are free or taken
0103   0000             FS_FILE_SIZE			.equ (FS_SECTORS_PER_FILE * 512)									
0104   0000             FS_TOTAL_SECTORS		.equ (FS_NBR_FILES * FS_SECTORS_PER_FILE)
0105   0000             FS_LBA_START			.equ (FST_LBA_END + 1)
0106   0000             FS_LBA_END				.equ (FS_LBA_START + FS_NBR_FILES - 1)
0107   0000             
0108   0000             CF_CARD_LBA_SIZE		.equ $800			; temporary small size
0109   0000             
0110   0000             ROOT_dirID:				.equ FST_LBA_START
0111   0000             
0112   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113   0000             ; GLOBAL SYSTEM VARIABLES
0114   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115   0000             
0116   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0117   0000             ; EXTERNAL INTERRUPT TABLE
0118   0000             ; highest priority at lowest address
0119   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0120   0000 8B 07       .dw int_0
0121   0002 8C 07       .dw int_1
0122   0004 8D 07       .dw int_2
0123   0006 8E 07       .dw int_3
0124   0008 8F 07       .dw int_4
0125   000A 90 07       .dw int_5
0126   000C 91 07       .dw int_6
0127   000E DD 07       .dw int_7
0128   0010             
0129   0010             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130   0010             ; RESET VECTOR DECLARATION
0131   0010             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0132   0010 95 14       .dw KERNEL_RESET_VECTOR
0133   0012             
0134   0012             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0135   0012             ;; EXCEPTION VECTOR TABLE
0136   0012             ;; total of 7 entries, starting at address $0012
0137   0012             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138   0012 A7 08       .dw trap_privilege
0139   0014 C4 09       .dw trap_div_zero
0140   0016 D1 09       .dw undefined_opcode
0141   0018 00 00       .dw NULL
0142   001A 00 00       .dw NULL
0143   001C 00 00       .dw NULL
0144   001E 00 00       .dw NULL
0145   0020             
0146   0020             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0147   0020             ;; SYSTEM CALL VECTOR TABLE
0148   0020             ;; starts at address $0020
0149   0020             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0150   0020 B3 08       .dw trap_breakpoint
0151   0022 D2 09       .dw rtc_services						
0152   0024 F5 0A       .dw IDE_services_kernel
0153   0026 B5 0B       .dw io_services
0154   0028 41 0C       .dw file_system
0155   002A 6C 15       .dw cmd_fork
0156   002C 6C 08       .dw list_procs
0157   002E 04 0A       .dw datetime_services
0158   0030 28 08       .dw syscall_reboot
0159   0032 36 15       .dw cmd_pause_proc
0160   0034 34 08       .dw resume_proc
0161   0036 F3 14       .dw cmd_terminate_proc
0162   0038 16 08       .dw cmd_system
0163   003A CE 0C       .dw cmd_boot_installer
0164   003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0165   003C             ;; FILE INCLUDES
0166   003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0167   003C             .include "bios.exp"	; to obtain the BIOS_RESET_VECTOR location (for reboots)
0001+  003C             BIOS_RESET_VECTOR .EQU  $01c0
0002+  003C             IDE_buffer       .EQU  $8204
0003+  003C             boot_origin      .EQU  $8004
0004+  003C             bios_uart        .EQU  $0002
0005+  003C             bios_ide         .EQU  $0003
0168   003C             .include "stdio.asm"
0001+  003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  003C             ; stdio.s
0003+  003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  003C             .include "string.asm"
0001++ 003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 003C             ; string.s
0003++ 003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 003C             
0005++ 003C             
0006++ 003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 003C             ; strrev
0008++ 003C             ; reverse a string
0009++ 003C             ; D = string address
0010++ 003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 003C             ; 01234
0012++ 003C             strrev:
0013++ 003C 4B          	pusha
0014++ 003D 07 83 00    	call strlen	; length in C
0015++ 0040 12          	mov a, c
0016++ 0041 AF 01 00    	cmp a, 1
0017++ 0044 D0 5E 00    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0047 7D          	dec a
0019++ 0048 FD 4E       	mov si, d	; beginning of string
0020++ 004A FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 004C 59          	add d, a	; end of string
0022++ 004D 12          	mov a, c
0023++ 004E FD 9B       	shr a		; divide by 2
0024++ 0050 39          	mov c, a	; C now counts the steps
0025++ 0051             strrev_L0:
0026++ 0051 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0052 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0053 3E          	mov [d], al	; store left char into right side
0029++ 0054 1B          	mov al, bl
0030++ 0055 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0056 7E          	dec c
0032++ 0057 7F          	dec d
0033++ 0058 C2 00 00    	cmp c, 0
0034++ 005B C7 51 00    	jne strrev_L0
0035++ 005E             strrev_end:
0036++ 005E 4C          	popa
0037++ 005F 09          	ret
0038++ 0060             	
0039++ 0060             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0060             ; strchr
0041++ 0060             ; search string in D for char in AL
0042++ 0060             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0060             strchr:
0044++ 0060             strchr_L0:
0045++ 0060 32          	mov bl, [d]
0046++ 0061 C1 00       	cmp bl, 0
0047++ 0063 C6 6E 00    	je strchr_end
0048++ 0066 BA          	cmp al, bl
0049++ 0067 C6 6E 00    	je strchr_end
0050++ 006A 79          	inc d
0051++ 006B 0A 60 00    	jmp strchr_L0
0052++ 006E             strchr_end:
0053++ 006E 1B          	mov al, bl
0054++ 006F 09          	ret
0055++ 0070             
0056++ 0070             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0070             ; strstr
0058++ 0070             ; find sub-string
0059++ 0070             ; str1 in SI
0060++ 0070             ; str2 in DI
0061++ 0070             ; SI points to end of source string
0062++ 0070             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0070             strstr:
0064++ 0070 DB          	push al
0065++ 0071 DA          	push d
0066++ 0072 E3          	push di
0067++ 0073             strstr_loop:
0068++ 0073 F3          	cmpsb					; compare a byte of the strings
0069++ 0074 C7 7F 00    	jne strstr_ret
0070++ 0077 FC 00 00    	lea d, [di + 0]
0071++ 007A BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 007C C7 73 00    	jne strstr_loop				; equal chars but not at end
0073++ 007F             strstr_ret:
0074++ 007F F0          	pop di
0075++ 0080 E7          	pop d
0076++ 0081 E8          	pop al
0077++ 0082 09          	ret
0078++ 0083             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0083             ; length of null terminated string
0080++ 0083             ; result in C
0081++ 0083             ; pointer in D
0082++ 0083             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0083             strlen:
0084++ 0083 DA          	push d
0085++ 0084 38 00 00    	mov c, 0
0086++ 0087             strlen_L1:
0087++ 0087 BD 00       	cmp byte [d], 0
0088++ 0089 C6 91 00    	je strlen_ret
0089++ 008C 79          	inc d
0090++ 008D 78          	inc c
0091++ 008E 0A 87 00    	jmp strlen_L1
0092++ 0091             strlen_ret:
0093++ 0091 E7          	pop d
0094++ 0092 09          	ret
0095++ 0093             
0096++ 0093             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0093             ; STRCMP
0098++ 0093             ; compare two strings
0099++ 0093             ; str1 in SI
0100++ 0093             ; str2 in DI
0101++ 0093             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0093             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0093             strcmp:
0104++ 0093 DB          	push al
0105++ 0094 DA          	push d
0106++ 0095 E3          	push di
0107++ 0096 E2          	push si
0108++ 0097             strcmp_loop:
0109++ 0097 F3          	cmpsb					; compare a byte of the strings
0110++ 0098 C7 A3 00    	jne strcmp_ret
0111++ 009B FB FF FF    	lea d, [si +- 1]
0112++ 009E BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 00A0 C7 97 00    	jne strcmp_loop				; equal chars but not at end
0114++ 00A3             strcmp_ret:
0115++ 00A3 EF          	pop si
0116++ 00A4 F0          	pop di
0117++ 00A5 E7          	pop d
0118++ 00A6 E8          	pop al
0119++ 00A7 09          	ret
0120++ 00A8             
0121++ 00A8             
0122++ 00A8             ; STRCPY
0123++ 00A8             ; copy null terminated string from SI to DI
0124++ 00A8             ; source in SI
0125++ 00A8             ; destination in DI
0126++ 00A8             strcpy:
0127++ 00A8 E2          	push si
0128++ 00A9 E3          	push di
0129++ 00AA DB          	push al
0130++ 00AB             strcpy_L1:
0131++ 00AB F6          	lodsb
0132++ 00AC F7          	stosb
0133++ 00AD B9 00       	cmp al, 0
0134++ 00AF C7 AB 00    	jne strcpy_L1
0135++ 00B2             strcpy_end:
0136++ 00B2 E8          	pop al
0137++ 00B3 F0          	pop di
0138++ 00B4 EF          	pop si
0139++ 00B5 09          	ret
0140++ 00B6             
0141++ 00B6             ; STRCAT
0142++ 00B6             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 00B6             ; source in SI
0144++ 00B6             ; destination in DI
0145++ 00B6             strcat:
0146++ 00B6 E2          	push si
0147++ 00B7 E3          	push di
0148++ 00B8 D7          	push a
0149++ 00B9 DA          	push d
0150++ 00BA 50          	mov a, di
0151++ 00BB 3C          	mov d, a
0152++ 00BC             strcat_goto_end_L1:
0153++ 00BC BD 00       	cmp byte[d], 0
0154++ 00BE C6 C5 00    	je strcat_start
0155++ 00C1 79          	inc d
0156++ 00C2 0A BC 00    	jmp strcat_goto_end_L1
0157++ 00C5             strcat_start:
0158++ 00C5 FD 50       	mov di, d
0159++ 00C7             strcat_L1:
0160++ 00C7 F6          	lodsb
0161++ 00C8 F7          	stosb
0162++ 00C9 B9 00       	cmp al, 0
0163++ 00CB C7 C7 00    	jne strcat_L1
0164++ 00CE             strcat_end:
0165++ 00CE E7          	pop d
0166++ 00CF E4          	pop a
0167++ 00D0 F0          	pop di
0168++ 00D1 EF          	pop si
0169++ 00D2 09          	ret
0005+  00D3             
0006+  00D3 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  00D7 34 35 36 37 
0006+  00DB 38 39 41 42 
0006+  00DF 43 44 45 46 
0007+  00E3 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  00E7 1B 5B 48 00 
0008+  00EB             
0009+  00EB 01 00       table_power:.dw 1
0010+  00ED 0A 00       			.dw 10
0011+  00EF 64 00       			.dw 100
0012+  00F1 E8 03       			.dw 1000
0013+  00F3 10 27       			.dw 10000
0014+  00F5             
0015+  00F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  00F5             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  00F5             ; ASCII in BL
0018+  00F5             ; result in AL
0019+  00F5             ; ascii for F = 0100 0110
0020+  00F5             ; ascii for 9 = 0011 1001
0021+  00F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  00F5             hex_ascii_encode:
0023+  00F5 1B          	mov al, bl
0024+  00F6 93 40       	test al, $40				; test if letter or number
0025+  00F8 C7 FE 00    	jnz hex_letter
0026+  00FB 87 0F       	and al, $0F				; get number
0027+  00FD 09          	ret
0028+  00FE             hex_letter:
0029+  00FE 87 0F       	and al, $0F				; get letter
0030+  0100 6A 09       	add al, 9
0031+  0102 09          	ret
0032+  0103             
0033+  0103             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  0103             ; ATOI
0035+  0103             ; 2 letter hex string in B
0036+  0103             ; 8bit integer returned in AL
0037+  0103             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0103             atoi:
0039+  0103 D8          	push b
0040+  0104 07 F5 00    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  0107 30          	mov bl, bh
0042+  0108 DB          	push al					; save a
0043+  0109 07 F5 00    	call hex_ascii_encode
0044+  010C EA          	pop bl	
0045+  010D FD 9E 04    	shl al, 4
0046+  0110 8C          	or al, bl
0047+  0111 E5          	pop b
0048+  0112 09          	ret	
0049+  0113             
0050+  0113             
0051+  0113             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  0113             ; printf
0053+  0113             ; no need for explanations!
0054+  0113             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0113             printf:
0056+  0113 09          	ret
0057+  0114             
0058+  0114             
0059+  0114             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  0114             ; scanf
0061+  0114             ; no need for explanations!
0062+  0114             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  0114             scanf:
0064+  0114 09          	ret
0065+  0115             
0066+  0115             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  0115             ; ITOA
0068+  0115             ; 8bit value in BL
0069+  0115             ; 2 byte ASCII result in A
0070+  0115             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  0115             itoa:
0072+  0115 DA          	push d
0073+  0116 D8          	push b
0074+  0117 A7 00       	mov bh, 0
0075+  0119 FD A4 04    	shr bl, 4	
0076+  011C 74          	mov d, b
0077+  011D 1F D3 00    	mov al, [d + s_hex_digits]
0078+  0120 23          	mov ah, al
0079+  0121             	
0080+  0121 E5          	pop b
0081+  0122 D8          	push b
0082+  0123 A7 00       	mov bh, 0
0083+  0125 FD 87 0F    	and bl, $0F
0084+  0128 74          	mov d, b
0085+  0129 1F D3 00    	mov al, [d + s_hex_digits]
0086+  012C E5          	pop b
0087+  012D E7          	pop d
0088+  012E 09          	ret
0089+  012F             
0090+  012F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  012F             ; HEX STRING TO BINARY
0092+  012F             ; di = destination address
0093+  012F             ; si = source
0094+  012F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  012F             hex_to_int:
0096+  012F             hex_to_int_L1:
0097+  012F F6          	lodsb					; load from [SI] to AL
0098+  0130 B9 00       	cmp al, 0				; check if ASCII 0
0099+  0132 C6 3F 01    	jz hex_to_int_ret
0100+  0135 36          	mov bh, al
0101+  0136 F6          	lodsb
0102+  0137 2F          	mov bl, al
0103+  0138 07 03 01    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  013B F7          	stosb					; store AL to [DI]
0105+  013C 0A 2F 01    	jmp hex_to_int_L1
0106+  013F             hex_to_int_ret:
0107+  013F 09          	ret		
0108+  0140             
0109+  0140             
0110+  0140             
0111+  0140             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  0140             ; GETCHAR
0113+  0140             ; char in ah
0114+  0140             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  0140             getchar:
0116+  0140 DB          	push al
0117+  0141             getchar_retry:
0118+  0141 FD 0C       	sti
0119+  0143 19 01       	mov al, 1
0120+  0145 05 03       	syscall sys_io			; receive in AH
0121+  0147 B9 00       	cmp al, 0			; check if any char was receive
0122+  0149 C6 41 01    	je getchar_retry
0123+  014C E8          	pop al
0124+  014D 09          	ret
0125+  014E             
0126+  014E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  014E             ; PUTCHAR
0128+  014E             ; char in ah
0129+  014E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  014E             putchar:
0131+  014E D7          	push a
0132+  014F 19 00       	mov al, 0
0133+  0151 05 03       	syscall sys_io			; char in AH
0134+  0153 E4          	pop a
0135+  0154 09          	ret
0136+  0155             
0137+  0155             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  0155             ;; INPUT A STRING
0139+  0155             ;; terminates with null
0140+  0155             ;; pointer in D
0141+  0155             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  0155             gets:
0143+  0155 D7          	push a
0144+  0156 DA          	push d
0145+  0157             gets_loop:
0146+  0157 FD 0C       	sti
0147+  0159 19 01       	mov al, 1
0148+  015B 05 03       	syscall sys_io			; receive in AH
0149+  015D B9 00       	cmp al, 0				; check error code (AL)
0150+  015F C6 57 01    	je gets_loop			; if no char received, retry
0151+  0162             
0152+  0162 76 1B       	cmp ah, 27
0153+  0164 C6 85 01    	je gets_telnet_escape
0154+  0167 76 0A       	cmp ah, $0A				; LF
0155+  0169 C6 DE 01    	je gets_end
0156+  016C 76 0D       	cmp ah, $0D				; CR
0157+  016E C6 DE 01    	je gets_end
0158+  0171 76 5C       	cmp ah, $5C				; '\\'
0159+  0173 C6 B5 01    	je gets_escape
0160+  0176             	
0161+  0176 76 08       	cmp ah, $08			; check for backspace
0162+  0178 C6 81 01    	je gets_backspace
0163+  017B             
0164+  017B 1A          	mov al, ah
0165+  017C 3E          	mov [d], al
0166+  017D 79          	inc d
0167+  017E 0A 57 01    	jmp gets_loop
0168+  0181             gets_backspace:
0169+  0181 7F          	dec d
0170+  0182 0A 57 01    	jmp gets_loop
0171+  0185             gets_telnet_escape:
0172+  0185 FD 0C       	sti
0173+  0187 19 01       	mov al, 1
0174+  0189 05 03       	syscall sys_io				; receive in AH without echo
0175+  018B B9 00       	cmp al, 0					; check error code (AL)
0176+  018D C6 85 01    	je gets_telnet_escape		; if no char received, retry
0177+  0190 76 5B       	cmp ah, '['
0178+  0192 C7 57 01    	jne gets_loop
0179+  0195             gets_telnet_escape_phase2:
0180+  0195 FD 0C       	sti
0181+  0197 19 01       	mov al, 1
0182+  0199 05 03       	syscall sys_io					; receive in AH without echo
0183+  019B B9 00       	cmp al, 0						; check error code (AL)
0184+  019D C6 95 01    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  01A0 76 44       	cmp ah, 'D'
0186+  01A2 C6 AD 01    	je gets_left_arrow
0187+  01A5 76 43       	cmp ah, 'C'
0188+  01A7 C6 B1 01    	je gets_right_arrow
0189+  01AA 0A 57 01    	jmp gets_loop
0190+  01AD             gets_left_arrow:
0191+  01AD 7F          	dec d
0192+  01AE 0A 57 01    	jmp gets_loop
0193+  01B1             gets_right_arrow:
0194+  01B1 79          	inc d
0195+  01B2 0A 57 01    	jmp gets_loop
0196+  01B5             gets_escape:
0197+  01B5 FD 0C       	sti
0198+  01B7 19 01       	mov al, 1
0199+  01B9 05 03       	syscall sys_io			; receive in AH
0200+  01BB B9 00       	cmp al, 0				; check error code (AL)
0201+  01BD C6 B5 01    	je gets_escape			; if no char received, retry
0202+  01C0 76 6E       	cmp ah, 'n'
0203+  01C2 C6 D0 01    	je gets_LF
0204+  01C5 76 72       	cmp ah, 'r'
0205+  01C7 C6 D7 01    	je gets_CR
0206+  01CA 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  01CB 3E          	mov [d], al
0208+  01CC 79          	inc d
0209+  01CD 0A 57 01    	jmp gets_loop
0210+  01D0             gets_LF:
0211+  01D0 19 0A       	mov al, $0A
0212+  01D2 3E          	mov [d], al
0213+  01D3 79          	inc d
0214+  01D4 0A 57 01    	jmp gets_loop
0215+  01D7             gets_CR:
0216+  01D7 19 0D       	mov al, $0D
0217+  01D9 3E          	mov [d], al
0218+  01DA 79          	inc d
0219+  01DB 0A 57 01    	jmp gets_loop
0220+  01DE             gets_end:
0221+  01DE 19 00       	mov al, 0
0222+  01E0 3E          	mov [d], al				; terminate string
0223+  01E1 E7          	pop d
0224+  01E2 E4          	pop a
0225+  01E3 09          	ret
0226+  01E4             
0227+  01E4             
0228+  01E4             
0229+  01E4             
0230+  01E4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  01E4             ;; INPUT TEXT
0232+  01E4             ;; terminated with CTRL+D
0233+  01E4             ;; pointer in D
0234+  01E4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  01E4             gettxt:
0236+  01E4 D7          	push a
0237+  01E5 DA          	push d
0238+  01E6             gettxt_loop:
0239+  01E6 19 01       	mov al, 1
0240+  01E8 05 03       	syscall sys_io			; receive in AH
0241+  01EA B9 00       	cmp al, 0				; check error code (AL)
0242+  01EC C6 E6 01    	je gettxt_loop		; if no char received, retry
0243+  01EF 76 04       	cmp ah, 4			; EOT
0244+  01F1 C6 2F 02    	je gettxt_end
0245+  01F4 76 08       	cmp ah, $08			; check for backspace
0246+  01F6 C6 2B 02    	je gettxt_backspace
0247+  01F9 76 5C       	cmp ah, $5C				; '\\'
0248+  01FB C6 04 02    	je gettxt_escape
0249+  01FE 1A          	mov al, ah
0250+  01FF 3E          	mov [d], al
0251+  0200 79          	inc d
0252+  0201 0A E6 01    	jmp gettxt_loop
0253+  0204             gettxt_escape:
0254+  0204 19 01       	mov al, 1
0255+  0206 05 03       	syscall sys_io			; receive in AH
0256+  0208 B9 00       	cmp al, 0				; check error code (AL)
0257+  020A C6 04 02    	je gettxt_escape		; if no char received, retry
0258+  020D 76 6E       	cmp ah, 'n'
0259+  020F C6 1D 02    	je gettxt_LF
0260+  0212 76 72       	cmp ah, 'r'
0261+  0214 C6 24 02    	je gettxt_CR
0262+  0217 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  0218 3E          	mov [d], al
0264+  0219 79          	inc d
0265+  021A 0A E6 01    	jmp gettxt_loop
0266+  021D             gettxt_LF:
0267+  021D 19 0A       	mov al, $0A
0268+  021F 3E          	mov [d], al
0269+  0220 79          	inc d
0270+  0221 0A E6 01    	jmp gettxt_loop
0271+  0224             gettxt_CR:
0272+  0224 19 0D       	mov al, $0D
0273+  0226 3E          	mov [d], al
0274+  0227 79          	inc d
0275+  0228 0A E6 01    	jmp gettxt_loop
0276+  022B             gettxt_backspace:
0277+  022B 7F          	dec d
0278+  022C 0A E6 01    	jmp gettxt_loop
0279+  022F             gettxt_end:
0280+  022F 19 00       	mov al, 0
0281+  0231 3E          	mov [d], al				; terminate string
0282+  0232 E7          	pop d
0283+  0233 E4          	pop a
0284+  0234 09          	ret
0285+  0235             
0286+  0235             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  0235             ; PRINT NEW LINE
0288+  0235             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  0235             printnl:
0290+  0235 D7          	push a
0291+  0236 10 00 0A    	mov a, $0A00
0292+  0239 05 03       	syscall sys_io
0293+  023B 10 00 0D    	mov a, $0D00
0294+  023E 05 03       	syscall sys_io
0295+  0240 E4          	pop a
0296+  0241 09          	ret
0297+  0242             
0298+  0242             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  0242             ; strtoint
0300+  0242             ; 4 digit hex string number in d
0301+  0242             ; integer returned in A
0302+  0242             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  0242             strtointx:
0304+  0242 D8          	push b
0305+  0243 32          	mov bl, [d]
0306+  0244 37          	mov bh, bl
0307+  0245 33 01 00    	mov bl, [d + 1]
0308+  0248 07 03 01    	call atoi				; convert to int in AL
0309+  024B 23          	mov ah, al				; move to AH
0310+  024C 33 02 00    	mov bl, [d + 2]
0311+  024F 37          	mov bh, bl
0312+  0250 33 03 00    	mov bl, [d + 3]
0313+  0253 07 03 01    	call atoi				; convert to int in AL
0314+  0256 E5          	pop b
0315+  0257 09          	ret
0316+  0258             
0317+  0258             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  0258             ; strtoint
0319+  0258             ; 5 digit base10 string number in d
0320+  0258             ; integer returned in A
0321+  0258             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  0258             strtoint:
0323+  0258 E2          	push si
0324+  0259 D8          	push b
0325+  025A D9          	push c
0326+  025B DA          	push d
0327+  025C 07 83 00    	call strlen			; get string length in C
0328+  025F 7E          	dec c
0329+  0260 FD 4E       	mov si, d
0330+  0262 12          	mov a, c
0331+  0263 FD 99       	shl a
0332+  0265 3B EB 00    	mov d, table_power
0333+  0268 59          	add d, a
0334+  0269 38 00 00    	mov c, 0
0335+  026C             strtoint_L0:
0336+  026C F6          	lodsb			; load ASCII to al
0337+  026D B9 00       	cmp al, 0
0338+  026F C6 82 02    	je strtoint_end
0339+  0272 6F 30       	sub al, $30		; make into integer
0340+  0274 22 00       	mov ah, 0
0341+  0276 2A          	mov b, [d]
0342+  0277 AC          	mul a, b			; result in B since it fits in 16bits
0343+  0278 11          	mov a, b
0344+  0279 28          	mov b, c
0345+  027A 54          	add a, b
0346+  027B 39          	mov c, a
0347+  027C 63 02 00    	sub d, 2
0348+  027F 0A 6C 02    	jmp strtoint_L0
0349+  0282             strtoint_end:
0350+  0282 12          	mov a, c
0351+  0283 E7          	pop d
0352+  0284 E6          	pop c
0353+  0285 E5          	pop b
0354+  0286 EF          	pop si
0355+  0287 09          	ret
0356+  0288             
0357+  0288             
0358+  0288             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  0288             ; PRINT NULL TERMINATED STRING
0360+  0288             ; pointer in D
0361+  0288             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  0288             puts:
0363+  0288 D7          	push a
0364+  0289 DA          	push d
0365+  028A             puts_L1:
0366+  028A 1E          	mov al, [d]
0367+  028B B9 00       	cmp al, 0
0368+  028D C6 99 02    	jz puts_END
0369+  0290 23          	mov ah, al
0370+  0291 19 00       	mov al, 0
0371+  0293 05 03       	syscall sys_io
0372+  0295 79          	inc d
0373+  0296 0A 8A 02    	jmp puts_L1
0374+  0299             puts_END:
0375+  0299 E7          	pop d
0376+  029A E4          	pop a
0377+  029B 09          	ret
0378+  029C             
0379+  029C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  029C             ; PRINT N SIZE STRING
0381+  029C             ; pointer in D
0382+  029C             ; size in C
0383+  029C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  029C             putsn:
0385+  029C DB          	push al
0386+  029D DA          	push d
0387+  029E D9          	push c
0388+  029F             putsn_L0:
0389+  029F 1E          	mov al, [d]
0390+  02A0 23          	mov ah, al
0391+  02A1 19 00       	mov al, 0
0392+  02A3 05 03       	syscall sys_io
0393+  02A5 79          	inc d
0394+  02A6 7E          	dec c	
0395+  02A7 C2 00 00    	cmp c, 0
0396+  02AA C7 9F 02    	jne putsn_L0
0397+  02AD             putsn_end:
0398+  02AD E6          	pop c
0399+  02AE E7          	pop d
0400+  02AF E8          	pop al
0401+  02B0 09          	ret
0402+  02B1             
0403+  02B1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  02B1             ; print 16bit decimal number
0405+  02B1             ; input number in A
0406+  02B1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  02B1             print_u16d:
0408+  02B1 D7          	push a
0409+  02B2 D8          	push b
0410+  02B3 26 10 27    	mov b, 10000
0411+  02B6 AE          	div a, b			; get 10000 coeff.
0412+  02B7 07 DD 02    	call print_number
0413+  02BA 11          	mov a, b
0414+  02BB 26 E8 03    	mov b, 1000
0415+  02BE AE          	div a, b			; get 10000 coeff.
0416+  02BF 07 DD 02    	call print_number
0417+  02C2 11          	mov a, b
0418+  02C3 26 64 00    	mov b, 100
0419+  02C6 AE          	div a, b
0420+  02C7 07 DD 02    	call print_number
0421+  02CA 11          	mov a, b
0422+  02CB 26 0A 00    	mov b, 10
0423+  02CE AE          	div a, b
0424+  02CF 07 DD 02    	call print_number
0425+  02D2 11          	mov a, b
0426+  02D3 6A 30       	add al, $30
0427+  02D5 23          	mov ah, al
0428+  02D6 19 00       	mov al, 0
0429+  02D8 05 03       	syscall sys_io	; print coeff
0430+  02DA E5          	pop b
0431+  02DB E4          	pop a
0432+  02DC 09          	ret
0433+  02DD             
0434+  02DD             
0435+  02DD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  02DD             ; if A == 0, print space
0437+  02DD             ; else print A
0438+  02DD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0439+  02DD             print_number:
0440+  02DD 6A 30       	add al, $30
0441+  02DF 23          	mov ah, al
0442+  02E0 07 4E 01    	call putchar
0443+  02E3 09          	ret
0444+  02E4             
0445+  02E4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0446+  02E4             ; PRINT 16BIT HEX INTEGER
0447+  02E4             ; integer value in reg B
0448+  02E4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  02E4             print_u16x:
0450+  02E4 D7          	push a
0451+  02E5 D8          	push b
0452+  02E6 DD          	push bl
0453+  02E7 30          	mov bl, bh
0454+  02E8 07 15 01    	call itoa				; convert bh to char in A
0455+  02EB 2F          	mov bl, al				; save al
0456+  02EC 19 00       	mov al, 0
0457+  02EE 05 03       	syscall sys_io				; display AH
0458+  02F0 24          	mov ah, bl				; retrieve al
0459+  02F1 19 00       	mov al, 0
0460+  02F3 05 03       	syscall sys_io				; display AL
0461+  02F5             
0462+  02F5 EA          	pop bl
0463+  02F6 07 15 01    	call itoa				; convert bh to char in A
0464+  02F9 2F          	mov bl, al				; save al
0465+  02FA 19 00       	mov al, 0
0466+  02FC 05 03       	syscall sys_io				; display AH
0467+  02FE 24          	mov ah, bl				; retrieve al
0468+  02FF 19 00       	mov al, 0
0469+  0301 05 03       	syscall sys_io				; display AL
0470+  0303             
0471+  0303 E5          	pop b
0472+  0304 E4          	pop a
0473+  0305 09          	ret
0474+  0306             
0475+  0306             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  0306             ; INPUT 16BIT HEX INTEGER
0477+  0306             ; read 16bit integer into A
0478+  0306             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  0306             scan_u16x:
0480+  0306 F8 10 00    	enter 16
0481+  0309 D8          	push b
0482+  030A DA          	push d
0483+  030B             
0484+  030B FA F1 FF    	lea d, [bp + -15]
0485+  030E 07 55 01    	call gets				; get number
0486+  0311             
0487+  0311 32          	mov bl, [d]
0488+  0312 37          	mov bh, bl
0489+  0313 33 01 00    	mov bl, [d + 1]
0490+  0316 07 03 01    	call atoi				; convert to int in AL
0491+  0319 23          	mov ah, al				; move to AH
0492+  031A             
0493+  031A 33 02 00    	mov bl, [d + 2]
0494+  031D 37          	mov bh, bl
0495+  031E 33 03 00    	mov bl, [d + 3]
0496+  0321 07 03 01    	call atoi				; convert to int in AL
0497+  0324             
0498+  0324 E7          	pop d
0499+  0325 E5          	pop b
0500+  0326 F9          	leave
0501+  0327 09          	ret
0502+  0328             
0503+  0328             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0504+  0328             ; PRINT 8bit HEX INTEGER
0505+  0328             ; integer value in reg bl
0506+  0328             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  0328             print_u8x:
0508+  0328 D7          	push a
0509+  0329 DD          	push bl
0510+  032A             
0511+  032A 07 15 01    	call itoa				; convert bl to char in A
0512+  032D 2F          	mov bl, al				; save al
0513+  032E 19 00       	mov al, 0
0514+  0330 05 03       	syscall sys_io				; display AH
0515+  0332 24          	mov ah, bl				; retrieve al
0516+  0333 19 00       	mov al, 0
0517+  0335 05 03       	syscall sys_io				; display AL
0518+  0337             
0519+  0337 EA          	pop bl
0520+  0338 E4          	pop a
0521+  0339 09          	ret
0522+  033A             
0523+  033A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0524+  033A             ; print 8bit decimal unsigned number
0525+  033A             ; input number in AL
0526+  033A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  033A             print_u8d:
0528+  033A D7          	push a
0529+  033B D8          	push b
0530+  033C             
0531+  033C 22 00       	mov ah, 0
0532+  033E 26 64 00    	mov b, 100
0533+  0341 AE          	div a, b
0534+  0342 D8          	push b			; save remainder
0535+  0343 B9 00       	cmp al, 0
0536+  0345 C6 4F 03    	je skip100
0537+  0348 6A 30       	add al, $30
0538+  034A 23          	mov ah, al
0539+  034B 19 00       	mov al, 0
0540+  034D 05 03       	syscall sys_io	; print coeff
0541+  034F             skip100:
0542+  034F E4          	pop a
0543+  0350 22 00       	mov ah, 0
0544+  0352 26 0A 00    	mov b, 10
0545+  0355 AE          	div a, b
0546+  0356 D8          	push b			; save remainder
0547+  0357 B9 00       	cmp al, 0
0548+  0359 C6 63 03    	je skip10
0549+  035C 6A 30       	add al, $30
0550+  035E 23          	mov ah, al
0551+  035F 19 00       	mov al, 0
0552+  0361 05 03       	syscall sys_io	; print coeff
0553+  0363             skip10:
0554+  0363 E4          	pop a
0555+  0364 1B          	mov al, bl
0556+  0365 6A 30       	add al, $30
0557+  0367 23          	mov ah, al
0558+  0368 19 00       	mov al, 0
0559+  036A 05 03       	syscall sys_io	; print coeff
0560+  036C E5          	pop b
0561+  036D E4          	pop a
0562+  036E 09          	ret
0563+  036F             
0564+  036F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0565+  036F             ; INPUT 8BIT HEX INTEGER
0566+  036F             ; read 8bit integer into AL
0567+  036F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  036F             scan_u8x:
0569+  036F F8 04 00    	enter 4
0570+  0372 D8          	push b
0571+  0373 DA          	push d
0572+  0374             
0573+  0374 FA FD FF    	lea d, [bp + -3]
0574+  0377 07 55 01    	call gets				; get number
0575+  037A             
0576+  037A 32          	mov bl, [d]
0577+  037B 37          	mov bh, bl
0578+  037C 33 01 00    	mov bl, [d + 1]
0579+  037F 07 03 01    	call atoi				; convert to int in AL
0580+  0382             
0581+  0382 E7          	pop d
0582+  0383 E5          	pop b
0583+  0384 F9          	leave
0584+  0385 09          	ret
0585+  0386             
0586+  0386             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  0386             ; input decimal number
0588+  0386             ; result in A
0589+  0386             ; 655'\0'
0590+  0386             ; low--------high
0591+  0386             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0592+  0386             scan_u16d:
0593+  0386 F8 08 00    	enter 8
0594+  0389 E2          	push si
0595+  038A D8          	push b
0596+  038B D9          	push c
0597+  038C DA          	push d
0598+  038D FA F9 FF    	lea d, [bp +- 7]
0599+  0390 07 55 01    	call gets
0600+  0393 07 83 00    	call strlen			; get string length in C
0601+  0396 7E          	dec c
0602+  0397 FD 4E       	mov si, d
0603+  0399 12          	mov a, c
0604+  039A FD 99       	shl a
0605+  039C 3B EB 00    	mov d, table_power
0606+  039F 59          	add d, a
0607+  03A0 38 00 00    	mov c, 0
0608+  03A3             mul_loop:
0609+  03A3 F6          	lodsb			; load ASCII to al
0610+  03A4 B9 00       	cmp al, 0
0611+  03A6 C6 B9 03    	je mul_exit
0612+  03A9 6F 30       	sub al, $30		; make into integer
0613+  03AB 22 00       	mov ah, 0
0614+  03AD 2A          	mov b, [d]
0615+  03AE AC          	mul a, b			; result in B since it fits in 16bits
0616+  03AF 11          	mov a, b
0617+  03B0 28          	mov b, c
0618+  03B1 54          	add a, b
0619+  03B2 39          	mov c, a
0620+  03B3 63 02 00    	sub d, 2
0621+  03B6 0A A3 03    	jmp mul_loop
0622+  03B9             mul_exit:
0623+  03B9 12          	mov a, c
0624+  03BA E7          	pop d
0625+  03BB E6          	pop c
0626+  03BC E5          	pop b
0627+  03BD EF          	pop si
0628+  03BE F9          	leave
0629+  03BF 09          	ret
0169   03C0             .include "ctype.asm"
0001+  03C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  03C0             ; ctype.s
0003+  03C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  03C0             
0005+  03C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  03C0             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  03C0             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  03C0             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  03C0             ;; characters are supported.
0010+  03C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  03C0             ;; isalnum 
0012+  03C0             ;; isalpha 
0013+  03C0             ;; islower 
0014+  03C0             ;; isupper 
0015+  03C0             ;; isdigit 
0016+  03C0             ;; isxdigit
0017+  03C0             ;; iscntrl 
0018+  03C0             ;; isgraph 
0019+  03C0             ;; isspace 
0020+  03C0             ;; isblank 
0021+  03C0             ;; isprint 
0022+  03C0             ;; ispunct 
0023+  03C0             ;; tolower 
0024+  03C0             ;; toupper
0025+  03C0             
0026+  03C0             
0027+  03C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  03C0             ;; IS ALPHANUMERIC
0029+  03C0             ;; sets ZF according with result
0030+  03C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  03C0             isalnum:
0032+  03C0 07 DD 03    	call isalpha
0033+  03C3 C6 C9 03    	je isalnum_exit
0034+  03C6 07 CA 03    	call isdigit
0035+  03C9             isalnum_exit:
0036+  03C9 09          	ret	
0037+  03CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  03CA             ;; IS DIGIT
0039+  03CA             ;; sets ZF according with result
0040+  03CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  03CA             isdigit:
0042+  03CA DB          	push al
0043+  03CB B9 30       	cmp al, '0'
0044+  03CD C8 D9 03    	jlu isdigit_false
0045+  03D0 B9 39       	cmp al, '9'
0046+  03D2 D1 D9 03    	jgu isdigit_false
0047+  03D5 87 00       	and al, 0	; set ZF
0048+  03D7 E8          	pop al
0049+  03D8 09          	ret
0050+  03D9             isdigit_false:
0051+  03D9 8B 01       	or al, 1	; clear ZF
0052+  03DB E8          	pop al
0053+  03DC 09          	ret	
0054+  03DD             	
0055+  03DD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  03DD             ;; IS ALPHA
0057+  03DD             ;; sets ZF according with result
0058+  03DD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  03DD             isalpha:
0060+  03DD DB          	push al
0061+  03DE B9 5F       	cmp al, '_'
0062+  03E0 C6 00 04    	je isalpha_true
0063+  03E3 B9 2E       	cmp al, '.'
0064+  03E5 C6 00 04    	je isalpha_true
0065+  03E8 B9 41       	cmp al, 'A'
0066+  03EA C8 FC 03    	jlu isalpha_false
0067+  03ED B9 7A       	cmp al, 'z'
0068+  03EF D1 FC 03    	jgu isalpha_false
0069+  03F2 B9 5A       	cmp al, 'Z'
0070+  03F4 D0 00 04    	jleu isalpha_true
0071+  03F7 B9 61       	cmp al, 'a'
0072+  03F9 C9 00 04    	jgeu isalpha_true
0073+  03FC             isalpha_false:
0074+  03FC 8B 01       	or al, 1	; clear ZF
0075+  03FE E8          	pop al
0076+  03FF 09          	ret
0077+  0400             isalpha_true:
0078+  0400 87 00       	and al, 0	; set ZF
0079+  0402 E8          	pop al
0080+  0403 09          	ret
0081+  0404             
0082+  0404             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  0404             ;; IS PATH-ALPHA
0084+  0404             ;; sets ZF according with result
0085+  0404             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  0404             ispath:
0087+  0404 DB          	push al
0088+  0405 07 CA 03    	call isdigit
0089+  0408 C6 32 04    	je ispath_true
0090+  040B B9 5F       	cmp al, '_'
0091+  040D C6 32 04    	je ispath_true
0092+  0410 B9 2F       	cmp al, '/'
0093+  0412 C6 32 04    	je ispath_true
0094+  0415 B9 2E       	cmp al, '.'
0095+  0417 C6 32 04    	je ispath_true
0096+  041A B9 41       	cmp al, 'A'
0097+  041C C8 2E 04    	jlu ispath_false
0098+  041F B9 7A       	cmp al, 'z'
0099+  0421 D1 2E 04    	jgu ispath_false
0100+  0424 B9 5A       	cmp al, 'Z'
0101+  0426 D0 32 04    	jleu ispath_true
0102+  0429 B9 61       	cmp al, 'a'
0103+  042B C9 32 04    	jgeu ispath_true
0104+  042E             ispath_false:
0105+  042E 8B 01       	or al, 1	; clear ZF
0106+  0430 E8          	pop al
0107+  0431 09          	ret
0108+  0432             ispath_true:
0109+  0432 87 00       	and al, 0	; set ZF
0110+  0434 E8          	pop al
0111+  0435 09          	ret
0112+  0436             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  0436             ;; IS SPACE
0114+  0436             ;; sets ZF according with result
0115+  0436             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  0436             isspace:
0117+  0436 B9 20       	cmp al, $20		; ' '
0118+  0438 C6 4C 04    	je isspace_exit
0119+  043B B9 09       	cmp al, $09		; '\t'
0120+  043D C6 4C 04    	je isspace_exit
0121+  0440 B9 0A       	cmp al, $0A		; '\n'
0122+  0442 C6 4C 04    	je isspace_exit
0123+  0445 B9 0D       	cmp al, $0D		; '\r'
0124+  0447 C6 4C 04    	je isspace_exit
0125+  044A B9 0B       	cmp al, $0B		; '\v'
0126+  044C             isspace_exit:
0127+  044C 09          	ret	
0128+  044D             
0129+  044D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  044D             ; TO LOWER
0131+  044D             ; input in AL
0132+  044D             ; output in AL
0133+  044D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  044D             to_lower:
0135+  044D B9 5A       	cmp al, 'Z'
0136+  044F D1 54 04    	jgu to_lower_ret
0137+  0452 6A 20       	add al, $20				; convert to lower case
0138+  0454             to_lower_ret:
0139+  0454 09          	ret
0140+  0455             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  0455             ; TO UPPER
0142+  0455             ; input in AL
0143+  0455             ; output in AL
0144+  0455             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  0455             to_upper:
0146+  0455 B9 61       	cmp al, 'a'
0147+  0457 C8 5C 04    	jlu to_upper_ret
0148+  045A 6F 20       	sub al, $20			; convert to upper case
0149+  045C             to_upper_ret:
0150+  045C 09          	ret
0151+  045D             
0170   045D             .include "token.asm"
0001+  045D             TOKTYP_IDENTIFIER	.equ 0
0002+  045D             TOKTYP_KEYWORD		.equ 1
0003+  045D             TOKTYP_DELIMITER	.equ 2
0004+  045D             TOKTYP_STRING		.equ 3
0005+  045D             TOKTYP_CHAR			.equ 4
0006+  045D             TOKTYP_NUMERIC		.equ 5
0007+  045D             TOKTYP_END			.equ 6
0008+  045D             
0009+  045D             TOK_NULL			.equ 0
0010+  045D             TOK_FSLASH			.equ 1
0011+  045D             TOK_TIMES 			.equ 2
0012+  045D             TOK_PLUS 			.equ 3
0013+  045D             TOK_MINUS 			.equ 4
0014+  045D             TOK_DOT				.equ 5
0015+  045D             TOK_SEMI			.equ 6
0016+  045D             TOK_ANGLE			.equ 7
0017+  045D             TOK_TILDE			.equ 8
0018+  045D             TOK_EQUAL			.equ 9
0019+  045D             TOK_COLON			.equ 10
0020+  045D             TOK_COMMA			.equ 11
0021+  045D             
0022+  045D             TOK_END				.equ 20
0023+  045D             
0024+  045D             
0025+  045D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  045D             ;; read a full command argment from shell input buffer
0027+  045D             ;; argument is written into tokstr
0028+  045D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  045D             get_arg:
0030+  045D D7          	push a
0031+  045E E2          	push si
0032+  045F E3          	push di
0033+  0460 19 00       	mov al, 0
0034+  0462 3D 8B 06    	mov [tokstr], al			; nullify tokstr string
0035+  0465 14 87 06    	mov a, [prog]
0036+  0468 4D          	mov si, a
0037+  0469 FD 4F 8B 06 	mov di, tokstr
0038+  046D             get_arg_skip_spaces:
0039+  046D F6          	lodsb
0040+  046E 07 36 04    	call isspace
0041+  0471 C6 6D 04    	je get_arg_skip_spaces
0042+  0474             get_arg_L0:
0043+  0474 B9 3B       	cmp al, $3B				; check if is ';'
0044+  0476 C6 83 04    	je get_arg_end
0045+  0479 B9 00       	cmp al, 0
0046+  047B C6 83 04    	je get_arg_end			; check if end of input
0047+  047E F7          	stosb
0048+  047F F6          	lodsb
0049+  0480 0A 74 04    	jmp get_arg_L0
0050+  0483             get_arg_end:
0051+  0483 19 00       	mov al, 0
0052+  0485 F7          	stosb
0053+  0486 D5 01 00    	sub si, 1
0054+  0489 4E          	mov a, si
0055+  048A 42 87 06    	mov [prog], a		; update pointer
0056+  048D F0          	pop di
0057+  048E EF          	pop si
0058+  048F E4          	pop a
0059+  0490 09          	ret
0060+  0491             
0061+  0491             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  0491             ;; read a path formation from shell input buffer
0063+  0491             ;; path is written into tokstr
0064+  0491             ;; /usr/bin
0065+  0491             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  0491             get_path:
0067+  0491 D7          	push a
0068+  0492 E2          	push si
0069+  0493 E3          	push di
0070+  0494 19 00       	mov al, 0
0071+  0496 3D 8B 06    	mov [tokstr], al			; nullify tokstr string
0072+  0499 14 87 06    	mov a, [prog]
0073+  049C 4D          	mov si, a
0074+  049D FD 4F 8B 06 	mov di, tokstr
0075+  04A1             get_path_skip_spaces:
0076+  04A1 F6          	lodsb
0077+  04A2 07 36 04    	call isspace
0078+  04A5 C6 A1 04    	je get_path_skip_spaces
0079+  04A8             get_path_is_pathchar:
0080+  04A8 F7          	stosb
0081+  04A9 F6          	lodsb
0082+  04AA 07 C0 03    	call isalnum			;check if is alphanumeric
0083+  04AD C6 A8 04    	je get_path_is_pathchar
0084+  04B0 B9 2F       	cmp al, '/'				; check if is '/'
0085+  04B2 C6 A8 04    	je get_path_is_pathchar
0086+  04B5 19 00       	mov al, 0
0087+  04B7 F7          	stosb
0088+  04B8 D5 01 00    	sub si, 1
0089+  04BB 4E          	mov a, si
0090+  04BC 42 87 06    	mov [prog], a		; update pointer
0091+  04BF             get_path_end:
0092+  04BF F0          	pop di
0093+  04C0 EF          	pop si
0094+  04C1 E4          	pop a
0095+  04C2 09          	ret
0096+  04C3             
0097+  04C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  04C3             ;; read a line
0099+  04C3             ;; line is written into tokstr
0100+  04C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  04C3             get_line:
0102+  04C3 D7          	push a
0103+  04C4 E2          	push si
0104+  04C5 E3          	push di
0105+  04C6 19 00       	mov al, 0
0106+  04C8 3D 8B 06    	mov [tokstr], al			; nullify tokstr string
0107+  04CB 14 87 06    	mov a, [prog]
0108+  04CE 4D          	mov si, a
0109+  04CF FD 4F 8B 06 	mov di, tokstr
0110+  04D3             get_line_L0:
0111+  04D3 F6          	lodsb
0112+  04D4 B9 0A       	cmp al, $0A		; check for new line
0113+  04D6 C6 DD 04    	je get_line_exit
0114+  04D9 F7          	stosb
0115+  04DA 0A D3 04    	jmp get_line_L0
0116+  04DD             get_line_exit:
0117+  04DD 19 00       	mov al, 0
0118+  04DF F7          	stosb
0119+  04E0 4E          	mov a, si
0120+  04E1 42 87 06    	mov [prog], a		; update pointer
0121+  04E4 F0          	pop di
0122+  04E5 EF          	pop si
0123+  04E6 E4          	pop a
0124+  04E7 09          	ret
0125+  04E8             
0126+  04E8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  04E8             ;; token parser
0128+  04E8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  04E8             get_token:
0130+  04E8 D7          	push a
0131+  04E9 DA          	push d
0132+  04EA E2          	push si
0133+  04EB E3          	push di
0134+  04EC 19 00       	mov al, 0
0135+  04EE 3D 8B 06    	mov [tokstr], al			; nullify tokstr string
0136+  04F1 19 00       	mov al, TOK_NULL
0137+  04F3 3D 8A 06    	mov [tok], al				; nullify token
0138+  04F6 14 87 06    	mov a, [prog]
0139+  04F9 4D          	mov si, a
0140+  04FA FD 4F 8B 06 	mov di, tokstr
0141+  04FE             get_tok_skip_spaces:
0142+  04FE F6          	lodsb
0143+  04FF 07 36 04    	call isspace
0144+  0502 C6 FE 04    	je get_tok_skip_spaces
0145+  0505 B9 00       	cmp al, 0			; check for end of input (NULL)
0146+  0507 C6 EC 05    	je get_token_end
0147+  050A B9 23       	cmp al, '#'			; comments!
0148+  050C C6 1A 06    	je get_tok_comment
0149+  050F 07 C0 03    	call isalnum
0150+  0512 C6 F9 05    	jz is_alphanumeric
0151+  0515             ; other token types
0152+  0515             get_token_slash:
0153+  0515 B9 2F       	cmp al, '/'				; check if '/'
0154+  0517 C7 2F 05    	jne get_token_minus
0155+  051A F7          	stosb					; store '/' into token string
0156+  051B 19 00       	mov al, 0
0157+  051D F7          	stosb					; terminate token string
0158+  051E 19 01       	mov al, TOK_FSLASH
0159+  0520 3D 8A 06    	mov [tok], al			
0160+  0523 19 02       	mov al, TOKTYP_DELIMITER
0161+  0525 3D 89 06    	mov [toktyp], al
0162+  0528 4E          	mov a, si
0163+  0529 42 87 06    	mov [prog], a		; update pointer
0164+  052C 0A 15 06    	jmp get_token_return
0165+  052F             get_token_minus:
0166+  052F B9 2D       	cmp al, '-'				; check if '-'
0167+  0531 C7 49 05    	jne get_token_comma
0168+  0534 F7          	stosb					; store '-' into token string
0169+  0535 19 00       	mov al, 0
0170+  0537 F7          	stosb					; terminate token string
0171+  0538 19 04       	mov al, TOK_MINUS
0172+  053A 3D 8A 06    	mov [tok], al			
0173+  053D 19 02       	mov al, TOKTYP_DELIMITER
0174+  053F 3D 89 06    	mov [toktyp], al
0175+  0542 4E          	mov a, si
0176+  0543 42 87 06    	mov [prog], a		; update pointer
0177+  0546 0A 15 06    	jmp get_token_return
0178+  0549             get_token_comma:
0179+  0549 B9 2C       	cmp al, ','				; check if ','
0180+  054B C7 63 05    	jne get_token_semi
0181+  054E F7          	stosb					; store ',' into token string
0182+  054F 19 00       	mov al, 0
0183+  0551 F7          	stosb					; terminate token string
0184+  0552 19 0B       	mov al, TOK_COMMA
0185+  0554 3D 8A 06    	mov [tok], al			
0186+  0557 19 02       	mov al, TOKTYP_DELIMITER
0187+  0559 3D 89 06    	mov [toktyp], al
0188+  055C 4E          	mov a, si
0189+  055D 42 87 06    	mov [prog], a		; update pointer
0190+  0560 0A 15 06    	jmp get_token_return
0191+  0563             get_token_semi:
0192+  0563 B9 3B       	cmp al, $3B				; check if ';'
0193+  0565 C7 7D 05    	jne get_token_colon
0194+  0568 F7          	stosb					; store ';' into token string
0195+  0569 19 00       	mov al, 0
0196+  056B F7          	stosb					; terminate token string
0197+  056C 19 06       	mov al, TOK_SEMI
0198+  056E 3D 8A 06    	mov [tok], al			
0199+  0571 19 02       	mov al, TOKTYP_DELIMITER
0200+  0573 3D 89 06    	mov [toktyp], al
0201+  0576 4E          	mov a, si
0202+  0577 42 87 06    	mov [prog], a		; update pointer
0203+  057A 0A 15 06    	jmp get_token_return
0204+  057D             get_token_colon:
0205+  057D B9 3A       	cmp al, $3A				; check if ':'
0206+  057F C7 97 05    	jne get_token_angle
0207+  0582 F7          	stosb					; store ':' into token string
0208+  0583 19 00       	mov al, 0
0209+  0585 F7          	stosb					; terminate token string
0210+  0586 19 0A       	mov al, TOK_COLON
0211+  0588 3D 8A 06    	mov [tok], al			
0212+  058B 19 02       	mov al, TOKTYP_DELIMITER
0213+  058D 3D 89 06    	mov [toktyp], al
0214+  0590 4E          	mov a, si
0215+  0591 42 87 06    	mov [prog], a		; update pointer
0216+  0594 0A 15 06    	jmp get_token_return
0217+  0597             get_token_angle:
0218+  0597 B9 3E       	cmp al, $3E				; check if '>'
0219+  0599 C7 B1 05    	jne get_token_tilde
0220+  059C F7          	stosb					; store '>' into token string
0221+  059D 19 00       	mov al, 0
0222+  059F F7          	stosb					; terminate token string
0223+  05A0 19 07       	mov al, TOK_ANGLE
0224+  05A2 3D 8A 06    	mov [tok], al			
0225+  05A5 19 02       	mov al, TOKTYP_DELIMITER
0226+  05A7 3D 89 06    	mov [toktyp], al
0227+  05AA 4E          	mov a, si
0228+  05AB 42 87 06    	mov [prog], a		; update pointer
0229+  05AE 0A 15 06    	jmp get_token_return
0230+  05B1             get_token_tilde:
0231+  05B1 B9 7E       	cmp al, '~'				; check if '~'
0232+  05B3 C7 CB 05    	jne get_token_equal
0233+  05B6 F7          	stosb					; store '~' into token string
0234+  05B7 19 00       	mov al, 0
0235+  05B9 F7          	stosb					; terminate token string
0236+  05BA 19 08       	mov al, TOK_TILDE
0237+  05BC 3D 8A 06    	mov [tok], al			
0238+  05BF 19 02       	mov al, TOKTYP_DELIMITER
0239+  05C1 3D 89 06    	mov [toktyp], al
0240+  05C4 4E          	mov a, si
0241+  05C5 42 87 06    	mov [prog], a		; update pointer
0242+  05C8 0A 15 06    	jmp get_token_return
0243+  05CB             get_token_equal:
0244+  05CB B9 3D       	cmp al, '='				; check if '='
0245+  05CD C7 E5 05    	jne get_token_skip
0246+  05D0 F7          	stosb					; store '=' into token string
0247+  05D1 19 00       	mov al, 0
0248+  05D3 F7          	stosb					; terminate token string
0249+  05D4 19 09       	mov al, TOK_EQUAL
0250+  05D6 3D 8A 06    	mov [tok], al			
0251+  05D9 19 02       	mov al, TOKTYP_DELIMITER
0252+  05DB 3D 89 06    	mov [toktyp], al
0253+  05DE 4E          	mov a, si
0254+  05DF 42 87 06    	mov [prog], a		; update pointer
0255+  05E2 0A 15 06    	jmp get_token_return
0256+  05E5             get_token_skip:
0257+  05E5 4E          	mov a, si
0258+  05E6 42 87 06    	mov [prog], a		; update pointer
0259+  05E9 0A 15 06    	jmp get_token_return
0260+  05EC             get_token_end:				; end of file token
0261+  05EC 19 14       	mov al, TOK_END
0262+  05EE 3D 8A 06    	mov [tok], al
0263+  05F1 19 06       	mov al, TOKTYP_END
0264+  05F3 3D 89 06    	mov [toktyp], al
0265+  05F6 0A 15 06    	jmp get_token_return
0266+  05F9             is_alphanumeric:
0267+  05F9 F7          	stosb
0268+  05FA F6          	lodsb
0269+  05FB 07 C0 03    	call isalnum			;check if is alphanumeric
0270+  05FE C6 F9 05    	jz is_alphanumeric
0271+  0601 B9 2E       	cmp al, $2E				; check if is '.'
0272+  0603 C6 F9 05    	je is_alphanumeric
0273+  0606 19 00       	mov al, 0
0274+  0608 F7          	stosb
0275+  0609 19 00       	mov al, TOKTYP_IDENTIFIER
0276+  060B 3D 89 06    	mov [toktyp], al
0277+  060E D5 01 00    	sub si, 1
0278+  0611 4E          	mov a, si
0279+  0612 42 87 06    	mov [prog], a		; update pointer
0280+  0615             get_token_return:
0281+  0615 F0          	pop di
0282+  0616 EF          	pop si
0283+  0617 E7          	pop d
0284+  0618 E4          	pop a
0285+  0619 09          	ret
0286+  061A             get_tok_comment:
0287+  061A F6          	lodsb
0288+  061B B9 0A       	cmp al, $0A			; new line
0289+  061D C7 1A 06    	jne get_tok_comment
0290+  0620 0A FE 04    	jmp get_tok_skip_spaces
0291+  0623             
0292+  0623             
0293+  0623             get_number:
0294+  0623 D7          	push a
0295+  0624 DA          	push d
0296+  0625 E2          	push si
0297+  0626 E3          	push di
0298+  0627 19 00       	mov al, 0
0299+  0629 3D 8B 06    	mov [tokstr], al			; nullify tokstr string
0300+  062C 19 00       	mov al, TOK_NULL
0301+  062E 3D 8A 06    	mov [tok], al				; nullify token
0302+  0631 14 87 06    	mov a, [prog]
0303+  0634 4D          	mov si, a
0304+  0635 FD 4F 8B 06 	mov di, tokstr
0305+  0639             get_number_skip_spaces:
0306+  0639 F6          	lodsb
0307+  063A 07 36 04    	call isspace
0308+  063D C6 39 06    	je get_number_skip_spaces
0309+  0640 B9 00       	cmp al, 0			; check for end of input (NULL)
0310+  0642 C7 52 06    	jne get_number_L0
0311+  0645 19 14       	mov al, TOK_END
0312+  0647 3D 8A 06    	mov [tok], al
0313+  064A 19 06       	mov al, TOKTYP_END
0314+  064C 3D 89 06    	mov [toktyp], al
0315+  064F 0A 69 06    	jmp get_number_return
0316+  0652             get_number_L0:
0317+  0652 F7          	stosb
0318+  0653 F6          	lodsb
0319+  0654 07 CA 03    	call isdigit			;check if is numeric
0320+  0657 C6 52 06    	jz get_number_L0
0321+  065A 19 00       	mov al, 0
0322+  065C F7          	stosb
0323+  065D 19 05       	mov al, TOKTYP_NUMERIC
0324+  065F 3D 89 06    	mov [toktyp], al
0325+  0662 D5 01 00    	sub si, 1
0326+  0665 4E          	mov a, si
0327+  0666 42 87 06    	mov [prog], a		; update pointer
0328+  0669             get_number_return:
0329+  0669 F0          	pop di
0330+  066A EF          	pop si
0331+  066B E7          	pop d
0332+  066C E4          	pop a
0333+  066D 09          	ret
0334+  066E             
0335+  066E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  066E             ;; PUT BACK TOKEN
0337+  066E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
0338+  066E             putback:
0339+  066E D7          	push a
0340+  066F E2          	push si
0341+  0670 FD 4D 8B 06 	mov si, tokstr	
0342+  0674             putback_loop:
0343+  0674 F6          	lodsb
0344+  0675 B9 00       	cmp al, 0
0345+  0677 C6 84 06    	je putback_end
0346+  067A 14 87 06    	mov a, [prog]
0347+  067D 7D          	dec a
0348+  067E 42 87 06    	mov [prog], a			; update pointer
0349+  0681 0A 74 06    	jmp putback_loop
0350+  0684             putback_end:
0351+  0684 EF          	pop si
0352+  0685 E4          	pop a
0353+  0686 09          	ret
0354+  0687             
0355+  0687             
0356+  0687             
0357+  0687             
0358+  0687 00 00       prog:		.dw 0			; pointer to current position in buffer
0359+  0689             
0360+  0689 00          toktyp: 	.db 0			; token type symbol
0361+  068A 00          tok:		.db 0			; current token symbol
0362+  068B 00 00 00 00 tokstr:		.fill 256, 0	; token as a string
0362+  068F 00 00 00 00 
0362+  0693 00 00 00 00 
0362+  0697 00 00 00 00 
0362+  069B 00 00 00 00 
0362+  069F 00 00 00 00 
0362+  06A3 00 00 00 00 
0362+  06A7 00 00 00 00 
0362+  06AB 00 00 00 00 
0362+  06AF 00 00 00 00 
0362+  06B3 00 00 00 00 
0362+  06B7 00 00 00 00 
0362+  06BB 00 00 00 00 
0362+  06BF 00 00 00 00 
0362+  06C3 00 00 00 00 
0362+  06C7 00 00 00 00 
0362+  06CB 00 00 00 00 
0362+  06CF 00 00 00 00 
0362+  06D3 00 00 00 00 
0362+  06D7 00 00 00 00 
0362+  06DB 00 00 00 00 
0362+  06DF 00 00 00 00 
0362+  06E3 00 00 00 00 
0362+  06E7 00 00 00 00 
0362+  06EB 00 00 00 00 
0362+  06EF 00 00 00 00 
0362+  06F3 00 00 00 00 
0362+  06F7 00 00 00 00 
0362+  06FB 00 00 00 00 
0362+  06FF 00 00 00 00 
0362+  0703 00 00 00 00 
0362+  0707 00 00 00 00 
0362+  070B 00 00 00 00 
0362+  070F 00 00 00 00 
0362+  0713 00 00 00 00 
0362+  0717 00 00 00 00 
0362+  071B 00 00 00 00 
0362+  071F 00 00 00 00 
0362+  0723 00 00 00 00 
0362+  0727 00 00 00 00 
0362+  072B 00 00 00 00 
0362+  072F 00 00 00 00 
0362+  0733 00 00 00 00 
0362+  0737 00 00 00 00 
0362+  073B 00 00 00 00 
0362+  073F 00 00 00 00 
0362+  0743 00 00 00 00 
0362+  0747 00 00 00 00 
0362+  074B 00 00 00 00 
0362+  074F 00 00 00 00 
0362+  0753 00 00 00 00 
0362+  0757 00 00 00 00 
0362+  075B 00 00 00 00 
0362+  075F 00 00 00 00 
0362+  0763 00 00 00 00 
0362+  0767 00 00 00 00 
0362+  076B 00 00 00 00 
0362+  076F 00 00 00 00 
0362+  0773 00 00 00 00 
0362+  0777 00 00 00 00 
0362+  077B 00 00 00 00 
0362+  077F 00 00 00 00 
0362+  0783 00 00 00 00 
0362+  0787 00 00 00 00 
0171   078B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0172   078B             
0173   078B             sys_bkpt			.equ 0
0174   078B             sys_rtc				.equ 1
0175   078B             sys_IDE				.equ 2
0176   078B             sys_io				.equ 3
0177   078B             sys_fileio			.equ 4
0178   078B             sys_fork			.equ 5
0179   078B             sys_list			.equ 6
0180   078B             sys_datetime		.equ 7
0181   078B             sys_reboot			.equ 8
0182   078B             sys_pauseproc		.equ 9
0183   078B             sys_resumeproc		.equ 10
0184   078B             sys_terminate_proc	.equ 11
0185   078B             sys_system			.equ 12
0186   078B             sys_boot_install	.equ 13
0187   078B             
0188   078B             .export PROC_TEXT_ORG
0189   078B             .export sys_bkpt
0190   078B             .export sys_IDE
0191   078B             .export sys_io
0192   078B             .export sys_fileio
0193   078B             .export sys_fork
0194   078B             .export sys_list
0195   078B             .export sys_rtc
0196   078B             .export sys_datetime
0197   078B             .export sys_reboot
0198   078B             .export sys_pauseproc
0199   078B             .export sys_resumeproc
0200   078B             .export sys_terminate_proc
0201   078B             .export sys_system
0202   078B             .export sys_boot_install
0203   078B             
0204   078B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0205   078B             ; EXTERNAL INTERRUPTS' CODE BLOCK
0206   078B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0207   078B             ; uart
0208   078B             int_0:
0209   078B 06          	sysret
0210   078C             int_1:
0211   078C 06          	sysret
0212   078D             int_2:
0213   078D 06          	sysret
0214   078E             int_3:
0215   078E 06          	sysret
0216   078F             int_4:
0217   078F 06          	sysret
0218   0790             int_5:
0219   0790 06          	sysret
0220   0791             int_6:	
0221   0791             ; save all registers into kernel stack
0222   0791 4B          	pusha
0223   0792 22 00       	mov ah, 0
0224   0794 1D 2B 16    	mov al, [active_proc_index]
0225   0797 FD 99       	shl a							; x2
0226   0799 B7 E9 15    	mov a, [proc_table_convert + a]	; get process state start index
0227   079C             		
0228   079C 4F          	mov di, a
0229   079D 48          	mov a, sp
0230   079E 77          	inc a
0231   079F 4D          	mov si, a
0232   07A0 38 14 00    	mov c, 20
0233   07A3 FD F5       	rep movsb					; save process state!
0234   07A5             ; restore kernel stack position to point before interrupt arrived
0235   07A5 51 14 00    	add sp, 20
0236   07A8             ; now load next process in queue
0237   07A8 1D 2B 16    	mov al, [active_proc_index]
0238   07AB 31 2A 16    	mov bl, [nbr_active_procs]
0239   07AE BA          	cmp al, bl
0240   07AF C6 B6 07    	je int6_cycle_back
0241   07B2 7A          	inc al						; next process is next in the series
0242   07B3 0A B8 07    	jmp int6_continue
0243   07B6             int6_cycle_back:
0244   07B6 19 01       	mov al, 1				; next process = process 1
0245   07B8             int6_continue:
0246   07B8 3D 2B 16    	mov [active_proc_index], al		; set next active proc
0247   07BB             
0248   07BB             ; calculate LUT entry for next process
0249   07BB 22 00       	mov ah, 0
0250   07BD FD 99       	shl a							; x2
0251   07BF B7 E9 15    	mov a, [proc_table_convert + a]		; get process state start index	
0252   07C2             	
0253   07C2 4D          	mov si, a						; source is proc state block
0254   07C3 48          	mov a, sp
0255   07C4 5F 13 00    	sub a, 19
0256   07C7 4F          	mov di, a						; destination is kernel stack
0257   07C8             ; restore SP
0258   07C8 7D          	dec a
0259   07C9 47          	mov sp, a
0260   07CA 38 14 00    	mov c, 20
0261   07CD FD F5       	rep movsb
0262   07CF             ; set VM process
0263   07CF 1D 2B 16    	mov al, [active_proc_index]
0264   07D2 01          	setptb
0265   07D3             		
0266   07D3 F2 E0 FF 00 	mov byte[_TIMER_C_0], 0				; load counter 0 low byte
0267   07D7 F2 E0 FF 10 	mov byte[_TIMER_C_0], $10				; load counter 0 high byte
0268   07DB             			
0269   07DB 4C          	popa
0270   07DC 06          	sysret
0271   07DD             
0272   07DD             int_7:
0273   07DD D7          	push a
0274   07DE DA          	push d
0275   07DF E1          	pushf
0276   07E0             			
0277   07E0 14 30 16    	mov a, [fifo_pi]
0278   07E3 3C          	mov d, a
0279   07E4             
0280   07E4 1D 80 FF    	mov al, [_UART0_DATA]	; get character
0281   07E7 B9 03       	cmp al, $03				; CTRL-C
0282   07E9 C6 06 08    	je CTRLC
0283   07EC B9 1A       	cmp al, $1A				; CTRL-Z
0284   07EE C6 0C 08    	je CTRLZ
0285   07F1 3E          	mov [d], al				; add to fifo
0286   07F2             	
0287   07F2 14 30 16    	mov a, [fifo_pi]
0288   07F5 77          	inc a
0289   07F6 AF DE 26    	cmp a, fifo + FIFO_SIZE 				; check if pointer reached the end of the fifo
0290   07F9 C7 FF 07    	jne int_7_continue
0291   07FC 10 DE 1E    	mov a, fifo	
0292   07FF             int_7_continue:	
0293   07FF 42 30 16    	mov [fifo_pi], a			; update fifo pointer
0294   0802             	
0295   0802 EE          	popf
0296   0803 E7          	pop d
0297   0804 E4          	pop a	
0298   0805 06          	sysret
0299   0806             
0300   0806             CTRLC:
0301   0806 EE          	popf
0302   0807 E7          	pop d
0303   0808 E4          	pop a
0304   0809 0A F3 14    	jmp cmd_terminate_proc
0305   080C             
0306   080C             CTRLZ:
0307   080C EE          	popf
0308   080D E7          	pop d
0309   080E E4          	pop a
0310   080F 0A 36 15    	jmp cmd_pause_proc		; pause current process and go back to the shell
0311   0812             
0312   0812             cmd_system_jmptbl:
0313   0812 1A 08       	.dw cmd_system_uname
0314   0814 21 08       	.dw cmd_system_whoami
0315   0816             
0316   0816             cmd_system:
0317   0816 FD 0A 12 08 	jmp [cmd_system_jmptbl + al]
0318   081A             cmd_system_uname:
0319   081A 3B 68 16    	mov d, s_uname
0320   081D 07 88 02    	call puts
0321   0820 06          	sysret
0322   0821             cmd_system_whoami:
0323   0821 3B 72 16    	mov d, s_root
0324   0824 07 88 02    	call puts
0325   0827 06          	sysret
0326   0828             
0327   0828             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0328   0828             ; REBOOT SYSTEM
0329   0828             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0330   0828             syscall_reboot:
0331   0828 FD D7 FF FF 	push word $FFFF 
0332   082C FD DB 00    	push byte %00000000				; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
0333   082F FD D7 C0 01 	push word BIOS_RESET_VECTOR		; and then push RESET VECTOR of the shell to the stack
0334   0833 06          	sysret
0335   0834             
0336   0834             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0337   0834             ;; switch to another process
0338   0834             ;; inputs:
0339   0834             ;; AL = new process number
0340   0834             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0341   0834             resume_proc:
0342   0834 FD 78       	mov g, a	; save the process number
0343   0836             ; save all registers into kernel stack
0344   0836 4B          	pusha
0345   0837 22 00       	mov ah, 0
0346   0839 1D 2B 16    	mov al, [active_proc_index]
0347   083C FD 99       	shl a							; x2
0348   083E B7 E9 15    	mov a, [proc_table_convert + a]	; get process state start index
0349   0841 4F          	mov di, a
0350   0842 48          	mov a, sp
0351   0843 77          	inc a
0352   0844 4D          	mov si, a
0353   0845 38 14 00    	mov c, 20
0354   0848 FD F5       	rep movsb					; save process state!
0355   084A             ; restore kernel stack position to point before interrupt arrived
0356   084A 51 14 00    	add sp, 20
0357   084D             ; now load the new process number!
0358   084D FD 12       	mov a, g						; retrieve the process number argument that was saved in the beginning
0359   084F 3D 2B 16    	mov [active_proc_index], al		; set new active proc
0360   0852             ; calculate LUT entry for next process
0361   0852 22 00       	mov ah, 0
0362   0854 FD 99       	shl a							; x2
0363   0856 B7 E9 15    	mov a, [proc_table_convert + a]		; get process state start index	
0364   0859             	
0365   0859 4D          	mov si, a						; source is proc state block
0366   085A 48          	mov a, sp
0367   085B 5F 13 00    	sub a, 19
0368   085E 4F          	mov di, a						; destination is kernel stack
0369   085F             ; restore SP
0370   085F 7D          	dec a
0371   0860 47          	mov sp, a
0372   0861 38 14 00    	mov c, 20
0373   0864 FD F5       	rep movsb
0374   0866             ; set VM process
0375   0866 1D 2B 16    	mov al, [active_proc_index]
0376   0869 01          	setptb
0377   086A             			
0378   086A 4C          	popa
0379   086B 06          	sysret
0380   086C             
0381   086C             
0382   086C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0383   086C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384   086C             list_procs:
0385   086C 3B 54 16    	mov d, s_ps_header
0386   086F 07 88 02    	call puts
0387   0872 3B CF 18    	mov d, proc_availab_table + 1
0388   0875 38 01 00    	mov c, 1
0389   0878             list_procs_L0:	
0390   0878 BD 01       	cmp byte[d], 1
0391   087A C7 9E 08    	jne list_procs_next
0392   087D 2D          	mov b, d
0393   087E 61 CE 18    	sub b, proc_availab_table
0394   0881 FD 9F 05    	shl b, 5
0395   0884 DA          	push d
0396   0885 D8          	push b
0397   0886 28          	mov b, c
0398   0887 07 28 03    	call print_u8x
0399   088A 22 20       	mov ah, ' '
0400   088C 07 4E 01    	call putchar
0401   088F 07 4E 01    	call putchar
0402   0892 E5          	pop b
0403   0893 74          	mov d, b
0404   0894 58 DE 18    	add d, proc_names
0405   0897 07 88 02    	call puts
0406   089A 07 35 02    	call printnl
0407   089D E7          	pop d
0408   089E             list_procs_next:
0409   089E 79          	inc d
0410   089F 78          	inc c
0411   08A0 C2 09 00    	cmp c, 9
0412   08A3 C7 78 08    	jne list_procs_L0
0413   08A6             list_procs_end:
0414   08A6 06          	sysret
0415   08A7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0416   08A7             ; PRIVILEGE EXCEPTION
0417   08A7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418   08A7             trap_privilege:
0419   08A7 0A 28 08    	jmp syscall_reboot
0420   08AA DA          	push d
0421   08AB             
0422   08AB 3B C0 16    	mov d, s_priviledge
0423   08AE 07 88 02    	call puts
0424   08B1             
0425   08B1 E7          	pop d
0426   08B2             	
0427   08B2 06          	sysret
0428   08B3             
0429   08B3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0430   08B3             ; BREAKPOINT EXCEPTION
0431   08B3             ; IMPORTANT: values in the stack are being pushed in big endian. i.e.: MSB at low address
0432   08B3             ; and LSB at high address. *** NEED TO CORRECT THIS IN THE MICROCODE and make it little endian again ***
0433   08B3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0434   08B3             trap_breakpoint:
0435   08B3 4B          	pusha
0436   08B4             trap_break_prompt:
0437   08B4 3B 6E 09    	mov d, s_break1
0438   08B7 07 88 02    	call puts
0439   08BA 07 35 02    	call printnl
0440   08BD 07 86 03    	call scan_u16d
0441   08C0 AF 00 00    	cmp a, 0
0442   08C3 C6 CE 08    	je trap_break_regs
0443   08C6 AF 01 00    	cmp a, 1
0444   08C9 C6 F1 08    	je trap_break_mem
0445   08CC             trap_break_end:	
0446   08CC 4C          	popa
0447   08CD 06          	sysret
0448   08CE             trap_break_regs:
0449   08CE 48          	mov a, sp
0450   08CF 53 0E 00    	add a, 14	; back-track 7 registers
0451   08D2 3C          	mov d, a
0452   08D3 3A 07       	mov cl, 7
0453   08D5             trap_regs_L0:
0454   08D5 2A          	mov b, [d]
0455   08D6 FD AB       	swp b
0456   08D8 07 E4 02    	call print_u16x	; print register value
0457   08DB 07 35 02    	call printnl
0458   08DE 63 02 00    	sub d, 2
0459   08E1 71 01       	sub cl, 1
0460   08E3 C3 00       	cmp cl, 0
0461   08E5 C7 D5 08    	jne trap_regs_L0
0462   08E8 0A B4 08    	jmp trap_break_prompt
0463   08EB 07 35 02    	call printnl
0464   08EE 0A B4 08    	jmp trap_break_prompt
0465   08F1             trap_break_mem:
0466   08F1 07 35 02    	call printnl
0467   08F4 07 06 03    	call scan_u16x
0468   08F7 4D          	mov si, a			; data source from user space
0469   08F8 FD 4F DE 26 	mov di, scrap_sector		; destination in kernel space
0470   08FC 38 00 02    	mov c, 512
0471   08FF 04          	load				; transfer data to kernel space!
0472   0900 3B DE 26    	mov d, scrap_sector		; dump pointer in d
0473   0903 38 00 00    	mov c, 0
0474   0906             dump_loop:
0475   0906 84          	mov al, cl
0476   0907 87 0F       	and al, $0F
0477   0909 C6 57 09    	jz print_base
0478   090C             back:
0479   090C 1E          	mov al, [d]				; read byte
0480   090D 2F          	mov bl, al
0481   090E 07 28 03    	call print_u8x
0482   0911 10 00 20    	mov a, $2000
0483   0914 05 03       	syscall sys_io			; space
0484   0916 84          	mov al, cl
0485   0917 87 0F       	and al, $0F
0486   0919 B9 0F       	cmp al, $0F
0487   091B C6 2C 09    	je print_ascii
0488   091E             back1:
0489   091E 79          	inc d
0490   091F 78          	inc c
0491   0920 C2 00 02    	cmp c, 512
0492   0923 C7 06 09    	jne dump_loop
0493   0926 07 35 02    	call printnl
0494   0929 0A B4 08    	jmp trap_break_prompt	; go to trap_breakpoint return point
0495   092C             print_ascii:
0496   092C 10 00 20    	mov a, $2000
0497   092F 05 03       	syscall sys_io
0498   0931 63 10 00    	sub d, 16
0499   0934 26 10 00    	mov b, 16
0500   0937             print_ascii_L:
0501   0937 79          	inc d
0502   0938 1E          	mov al, [d]				; read byte
0503   0939 B9 20       	cmp al, $20
0504   093B C8 43 09    	jlu dot
0505   093E B9 7E       	cmp al, $7E
0506   0940 D0 4B 09    	jleu ascii
0507   0943             dot:
0508   0943 10 00 2E    	mov a, $2E00
0509   0946 05 03       	syscall sys_io
0510   0948 0A 50 09    	jmp ascii_continue
0511   094B             ascii:
0512   094B 23          	mov ah, al
0513   094C 19 00       	mov al, 0
0514   094E 05 03       	syscall sys_io
0515   0950             ascii_continue:
0516   0950 FD A9 37 09 	loopb print_ascii_L
0517   0954 0A 1E 09    	jmp back1
0518   0957             print_base:
0519   0957 07 35 02    	call printnl
0520   095A 2D          	mov b, d
0521   095B 61 DE 26    	sub b, scrap_sector			; remove this later and fix address bases which display incorrectly
0522   095E 07 E4 02    	call print_u16x				; display row
0523   0961 10 00 3A    	mov a, $3A00
0524   0964 05 03       	syscall sys_io
0525   0966 10 00 20    	mov a, $2000
0526   0969 05 03       	syscall sys_io
0527   096B 0A 0C 09    	jmp back
0528   096E             
0529   096E 0A 44 65 62 s_break1:	.db "\nDebugger entry point.\n"
0529   0972 75 67 67 65 
0529   0976 72 20 65 6E 
0529   097A 74 72 79 20 
0529   097E 70 6F 69 6E 
0529   0982 74 2E 0A 
0530   0985 30 2E 20 53 			.db "0. Show Registers\n"
0530   0989 68 6F 77 20 
0530   098D 52 65 67 69 
0530   0991 73 74 65 72 
0530   0995 73 0A 
0531   0997 31 2E 20 53 			.db "1. Show 512B RAM block\n"
0531   099B 68 6F 77 20 
0531   099F 35 31 32 42 
0531   09A3 20 52 41 4D 
0531   09A7 20 62 6C 6F 
0531   09AB 63 6B 0A 
0532   09AE 32 2E 20 43 			.db "2. Continue Execution", 0
0532   09B2 6F 6E 74 69 
0532   09B6 6E 75 65 20 
0532   09BA 45 78 65 63 
0532   09BE 75 74 69 6F 
0532   09C2 6E 00 
0533   09C4             
0534   09C4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535   09C4             ; DIVIDE BY ZERO EXCEPTION
0536   09C4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0537   09C4             trap_div_zero:
0538   09C4 D7          	push a
0539   09C5 DA          	push d
0540   09C6 E1          	pushf
0541   09C7             		
0542   09C7 3B E8 16    	mov d, s_divzero
0543   09CA 07 88 02    	call puts
0544   09CD             	
0545   09CD EE          	popf
0546   09CE E7          	pop d
0547   09CF E4          	pop a
0548   09D0             							; enable interrupts
0549   09D0 06          	sysret
0550   09D1             
0551   09D1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0552   09D1             ; UNDEFINED OPCODE EXCEPTION
0553   09D1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0554   09D1             undefined_opcode:
0555   09D1 06          	sysret
0556   09D2             
0557   09D2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0558   09D2             ; RTC SERVICES INTERRUPT
0559   09D2             ; RTC I/O bank = FFA0 to FFAF
0560   09D2             ; FFA0 to FFA7 is scratch RAM
0561   09D2             ; control register at $FFA8 [ W | R | S | Cal4..Cal0 ]
0562   09D2             ; al = 0..6 -> get
0563   09D2             ; al = 7..D -> set
0564   09D2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0565   09D2             rtc_services:
0566   09D2 DB          	push al
0567   09D3 DA          	push d
0568   09D4 B9 06       	cmp al, 6
0569   09D6 D1 EB 09    	jgu rtc_set
0570   09D9             rtc_get:
0571   09D9 6A A9       	add al, $A9			; generate RTC address to get to address A9 of clock
0572   09DB 22 FF       	mov ah, $FF		
0573   09DD 3C          	mov d, a				; get to FFA9 + offset
0574   09DE F2 A8 FF 40 	mov byte[$FFA8], $40		; set R bit to 1
0575   09E2 1E          	mov al, [d]			; get data
0576   09E3 F2 A8 FF 00 	mov byte[$FFA8], 0		; reset R bit
0577   09E7 23          	mov ah, al
0578   09E8 E7          	pop d
0579   09E9 E8          	pop al
0580   09EA 06          	sysret
0581   09EB             rtc_set:
0582   09EB DD          	push bl
0583   09EC 99          	mov bl, ah		; set data asIDE
0584   09ED 6A A2       	add al, $A2		; generate RTC address to get to address A9 of clock
0585   09EF 22 FF       	mov ah, $FF		
0586   09F1 3C          	mov d, a		; get to FFA9 + offset
0587   09F2 1B          	mov al, bl		; get data back
0588   09F3 F2 A8 FF 80 	mov byte[$FFA8], $80	; set W bit to 1
0589   09F7 3E          	mov [d], al		; set data
0590   09F8 F2 A8 FF 00 	mov byte[$FFA8], 0		; reset write bit
0591   09FC EA          	pop bl
0592   09FD E7          	pop d
0593   09FE E8          	pop al
0594   09FF 06          	sysret
0595   0A00             
0596   0A00             datetime_serv_tbl:
0597   0A00 08 0A       	.dw print_date
0598   0A02 7C 0A       	.dw set_date
0599   0A04             datetime_services:
0600   0A04 FD 0A 00 0A 	jmp [datetime_serv_tbl + al]			
0601   0A08             print_date:
0602   0A08 10 00 0D    	mov a, $0D00				; print carriage return char
0603   0A0B 19 03       	mov al, 3
0604   0A0D 05 01       	syscall sys_rtc				; get week
0605   0A0F 1A          	mov al, ah
0606   0A10 22 00       	mov ah, 0
0607   0A12 FD 9D 02    	shl a, 2					
0608   0A15 3B 72 17    	mov d, s_week
0609   0A18 59          	add d, a
0610   0A19 07 88 02    	call puts
0611   0A1C 10 00 20    	mov a, $2000
0612   0A1F 05 03       	syscall sys_io					; display ' '
0613   0A21             	
0614   0A21 19 04       	mov al, 4
0615   0A23 05 01       	syscall sys_rtc					; get day
0616   0A25 99          	mov bl, ah
0617   0A26 07 28 03    	call print_u8x
0618   0A29 10 00 20    	mov a, $2000
0619   0A2C 05 03       	syscall sys_io					; display ' '
0620   0A2E             ; there is a problem with the month displaying
0621   0A2E             ; the month is stored as BCD. so when retrieving the month, the value will be in binary
0622   0A2E             ; even though it is to be understood as BCD.
0623   0A2E             ; when retrieving the value and adding the string table address offset the value will go overboard!	
0624   0A2E 19 05       	mov al, 05
0625   0A30 05 01       	syscall sys_rtc				; get month
0626   0A32 1A          	mov al, ah
0627   0A33 22 00       	mov ah, 0
0628   0A35 FD 9D 02    	shl a, 2					
0629   0A38 3B 3E 17    	mov d, s_months
0630   0A3B 59          	add d, a
0631   0A3C 07 88 02    	call puts
0632   0A3F             	
0633   0A3F 10 00 20    	mov a, $2000
0634   0A42 05 03       	syscall sys_io			; display ' '
0635   0A44             	
0636   0A44 2E 20       	mov bl, $20
0637   0A46 07 28 03    	call print_u8x			; print 20 for year prefix
0638   0A49 19 06       	mov al, 06
0639   0A4B 05 01       	syscall sys_rtc					; get year
0640   0A4D 99          	mov bl, ah
0641   0A4E 07 28 03    	call print_u8x
0642   0A51             	
0643   0A51 10 00 20    	mov a, $2000	
0644   0A54 05 03       	syscall sys_io			; display ' '
0645   0A56             
0646   0A56 19 02       	mov al, 2
0647   0A58 05 01       	syscall sys_rtc					; get hours
0648   0A5A 99          	mov bl, ah
0649   0A5B 07 28 03    	call print_u8x
0650   0A5E 10 00 3A    	mov a, $3A00		
0651   0A61 05 03       	syscall sys_io				; display ':'
0652   0A63             
0653   0A63 19 01       	mov al, 01
0654   0A65 05 01       	syscall sys_rtc					; get minutes
0655   0A67 99          	mov bl, ah
0656   0A68 07 28 03    	call print_u8x
0657   0A6B 10 00 3A    	mov a, $3A00	
0658   0A6E 05 03       	syscall sys_io			; display ':'
0659   0A70             
0660   0A70 19 00       	mov al, 0
0661   0A72 05 01       	syscall sys_rtc					; get seconds
0662   0A74 99          	mov bl, ah
0663   0A75 07 28 03    	call print_u8x
0664   0A78             	
0665   0A78 07 35 02    	call printnl
0666   0A7B 06          	sysret
0667   0A7C             	
0668   0A7C             set_date:
0669   0A7C 3B 03 17    	mov d, s_set_year
0670   0A7F 07 88 02    	call puts
0671   0A82 07 6F 03    	call scan_u8x				; read integer into A
0672   0A85 FD 9D 08    	shl a, 8				; only AL used, move to AH
0673   0A88 19 0D       	mov al, 0Dh				; set RTC year
0674   0A8A 05 01       	syscall sys_rtc					; set RTC
0675   0A8C             	
0676   0A8C 3B 0A 17    	mov d, s_set_month
0677   0A8F 07 88 02    	call puts
0678   0A92 07 6F 03    	call scan_u8x					; read integer into A
0679   0A95 FD 9D 08    	shl a, 8				; only AL used, move to AH
0680   0A98 19 0C       	mov al, 0Ch				; set RTC month
0681   0A9A 05 01       	syscall sys_rtc					; set RTC
0682   0A9C             
0683   0A9C 3B 12 17    	mov d, s_set_day
0684   0A9F 07 88 02    	call puts
0685   0AA2 07 6F 03    	call scan_u8x					; read integer into A
0686   0AA5 FD 9D 08    	shl a, 8				; only AL used, move to AH
0687   0AA8 19 0B       	mov al, 0Bh				; set RTC month
0688   0AAA 05 01       	syscall sys_rtc					; set RTC
0689   0AAC             
0690   0AAC 3B 18 17    	mov d, s_set_week
0691   0AAF 07 88 02    	call puts
0692   0AB2 07 6F 03    	call scan_u8x					; read integer into A
0693   0AB5 FD 9D 08    	shl a, 8				; only AL used, move to AH
0694   0AB8 19 0A       	mov al, 0Ah				; set RTC month
0695   0ABA 05 01       	syscall sys_rtc					; set RTC
0696   0ABC             
0697   0ABC 3B 22 17    	mov d, s_set_hours
0698   0ABF 07 88 02    	call puts
0699   0AC2 07 6F 03    	call scan_u8x					; read integer into A
0700   0AC5 FD 9D 08    	shl a, 8				; only AL used, move to AH
0701   0AC8 19 09       	mov al, 09h				; set RTC month
0702   0ACA 05 01       	syscall sys_rtc					; set RTC
0703   0ACC             
0704   0ACC 3B 2A 17    	mov d, s_set_minutes
0705   0ACF 07 88 02    	call puts
0706   0AD2 07 6F 03    	call scan_u8x					; read integer into A
0707   0AD5 FD 9D 08    	shl a, 8				; only AL used, move to AH
0708   0AD8 19 08       	mov al, 08h				; set RTC month
0709   0ADA 05 01       	syscall sys_rtc					; set RTC
0710   0ADC             
0711   0ADC 3B 34 17    	mov d, s_set_seconds
0712   0ADF 07 88 02    	call puts
0713   0AE2 07 6F 03    	call scan_u8x					; read integer into A
0714   0AE5 FD 9D 08    	shl a, 8					; only AL used, move to AH
0715   0AE8 19 07       	mov al, 07h				; set RTC month
0716   0AEA 05 01       	syscall sys_rtc					; set RTC
0717   0AEC 06          	sysret
0718   0AED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0719   0AED             ; IDE SERVICES INTERRUPT
0720   0AED             ; al = option
0721   0AED             ; 0 = IDE reset, 1 = IDE sleep, 2 = read sector, 3 = write sector
0722   0AED             ; IDE read/write sector
0723   0AED             ; 512 bytes
0724   0AED             ; user buffer pointer in D
0725   0AED             ; AH = number of sectors
0726   0AED             ; CB = LBA bytes 3..0
0727   0AED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0728   0AED             IDE_serv_tbl:
0729   0AED F9 0A       	.dw IDE_reset
0730   0AEF 0D 0B       	.dw IDE_sleep
0731   0AF1 1C 0B       	.dw IDE_read_sect_wrapper
0732   0AF3 20 0B       	.dw IDE_write_sect_wrapper
0733   0AF5             IDE_services_kernel:
0734   0AF5 FD 0A ED 0A 	jmp [IDE_serv_tbl + al]		
0735   0AF9             	
0736   0AF9             IDE_reset:			
0737   0AF9 F2 D7 FF 04 	mov byte[_IDE_R7], 4		; RESET IDE
0738   0AFD 07 A6 0B    	call IDE_wait				; wait for IDE ready			 			
0739   0B00 F2 D6 FF E0 	mov byte[_IDE_R6], $E0		; LBA3= 0, MASTER, MODE= LBA				
0740   0B04 F2 D1 FF 01 	mov byte[_IDE_R1], 1		; 8-BIT TRANSFERS			
0741   0B08 F2 D7 FF EF 	mov byte[_IDE_R7], $EF		; SET FEATURE COMMAND
0742   0B0C 06          	sysret
0743   0B0D             IDE_sleep:
0744   0B0D 07 A6 0B    	call IDE_wait					; wait for IDE ready			 			
0745   0B10 F2 D6 FF 40 	mov byte [_IDE_R6], %01000000	; lba[3:0](reserved), bit 6=1
0746   0B14 F2 D7 FF E6 	mov byte [_IDE_R7], $E6		; sleep command
0747   0B18 07 A6 0B    	call IDE_wait					; wait for IDE ready
0748   0B1B 06          	sysret
0749   0B1C             IDE_read_sect_wrapper:
0750   0B1C 07 24 0B    	call IDE_read_sect
0751   0B1F 06          	sysret
0752   0B20             IDE_write_sect_wrapper:
0753   0B20 07 4A 0B    	call IDE_write_sect
0754   0B23 06          	sysret
0755   0B24             IDE_read_sect:
0756   0B24 1A          	mov al, ah
0757   0B25 24          	mov ah, bl
0758   0B26 42 D2 FF    	mov [_IDE_R2], a			; number of sectors (0..255)
0759   0B29 1C          	mov al, bh
0760   0B2A 3D D4 FF    	mov [_IDE_R4], al
0761   0B2D 12          	mov a, c
0762   0B2E 3D D5 FF    	mov [_IDE_R5], al
0763   0B31 1A          	mov al, ah
0764   0B32 87 0F       	and al, %00001111
0765   0B34 8B E0       	or al, %11100000			; mode lba, master
0766   0B36 3D D6 FF    	mov [_IDE_R6], al
0767   0B39             IDE_read_sect_wait:
0768   0B39 1D D7 FF    	mov al, [_IDE_R7]	
0769   0B3C 87 80       	and al, $80				; BUSY FLAG
0770   0B3E C7 39 0B    	jnz IDE_read_sect_wait
0771   0B41 19 20       	mov al, $20
0772   0B43 3D D7 FF    	mov [_IDE_R7], al			; read sector cmd
0773   0B46 07 70 0B    	call IDE_read	
0774   0B49 09          	ret
0775   0B4A             IDE_write_sect:
0776   0B4A 1A          	mov al, ah
0777   0B4B 24          	mov ah, bl
0778   0B4C 42 D2 FF    	mov [_IDE_R2], a			; number of sectors (0..255)
0779   0B4F 1C          	mov al, bh
0780   0B50 3D D4 FF    	mov [_IDE_R4], al
0781   0B53 12          	mov a, c
0782   0B54 3D D5 FF    	mov [_IDE_R5], al
0783   0B57 1A          	mov al, ah
0784   0B58 87 0F       	and al, %00001111
0785   0B5A 8B E0       	or al, %11100000			; mode lba, master
0786   0B5C 3D D6 FF    	mov [_IDE_R6], al
0787   0B5F             IDE_write_sect_wait:
0788   0B5F 1D D7 FF    	mov al, [_IDE_R7]	
0789   0B62 87 80       	and al, $80				; BUSY FLAG
0790   0B64 C7 5F 0B    	jnz IDE_write_sect_wait
0791   0B67 19 30       	mov al, $30
0792   0B69 3D D7 FF    	mov [_IDE_R7], al			; write sector cmd
0793   0B6C 07 8B 0B    	call IDE_write			
0794   0B6F 09          	ret
0795   0B70             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0796   0B70             ; READ IDE DATA
0797   0B70             ; pointer in D
0798   0B70             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0799   0B70             IDE_read:
0800   0B70 DA          	push d
0801   0B71             IDE_read_loop:
0802   0B71 1D D7 FF    	mov al, [_IDE_R7]	
0803   0B74 87 80       	and al, 80h				; BUSY FLAG
0804   0B76 C7 71 0B    	jnz IDE_read_loop			; wait loop
0805   0B79             	
0806   0B79 1D D7 FF    	mov al, [_IDE_R7]
0807   0B7C 87 08       	and al, %00001000			; DRQ FLAG
0808   0B7E C6 89 0B    	jz IDE_read_end
0809   0B81 1D D0 FF    	mov al, [_IDE_R0]
0810   0B84 3E          	mov [d], al
0811   0B85 79          	inc d
0812   0B86 0A 71 0B    	jmp IDE_read_loop
0813   0B89             IDE_read_end:
0814   0B89 E7          	pop d
0815   0B8A 09          	ret
0816   0B8B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0817   0B8B             ; WRITE IDE DATA
0818   0B8B             ; data pointer in D
0819   0B8B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0820   0B8B             IDE_write:
0821   0B8B DA          	push d
0822   0B8C             IDE_write_loop:
0823   0B8C 1D D7 FF    	mov al, [_IDE_R7]	
0824   0B8F 87 80       	and al, 80h				; BUSY FLAG
0825   0B91 C7 8C 0B    	jnz IDE_write_loop			; wait loop
0826   0B94             	
0827   0B94 1D D7 FF    	mov al, [_IDE_R7]
0828   0B97 87 08       	and al, %00001000			; DRQ FLAG
0829   0B99 C6 A4 0B    	jz IDE_write_end
0830   0B9C 1E          	mov al, [d]
0831   0B9D 3D D0 FF    	mov [_IDE_R0], al
0832   0BA0 79          	inc d 
0833   0BA1 0A 8C 0B    	jmp IDE_write_loop
0834   0BA4             IDE_write_end:
0835   0BA4 E7          	pop d
0836   0BA5 09          	ret
0837   0BA6             
0838   0BA6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0839   0BA6             ; wait for IDE to be ready
0840   0BA6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0841   0BA6             IDE_wait:
0842   0BA6 1D D7 FF    	mov al, [_IDE_R7]	
0843   0BA9 87 80       	and al, 80h				; BUSY FLAG
0844   0BAB C7 A6 0B    	jnz IDE_wait
0845   0BAE 09          	ret
0846   0BAF             
0847   0BAF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0848   0BAF             ; i/o interrupt
0849   0BAF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0850   0BAF             io_services_jmp:
0851   0BAF D2 0B       	.dw io_putchar
0852   0BB1 DF 0B       	.dw io_getchar
0853   0BB3 B9 0B       	.dw io_uart_init
0854   0BB5             
0855   0BB5             io_services:
0856   0BB5 FD 0A AF 0B 	jmp [io_services_jmp + al]
0857   0BB9             io_uart_init:
0858   0BB9 F2 83 FF 83 	mov byte[_UART0_LCR], $83			; 8 data, 1 stop, no parity	, divisor latch = 1, UART address 3 = Line Control Register
0859   0BBD F2 80 FF 03 	mov byte[_UART0_DLAB_0], 3			; baud = 38400, divisor latch low byte = 3
0860   0BC1 F2 81 FF 00 	mov byte[_UART0_DLAB_1], 0			; divisor latch high byte = 0			
0861   0BC5 F2 83 FF 03 	mov byte[_UART0_LCR], 3			; UART address 3 = Line Control Register
0862   0BC9 F2 81 FF 01 	mov byte[_UART0_IER], 1			; enable interrupt: receive data available
0863   0BCD F2 82 FF 00 	mov byte[_UART0_FCR], 0			; disable FIFO
0864   0BD1 06          	sysret
0865   0BD2             ; char in ah
0866   0BD2             io_putchar:
0867   0BD2             io_putchar_L0:
0868   0BD2 1D 85 FF    	mov al, [_UART0_LSR]			; read Line Status Register
0869   0BD5 93 20       	test al, $20					; isolate Transmitter Empty
0870   0BD7 C6 D2 0B    	jz io_putchar_L0		
0871   0BDA 1A          	mov al, ah
0872   0BDB 3D 80 FF    	mov [_UART0_DATA], al			; write char to Transmitter Holding Register
0873   0BDE 06          	sysret
0874   0BDF             ; char in ah
0875   0BDF             ; al = sucess code
0876   0BDF             io_getchar:
0877   0BDF D8          	push b
0878   0BE0 DA          	push d
0879   0BE1             io_getchar_L0:	
0880   0BE1 14 32 16    	mov a, [fifo_pr]
0881   0BE4 29 30 16    	mov b, [fifo_pi]
0882   0BE7 B0          	cmp a, b
0883   0BE8 C6 10 0C    	je io_getchar_fail
0884   0BEB             	
0885   0BEB 3C          	mov d, a
0886   0BEC 1E          	mov al, [d]
0887   0BED DB          	push al
0888   0BEE             	
0889   0BEE 14 32 16    	mov a, [fifo_pr]
0890   0BF1 77          	inc a
0891   0BF2 AF DE 26    	cmp a, fifo + FIFO_SIZE				; check if pointer reached the end of the fifo
0892   0BF5 C7 FB 0B    	jne io_getchar_cont
0893   0BF8 10 DE 1E    	mov a, fifo	
0894   0BFB             io_getchar_cont:	
0895   0BFB 42 32 16    	mov [fifo_pr], a			; update fifo pointer
0896   0BFE             	
0897   0BFE E9          	pop ah
0898   0BFF             ; here we just echo the char back to the console
0899   0BFF             io_getchar_echo_L0:
0900   0BFF 1D 85 FF    	mov al, [_UART0_LSR]			; read Line Status Register
0901   0C02 93 20       	test al, $20					; isolate Transmitter Empty
0902   0C04 C6 FF 0B    	jz io_getchar_echo_L0
0903   0C07 1A          	mov al, ah
0904   0C08 3D 80 FF    	mov [_UART0_DATA], al			; write char to Transmitter Holding Register
0905   0C0B             
0906   0C0B 19 01       	mov al, 1		; AL = 1 means a char successfully received
0907   0C0D E7          	pop d
0908   0C0E E5          	pop b
0909   0C0F 06          	sysret
0910   0C10             io_getchar_fail:
0911   0C10 E7          	pop d
0912   0C11 E5          	pop b
0913   0C12 19 00       	mov al, 0			; AL = 0 means no char received
0914   0C14 06          	sysret
0915   0C15             
0916   0C15             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0917   0C15             ;; FILE SYSTEM DATA
0918   0C15             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0919   0C15             ; infor for : IDE SERVICES INTERRUPT
0920   0C15             ; IDE read/write 512-byte sector
0921   0C15             ; al = option
0922   0C15             ; user buffer pointer in D
0923   0C15             ; AH = number of sectors
0924   0C15             ; CB = LBA bytes 3..0	
0925   0C15             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0926   0C15             ;; FILE SYSTEM DATA STRUCTURE
0927   0C15             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0928   0C15             ; for a directory we have the header first, followed by metadata
0929   0C15             ; header 1 sector (512 bytes)
0930   0C15             ; metadata 1 sector (512 bytes)
0931   0C15             ; HEADER ENTRIES:
0932   0C15             ; filename (64)
0933   0C15             ; parent dir LBA (2) -  to be used for faster backwards navigation...
0934   0C15             ;
0935   0C15             ; metadata entries:
0936   0C15             ; filename (24)
0937   0C15             ; attributes (1)	|_|_|file_type(3bits)|x|w|r| types: file, directory, character device
0938   0C15             ; LBA (2)
0939   0C15             ; size (2)
0940   0C15             ; day (1)
0941   0C15             ; month (1)
0942   0C15             ; year (1)
0943   0C15             ; packet size = 32 bytes
0944   0C15             ;
0945   0C15             ; first directory on disk is the root directory '/'
0946   0C15             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0947   0C15             ;; FILE SYSTEM DISK FORMATTING
0948   0C15             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0949   0C15             ; writes FST_TOTAL_SECTORS + FS_NBR_FILES disk sectors  with 0's
0950   0C15             ; this is the file system table formating
0951   0C15             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0952   0C15             file_system_jmptbl:
0953   0C15 45 0C       	.dw file_system_mkfs
0954   0C17 F0 0C       	.dw cmd_fs_space
0955   0C19 F1 0C       	.dw cmd_mkdir
0956   0C1B 6A 10       	.dw cmd_cd
0957   0C1D 6F 10       	.dw cmd_ls
0958   0C1F 58 11       	.dw cmd_mktxt
0959   0C21 D9 11       	.dw cmd_mkbin
0960   0C23 96 12       	.dw cmd_pwd
0961   0C25 04 13       	.dw cmd_cat
0962   0C27 60 13       	.dw cmd_rmdir					; 9
0963   0C29 BC 13       	.dw cmd_rm
0964   0C2B 00 00       	.dw 0
0965   0C2D 00 00       	.dw 0
0966   0C2F 00 00       	.dw 0							; 13
0967   0C31 74 0C       	.dw fileio_chmod				; 14
0968   0C33 24 14       	.dw cmd_mv						; 15
0969   0C35 6D 0C       	.dw cd_goto_root				; 16
0970   0C37 66 10       	.dw get_current_dirID			; 17
0971   0C39 42 0E       	.dw get_path_from_dirID			; 18
0972   0C3B A8 0E       	.dw get_dirID_from_path_user	; 19
0973   0C3D C2 0F       	.dw loadfile_from_path_user		; 20	
0974   0C3F 32 0F       	.dw file_exists_by_path_user	; 21
0975   0C41             file_system:
0976   0C41 FD 0A 15 0C 	jmp [file_system_jmptbl + al]
0977   0C45             
0978   0C45             file_system_mkfs:	
0979   0C45 FD 4F DE 28 	mov di, transient_area
0980   0C49 19 00       	mov al, 0
0981   0C4B 38 00 02    	mov c, 512
0982   0C4E FD F7       	rep stosb
0983   0C50 26 20 00    	mov b, FST_LBA_START
0984   0C53 38 00 00    	mov c, 0				; reset LBA to 0
0985   0C56             file_system_mkfs_L1:	
0986   0C56 22 01       	mov ah, $01			; one sect
0987   0C58 3B DE 28    	mov d, transient_area
0988   0C5B 07 4A 0B    	call IDE_write_sect
0989   0C5E FD 77       	inc b
0990   0C60 C0 00 08    	cmp b, CF_CARD_LBA_SIZE
0991   0C63 C7 56 0C    	jne file_system_mkfs_L1
0992   0C66             file_system_mkfs_create_root:
0993   0C66 10 20 00    	mov a, ROOT_dirID
0994   0C69 42 34 16    	mov [current_dirID], a		; set current directory LBA to ROOT
0995   0C6C 06          	sysret	
0996   0C6D             	
0997   0C6D             cd_goto_root:
0998   0C6D 10 20 00    	mov a, ROOT_dirID
0999   0C70 42 34 16    	mov [current_dirID], a		; set current directory LBA to ROOT
1000   0C73 06          	sysret	
1001   0C74             
1002   0C74             ; filename in D (userspace data)
1003   0C74             ; permission in BL
1004   0C74             fileio_chmod:
1005   0C74 DD          	push bl
1006   0C75 FD 4E       	mov si, d
1007   0C77 FD 4F DE 1C 	mov di, temp_data
1008   0C7B 38 80 00    	mov c, 128
1009   0C7E 04          	load					; load filename from user-space
1010   0C7F             		
1011   0C7F 14 34 16    	mov a, [current_dirID]
1012   0C82 77          	inc a				; metadata sector
1013   0C83 27          	mov b, a
1014   0C84 38 00 00    	mov c, 0				; reset LBA to 0
1015   0C87 22 01       	mov ah, $01			; disk read
1016   0C89 3B DE 28    	mov d, transient_area
1017   0C8C 07 24 0B    	call IDE_read_sect		; read directory
1018   0C8F FD 10       	cla
1019   0C91 42 2C 16    	mov [index], a		; reset file counter
1020   0C94             fileio_chmod_L1:
1021   0C94 FD 4E       	mov si, d
1022   0C96 FD 4F DE 1C 	mov di, temp_data
1023   0C9A 07 93 00    	call strcmp
1024   0C9D C6 B4 0C    	je fileio_chmod_found_entry
1025   0CA0             
1026   0CA0 58 20 00    	add d, 32
1027   0CA3 14 2C 16    	mov a, [index]
1028   0CA6 77          	inc a
1029   0CA7 42 2C 16    	mov [index], a
1030   0CAA AF 10 00    	cmp a, FST_FILES_PER_DIR
1031   0CAD C7 94 0C    	jne fileio_chmod_L1
1032   0CB0 EA          	pop bl
1033   0CB1 0A CD 0C    	jmp fileio_chmod_not_found
1034   0CB4             fileio_chmod_found_entry:	
1035   0CB4 FD 79       	mov g, b					; save LBA
1036   0CB6 EA          	pop bl						; retrieve saved permission value
1037   0CB7 1F 18 00    	mov al, [d + 24]			; read file permissions
1038   0CBA 87 F8       	and al, %11111000			; remove all permissions, keep other flags
1039   0CBC 8C          	or al, bl					; set new permissions
1040   0CBD 3F 18 00    	mov [d + 24], al			; write new permissions
1041   0CC0 38 00 00    	mov c, 0
1042   0CC3 3B DE 28    	mov d, transient_area
1043   0CC6 22 01       	mov ah, $01				; disk write 1 sect
1044   0CC8 FD 27       	mov b, g					; retrieve LBA
1045   0CCA 07 4A 0B    	call IDE_write_sect		; write sector
1046   0CCD             fileio_chmod_not_found:
1047   0CCD 06          	sysret
1048   0CCE             
1049   0CCE             ;; bootloader installer
1050   0CCE             ;; kernel LBA address in A
1051   0CCE             cmd_boot_installer:
1052   0CCE D7          	push a
1053   0CCF 26 00 00    	mov b, 0
1054   0CD2 38 00 00    	mov c, 0
1055   0CD5 22 01       	mov ah, $01				; 1 sector
1056   0CD7 3B DE 28    	mov d, transient_area
1057   0CDA 07 24 0B    	call IDE_read_sect			; read sector
1058   0CDD             	
1059   0CDD E4          	pop a
1060   0CDE 44 FE 01    	mov [d + 510], a		; update LBA address
1061   0CE1 26 00 00    	mov b, 0
1062   0CE4 38 00 00    	mov c, 0
1063   0CE7 22 01       	mov ah, $01				; 1 sector
1064   0CE9 3B DE 28    	mov d, transient_area
1065   0CEC 07 4A 0B    	call IDE_write_sect		; write sector
1066   0CEF             	
1067   0CEF 06          	sysret
1068   0CF0             
1069   0CF0             cmd_fs_space:
1070   0CF0 06          	sysret
1071   0CF1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1072   0CF1             ;; CREATE NEW DIRECTORY
1073   0CF1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1074   0CF1             ; search list for NULL name entry. add new directory to list
1075   0CF1             cmd_mkdir:
1076   0CF1 FD 4E       	mov si, d
1077   0CF3 FD 4F DE 1C 	mov di, temp_data
1078   0CF7 38 00 02    	mov c, 512
1079   0CFA 04          	load						; load data from user-space
1080   0CFB 26 22 00    	mov b, FST_LBA_START + 2 	; start at 2 because LBA  0 is ROOT (this would also cause issues 								
1081   0CFE             								; when checking for NULL name, since root has a NULL name)
1082   0CFE 38 00 00    	mov c, 0					; reset LBA to 0
1083   0D01             cmd_mkdir_L1:	
1084   0D01 22 01       	mov ah, $01			; disk read
1085   0D03 3B DE 28    	mov d, transient_area
1086   0D06 07 24 0B    	call IDE_read_sect		; read sector
1087   0D09 BD 00       	cmp byte[d], 0			; check for NULL
1088   0D0B C6 14 0D    	je cmd_mkdir_found_null
1089   0D0E 55 02 00    	add b, FST_SECTORS_PER_DIR					; skip directory
1090   0D11 0A 01 0D    	jmp cmd_mkdir_L1
1091   0D14             cmd_mkdir_found_null:
1092   0D14             ;create header file by grabbing dir name from parameter
1093   0D14 D8          	push b				; save new directory's LBA
1094   0D15 38 40 00    	mov c, 64
1095   0D18 FD 4D DE 1C 	mov si, temp_data
1096   0D1C FD 4F DE 28 	mov di, transient_area
1097   0D20 FD F5       	rep movsb					; copy dirname from temp_data to transient_area
1098   0D22 14 34 16    	mov a, [current_dirID]
1099   0D25 42 1E 29    	mov [transient_area + 64], a		; store parent directory LBA
1100   0D28 19 00       	mov al, 0
1101   0D2A FD 4F DE 2A 	mov di, transient_area + 512
1102   0D2E 38 00 02    	mov c, 512
1103   0D31 FD F7       	rep stosb					; clean buffer
1104   0D33 38 00 00    	mov c, 0				; reset LBA(c) to 0
1105   0D36             ; write directory entry sectors
1106   0D36 3B DE 28    	mov d, transient_area
1107   0D39 22 02       	mov ah, $02			; disk write, 2 sectors
1108   0D3B 07 4A 0B    	call IDE_write_sect		; write sector
1109   0D3E             ; now we need to add the new directory to the list, insIDE the current directory
1110   0D3E 14 34 16    	mov a, [current_dirID]
1111   0D41 53 01 00    	add a, 1
1112   0D44 27          	mov b, a					; metadata sector
1113   0D45 38 00 00    	mov c, 0
1114   0D48 FD 79       	mov g, b					; save LBA
1115   0D4A 3B DE 28    	mov d, transient_area
1116   0D4D 22 01       	mov ah, $01			; disk read
1117   0D4F 07 24 0B    	call IDE_read_sect		; read metadata sector
1118   0D52             cmd_mkdir_L2:
1119   0D52 BD 00       	cmp byte[d], 0
1120   0D54 C6 5D 0D    	je cmd_mkdir_found_null2
1121   0D57 58 20 00    	add d, FST_ENTRY_SIZE
1122   0D5A 0A 52 0D    	jmp cmd_mkdir_L2					; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1123   0D5D             cmd_mkdir_found_null2:
1124   0D5D FD 4D DE 1C 	mov si, temp_data
1125   0D61 FD 50       	mov di, d
1126   0D63 07 A8 00    	call strcpy			; copy directory name
1127   0D66 58 18 00    	add d, 24			; goto ATTRIBUTES
1128   0D69 19 0B       	mov al, %00001011		;directory, no execute, write, read
1129   0D6B 3E          	mov [d], al			
1130   0D6C 79          	inc d
1131   0D6D E5          	pop b
1132   0D6E D8          	push b				; push LBA back
1133   0D6F FD 43       	mov [d], b			; save LBA
1134   0D71             ; set file creation date	
1135   0D71 58 04 00    	add d, 4
1136   0D74 19 04       	mov al, 4
1137   0D76 05 01       	syscall sys_rtc
1138   0D78 1A          	mov al, ah
1139   0D79 3E          	mov [d], al			; set day
1140   0D7A 79          	inc d
1141   0D7B 19 05       	mov al, 5
1142   0D7D 05 01       	syscall sys_rtc
1143   0D7F 1A          	mov al, ah
1144   0D80 3E          	mov [d], al			; set month
1145   0D81 79          	inc d
1146   0D82 19 06       	mov al, 6
1147   0D84 05 01       	syscall sys_rtc
1148   0D86 1A          	mov al, ah
1149   0D87 3E          	mov [d], al			; set year
1150   0D88             ; write sector into disk for new directory entry
1151   0D88 FD 27       	mov b, g
1152   0D8A 38 00 00    	mov c, 0
1153   0D8D 3B DE 28    	mov d, transient_area
1154   0D90 22 01       	mov ah, $01			; disk write, 1 sector
1155   0D92 07 4A 0B    	call IDE_write_sect		; write sector
1156   0D95             
1157   0D95             ; after adding the new directory's information to its parent directory's list
1158   0D95             ; we need to now enter the new directory, and to it add two new directories!
1159   0D95             ; which directories do we need to add ? '..' and '.' are the directories needed.
1160   0D95             ; importantly, note that these two new directories are only entries in the list
1161   0D95             ; and do not have actual physical entries in the disk as real directories.
1162   0D95             ; i.e. they only exist as list entries in the new directory created so that
1163   0D95             ; the new directory can reference its parent and itself
1164   0D95             ;
1165   0D95             ; we need to add both '..' and '.'
1166   0D95             ; this first section is for '..' and on the section below we do the same for '.'
1167   0D95 E4          	pop a						; retrieve the new directory's LBA	
1168   0D96 D7          	push a						; and save again
1169   0D97 53 01 00    	add a, 1
1170   0D9A 27          	mov b, a					; metadata sector
1171   0D9B 38 00 00    	mov c, 0
1172   0D9E FD 79       	mov g, b					; save LBA
1173   0DA0 3B DE 28    	mov d, transient_area
1174   0DA3 22 01       	mov ah, $01			; disk read
1175   0DA5 07 24 0B    	call IDE_read_sect		; read metadata sector
1176   0DA8             cmd_mkdir_L3:
1177   0DA8 BD 00       	cmp byte[d], 0
1178   0DAA C6 B3 0D    	je cmd_mkdir_found_null3
1179   0DAD 58 20 00    	add d, FST_ENTRY_SIZE
1180   0DB0 0A A8 0D    	jmp cmd_mkdir_L3	; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1181   0DB3             cmd_mkdir_found_null3:
1182   0DB3 FD 4D 41 16 	mov si, s_parent_dir
1183   0DB7 FD 50       	mov di, d
1184   0DB9 07 A8 00    	call strcpy			; copy directory name
1185   0DBC 58 18 00    	add d, 24			; goto ATTRIBUTES
1186   0DBF 19 0B       	mov al, %00001011		;directory, no execute, write, read, 
1187   0DC1 3E          	mov [d], al			
1188   0DC2 79          	inc d
1189   0DC3 29 34 16    	mov b, [current_dirID]	; retrieve the parent directorys LBA
1190   0DC6 FD 43       	mov [d], b			; save LBA
1191   0DC8             ; set file creation date	
1192   0DC8 58 04 00    	add d, 4
1193   0DCB 19 04       	mov al, 4
1194   0DCD 05 01       	syscall sys_rtc
1195   0DCF 1A          	mov al, ah
1196   0DD0 3E          	mov [d], al			; set day
1197   0DD1 79          	inc d
1198   0DD2 19 05       	mov al, 5
1199   0DD4 05 01       	syscall sys_rtc
1200   0DD6 1A          	mov al, ah
1201   0DD7 3E          	mov [d], al			; set month
1202   0DD8 79          	inc d
1203   0DD9 19 06       	mov al, 6
1204   0DDB 05 01       	syscall sys_rtc
1205   0DDD 1A          	mov al, ah
1206   0DDE 3E          	mov [d], al			; set year
1207   0DDF             ; write sector into disk for new directory entry
1208   0DDF FD 27       	mov b, g
1209   0DE1 38 00 00    	mov c, 0
1210   0DE4 3B DE 28    	mov d, transient_area
1211   0DE7 22 01       	mov ah, $01			; disk write, 1 sector
1212   0DE9 07 4A 0B    	call IDE_write_sect		; write sector
1213   0DEC             
1214   0DEC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1215   0DEC             ; like we did above for '..', we need to now add the '.' directory to the list.
1216   0DEC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1217   0DEC E4          	pop a						; retrieve the new directory's LBA	
1218   0DED D7          	push a
1219   0DEE 53 01 00    	add a, 1
1220   0DF1 27          	mov b, a					; metadata sector
1221   0DF2 38 00 00    	mov c, 0
1222   0DF5 FD 79       	mov g, b					; save LBA
1223   0DF7 3B DE 28    	mov d, transient_area
1224   0DFA 22 01       	mov ah, $01				; disk read
1225   0DFC 07 24 0B    	call IDE_read_sect				; read metadata sector
1226   0DFF             cmd_mkdir_L4:
1227   0DFF BD 00       	cmp byte[d], 0
1228   0E01 C6 0A 0E    	je cmd_mkdir_found_null4
1229   0E04 58 20 00    	add d, FST_ENTRY_SIZE
1230   0E07 0A FF 0D    	jmp cmd_mkdir_L4	; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1231   0E0A             cmd_mkdir_found_null4:
1232   0E0A FD 4D 44 16 	mov si, s_current_dir
1233   0E0E FD 50       	mov di, d
1234   0E10 07 A8 00    	call strcpy			; copy directory name
1235   0E13 58 18 00    	add d, 24			; goto ATTRIBUTES
1236   0E16 19 0B       	mov al, %00001011		;directory, no execute, write, read, 
1237   0E18 3E          	mov [d], al			
1238   0E19 79          	inc d
1239   0E1A E5          	pop b				; new directory's LBA itself. for self-referential directory entry '.'
1240   0E1B FD 43       	mov [d], b			; save LBA
1241   0E1D             ; set file creation date	
1242   0E1D 58 04 00    	add d, 4
1243   0E20 19 04       	mov al, 4
1244   0E22 05 01       	syscall sys_rtc
1245   0E24 1A          	mov al, ah
1246   0E25 3E          	mov [d], al			; set day
1247   0E26 79          	inc d
1248   0E27 19 05       	mov al, 5
1249   0E29 05 01       	syscall sys_rtc
1250   0E2B 1A          	mov al, ah
1251   0E2C 3E          	mov [d], al			; set month
1252   0E2D 79          	inc d
1253   0E2E 19 06       	mov al, 6
1254   0E30 05 01       	syscall sys_rtc
1255   0E32 1A          	mov al, ah
1256   0E33 3E          	mov [d], al			; set year
1257   0E34             ; write sector into disk for new directory entry
1258   0E34 FD 27       	mov b, g
1259   0E36 38 00 00    	mov c, 0
1260   0E39 3B DE 28    	mov d, transient_area
1261   0E3C 22 01       	mov ah, $01			; disk write, 1 sector
1262   0E3E 07 4A 0B    	call IDE_write_sect		; write sector
1263   0E41             cmd_mkdir_end:
1264   0E41 06          	sysret
1265   0E42             
1266   0E42             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1267   0E42             ;; get path from a given directory dirID
1268   0E42             ;; pseudo code:
1269   0E42             ;	get_path_from_dirID(int dirID, char *D){
1270   0E42             ;		if(dirID == 0){
1271   0E42             ;			reverse path in D;
1272   0E42             ;			return;
1273   0E42             ;		}
1274   0E42             ;		else{
1275   0E42             ;			copy directory name to end of D;
1276   0E42             ;			add '/' to end of D;
1277   0E42             ;			parentID = get parent directory ID;
1278   0E42             ;			get_path_from_dirID(parentID, D);
1279   0E42             ;		}
1280   0E42             ;	}
1281   0E42             ;; A = dirID
1282   0E42             ;; D = generated path string pointer
1283   0E42             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1284   0E42             ;; sample path: /usr/bin
1285   0E42             get_path_from_dirID:
1286   0E42 3B DE 1A    	mov d, filename
1287   0E45 19 00       	mov al, 0
1288   0E47 3E          	mov [d], al				; initialize path string 
1289   0E48 14 34 16    	mov a, [current_dirID]
1290   0E4B 07 58 0E    	call get_path_from_dirID_E0
1291   0E4E 3B DE 1A    	mov d, filename
1292   0E51 07 3C 00    	call strrev
1293   0E54 07 88 02    	call puts
1294   0E57 06          	sysret
1295   0E58             get_path_from_dirID_E0:
1296   0E58 07 77 0E    	call get_dirname_from_dirID
1297   0E5B FD 4D 46 16 	mov si, s_fslash
1298   0E5F FD 50       	mov di, d
1299   0E61 07 B6 00    	call strcat						; add '/' to end of path
1300   0E64 AF 20 00    	cmp a, ROOT_dirID				; check if we are at the root directory
1301   0E67 C6 76 0E    	je get_path_from_dirID_root
1302   0E6A 07 94 0E    	call get_parentID_from_dirID	; use current ID (A) to find parentID (into A)
1303   0E6D AF 20 00    	cmp a, ROOT_dirID				; check if we are at the root directory
1304   0E70 C6 76 0E    	je get_path_from_dirID_root
1305   0E73 07 58 0E    	call get_path_from_dirID_E0		; recursively call itself
1306   0E76             get_path_from_dirID_root:
1307   0E76 09          	ret
1308   0E77             
1309   0E77             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1310   0E77             ;; inputs:
1311   0E77             ;; A = directory ID
1312   0E77             ;; outputs:
1313   0E77             ;; D = pointer to directory name string
1314   0E77             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1315   0E77             get_dirname_from_dirID:
1316   0E77 D7          	push a
1317   0E78 D8          	push b
1318   0E79 DA          	push d
1319   0E7A 27          	mov b, a
1320   0E7B 38 00 00    	mov c, 0				; reset LBA to 0
1321   0E7E 22 01       	mov ah, $01			; disk read
1322   0E80 3B DE 26    	mov d, transient_area - 512
1323   0E83 07 24 0B    	call IDE_read_sect			; read directory
1324   0E86 07 3C 00    	call strrev				; reverse dir name before copying
1325   0E89 FD 4E       	mov si, d
1326   0E8B E7          	pop d					; destination address = D value pushed at beginning
1327   0E8C FD 50       	mov di, d
1328   0E8E 07 B6 00    	call strcat				; copy filename to D
1329   0E91 E5          	pop b
1330   0E92 E4          	pop a
1331   0E93 09          	ret
1332   0E94             
1333   0E94             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1334   0E94             ;; inputs:
1335   0E94             ;; A = directory ID
1336   0E94             ;; outputs:
1337   0E94             ;; A = parent directory ID
1338   0E94             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1339   0E94             get_parentID_from_dirID:
1340   0E94 D8          	push b
1341   0E95 DA          	push d
1342   0E96 27          	mov b, a
1343   0E97 38 00 00    	mov c, 0				; reset LBA to 0
1344   0E9A 22 01       	mov ah, $01			; disk read
1345   0E9C 3B DE 26    	mov d, transient_area - 512
1346   0E9F 07 24 0B    	call IDE_read_sect			; read directory
1347   0EA2 16 40 00    	mov a, [d + 64]			; copy parent ID value to A
1348   0EA5 E7          	pop d
1349   0EA6 E5          	pop b
1350   0EA7 09          	ret
1351   0EA8             
1352   0EA8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1353   0EA8             ;; get dirID from a given path string
1354   0EA8             ;; inputs:
1355   0EA8             ;; D = path pointer 
1356   0EA8             ;; outputs:
1357   0EA8             ;; A = dirID
1358   0EA8             ;; if dir non existent, A = FFFF (fail code)
1359   0EA8             ;; /usr/local/bin		- absolute
1360   0EA8             ;; local/bin/games		- relative
1361   0EA8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1362   0EA8             get_dirID_from_path_user:
1363   0EA8 FD 4E       	mov si, d
1364   0EAA FD 4F DE 1C 	mov di, temp_data
1365   0EAE 38 00 02    	mov c, 512
1366   0EB1 04          	load
1367   0EB2 07 B6 0E    	call get_dirID_from_path
1368   0EB5 06          	sysret
1369   0EB6             
1370   0EB6             get_dirID_from_path:
1371   0EB6 26 DE 1C    	mov b, temp_data
1372   0EB9 FD 42 87 06 	mov [prog], b			; token pointer set to path string
1373   0EBD 07 E8 04    	call get_token
1374   0EC0 31 8A 06    	mov bl, [tok]
1375   0EC3 C1 01       	cmp bl, TOK_FSLASH
1376   0EC5 C6 D1 0E    	je get_dirID_from_path_abs 
1377   0EC8 14 34 16    	mov a, [current_dirID]
1378   0ECB 07 6E 06    	call putback
1379   0ECE 0A D4 0E    	jmp get_dirID_from_path_E0
1380   0ED1             get_dirID_from_path_abs:
1381   0ED1 10 20 00    	mov a, ROOT_dirID
1382   0ED4             get_dirID_from_path_E0:
1383   0ED4 07 E8 04    	call get_token
1384   0ED7 31 89 06    	mov bl, [toktyp]
1385   0EDA C1 00       	cmp bl, TOKTYP_IDENTIFIER
1386   0EDC C7 2D 0F    	jne get_dirID_from_path_end	; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1387   0EDF             
1388   0EDF FD 4D 8B 06 	mov si, tokstr
1389   0EE3 FD 4F DE 1A 	mov di, filename
1390   0EE7 07 A8 00    	call strcpy				
1391   0EEA 77          	inc a					; metadata sector
1392   0EEB 27          	mov b, a
1393   0EEC 38 00 00    	mov c, 0				; reset LBA to 0
1394   0EEF 22 01       	mov ah, $01			; disk read
1395   0EF1 3B DE 28    	mov d, transient_area
1396   0EF4 07 24 0B    	call IDE_read_sect		; read directory
1397   0EF7 FD 10       	cla
1398   0EF9 42 2C 16    	mov [index], a
1399   0EFC             get_dirID_from_path_L1:
1400   0EFC FD 4E       	mov si, d
1401   0EFE FD 4F DE 1A 	mov di, filename
1402   0F02 07 93 00    	call strcmp
1403   0F05 C6 1B 0F    	je get_dirID_from_path_name_equal	
1404   0F08 58 20 00    	add d, 32
1405   0F0B 14 2C 16    	mov a, [index]
1406   0F0E 77          	inc a
1407   0F0F 42 2C 16    	mov [index], a
1408   0F12 AF 10 00    	cmp a, FST_FILES_PER_DIR
1409   0F15 C6 2E 0F    	je get_dirID_from_path_fail
1410   0F18 0A FC 0E    	jmp get_dirID_from_path_L1
1411   0F1B             get_dirID_from_path_name_equal:
1412   0F1B 58 19 00    	add d, 25					; 
1413   0F1E 15          	mov a, [d]					; set result register A = dirID
1414   0F1F 07 E8 04    	call get_token
1415   0F22 31 8A 06    	mov bl, [tok]
1416   0F25 C1 01       	cmp bl, TOK_FSLASH			; check if there are more elements in the path
1417   0F27 C6 D4 0E    	je get_dirID_from_path_E0
1418   0F2A 07 6E 06    	call putback
1419   0F2D             get_dirID_from_path_end:
1420   0F2D 09          	ret
1421   0F2E             get_dirID_from_path_fail:
1422   0F2E 10 FF FF    	mov A, $FFFF
1423   0F31 09          	ret
1424   0F32             
1425   0F32             
1426   0F32             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1427   0F32             ;; check if file exists by a given path string
1428   0F32             ;; inputs:
1429   0F32             ;; D = path pointer 
1430   0F32             ;; OUTPUTS:
1431   0F32             ;; A = success code, if file exists gives LBA, else, give 0
1432   0F32             ;; /usr/local/bin/ed
1433   0F32             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1434   0F32             file_exists_by_path_user:
1435   0F32 FD 4E       	mov si, d
1436   0F34 FD 4F DE 1C 	mov di, temp_data
1437   0F38 38 00 02    	mov c, 512
1438   0F3B 04          	load
1439   0F3C 07 40 0F    	call file_exists_by_path
1440   0F3F 06          	sysret
1441   0F40             file_exists_by_path:
1442   0F40 26 DE 1C    	mov b, temp_data
1443   0F43 FD 42 87 06 	mov [prog], b			; token pointer set to path string
1444   0F47 07 E8 04    	call get_token
1445   0F4A 31 8A 06    	mov bl, [tok]
1446   0F4D C1 01       	cmp bl, TOK_FSLASH
1447   0F4F C6 5B 0F    	je  file_exists_by_path_abs
1448   0F52 14 34 16    	mov a, [current_dirID]
1449   0F55 07 6E 06    	call putback
1450   0F58 0A 5E 0F    	jmp file_exists_by_path_E0
1451   0F5B             file_exists_by_path_abs:
1452   0F5B 10 20 00    	mov a, ROOT_dirID
1453   0F5E             file_exists_by_path_E0:
1454   0F5E 07 E8 04    	call get_token
1455   0F61 31 89 06    	mov bl, [toktyp]
1456   0F64 C1 00       	cmp bl, TOKTYP_IDENTIFIER
1457   0F66 C7 BE 0F    	jne file_exists_by_path_end	; check if there are tokens after '/'
1458   0F69 FD 4D 8B 06 	mov si, tokstr
1459   0F6D FD 4F DE 1A 	mov di, filename
1460   0F71 07 A8 00    	call strcpy				
1461   0F74 77          	inc a					; metadata sector
1462   0F75 27          	mov b, a
1463   0F76 38 00 00    	mov c, 0				; reset LBA to 0
1464   0F79 22 01       	mov ah, $01			; disk read
1465   0F7B 3B DE 28    	mov d, transient_area
1466   0F7E 07 24 0B    	call IDE_read_sect		; read directory
1467   0F81 FD 10       	cla
1468   0F83 42 2C 16    	mov [index], a
1469   0F86             file_exists_by_path_L1:
1470   0F86 FD 4E       	mov si, d
1471   0F88 FD 4F DE 1A 	mov di, filename
1472   0F8C 07 93 00    	call strcmp
1473   0F8F C6 A5 0F    	je 	file_exists_by_path_name_equal
1474   0F92 58 20 00    	add d, 32
1475   0F95 14 2C 16    	mov a, [index]
1476   0F98 77          	inc a
1477   0F99 42 2C 16    	mov [index], a
1478   0F9C AF 10 00    	cmp a, FST_FILES_PER_DIR
1479   0F9F C6 BE 0F    	je file_exists_by_path_end
1480   0FA2 0A 86 0F    	jmp file_exists_by_path_L1
1481   0FA5             file_exists_by_path_name_equal:
1482   0FA5 33 18 00    	mov bl, [d + 24]
1483   0FA8 FD 87 38    	and bl, %00111000			; directory flag
1484   0FAB C1 08       	cmp bl, %00001000			; is dir?
1485   0FAD C6 B4 0F    	je file_exists_by_path_isdir;
1486   0FB0             ; entry is a file
1487   0FB0 16 19 00    	mov a, [d + 25]			; get and return LBA of file
1488   0FB3 09          	ret
1489   0FB4             file_exists_by_path_isdir:
1490   0FB4 58 19 00    	add d, 25					; 
1491   0FB7 15          	mov a, [d]					; set result register A = dirID
1492   0FB8 07 E8 04    	call get_token
1493   0FBB 0A 5E 0F    	jmp file_exists_by_path_E0
1494   0FBE             file_exists_by_path_end:
1495   0FBE 10 00 00    	mov a, 0			; return 0 because file was not found
1496   0FC1 09          	ret
1497   0FC2             
1498   0FC2             
1499   0FC2             
1500   0FC2             
1501   0FC2             
1502   0FC2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1503   0FC2             ;; load file data from a given path string
1504   0FC2             ;; inputs:
1505   0FC2             ;; D = path pointer 
1506   0FC2             ;; DI = userspace program data destination
1507   0FC2             ;; /usr/local/bin/ed
1508   0FC2             ;; ./ed
1509   0FC2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1510   0FC2             loadfile_from_path_user:
1511   0FC2 E3          	push di
1512   0FC3 FD 4E       	mov si, d
1513   0FC5 FD 4F DE 1C 	mov di, temp_data
1514   0FC9 38 00 02    	mov c, 512
1515   0FCC 04          	load
1516   0FCD 07 DA 0F    	call loadfile_from_path
1517   0FD0 F0          	pop di
1518   0FD1 FD 4D DE 28 	mov si, transient_area
1519   0FD5 38 00 3E    	mov c, 512 * (FS_SECTORS_PER_FILE-1)
1520   0FD8 03          	store
1521   0FD9 06          	sysret
1522   0FDA             loadfile_from_path:
1523   0FDA 26 DE 1C    	mov b, temp_data
1524   0FDD FD 42 87 06 	mov [prog], b			; token pointer set to path string
1525   0FE1 07 E8 04    	call get_token
1526   0FE4 31 8A 06    	mov bl, [tok]
1527   0FE7 C1 01       	cmp bl, TOK_FSLASH
1528   0FE9 C6 F5 0F    	je loadfile_from_path_abs 
1529   0FEC 14 34 16    	mov a, [current_dirID]
1530   0FEF 07 6E 06    	call putback
1531   0FF2 0A F8 0F    	jmp loadfile_from_path_E0
1532   0FF5             loadfile_from_path_abs:
1533   0FF5 10 20 00    	mov a, ROOT_dirID
1534   0FF8             loadfile_from_path_E0:
1535   0FF8 07 E8 04    	call get_token
1536   0FFB 31 89 06    	mov bl, [toktyp]
1537   0FFE C1 00       	cmp bl, TOKTYP_IDENTIFIER
1538   1000 C7 65 10    	jne loadfile_from_path_end	; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1539   1003 FD 4D 8B 06 	mov si, tokstr
1540   1007 FD 4F DE 1A 	mov di, filename
1541   100B 07 A8 00    	call strcpy				
1542   100E 77          	inc a					; metadata sector
1543   100F 27          	mov b, a
1544   1010 38 00 00    	mov c, 0				; reset LBA to 0
1545   1013 22 01       	mov ah, $01			; disk read
1546   1015 3B DE 28    	mov d, transient_area
1547   1018 07 24 0B    	call IDE_read_sect		; read directory
1548   101B FD 10       	cla
1549   101D 42 2C 16    	mov [index], a
1550   1020             loadfile_from_path_L1:
1551   1020 FD 4E       	mov si, d
1552   1022 FD 4F DE 1A 	mov di, filename
1553   1026 07 93 00    	call strcmp
1554   1029 C6 3F 10    	je loadfile_from_path_name_equal	
1555   102C 58 20 00    	add d, 32
1556   102F 14 2C 16    	mov a, [index]
1557   1032 77          	inc a
1558   1033 42 2C 16    	mov [index], a
1559   1036 AF 10 00    	cmp a, FST_FILES_PER_DIR
1560   1039 C6 65 10    	je loadfile_from_path_end
1561   103C 0A 20 10    	jmp loadfile_from_path_L1
1562   103F             loadfile_from_path_name_equal:
1563   103F 33 18 00    	mov bl, [d + 24]
1564   1042 FD 87 38    	and bl, %00111000			; directory flag
1565   1045 C1 08       	cmp bl, %00001000			; is dir?
1566   1047 C6 5B 10    	je loadfile_isdirectory	;
1567   104A             ; entry is a file
1568   104A 2B 19 00    	mov b, [d + 25]			; get LBA
1569   104D FD 77       	inc b				; add 1 to B because the LBA for data comes after the header sector
1570   104F 3B DE 28    	mov d, transient_area
1571   1052 38 00 00    	mov c, 0
1572   1055 22 1F       	mov ah, FS_SECTORS_PER_FILE-1		; number of sectors
1573   1057 07 24 0B    	call IDE_read_sect				; read sector
1574   105A 09          	ret
1575   105B             loadfile_isdirectory:
1576   105B 58 19 00    	add d, 25					; 
1577   105E 15          	mov a, [d]					; set result register A = dirID
1578   105F 07 E8 04    	call get_token
1579   1062 0A F8 0F    	jmp loadfile_from_path_E0
1580   1065             loadfile_from_path_end:
1581   1065 09          	ret
1582   1066             
1583   1066             
1584   1066             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1585   1066             ;; return the ID of the current directory
1586   1066             ;; ID returned in B
1587   1066             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1588   1066             get_current_dirID:
1589   1066 29 34 16    	mov b, [current_dirID]
1590   1069 06          	sysret
1591   106A             
1592   106A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1593   106A             ;; CD
1594   106A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1595   106A             ; new dirID in B
1596   106A             cmd_cd:
1597   106A FD 42 34 16 	mov [current_dirID], b
1598   106E 06          	sysret	
1599   106F             
1600   106F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1601   106F             ;; LS
1602   106F             ;; dirID in B
1603   106F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1604   106F             cmd_ls:
1605   106F FD 77       	inc b				; metadata sector
1606   1071 38 00 00    	mov c, 0				; reset LBA to 0
1607   1074 22 01       	mov ah, $01			; disk read
1608   1076 3B DE 28    	mov d, transient_area
1609   1079 07 24 0B    	call IDE_read_sect		; read directory
1610   107C FD 10       	cla
1611   107E 42 2C 16    	mov [index], a		; reset entry index
1612   1081             cmd_ls_L1:
1613   1081 BD 00       	cmp byte [d], 0		; check for NULL
1614   1083 C6 13 11    	je cmd_ls_next
1615   1086             cmd_ls_non_null:
1616   1086 1F 18 00    	mov al, [d + 24]
1617   1089 87 38       	and al, %00111000
1618   108B FD A2 03    	shr al, 3
1619   108E 22 00       	mov ah, 0					; file type
1620   1090 B7 51 16    	mov a, [a + file_type]			
1621   1093 23          	mov ah, al
1622   1094 07 4E 01    	call putchar
1623   1097 1F 18 00    	mov al, [d + 24]
1624   109A 87 01       	and al, %00000001
1625   109C 22 00       	mov ah, 0
1626   109E B7 4C 16    	mov a, [a + file_attrib]		; read
1627   10A1 23          	mov ah, al
1628   10A2 07 4E 01    	call putchar
1629   10A5 1F 18 00    	mov al, [d + 24]
1630   10A8 87 02       	and al, %00000010
1631   10AA 22 00       	mov ah, 0
1632   10AC B7 4C 16    	mov a, [a + file_attrib]		; write
1633   10AF 23          	mov ah, al
1634   10B0 07 4E 01    	call putchar
1635   10B3 1F 18 00    	mov al, [d + 24]
1636   10B6 87 04       	and al, %00000100
1637   10B8 22 00       	mov ah, 0
1638   10BA B7 4C 16    	mov a, [a + file_attrib]		; execute
1639   10BD 23          	mov ah, al
1640   10BE 07 4E 01    	call putchar
1641   10C1 22 20       	mov ah, $20
1642   10C3 07 4E 01    	call putchar	
1643   10C6 16 1B 00    	mov a, [d + 27]
1644   10C9 07 B1 02    	call print_u16d				; filesize
1645   10CC 22 20       	mov ah, $20
1646   10CE 07 4E 01    	call putchar	
1647   10D1 16 19 00    	mov a, [d + 25]
1648   10D4 07 B1 02    	call print_u16d			; dirID / LBA
1649   10D7 22 20       	mov ah, $20
1650   10D9 07 4E 01    	call putchar
1651   10DC             ; print date
1652   10DC 33 1D 00    	mov bl, [d + 29]			; day
1653   10DF 07 28 03    	call print_u8x
1654   10E2 22 20       	mov ah, $20
1655   10E4 07 4E 01    	call putchar	
1656   10E7 1F 1E 00    	mov al, [d + 30]			; month
1657   10EA FD 9E 02    	shl al, 2
1658   10ED DA          	push d
1659   10EE 3B 3E 17    	mov d, s_months
1660   10F1 22 00       	mov ah, 0
1661   10F3 59          	add d, a
1662   10F4 07 88 02    	call puts
1663   10F7 E7          	pop d
1664   10F8 22 20       	mov ah, $20
1665   10FA 07 4E 01    	call putchar
1666   10FD 2E 20       	mov bl, $20
1667   10FF 07 28 03    	call print_u8x
1668   1102 33 1F 00    	mov bl, [d + 31]			; year
1669   1105 07 28 03    	call print_u8x	
1670   1108 22 20       	mov ah, $20
1671   110A 07 4E 01    	call putchar	
1672   110D 07 88 02    	call puts				; print filename	
1673   1110 07 35 02    	call printnl
1674   1113             cmd_ls_next:
1675   1113 14 2C 16    	mov a, [index]
1676   1116 77          	inc a
1677   1117 42 2C 16    	mov [index], a
1678   111A AF 10 00    	cmp a, FST_FILES_PER_DIR
1679   111D C6 26 11    	je cmd_ls_end
1680   1120 58 20 00    	add d, 32			
1681   1123 0A 81 10    	jmp cmd_ls_L1	
1682   1126             cmd_ls_end:
1683   1126 06          	sysret
1684   1127             
1685   1127             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1686   1127             ;; pad string to 32 chars
1687   1127             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1688   1127             ; count in C
1689   1127             padding:
1690   1127 D7          	push a
1691   1128 D8          	push b
1692   1129 10 20 00    	mov a, 32
1693   112C 28          	mov b, c
1694   112D 60          	sub a, b
1695   112E 39          	mov c, a
1696   112F             padding_L1:
1697   112F 22 20       	mov ah, $20
1698   1131 07 4E 01    	call putchar
1699   1134 7E          	dec c
1700   1135 C2 00 00    	cmp c, 0
1701   1138 C7 2F 11    	jne padding_L1
1702   113B E5          	pop b
1703   113C E4          	pop a
1704   113D 09          	ret
1705   113E             
1706   113E             
1707   113E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1708   113E             ;; finds an empty data block
1709   113E             ;; block LBA returned in B
1710   113E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1711   113E             fs_find_empty_block:
1712   113E 26 A0 00    	mov b, FS_LBA_START		; raw files starting block
1713   1141 38 00 00    	mov c, 0						; reset LBA to 0
1714   1144             fs_find_empty_block_L1:	
1715   1144 22 01       	mov ah, $01			; disk read
1716   1146 3B DE 26    	mov d, transient_area - 512
1717   1149 07 24 0B    	call IDE_read_sect		; read sector
1718   114C BD 00       	cmp byte [d], 0
1719   114E C6 57 11    	je fs_find_empty_block_found_null
1720   1151 55 20 00    	add b, FS_SECTORS_PER_FILE
1721   1154 0A 44 11    	jmp fs_find_empty_block_L1
1722   1157             fs_find_empty_block_found_null:
1723   1157 09          	ret
1724   1158             
1725   1158             ; file structure:
1726   1158             ; 512 bytes header
1727   1158             ; header used to tell whether the block is free
1728   1158             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1729   1158             ;; CREATE NEW TEXTFILE
1730   1158             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1731   1158             cmd_mktxt:
1732   1158 FD 4E       	mov si, d
1733   115A FD 4F DE 28 	mov di, transient_area
1734   115E 38 00 40    	mov c, FS_SECTORS_PER_FILE * 512
1735   1161 04          	load					; load data from user-space
1736   1162 07 3E 11    	call fs_find_empty_block	; look for empty data blocks
1737   1165 D8          	push b				; save empty block LBA
1738   1166             ;create header file by grabbing file name from parameter	
1739   1166 3B DE 2A    	mov d, transient_area + 512			; pointer to file contents
1740   1169             	;call gettxt
1741   1169 07 83 00    	call strlen						; get length of the text file
1742   116C D9          	push c							; save length
1743   116D 19 01       	mov al, 1
1744   116F 3D DE 28    	mov [transient_area], al					; mark sectors as USED (not NULL)
1745   1172 3B DE 28    	mov d, transient_area
1746   1175             cmd_mktxt_L2:
1747   1175 38 00 00    	mov c, 0
1748   1178 22 20       	mov ah, FS_SECTORS_PER_FILE		; number of sectors to write
1749   117A 07 4A 0B    	call IDE_write_sect			; write sectors
1750   117D             ; now we add the file to the current directory!
1751   117D             cmd_mktxt_add_to_dir:	
1752   117D 14 34 16    	mov a, [current_dirID]
1753   1180 77          	inc a
1754   1181 27          	mov b, a					; metadata sector
1755   1182 38 00 00    	mov c, 0
1756   1185 FD 79       	mov g, b					; save LBA
1757   1187 3B DE 26    	mov d, transient_area - 512
1758   118A 22 01       	mov ah, $01			; disk read
1759   118C 07 24 0B    	call IDE_read_sect		; read metadata sector
1760   118F             cmd_mktxt_add_to_dir_L2:
1761   118F BD 00       	cmp byte[d], 0
1762   1191 C6 9A 11    	je cmd_mktxt_add_to_dir_null
1763   1194 58 20 00    	add d, FST_ENTRY_SIZE
1764   1197 0A 8F 11    	jmp cmd_mktxt_add_to_dir_L2		; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1765   119A             cmd_mktxt_add_to_dir_null:
1766   119A FD 4D DF 28 	mov si, transient_area + 1		; filename located after the data block 'USED' marker byte
1767   119E FD 50       	mov di, d
1768   11A0 07 A8 00    	call strcpy			; copy file name
1769   11A3 58 18 00    	add d, 24			; skip name
1770   11A6 19 03       	mov al, %00000011	; type=file, no execute, write, read
1771   11A8 3E          	mov [d], al			
1772   11A9 58 03 00    	add d, 3
1773   11AC E4          	pop a
1774   11AD 43          	mov [d], a
1775   11AE 63 02 00    	sub d, 2
1776   11B1 E5          	pop b				; get file LBA
1777   11B2 FD 43       	mov [d], b			; save LBA	
1778   11B4             	
1779   11B4             	; set file creation date	
1780   11B4 58 04 00    	add d, 4
1781   11B7 19 04       	mov al, 4
1782   11B9 05 01       	syscall sys_rtc
1783   11BB 1A          	mov al, ah
1784   11BC 3E          	mov [d], al			; set day
1785   11BD             	
1786   11BD 79          	inc d
1787   11BE 19 05       	mov al, 5
1788   11C0 05 01       	syscall sys_rtc
1789   11C2 1A          	mov al, ah
1790   11C3 3E          	mov [d], al			; set month
1791   11C4             	
1792   11C4 79          	inc d
1793   11C5 19 06       	mov al, 6
1794   11C7 05 01       	syscall sys_rtc
1795   11C9 1A          	mov al, ah
1796   11CA 3E          	mov [d], al			; set year
1797   11CB             	
1798   11CB             ; write sector into disk for new directory entry
1799   11CB FD 27       	mov b, g
1800   11CD 38 00 00    	mov c, 0
1801   11D0 3B DE 26    	mov d, transient_area - 512
1802   11D3 22 01       	mov ah, $01			; disk write, 1 sector
1803   11D5 07 4A 0B    	call IDE_write_sect		; write sector
1804   11D8 06          	sysret
1805   11D9             
1806   11D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1807   11D9             ;; CREATE NEW BINARY FILE
1808   11D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1809   11D9             ; search for first null block
1810   11D9             cmd_mkbin:
1811   11D9 FD 4E       	mov si, d
1812   11DB FD 4F DE 1C 	mov di, temp_data
1813   11DF 38 00 02    	mov c, 512
1814   11E2 04          	load					; load data from user-space
1815   11E3             	
1816   11E3 26 A0 00    	mov b, FS_LBA_START		; files start when directories end
1817   11E6 38 00 00    	mov c, 0				; reset LBA to 0
1818   11E9             cmd_mkbin_L1:	
1819   11E9 22 01       	mov ah, $01			; disk read
1820   11EB 3B DE 28    	mov d, transient_area
1821   11EE 07 24 0B    	call IDE_read_sect		; read sector
1822   11F1 BD 00       	cmp byte[d], 0			; check for NULL
1823   11F3 C6 FC 11    	je cmd_mkbin_found_null
1824   11F6 55 20 00    	add b, FS_SECTORS_PER_FILE
1825   11F9 0A E9 11    	jmp cmd_mkbin_L1
1826   11FC             cmd_mkbin_found_null:
1827   11FC D8          	push b				; save LBA
1828   11FD             ;create header file by grabbing file name from parameter
1829   11FD FD 4F DE 2A 	mov di, transient_area + 512	; pointer to file contents
1830   1201 07 F9 15    	call _load_hex			; load binary hex
1831   1204 D9          	push c					; save size (nbr of bytes)
1832   1205 19 01       	mov al, 1
1833   1207 3D DE 28    	mov [transient_area], al		; mark sectors as USED (not NULL)
1834   120A FD 10       	cla
1835   120C 42 2C 16    	mov [index], a
1836   120F 3B DE 28    	mov d, transient_area
1837   1212 13          	mov a, d
1838   1213 42 2E 16    	mov [buffer_addr], a
1839   1216             cmd_mkbin_L2:
1840   1216 38 00 00    	mov c, 0
1841   1219 22 01       	mov ah, $01				; disk write, 1 sector
1842   121B 07 4A 0B    	call IDE_write_sect			; write sector
1843   121E 14 2C 16    	mov a, [index]
1844   1221 77          	inc a
1845   1222 42 2C 16    	mov [index], a
1846   1225 AF 20 00    	cmp a, FS_SECTORS_PER_FILE		; remove 1 from this because we dont count the header sector
1847   1228 C6 3A 12    	je cmd_mkbin_add_to_dir
1848   122B FD 77       	inc b
1849   122D 14 2E 16    	mov a, [buffer_addr]
1850   1230 53 00 02    	add a, 512
1851   1233 42 2E 16    	mov [buffer_addr], a
1852   1236 3C          	mov d, a
1853   1237 0A 16 12    	jmp cmd_mkbin_L2
1854   123A             ; now we add the file to the current directory!
1855   123A             cmd_mkbin_add_to_dir:	
1856   123A 14 34 16    	mov a, [current_dirID]
1857   123D 77          	inc a
1858   123E 27          	mov b, a					; metadata sector
1859   123F 38 00 00    	mov c, 0
1860   1242 FD 79       	mov g, b					; save LBA
1861   1244 3B DE 28    	mov d, transient_area
1862   1247 22 01       	mov ah, $01			; disk read
1863   1249 07 24 0B    	call IDE_read_sect		; read metadata sector
1864   124C             cmd_mkbin_add_to_dir_L2:
1865   124C BD 00       	cmp byte[d], 0
1866   124E C6 57 12    	je cmd_mkbin_add_to_dir_null
1867   1251 58 20 00    	add d, FST_ENTRY_SIZE
1868   1254 0A 4C 12    	jmp cmd_mkbin_add_to_dir_L2		; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1869   1257             cmd_mkbin_add_to_dir_null:
1870   1257 FD 4D DE 1C 	mov si, temp_data
1871   125B FD 50       	mov di, d
1872   125D 07 A8 00    	call strcpy			; copy file name
1873   1260 58 18 00    	add d, 24			; skip name
1874   1263 19 07       	mov al, %00000111		;type=file, execute, write, read, 
1875   1265 3E          	mov [d], al
1876   1266 58 03 00    	add d, 3
1877   1269 E4          	pop a
1878   126A 43          	mov [d], a
1879   126B 63 02 00    	sub d, 2
1880   126E E5          	pop b				; get file LBA
1881   126F FD 43       	mov [d], b			; save LBA
1882   1271             	
1883   1271             	; set file creation date	
1884   1271 58 04 00    	add d, 4
1885   1274 19 04       	mov al, 4
1886   1276 05 01       	syscall sys_rtc
1887   1278 1A          	mov al, ah
1888   1279 3E          	mov [d], al			; set day
1889   127A             	
1890   127A 79          	inc d
1891   127B 19 05       	mov al, 5
1892   127D 05 01       	syscall sys_rtc
1893   127F 1A          	mov al, ah
1894   1280 3E          	mov [d], al			; set month
1895   1281             	
1896   1281 79          	inc d
1897   1282 19 06       	mov al, 6
1898   1284 05 01       	syscall sys_rtc
1899   1286 1A          	mov al, ah
1900   1287 3E          	mov [d], al			; set year
1901   1288             	
1902   1288             ; write sector into disk for new directory entry
1903   1288 FD 27       	mov b, g
1904   128A 38 00 00    	mov c, 0
1905   128D 3B DE 28    	mov d, transient_area
1906   1290 22 01       	mov ah, $01			; disk write, 1 sector
1907   1292 07 4A 0B    	call IDE_write_sect		; write sector
1908   1295 06          	sysret
1909   1296             
1910   1296             			
1911   1296             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1912   1296             ;; PWD - PRINT WORKING DIRECTORY
1913   1296             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		
1914   1296             cmd_pwd:
1915   1296 3B DE 1A    	mov d, filename
1916   1299 19 00       	mov al, 0
1917   129B 3E          	mov [d], al				; initialize path string 
1918   129C 14 34 16    	mov a, [current_dirID]
1919   129F 07 58 0E    	call get_path_from_dirID_E0
1920   12A2 3B DE 1A    	mov d, filename
1921   12A5 07 3C 00    	call strrev
1922   12A8 07 88 02    	call puts
1923   12AB 07 35 02    	call printnl
1924   12AE 06          	sysret
1925   12AF             
1926   12AF             
1927   12AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1928   12AF             ;; get current directory LBA
1929   12AF             ;; A: returned LBA
1930   12AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:
1931   12AF             cmd_get_curr_dir_LBA:
1932   12AF 14 34 16    	mov a, [current_dirID]
1933   12B2 06          	sysret
1934   12B3             
1935   12B3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1936   12B3             ;; LOAD FILE INTO MEM
1937   12B3             ;; file loaded to transient_area
1938   12B3             ;; D: filename pointer
1939   12B3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:
1940   12B3             cmd_loadfile_user:
1941   12B3 FD 4E       	mov si, d
1942   12B5 FD 4F DE 1A 	mov di, filename
1943   12B9 38 00 01    	mov c, 256
1944   12BC 04          	load
1945   12BD 07 C1 12    	call cmd_loadfile
1946   12C0 06          	sysret
1947   12C1             
1948   12C1             cmd_loadfile:
1949   12C1 14 34 16    	mov a, [current_dirID]
1950   12C4 77          	inc a				; metadata sector
1951   12C5 27          	mov b, a
1952   12C6 38 00 00    	mov c, 0				; reset LBA to 0
1953   12C9 22 01       	mov ah, $01			; disk read
1954   12CB 3B DE 26    	mov d, transient_area-512
1955   12CE 07 24 0B    	call IDE_read_sect		; read directory
1956   12D1 FD 10       	cla
1957   12D3 42 2C 16    	mov [index], a		; reset file counter
1958   12D6             cmd_loadfile_L1:
1959   12D6 FD 4E       	mov si, d
1960   12D8 FD 4F DE 1A 	mov di, filename
1961   12DC 07 93 00    	call strcmp
1962   12DF C6 F5 12    	je cmd_loadfile_found_entry
1963   12E2 58 20 00    	add d, 32
1964   12E5 14 2C 16    	mov a, [index]
1965   12E8 77          	inc a
1966   12E9 42 2C 16    	mov [index], a
1967   12EC AF 10 00    	cmp a, FST_FILES_PER_DIR
1968   12EF C6 03 13    	je cmd_loadfile_not_found
1969   12F2 0A D6 12    	jmp cmd_loadfile_L1
1970   12F5             cmd_loadfile_found_entry:
1971   12F5 58 19 00    	add d, 25			; get to dirID of file in disk
1972   12F8 2A          	mov b, [d]			; get LBA
1973   12F9 FD 77       	inc b				; add 1 to B because the LBA for data comes after the header sector
1974   12FB 3B DE 28    	mov d, transient_area
1975   12FE 22 1F       	mov ah, FS_SECTORS_PER_FILE-1		; number of sectors
1976   1300 07 24 0B    	call IDE_read_sect				; read sector
1977   1303             cmd_loadfile_not_found:
1978   1303 09          	ret
1979   1304             
1980   1304             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1981   1304             ;; CAT
1982   1304             ;; userspace destination data pointer in D
1983   1304             ;; filename starts at D, but is overwritten after the read is made
1984   1304             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:
1985   1304             cmd_cat:
1986   1304 DA          	push d					; save userspace file data destination
1987   1305 FD 4E       	mov si, d
1988   1307 FD 4F DE 1C 	mov di, temp_data
1989   130B 38 00 02    	mov c, 512
1990   130E 04          	load					; copy filename from user-space
1991   130F 29 34 16    	mov b, [current_dirID]
1992   1312 FD 77       	inc b				; metadata sector
1993   1314 38 00 00    	mov c, 0				; reset LBA to 0
1994   1317 22 01       	mov ah, $01			; disk read
1995   1319 3B DE 26    	mov d, transient_area-512
1996   131C 07 24 0B    	call IDE_read_sect		; read directory
1997   131F FD 10       	cla
1998   1321 42 2C 16    	mov [index], a		; reset file counter
1999   1324             cmd_cat_L1:
2000   1324 FD 4E       	mov si, d
2001   1326 FD 4F DE 1C 	mov di, temp_data
2002   132A 07 93 00    	call strcmp
2003   132D C6 43 13    	je cmd_cat_found_entry
2004   1330 58 20 00    	add d, 32
2005   1333 14 2C 16    	mov a, [index]
2006   1336 77          	inc a
2007   1337 42 2C 16    	mov [index], a
2008   133A AF 10 00    	cmp a, FST_FILES_PER_DIR
2009   133D C6 5E 13    	je cmd_cat_not_found
2010   1340 0A 24 13    	jmp cmd_cat_L1
2011   1343             cmd_cat_found_entry:
2012   1343 58 19 00    	add d, 25			; get to dirID of file in disk
2013   1346 2A          	mov b, [d]			; get LBA
2014   1347 FD 77       	inc b				; add 1 to B because the LBA for data comes after the header sector 
2015   1349 3B DE 28    	mov d, transient_area	
2016   134C 38 00 00    	mov c, 0
2017   134F 22 1F       	mov ah, FS_SECTORS_PER_FILE-1	; nbr sectors
2018   1351 07 24 0B    	call IDE_read_sect		; read sectors
2019   1354 F0          	pop di						; write userspace file data destination to DI
2020   1355 FD 4D DE 28 	mov si, transient_area		; data origin
2021   1359 38 00 3E    	mov c, 512*(FS_SECTORS_PER_FILE-1)
2022   135C 03          	store
2023   135D 06          	sysret
2024   135E             cmd_cat_not_found:
2025   135E E7          	pop d
2026   135F 06          	sysret
2027   1360             
2028   1360             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2029   1360             ;; RMDIR - remove DIR by dirID
2030   1360             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2031   1360             ; deletes a directory entry in the given directory's file list 
2032   1360             ; also deletes the actual directory entry in the FST
2033   1360             ; synopsis: rmdir /usr/local/testdir
2034   1360             ; B = dirID
2035   1360             cmd_rmdir:
2036   1360 FD 79       	mov g, b
2037   1362 11          	mov a, b
2038   1363 07 94 0E    	call get_parentID_from_dirID	; now get the directory's parent, in A
2039   1366 D7          	push a						; save dirID
2040   1367             ; search for directory's entry in the parent's directory then and delete it
2041   1367 77          	inc a						; metadata sector
2042   1368 27          	mov b, a
2043   1369 38 00 00    	mov c, 0					; reset LBA to 0
2044   136C 22 01       	mov ah, $01					;
2045   136E 3B DE 28    	mov d, transient_area
2046   1371 07 24 0B    	call IDE_read_sect			; read directory
2047   1374 FD 10       	cla
2048   1376 42 2C 16    	mov [index], a				; reset file counter
2049   1379 FD 27       	mov b, g					; retrieve directory's dirID
2050   137B             cmd_rmdir_L1:
2051   137B 16 19 00    	mov a, [d + 25]				; get entry's dirID/LBA value
2052   137E B0          	cmp a, b					; compare dirID's to find the directory
2053   137F C6 95 13    	je cmd_rmdir_found_entry
2054   1382 58 20 00    	add d, 32
2055   1385 14 2C 16    	mov a, [index]
2056   1388 77          	inc a
2057   1389 42 2C 16    	mov [index], a
2058   138C AF 10 00    	cmp a, FST_FILES_PER_DIR
2059   138F C6 BA 13    	je cmd_rmdir_not_found
2060   1392 0A 7B 13    	jmp cmd_rmdir_L1
2061   1395             cmd_rmdir_found_entry:
2062   1395 FD 10       	cla
2063   1397 3E          	mov [d], al					; make filename NULL
2064   1398 44 19 00    	mov [d + 25], a				; clear dirID/LBA as well not to generate problems with previously deleted directories
2065   139B E5          	pop b
2066   139C FD 77       	inc b						; metadata sector
2067   139E 38 00 00    	mov c, 0					; reset LBA to 0
2068   13A1 22 01       	mov ah, $01					; 
2069   13A3 3B DE 28    	mov d, transient_area
2070   13A6 07 4A 0B    	call IDE_write_sect			; write sector and erase file's entry in the current DIR
2071   13A9             
2072   13A9 FD 27       	mov b, g
2073   13AB 3B DE 28    	mov d, transient_area	
2074   13AE FD 10       	cla
2075   13B0 3E          	mov [d], al					; make directory's name header NULL for re-use
2076   13B1 38 00 00    	mov c, 0
2077   13B4 22 01       	mov ah, $01					; disk write 1 sect
2078   13B6 07 4A 0B    	call IDE_write_sect			; delete directory given by dirID in B
2079   13B9 06          	sysret
2080   13BA             cmd_rmdir_not_found:
2081   13BA E5          	pop b
2082   13BB 06          	sysret
2083   13BC             
2084   13BC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2085   13BC             ;; RM - remove file
2086   13BC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2087   13BC             ; frees up the data sectors for the file further down the disk
2088   13BC             ; deletes file entry in the directory's file list 
2089   13BC             cmd_rm:
2090   13BC FD 4E       	mov si, d
2091   13BE FD 4F DE 1C 	mov di, temp_data
2092   13C2 38 00 02    	mov c, 512
2093   13C5 04          	load					; load data from user-space
2094   13C6 14 34 16    	mov a, [current_dirID]
2095   13C9 77          	inc a				; metadata sector
2096   13CA 27          	mov b, a
2097   13CB 38 00 00    	mov c, 0				; reset LBA to 0
2098   13CE 22 01       	mov ah, $01			; disk read
2099   13D0 3B DE 28    	mov d, transient_area
2100   13D3 07 24 0B    	call IDE_read_sect		; read directory
2101   13D6 10 00 00    	mov a, 0
2102   13D9 42 2C 16    	mov [index], a		; reset file counter
2103   13DC             cmd_rm_L1:
2104   13DC FD 4E       	mov si, d
2105   13DE FD 4F DE 1C 	mov di, temp_data
2106   13E2 07 93 00    	call strcmp
2107   13E5 C6 FB 13    	je cmd_rm_found_entry
2108   13E8 58 20 00    	add d, 32
2109   13EB 14 2C 16    	mov a, [index]
2110   13EE 77          	inc a
2111   13EF 42 2C 16    	mov [index], a
2112   13F2 AF 10 00    	cmp a, FST_FILES_PER_DIR
2113   13F5 C6 23 14    	je cmd_rm_not_found
2114   13F8 0A DC 13    	jmp cmd_rm_L1
2115   13FB             cmd_rm_found_entry:
2116   13FB 2B 19 00    	mov b, [d + 25]			; get LBA
2117   13FE FD 79       	mov g, b				; save LBA
2118   1400 19 00       	mov al, 0
2119   1402 3E          	mov [d], al			; make file entry NULL
2120   1403 14 34 16    	mov a, [current_dirID]
2121   1406 77          	inc a				; metadata sector
2122   1407 27          	mov b, a
2123   1408 38 00 00    	mov c, 0				; reset LBA to 0
2124   140B 22 01       	mov ah, $01			; disk write
2125   140D 3B DE 28    	mov d, transient_area
2126   1410 07 4A 0B    	call IDE_write_sect		; write sector and erase file's entry in the current DIR
2127   1413 3B DE 28    	mov d, transient_area	
2128   1416 19 00       	mov al, 0
2129   1418 3E          	mov [d], al			; make file's data header NULL for re-use
2130   1419 38 00 00    	mov c, 0
2131   141C FD 27       	mov b, g				; get data header LBA
2132   141E 22 01       	mov ah, $01					; disk write 1 sect
2133   1420 07 4A 0B    	call IDE_write_sect				; write sector
2134   1423             cmd_rm_not_found:	
2135   1423 06          	sysret	
2136   1424             
2137   1424             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2138   1424             ;; mv - move / change file name
2139   1424             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2140   1424             cmd_mv:
2141   1424 FD 4E       	mov si, d
2142   1426 FD 4F DE 1C 	mov di, temp_data
2143   142A 38 00 02    	mov c, 512
2144   142D 04          	load						; load data from user-space
2145   142E 14 34 16    	mov a, [current_dirID]
2146   1431 77          	inc a						; metadata sector
2147   1432 27          	mov b, a	
2148   1433 38 00 00    	mov c, 0					; reset LBA to 0
2149   1436 22 01       	mov ah, $01				; disk read
2150   1438 3B DE 28    	mov d, transient_area
2151   143B 07 24 0B    	call IDE_read_sect		;read directory
2152   143E FD 10       	cla
2153   1440 42 2C 16    	mov [index], a				;reset file counter
2154   1443             cmd_mv_L1:
2155   1443 FD 4E       	mov si, d
2156   1445 FD 4F DE 1C 	mov di, temp_data
2157   1449 07 93 00    	call strcmp
2158   144C C6 62 14    	je cmd_mv_found_entry
2159   144F 58 20 00    	add d, 32
2160   1452 14 2C 16    	mov a, [index]
2161   1455 77          	inc a
2162   1456 42 2C 16    	mov [index], a
2163   1459 AF 10 00    	cmp a, FST_FILES_PER_DIR
2164   145C C6 94 14    	je cmd_mv_not_found
2165   145F 0A 43 14    	jmp cmd_mv_L1
2166   1462             cmd_mv_found_entry:	
2167   1462 DA          	push d
2168   1463 FD 4D 5E 1D 	mov si, temp_data + 128	; (0...127) = original filename , (128...255) = new name
2169   1467 FD 50       	mov di, d
2170   1469 07 A8 00    	call strcpy	
2171   146C 38 00 00    	mov c, 0
2172   146F 3B DE 28    	mov d, transient_area
2173   1472 22 01       	mov ah, $01					;disk write 1 sect
2174   1474 07 4A 0B    	call IDE_write_sect			;write sector
2175   1477 E7          	pop d
2176   1478             ;;;;;;;; need to check whether its a dir or a file here ;;;;;;;;;;;;;;
2177   1478 2B 19 00    	mov b, [d + 25]				; get the dirID of the directory so we can locate its own entry in the list
2178   147B 22 01       	mov ah, $01
2179   147D 3B DE 28    	mov d, transient_area
2180   1480 38 00 00    	mov c, 0
2181   1483 07 24 0B    	call IDE_read_sect			; read directory entry
2182   1486 FD 4D 5E 1D 	mov si, temp_data + 128
2183   148A FD 50       	mov di, d
2184   148C 07 A8 00    	call strcpy					; change directory's name
2185   148F 22 01       	mov ah, $01
2186   1491 07 4A 0B    	call IDE_write_sect			; rewrite directory back to disk
2187   1494             cmd_mv_not_found:
2188   1494 06          	sysret
2189   1495             
2190   1495             KERNEL_RESET_VECTOR:	
2191   1495 FD 49 FF F7 	mov bp, STACK_BEGIN
2192   1499 FD 47 FF F7 	mov sp, STACK_BEGIN
2193   149D             	
2194   149D 19 80       	mov al, %10000000
2195   149F FD 0F       	stomsk					; mask out timer interrupt for now (only allow UART to interrupt)
2196   14A1 FD 0C       	sti	
2197   14A3             
2198   14A3 0C          	lodstat
2199   14A4 87 DF       	and al, %11011111	; disable display register loading
2200   14A6 0D          	stostat
2201   14A7             	
2202   14A7             ; reset fifo pointers
2203   14A7 10 DE 1E    	mov a, fifo
2204   14AA 3B 30 16    	mov d, fifo_pi
2205   14AD 43          	mov [d], a
2206   14AE 3B 32 16    	mov d, fifo_pr
2207   14B1 43          	mov [d], a	
2208   14B2 19 02       	mov al, 2
2209   14B4 05 03       	syscall sys_io			; enable uart in interrupt mode
2210   14B6             	
2211   14B6 3B 8C 16    	mov d, s_kernel_started
2212   14B9 07 88 02    	call puts
2213   14BC             	
2214   14BC 3B B1 16    	mov d, s_prompt_init
2215   14BF 07 88 02    	call puts
2216   14C2             
2217   14C2 19 10       	mov al, 16
2218   14C4 05 04       	syscall sys_fileio		; set root dirID
2219   14C6             
2220   14C6 3B 36 16    	mov d, s_init_path
2221   14C9 05 05       	syscall sys_fork		; launch init as a new process
2222   14CB             
2223   14CB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2224   14CB             ;;; Process Index in A
2225   14CB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2226   14CB             find_free_proc:
2227   14CB FD 4D CF 18 	mov si, proc_availab_table + 1			; skip process 0 (kernel)
2228   14CF             find_free_proc_L0:
2229   14CF F6          	lodsb						; get process state
2230   14D0 B9 00       	cmp al, 0
2231   14D2 C6 D8 14    	je find_free_proc_free			; if free, jump
2232   14D5 0A CF 14    	jmp find_free_proc_L0			; else, goto next
2233   14D8             find_free_proc_free:
2234   14D8 4E          	mov a, si
2235   14D9 5F CF 18    	sub a, 1 + proc_availab_table				; get process index
2236   14DC 09          	ret
2237   14DD             	
2238   14DD             
2239   14DD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2240   14DD             ;;; Process Index in AL
2241   14DD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2242   14DD             proc_memory_map:
2243   14DD 22 00       	mov ah, 0
2244   14DF 27          	mov b, a			; page in BL, 0 in BH
2245   14E0 FD 9D 05    	shl a, 5			; multiply by 32
2246   14E3 39          	mov c, a			; save in C
2247   14E4 57 20 00    	add c, 32
2248   14E7             proc_memory_map_L0:
2249   14E7 02          	pagemap
2250   14E8 55 00 08    	add b, $0800					; increase page number (msb 5 bits of BH only)
2251   14EB 53 01 00    	add a, 1						; increase both 
2252   14EE B1          	cmp a, c						; check to see if we reached the end of memory
2253   14EF C7 E7 14    	jne proc_memory_map_L0
2254   14F2 09          	ret
2255   14F3             	
2256   14F3             
2257   14F3             cmd_terminate_proc:
2258   14F3 51 05 00    	add sp, 5		; clear stack of the values that were pushed by the interrupt (SP, Status, PC)
2259   14F6             					; since they will not be used for anything here.
2260   14F6 1D 2B 16    	mov al, [active_proc_index]
2261   14F9 22 00       	mov ah, 0	
2262   14FB FD 9D 05    	shl a, 5						; x32
2263   14FE 53 DE 18    	add a, proc_names
2264   1501 3C          	mov d, a
2265   1502 19 00       	mov al, 0
2266   1504 3E          	mov [d], al			; nullify process name
2267   1505             
2268   1505 1D 2B 16    	mov al, [active_proc_index]
2269   1508 22 00       	mov ah, 0	
2270   150A 3C          	mov d, a
2271   150B 19 00       	mov al, 0
2272   150D 3F CE 18    	mov [d + proc_availab_table], al					; make process empty again
2273   1510             	
2274   1510 1D 2A 16    	mov al, [nbr_active_procs]			; decrease nbr of active processes
2275   1513 80          	dec al
2276   1514 3D 2A 16    	mov [nbr_active_procs], al
2277   1517             
2278   1517             ; now load the shell process again
2279   1517 19 02       	mov al, 2				; next process = process 2 = shell
2280   1519 3D 2B 16    	mov [active_proc_index], al		; set next active proc
2281   151C             
2282   151C             ; calculate LUT entry for next process
2283   151C 22 00       	mov ah, 0
2284   151E FD 99       	shl a							; x2
2285   1520 B7 E9 15    	mov a, [proc_table_convert + a]		; get process state start index	
2286   1523             	
2287   1523 4D          	mov si, a						; source is proc state block
2288   1524 48          	mov a, sp
2289   1525 5F 13 00    	sub a, 19
2290   1528 4F          	mov di, a						; destination is kernel stack
2291   1529             ; restore SP
2292   1529 7D          	dec a
2293   152A 47          	mov sp, a
2294   152B 38 14 00    	mov c, 20
2295   152E FD F5       	rep movsb
2296   1530             ; set VM process
2297   1530 1D 2B 16    	mov al, [active_proc_index]
2298   1533 01          	setptb
2299   1534             		
2300   1534 4C          	popa
2301   1535 06          	sysret
2302   1536             
2303   1536             cmd_pause_proc:
2304   1536             ; save all registers into kernel stack
2305   1536 4B          	pusha
2306   1537 22 00       	mov ah, 0
2307   1539 1D 2B 16    	mov al, [active_proc_index]
2308   153C FD 99       	shl a							; x2
2309   153E B7 E9 15    	mov a, [proc_table_convert + a]	; get process state start index
2310   1541             		
2311   1541 4F          	mov di, a
2312   1542 48          	mov a, sp
2313   1543 77          	inc a
2314   1544 4D          	mov si, a
2315   1545 38 14 00    	mov c, 20
2316   1548 FD F5       	rep movsb					; save process state!
2317   154A             ; restore kernel stack position to point before interrupt arrived
2318   154A 51 14 00    	add sp, 20
2319   154D             ; now load the shell process again
2320   154D 19 02       	mov al, 2				; next process = process 2 = shell
2321   154F 3D 2B 16    	mov [active_proc_index], al		; set next active proc
2322   1552             
2323   1552             ; calculate LUT entry for next process
2324   1552 22 00       	mov ah, 0
2325   1554 FD 99       	shl a							; x2
2326   1556 B7 E9 15    	mov a, [proc_table_convert + a]		; get process state start index	
2327   1559             	
2328   1559 4D          	mov si, a						; source is proc state block
2329   155A 48          	mov a, sp
2330   155B 5F 13 00    	sub a, 19
2331   155E 4F          	mov di, a						; destination is kernel stack
2332   155F             ; restore SP
2333   155F 7D          	dec a
2334   1560 47          	mov sp, a
2335   1561 38 14 00    	mov c, 20
2336   1564 FD F5       	rep movsb
2337   1566             ; set VM process
2338   1566 1D 2B 16    	mov al, [active_proc_index]
2339   1569 01          	setptb
2340   156A             		
2341   156A 4C          	popa
2342   156B 06          	sysret
2343   156C             
2344   156C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2345   156C             ;; fork a new process
2346   156C             ;; D = path of the process file to be forked
2347   156C             ;; B = arguments ptr
2348   156C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2349   156C             cmd_fork:
2350   156C             ; we save the active process first	
2351   156C 4B          	pusha
2352   156D 22 00       	mov ah, 0
2353   156F 1D 2B 16    	mov al, [active_proc_index]
2354   1572 FD 99       	shl a							; x2
2355   1574 B7 E9 15    	mov a, [proc_table_convert + a]		; get process state table's start index
2356   1577             	
2357   1577 4F          	mov di, a
2358   1578 48          	mov a, sp
2359   1579 77          	inc a
2360   157A 4D          	mov si, a
2361   157B 38 14 00    	mov c, 20
2362   157E FD F5       	rep movsb					; save process state!
2363   1580             ; restore kernel stack position to point before interrupt arrived
2364   1580 51 14 00    	add sp, 20
2365   1583             	
2366   1583 FD 4E       	mov si, d				; copy the file path
2367   1585 FD 4F DE 1C 	mov di, temp_data
2368   1589 38 00 02    	mov c, 512
2369   158C 04          	load
2370   158D 11          	mov a, b
2371   158E 4D          	mov si, a				; copy the arguments
2372   158F FD 4F DE 26 	mov di, scrap_sector
2373   1593 38 00 02    	mov c, 512
2374   1596 04          	load
2375   1597 07 DA 0F    	call loadfile_from_path		; load the process file from disk by path (path is in temp_data)
2376   159A             								; the file data is loaded into transient_area
2377   159A             ; now we allocate a new process	
2378   159A 07 CB 14    	call find_free_proc			; index in A
2379   159D 01          	setptb
2380   159E 07 DD 14    	call proc_memory_map			; map process memory pages
2381   15A1             ; copy arguments into process's memory
2382   15A1 FD 4D DE 26 	mov si, scrap_sector
2383   15A5 FD 4F 00 00 	mov di, 0
2384   15A9 38 00 02    	mov c, 512
2385   15AC 03          	store
2386   15AD             ; now copy process binary data into process's memory
2387   15AD FD 4D DE 28 	mov si, transient_area
2388   15B1 FD 4F 00 04 	mov di, PROC_TEXT_ORG		; code origin address for all user processes
2389   15B5 38 00 40    	mov c, FS_FILE_SIZE			; size of memory space to copy, which is equal to the max file size in disk (for now)
2390   15B8 03          	store						; copy process data
2391   15B9             		
2392   15B9 07 CB 14    	call find_free_proc			; index in A
2393   15BC 3D 2B 16    	mov [active_proc_index], al		; set new active process
2394   15BF FD 9D 05    	shl a, 5						; x32
2395   15C2 53 DE 18    	add a, proc_names
2396   15C5 4F          	mov di, a
2397   15C6 FD 4D DE 1C 	mov si, temp_data			; copy and store process filename
2398   15CA 07 A8 00    	call strcpy
2399   15CD             	
2400   15CD 07 CB 14    	call find_free_proc			; index in A
2401   15D0 3C          	mov d, a
2402   15D1 19 01       	mov al, 1
2403   15D3 3F CE 18    	mov [d + proc_availab_table], al					; make process busy
2404   15D6             	
2405   15D6 1D 2A 16    	mov al, [nbr_active_procs]			; increase nbr of active processes
2406   15D9 7A          	inc al
2407   15DA 3D 2A 16    	mov [nbr_active_procs], al
2408   15DD             ; launch process
2409   15DD FD D7 FF FF 	push word $FFFF 
2410   15E1 FD DB 0E    	push byte %00001110		; dma_ack = 0, interrupts enabled = 1, mode = user, paging = on, halt=0, display_reg_load=0, dir=0
2411   15E4 FD D7 00 04 	push word PROC_TEXT_ORG
2412   15E8 06          	sysret
2413   15E9             
2414   15E9             proc_table_convert:
2415   15E9 8E 17       	.dw proc_state_table + 0
2416   15EB A2 17       	.dw proc_state_table + 20
2417   15ED B6 17       	.dw proc_state_table + 40
2418   15EF CA 17       	.dw proc_state_table + 60
2419   15F1 DE 17       	.dw proc_state_table + 80
2420   15F3 F2 17       	.dw proc_state_table + 100
2421   15F5 06 18       	.dw proc_state_table + 120
2422   15F7 1A 18       	.dw proc_state_table + 140
2423   15F9             	
2424   15F9             ; ************************************************************
2425   15F9             ; GET HEX FILE
2426   15F9             ; di = destination address
2427   15F9             ; return length in bytes in C
2428   15F9             ; ************************************************************
2429   15F9             _load_hex:
2430   15F9 D2          	push bp
2431   15FA 9B          	mov bp, sp
2432   15FB D7          	push a
2433   15FC D8          	push b
2434   15FD DA          	push d
2435   15FE E2          	push si
2436   15FF E3          	push di
2437   1600 52 00 70    	sub sp, $7000				; string data block
2438   1603 38 00 00    	mov c, 0
2439   1606 48          	mov a, sp
2440   1607 77          	inc a
2441   1608 3C          	mov d, a				; start of string data block
2442   1609 07 55 01    	call gets				; get program string
2443   160C 4D          	mov si, a
2444   160D             __load_hex_loop:
2445   160D F6          	lodsb					; load from [SI] to AL
2446   160E B9 00       	cmp al, 0				; check if ASCII 0
2447   1610 C6 1E 16    	jz __load_hex_ret
2448   1613 36          	mov bh, al
2449   1614 F6          	lodsb
2450   1615 2F          	mov bl, al
2451   1616 07 03 01    	call atoi				; convert ASCII byte in B to int (to AL)
2452   1619 F7          	stosb					; store AL to [DI]
2453   161A 78          	inc c
2454   161B 0A 0D 16    	jmp __load_hex_loop
2455   161E             __load_hex_ret:
2456   161E 51 00 70    	add sp, $7000
2457   1621 F0          	pop di
2458   1622 EF          	pop si
2459   1623 E7          	pop d
2460   1624 E5          	pop b
2461   1625 E4          	pop a
2462   1626 9C          	mov sp, bp
2463   1627 F1          	pop bp
2464   1628 09          	ret
2465   1629             
2466   1629             ; synopsis: look insIDE a certain DIRECTORY for files/directories
2467   1629             ; BEFORE CALLING THIS FUNCTION, CD INTO REQUIRED DIRECTORY
2468   1629             ; for each entry insIDE DIRECTORY:
2469   1629             ;	if entry is a file:
2470   1629             ;		compare filename to searched filename
2471   1629             ;		if filenames are the same, print filename
2472   1629             ;	else if entry is a directory:
2473   1629             ;		cd to the given directory
2474   1629             ;		recursively call cmd_find
2475   1629             ;		cd outsIDE previous directory
2476   1629             ;	if current entry == last entry, return
2477   1629             ; endfor
2478   1629             ;		
2479   1629             ;	
2480   1629             f_find:
2481   1629             	
2482   1629 09          	ret
2483   162A             
2484   162A             
2485   162A             
2486   162A 00          nbr_active_procs:	.db 0
2487   162B 01          active_proc_index:	.db 1
2488   162C             
2489   162C 00 00       index:				.dw 0
2490   162E 00 00       buffer_addr:		.dw 0
2491   1630             
2492   1630 DE 1E       fifo_pi:			.dw fifo
2493   1632 DE 1E       fifo_pr:			.dw fifo
2494   1634             
2495   1634             ; file system variables
2496   1634 00 00       current_dirID:		.dw 0				; keep dirID of current directory
2497   1636 2F 73 62 69 s_init_path:		.db "/sbin/init", 0
2497   163A 6E 2F 69 6E 
2497   163E 69 74 00 
2498   1641             
2499   1641 2E 2E 00    s_parent_dir:		.db "..", 0
2500   1644 2E 00       s_current_dir:		.db ".", 0
2501   1646 2F 00       s_fslash: 			.db "/", 0
2502   1648 20 23 20 00 s_hash:				.db " # ", 0
2503   164C 2D 72 77 20 file_attrib:		.db "-rw x"			; chars at multiples of 2
2503   1650 78 
2504   1651 2D 64 63    file_type:			.db "-dc"
2505   1654 50 49 44 20 s_ps_header:		.db "PID COMMAND\n", 0
2505   1658 43 4F 4D 4D 
2505   165C 41 4E 44 0A 
2505   1660 00 
2506   1661 53 6F 6C 2D s_host: 			.db "Sol-1:", 0
2506   1665 31 3A 00 
2507   1668 53 6F 6C 61 s_uname:			.db "Solarium\n", 0
2507   166C 72 69 75 6D 
2507   1670 0A 00 
2508   1672             
2509   1672 72 6F 6F 74 s_root:				.db "root\n", 0
2509   1676 0A 00 
2510   1678             
2511   1678 69 6E 74 65 s_int_en:			.db "interrupts enabled\n", 0
2511   167C 72 72 75 70 
2511   1680 74 73 20 65 
2511   1684 6E 61 62 6C 
2511   1688 65 64 0A 00 
2512   168C 6B 65 72 6E s_kernel_started:	.db "kernel started\n", 0
2512   1690 65 6C 20 73 
2512   1694 74 61 72 74 
2512   1698 65 64 0A 00 
2513   169C 65 6E 74 65 s_procname:			.db "enter process name: ", 0
2513   16A0 72 20 70 72 
2513   16A4 6F 63 65 73 
2513   16A8 73 20 6E 61 
2513   16AC 6D 65 3A 20 
2513   16B0 00 
2514   16B1 73 74 61 72 s_prompt_init:		.db "starting init\n", 0
2514   16B5 74 69 6E 67 
2514   16B9 20 69 6E 69 
2514   16BD 74 0A 00 
2515   16C0 0A 73 6F 66 s_priviledge:		.db "\nsoftware failure: privilege exception\n", 0
2515   16C4 74 77 61 72 
2515   16C8 65 20 66 61 
2515   16CC 69 6C 75 72 
2515   16D0 65 3A 20 70 
2515   16D4 72 69 76 69 
2515   16D8 6C 65 67 65 
2515   16DC 20 65 78 63 
2515   16E0 65 70 74 69 
2515   16E4 6F 6E 0A 00 
2516   16E8 0A 65 78 63 s_divzero:			.db "\nexception: zero division\n", 0
2516   16EC 65 70 74 69 
2516   16F0 6F 6E 3A 20 
2516   16F4 7A 65 72 6F 
2516   16F8 20 64 69 76 
2516   16FC 69 73 69 6F 
2516   1700 6E 0A 00 
2517   1703             
2518   1703 59 65 61 72 s_set_year:			.db "Year: ", 0
2518   1707 3A 20 00 
2519   170A 4D 6F 6E 74 s_set_month:		.db "Month: ", 0
2519   170E 68 3A 20 00 
2520   1712 44 61 79 3A s_set_day:			.db "Day: ", 0
2520   1716 20 00 
2521   1718 57 65 65 6B s_set_week:			.db "Weekday: ", 0
2521   171C 64 61 79 3A 
2521   1720 20 00 
2522   1722 48 6F 75 72 s_set_hours:		.db "Hours: ", 0
2522   1726 73 3A 20 00 
2523   172A 4D 69 6E 75 s_set_minutes:		.db "Minutes: ", 0
2523   172E 74 65 73 3A 
2523   1732 20 00 
2524   1734 53 65 63 6F s_set_seconds:		.db "Seconds: ", 0
2524   1738 6E 64 73 3A 
2524   173C 20 00 
2525   173E 20 20 20 00 s_months:			.db "   ", 0
2526   1742 4A 61 6E 00 					.db "Jan", 0
2527   1746 46 65 62 00 					.db "Feb", 0
2528   174A 4D 61 72 00 					.db "Mar", 0
2529   174E 41 70 72 00 					.db "Apr", 0
2530   1752 4D 61 79 00 					.db "May", 0
2531   1756 4A 75 6E 00 					.db "Jun", 0
2532   175A 4A 75 6C 00 					.db "Jul", 0
2533   175E 41 75 67 00 					.db "Aug", 0
2534   1762 53 65 70 00 					.db "Sep", 0
2535   1766 4F 63 74 00 					.db "Oct", 0
2536   176A 4E 6F 76 00 					.db "Nov", 0
2537   176E 44 65 63 00 					.db "Dec", 0
2538   1772 53 75 6E 00 s_week:				.db "Sun", 0 
2539   1776 4D 6F 6E 00 					.db "Mon", 0 
2540   177A 54 75 65 00 					.db "Tue", 0 
2541   177E 57 65 64 00 					.db "Wed", 0 
2542   1782 54 68 75 00 					.db "Thu", 0 
2543   1786 46 72 69 00 					.db "Fri", 0 
2544   178A 53 61 74 00 					.db "Sat", 0
2545   178E             
2546   178E 00 00 00 00 proc_state_table:	.fill 16 * 20, 0	; for 15 processes max
2546   1792 00 00 00 00 
2546   1796 00 00 00 00 
2546   179A 00 00 00 00 
2546   179E 00 00 00 00 
2546   17A2 00 00 00 00 
2546   17A6 00 00 00 00 
2546   17AA 00 00 00 00 
2546   17AE 00 00 00 00 
2546   17B2 00 00 00 00 
2546   17B6 00 00 00 00 
2546   17BA 00 00 00 00 
2546   17BE 00 00 00 00 
2546   17C2 00 00 00 00 
2546   17C6 00 00 00 00 
2546   17CA 00 00 00 00 
2546   17CE 00 00 00 00 
2546   17D2 00 00 00 00 
2546   17D6 00 00 00 00 
2546   17DA 00 00 00 00 
2546   17DE 00 00 00 00 
2546   17E2 00 00 00 00 
2546   17E6 00 00 00 00 
2546   17EA 00 00 00 00 
2546   17EE 00 00 00 00 
2546   17F2 00 00 00 00 
2546   17F6 00 00 00 00 
2546   17FA 00 00 00 00 
2546   17FE 00 00 00 00 
2546   1802 00 00 00 00 
2546   1806 00 00 00 00 
2546   180A 00 00 00 00 
2546   180E 00 00 00 00 
2546   1812 00 00 00 00 
2546   1816 00 00 00 00 
2546   181A 00 00 00 00 
2546   181E 00 00 00 00 
2546   1822 00 00 00 00 
2546   1826 00 00 00 00 
2546   182A 00 00 00 00 
2546   182E 00 00 00 00 
2546   1832 00 00 00 00 
2546   1836 00 00 00 00 
2546   183A 00 00 00 00 
2546   183E 00 00 00 00 
2546   1842 00 00 00 00 
2546   1846 00 00 00 00 
2546   184A 00 00 00 00 
2546   184E 00 00 00 00 
2546   1852 00 00 00 00 
2546   1856 00 00 00 00 
2546   185A 00 00 00 00 
2546   185E 00 00 00 00 
2546   1862 00 00 00 00 
2546   1866 00 00 00 00 
2546   186A 00 00 00 00 
2546   186E 00 00 00 00 
2546   1872 00 00 00 00 
2546   1876 00 00 00 00 
2546   187A 00 00 00 00 
2546   187E 00 00 00 00 
2546   1882 00 00 00 00 
2546   1886 00 00 00 00 
2546   188A 00 00 00 00 
2546   188E 00 00 00 00 
2546   1892 00 00 00 00 
2546   1896 00 00 00 00 
2546   189A 00 00 00 00 
2546   189E 00 00 00 00 
2546   18A2 00 00 00 00 
2546   18A6 00 00 00 00 
2546   18AA 00 00 00 00 
2546   18AE 00 00 00 00 
2546   18B2 00 00 00 00 
2546   18B6 00 00 00 00 
2546   18BA 00 00 00 00 
2546   18BE 00 00 00 00 
2546   18C2 00 00 00 00 
2546   18C6 00 00 00 00 
2546   18CA 00 00 00 00 
2547   18CE 00 00 00 00 proc_availab_table:	.fill 16, 0			; space for 15 processes. 0 = process empty, 1 = process taken
2547   18D2 00 00 00 00 
2547   18D6 00 00 00 00 
2547   18DA 00 00 00 00 
2548   18DE 00 00 00 00 proc_names:			.fill 16 * 32, 0	; process names
2548   18E2 00 00 00 00 
2548   18E6 00 00 00 00 
2548   18EA 00 00 00 00 
2548   18EE 00 00 00 00 
2548   18F2 00 00 00 00 
2548   18F6 00 00 00 00 
2548   18FA 00 00 00 00 
2548   18FE 00 00 00 00 
2548   1902 00 00 00 00 
2548   1906 00 00 00 00 
2548   190A 00 00 00 00 
2548   190E 00 00 00 00 
2548   1912 00 00 00 00 
2548   1916 00 00 00 00 
2548   191A 00 00 00 00 
2548   191E 00 00 00 00 
2548   1922 00 00 00 00 
2548   1926 00 00 00 00 
2548   192A 00 00 00 00 
2548   192E 00 00 00 00 
2548   1932 00 00 00 00 
2548   1936 00 00 00 00 
2548   193A 00 00 00 00 
2548   193E 00 00 00 00 
2548   1942 00 00 00 00 
2548   1946 00 00 00 00 
2548   194A 00 00 00 00 
2548   194E 00 00 00 00 
2548   1952 00 00 00 00 
2548   1956 00 00 00 00 
2548   195A 00 00 00 00 
2548   195E 00 00 00 00 
2548   1962 00 00 00 00 
2548   1966 00 00 00 00 
2548   196A 00 00 00 00 
2548   196E 00 00 00 00 
2548   1972 00 00 00 00 
2548   1976 00 00 00 00 
2548   197A 00 00 00 00 
2548   197E 00 00 00 00 
2548   1982 00 00 00 00 
2548   1986 00 00 00 00 
2548   198A 00 00 00 00 
2548   198E 00 00 00 00 
2548   1992 00 00 00 00 
2548   1996 00 00 00 00 
2548   199A 00 00 00 00 
2548   199E 00 00 00 00 
2548   19A2 00 00 00 00 
2548   19A6 00 00 00 00 
2548   19AA 00 00 00 00 
2548   19AE 00 00 00 00 
2548   19B2 00 00 00 00 
2548   19B6 00 00 00 00 
2548   19BA 00 00 00 00 
2548   19BE 00 00 00 00 
2548   19C2 00 00 00 00 
2548   19C6 00 00 00 00 
2548   19CA 00 00 00 00 
2548   19CE 00 00 00 00 
2548   19D2 00 00 00 00 
2548   19D6 00 00 00 00 
2548   19DA 00 00 00 00 
2548   19DE 00 00 00 00 
2548   19E2 00 00 00 00 
2548   19E6 00 00 00 00 
2548   19EA 00 00 00 00 
2548   19EE 00 00 00 00 
2548   19F2 00 00 00 00 
2548   19F6 00 00 00 00 
2548   19FA 00 00 00 00 
2548   19FE 00 00 00 00 
2548   1A02 00 00 00 00 
2548   1A06 00 00 00 00 
2548   1A0A 00 00 00 00 
2548   1A0E 00 00 00 00 
2548   1A12 00 00 00 00 
2548   1A16 00 00 00 00 
2548   1A1A 00 00 00 00 
2548   1A1E 00 00 00 00 
2548   1A22 00 00 00 00 
2548   1A26 00 00 00 00 
2548   1A2A 00 00 00 00 
2548   1A2E 00 00 00 00 
2548   1A32 00 00 00 00 
2548   1A36 00 00 00 00 
2548   1A3A 00 00 00 00 
2548   1A3E 00 00 00 00 
2548   1A42 00 00 00 00 
2548   1A46 00 00 00 00 
2548   1A4A 00 00 00 00 
2548   1A4E 00 00 00 00 
2548   1A52 00 00 00 00 
2548   1A56 00 00 00 00 
2548   1A5A 00 00 00 00 
2548   1A5E 00 00 00 00 
2548   1A62 00 00 00 00 
2548   1A66 00 00 00 00 
2548   1A6A 00 00 00 00 
2548   1A6E 00 00 00 00 
2548   1A72 00 00 00 00 
2548   1A76 00 00 00 00 
2548   1A7A 00 00 00 00 
2548   1A7E 00 00 00 00 
2548   1A82 00 00 00 00 
2548   1A86 00 00 00 00 
2548   1A8A 00 00 00 00 
2548   1A8E 00 00 00 00 
2548   1A92 00 00 00 00 
2548   1A96 00 00 00 00 
2548   1A9A 00 00 00 00 
2548   1A9E 00 00 00 00 
2548   1AA2 00 00 00 00 
2548   1AA6 00 00 00 00 
2548   1AAA 00 00 00 00 
2548   1AAE 00 00 00 00 
2548   1AB2 00 00 00 00 
2548   1AB6 00 00 00 00 
2548   1ABA 00 00 00 00 
2548   1ABE 00 00 00 00 
2548   1AC2 00 00 00 00 
2548   1AC6 00 00 00 00 
2548   1ACA 00 00 00 00 
2548   1ACE 00 00 00 00 
2548   1AD2 00 00 00 00 
2548   1AD6 00 00 00 00 
2548   1ADA 00 00 00 00 
2549   1ADE 00 00 00 00 filename:			.fill 512, 0		; holds a path for file search
2549   1AE2 00 00 00 00 
2549   1AE6 00 00 00 00 
2549   1AEA 00 00 00 00 
2549   1AEE 00 00 00 00 
2549   1AF2 00 00 00 00 
2549   1AF6 00 00 00 00 
2549   1AFA 00 00 00 00 
2549   1AFE 00 00 00 00 
2549   1B02 00 00 00 00 
2549   1B06 00 00 00 00 
2549   1B0A 00 00 00 00 
2549   1B0E 00 00 00 00 
2549   1B12 00 00 00 00 
2549   1B16 00 00 00 00 
2549   1B1A 00 00 00 00 
2549   1B1E 00 00 00 00 
2549   1B22 00 00 00 00 
2549   1B26 00 00 00 00 
2549   1B2A 00 00 00 00 
2549   1B2E 00 00 00 00 
2549   1B32 00 00 00 00 
2549   1B36 00 00 00 00 
2549   1B3A 00 00 00 00 
2549   1B3E 00 00 00 00 
2549   1B42 00 00 00 00 
2549   1B46 00 00 00 00 
2549   1B4A 00 00 00 00 
2549   1B4E 00 00 00 00 
2549   1B52 00 00 00 00 
2549   1B56 00 00 00 00 
2549   1B5A 00 00 00 00 
2549   1B5E 00 00 00 00 
2549   1B62 00 00 00 00 
2549   1B66 00 00 00 00 
2549   1B6A 00 00 00 00 
2549   1B6E 00 00 00 00 
2549   1B72 00 00 00 00 
2549   1B76 00 00 00 00 
2549   1B7A 00 00 00 00 
2549   1B7E 00 00 00 00 
2549   1B82 00 00 00 00 
2549   1B86 00 00 00 00 
2549   1B8A 00 00 00 00 
2549   1B8E 00 00 00 00 
2549   1B92 00 00 00 00 
2549   1B96 00 00 00 00 
2549   1B9A 00 00 00 00 
2549   1B9E 00 00 00 00 
2549   1BA2 00 00 00 00 
2549   1BA6 00 00 00 00 
2549   1BAA 00 00 00 00 
2549   1BAE 00 00 00 00 
2549   1BB2 00 00 00 00 
2549   1BB6 00 00 00 00 
2549   1BBA 00 00 00 00 
2549   1BBE 00 00 00 00 
2549   1BC2 00 00 00 00 
2549   1BC6 00 00 00 00 
2549   1BCA 00 00 00 00 
2549   1BCE 00 00 00 00 
2549   1BD2 00 00 00 00 
2549   1BD6 00 00 00 00 
2549   1BDA 00 00 00 00 
2549   1BDE 00 00 00 00 
2549   1BE2 00 00 00 00 
2549   1BE6 00 00 00 00 
2549   1BEA 00 00 00 00 
2549   1BEE 00 00 00 00 
2549   1BF2 00 00 00 00 
2549   1BF6 00 00 00 00 
2549   1BFA 00 00 00 00 
2549   1BFE 00 00 00 00 
2549   1C02 00 00 00 00 
2549   1C06 00 00 00 00 
2549   1C0A 00 00 00 00 
2549   1C0E 00 00 00 00 
2549   1C12 00 00 00 00 
2549   1C16 00 00 00 00 
2549   1C1A 00 00 00 00 
2549   1C1E 00 00 00 00 
2549   1C22 00 00 00 00 
2549   1C26 00 00 00 00 
2549   1C2A 00 00 00 00 
2549   1C2E 00 00 00 00 
2549   1C32 00 00 00 00 
2549   1C36 00 00 00 00 
2549   1C3A 00 00 00 00 
2549   1C3E 00 00 00 00 
2549   1C42 00 00 00 00 
2549   1C46 00 00 00 00 
2549   1C4A 00 00 00 00 
2549   1C4E 00 00 00 00 
2549   1C52 00 00 00 00 
2549   1C56 00 00 00 00 
2549   1C5A 00 00 00 00 
2549   1C5E 00 00 00 00 
2549   1C62 00 00 00 00 
2549   1C66 00 00 00 00 
2549   1C6A 00 00 00 00 
2549   1C6E 00 00 00 00 
2549   1C72 00 00 00 00 
2549   1C76 00 00 00 00 
2549   1C7A 00 00 00 00 
2549   1C7E 00 00 00 00 
2549   1C82 00 00 00 00 
2549   1C86 00 00 00 00 
2549   1C8A 00 00 00 00 
2549   1C8E 00 00 00 00 
2549   1C92 00 00 00 00 
2549   1C96 00 00 00 00 
2549   1C9A 00 00 00 00 
2549   1C9E 00 00 00 00 
2549   1CA2 00 00 00 00 
2549   1CA6 00 00 00 00 
2549   1CAA 00 00 00 00 
2549   1CAE 00 00 00 00 
2549   1CB2 00 00 00 00 
2549   1CB6 00 00 00 00 
2549   1CBA 00 00 00 00 
2549   1CBE 00 00 00 00 
2549   1CC2 00 00 00 00 
2549   1CC6 00 00 00 00 
2549   1CCA 00 00 00 00 
2549   1CCE 00 00 00 00 
2549   1CD2 00 00 00 00 
2549   1CD6 00 00 00 00 
2549   1CDA 00 00 00 00 
2550   1CDE 00 00 00 00 temp_data:			.fill 512, 0   		;  user space data
2550   1CE2 00 00 00 00 
2550   1CE6 00 00 00 00 
2550   1CEA 00 00 00 00 
2550   1CEE 00 00 00 00 
2550   1CF2 00 00 00 00 
2550   1CF6 00 00 00 00 
2550   1CFA 00 00 00 00 
2550   1CFE 00 00 00 00 
2550   1D02 00 00 00 00 
2550   1D06 00 00 00 00 
2550   1D0A 00 00 00 00 
2550   1D0E 00 00 00 00 
2550   1D12 00 00 00 00 
2550   1D16 00 00 00 00 
2550   1D1A 00 00 00 00 
2550   1D1E 00 00 00 00 
2550   1D22 00 00 00 00 
2550   1D26 00 00 00 00 
2550   1D2A 00 00 00 00 
2550   1D2E 00 00 00 00 
2550   1D32 00 00 00 00 
2550   1D36 00 00 00 00 
2550   1D3A 00 00 00 00 
2550   1D3E 00 00 00 00 
2550   1D42 00 00 00 00 
2550   1D46 00 00 00 00 
2550   1D4A 00 00 00 00 
2550   1D4E 00 00 00 00 
2550   1D52 00 00 00 00 
2550   1D56 00 00 00 00 
2550   1D5A 00 00 00 00 
2550   1D5E 00 00 00 00 
2550   1D62 00 00 00 00 
2550   1D66 00 00 00 00 
2550   1D6A 00 00 00 00 
2550   1D6E 00 00 00 00 
2550   1D72 00 00 00 00 
2550   1D76 00 00 00 00 
2550   1D7A 00 00 00 00 
2550   1D7E 00 00 00 00 
2550   1D82 00 00 00 00 
2550   1D86 00 00 00 00 
2550   1D8A 00 00 00 00 
2550   1D8E 00 00 00 00 
2550   1D92 00 00 00 00 
2550   1D96 00 00 00 00 
2550   1D9A 00 00 00 00 
2550   1D9E 00 00 00 00 
2550   1DA2 00 00 00 00 
2550   1DA6 00 00 00 00 
2550   1DAA 00 00 00 00 
2550   1DAE 00 00 00 00 
2550   1DB2 00 00 00 00 
2550   1DB6 00 00 00 00 
2550   1DBA 00 00 00 00 
2550   1DBE 00 00 00 00 
2550   1DC2 00 00 00 00 
2550   1DC6 00 00 00 00 
2550   1DCA 00 00 00 00 
2550   1DCE 00 00 00 00 
2550   1DD2 00 00 00 00 
2550   1DD6 00 00 00 00 
2550   1DDA 00 00 00 00 
2550   1DDE 00 00 00 00 
2550   1DE2 00 00 00 00 
2550   1DE6 00 00 00 00 
2550   1DEA 00 00 00 00 
2550   1DEE 00 00 00 00 
2550   1DF2 00 00 00 00 
2550   1DF6 00 00 00 00 
2550   1DFA 00 00 00 00 
2550   1DFE 00 00 00 00 
2550   1E02 00 00 00 00 
2550   1E06 00 00 00 00 
2550   1E0A 00 00 00 00 
2550   1E0E 00 00 00 00 
2550   1E12 00 00 00 00 
2550   1E16 00 00 00 00 
2550   1E1A 00 00 00 00 
2550   1E1E 00 00 00 00 
2550   1E22 00 00 00 00 
2550   1E26 00 00 00 00 
2550   1E2A 00 00 00 00 
2550   1E2E 00 00 00 00 
2550   1E32 00 00 00 00 
2550   1E36 00 00 00 00 
2550   1E3A 00 00 00 00 
2550   1E3E 00 00 00 00 
2550   1E42 00 00 00 00 
2550   1E46 00 00 00 00 
2550   1E4A 00 00 00 00 
2550   1E4E 00 00 00 00 
2550   1E52 00 00 00 00 
2550   1E56 00 00 00 00 
2550   1E5A 00 00 00 00 
2550   1E5E 00 00 00 00 
2550   1E62 00 00 00 00 
2550   1E66 00 00 00 00 
2550   1E6A 00 00 00 00 
2550   1E6E 00 00 00 00 
2550   1E72 00 00 00 00 
2550   1E76 00 00 00 00 
2550   1E7A 00 00 00 00 
2550   1E7E 00 00 00 00 
2550   1E82 00 00 00 00 
2550   1E86 00 00 00 00 
2550   1E8A 00 00 00 00 
2550   1E8E 00 00 00 00 
2550   1E92 00 00 00 00 
2550   1E96 00 00 00 00 
2550   1E9A 00 00 00 00 
2550   1E9E 00 00 00 00 
2550   1EA2 00 00 00 00 
2550   1EA6 00 00 00 00 
2550   1EAA 00 00 00 00 
2550   1EAE 00 00 00 00 
2550   1EB2 00 00 00 00 
2550   1EB6 00 00 00 00 
2550   1EBA 00 00 00 00 
2550   1EBE 00 00 00 00 
2550   1EC2 00 00 00 00 
2550   1EC6 00 00 00 00 
2550   1ECA 00 00 00 00 
2550   1ECE 00 00 00 00 
2550   1ED2 00 00 00 00 
2550   1ED6 00 00 00 00 
2550   1EDA 00 00 00 00 
2551   1EDE FF FF FF FF fifo:				.fill FIFO_SIZE
2551   1EE2 FF FF FF FF 
2551   1EE6 FF FF FF FF 
2551   1EEA FF FF FF FF 
2551   1EEE FF FF FF FF 
2551   1EF2 FF FF FF FF 
2551   1EF6 FF FF FF FF 
2551   1EFA FF FF FF FF 
2551   1EFE FF FF FF FF 
2551   1F02 FF FF FF FF 
2551   1F06 FF FF FF FF 
2551   1F0A FF FF FF FF 
2551   1F0E FF FF FF FF 
2551   1F12 FF FF FF FF 
2551   1F16 FF FF FF FF 
2551   1F1A FF FF FF FF 
2551   1F1E FF FF FF FF 
2551   1F22 FF FF FF FF 
2551   1F26 FF FF FF FF 
2551   1F2A FF FF FF FF 
2551   1F2E FF FF FF FF 
2551   1F32 FF FF FF FF 
2551   1F36 FF FF FF FF 
2551   1F3A FF FF FF FF 
2551   1F3E FF FF FF FF 
2551   1F42 FF FF FF FF 
2551   1F46 FF FF FF FF 
2551   1F4A FF FF FF FF 
2551   1F4E FF FF FF FF 
2551   1F52 FF FF FF FF 
2551   1F56 FF FF FF FF 
2551   1F5A FF FF FF FF 
2551   1F5E FF FF FF FF 
2551   1F62 FF FF FF FF 
2551   1F66 FF FF FF FF 
2551   1F6A FF FF FF FF 
2551   1F6E FF FF FF FF 
2551   1F72 FF FF FF FF 
2551   1F76 FF FF FF FF 
2551   1F7A FF FF FF FF 
2551   1F7E FF FF FF FF 
2551   1F82 FF FF FF FF 
2551   1F86 FF FF FF FF 
2551   1F8A FF FF FF FF 
2551   1F8E FF FF FF FF 
2551   1F92 FF FF FF FF 
2551   1F96 FF FF FF FF 
2551   1F9A FF FF FF FF 
2551   1F9E FF FF FF FF 
2551   1FA2 FF FF FF FF 
2551   1FA6 FF FF FF FF 
2551   1FAA FF FF FF FF 
2551   1FAE FF FF FF FF 
2551   1FB2 FF FF FF FF 
2551   1FB6 FF FF FF FF 
2551   1FBA FF FF FF FF 
2551   1FBE FF FF FF FF 
2551   1FC2 FF FF FF FF 
2551   1FC6 FF FF FF FF 
2551   1FCA FF FF FF FF 
2551   1FCE FF FF FF FF 
2551   1FD2 FF FF FF FF 
2551   1FD6 FF FF FF FF 
2551   1FDA FF FF FF FF 
2551   1FDE FF FF FF FF 
2551   1FE2 FF FF FF FF 
2551   1FE6 FF FF FF FF 
2551   1FEA FF FF FF FF 
2551   1FEE FF FF FF FF 
2551   1FF2 FF FF FF FF 
2551   1FF6 FF FF FF FF 
2551   1FFA FF FF FF FF 
2551   1FFE FF FF FF FF 
2551   2002 FF FF FF FF 
2551   2006 FF FF FF FF 
2551   200A FF FF FF FF 
2551   200E FF FF FF FF 
2551   2012 FF FF FF FF 
2551   2016 FF FF FF FF 
2551   201A FF FF FF FF 
2551   201E FF FF FF FF 
2551   2022 FF FF FF FF 
2551   2026 FF FF FF FF 
2551   202A FF FF FF FF 
2551   202E FF FF FF FF 
2551   2032 FF FF FF FF 
2551   2036 FF FF FF FF 
2551   203A FF FF FF FF 
2551   203E FF FF FF FF 
2551   2042 FF FF FF FF 
2551   2046 FF FF FF FF 
2551   204A FF FF FF FF 
2551   204E FF FF FF FF 
2551   2052 FF FF FF FF 
2551   2056 FF FF FF FF 
2551   205A FF FF FF FF 
2551   205E FF FF FF FF 
2551   2062 FF FF FF FF 
2551   2066 FF FF FF FF 
2551   206A FF FF FF FF 
2551   206E FF FF FF FF 
2551   2072 FF FF FF FF 
2551   2076 FF FF FF FF 
2551   207A FF FF FF FF 
2551   207E FF FF FF FF 
2551   2082 FF FF FF FF 
2551   2086 FF FF FF FF 
2551   208A FF FF FF FF 
2551   208E FF FF FF FF 
2551   2092 FF FF FF FF 
2551   2096 FF FF FF FF 
2551   209A FF FF FF FF 
2551   209E FF FF FF FF 
2551   20A2 FF FF FF FF 
2551   20A6 FF FF FF FF 
2551   20AA FF FF FF FF 
2551   20AE FF FF FF FF 
2551   20B2 FF FF FF FF 
2551   20B6 FF FF FF FF 
2551   20BA FF FF FF FF 
2551   20BE FF FF FF FF 
2551   20C2 FF FF FF FF 
2551   20C6 FF FF FF FF 
2551   20CA FF FF FF FF 
2551   20CE FF FF FF FF 
2551   20D2 FF FF FF FF 
2551   20D6 FF FF FF FF 
2551   20DA FF FF FF FF 
2551   20DE FF FF FF FF 
2551   20E2 FF FF FF FF 
2551   20E6 FF FF FF FF 
2551   20EA FF FF FF FF 
2551   20EE FF FF FF FF 
2551   20F2 FF FF FF FF 
2551   20F6 FF FF FF FF 
2551   20FA FF FF FF FF 
2551   20FE FF FF FF FF 
2551   2102 FF FF FF FF 
2551   2106 FF FF FF FF 
2551   210A FF FF FF FF 
2551   210E FF FF FF FF 
2551   2112 FF FF FF FF 
2551   2116 FF FF FF FF 
2551   211A FF FF FF FF 
2551   211E FF FF FF FF 
2551   2122 FF FF FF FF 
2551   2126 FF FF FF FF 
2551   212A FF FF FF FF 
2551   212E FF FF FF FF 
2551   2132 FF FF FF FF 
2551   2136 FF FF FF FF 
2551   213A FF FF FF FF 
2551   213E FF FF FF FF 
2551   2142 FF FF FF FF 
2551   2146 FF FF FF FF 
2551   214A FF FF FF FF 
2551   214E FF FF FF FF 
2551   2152 FF FF FF FF 
2551   2156 FF FF FF FF 
2551   215A FF FF FF FF 
2551   215E FF FF FF FF 
2551   2162 FF FF FF FF 
2551   2166 FF FF FF FF 
2551   216A FF FF FF FF 
2551   216E FF FF FF FF 
2551   2172 FF FF FF FF 
2551   2176 FF FF FF FF 
2551   217A FF FF FF FF 
2551   217E FF FF FF FF 
2551   2182 FF FF FF FF 
2551   2186 FF FF FF FF 
2551   218A FF FF FF FF 
2551   218E FF FF FF FF 
2551   2192 FF FF FF FF 
2551   2196 FF FF FF FF 
2551   219A FF FF FF FF 
2551   219E FF FF FF FF 
2551   21A2 FF FF FF FF 
2551   21A6 FF FF FF FF 
2551   21AA FF FF FF FF 
2551   21AE FF FF FF FF 
2551   21B2 FF FF FF FF 
2551   21B6 FF FF FF FF 
2551   21BA FF FF FF FF 
2551   21BE FF FF FF FF 
2551   21C2 FF FF FF FF 
2551   21C6 FF FF FF FF 
2551   21CA FF FF FF FF 
2551   21CE FF FF FF FF 
2551   21D2 FF FF FF FF 
2551   21D6 FF FF FF FF 
2551   21DA FF FF FF FF 
2551   21DE FF FF FF FF 
2551   21E2 FF FF FF FF 
2551   21E6 FF FF FF FF 
2551   21EA FF FF FF FF 
2551   21EE FF FF FF FF 
2551   21F2 FF FF FF FF 
2551   21F6 FF FF FF FF 
2551   21FA FF FF FF FF 
2551   21FE FF FF FF FF 
2551   2202 FF FF FF FF 
2551   2206 FF FF FF FF 
2551   220A FF FF FF FF 
2551   220E FF FF FF FF 
2551   2212 FF FF FF FF 
2551   2216 FF FF FF FF 
2551   221A FF FF FF FF 
2551   221E FF FF FF FF 
2551   2222 FF FF FF FF 
2551   2226 FF FF FF FF 
2551   222A FF FF FF FF 
2551   222E FF FF FF FF 
2551   2232 FF FF FF FF 
2551   2236 FF FF FF FF 
2551   223A FF FF FF FF 
2551   223E FF FF FF FF 
2551   2242 FF FF FF FF 
2551   2246 FF FF FF FF 
2551   224A FF FF FF FF 
2551   224E FF FF FF FF 
2551   2252 FF FF FF FF 
2551   2256 FF FF FF FF 
2551   225A FF FF FF FF 
2551   225E FF FF FF FF 
2551   2262 FF FF FF FF 
2551   2266 FF FF FF FF 
2551   226A FF FF FF FF 
2551   226E FF FF FF FF 
2551   2272 FF FF FF FF 
2551   2276 FF FF FF FF 
2551   227A FF FF FF FF 
2551   227E FF FF FF FF 
2551   2282 FF FF FF FF 
2551   2286 FF FF FF FF 
2551   228A FF FF FF FF 
2551   228E FF FF FF FF 
2551   2292 FF FF FF FF 
2551   2296 FF FF FF FF 
2551   229A FF FF FF FF 
2551   229E FF FF FF FF 
2551   22A2 FF FF FF FF 
2551   22A6 FF FF FF FF 
2551   22AA FF FF FF FF 
2551   22AE FF FF FF FF 
2551   22B2 FF FF FF FF 
2551   22B6 FF FF FF FF 
2551   22BA FF FF FF FF 
2551   22BE FF FF FF FF 
2551   22C2 FF FF FF FF 
2551   22C6 FF FF FF FF 
2551   22CA FF FF FF FF 
2551   22CE FF FF FF FF 
2551   22D2 FF FF FF FF 
2551   22D6 FF FF FF FF 
2551   22DA FF FF FF FF 
2551   22DE FF FF FF FF 
2551   22E2 FF FF FF FF 
2551   22E6 FF FF FF FF 
2551   22EA FF FF FF FF 
2551   22EE FF FF FF FF 
2551   22F2 FF FF FF FF 
2551   22F6 FF FF FF FF 
2551   22FA FF FF FF FF 
2551   22FE FF FF FF FF 
2551   2302 FF FF FF FF 
2551   2306 FF FF FF FF 
2551   230A FF FF FF FF 
2551   230E FF FF FF FF 
2551   2312 FF FF FF FF 
2551   2316 FF FF FF FF 
2551   231A FF FF FF FF 
2551   231E FF FF FF FF 
2551   2322 FF FF FF FF 
2551   2326 FF FF FF FF 
2551   232A FF FF FF FF 
2551   232E FF FF FF FF 
2551   2332 FF FF FF FF 
2551   2336 FF FF FF FF 
2551   233A FF FF FF FF 
2551   233E FF FF FF FF 
2551   2342 FF FF FF FF 
2551   2346 FF FF FF FF 
2551   234A FF FF FF FF 
2551   234E FF FF FF FF 
2551   2352 FF FF FF FF 
2551   2356 FF FF FF FF 
2551   235A FF FF FF FF 
2551   235E FF FF FF FF 
2551   2362 FF FF FF FF 
2551   2366 FF FF FF FF 
2551   236A FF FF FF FF 
2551   236E FF FF FF FF 
2551   2372 FF FF FF FF 
2551   2376 FF FF FF FF 
2551   237A FF FF FF FF 
2551   237E FF FF FF FF 
2551   2382 FF FF FF FF 
2551   2386 FF FF FF FF 
2551   238A FF FF FF FF 
2551   238E FF FF FF FF 
2551   2392 FF FF FF FF 
2551   2396 FF FF FF FF 
2551   239A FF FF FF FF 
2551   239E FF FF FF FF 
2551   23A2 FF FF FF FF 
2551   23A6 FF FF FF FF 
2551   23AA FF FF FF FF 
2551   23AE FF FF FF FF 
2551   23B2 FF FF FF FF 
2551   23B6 FF FF FF FF 
2551   23BA FF FF FF FF 
2551   23BE FF FF FF FF 
2551   23C2 FF FF FF FF 
2551   23C6 FF FF FF FF 
2551   23CA FF FF FF FF 
2551   23CE FF FF FF FF 
2551   23D2 FF FF FF FF 
2551   23D6 FF FF FF FF 
2551   23DA FF FF FF FF 
2551   23DE FF FF FF FF 
2551   23E2 FF FF FF FF 
2551   23E6 FF FF FF FF 
2551   23EA FF FF FF FF 
2551   23EE FF FF FF FF 
2551   23F2 FF FF FF FF 
2551   23F6 FF FF FF FF 
2551   23FA FF FF FF FF 
2551   23FE FF FF FF FF 
2551   2402 FF FF FF FF 
2551   2406 FF FF FF FF 
2551   240A FF FF FF FF 
2551   240E FF FF FF FF 
2551   2412 FF FF FF FF 
2551   2416 FF FF FF FF 
2551   241A FF FF FF FF 
2551   241E FF FF FF FF 
2551   2422 FF FF FF FF 
2551   2426 FF FF FF FF 
2551   242A FF FF FF FF 
2551   242E FF FF FF FF 
2551   2432 FF FF FF FF 
2551   2436 FF FF FF FF 
2551   243A FF FF FF FF 
2551   243E FF FF FF FF 
2551   2442 FF FF FF FF 
2551   2446 FF FF FF FF 
2551   244A FF FF FF FF 
2551   244E FF FF FF FF 
2551   2452 FF FF FF FF 
2551   2456 FF FF FF FF 
2551   245A FF FF FF FF 
2551   245E FF FF FF FF 
2551   2462 FF FF FF FF 
2551   2466 FF FF FF FF 
2551   246A FF FF FF FF 
2551   246E FF FF FF FF 
2551   2472 FF FF FF FF 
2551   2476 FF FF FF FF 
2551   247A FF FF FF FF 
2551   247E FF FF FF FF 
2551   2482 FF FF FF FF 
2551   2486 FF FF FF FF 
2551   248A FF FF FF FF 
2551   248E FF FF FF FF 
2551   2492 FF FF FF FF 
2551   2496 FF FF FF FF 
2551   249A FF FF FF FF 
2551   249E FF FF FF FF 
2551   24A2 FF FF FF FF 
2551   24A6 FF FF FF FF 
2551   24AA FF FF FF FF 
2551   24AE FF FF FF FF 
2551   24B2 FF FF FF FF 
2551   24B6 FF FF FF FF 
2551   24BA FF FF FF FF 
2551   24BE FF FF FF FF 
2551   24C2 FF FF FF FF 
2551   24C6 FF FF FF FF 
2551   24CA FF FF FF FF 
2551   24CE FF FF FF FF 
2551   24D2 FF FF FF FF 
2551   24D6 FF FF FF FF 
2551   24DA FF FF FF FF 
2551   24DE FF FF FF FF 
2551   24E2 FF FF FF FF 
2551   24E6 FF FF FF FF 
2551   24EA FF FF FF FF 
2551   24EE FF FF FF FF 
2551   24F2 FF FF FF FF 
2551   24F6 FF FF FF FF 
2551   24FA FF FF FF FF 
2551   24FE FF FF FF FF 
2551   2502 FF FF FF FF 
2551   2506 FF FF FF FF 
2551   250A FF FF FF FF 
2551   250E FF FF FF FF 
2551   2512 FF FF FF FF 
2551   2516 FF FF FF FF 
2551   251A FF FF FF FF 
2551   251E FF FF FF FF 
2551   2522 FF FF FF FF 
2551   2526 FF FF FF FF 
2551   252A FF FF FF FF 
2551   252E FF FF FF FF 
2551   2532 FF FF FF FF 
2551   2536 FF FF FF FF 
2551   253A FF FF FF FF 
2551   253E FF FF FF FF 
2551   2542 FF FF FF FF 
2551   2546 FF FF FF FF 
2551   254A FF FF FF FF 
2551   254E FF FF FF FF 
2551   2552 FF FF FF FF 
2551   2556 FF FF FF FF 
2551   255A FF FF FF FF 
2551   255E FF FF FF FF 
2551   2562 FF FF FF FF 
2551   2566 FF FF FF FF 
2551   256A FF FF FF FF 
2551   256E FF FF FF FF 
2551   2572 FF FF FF FF 
2551   2576 FF FF FF FF 
2551   257A FF FF FF FF 
2551   257E FF FF FF FF 
2551   2582 FF FF FF FF 
2551   2586 FF FF FF FF 
2551   258A FF FF FF FF 
2551   258E FF FF FF FF 
2551   2592 FF FF FF FF 
2551   2596 FF FF FF FF 
2551   259A FF FF FF FF 
2551   259E FF FF FF FF 
2551   25A2 FF FF FF FF 
2551   25A6 FF FF FF FF 
2551   25AA FF FF FF FF 
2551   25AE FF FF FF FF 
2551   25B2 FF FF FF FF 
2551   25B6 FF FF FF FF 
2551   25BA FF FF FF FF 
2551   25BE FF FF FF FF 
2551   25C2 FF FF FF FF 
2551   25C6 FF FF FF FF 
2551   25CA FF FF FF FF 
2551   25CE FF FF FF FF 
2551   25D2 FF FF FF FF 
2551   25D6 FF FF FF FF 
2551   25DA FF FF FF FF 
2551   25DE FF FF FF FF 
2551   25E2 FF FF FF FF 
2551   25E6 FF FF FF FF 
2551   25EA FF FF FF FF 
2551   25EE FF FF FF FF 
2551   25F2 FF FF FF FF 
2551   25F6 FF FF FF FF 
2551   25FA FF FF FF FF 
2551   25FE FF FF FF FF 
2551   2602 FF FF FF FF 
2551   2606 FF FF FF FF 
2551   260A FF FF FF FF 
2551   260E FF FF FF FF 
2551   2612 FF FF FF FF 
2551   2616 FF FF FF FF 
2551   261A FF FF FF FF 
2551   261E FF FF FF FF 
2551   2622 FF FF FF FF 
2551   2626 FF FF FF FF 
2551   262A FF FF FF FF 
2551   262E FF FF FF FF 
2551   2632 FF FF FF FF 
2551   2636 FF FF FF FF 
2551   263A FF FF FF FF 
2551   263E FF FF FF FF 
2551   2642 FF FF FF FF 
2551   2646 FF FF FF FF 
2551   264A FF FF FF FF 
2551   264E FF FF FF FF 
2551   2652 FF FF FF FF 
2551   2656 FF FF FF FF 
2551   265A FF FF FF FF 
2551   265E FF FF FF FF 
2551   2662 FF FF FF FF 
2551   2666 FF FF FF FF 
2551   266A FF FF FF FF 
2551   266E FF FF FF FF 
2551   2672 FF FF FF FF 
2551   2676 FF FF FF FF 
2551   267A FF FF FF FF 
2551   267E FF FF FF FF 
2551   2682 FF FF FF FF 
2551   2686 FF FF FF FF 
2551   268A FF FF FF FF 
2551   268E FF FF FF FF 
2551   2692 FF FF FF FF 
2551   2696 FF FF FF FF 
2551   269A FF FF FF FF 
2551   269E FF FF FF FF 
2551   26A2 FF FF FF FF 
2551   26A6 FF FF FF FF 
2551   26AA FF FF FF FF 
2551   26AE FF FF FF FF 
2551   26B2 FF FF FF FF 
2551   26B6 FF FF FF FF 
2551   26BA FF FF FF FF 
2551   26BE FF FF FF FF 
2551   26C2 FF FF FF FF 
2551   26C6 FF FF FF FF 
2551   26CA FF FF FF FF 
2551   26CE FF FF FF FF 
2551   26D2 FF FF FF FF 
2551   26D6 FF FF FF FF 
2551   26DA FF FF FF FF 
2552   26DE             
2553   26DE FF FF FF FF scrap_sector:		.fill 512		; scrap sector
2553   26E2 FF FF FF FF 
2553   26E6 FF FF FF FF 
2553   26EA FF FF FF FF 
2553   26EE FF FF FF FF 
2553   26F2 FF FF FF FF 
2553   26F6 FF FF FF FF 
2553   26FA FF FF FF FF 
2553   26FE FF FF FF FF 
2553   2702 FF FF FF FF 
2553   2706 FF FF FF FF 
2553   270A FF FF FF FF 
2553   270E FF FF FF FF 
2553   2712 FF FF FF FF 
2553   2716 FF FF FF FF 
2553   271A FF FF FF FF 
2553   271E FF FF FF FF 
2553   2722 FF FF FF FF 
2553   2726 FF FF FF FF 
2553   272A FF FF FF FF 
2553   272E FF FF FF FF 
2553   2732 FF FF FF FF 
2553   2736 FF FF FF FF 
2553   273A FF FF FF FF 
2553   273E FF FF FF FF 
2553   2742 FF FF FF FF 
2553   2746 FF FF FF FF 
2553   274A FF FF FF FF 
2553   274E FF FF FF FF 
2553   2752 FF FF FF FF 
2553   2756 FF FF FF FF 
2553   275A FF FF FF FF 
2553   275E FF FF FF FF 
2553   2762 FF FF FF FF 
2553   2766 FF FF FF FF 
2553   276A FF FF FF FF 
2553   276E FF FF FF FF 
2553   2772 FF FF FF FF 
2553   2776 FF FF FF FF 
2553   277A FF FF FF FF 
2553   277E FF FF FF FF 
2553   2782 FF FF FF FF 
2553   2786 FF FF FF FF 
2553   278A FF FF FF FF 
2553   278E FF FF FF FF 
2553   2792 FF FF FF FF 
2553   2796 FF FF FF FF 
2553   279A FF FF FF FF 
2553   279E FF FF FF FF 
2553   27A2 FF FF FF FF 
2553   27A6 FF FF FF FF 
2553   27AA FF FF FF FF 
2553   27AE FF FF FF FF 
2553   27B2 FF FF FF FF 
2553   27B6 FF FF FF FF 
2553   27BA FF FF FF FF 
2553   27BE FF FF FF FF 
2553   27C2 FF FF FF FF 
2553   27C6 FF FF FF FF 
2553   27CA FF FF FF FF 
2553   27CE FF FF FF FF 
2553   27D2 FF FF FF FF 
2553   27D6 FF FF FF FF 
2553   27DA FF FF FF FF 
2553   27DE FF FF FF FF 
2553   27E2 FF FF FF FF 
2553   27E6 FF FF FF FF 
2553   27EA FF FF FF FF 
2553   27EE FF FF FF FF 
2553   27F2 FF FF FF FF 
2553   27F6 FF FF FF FF 
2553   27FA FF FF FF FF 
2553   27FE FF FF FF FF 
2553   2802 FF FF FF FF 
2553   2806 FF FF FF FF 
2553   280A FF FF FF FF 
2553   280E FF FF FF FF 
2553   2812 FF FF FF FF 
2553   2816 FF FF FF FF 
2553   281A FF FF FF FF 
2553   281E FF FF FF FF 
2553   2822 FF FF FF FF 
2553   2826 FF FF FF FF 
2553   282A FF FF FF FF 
2553   282E FF FF FF FF 
2553   2832 FF FF FF FF 
2553   2836 FF FF FF FF 
2553   283A FF FF FF FF 
2553   283E FF FF FF FF 
2553   2842 FF FF FF FF 
2553   2846 FF FF FF FF 
2553   284A FF FF FF FF 
2553   284E FF FF FF FF 
2553   2852 FF FF FF FF 
2553   2856 FF FF FF FF 
2553   285A FF FF FF FF 
2553   285E FF FF FF FF 
2553   2862 FF FF FF FF 
2553   2866 FF FF FF FF 
2553   286A FF FF FF FF 
2553   286E FF FF FF FF 
2553   2872 FF FF FF FF 
2553   2876 FF FF FF FF 
2553   287A FF FF FF FF 
2553   287E FF FF FF FF 
2553   2882 FF FF FF FF 
2553   2886 FF FF FF FF 
2553   288A FF FF FF FF 
2553   288E FF FF FF FF 
2553   2892 FF FF FF FF 
2553   2896 FF FF FF FF 
2553   289A FF FF FF FF 
2553   289E FF FF FF FF 
2553   28A2 FF FF FF FF 
2553   28A6 FF FF FF FF 
2553   28AA FF FF FF FF 
2553   28AE FF FF FF FF 
2553   28B2 FF FF FF FF 
2553   28B6 FF FF FF FF 
2553   28BA FF FF FF FF 
2553   28BE FF FF FF FF 
2553   28C2 FF FF FF FF 
2553   28C6 FF FF FF FF 
2553   28CA FF FF FF FF 
2553   28CE FF FF FF FF 
2553   28D2 FF FF FF FF 
2553   28D6 FF FF FF FF 
2553   28DA FF FF FF FF 
2554   28DE 00          transient_area:		.db 0			; beginning of the transient memory area. used for disk reads and other purposes		
2555   28DF             
2556   28DF             
2557   28DF             .end
tasm: Number of errors = 0
