0001   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002   0000             ; MEMORY MAP
0003   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004   0000             ; 0000    ROM BEGIN
0005   0000             ; ....
0006   0000             ; 7FFF    ROM END
0007   0000             ;
0008   0000             ; 8000    RAM begin
0009   0000             ; ....
0010   0000             ; F7FF    Stack root
0011   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0012   0000             ; I/O MAP
0013   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014   0000             ; FF80    UART 0    (16550)
0015   0000             ; FF90    UART 1    (16550)
0016   0000             ; FFA0    RTC    (M48T02)
0017   0000             ; FFB0    PIO 0    (8255)
0018   0000             ; FFC0    PIO 1    (8255)
0019   0000             ; FFD0    IDE    (Compact Flash / PATA)
0020   0000             ; FFE0    Timer    (8253)
0021   0000             ; FFF0    BIOS CONFIGURATION NV-RAM STORE AREA
0022   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0023   0000             
0024   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0025   0000             ; SYSTEM CONSTANTS / EQUATIONS
0026   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0027   0000             _UART0_DATA      	.equ $FF80        ; data
0028   0000             _UART0_DLAB_0    	.equ $FF80        ; divisor latch low byte
0029   0000             _UART0_DLAB_1    	.equ $FF81        ; divisor latch high byte
0030   0000             _UART0_IER      	.equ $FF81        ; Interrupt enable register
0031   0000             _UART0_FCR      	.equ $FF82        ; FIFO control register
0032   0000             _UART0_LCR      	.equ $FF83        ; line control register
0033   0000             _UART0_LSR      	.equ $FF85        ; line status register
0034   0000             
0035   0000             _ide_BASE        	.equ $FFD0        ; IDE BASE
0036   0000             _ide_R0           .equ _ide_BASE + 0    ; DATA PORT
0037   0000             _ide_R1           .equ _ide_BASE + 1    ; READ: ERROR CODE, WRITE: FEATURE
0038   0000             _ide_R2           .equ _ide_BASE + 2    ; NUMBER OF SECTORS TO TRANSFER
0039   0000             _ide_R3           .equ _ide_BASE + 3    ; SECTOR ADDRESS LBA 0 [0:7]
0040   0000             _ide_R4           .equ _ide_BASE + 4    ; SECTOR ADDRESS LBA 1 [8:15]
0041   0000             _ide_R5           .equ _ide_BASE + 5    ; SECTOR ADDRESS LBA 2 [16:23]
0042   0000             _ide_R6           .equ _ide_BASE + 6    ; SECTOR ADDRESS LBA 3 [24:27 (LSB)]
0043   0000             _ide_R7           .equ _ide_BASE + 7    ; READ: STATUS, WRITE: COMMAND
0044   0000             
0045   0000             _7SEG_DISPLAY    	.equ $FFB0        ; BIOS POST CODE HEX DISPLAY (2 DIGITS)
0046   0000             _BIOS_POST_CTRL  	.equ $FFB3        ; BIOS POST DISPLAY CONTROL REGISTER, 80h = As Output
0047   0000             _PIO_A          	.equ $FFB0    
0048   0000             _PIO_B          	.equ $FFB1
0049   0000             _PIO_C          	.equ $FFB2
0050   0000             _PIO_CONTROL    	.equ $FFB3        ; PIO CONTROL PORT
0051   0000             
0052   0000             _TIMER_C_0      	.equ $FFE0        ; TIMER COUNTER 0
0053   0000             _TIMER_C_1      	.equ $FFE1        ; TIMER COUNTER 1
0054   0000             _TIMER_C_2      	.equ $FFE2        ; TIMER COUNTER 2
0055   0000             _TIMER_CTRL      	.equ $FFE3        ; TIMER CONTROL REGISTER
0056   0000             
0057   0000             STACK_BEGIN      	.equ $F7FF        ; beginning of stack
0058   0000             FIFO_SIZE        	.equ (1024*2)
0059   0000             
0060   0000             PROC_TEXT_ORG   	.equ $400
0061   0000             NULL            	.equ 0
0062   0000             
0063   0000             
0064   0000             ; for the next iteration:
0065   0000             ; boot-sector(1) | kernel-sectors(32) | inode-bitmap | rawdata-bitmap | inode-table | raw-disk-data
0066   0000             ;
0067   0000             ; inode-table format:
0068   0000             ;  file-type(f, d)
0069   0000             ;  permissons
0070   0000             ;  link-count
0071   0000             ;  filesize
0072   0000             ;  time-stamps
0073   0000             ;  15 data block pointers
0074   0000             ;  single-indirect pointer
0075   0000             ;
0076   0000             
0077   0000             ; for now:
0078   0000             ; boot-sector(1) | kernel-sectors(32) | rawdata-bitmap() | raw-disk-data
0079   0000             ;
0080   0000             ; filename (24)
0081   0000             ; attributes (1)       :|0|0|file_type(3bits)|x|w|r|
0082   0000             ; LBA (2)          : location of raw data for file entry, or dirID for directory entry
0083   0000             ; size (2)          : filesize
0084   0000             ; day (1)           
0085   0000             ; month (1)
0086   0000             ; year (1)
0087   0000             ; packet size = 32 bytes  : total packet size in bytes
0088   0000             ;
0089   0000             FST_ENTRY_SIZE        	.equ 32
0090   0000             FST_FILES_PER_SECT    	.equ (512 / FST_ENTRY_SIZE)
0091   0000             FST_FILES_PER_DIR      	.equ 16
0092   0000             FST_NBR_DIRECTORIES    	.equ 64
0093   0000                         ; 1 sector for header, the rest is for the list of files/dirs
0094   0000             FST_SECTORS_PER_DIR    	.equ (1 + (FST_ENTRY_SIZE * FST_FILES_PER_DIR / 512))    
0095   0000             FST_TOTAL_SECTORS      	.equ (FST_SECTORS_PER_DIR * FST_NBR_DIRECTORIES)
0096   0000             FST_LBA_START          	.equ 32
0097   0000             FST_LBA_END            	.equ (FST_LBA_START + FST_TOTAL_SECTORS - 1)
0098   0000             
0099   0000             FS_NBR_FILES           	.equ (FST_NBR_DIRECTORIES * FST_FILES_PER_DIR)
0100   0000             FS_SECTORS_PER_FILE    	.equ 32        ; the first sector is always a header with a NULL parameter (first byte)
0101   0000                                   ; so that we know which blocks are free or taken
0102   0000             FS_FILE_SIZE          	.equ (FS_SECTORS_PER_FILE * 512)                  
0103   0000             FS_TOTAL_SECTORS      	.equ (FS_NBR_FILES * FS_SECTORS_PER_FILE)
0104   0000             FS_LBA_START          	.equ (FST_LBA_END + 1)
0105   0000             FS_LBA_END            	.equ (FS_LBA_START + FS_NBR_FILES - 1)
0106   0000             
0107   0000             CF_CARD_LBA_SIZE    		.equ $800      ; temporary small size
0108   0000             
0109   0000             ROOT_dirID:        			.equ FST_LBA_START
0110   0000             
0111   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112   0000             ; GLOBAL SYSTEM VARIABLES
0113   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0114   0000             
0115   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116   0000             ; EXTERNAL INTERRUPT TABLE
0117   0000             ; highest priority at lowest address
0118   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119   0000 87 07       .dw int_0
0120   0002 88 07       .dw int_1
0121   0004 89 07       .dw int_2
0122   0006 8A 07       .dw int_3
0123   0008 8B 07       .dw int_4
0124   000A 8C 07       .dw int_5
0125   000C 8D 07       .dw int_6
0126   000E D9 07       .dw int_7
0127   0010             
0128   0010             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129   0010             ; RESET VECTOR DECLARATION
0130   0010             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0131   0010 91 14       .dw kernel_reset_vector
0132   0012             
0133   0012             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134   0012             ;; EXCEPTION VECTOR TABLE
0135   0012             ;; total of 7 entries, starting at address $0012
0136   0012             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0137   0012 A3 08       .dw trap_privilege
0138   0014 C0 09       .dw trap_div_zero
0139   0016 CD 09       .dw undefined_opcode
0140   0018 00 00       .dw NULL
0141   001A 00 00       .dw NULL
0142   001C 00 00       .dw NULL
0143   001E 00 00       .dw NULL
0144   0020             
0145   0020             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0146   0020             ;; SYSTEM CALL VECTOR TABLE
0147   0020             ;; starts at address $0020
0148   0020             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0149   0020 AF 08       .dw syscall_breakpoint
0150   0022 CE 09       .dw syscall_rtc
0151   0024 F1 0A       .dw ide_services
0152   0026 B1 0B       .dw io_services
0153   0028 3D 0C       .dw file_system
0154   002A 68 15       .dw cmd_fork
0155   002C 68 08       .dw list_procs
0156   002E 00 0A       .dw datetime_services
0157   0030 24 08       .dw syscall_reboot
0158   0032 32 15       .dw cmd_pause_proc
0159   0034 30 08       .dw resume_proc
0160   0036 EF 14       .dw cmd_terminate_proc
0161   0038 12 08       .dw cmd_system
0162   003A CA 0C       .dw cmd_boot_installer
0163   003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0164   003C             ;; FILE INCLUDES
0165   003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0166   003C             .include "bios.exp"  ; to obtain the BIOS_RESET_VECTOR location (for reboots)
0001+  003C             BIOS_RESET_VECTOR .EQU  $01c0
0002+  003C             IDE_buffer       .EQU  $8204
0003+  003C             boot_origin      .EQU  $8004
0004+  003C             bios_uart        .EQU  $0002
0005+  003C             bios_ide         .EQU  $0003
0167   003C             .include "lib/stdio.asm"
0001+  003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  003C             ; stdio.s
0003+  003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  003C             .include "lib/string.asm"
0001++ 003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 003C             ; string.s
0003++ 003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 003C             
0005++ 003C             
0006++ 003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 003C             ; strrev
0008++ 003C             ; reverse a string
0009++ 003C             ; D = string address
0010++ 003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 003C             ; 01234
0012++ 003C             strrev:
0013++ 003C 4B          	pusha
0014++ 003D 07 83 00    	call strlen	; length in C
0015++ 0040 12          	mov a, c
0016++ 0041 AF 01 00    	cmp a, 1
0017++ 0044 D0 5E 00    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0047 7D          	dec a
0019++ 0048 FD 4E       	mov si, d	; beginning of string
0020++ 004A FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 004C 59          	add d, a	; end of string
0022++ 004D 12          	mov a, c
0023++ 004E FD 9B       	shr a		; divide by 2
0024++ 0050 39          	mov c, a	; C now counts the steps
0025++ 0051             strrev_L0:
0026++ 0051 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0052 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0053 3E          	mov [d], al	; store left char into right side
0029++ 0054 1B          	mov al, bl
0030++ 0055 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0056 7E          	dec c
0032++ 0057 7F          	dec d
0033++ 0058 C2 00 00    	cmp c, 0
0034++ 005B C7 51 00    	jne strrev_L0
0035++ 005E             strrev_end:
0036++ 005E 4C          	popa
0037++ 005F 09          	ret
0038++ 0060             	
0039++ 0060             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0060             ; strchr
0041++ 0060             ; search string in D for char in AL
0042++ 0060             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0060             strchr:
0044++ 0060             strchr_L0:
0045++ 0060 32          	mov bl, [d]
0046++ 0061 C1 00       	cmp bl, 0
0047++ 0063 C6 6E 00    	je strchr_end
0048++ 0066 BA          	cmp al, bl
0049++ 0067 C6 6E 00    	je strchr_end
0050++ 006A 79          	inc d
0051++ 006B 0A 60 00    	jmp strchr_L0
0052++ 006E             strchr_end:
0053++ 006E 1B          	mov al, bl
0054++ 006F 09          	ret
0055++ 0070             
0056++ 0070             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0070             ; strstr
0058++ 0070             ; find sub-string
0059++ 0070             ; str1 in SI
0060++ 0070             ; str2 in DI
0061++ 0070             ; SI points to end of source string
0062++ 0070             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0070             strstr:
0064++ 0070 DB          	push al
0065++ 0071 DA          	push d
0066++ 0072 E3          	push di
0067++ 0073             strstr_loop:
0068++ 0073 F3          	cmpsb					; compare a byte of the strings
0069++ 0074 C7 7F 00    	jne strstr_ret
0070++ 0077 FC 00 00    	lea d, [di + 0]
0071++ 007A BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 007C C7 73 00    	jne strstr_loop				; equal chars but not at end
0073++ 007F             strstr_ret:
0074++ 007F F0          	pop di
0075++ 0080 E7          	pop d
0076++ 0081 E8          	pop al
0077++ 0082 09          	ret
0078++ 0083             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0083             ; length of null terminated string
0080++ 0083             ; result in C
0081++ 0083             ; pointer in D
0082++ 0083             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0083             strlen:
0084++ 0083 DA          	push d
0085++ 0084 38 00 00    	mov c, 0
0086++ 0087             strlen_L1:
0087++ 0087 BD 00       	cmp byte [d], 0
0088++ 0089 C6 91 00    	je strlen_ret
0089++ 008C 79          	inc d
0090++ 008D 78          	inc c
0091++ 008E 0A 87 00    	jmp strlen_L1
0092++ 0091             strlen_ret:
0093++ 0091 E7          	pop d
0094++ 0092 09          	ret
0095++ 0093             
0096++ 0093             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0093             ; STRCMP
0098++ 0093             ; compare two strings
0099++ 0093             ; str1 in SI
0100++ 0093             ; str2 in DI
0101++ 0093             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0093             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0093             strcmp:
0104++ 0093 DB          	push al
0105++ 0094 DA          	push d
0106++ 0095 E3          	push di
0107++ 0096 E2          	push si
0108++ 0097             strcmp_loop:
0109++ 0097 F3          	cmpsb					; compare a byte of the strings
0110++ 0098 C7 A3 00    	jne strcmp_ret
0111++ 009B FB FF FF    	lea d, [si +- 1]
0112++ 009E BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 00A0 C7 97 00    	jne strcmp_loop				; equal chars but not at end
0114++ 00A3             strcmp_ret:
0115++ 00A3 EF          	pop si
0116++ 00A4 F0          	pop di
0117++ 00A5 E7          	pop d
0118++ 00A6 E8          	pop al
0119++ 00A7 09          	ret
0120++ 00A8             
0121++ 00A8             
0122++ 00A8             ; STRCPY
0123++ 00A8             ; copy null terminated string from SI to DI
0124++ 00A8             ; source in SI
0125++ 00A8             ; destination in DI
0126++ 00A8             strcpy:
0127++ 00A8 E2          	push si
0128++ 00A9 E3          	push di
0129++ 00AA DB          	push al
0130++ 00AB             strcpy_L1:
0131++ 00AB F6          	lodsb
0132++ 00AC F7          	stosb
0133++ 00AD B9 00       	cmp al, 0
0134++ 00AF C7 AB 00    	jne strcpy_L1
0135++ 00B2             strcpy_end:
0136++ 00B2 E8          	pop al
0137++ 00B3 F0          	pop di
0138++ 00B4 EF          	pop si
0139++ 00B5 09          	ret
0140++ 00B6             
0141++ 00B6             ; STRCAT
0142++ 00B6             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 00B6             ; source in SI
0144++ 00B6             ; destination in DI
0145++ 00B6             strcat:
0146++ 00B6 E2          	push si
0147++ 00B7 E3          	push di
0148++ 00B8 D7          	push a
0149++ 00B9 DA          	push d
0150++ 00BA 50          	mov a, di
0151++ 00BB 3C          	mov d, a
0152++ 00BC             strcat_goto_end_L1:
0153++ 00BC BD 00       	cmp byte[d], 0
0154++ 00BE C6 C5 00    	je strcat_start
0155++ 00C1 79          	inc d
0156++ 00C2 0A BC 00    	jmp strcat_goto_end_L1
0157++ 00C5             strcat_start:
0158++ 00C5 FD 50       	mov di, d
0159++ 00C7             strcat_L1:
0160++ 00C7 F6          	lodsb
0161++ 00C8 F7          	stosb
0162++ 00C9 B9 00       	cmp al, 0
0163++ 00CB C7 C7 00    	jne strcat_L1
0164++ 00CE             strcat_end:
0165++ 00CE E7          	pop d
0166++ 00CF E4          	pop a
0167++ 00D0 F0          	pop di
0168++ 00D1 EF          	pop si
0169++ 00D2 09          	ret
0005+  00D3             
0006+  00D3 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  00D7 34 35 36 37 
0006+  00DB 38 39 41 42 
0006+  00DF 43 44 45 46 
0007+  00E3 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  00E7 1B 5B 48 00 
0008+  00EB             
0009+  00EB 01 00       table_power:.dw 1
0010+  00ED 0A 00       			.dw 10
0011+  00EF 64 00       			.dw 100
0012+  00F1 E8 03       			.dw 1000
0013+  00F3 10 27       			.dw 10000
0014+  00F5             
0015+  00F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  00F5             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  00F5             ; ASCII in BL
0018+  00F5             ; result in AL
0019+  00F5             ; ascii for F = 0100 0110
0020+  00F5             ; ascii for 9 = 0011 1001
0021+  00F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  00F5             hex_ascii_encode:
0023+  00F5 1B          	mov al, bl
0024+  00F6 93 40       	test al, $40				; test if letter or number
0025+  00F8 C7 FE 00    	jnz hex_letter
0026+  00FB 87 0F       	and al, $0F				; get number
0027+  00FD 09          	ret
0028+  00FE             hex_letter:
0029+  00FE 87 0F       	and al, $0F				; get letter
0030+  0100 6A 09       	add al, 9
0031+  0102 09          	ret
0032+  0103             
0033+  0103             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  0103             ; ATOI
0035+  0103             ; 2 letter hex string in B
0036+  0103             ; 8bit integer returned in AL
0037+  0103             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0103             atoi:
0039+  0103 D8          	push b
0040+  0104 07 F5 00    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  0107 30          	mov bl, bh
0042+  0108 DB          	push al					; save a
0043+  0109 07 F5 00    	call hex_ascii_encode
0044+  010C EA          	pop bl	
0045+  010D FD 9E 04    	shl al, 4
0046+  0110 8C          	or al, bl
0047+  0111 E5          	pop b
0048+  0112 09          	ret	
0049+  0113             
0050+  0113             
0051+  0113             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  0113             ; printf
0053+  0113             ; no need for explanations!
0054+  0113             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0113             printf:
0056+  0113 09          	ret
0057+  0114             
0058+  0114             
0059+  0114             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  0114             ; scanf
0061+  0114             ; no need for explanations!
0062+  0114             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  0114             scanf:
0064+  0114 09          	ret
0065+  0115             
0066+  0115             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  0115             ; ITOA
0068+  0115             ; 8bit value in BL
0069+  0115             ; 2 byte ASCII result in A
0070+  0115             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  0115             itoa:
0072+  0115 DA          	push d
0073+  0116 D8          	push b
0074+  0117 A7 00       	mov bh, 0
0075+  0119 FD A4 04    	shr bl, 4	
0076+  011C 74          	mov d, b
0077+  011D 1F D3 00    	mov al, [d + s_hex_digits]
0078+  0120 23          	mov ah, al
0079+  0121             	
0080+  0121 E5          	pop b
0081+  0122 D8          	push b
0082+  0123 A7 00       	mov bh, 0
0083+  0125 FD 87 0F    	and bl, $0F
0084+  0128 74          	mov d, b
0085+  0129 1F D3 00    	mov al, [d + s_hex_digits]
0086+  012C E5          	pop b
0087+  012D E7          	pop d
0088+  012E 09          	ret
0089+  012F             
0090+  012F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  012F             ; HEX STRING TO BINARY
0092+  012F             ; di = destination address
0093+  012F             ; si = source
0094+  012F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  012F             hex_to_int:
0096+  012F             hex_to_int_L1:
0097+  012F F6          	lodsb					; load from [SI] to AL
0098+  0130 B9 00       	cmp al, 0				; check if ASCII 0
0099+  0132 C6 3F 01    	jz hex_to_int_ret
0100+  0135 36          	mov bh, al
0101+  0136 F6          	lodsb
0102+  0137 2F          	mov bl, al
0103+  0138 07 03 01    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  013B F7          	stosb					; store AL to [DI]
0105+  013C 0A 2F 01    	jmp hex_to_int_L1
0106+  013F             hex_to_int_ret:
0107+  013F 09          	ret		
0108+  0140             
0109+  0140             
0110+  0140             
0111+  0140             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  0140             ; GETCHAR
0113+  0140             ; char in ah
0114+  0140             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  0140             getchar:
0116+  0140 DB          	push al
0117+  0141             getchar_retry:
0118+  0141 FD 0C       	sti
0119+  0143 19 01       	mov al, 1
0120+  0145 05 03       	syscall sys_io			; receive in AH
0121+  0147 B9 00       	cmp al, 0			; check if any char was receive
0122+  0149 C6 41 01    	je getchar_retry
0123+  014C E8          	pop al
0124+  014D 09          	ret
0125+  014E             
0126+  014E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  014E             ; PUTCHAR
0128+  014E             ; char in ah
0129+  014E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  014E             putchar:
0131+  014E D7          	push a
0132+  014F 19 00       	mov al, 0
0133+  0151 05 03       	syscall sys_io			; char in AH
0134+  0153 E4          	pop a
0135+  0154 09          	ret
0136+  0155             
0137+  0155             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  0155             ;; INPUT A STRING
0139+  0155             ;; terminates with null
0140+  0155             ;; pointer in D
0141+  0155             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  0155             gets:
0143+  0155 D7          	push a
0144+  0156 DA          	push d
0145+  0157             gets_loop:
0146+  0157 FD 0C       	sti
0147+  0159 19 01       	mov al, 1
0148+  015B 05 03       	syscall sys_io			; receive in AH
0149+  015D B9 00       	cmp al, 0				; check error code (AL)
0150+  015F C6 57 01    	je gets_loop			; if no char received, retry
0151+  0162             
0152+  0162 76 1B       	cmp ah, 27
0153+  0164 C6 85 01    	je gets_telnet_escape
0154+  0167 76 0A       	cmp ah, $0A				; LF
0155+  0169 C6 DE 01    	je gets_end
0156+  016C 76 0D       	cmp ah, $0D				; CR
0157+  016E C6 DE 01    	je gets_end
0158+  0171 76 5C       	cmp ah, $5C				; '\\'
0159+  0173 C6 B5 01    	je gets_escape
0160+  0176             	
0161+  0176 76 08       	cmp ah, $08			; check for backspace
0162+  0178 C6 81 01    	je gets_backspace
0163+  017B             
0164+  017B 1A          	mov al, ah
0165+  017C 3E          	mov [d], al
0166+  017D 79          	inc d
0167+  017E 0A 57 01    	jmp gets_loop
0168+  0181             gets_backspace:
0169+  0181 7F          	dec d
0170+  0182 0A 57 01    	jmp gets_loop
0171+  0185             gets_telnet_escape:
0172+  0185 FD 0C       	sti
0173+  0187 19 01       	mov al, 1
0174+  0189 05 03       	syscall sys_io				; receive in AH without echo
0175+  018B B9 00       	cmp al, 0					; check error code (AL)
0176+  018D C6 85 01    	je gets_telnet_escape		; if no char received, retry
0177+  0190 76 5B       	cmp ah, '['
0178+  0192 C7 57 01    	jne gets_loop
0179+  0195             gets_telnet_escape_phase2:
0180+  0195 FD 0C       	sti
0181+  0197 19 01       	mov al, 1
0182+  0199 05 03       	syscall sys_io					; receive in AH without echo
0183+  019B B9 00       	cmp al, 0						; check error code (AL)
0184+  019D C6 95 01    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  01A0 76 44       	cmp ah, 'D'
0186+  01A2 C6 AD 01    	je gets_left_arrow
0187+  01A5 76 43       	cmp ah, 'C'
0188+  01A7 C6 B1 01    	je gets_right_arrow
0189+  01AA 0A 57 01    	jmp gets_loop
0190+  01AD             gets_left_arrow:
0191+  01AD 7F          	dec d
0192+  01AE 0A 57 01    	jmp gets_loop
0193+  01B1             gets_right_arrow:
0194+  01B1 79          	inc d
0195+  01B2 0A 57 01    	jmp gets_loop
0196+  01B5             gets_escape:
0197+  01B5 FD 0C       	sti
0198+  01B7 19 01       	mov al, 1
0199+  01B9 05 03       	syscall sys_io			; receive in AH
0200+  01BB B9 00       	cmp al, 0				; check error code (AL)
0201+  01BD C6 B5 01    	je gets_escape			; if no char received, retry
0202+  01C0 76 6E       	cmp ah, 'n'
0203+  01C2 C6 D0 01    	je gets_LF
0204+  01C5 76 72       	cmp ah, 'r'
0205+  01C7 C6 D7 01    	je gets_CR
0206+  01CA 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  01CB 3E          	mov [d], al
0208+  01CC 79          	inc d
0209+  01CD 0A 57 01    	jmp gets_loop
0210+  01D0             gets_LF:
0211+  01D0 19 0A       	mov al, $0A
0212+  01D2 3E          	mov [d], al
0213+  01D3 79          	inc d
0214+  01D4 0A 57 01    	jmp gets_loop
0215+  01D7             gets_CR:
0216+  01D7 19 0D       	mov al, $0D
0217+  01D9 3E          	mov [d], al
0218+  01DA 79          	inc d
0219+  01DB 0A 57 01    	jmp gets_loop
0220+  01DE             gets_end:
0221+  01DE 19 00       	mov al, 0
0222+  01E0 3E          	mov [d], al				; terminate string
0223+  01E1 E7          	pop d
0224+  01E2 E4          	pop a
0225+  01E3 09          	ret
0226+  01E4             
0227+  01E4             
0228+  01E4             
0229+  01E4             
0230+  01E4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  01E4             ;; INPUT TEXT
0232+  01E4             ;; terminated with CTRL+D
0233+  01E4             ;; pointer in D
0234+  01E4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  01E4             gettxt:
0236+  01E4 D7          	push a
0237+  01E5 DA          	push d
0238+  01E6             gettxt_loop:
0239+  01E6 19 01       	mov al, 1
0240+  01E8 05 03       	syscall sys_io			; receive in AH
0241+  01EA B9 00       	cmp al, 0				; check error code (AL)
0242+  01EC C6 E6 01    	je gettxt_loop		; if no char received, retry
0243+  01EF 76 04       	cmp ah, 4			; EOT
0244+  01F1 C6 2F 02    	je gettxt_end
0245+  01F4 76 08       	cmp ah, $08			; check for backspace
0246+  01F6 C6 2B 02    	je gettxt_backspace
0247+  01F9 76 5C       	cmp ah, $5C				; '\\'
0248+  01FB C6 04 02    	je gettxt_escape
0249+  01FE 1A          	mov al, ah
0250+  01FF 3E          	mov [d], al
0251+  0200 79          	inc d
0252+  0201 0A E6 01    	jmp gettxt_loop
0253+  0204             gettxt_escape:
0254+  0204 19 01       	mov al, 1
0255+  0206 05 03       	syscall sys_io			; receive in AH
0256+  0208 B9 00       	cmp al, 0				; check error code (AL)
0257+  020A C6 04 02    	je gettxt_escape		; if no char received, retry
0258+  020D 76 6E       	cmp ah, 'n'
0259+  020F C6 1D 02    	je gettxt_LF
0260+  0212 76 72       	cmp ah, 'r'
0261+  0214 C6 24 02    	je gettxt_CR
0262+  0217 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  0218 3E          	mov [d], al
0264+  0219 79          	inc d
0265+  021A 0A E6 01    	jmp gettxt_loop
0266+  021D             gettxt_LF:
0267+  021D 19 0A       	mov al, $0A
0268+  021F 3E          	mov [d], al
0269+  0220 79          	inc d
0270+  0221 0A E6 01    	jmp gettxt_loop
0271+  0224             gettxt_CR:
0272+  0224 19 0D       	mov al, $0D
0273+  0226 3E          	mov [d], al
0274+  0227 79          	inc d
0275+  0228 0A E6 01    	jmp gettxt_loop
0276+  022B             gettxt_backspace:
0277+  022B 7F          	dec d
0278+  022C 0A E6 01    	jmp gettxt_loop
0279+  022F             gettxt_end:
0280+  022F 19 00       	mov al, 0
0281+  0231 3E          	mov [d], al				; terminate string
0282+  0232 E7          	pop d
0283+  0233 E4          	pop a
0284+  0234 09          	ret
0285+  0235             
0286+  0235             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  0235             ; PRINT NEW LINE
0288+  0235             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  0235             printnl:
0290+  0235 D7          	push a
0291+  0236 10 00 0A    	mov a, $0A00
0292+  0239 05 03       	syscall sys_io
0293+  023B 10 00 0D    	mov a, $0D00
0294+  023E 05 03       	syscall sys_io
0295+  0240 E4          	pop a
0296+  0241 09          	ret
0297+  0242             
0298+  0242             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  0242             ; strtoint
0300+  0242             ; 4 digit hex string number in d
0301+  0242             ; integer returned in A
0302+  0242             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  0242             strtointx:
0304+  0242 D8          	push b
0305+  0243 32          	mov bl, [d]
0306+  0244 37          	mov bh, bl
0307+  0245 33 01 00    	mov bl, [d + 1]
0308+  0248 07 03 01    	call atoi				; convert to int in AL
0309+  024B 23          	mov ah, al				; move to AH
0310+  024C 33 02 00    	mov bl, [d + 2]
0311+  024F 37          	mov bh, bl
0312+  0250 33 03 00    	mov bl, [d + 3]
0313+  0253 07 03 01    	call atoi				; convert to int in AL
0314+  0256 E5          	pop b
0315+  0257 09          	ret
0316+  0258             
0317+  0258             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  0258             ; strtoint
0319+  0258             ; 5 digit base10 string number in d
0320+  0258             ; integer returned in A
0321+  0258             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  0258             strtoint:
0323+  0258 E2          	push si
0324+  0259 D8          	push b
0325+  025A D9          	push c
0326+  025B DA          	push d
0327+  025C 07 83 00    	call strlen			; get string length in C
0328+  025F 7E          	dec c
0329+  0260 FD 4E       	mov si, d
0330+  0262 12          	mov a, c
0331+  0263 FD 99       	shl a
0332+  0265 3B EB 00    	mov d, table_power
0333+  0268 59          	add d, a
0334+  0269 38 00 00    	mov c, 0
0335+  026C             strtoint_L0:
0336+  026C F6          	lodsb			; load ASCII to al
0337+  026D B9 00       	cmp al, 0
0338+  026F C6 82 02    	je strtoint_end
0339+  0272 6F 30       	sub al, $30		; make into integer
0340+  0274 22 00       	mov ah, 0
0341+  0276 2A          	mov b, [d]
0342+  0277 AC          	mul a, b			; result in B since it fits in 16bits
0343+  0278 11          	mov a, b
0344+  0279 28          	mov b, c
0345+  027A 54          	add a, b
0346+  027B 39          	mov c, a
0347+  027C 63 02 00    	sub d, 2
0348+  027F 0A 6C 02    	jmp strtoint_L0
0349+  0282             strtoint_end:
0350+  0282 12          	mov a, c
0351+  0283 E7          	pop d
0352+  0284 E6          	pop c
0353+  0285 E5          	pop b
0354+  0286 EF          	pop si
0355+  0287 09          	ret
0356+  0288             
0357+  0288             
0358+  0288             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  0288             ; PRINT NULL TERMINATED STRING
0360+  0288             ; pointer in D
0361+  0288             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  0288             puts:
0363+  0288 D7          	push a
0364+  0289 DA          	push d
0365+  028A             puts_L1:
0366+  028A 1E          	mov al, [d]
0367+  028B B9 00       	cmp al, 0
0368+  028D C6 99 02    	jz puts_END
0369+  0290 23          	mov ah, al
0370+  0291 19 00       	mov al, 0
0371+  0293 05 03       	syscall sys_io
0372+  0295 79          	inc d
0373+  0296 0A 8A 02    	jmp puts_L1
0374+  0299             puts_END:
0375+  0299 E7          	pop d
0376+  029A E4          	pop a
0377+  029B 09          	ret
0378+  029C             
0379+  029C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  029C             ; PRINT N SIZE STRING
0381+  029C             ; pointer in D
0382+  029C             ; size in C
0383+  029C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  029C             putsn:
0385+  029C DB          	push al
0386+  029D DA          	push d
0387+  029E D9          	push c
0388+  029F             putsn_L0:
0389+  029F 1E          	mov al, [d]
0390+  02A0 23          	mov ah, al
0391+  02A1 19 00       	mov al, 0
0392+  02A3 05 03       	syscall sys_io
0393+  02A5 79          	inc d
0394+  02A6 7E          	dec c	
0395+  02A7 C2 00 00    	cmp c, 0
0396+  02AA C7 9F 02    	jne putsn_L0
0397+  02AD             putsn_end:
0398+  02AD E6          	pop c
0399+  02AE E7          	pop d
0400+  02AF E8          	pop al
0401+  02B0 09          	ret
0402+  02B1             
0403+  02B1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  02B1             ; print 16bit decimal number
0405+  02B1             ; input number in A
0406+  02B1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  02B1             print_u16d:
0408+  02B1 D7          	push a
0409+  02B2 D8          	push b
0410+  02B3 26 10 27    	mov b, 10000
0411+  02B6 AE          	div a, b			; get 10000's coeff.
0412+  02B7 07 D9 02    	call print_number
0413+  02BA 11          	mov a, b
0414+  02BB 26 E8 03    	mov b, 1000
0415+  02BE AE          	div a, b			; get 1000's coeff.
0416+  02BF 07 D9 02    	call print_number
0417+  02C2 11          	mov a, b
0418+  02C3 26 64 00    	mov b, 100
0419+  02C6 AE          	div a, b
0420+  02C7 07 D9 02    	call print_number
0421+  02CA 11          	mov a, b
0422+  02CB 26 0A 00    	mov b, 10
0423+  02CE AE          	div a, b
0424+  02CF 07 D9 02    	call print_number
0425+  02D2 1B          	mov al, bl			; 1's coeff in bl
0426+  02D3 07 D9 02    	call print_number
0427+  02D6 E5          	pop b
0428+  02D7 E4          	pop a
0429+  02D8 09          	ret
0430+  02D9             
0431+  02D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0432+  02D9             ; print AL
0433+  02D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0434+  02D9             print_number:
0435+  02D9 6A 30       	add al, $30
0436+  02DB 23          	mov ah, al
0437+  02DC 07 4E 01    	call putchar
0438+  02DF 09          	ret
0439+  02E0             
0440+  02E0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0441+  02E0             ; PRINT 16BIT HEX INTEGER
0442+  02E0             ; integer value in reg B
0443+  02E0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0444+  02E0             print_u16x:
0445+  02E0 D7          	push a
0446+  02E1 D8          	push b
0447+  02E2 DD          	push bl
0448+  02E3 30          	mov bl, bh
0449+  02E4 07 15 01    	call itoa				; convert bh to char in A
0450+  02E7 2F          	mov bl, al				; save al
0451+  02E8 19 00       	mov al, 0
0452+  02EA 05 03       	syscall sys_io				; display AH
0453+  02EC 24          	mov ah, bl				; retrieve al
0454+  02ED 19 00       	mov al, 0
0455+  02EF 05 03       	syscall sys_io				; display AL
0456+  02F1             
0457+  02F1 EA          	pop bl
0458+  02F2 07 15 01    	call itoa				; convert bh to char in A
0459+  02F5 2F          	mov bl, al				; save al
0460+  02F6 19 00       	mov al, 0
0461+  02F8 05 03       	syscall sys_io				; display AH
0462+  02FA 24          	mov ah, bl				; retrieve al
0463+  02FB 19 00       	mov al, 0
0464+  02FD 05 03       	syscall sys_io				; display AL
0465+  02FF             
0466+  02FF E5          	pop b
0467+  0300 E4          	pop a
0468+  0301 09          	ret
0469+  0302             
0470+  0302             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0471+  0302             ; INPUT 16BIT HEX INTEGER
0472+  0302             ; read 16bit integer into A
0473+  0302             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0474+  0302             scan_u16x:
0475+  0302 F8 10 00    	enter 16
0476+  0305 D8          	push b
0477+  0306 DA          	push d
0478+  0307             
0479+  0307 FA F1 FF    	lea d, [bp + -15]
0480+  030A 07 55 01    	call gets				; get number
0481+  030D             
0482+  030D 32          	mov bl, [d]
0483+  030E 37          	mov bh, bl
0484+  030F 33 01 00    	mov bl, [d + 1]
0485+  0312 07 03 01    	call atoi				; convert to int in AL
0486+  0315 23          	mov ah, al				; move to AH
0487+  0316             
0488+  0316 33 02 00    	mov bl, [d + 2]
0489+  0319 37          	mov bh, bl
0490+  031A 33 03 00    	mov bl, [d + 3]
0491+  031D 07 03 01    	call atoi				; convert to int in AL
0492+  0320             
0493+  0320 E7          	pop d
0494+  0321 E5          	pop b
0495+  0322 F9          	leave
0496+  0323 09          	ret
0497+  0324             
0498+  0324             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0499+  0324             ; PRINT 8bit HEX INTEGER
0500+  0324             ; integer value in reg bl
0501+  0324             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0502+  0324             print_u8x:
0503+  0324 D7          	push a
0504+  0325 DD          	push bl
0505+  0326             
0506+  0326 07 15 01    	call itoa				; convert bl to char in A
0507+  0329 2F          	mov bl, al				; save al
0508+  032A 19 00       	mov al, 0
0509+  032C 05 03       	syscall sys_io				; display AH
0510+  032E 24          	mov ah, bl				; retrieve al
0511+  032F 19 00       	mov al, 0
0512+  0331 05 03       	syscall sys_io				; display AL
0513+  0333             
0514+  0333 EA          	pop bl
0515+  0334 E4          	pop a
0516+  0335 09          	ret
0517+  0336             
0518+  0336             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0519+  0336             ; print 8bit decimal unsigned number
0520+  0336             ; input number in AL
0521+  0336             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0522+  0336             print_u8d:
0523+  0336 D7          	push a
0524+  0337 D8          	push b
0525+  0338             
0526+  0338 22 00       	mov ah, 0
0527+  033A 26 64 00    	mov b, 100
0528+  033D AE          	div a, b
0529+  033E D8          	push b			; save remainder
0530+  033F B9 00       	cmp al, 0
0531+  0341 C6 4B 03    	je skip100
0532+  0344 6A 30       	add al, $30
0533+  0346 23          	mov ah, al
0534+  0347 19 00       	mov al, 0
0535+  0349 05 03       	syscall sys_io	; print coeff
0536+  034B             skip100:
0537+  034B E4          	pop a
0538+  034C 22 00       	mov ah, 0
0539+  034E 26 0A 00    	mov b, 10
0540+  0351 AE          	div a, b
0541+  0352 D8          	push b			; save remainder
0542+  0353 B9 00       	cmp al, 0
0543+  0355 C6 5F 03    	je skip10
0544+  0358 6A 30       	add al, $30
0545+  035A 23          	mov ah, al
0546+  035B 19 00       	mov al, 0
0547+  035D 05 03       	syscall sys_io	; print coeff
0548+  035F             skip10:
0549+  035F E4          	pop a
0550+  0360 1B          	mov al, bl
0551+  0361 6A 30       	add al, $30
0552+  0363 23          	mov ah, al
0553+  0364 19 00       	mov al, 0
0554+  0366 05 03       	syscall sys_io	; print coeff
0555+  0368 E5          	pop b
0556+  0369 E4          	pop a
0557+  036A 09          	ret
0558+  036B             
0559+  036B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0560+  036B             ; INPUT 8BIT HEX INTEGER
0561+  036B             ; read 8bit integer into AL
0562+  036B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0563+  036B             scan_u8x:
0564+  036B F8 04 00    	enter 4
0565+  036E D8          	push b
0566+  036F DA          	push d
0567+  0370             
0568+  0370 FA FD FF    	lea d, [bp + -3]
0569+  0373 07 55 01    	call gets				; get number
0570+  0376             
0571+  0376 32          	mov bl, [d]
0572+  0377 37          	mov bh, bl
0573+  0378 33 01 00    	mov bl, [d + 1]
0574+  037B 07 03 01    	call atoi				; convert to int in AL
0575+  037E             
0576+  037E E7          	pop d
0577+  037F E5          	pop b
0578+  0380 F9          	leave
0579+  0381 09          	ret
0580+  0382             
0581+  0382             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0582+  0382             ; input decimal number
0583+  0382             ; result in A
0584+  0382             ; 655'\0'
0585+  0382             ; low--------high
0586+  0382             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  0382             scan_u16d:
0588+  0382 F8 08 00    	enter 8
0589+  0385 E2          	push si
0590+  0386 D8          	push b
0591+  0387 D9          	push c
0592+  0388 DA          	push d
0593+  0389 FA F9 FF    	lea d, [bp +- 7]
0594+  038C 07 55 01    	call gets
0595+  038F 07 83 00    	call strlen			; get string length in C
0596+  0392 7E          	dec c
0597+  0393 FD 4E       	mov si, d
0598+  0395 12          	mov a, c
0599+  0396 FD 99       	shl a
0600+  0398 3B EB 00    	mov d, table_power
0601+  039B 59          	add d, a
0602+  039C 38 00 00    	mov c, 0
0603+  039F             mul_loop:
0604+  039F F6          	lodsb			; load ASCII to al
0605+  03A0 B9 00       	cmp al, 0
0606+  03A2 C6 B5 03    	je mul_exit
0607+  03A5 6F 30       	sub al, $30		; make into integer
0608+  03A7 22 00       	mov ah, 0
0609+  03A9 2A          	mov b, [d]
0610+  03AA AC          	mul a, b			; result in B since it fits in 16bits
0611+  03AB 11          	mov a, b
0612+  03AC 28          	mov b, c
0613+  03AD 54          	add a, b
0614+  03AE 39          	mov c, a
0615+  03AF 63 02 00    	sub d, 2
0616+  03B2 0A 9F 03    	jmp mul_loop
0617+  03B5             mul_exit:
0618+  03B5 12          	mov a, c
0619+  03B6 E7          	pop d
0620+  03B7 E6          	pop c
0621+  03B8 E5          	pop b
0622+  03B9 EF          	pop si
0623+  03BA F9          	leave
0624+  03BB 09          	ret
0168   03BC             .include "lib/ctype.asm"
0001+  03BC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  03BC             ; ctype.s
0003+  03BC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  03BC             
0005+  03BC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  03BC             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  03BC             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  03BC             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  03BC             ;; characters are supported.
0010+  03BC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  03BC             ;; isalnum 
0012+  03BC             ;; isalpha 
0013+  03BC             ;; islower 
0014+  03BC             ;; isupper 
0015+  03BC             ;; isdigit 
0016+  03BC             ;; isxdigit
0017+  03BC             ;; iscntrl 
0018+  03BC             ;; isgraph 
0019+  03BC             ;; isspace 
0020+  03BC             ;; isblank 
0021+  03BC             ;; isprint 
0022+  03BC             ;; ispunct 
0023+  03BC             ;; tolower 
0024+  03BC             ;; toupper
0025+  03BC             
0026+  03BC             
0027+  03BC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  03BC             ;; IS ALPHANUMERIC
0029+  03BC             ;; sets ZF according with result
0030+  03BC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  03BC             isalnum:
0032+  03BC 07 D9 03    	call isalpha
0033+  03BF C6 C5 03    	je isalnum_exit
0034+  03C2 07 C6 03    	call isdigit
0035+  03C5             isalnum_exit:
0036+  03C5 09          	ret	
0037+  03C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  03C6             ;; IS DIGIT
0039+  03C6             ;; sets ZF according with result
0040+  03C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  03C6             isdigit:
0042+  03C6 DB          	push al
0043+  03C7 B9 30       	cmp al, '0'
0044+  03C9 C8 D5 03    	jlu isdigit_false
0045+  03CC B9 39       	cmp al, '9'
0046+  03CE D1 D5 03    	jgu isdigit_false
0047+  03D1 87 00       	and al, 0	; set ZF
0048+  03D3 E8          	pop al
0049+  03D4 09          	ret
0050+  03D5             isdigit_false:
0051+  03D5 8B 01       	or al, 1	; clear ZF
0052+  03D7 E8          	pop al
0053+  03D8 09          	ret	
0054+  03D9             	
0055+  03D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  03D9             ;; IS ALPHA
0057+  03D9             ;; sets ZF according with result
0058+  03D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  03D9             isalpha:
0060+  03D9 DB          	push al
0061+  03DA B9 5F       	cmp al, '_'
0062+  03DC C6 FC 03    	je isalpha_true
0063+  03DF B9 2E       	cmp al, '.'
0064+  03E1 C6 FC 03    	je isalpha_true
0065+  03E4 B9 41       	cmp al, 'A'
0066+  03E6 C8 F8 03    	jlu isalpha_false
0067+  03E9 B9 7A       	cmp al, 'z'
0068+  03EB D1 F8 03    	jgu isalpha_false
0069+  03EE B9 5A       	cmp al, 'Z'
0070+  03F0 D0 FC 03    	jleu isalpha_true
0071+  03F3 B9 61       	cmp al, 'a'
0072+  03F5 C9 FC 03    	jgeu isalpha_true
0073+  03F8             isalpha_false:
0074+  03F8 8B 01       	or al, 1	; clear ZF
0075+  03FA E8          	pop al
0076+  03FB 09          	ret
0077+  03FC             isalpha_true:
0078+  03FC 87 00       	and al, 0	; set ZF
0079+  03FE E8          	pop al
0080+  03FF 09          	ret
0081+  0400             
0082+  0400             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  0400             ;; IS PATH-ALPHA
0084+  0400             ;; sets ZF according with result
0085+  0400             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  0400             ispath:
0087+  0400 DB          	push al
0088+  0401 07 C6 03    	call isdigit
0089+  0404 C6 2E 04    	je ispath_true
0090+  0407 B9 5F       	cmp al, '_'
0091+  0409 C6 2E 04    	je ispath_true
0092+  040C B9 2F       	cmp al, '/'
0093+  040E C6 2E 04    	je ispath_true
0094+  0411 B9 2E       	cmp al, '.'
0095+  0413 C6 2E 04    	je ispath_true
0096+  0416 B9 41       	cmp al, 'A'
0097+  0418 C8 2A 04    	jlu ispath_false
0098+  041B B9 7A       	cmp al, 'z'
0099+  041D D1 2A 04    	jgu ispath_false
0100+  0420 B9 5A       	cmp al, 'Z'
0101+  0422 D0 2E 04    	jleu ispath_true
0102+  0425 B9 61       	cmp al, 'a'
0103+  0427 C9 2E 04    	jgeu ispath_true
0104+  042A             ispath_false:
0105+  042A 8B 01       	or al, 1	; clear ZF
0106+  042C E8          	pop al
0107+  042D 09          	ret
0108+  042E             ispath_true:
0109+  042E 87 00       	and al, 0	; set ZF
0110+  0430 E8          	pop al
0111+  0431 09          	ret
0112+  0432             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  0432             ;; IS SPACE
0114+  0432             ;; sets ZF according with result
0115+  0432             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  0432             isspace:
0117+  0432 B9 20       	cmp al, $20		; ' '
0118+  0434 C6 48 04    	je isspace_exit
0119+  0437 B9 09       	cmp al, $09		; '\t'
0120+  0439 C6 48 04    	je isspace_exit
0121+  043C B9 0A       	cmp al, $0A		; '\n'
0122+  043E C6 48 04    	je isspace_exit
0123+  0441 B9 0D       	cmp al, $0D		; '\r'
0124+  0443 C6 48 04    	je isspace_exit
0125+  0446 B9 0B       	cmp al, $0B		; '\v'
0126+  0448             isspace_exit:
0127+  0448 09          	ret	
0128+  0449             
0129+  0449             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0449             ; TO LOWER
0131+  0449             ; input in AL
0132+  0449             ; output in AL
0133+  0449             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  0449             to_lower:
0135+  0449 B9 5A       	cmp al, 'Z'
0136+  044B D1 50 04    	jgu to_lower_ret
0137+  044E 6A 20       	add al, $20				; convert to lower case
0138+  0450             to_lower_ret:
0139+  0450 09          	ret
0140+  0451             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  0451             ; TO UPPER
0142+  0451             ; input in AL
0143+  0451             ; output in AL
0144+  0451             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  0451             to_upper:
0146+  0451 B9 61       	cmp al, 'a'
0147+  0453 C8 58 04    	jlu to_upper_ret
0148+  0456 6F 20       	sub al, $20			; convert to upper case
0149+  0458             to_upper_ret:
0150+  0458 09          	ret
0151+  0459             
0169   0459             .include "lib/token.asm"
0001+  0459             TOKTYP_IDENTIFIER	.equ 0
0002+  0459             TOKTYP_KEYWORD		.equ 1
0003+  0459             TOKTYP_DELIMITER	.equ 2
0004+  0459             TOKTYP_STRING		.equ 3
0005+  0459             TOKTYP_CHAR			.equ 4
0006+  0459             TOKTYP_NUMERIC		.equ 5
0007+  0459             TOKTYP_END			.equ 6
0008+  0459             
0009+  0459             TOK_NULL			.equ 0
0010+  0459             TOK_FSLASH			.equ 1
0011+  0459             TOK_TIMES 			.equ 2
0012+  0459             TOK_PLUS 			.equ 3
0013+  0459             TOK_MINUS 			.equ 4
0014+  0459             TOK_DOT				.equ 5
0015+  0459             TOK_SEMI			.equ 6
0016+  0459             TOK_ANGLE			.equ 7
0017+  0459             TOK_TILDE			.equ 8
0018+  0459             TOK_EQUAL			.equ 9
0019+  0459             TOK_COLON			.equ 10
0020+  0459             TOK_COMMA			.equ 11
0021+  0459             
0022+  0459             TOK_END				.equ 20
0023+  0459             
0024+  0459             
0025+  0459             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  0459             ;; read a full command argment from shell input buffer
0027+  0459             ;; argument is written into tokstr
0028+  0459             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  0459             get_arg:
0030+  0459 D7          	push a
0031+  045A E2          	push si
0032+  045B E3          	push di
0033+  045C 19 00       	mov al, 0
0034+  045E 3D 87 06    	mov [tokstr], al			; nullify tokstr string
0035+  0461 14 83 06    	mov a, [prog]
0036+  0464 4D          	mov si, a
0037+  0465 FD 4F 87 06 	mov di, tokstr
0038+  0469             get_arg_skip_spaces:
0039+  0469 F6          	lodsb
0040+  046A 07 32 04    	call isspace
0041+  046D C6 69 04    	je get_arg_skip_spaces
0042+  0470             get_arg_L0:
0043+  0470 B9 3B       	cmp al, $3B				; check if is ';'
0044+  0472 C6 7F 04    	je get_arg_end
0045+  0475 B9 00       	cmp al, 0
0046+  0477 C6 7F 04    	je get_arg_end			; check if end of input
0047+  047A F7          	stosb
0048+  047B F6          	lodsb
0049+  047C 0A 70 04    	jmp get_arg_L0
0050+  047F             get_arg_end:
0051+  047F 19 00       	mov al, 0
0052+  0481 F7          	stosb
0053+  0482 D5 01 00    	sub si, 1
0054+  0485 4E          	mov a, si
0055+  0486 42 83 06    	mov [prog], a		; update pointer
0056+  0489 F0          	pop di
0057+  048A EF          	pop si
0058+  048B E4          	pop a
0059+  048C 09          	ret
0060+  048D             
0061+  048D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  048D             ;; read a path formation from shell input buffer
0063+  048D             ;; path is written into tokstr
0064+  048D             ;; /usr/bin
0065+  048D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  048D             get_path:
0067+  048D D7          	push a
0068+  048E E2          	push si
0069+  048F E3          	push di
0070+  0490 19 00       	mov al, 0
0071+  0492 3D 87 06    	mov [tokstr], al			; nullify tokstr string
0072+  0495 14 83 06    	mov a, [prog]
0073+  0498 4D          	mov si, a
0074+  0499 FD 4F 87 06 	mov di, tokstr
0075+  049D             get_path_skip_spaces:
0076+  049D F6          	lodsb
0077+  049E 07 32 04    	call isspace
0078+  04A1 C6 9D 04    	je get_path_skip_spaces
0079+  04A4             get_path_is_pathchar:
0080+  04A4 F7          	stosb
0081+  04A5 F6          	lodsb
0082+  04A6 07 BC 03    	call isalnum			;check if is alphanumeric
0083+  04A9 C6 A4 04    	je get_path_is_pathchar
0084+  04AC B9 2F       	cmp al, '/'				; check if is '/'
0085+  04AE C6 A4 04    	je get_path_is_pathchar
0086+  04B1 19 00       	mov al, 0
0087+  04B3 F7          	stosb
0088+  04B4 D5 01 00    	sub si, 1
0089+  04B7 4E          	mov a, si
0090+  04B8 42 83 06    	mov [prog], a		; update pointer
0091+  04BB             get_path_end:
0092+  04BB F0          	pop di
0093+  04BC EF          	pop si
0094+  04BD E4          	pop a
0095+  04BE 09          	ret
0096+  04BF             
0097+  04BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  04BF             ;; read a line
0099+  04BF             ;; line is written into tokstr
0100+  04BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  04BF             get_line:
0102+  04BF D7          	push a
0103+  04C0 E2          	push si
0104+  04C1 E3          	push di
0105+  04C2 19 00       	mov al, 0
0106+  04C4 3D 87 06    	mov [tokstr], al			; nullify tokstr string
0107+  04C7 14 83 06    	mov a, [prog]
0108+  04CA 4D          	mov si, a
0109+  04CB FD 4F 87 06 	mov di, tokstr
0110+  04CF             get_line_L0:
0111+  04CF F6          	lodsb
0112+  04D0 B9 0A       	cmp al, $0A		; check for new line
0113+  04D2 C6 D9 04    	je get_line_exit
0114+  04D5 F7          	stosb
0115+  04D6 0A CF 04    	jmp get_line_L0
0116+  04D9             get_line_exit:
0117+  04D9 19 00       	mov al, 0
0118+  04DB F7          	stosb
0119+  04DC 4E          	mov a, si
0120+  04DD 42 83 06    	mov [prog], a		; update pointer
0121+  04E0 F0          	pop di
0122+  04E1 EF          	pop si
0123+  04E2 E4          	pop a
0124+  04E3 09          	ret
0125+  04E4             
0126+  04E4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  04E4             ;; token parser
0128+  04E4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  04E4             get_token:
0130+  04E4 D7          	push a
0131+  04E5 DA          	push d
0132+  04E6 E2          	push si
0133+  04E7 E3          	push di
0134+  04E8 19 00       	mov al, 0
0135+  04EA 3D 87 06    	mov [tokstr], al			; nullify tokstr string
0136+  04ED 19 00       	mov al, TOK_NULL
0137+  04EF 3D 86 06    	mov [tok], al				; nullify token
0138+  04F2 14 83 06    	mov a, [prog]
0139+  04F5 4D          	mov si, a
0140+  04F6 FD 4F 87 06 	mov di, tokstr
0141+  04FA             get_tok_skip_spaces:
0142+  04FA F6          	lodsb
0143+  04FB 07 32 04    	call isspace
0144+  04FE C6 FA 04    	je get_tok_skip_spaces
0145+  0501 B9 00       	cmp al, 0			; check for end of input (NULL)
0146+  0503 C6 E8 05    	je get_token_end
0147+  0506 B9 23       	cmp al, '#'			; comments!
0148+  0508 C6 16 06    	je get_tok_comment
0149+  050B 07 BC 03    	call isalnum
0150+  050E C6 F5 05    	jz is_alphanumeric
0151+  0511             ; other token types
0152+  0511             get_token_slash:
0153+  0511 B9 2F       	cmp al, '/'				; check if '/'
0154+  0513 C7 2B 05    	jne get_token_minus
0155+  0516 F7          	stosb					; store '/' into token string
0156+  0517 19 00       	mov al, 0
0157+  0519 F7          	stosb					; terminate token string
0158+  051A 19 01       	mov al, TOK_FSLASH
0159+  051C 3D 86 06    	mov [tok], al			
0160+  051F 19 02       	mov al, TOKTYP_DELIMITER
0161+  0521 3D 85 06    	mov [toktyp], al
0162+  0524 4E          	mov a, si
0163+  0525 42 83 06    	mov [prog], a		; update pointer
0164+  0528 0A 11 06    	jmp get_token_return
0165+  052B             get_token_minus:
0166+  052B B9 2D       	cmp al, '-'				; check if '-'
0167+  052D C7 45 05    	jne get_token_comma
0168+  0530 F7          	stosb					; store '-' into token string
0169+  0531 19 00       	mov al, 0
0170+  0533 F7          	stosb					; terminate token string
0171+  0534 19 04       	mov al, TOK_MINUS
0172+  0536 3D 86 06    	mov [tok], al			
0173+  0539 19 02       	mov al, TOKTYP_DELIMITER
0174+  053B 3D 85 06    	mov [toktyp], al
0175+  053E 4E          	mov a, si
0176+  053F 42 83 06    	mov [prog], a		; update pointer
0177+  0542 0A 11 06    	jmp get_token_return
0178+  0545             get_token_comma:
0179+  0545 B9 2C       	cmp al, ','				; check if ','
0180+  0547 C7 5F 05    	jne get_token_semi
0181+  054A F7          	stosb					; store ',' into token string
0182+  054B 19 00       	mov al, 0
0183+  054D F7          	stosb					; terminate token string
0184+  054E 19 0B       	mov al, TOK_COMMA
0185+  0550 3D 86 06    	mov [tok], al			
0186+  0553 19 02       	mov al, TOKTYP_DELIMITER
0187+  0555 3D 85 06    	mov [toktyp], al
0188+  0558 4E          	mov a, si
0189+  0559 42 83 06    	mov [prog], a		; update pointer
0190+  055C 0A 11 06    	jmp get_token_return
0191+  055F             get_token_semi:
0192+  055F B9 3B       	cmp al, $3B				; check if ';'
0193+  0561 C7 79 05    	jne get_token_colon
0194+  0564 F7          	stosb					; store ';' into token string
0195+  0565 19 00       	mov al, 0
0196+  0567 F7          	stosb					; terminate token string
0197+  0568 19 06       	mov al, TOK_SEMI
0198+  056A 3D 86 06    	mov [tok], al			
0199+  056D 19 02       	mov al, TOKTYP_DELIMITER
0200+  056F 3D 85 06    	mov [toktyp], al
0201+  0572 4E          	mov a, si
0202+  0573 42 83 06    	mov [prog], a		; update pointer
0203+  0576 0A 11 06    	jmp get_token_return
0204+  0579             get_token_colon:
0205+  0579 B9 3A       	cmp al, $3A				; check if ':'
0206+  057B C7 93 05    	jne get_token_angle
0207+  057E F7          	stosb					; store ':' into token string
0208+  057F 19 00       	mov al, 0
0209+  0581 F7          	stosb					; terminate token string
0210+  0582 19 0A       	mov al, TOK_COLON
0211+  0584 3D 86 06    	mov [tok], al			
0212+  0587 19 02       	mov al, TOKTYP_DELIMITER
0213+  0589 3D 85 06    	mov [toktyp], al
0214+  058C 4E          	mov a, si
0215+  058D 42 83 06    	mov [prog], a		; update pointer
0216+  0590 0A 11 06    	jmp get_token_return
0217+  0593             get_token_angle:
0218+  0593 B9 3E       	cmp al, $3E				; check if '>'
0219+  0595 C7 AD 05    	jne get_token_tilde
0220+  0598 F7          	stosb					; store '>' into token string
0221+  0599 19 00       	mov al, 0
0222+  059B F7          	stosb					; terminate token string
0223+  059C 19 07       	mov al, TOK_ANGLE
0224+  059E 3D 86 06    	mov [tok], al			
0225+  05A1 19 02       	mov al, TOKTYP_DELIMITER
0226+  05A3 3D 85 06    	mov [toktyp], al
0227+  05A6 4E          	mov a, si
0228+  05A7 42 83 06    	mov [prog], a		; update pointer
0229+  05AA 0A 11 06    	jmp get_token_return
0230+  05AD             get_token_tilde:
0231+  05AD B9 7E       	cmp al, '~'				; check if '~'
0232+  05AF C7 C7 05    	jne get_token_equal
0233+  05B2 F7          	stosb					; store '~' into token string
0234+  05B3 19 00       	mov al, 0
0235+  05B5 F7          	stosb					; terminate token string
0236+  05B6 19 08       	mov al, TOK_TILDE
0237+  05B8 3D 86 06    	mov [tok], al			
0238+  05BB 19 02       	mov al, TOKTYP_DELIMITER
0239+  05BD 3D 85 06    	mov [toktyp], al
0240+  05C0 4E          	mov a, si
0241+  05C1 42 83 06    	mov [prog], a		; update pointer
0242+  05C4 0A 11 06    	jmp get_token_return
0243+  05C7             get_token_equal:
0244+  05C7 B9 3D       	cmp al, '='				; check if '='
0245+  05C9 C7 E1 05    	jne get_token_skip
0246+  05CC F7          	stosb					; store '=' into token string
0247+  05CD 19 00       	mov al, 0
0248+  05CF F7          	stosb					; terminate token string
0249+  05D0 19 09       	mov al, TOK_EQUAL
0250+  05D2 3D 86 06    	mov [tok], al			
0251+  05D5 19 02       	mov al, TOKTYP_DELIMITER
0252+  05D7 3D 85 06    	mov [toktyp], al
0253+  05DA 4E          	mov a, si
0254+  05DB 42 83 06    	mov [prog], a		; update pointer
0255+  05DE 0A 11 06    	jmp get_token_return
0256+  05E1             get_token_skip:
0257+  05E1 4E          	mov a, si
0258+  05E2 42 83 06    	mov [prog], a		; update pointer
0259+  05E5 0A 11 06    	jmp get_token_return
0260+  05E8             get_token_end:				; end of file token
0261+  05E8 19 14       	mov al, TOK_END
0262+  05EA 3D 86 06    	mov [tok], al
0263+  05ED 19 06       	mov al, TOKTYP_END
0264+  05EF 3D 85 06    	mov [toktyp], al
0265+  05F2 0A 11 06    	jmp get_token_return
0266+  05F5             is_alphanumeric:
0267+  05F5 F7          	stosb
0268+  05F6 F6          	lodsb
0269+  05F7 07 BC 03    	call isalnum			;check if is alphanumeric
0270+  05FA C6 F5 05    	jz is_alphanumeric
0271+  05FD B9 2E       	cmp al, $2E				; check if is '.'
0272+  05FF C6 F5 05    	je is_alphanumeric
0273+  0602 19 00       	mov al, 0
0274+  0604 F7          	stosb
0275+  0605 19 00       	mov al, TOKTYP_IDENTIFIER
0276+  0607 3D 85 06    	mov [toktyp], al
0277+  060A D5 01 00    	sub si, 1
0278+  060D 4E          	mov a, si
0279+  060E 42 83 06    	mov [prog], a		; update pointer
0280+  0611             get_token_return:
0281+  0611 F0          	pop di
0282+  0612 EF          	pop si
0283+  0613 E7          	pop d
0284+  0614 E4          	pop a
0285+  0615 09          	ret
0286+  0616             get_tok_comment:
0287+  0616 F6          	lodsb
0288+  0617 B9 0A       	cmp al, $0A			; new line
0289+  0619 C7 16 06    	jne get_tok_comment
0290+  061C 0A FA 04    	jmp get_tok_skip_spaces
0291+  061F             
0292+  061F             
0293+  061F             get_number:
0294+  061F D7          	push a
0295+  0620 DA          	push d
0296+  0621 E2          	push si
0297+  0622 E3          	push di
0298+  0623 19 00       	mov al, 0
0299+  0625 3D 87 06    	mov [tokstr], al			; nullify tokstr string
0300+  0628 19 00       	mov al, TOK_NULL
0301+  062A 3D 86 06    	mov [tok], al				; nullify token
0302+  062D 14 83 06    	mov a, [prog]
0303+  0630 4D          	mov si, a
0304+  0631 FD 4F 87 06 	mov di, tokstr
0305+  0635             get_number_skip_spaces:
0306+  0635 F6          	lodsb
0307+  0636 07 32 04    	call isspace
0308+  0639 C6 35 06    	je get_number_skip_spaces
0309+  063C B9 00       	cmp al, 0			; check for end of input (NULL)
0310+  063E C7 4E 06    	jne get_number_L0
0311+  0641 19 14       	mov al, TOK_END
0312+  0643 3D 86 06    	mov [tok], al
0313+  0646 19 06       	mov al, TOKTYP_END
0314+  0648 3D 85 06    	mov [toktyp], al
0315+  064B 0A 65 06    	jmp get_number_return
0316+  064E             get_number_L0:
0317+  064E F7          	stosb
0318+  064F F6          	lodsb
0319+  0650 07 C6 03    	call isdigit			;check if is numeric
0320+  0653 C6 4E 06    	jz get_number_L0
0321+  0656 19 00       	mov al, 0
0322+  0658 F7          	stosb
0323+  0659 19 05       	mov al, TOKTYP_NUMERIC
0324+  065B 3D 85 06    	mov [toktyp], al
0325+  065E D5 01 00    	sub si, 1
0326+  0661 4E          	mov a, si
0327+  0662 42 83 06    	mov [prog], a		; update pointer
0328+  0665             get_number_return:
0329+  0665 F0          	pop di
0330+  0666 EF          	pop si
0331+  0667 E7          	pop d
0332+  0668 E4          	pop a
0333+  0669 09          	ret
0334+  066A             
0335+  066A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  066A             ;; PUT BACK TOKEN
0337+  066A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
0338+  066A             putback:
0339+  066A D7          	push a
0340+  066B E2          	push si
0341+  066C FD 4D 87 06 	mov si, tokstr	
0342+  0670             putback_loop:
0343+  0670 F6          	lodsb
0344+  0671 B9 00       	cmp al, 0
0345+  0673 C6 80 06    	je putback_end
0346+  0676 14 83 06    	mov a, [prog]
0347+  0679 7D          	dec a
0348+  067A 42 83 06    	mov [prog], a			; update pointer
0349+  067D 0A 70 06    	jmp putback_loop
0350+  0680             putback_end:
0351+  0680 EF          	pop si
0352+  0681 E4          	pop a
0353+  0682 09          	ret
0354+  0683             
0355+  0683             
0356+  0683             
0357+  0683             
0358+  0683 00 00       prog:		.dw 0			; pointer to current position in buffer
0359+  0685             
0360+  0685 00          toktyp: 	.db 0			; token type symbol
0361+  0686 00          tok:		.db 0			; current token symbol
0362+  0687 00 00 00 00 tokstr:		.fill 256, 0	; token as a string
0362+  068B 00 00 00 00 
0362+  068F 00 00 00 00 
0362+  0693 00 00 00 00 
0362+  0697 00 00 00 00 
0362+  069B 00 00 00 00 
0362+  069F 00 00 00 00 
0362+  06A3 00 00 00 00 
0362+  06A7 00 00 00 00 
0362+  06AB 00 00 00 00 
0362+  06AF 00 00 00 00 
0362+  06B3 00 00 00 00 
0362+  06B7 00 00 00 00 
0362+  06BB 00 00 00 00 
0362+  06BF 00 00 00 00 
0362+  06C3 00 00 00 00 
0362+  06C7 00 00 00 00 
0362+  06CB 00 00 00 00 
0362+  06CF 00 00 00 00 
0362+  06D3 00 00 00 00 
0362+  06D7 00 00 00 00 
0362+  06DB 00 00 00 00 
0362+  06DF 00 00 00 00 
0362+  06E3 00 00 00 00 
0362+  06E7 00 00 00 00 
0362+  06EB 00 00 00 00 
0362+  06EF 00 00 00 00 
0362+  06F3 00 00 00 00 
0362+  06F7 00 00 00 00 
0362+  06FB 00 00 00 00 
0362+  06FF 00 00 00 00 
0362+  0703 00 00 00 00 
0362+  0707 00 00 00 00 
0362+  070B 00 00 00 00 
0362+  070F 00 00 00 00 
0362+  0713 00 00 00 00 
0362+  0717 00 00 00 00 
0362+  071B 00 00 00 00 
0362+  071F 00 00 00 00 
0362+  0723 00 00 00 00 
0362+  0727 00 00 00 00 
0362+  072B 00 00 00 00 
0362+  072F 00 00 00 00 
0362+  0733 00 00 00 00 
0362+  0737 00 00 00 00 
0362+  073B 00 00 00 00 
0362+  073F 00 00 00 00 
0362+  0743 00 00 00 00 
0362+  0747 00 00 00 00 
0362+  074B 00 00 00 00 
0362+  074F 00 00 00 00 
0362+  0753 00 00 00 00 
0362+  0757 00 00 00 00 
0362+  075B 00 00 00 00 
0362+  075F 00 00 00 00 
0362+  0763 00 00 00 00 
0362+  0767 00 00 00 00 
0362+  076B 00 00 00 00 
0362+  076F 00 00 00 00 
0362+  0773 00 00 00 00 
0362+  0777 00 00 00 00 
0362+  077B 00 00 00 00 
0362+  077F 00 00 00 00 
0362+  0783 00 00 00 00 
0170   0787             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0171   0787             
0172   0787             sys_bkpt      			.equ 0
0173   0787             sys_rtc        			.equ 1
0174   0787             sys_ide        			.equ 2
0175   0787             sys_io        			.equ 3
0176   0787             sys_filesystem  		.equ 4
0177   0787             sys_fork      			.equ 5
0178   0787             sys_list      			.equ 6
0179   0787             sys_datetime    		.equ 7
0180   0787             sys_reboot      		.equ 8
0181   0787             sys_pause_proc  		.equ 9
0182   0787             sys_resume_proc    	.equ 10
0183   0787             sys_terminate_proc  .equ 11
0184   0787             sys_system      		.equ 12
0185   0787             sys_boot_install  	.equ 13
0186   0787             
0187   0787             .export PROC_TEXT_ORG
0188   0787             .export sys_bkpt
0189   0787             .export sys_ide
0190   0787             .export sys_io
0191   0787             .export sys_filesystem
0192   0787             .export sys_fork
0193   0787             .export sys_list
0194   0787             .export sys_rtc
0195   0787             .export sys_datetime
0196   0787             .export sys_reboot
0197   0787             .export sys_pause_proc
0198   0787             .export sys_resume_proc
0199   0787             .export sys_terminate_proc
0200   0787             .export sys_system
0201   0787             .export sys_boot_install
0202   0787             
0203   0787             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0204   0787             ; EXTERNAL INTERRUPTS' CODE BLOCK
0205   0787             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0206   0787             ; uart
0207   0787             int_0:
0208   0787 06            sysret
0209   0788             int_1:
0210   0788 06            sysret
0211   0789             int_2:
0212   0789 06            sysret
0213   078A             int_3:
0214   078A 06            sysret
0215   078B             int_4:
0216   078B 06            sysret
0217   078C             int_5:
0218   078C 06            sysret
0219   078D             int_6:  
0220   078D             ; save all registers into kernel stack
0221   078D 4B            pusha
0222   078E 22 00         mov ah, 0
0223   0790 1D 27 16      mov al, [active_proc_index]
0224   0793 FD 99         shl a              ; x2
0225   0795 B7 E5 15      mov a, [proc_table_convert + a]  ; get process state start index
0226   0798                 
0227   0798 4F            mov di, a
0228   0799 48            mov a, sp
0229   079A 77            inc a
0230   079B 4D            mov si, a
0231   079C 38 14 00      mov c, 20
0232   079F FD F5         rep movsb          ; save process state!
0233   07A1             ; restore kernel stack position to point before interrupt arrived
0234   07A1 51 14 00      add sp, 20
0235   07A4             ; now load next process in queue
0236   07A4 1D 27 16      mov al, [active_proc_index]
0237   07A7 31 26 16      mov bl, [nbr_active_procs]
0238   07AA BA            cmp al, bl
0239   07AB C6 B2 07      je int6_cycle_back
0240   07AE 7A            inc al            ; next process is next in the series
0241   07AF 0A B4 07      jmp int6_continue
0242   07B2             int6_cycle_back:
0243   07B2 19 01         mov al, 1        ; next process = process 1
0244   07B4             int6_continue:
0245   07B4 3D 27 16      mov [active_proc_index], al    ; set next active proc
0246   07B7             
0247   07B7             ; calculate LUT entry for next process
0248   07B7 22 00         mov ah, 0
0249   07B9 FD 99         shl a              ; x2
0250   07BB B7 E5 15      mov a, [proc_table_convert + a]    ; get process state start index  
0251   07BE               
0252   07BE 4D            mov si, a            ; source is proc state block
0253   07BF 48            mov a, sp
0254   07C0 5F 13 00      sub a, 19
0255   07C3 4F            mov di, a            ; destination is kernel stack
0256   07C4             ; restore SP
0257   07C4 7D            dec a
0258   07C5 47            mov sp, a
0259   07C6 38 14 00      mov c, 20
0260   07C9 FD F5         rep movsb
0261   07CB             ; set VM process
0262   07CB 1D 27 16      mov al, [active_proc_index]
0263   07CE 01            setptb
0264   07CF                 
0265   07CF F2 E0 FF 00   mov byte[_TIMER_C_0], 0        ; load counter 0 low byte
0266   07D3 F2 E0 FF 10   mov byte[_TIMER_C_0], $10        ; load counter 0 high byte
0267   07D7                   
0268   07D7 4C            popa
0269   07D8 06            sysret
0270   07D9             
0271   07D9             int_7:
0272   07D9 D7            push a
0273   07DA DA            push d
0274   07DB E1            pushf
0275   07DC                   
0276   07DC 14 2C 16      mov a, [fifo_pi]
0277   07DF 3C            mov d, a
0278   07E0             
0279   07E0 1D 80 FF      mov al, [_UART0_DATA]  ; get character
0280   07E3 B9 03         cmp al, $03        ; CTRL-C
0281   07E5 C6 02 08      je CTRLC
0282   07E8 B9 1A         cmp al, $1A        ; CTRL-Z
0283   07EA C6 08 08      je CTRLZ
0284   07ED 3E            mov [d], al        ; add to fifo
0285   07EE               
0286   07EE 14 2C 16      mov a, [fifo_pi]
0287   07F1 77            inc a
0288   07F2 AF DA 26      cmp a, fifo + FIFO_SIZE         ; check if pointer reached the end of the fifo
0289   07F5 C7 FB 07      jne int_7_continue
0290   07F8 10 DA 1E      mov a, fifo  
0291   07FB             int_7_continue:  
0292   07FB 42 2C 16      mov [fifo_pi], a      ; update fifo pointer
0293   07FE               
0294   07FE EE            popf
0295   07FF E7            pop d
0296   0800 E4            pop a  
0297   0801 06            sysret
0298   0802             
0299   0802             CTRLC:
0300   0802 EE            popf
0301   0803 E7            pop d
0302   0804 E4            pop a
0303   0805 0A EF 14      jmp cmd_terminate_proc
0304   0808             
0305   0808             CTRLZ:
0306   0808 EE            popf
0307   0809 E7            pop d
0308   080A E4            pop a
0309   080B 0A 32 15      jmp cmd_pause_proc    ; pause current process and go back to the shell
0310   080E             
0311   080E             cmd_system_jmptbl:
0312   080E 16 08         .dw cmd_system_uname
0313   0810 1D 08         .dw cmd_system_whoami
0314   0812             
0315   0812             cmd_system:
0316   0812 FD 0A 0E 08   jmp [cmd_system_jmptbl + al]
0317   0816             cmd_system_uname:
0318   0816 3B 64 16      mov d, s_uname
0319   0819 07 88 02      call puts
0320   081C 06            sysret
0321   081D             cmd_system_whoami:
0322   081D 3B 6E 16      mov d, s_root
0323   0820 07 88 02      call puts
0324   0823 06            sysret
0325   0824             
0326   0824             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0327   0824             ; REBOOT SYSTEM
0328   0824             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0329   0824             syscall_reboot:
0330   0824 FD D7 FF FF   push word $FFFF 
0331   0828 FD DB 00      push byte %00000000        ; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
0332   082B FD D7 C0 01   push word BIOS_RESET_VECTOR    ; and then push RESET VECTOR of the shell to the stack
0333   082F 06            sysret
0334   0830             
0335   0830             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336   0830             ;; switch to another process
0337   0830             ;; inputs:
0338   0830             ;; AL = new process number
0339   0830             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0340   0830             resume_proc:
0341   0830 FD 78         mov g, a  ; save the process number
0342   0832             ; save all registers into kernel stack
0343   0832 4B            pusha
0344   0833 22 00         mov ah, 0
0345   0835 1D 27 16      mov al, [active_proc_index]
0346   0838 FD 99         shl a              ; x2
0347   083A B7 E5 15      mov a, [proc_table_convert + a]  ; get process state start index
0348   083D 4F            mov di, a
0349   083E 48            mov a, sp
0350   083F 77            inc a
0351   0840 4D            mov si, a
0352   0841 38 14 00      mov c, 20
0353   0844 FD F5         rep movsb          ; save process state!
0354   0846             ; restore kernel stack position to point before interrupt arrived
0355   0846 51 14 00      add sp, 20
0356   0849             ; now load the new process number!
0357   0849 FD 12         mov a, g            ; retrieve the process number argument that was saved in the beginning
0358   084B 3D 27 16      mov [active_proc_index], al    ; set new active proc
0359   084E             ; calculate LUT entry for next process
0360   084E 22 00         mov ah, 0
0361   0850 FD 99         shl a              ; x2
0362   0852 B7 E5 15      mov a, [proc_table_convert + a]    ; get process state start index  
0363   0855               
0364   0855 4D            mov si, a            ; source is proc state block
0365   0856 48            mov a, sp
0366   0857 5F 13 00      sub a, 19
0367   085A 4F            mov di, a            ; destination is kernel stack
0368   085B             ; restore SP
0369   085B 7D            dec a
0370   085C 47            mov sp, a
0371   085D 38 14 00      mov c, 20
0372   0860 FD F5         rep movsb
0373   0862             ; set VM process
0374   0862 1D 27 16      mov al, [active_proc_index]
0375   0865 01            setptb
0376   0866                   
0377   0866 4C            popa
0378   0867 06            sysret
0379   0868             
0380   0868             
0381   0868             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0382   0868             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0383   0868             list_procs:
0384   0868 3B 50 16      mov d, s_ps_header
0385   086B 07 88 02      call puts
0386   086E 3B CB 18      mov d, proc_availab_table + 1
0387   0871 38 01 00      mov c, 1
0388   0874             list_procs_L0:  
0389   0874 BD 01         cmp byte[d], 1
0390   0876 C7 9A 08      jne list_procs_next
0391   0879 2D            mov b, d
0392   087A 61 CA 18      sub b, proc_availab_table
0393   087D FD 9F 05      shl b, 5
0394   0880 DA            push d
0395   0881 D8            push b
0396   0882 28            mov b, c
0397   0883 07 24 03      call print_u8x
0398   0886 22 20         mov ah, ' '
0399   0888 07 4E 01      call putchar
0400   088B 07 4E 01      call putchar
0401   088E E5            pop b
0402   088F 74            mov d, b
0403   0890 58 DA 18      add d, proc_names
0404   0893 07 88 02      call puts
0405   0896 07 35 02      call printnl
0406   0899 E7            pop d
0407   089A             list_procs_next:
0408   089A 79            inc d
0409   089B 78            inc c
0410   089C C2 09 00      cmp c, 9
0411   089F C7 74 08      jne list_procs_L0
0412   08A2             list_procs_end:
0413   08A2 06            sysret
0414   08A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415   08A3             ; PRIVILEGE EXCEPTION
0416   08A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0417   08A3             trap_privilege:
0418   08A3 0A 24 08      jmp syscall_reboot
0419   08A6 DA            push d
0420   08A7             
0421   08A7 3B BC 16      mov d, s_priviledge
0422   08AA 07 88 02      call puts
0423   08AD             
0424   08AD E7            pop d
0425   08AE               
0426   08AE 06            sysret
0427   08AF             
0428   08AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0429   08AF             ; BREAKPOINT EXCEPTION
0430   08AF             ; IMPORTANT: values in the stack are being pushed in big endian. i.e.: MSB at low address
0431   08AF             ; and LSB at high address. *** NEED TO CORRECT THIS IN THE MICROCODE and make it little endian again ***
0432   08AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0433   08AF             syscall_breakpoint:
0434   08AF 4B            pusha
0435   08B0             syscall_break_prompt:
0436   08B0 3B 6A 09      mov d, s_break1
0437   08B3 07 88 02      call puts
0438   08B6 07 35 02      call printnl
0439   08B9 07 82 03      call scan_u16d
0440   08BC AF 00 00      cmp a, 0
0441   08BF C6 CA 08      je syscall_break_regs
0442   08C2 AF 01 00      cmp a, 1
0443   08C5 C6 ED 08      je syscall_break_mem
0444   08C8             syscall_break_end:  
0445   08C8 4C            popa
0446   08C9 06            sysret
0447   08CA             syscall_break_regs:
0448   08CA 48            mov a, sp
0449   08CB 53 0E 00      add a, 14  ; back-track 7 registers
0450   08CE 3C            mov d, a
0451   08CF 3A 07         mov cl, 7
0452   08D1             syscall_regs_L0:
0453   08D1 2A            mov b, [d]
0454   08D2 FD AB         swp b
0455   08D4 07 E0 02      call print_u16x  ; print register value
0456   08D7 07 35 02      call printnl
0457   08DA 63 02 00      sub d, 2
0458   08DD 71 01         sub cl, 1
0459   08DF C3 00         cmp cl, 0
0460   08E1 C7 D1 08      jne syscall_regs_L0
0461   08E4 0A B0 08      jmp syscall_break_prompt
0462   08E7 07 35 02      call printnl
0463   08EA 0A B0 08      jmp syscall_break_prompt
0464   08ED             syscall_break_mem:
0465   08ED 07 35 02      call printnl
0466   08F0 07 02 03      call scan_u16x
0467   08F3 4D            mov si, a      ; data source from user space
0468   08F4 FD 4F DA 26   mov di, scrap_sector    ; destination in kernel space
0469   08F8 38 00 02      mov c, 512
0470   08FB 04            load        ; transfer data to kernel space!
0471   08FC 3B DA 26      mov d, scrap_sector    ; dump pointer in d
0472   08FF 38 00 00      mov c, 0
0473   0902             dump_loop:
0474   0902 84            mov al, cl
0475   0903 87 0F         and al, $0F
0476   0905 C6 53 09      jz print_base
0477   0908             back:
0478   0908 1E            mov al, [d]        ; read byte
0479   0909 2F            mov bl, al
0480   090A 07 24 03      call print_u8x
0481   090D 10 00 20      mov a, $2000
0482   0910 05 03         syscall sys_io      ; space
0483   0912 84            mov al, cl
0484   0913 87 0F         and al, $0F
0485   0915 B9 0F         cmp al, $0F
0486   0917 C6 28 09      je print_ascii
0487   091A             back1:
0488   091A 79            inc d
0489   091B 78            inc c
0490   091C C2 00 02      cmp c, 512
0491   091F C7 02 09      jne dump_loop
0492   0922 07 35 02      call printnl
0493   0925 0A B0 08      jmp syscall_break_prompt  ; go to syscall_breakpoint return point
0494   0928             print_ascii:
0495   0928 10 00 20      mov a, $2000
0496   092B 05 03         syscall sys_io
0497   092D 63 10 00      sub d, 16
0498   0930 26 10 00      mov b, 16
0499   0933             print_ascii_L:
0500   0933 79            inc d
0501   0934 1E            mov al, [d]        ; read byte
0502   0935 B9 20         cmp al, $20
0503   0937 C8 3F 09      jlu dot
0504   093A B9 7E         cmp al, $7E
0505   093C D0 47 09      jleu ascii
0506   093F             dot:
0507   093F 10 00 2E      mov a, $2E00
0508   0942 05 03         syscall sys_io
0509   0944 0A 4C 09      jmp ascii_continue
0510   0947             ascii:
0511   0947 23            mov ah, al
0512   0948 19 00         mov al, 0
0513   094A 05 03         syscall sys_io
0514   094C             ascii_continue:
0515   094C FD A9 33 09   loopb print_ascii_L
0516   0950 0A 1A 09      jmp back1
0517   0953             print_base:
0518   0953 07 35 02      call printnl
0519   0956 2D            mov b, d
0520   0957 61 DA 26      sub b, scrap_sector      ; remove this later and fix address bases which display incorrectly
0521   095A 07 E0 02      call print_u16x        ; display row
0522   095D 10 00 3A      mov a, $3A00
0523   0960 05 03         syscall sys_io
0524   0962 10 00 20      mov a, $2000
0525   0965 05 03         syscall sys_io
0526   0967 0A 08 09      jmp back
0527   096A             
0528   096A 0A 44 65 62 s_break1:  .db "\nDebugger entry point.\n"
0528   096E 75 67 67 65 
0528   0972 72 20 65 6E 
0528   0976 74 72 79 20 
0528   097A 70 6F 69 6E 
0528   097E 74 2E 0A 
0529   0981 30 2E 20 53       .db "0. Show Registers\n"
0529   0985 68 6F 77 20 
0529   0989 52 65 67 69 
0529   098D 73 74 65 72 
0529   0991 73 0A 
0530   0993 31 2E 20 53       .db "1. Show 512B RAM block\n"
0530   0997 68 6F 77 20 
0530   099B 35 31 32 42 
0530   099F 20 52 41 4D 
0530   09A3 20 62 6C 6F 
0530   09A7 63 6B 0A 
0531   09AA 32 2E 20 43       .db "2. Continue Execution", 0
0531   09AE 6F 6E 74 69 
0531   09B2 6E 75 65 20 
0531   09B6 45 78 65 63 
0531   09BA 75 74 69 6F 
0531   09BE 6E 00 
0532   09C0             
0533   09C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0534   09C0             ; DIVIDE BY ZERO EXCEPTION
0535   09C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0536   09C0             trap_div_zero:
0537   09C0 D7            push a
0538   09C1 DA            push d
0539   09C2 E1            pushf
0540   09C3                 
0541   09C3 3B E4 16      mov d, s_divzero
0542   09C6 07 88 02      call puts
0543   09C9               
0544   09C9 EE            popf
0545   09CA E7            pop d
0546   09CB E4            pop a
0547   09CC                           ; enable interrupts
0548   09CC 06            sysret
0549   09CD             
0550   09CD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0551   09CD             ; UNDEFINED OPCODE EXCEPTION
0552   09CD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0553   09CD             undefined_opcode:
0554   09CD 06            sysret
0555   09CE             
0556   09CE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557   09CE             ; RTC SERVICES INTERRUPT
0558   09CE             ; RTC I/O bank = FFA0 to FFAF
0559   09CE             ; FFA0 to FFA7 is scratch RAM
0560   09CE             ; control register at $FFA8 [ W | R | S | Cal4..Cal0 ]
0561   09CE             ; al = 0..6 -> get
0562   09CE             ; al = 7..D -> set
0563   09CE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0564   09CE             syscall_rtc:
0565   09CE DB            push al
0566   09CF DA            push d
0567   09D0 B9 06         cmp al, 6
0568   09D2 D1 E7 09      jgu syscall_rtc_set
0569   09D5             syscall_rtc_get:
0570   09D5 6A A9         add al, $A9      ; generate RTC address to get to address A9 of clock
0571   09D7 22 FF         mov ah, $FF    
0572   09D9 3C            mov d, a        ; get to FFA9 + offset
0573   09DA F2 A8 FF 40   mov byte[$FFA8], $40    ; set R bit to 1
0574   09DE 1E            mov al, [d]      ; get data
0575   09DF F2 A8 FF 00   mov byte[$FFA8], 0    ; reset R bit
0576   09E3 23            mov ah, al
0577   09E4 E7            pop d
0578   09E5 E8            pop al
0579   09E6 06            sysret
0580   09E7             syscall_rtc_set:
0581   09E7 DD            push bl
0582   09E8 99            mov bl, ah    ; set data asIDE
0583   09E9 6A A2         add al, $A2    ; generate RTC address to get to address A9 of clock
0584   09EB 22 FF         mov ah, $FF    
0585   09ED 3C            mov d, a    ; get to FFA9 + offset
0586   09EE 1B            mov al, bl    ; get data back
0587   09EF F2 A8 FF 80   mov byte[$FFA8], $80  ; set W bit to 1
0588   09F3 3E            mov [d], al    ; set data
0589   09F4 F2 A8 FF 00   mov byte[$FFA8], 0    ; reset write bit
0590   09F8 EA            pop bl
0591   09F9 E7            pop d
0592   09FA E8            pop al
0593   09FB 06            sysret
0594   09FC             
0595   09FC             datetime_serv_tbl:
0596   09FC 04 0A         .dw print_date
0597   09FE 78 0A         .dw set_date
0598   0A00             datetime_services:
0599   0A00 FD 0A FC 09   jmp [datetime_serv_tbl + al]      
0600   0A04             print_date:
0601   0A04 10 00 0D      mov a, $0D00        ; print carriage return char
0602   0A07 19 03         mov al, 3
0603   0A09 05 01         syscall sys_rtc        ; get week
0604   0A0B 1A            mov al, ah
0605   0A0C 22 00         mov ah, 0
0606   0A0E FD 9D 02      shl a, 2          
0607   0A11 3B 6E 17      mov d, s_week
0608   0A14 59            add d, a
0609   0A15 07 88 02      call puts
0610   0A18 10 00 20      mov a, $2000
0611   0A1B 05 03         syscall sys_io          ; display ' '
0612   0A1D               
0613   0A1D 19 04         mov al, 4
0614   0A1F 05 01         syscall sys_rtc          ; get day
0615   0A21 99            mov bl, ah
0616   0A22 07 24 03      call print_u8x
0617   0A25 10 00 20      mov a, $2000
0618   0A28 05 03         syscall sys_io          ; display ' '
0619   0A2A             ; there is a problem with the month displaying
0620   0A2A             ; the month is stored as BCD. so when retrieving the month, the value will be in binary
0621   0A2A             ; even though it is to be understood as BCD.
0622   0A2A             ; when retrieving the value and adding the string table address offset the value will go overboard!  
0623   0A2A 19 05         mov al, 05
0624   0A2C 05 01         syscall sys_rtc        ; get month
0625   0A2E 1A            mov al, ah
0626   0A2F 22 00         mov ah, 0
0627   0A31 FD 9D 02      shl a, 2          
0628   0A34 3B 3A 17      mov d, s_months
0629   0A37 59            add d, a
0630   0A38 07 88 02      call puts
0631   0A3B               
0632   0A3B 10 00 20      mov a, $2000
0633   0A3E 05 03         syscall sys_io      ; display ' '
0634   0A40               
0635   0A40 2E 20         mov bl, $20
0636   0A42 07 24 03      call print_u8x      ; print 20 for year prefix
0637   0A45 19 06         mov al, 06
0638   0A47 05 01         syscall sys_rtc          ; get year
0639   0A49 99            mov bl, ah
0640   0A4A 07 24 03      call print_u8x
0641   0A4D               
0642   0A4D 10 00 20      mov a, $2000  
0643   0A50 05 03         syscall sys_io      ; display ' '
0644   0A52             
0645   0A52 19 02         mov al, 2
0646   0A54 05 01         syscall sys_rtc          ; get hours
0647   0A56 99            mov bl, ah
0648   0A57 07 24 03      call print_u8x
0649   0A5A 10 00 3A      mov a, $3A00    
0650   0A5D 05 03         syscall sys_io        ; display ':'
0651   0A5F             
0652   0A5F 19 01         mov al, 01
0653   0A61 05 01         syscall sys_rtc          ; get minutes
0654   0A63 99            mov bl, ah
0655   0A64 07 24 03      call print_u8x
0656   0A67 10 00 3A      mov a, $3A00  
0657   0A6A 05 03         syscall sys_io      ; display ':'
0658   0A6C             
0659   0A6C 19 00         mov al, 0
0660   0A6E 05 01         syscall sys_rtc          ; get seconds
0661   0A70 99            mov bl, ah
0662   0A71 07 24 03      call print_u8x
0663   0A74               
0664   0A74 07 35 02      call printnl
0665   0A77 06            sysret
0666   0A78               
0667   0A78             set_date:
0668   0A78 3B FF 16      mov d, s_set_year
0669   0A7B 07 88 02      call puts
0670   0A7E 07 6B 03      call scan_u8x        ; read integer into A
0671   0A81 FD 9D 08      shl a, 8        ; only AL used, move to AH
0672   0A84 19 0D         mov al, 0Dh        ; set RTC year
0673   0A86 05 01         syscall sys_rtc          ; set RTC
0674   0A88               
0675   0A88 3B 06 17      mov d, s_set_month
0676   0A8B 07 88 02      call puts
0677   0A8E 07 6B 03      call scan_u8x          ; read integer into A
0678   0A91 FD 9D 08      shl a, 8        ; only AL used, move to AH
0679   0A94 19 0C         mov al, 0Ch        ; set RTC month
0680   0A96 05 01         syscall sys_rtc          ; set RTC
0681   0A98             
0682   0A98 3B 0E 17      mov d, s_set_day
0683   0A9B 07 88 02      call puts
0684   0A9E 07 6B 03      call scan_u8x          ; read integer into A
0685   0AA1 FD 9D 08      shl a, 8        ; only AL used, move to AH
0686   0AA4 19 0B         mov al, 0Bh        ; set RTC month
0687   0AA6 05 01         syscall sys_rtc          ; set RTC
0688   0AA8             
0689   0AA8 3B 14 17      mov d, s_set_week
0690   0AAB 07 88 02      call puts
0691   0AAE 07 6B 03      call scan_u8x          ; read integer into A
0692   0AB1 FD 9D 08      shl a, 8        ; only AL used, move to AH
0693   0AB4 19 0A         mov al, 0Ah        ; set RTC month
0694   0AB6 05 01         syscall sys_rtc          ; set RTC
0695   0AB8             
0696   0AB8 3B 1E 17      mov d, s_set_hours
0697   0ABB 07 88 02      call puts
0698   0ABE 07 6B 03      call scan_u8x          ; read integer into A
0699   0AC1 FD 9D 08      shl a, 8        ; only AL used, move to AH
0700   0AC4 19 09         mov al, 09h        ; set RTC month
0701   0AC6 05 01         syscall sys_rtc          ; set RTC
0702   0AC8             
0703   0AC8 3B 26 17      mov d, s_set_minutes
0704   0ACB 07 88 02      call puts
0705   0ACE 07 6B 03      call scan_u8x          ; read integer into A
0706   0AD1 FD 9D 08      shl a, 8        ; only AL used, move to AH
0707   0AD4 19 08         mov al, 08h        ; set RTC month
0708   0AD6 05 01         syscall sys_rtc          ; set RTC
0709   0AD8             
0710   0AD8 3B 30 17      mov d, s_set_seconds
0711   0ADB 07 88 02      call puts
0712   0ADE 07 6B 03      call scan_u8x          ; read integer into A
0713   0AE1 FD 9D 08      shl a, 8          ; only AL used, move to AH
0714   0AE4 19 07         mov al, 07h        ; set RTC month
0715   0AE6 05 01         syscall sys_rtc          ; set RTC
0716   0AE8 06            sysret
0717   0AE9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0718   0AE9             ; IDE SERVICES INTERRUPT
0719   0AE9             ; al = option
0720   0AE9             ; 0 = IDE reset, 1 = IDE sleep, 2 = read sector, 3 = write sector
0721   0AE9             ; IDE read/write sector
0722   0AE9             ; 512 bytes
0723   0AE9             ; user buffer pointer in D
0724   0AE9             ; AH = number of sectors
0725   0AE9             ; CB = LBA bytes 3..0
0726   0AE9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0727   0AE9             ide_serv_tbl:
0728   0AE9 F5 0A         .dw ide_reset
0729   0AEB 09 0B         .dw ide_sleep
0730   0AED 18 0B         .dw ide_read_sect_wrapper
0731   0AEF 1C 0B         .dw ide_write_sect_wrapper
0732   0AF1             ide_services:
0733   0AF1 FD 0A E9 0A   jmp [ide_serv_tbl + al]    
0734   0AF5               
0735   0AF5             ide_reset:      
0736   0AF5 F2 D7 FF 04   mov byte[_ide_R7], 4    ; RESET IDE
0737   0AF9 07 A2 0B      call ide_wait        ; wait for IDE ready             
0738   0AFC F2 D6 FF E0   mov byte[_ide_R6], $E0    ; LBA3= 0, MASTER, MODE= LBA        
0739   0B00 F2 D1 FF 01   mov byte[_ide_R1], 1    ; 8-BIT TRANSFERS      
0740   0B04 F2 D7 FF EF   mov byte[_ide_R7], $EF    ; SET FEATURE COMMAND
0741   0B08 06            sysret
0742   0B09             ide_sleep:
0743   0B09 07 A2 0B      call ide_wait          ; wait for IDE ready             
0744   0B0C F2 D6 FF 40   mov byte [_ide_R6], %01000000  ; lba[3:0](reserved), bit 6=1
0745   0B10 F2 D7 FF E6   mov byte [_ide_R7], $E6    ; sleep command
0746   0B14 07 A2 0B      call ide_wait          ; wait for IDE ready
0747   0B17 06            sysret
0748   0B18             ide_read_sect_wrapper:
0749   0B18 07 20 0B      call ide_read_sect
0750   0B1B 06            sysret
0751   0B1C             ide_write_sect_wrapper:
0752   0B1C 07 46 0B      call ide_write_sect
0753   0B1F 06            sysret
0754   0B20             ide_read_sect:
0755   0B20 1A            mov al, ah
0756   0B21 24            mov ah, bl
0757   0B22 42 D2 FF      mov [_ide_R2], a      ; number of sectors (0..255)
0758   0B25 1C            mov al, bh
0759   0B26 3D D4 FF      mov [_ide_R4], al
0760   0B29 12            mov a, c
0761   0B2A 3D D5 FF      mov [_ide_R5], al
0762   0B2D 1A            mov al, ah
0763   0B2E 87 0F         and al, %00001111
0764   0B30 8B E0         or al, %11100000      ; mode lba, master
0765   0B32 3D D6 FF      mov [_ide_R6], al
0766   0B35             ide_read_sect_wait:
0767   0B35 1D D7 FF      mov al, [_ide_R7]  
0768   0B38 87 80         and al, $80        ; BUSY FLAG
0769   0B3A C7 35 0B      jnz ide_read_sect_wait
0770   0B3D 19 20         mov al, $20
0771   0B3F 3D D7 FF      mov [_ide_R7], al      ; read sector cmd
0772   0B42 07 6C 0B      call ide_read  
0773   0B45 09            ret
0774   0B46             ide_write_sect:
0775   0B46 1A            mov al, ah
0776   0B47 24            mov ah, bl
0777   0B48 42 D2 FF      mov [_ide_R2], a      ; number of sectors (0..255)
0778   0B4B 1C            mov al, bh
0779   0B4C 3D D4 FF      mov [_ide_R4], al
0780   0B4F 12            mov a, c
0781   0B50 3D D5 FF      mov [_ide_R5], al
0782   0B53 1A            mov al, ah
0783   0B54 87 0F         and al, %00001111
0784   0B56 8B E0         or al, %11100000      ; mode lba, master
0785   0B58 3D D6 FF      mov [_ide_R6], al
0786   0B5B             ide_write_sect_wait:
0787   0B5B 1D D7 FF      mov al, [_ide_R7]  
0788   0B5E 87 80         and al, $80        ; BUSY FLAG
0789   0B60 C7 5B 0B      jnz ide_write_sect_wait
0790   0B63 19 30         mov al, $30
0791   0B65 3D D7 FF      mov [_ide_R7], al      ; write sector cmd
0792   0B68 07 87 0B      call ide_write      
0793   0B6B 09            ret
0794   0B6C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0795   0B6C             ; READ IDE DATA
0796   0B6C             ; pointer in D
0797   0B6C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0798   0B6C             ide_read:
0799   0B6C DA            push d
0800   0B6D             ide_read_loop:
0801   0B6D 1D D7 FF      mov al, [_ide_R7]  
0802   0B70 87 80         and al, 80h        ; BUSY FLAG
0803   0B72 C7 6D 0B      jnz ide_read_loop      ; wait loop
0804   0B75               
0805   0B75 1D D7 FF      mov al, [_ide_R7]
0806   0B78 87 08         and al, %00001000      ; DRQ FLAG
0807   0B7A C6 85 0B      jz ide_read_end
0808   0B7D 1D D0 FF      mov al, [_ide_R0]
0809   0B80 3E            mov [d], al
0810   0B81 79            inc d
0811   0B82 0A 6D 0B      jmp ide_read_loop
0812   0B85             ide_read_end:
0813   0B85 E7            pop d
0814   0B86 09            ret
0815   0B87             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0816   0B87             ; WRITE IDE DATA
0817   0B87             ; data pointer in D
0818   0B87             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0819   0B87             ide_write:
0820   0B87 DA            push d
0821   0B88             ide_write_loop:
0822   0B88 1D D7 FF      mov al, [_ide_R7]  
0823   0B8B 87 80         and al, 80h        ; BUSY FLAG
0824   0B8D C7 88 0B      jnz ide_write_loop      ; wait loop
0825   0B90               
0826   0B90 1D D7 FF      mov al, [_ide_R7]
0827   0B93 87 08         and al, %00001000      ; DRQ FLAG
0828   0B95 C6 A0 0B      jz ide_write_end
0829   0B98 1E            mov al, [d]
0830   0B99 3D D0 FF      mov [_ide_R0], al
0831   0B9C 79            inc d 
0832   0B9D 0A 88 0B      jmp ide_write_loop
0833   0BA0             ide_write_end:
0834   0BA0 E7            pop d
0835   0BA1 09            ret
0836   0BA2             
0837   0BA2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0838   0BA2             ; wait for IDE to be ready
0839   0BA2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0840   0BA2             ide_wait:
0841   0BA2 1D D7 FF      mov al, [_ide_R7]  
0842   0BA5 87 80         and al, 80h        ; BUSY FLAG
0843   0BA7 C7 A2 0B      jnz ide_wait
0844   0BAA 09            ret
0845   0BAB             
0846   0BAB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0847   0BAB             ; i/o interrupt
0848   0BAB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0849   0BAB             io_services_jmp:
0850   0BAB CE 0B         .dw io_putchar
0851   0BAD DB 0B         .dw io_getchar
0852   0BAF B5 0B         .dw io_uart_init
0853   0BB1             
0854   0BB1             io_services:
0855   0BB1 FD 0A AB 0B   jmp [io_services_jmp + al]
0856   0BB5             io_uart_init:
0857   0BB5 F2 83 FF 83   mov byte[_UART0_LCR], $83      ; 8 data, 1 stop, no parity  , divisor latch = 1, UART address 3 = Line Control Register
0858   0BB9 F2 80 FF 03   mov byte[_UART0_DLAB_0], 3      ; baud = 38400, divisor latch low byte = 3
0859   0BBD F2 81 FF 00   mov byte[_UART0_DLAB_1], 0      ; divisor latch high byte = 0      
0860   0BC1 F2 83 FF 03   mov byte[_UART0_LCR], 3      ; UART address 3 = Line Control Register
0861   0BC5 F2 81 FF 01   mov byte[_UART0_IER], 1      ; enable interrupt: receive data available
0862   0BC9 F2 82 FF 00   mov byte[_UART0_FCR], 0      ; disable FIFO
0863   0BCD 06            sysret
0864   0BCE             ; char in ah
0865   0BCE             io_putchar:
0866   0BCE             io_putchar_L0:
0867   0BCE 1D 85 FF      mov al, [_UART0_LSR]      ; read Line Status Register
0868   0BD1 93 20         test al, $20          ; isolate Transmitter Empty
0869   0BD3 C6 CE 0B      jz io_putchar_L0    
0870   0BD6 1A            mov al, ah
0871   0BD7 3D 80 FF      mov [_UART0_DATA], al      ; write char to Transmitter Holding Register
0872   0BDA 06            sysret
0873   0BDB             ; char in ah
0874   0BDB             ; al = sucess code
0875   0BDB             io_getchar:
0876   0BDB D8            push b
0877   0BDC DA            push d
0878   0BDD             io_getchar_L0:  
0879   0BDD 14 2E 16      mov a, [fifo_pr]
0880   0BE0 29 2C 16      mov b, [fifo_pi]
0881   0BE3 B0            cmp a, b
0882   0BE4 C6 0C 0C      je io_getchar_fail
0883   0BE7               
0884   0BE7 3C            mov d, a
0885   0BE8 1E            mov al, [d]
0886   0BE9 DB            push al
0887   0BEA               
0888   0BEA 14 2E 16      mov a, [fifo_pr]
0889   0BED 77            inc a
0890   0BEE AF DA 26      cmp a, fifo + FIFO_SIZE        ; check if pointer reached the end of the fifo
0891   0BF1 C7 F7 0B      jne io_getchar_cont
0892   0BF4 10 DA 1E      mov a, fifo  
0893   0BF7             io_getchar_cont:  
0894   0BF7 42 2E 16      mov [fifo_pr], a      ; update fifo pointer
0895   0BFA               
0896   0BFA E9            pop ah
0897   0BFB             ; here we just echo the char back to the console
0898   0BFB             io_getchar_echo_L0:
0899   0BFB 1D 85 FF      mov al, [_UART0_LSR]      ; read Line Status Register
0900   0BFE 93 20         test al, $20          ; isolate Transmitter Empty
0901   0C00 C6 FB 0B      jz io_getchar_echo_L0
0902   0C03 1A            mov al, ah
0903   0C04 3D 80 FF      mov [_UART0_DATA], al      ; write char to Transmitter Holding Register
0904   0C07             
0905   0C07 19 01         mov al, 1    ; AL = 1 means a char successfully received
0906   0C09 E7            pop d
0907   0C0A E5            pop b
0908   0C0B 06            sysret
0909   0C0C             io_getchar_fail:
0910   0C0C E7            pop d
0911   0C0D E5            pop b
0912   0C0E 19 00         mov al, 0      ; AL = 0 means no char received
0913   0C10 06            sysret
0914   0C11             
0915   0C11             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0916   0C11             ;; FILE SYSTEM DATA
0917   0C11             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0918   0C11             ; infor for : IDE SERVICES INTERRUPT
0919   0C11             ; IDE read/write 512-byte sector
0920   0C11             ; al = option
0921   0C11             ; user buffer pointer in D
0922   0C11             ; AH = number of sectors
0923   0C11             ; CB = LBA bytes 3..0  
0924   0C11             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0925   0C11             ;; FILE SYSTEM DATA STRUCTURE
0926   0C11             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0927   0C11             ; for a directory we have the header first, followed by metadata
0928   0C11             ; header 1 sector (512 bytes)
0929   0C11             ; metadata 1 sector (512 bytes)
0930   0C11             ; HEADER ENTRIES:
0931   0C11             ; filename (64)
0932   0C11             ; parent dir LBA (2) -  to be used for faster backwards navigation...
0933   0C11             ;
0934   0C11             ; metadata entries:
0935   0C11             ; filename (24)
0936   0C11             ; attributes (1)  |_|_|file_type(3bits)|x|w|r| types: file, directory, character device
0937   0C11             ; LBA (2)
0938   0C11             ; size (2)
0939   0C11             ; day (1)
0940   0C11             ; month (1)
0941   0C11             ; year (1)
0942   0C11             ; packet size = 32 bytes
0943   0C11             ;
0944   0C11             ; first directory on disk is the root directory '/'
0945   0C11             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0946   0C11             ;; FILE SYSTEM DISK FORMATTING
0947   0C11             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0948   0C11             ; writes FST_TOTAL_SECTORS + FS_NBR_FILES disk sectors  with 0's
0949   0C11             ; this is the file system table formating
0950   0C11             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0951   0C11             file_system_jmptbl:
0952   0C11 41 0C         .dw file_system_mkfs
0953   0C13 EC 0C         .dw cmd_fs_space
0954   0C15 ED 0C         .dw cmd_mkdir
0955   0C17 66 10         .dw cmd_cd
0956   0C19 6B 10         .dw cmd_ls
0957   0C1B 54 11         .dw cmd_mktxt
0958   0C1D D5 11         .dw cmd_mkbin
0959   0C1F 92 12         .dw cmd_pwd
0960   0C21 00 13         .dw cmd_cat
0961   0C23 5C 13         .dw cmd_rmdir          ; 9
0962   0C25 B8 13         .dw cmd_rm
0963   0C27 00 00         .dw 0
0964   0C29 00 00         .dw 0
0965   0C2B 00 00         .dw 0              ; 13
0966   0C2D 70 0C         .dw fileio_chmod        ; 14
0967   0C2F 20 14         .dw cmd_mv            ; 15
0968   0C31 69 0C         .dw cd_goto_root        ; 16
0969   0C33 62 10         .dw get_current_dirID      ; 17
0970   0C35 3E 0E         .dw get_path_from_dirID      ; 18
0971   0C37 A4 0E         .dw get_dirID_from_path_user  ; 19
0972   0C39 BE 0F         .dw loadfile_from_path_user    ; 20  
0973   0C3B 2E 0F         .dw file_exists_by_path_user  ; 21
0974   0C3D             file_system:
0975   0C3D FD 0A 11 0C   jmp [file_system_jmptbl + al]
0976   0C41             
0977   0C41             file_system_mkfs:  
0978   0C41 FD 4F DA 28   mov di, transient_area
0979   0C45 19 00         mov al, 0
0980   0C47 38 00 02      mov c, 512
0981   0C4A FD F7         rep stosb
0982   0C4C 26 20 00      mov b, FST_LBA_START
0983   0C4F 38 00 00      mov c, 0        ; reset LBA to 0
0984   0C52             file_system_mkfs_L1:  
0985   0C52 22 01         mov ah, $01      ; one sect
0986   0C54 3B DA 28      mov d, transient_area
0987   0C57 07 46 0B      call ide_write_sect
0988   0C5A FD 77         inc b
0989   0C5C C0 00 08      cmp b, CF_CARD_LBA_SIZE
0990   0C5F C7 52 0C      jne file_system_mkfs_L1
0991   0C62             file_system_mkfs_create_root:
0992   0C62 10 20 00      mov a, ROOT_dirID
0993   0C65 42 30 16      mov [current_dirID], a    ; set current directory LBA to ROOT
0994   0C68 06            sysret  
0995   0C69               
0996   0C69             cd_goto_root:
0997   0C69 10 20 00      mov a, ROOT_dirID
0998   0C6C 42 30 16      mov [current_dirID], a    ; set current directory LBA to ROOT
0999   0C6F 06            sysret  
1000   0C70             
1001   0C70             ; filename in D (userspace data)
1002   0C70             ; permission in BL
1003   0C70             fileio_chmod:
1004   0C70 DD            push bl
1005   0C71 FD 4E         mov si, d
1006   0C73 FD 4F DA 1C   mov di, temp_data
1007   0C77 38 80 00      mov c, 128
1008   0C7A 04            load          ; load filename from user-space
1009   0C7B                 
1010   0C7B 14 30 16      mov a, [current_dirID]
1011   0C7E 77            inc a        ; metadata sector
1012   0C7F 27            mov b, a
1013   0C80 38 00 00      mov c, 0        ; reset LBA to 0
1014   0C83 22 01         mov ah, $01      ; disk read
1015   0C85 3B DA 28      mov d, transient_area
1016   0C88 07 20 0B      call ide_read_sect    ; read directory
1017   0C8B FD 10         cla
1018   0C8D 42 28 16      mov [index], a    ; reset file counter
1019   0C90             fileio_chmod_L1:
1020   0C90 FD 4E         mov si, d
1021   0C92 FD 4F DA 1C   mov di, temp_data
1022   0C96 07 93 00      call strcmp
1023   0C99 C6 B0 0C      je fileio_chmod_found_entry
1024   0C9C             
1025   0C9C 58 20 00      add d, 32
1026   0C9F 14 28 16      mov a, [index]
1027   0CA2 77            inc a
1028   0CA3 42 28 16      mov [index], a
1029   0CA6 AF 10 00      cmp a, FST_FILES_PER_DIR
1030   0CA9 C7 90 0C      jne fileio_chmod_L1
1031   0CAC EA            pop bl
1032   0CAD 0A C9 0C      jmp fileio_chmod_not_found
1033   0CB0             fileio_chmod_found_entry:  
1034   0CB0 FD 79         mov g, b          ; save LBA
1035   0CB2 EA            pop bl            ; retrieve saved permission value
1036   0CB3 1F 18 00      mov al, [d + 24]      ; read file permissions
1037   0CB6 87 F8         and al, %11111000      ; remove all permissions, keep other flags
1038   0CB8 8C            or al, bl          ; set new permissions
1039   0CB9 3F 18 00      mov [d + 24], al      ; write new permissions
1040   0CBC 38 00 00      mov c, 0
1041   0CBF 3B DA 28      mov d, transient_area
1042   0CC2 22 01         mov ah, $01        ; disk write 1 sect
1043   0CC4 FD 27         mov b, g          ; retrieve LBA
1044   0CC6 07 46 0B      call ide_write_sect    ; write sector
1045   0CC9             fileio_chmod_not_found:
1046   0CC9 06            sysret
1047   0CCA             
1048   0CCA             ;; bootloader installer
1049   0CCA             ;; kernel LBA address in A
1050   0CCA             cmd_boot_installer:
1051   0CCA D7            push a
1052   0CCB 26 00 00      mov b, 0
1053   0CCE 38 00 00      mov c, 0
1054   0CD1 22 01         mov ah, $01        ; 1 sector
1055   0CD3 3B DA 28      mov d, transient_area
1056   0CD6 07 20 0B      call ide_read_sect      ; read sector
1057   0CD9               
1058   0CD9 E4            pop a
1059   0CDA 44 FE 01      mov [d + 510], a    ; update LBA address
1060   0CDD 26 00 00      mov b, 0
1061   0CE0 38 00 00      mov c, 0
1062   0CE3 22 01         mov ah, $01        ; 1 sector
1063   0CE5 3B DA 28      mov d, transient_area
1064   0CE8 07 46 0B      call ide_write_sect    ; write sector
1065   0CEB               
1066   0CEB 06            sysret
1067   0CEC             
1068   0CEC             cmd_fs_space:
1069   0CEC 06            sysret
1070   0CED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1071   0CED             ;; CREATE NEW DIRECTORY
1072   0CED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1073   0CED             ; search list for NULL name entry. add new directory to list
1074   0CED             cmd_mkdir:
1075   0CED FD 4E         mov si, d
1076   0CEF FD 4F DA 1C   mov di, temp_data
1077   0CF3 38 00 02      mov c, 512
1078   0CF6 04            load            ; load data from user-space
1079   0CF7 26 22 00      mov b, FST_LBA_START + 2   ; start at 2 because LBA  0 is ROOT (this would also cause issues                 
1080   0CFA                             ; when checking for NULL name, since root has a NULL name)
1081   0CFA 38 00 00      mov c, 0          ; reset LBA to 0
1082   0CFD             cmd_mkdir_L1:  
1083   0CFD 22 01         mov ah, $01      ; disk read
1084   0CFF 3B DA 28      mov d, transient_area
1085   0D02 07 20 0B      call ide_read_sect    ; read sector
1086   0D05 BD 00         cmp byte[d], 0      ; check for NULL
1087   0D07 C6 10 0D      je cmd_mkdir_found_null
1088   0D0A 55 02 00      add b, FST_SECTORS_PER_DIR          ; skip directory
1089   0D0D 0A FD 0C      jmp cmd_mkdir_L1
1090   0D10             cmd_mkdir_found_null:
1091   0D10             ;create header file by grabbing dir name from parameter
1092   0D10 D8            push b        ; save new directory's LBA
1093   0D11 38 40 00      mov c, 64
1094   0D14 FD 4D DA 1C   mov si, temp_data
1095   0D18 FD 4F DA 28   mov di, transient_area
1096   0D1C FD F5         rep movsb          ; copy dirname from temp_data to transient_area
1097   0D1E 14 30 16      mov a, [current_dirID]
1098   0D21 42 1A 29      mov [transient_area + 64], a    ; store parent directory LBA
1099   0D24 19 00         mov al, 0
1100   0D26 FD 4F DA 2A   mov di, transient_area + 512
1101   0D2A 38 00 02      mov c, 512
1102   0D2D FD F7         rep stosb          ; clean buffer
1103   0D2F 38 00 00      mov c, 0        ; reset LBA(c) to 0
1104   0D32             ; write directory entry sectors
1105   0D32 3B DA 28      mov d, transient_area
1106   0D35 22 02         mov ah, $02      ; disk write, 2 sectors
1107   0D37 07 46 0B      call ide_write_sect    ; write sector
1108   0D3A             ; now we need to add the new directory to the list, insIDE the current directory
1109   0D3A 14 30 16      mov a, [current_dirID]
1110   0D3D 53 01 00      add a, 1
1111   0D40 27            mov b, a          ; metadata sector
1112   0D41 38 00 00      mov c, 0
1113   0D44 FD 79         mov g, b          ; save LBA
1114   0D46 3B DA 28      mov d, transient_area
1115   0D49 22 01         mov ah, $01      ; disk read
1116   0D4B 07 20 0B      call ide_read_sect    ; read metadata sector
1117   0D4E             cmd_mkdir_L2:
1118   0D4E BD 00         cmp byte[d], 0
1119   0D50 C6 59 0D      je cmd_mkdir_found_null2
1120   0D53 58 20 00      add d, FST_ENTRY_SIZE
1121   0D56 0A 4E 0D      jmp cmd_mkdir_L2          ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1122   0D59             cmd_mkdir_found_null2:
1123   0D59 FD 4D DA 1C   mov si, temp_data
1124   0D5D FD 50         mov di, d
1125   0D5F 07 A8 00      call strcpy      ; copy directory name
1126   0D62 58 18 00      add d, 24      ; goto ATTRIBUTES
1127   0D65 19 0B         mov al, %00001011    ;directory, no execute, write, read
1128   0D67 3E            mov [d], al      
1129   0D68 79            inc d
1130   0D69 E5            pop b
1131   0D6A D8            push b        ; push LBA back
1132   0D6B FD 43         mov [d], b      ; save LBA
1133   0D6D             ; set file creation date  
1134   0D6D 58 04 00      add d, 4
1135   0D70 19 04         mov al, 4
1136   0D72 05 01         syscall sys_rtc
1137   0D74 1A            mov al, ah
1138   0D75 3E            mov [d], al      ; set day
1139   0D76 79            inc d
1140   0D77 19 05         mov al, 5
1141   0D79 05 01         syscall sys_rtc
1142   0D7B 1A            mov al, ah
1143   0D7C 3E            mov [d], al      ; set month
1144   0D7D 79            inc d
1145   0D7E 19 06         mov al, 6
1146   0D80 05 01         syscall sys_rtc
1147   0D82 1A            mov al, ah
1148   0D83 3E            mov [d], al      ; set year
1149   0D84             ; write sector into disk for new directory entry
1150   0D84 FD 27         mov b, g
1151   0D86 38 00 00      mov c, 0
1152   0D89 3B DA 28      mov d, transient_area
1153   0D8C 22 01         mov ah, $01      ; disk write, 1 sector
1154   0D8E 07 46 0B      call ide_write_sect    ; write sector
1155   0D91             
1156   0D91             ; after adding the new directory's information to its parent directory's list
1157   0D91             ; we need to now enter the new directory, and to it add two new directories!
1158   0D91             ; which directories do we need to add ? '..' and '.' are the directories needed.
1159   0D91             ; importantly, note that these two new directories are only entries in the list
1160   0D91             ; and do not have actual physical entries in the disk as real directories.
1161   0D91             ; i.e. they only exist as list entries in the new directory created so that
1162   0D91             ; the new directory can reference its parent and itself
1163   0D91             ;
1164   0D91             ; we need to add both '..' and '.'
1165   0D91             ; this first section is for '..' and on the section below we do the same for '.'
1166   0D91 E4            pop a            ; retrieve the new directory's LBA  
1167   0D92 D7            push a            ; and save again
1168   0D93 53 01 00      add a, 1
1169   0D96 27            mov b, a          ; metadata sector
1170   0D97 38 00 00      mov c, 0
1171   0D9A FD 79         mov g, b          ; save LBA
1172   0D9C 3B DA 28      mov d, transient_area
1173   0D9F 22 01         mov ah, $01      ; disk read
1174   0DA1 07 20 0B      call ide_read_sect    ; read metadata sector
1175   0DA4             cmd_mkdir_L3:
1176   0DA4 BD 00         cmp byte[d], 0
1177   0DA6 C6 AF 0D      je cmd_mkdir_found_null3
1178   0DA9 58 20 00      add d, FST_ENTRY_SIZE
1179   0DAC 0A A4 0D      jmp cmd_mkdir_L3  ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1180   0DAF             cmd_mkdir_found_null3:
1181   0DAF FD 4D 3D 16   mov si, s_parent_dir
1182   0DB3 FD 50         mov di, d
1183   0DB5 07 A8 00      call strcpy      ; copy directory name
1184   0DB8 58 18 00      add d, 24      ; goto ATTRIBUTES
1185   0DBB 19 0B         mov al, %00001011    ;directory, no execute, write, read, 
1186   0DBD 3E            mov [d], al      
1187   0DBE 79            inc d
1188   0DBF 29 30 16      mov b, [current_dirID]  ; retrieve the parent directorys LBA
1189   0DC2 FD 43         mov [d], b      ; save LBA
1190   0DC4             ; set file creation date  
1191   0DC4 58 04 00      add d, 4
1192   0DC7 19 04         mov al, 4
1193   0DC9 05 01         syscall sys_rtc
1194   0DCB 1A            mov al, ah
1195   0DCC 3E            mov [d], al      ; set day
1196   0DCD 79            inc d
1197   0DCE 19 05         mov al, 5
1198   0DD0 05 01         syscall sys_rtc
1199   0DD2 1A            mov al, ah
1200   0DD3 3E            mov [d], al      ; set month
1201   0DD4 79            inc d
1202   0DD5 19 06         mov al, 6
1203   0DD7 05 01         syscall sys_rtc
1204   0DD9 1A            mov al, ah
1205   0DDA 3E            mov [d], al      ; set year
1206   0DDB             ; write sector into disk for new directory entry
1207   0DDB FD 27         mov b, g
1208   0DDD 38 00 00      mov c, 0
1209   0DE0 3B DA 28      mov d, transient_area
1210   0DE3 22 01         mov ah, $01      ; disk write, 1 sector
1211   0DE5 07 46 0B      call ide_write_sect    ; write sector
1212   0DE8             
1213   0DE8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1214   0DE8             ; like we did above for '..', we need to now add the '.' directory to the list.
1215   0DE8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1216   0DE8 E4            pop a            ; retrieve the new directory's LBA  
1217   0DE9 D7            push a
1218   0DEA 53 01 00      add a, 1
1219   0DED 27            mov b, a          ; metadata sector
1220   0DEE 38 00 00      mov c, 0
1221   0DF1 FD 79         mov g, b          ; save LBA
1222   0DF3 3B DA 28      mov d, transient_area
1223   0DF6 22 01         mov ah, $01        ; disk read
1224   0DF8 07 20 0B      call ide_read_sect        ; read metadata sector
1225   0DFB             cmd_mkdir_L4:
1226   0DFB BD 00         cmp byte[d], 0
1227   0DFD C6 06 0E      je cmd_mkdir_found_null4
1228   0E00 58 20 00      add d, FST_ENTRY_SIZE
1229   0E03 0A FB 0D      jmp cmd_mkdir_L4  ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1230   0E06             cmd_mkdir_found_null4:
1231   0E06 FD 4D 40 16   mov si, s_current_dir
1232   0E0A FD 50         mov di, d
1233   0E0C 07 A8 00      call strcpy      ; copy directory name
1234   0E0F 58 18 00      add d, 24      ; goto ATTRIBUTES
1235   0E12 19 0B         mov al, %00001011    ;directory, no execute, write, read, 
1236   0E14 3E            mov [d], al      
1237   0E15 79            inc d
1238   0E16 E5            pop b        ; new directory's LBA itself. for self-referential directory entry '.'
1239   0E17 FD 43         mov [d], b      ; save LBA
1240   0E19             ; set file creation date  
1241   0E19 58 04 00      add d, 4
1242   0E1C 19 04         mov al, 4
1243   0E1E 05 01         syscall sys_rtc
1244   0E20 1A            mov al, ah
1245   0E21 3E            mov [d], al      ; set day
1246   0E22 79            inc d
1247   0E23 19 05         mov al, 5
1248   0E25 05 01         syscall sys_rtc
1249   0E27 1A            mov al, ah
1250   0E28 3E            mov [d], al      ; set month
1251   0E29 79            inc d
1252   0E2A 19 06         mov al, 6
1253   0E2C 05 01         syscall sys_rtc
1254   0E2E 1A            mov al, ah
1255   0E2F 3E            mov [d], al      ; set year
1256   0E30             ; write sector into disk for new directory entry
1257   0E30 FD 27         mov b, g
1258   0E32 38 00 00      mov c, 0
1259   0E35 3B DA 28      mov d, transient_area
1260   0E38 22 01         mov ah, $01      ; disk write, 1 sector
1261   0E3A 07 46 0B      call ide_write_sect    ; write sector
1262   0E3D             cmd_mkdir_end:
1263   0E3D 06            sysret
1264   0E3E             
1265   0E3E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1266   0E3E             ;; get path from a given directory dirID
1267   0E3E             ;; pseudo code:
1268   0E3E             ;  get_path_from_dirID(int dirID, char *D){
1269   0E3E             ;    if(dirID == 0){
1270   0E3E             ;      reverse path in D;
1271   0E3E             ;      return;
1272   0E3E             ;    }
1273   0E3E             ;    else{
1274   0E3E             ;      copy directory name to end of D;
1275   0E3E             ;      add '/' to end of D;
1276   0E3E             ;      parentID = get parent directory ID;
1277   0E3E             ;      get_path_from_dirID(parentID, D);
1278   0E3E             ;    }
1279   0E3E             ;  }
1280   0E3E             ;; A = dirID
1281   0E3E             ;; D = generated path string pointer
1282   0E3E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1283   0E3E             ;; sample path: /usr/bin
1284   0E3E             get_path_from_dirID:
1285   0E3E 3B DA 1A      mov d, filename
1286   0E41 19 00         mov al, 0
1287   0E43 3E            mov [d], al        ; initialize path string 
1288   0E44 14 30 16      mov a, [current_dirID]
1289   0E47 07 54 0E      call get_path_from_dirID_E0
1290   0E4A 3B DA 1A      mov d, filename
1291   0E4D 07 3C 00      call strrev
1292   0E50 07 88 02      call puts
1293   0E53 06            sysret
1294   0E54             get_path_from_dirID_E0:
1295   0E54 07 73 0E      call get_dirname_from_dirID
1296   0E57 FD 4D 42 16   mov si, s_fslash
1297   0E5B FD 50         mov di, d
1298   0E5D 07 B6 00      call strcat            ; add '/' to end of path
1299   0E60 AF 20 00      cmp a, ROOT_dirID        ; check if we are at the root directory
1300   0E63 C6 72 0E      je get_path_from_dirID_root
1301   0E66 07 90 0E      call get_parentID_from_dirID  ; use current ID (A) to find parentID (into A)
1302   0E69 AF 20 00      cmp a, ROOT_dirID        ; check if we are at the root directory
1303   0E6C C6 72 0E      je get_path_from_dirID_root
1304   0E6F 07 54 0E      call get_path_from_dirID_E0    ; recursively call itself
1305   0E72             get_path_from_dirID_root:
1306   0E72 09            ret
1307   0E73             
1308   0E73             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1309   0E73             ;; inputs:
1310   0E73             ;; A = directory ID
1311   0E73             ;; outputs:
1312   0E73             ;; D = pointer to directory name string
1313   0E73             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1314   0E73             get_dirname_from_dirID:
1315   0E73 D7            push a
1316   0E74 D8            push b
1317   0E75 DA            push d
1318   0E76 27            mov b, a
1319   0E77 38 00 00      mov c, 0        ; reset LBA to 0
1320   0E7A 22 01         mov ah, $01      ; disk read
1321   0E7C 3B DA 26      mov d, transient_area - 512
1322   0E7F 07 20 0B      call ide_read_sect      ; read directory
1323   0E82 07 3C 00      call strrev        ; reverse dir name before copying
1324   0E85 FD 4E         mov si, d
1325   0E87 E7            pop d          ; destination address = D value pushed at beginning
1326   0E88 FD 50         mov di, d
1327   0E8A 07 B6 00      call strcat        ; copy filename to D
1328   0E8D E5            pop b
1329   0E8E E4            pop a
1330   0E8F 09            ret
1331   0E90             
1332   0E90             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1333   0E90             ;; inputs:
1334   0E90             ;; A = directory ID
1335   0E90             ;; outputs:
1336   0E90             ;; A = parent directory ID
1337   0E90             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1338   0E90             get_parentID_from_dirID:
1339   0E90 D8            push b
1340   0E91 DA            push d
1341   0E92 27            mov b, a
1342   0E93 38 00 00      mov c, 0        ; reset LBA to 0
1343   0E96 22 01         mov ah, $01      ; disk read
1344   0E98 3B DA 26      mov d, transient_area - 512
1345   0E9B 07 20 0B      call ide_read_sect      ; read directory
1346   0E9E 16 40 00      mov a, [d + 64]      ; copy parent ID value to A
1347   0EA1 E7            pop d
1348   0EA2 E5            pop b
1349   0EA3 09            ret
1350   0EA4             
1351   0EA4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1352   0EA4             ;; get dirID from a given path string
1353   0EA4             ;; inputs:
1354   0EA4             ;; D = path pointer 
1355   0EA4             ;; outputs:
1356   0EA4             ;; A = dirID
1357   0EA4             ;; if dir non existent, A = FFFF (fail code)
1358   0EA4             ;; /usr/local/bin    - absolute
1359   0EA4             ;; local/bin/games    - relative
1360   0EA4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1361   0EA4             get_dirID_from_path_user:
1362   0EA4 FD 4E         mov si, d
1363   0EA6 FD 4F DA 1C   mov di, temp_data
1364   0EAA 38 00 02      mov c, 512
1365   0EAD 04            load
1366   0EAE 07 B2 0E      call get_dirID_from_path
1367   0EB1 06            sysret
1368   0EB2             
1369   0EB2             get_dirID_from_path:
1370   0EB2 26 DA 1C      mov b, temp_data
1371   0EB5 FD 42 83 06   mov [prog], b      ; token pointer set to path string
1372   0EB9 07 E4 04      call get_token
1373   0EBC 31 86 06      mov bl, [tok]
1374   0EBF C1 01         cmp bl, TOK_FSLASH
1375   0EC1 C6 CD 0E      je get_dirID_from_path_abs 
1376   0EC4 14 30 16      mov a, [current_dirID]
1377   0EC7 07 6A 06      call putback
1378   0ECA 0A D0 0E      jmp get_dirID_from_path_E0
1379   0ECD             get_dirID_from_path_abs:
1380   0ECD 10 20 00      mov a, ROOT_dirID
1381   0ED0             get_dirID_from_path_E0:
1382   0ED0 07 E4 04      call get_token
1383   0ED3 31 85 06      mov bl, [toktyp]
1384   0ED6 C1 00         cmp bl, TOKTYP_IDENTIFIER
1385   0ED8 C7 29 0F      jne get_dirID_from_path_end  ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1386   0EDB             
1387   0EDB FD 4D 87 06   mov si, tokstr
1388   0EDF FD 4F DA 1A   mov di, filename
1389   0EE3 07 A8 00      call strcpy        
1390   0EE6 77            inc a          ; metadata sector
1391   0EE7 27            mov b, a
1392   0EE8 38 00 00      mov c, 0        ; reset LBA to 0
1393   0EEB 22 01         mov ah, $01      ; disk read
1394   0EED 3B DA 28      mov d, transient_area
1395   0EF0 07 20 0B      call ide_read_sect    ; read directory
1396   0EF3 FD 10         cla
1397   0EF5 42 28 16      mov [index], a
1398   0EF8             get_dirID_from_path_L1:
1399   0EF8 FD 4E         mov si, d
1400   0EFA FD 4F DA 1A   mov di, filename
1401   0EFE 07 93 00      call strcmp
1402   0F01 C6 17 0F      je get_dirID_from_path_name_equal  
1403   0F04 58 20 00      add d, 32
1404   0F07 14 28 16      mov a, [index]
1405   0F0A 77            inc a
1406   0F0B 42 28 16      mov [index], a
1407   0F0E AF 10 00      cmp a, FST_FILES_PER_DIR
1408   0F11 C6 2A 0F      je get_dirID_from_path_fail
1409   0F14 0A F8 0E      jmp get_dirID_from_path_L1
1410   0F17             get_dirID_from_path_name_equal:
1411   0F17 58 19 00      add d, 25          ; 
1412   0F1A 15            mov a, [d]          ; set result register A = dirID
1413   0F1B 07 E4 04      call get_token
1414   0F1E 31 86 06      mov bl, [tok]
1415   0F21 C1 01         cmp bl, TOK_FSLASH      ; check if there are more elements in the path
1416   0F23 C6 D0 0E      je get_dirID_from_path_E0
1417   0F26 07 6A 06      call putback
1418   0F29             get_dirID_from_path_end:
1419   0F29 09            ret
1420   0F2A             get_dirID_from_path_fail:
1421   0F2A 10 FF FF      mov A, $FFFF
1422   0F2D 09            ret
1423   0F2E             
1424   0F2E             
1425   0F2E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1426   0F2E             ;; check if file exists by a given path string
1427   0F2E             ;; inputs:
1428   0F2E             ;; D = path pointer 
1429   0F2E             ;; OUTPUTS:
1430   0F2E             ;; A = success code, if file exists gives LBA, else, give 0
1431   0F2E             ;; /usr/local/bin/ed
1432   0F2E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1433   0F2E             file_exists_by_path_user:
1434   0F2E FD 4E         mov si, d
1435   0F30 FD 4F DA 1C   mov di, temp_data
1436   0F34 38 00 02      mov c, 512
1437   0F37 04            load
1438   0F38 07 3C 0F      call file_exists_by_path
1439   0F3B 06            sysret
1440   0F3C             file_exists_by_path:
1441   0F3C 26 DA 1C      mov b, temp_data
1442   0F3F FD 42 83 06   mov [prog], b      ; token pointer set to path string
1443   0F43 07 E4 04      call get_token
1444   0F46 31 86 06      mov bl, [tok]
1445   0F49 C1 01         cmp bl, TOK_FSLASH
1446   0F4B C6 57 0F      je  file_exists_by_path_abs
1447   0F4E 14 30 16      mov a, [current_dirID]
1448   0F51 07 6A 06      call putback
1449   0F54 0A 5A 0F      jmp file_exists_by_path_E0
1450   0F57             file_exists_by_path_abs:
1451   0F57 10 20 00      mov a, ROOT_dirID
1452   0F5A             file_exists_by_path_E0:
1453   0F5A 07 E4 04      call get_token
1454   0F5D 31 85 06      mov bl, [toktyp]
1455   0F60 C1 00         cmp bl, TOKTYP_IDENTIFIER
1456   0F62 C7 BA 0F      jne file_exists_by_path_end  ; check if there are tokens after '/'
1457   0F65 FD 4D 87 06   mov si, tokstr
1458   0F69 FD 4F DA 1A   mov di, filename
1459   0F6D 07 A8 00      call strcpy        
1460   0F70 77            inc a          ; metadata sector
1461   0F71 27            mov b, a
1462   0F72 38 00 00      mov c, 0        ; reset LBA to 0
1463   0F75 22 01         mov ah, $01      ; disk read
1464   0F77 3B DA 28      mov d, transient_area
1465   0F7A 07 20 0B      call ide_read_sect    ; read directory
1466   0F7D FD 10         cla
1467   0F7F 42 28 16      mov [index], a
1468   0F82             file_exists_by_path_L1:
1469   0F82 FD 4E         mov si, d
1470   0F84 FD 4F DA 1A   mov di, filename
1471   0F88 07 93 00      call strcmp
1472   0F8B C6 A1 0F      je   file_exists_by_path_name_equal
1473   0F8E 58 20 00      add d, 32
1474   0F91 14 28 16      mov a, [index]
1475   0F94 77            inc a
1476   0F95 42 28 16      mov [index], a
1477   0F98 AF 10 00      cmp a, FST_FILES_PER_DIR
1478   0F9B C6 BA 0F      je file_exists_by_path_end
1479   0F9E 0A 82 0F      jmp file_exists_by_path_L1
1480   0FA1             file_exists_by_path_name_equal:
1481   0FA1 33 18 00      mov bl, [d + 24]
1482   0FA4 FD 87 38      and bl, %00111000      ; directory flag
1483   0FA7 C1 08         cmp bl, %00001000      ; is dir?
1484   0FA9 C6 B0 0F      je file_exists_by_path_isdir;
1485   0FAC             ; entry is a file
1486   0FAC 16 19 00      mov a, [d + 25]      ; get and return LBA of file
1487   0FAF 09            ret
1488   0FB0             file_exists_by_path_isdir:
1489   0FB0 58 19 00      add d, 25          ; 
1490   0FB3 15            mov a, [d]          ; set result register A = dirID
1491   0FB4 07 E4 04      call get_token
1492   0FB7 0A 5A 0F      jmp file_exists_by_path_E0
1493   0FBA             file_exists_by_path_end:
1494   0FBA 10 00 00      mov a, 0      ; return 0 because file was not found
1495   0FBD 09            ret
1496   0FBE             
1497   0FBE             
1498   0FBE             
1499   0FBE             
1500   0FBE             
1501   0FBE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1502   0FBE             ;; load file data from a given path string
1503   0FBE             ;; inputs:
1504   0FBE             ;; D = path pointer 
1505   0FBE             ;; DI = userspace program data destination
1506   0FBE             ;; /usr/local/bin/ed
1507   0FBE             ;; ./ed
1508   0FBE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1509   0FBE             loadfile_from_path_user:
1510   0FBE E3            push di
1511   0FBF FD 4E         mov si, d
1512   0FC1 FD 4F DA 1C   mov di, temp_data
1513   0FC5 38 00 02      mov c, 512
1514   0FC8 04            load
1515   0FC9 07 D6 0F      call loadfile_from_path
1516   0FCC F0            pop di
1517   0FCD FD 4D DA 28   mov si, transient_area
1518   0FD1 38 00 3E      mov c, 512 * (FS_SECTORS_PER_FILE-1)
1519   0FD4 03            store
1520   0FD5 06            sysret
1521   0FD6             loadfile_from_path:
1522   0FD6 26 DA 1C      mov b, temp_data
1523   0FD9 FD 42 83 06   mov [prog], b      ; token pointer set to path string
1524   0FDD 07 E4 04      call get_token
1525   0FE0 31 86 06      mov bl, [tok]
1526   0FE3 C1 01         cmp bl, TOK_FSLASH
1527   0FE5 C6 F1 0F      je loadfile_from_path_abs 
1528   0FE8 14 30 16      mov a, [current_dirID]
1529   0FEB 07 6A 06      call putback
1530   0FEE 0A F4 0F      jmp loadfile_from_path_E0
1531   0FF1             loadfile_from_path_abs:
1532   0FF1 10 20 00      mov a, ROOT_dirID
1533   0FF4             loadfile_from_path_E0:
1534   0FF4 07 E4 04      call get_token
1535   0FF7 31 85 06      mov bl, [toktyp]
1536   0FFA C1 00         cmp bl, TOKTYP_IDENTIFIER
1537   0FFC C7 61 10      jne loadfile_from_path_end  ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1538   0FFF FD 4D 87 06   mov si, tokstr
1539   1003 FD 4F DA 1A   mov di, filename
1540   1007 07 A8 00      call strcpy        
1541   100A 77            inc a          ; metadata sector
1542   100B 27            mov b, a
1543   100C 38 00 00      mov c, 0        ; reset LBA to 0
1544   100F 22 01         mov ah, $01      ; disk read
1545   1011 3B DA 28      mov d, transient_area
1546   1014 07 20 0B      call ide_read_sect    ; read directory
1547   1017 FD 10         cla
1548   1019 42 28 16      mov [index], a
1549   101C             loadfile_from_path_L1:
1550   101C FD 4E         mov si, d
1551   101E FD 4F DA 1A   mov di, filename
1552   1022 07 93 00      call strcmp
1553   1025 C6 3B 10      je loadfile_from_path_name_equal  
1554   1028 58 20 00      add d, 32
1555   102B 14 28 16      mov a, [index]
1556   102E 77            inc a
1557   102F 42 28 16      mov [index], a
1558   1032 AF 10 00      cmp a, FST_FILES_PER_DIR
1559   1035 C6 61 10      je loadfile_from_path_end
1560   1038 0A 1C 10      jmp loadfile_from_path_L1
1561   103B             loadfile_from_path_name_equal:
1562   103B 33 18 00      mov bl, [d + 24]
1563   103E FD 87 38      and bl, %00111000      ; directory flag
1564   1041 C1 08         cmp bl, %00001000      ; is dir?
1565   1043 C6 57 10      je loadfile_isdirectory  ;
1566   1046             ; entry is a file
1567   1046 2B 19 00      mov b, [d + 25]      ; get LBA
1568   1049 FD 77         inc b        ; add 1 to B because the LBA for data comes after the header sector
1569   104B 3B DA 28      mov d, transient_area
1570   104E 38 00 00      mov c, 0
1571   1051 22 1F         mov ah, FS_SECTORS_PER_FILE-1    ; number of sectors
1572   1053 07 20 0B      call ide_read_sect        ; read sector
1573   1056 09            ret
1574   1057             loadfile_isdirectory:
1575   1057 58 19 00      add d, 25          ; 
1576   105A 15            mov a, [d]          ; set result register A = dirID
1577   105B 07 E4 04      call get_token
1578   105E 0A F4 0F      jmp loadfile_from_path_E0
1579   1061             loadfile_from_path_end:
1580   1061 09            ret
1581   1062             
1582   1062             
1583   1062             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1584   1062             ;; return the ID of the current directory
1585   1062             ;; ID returned in B
1586   1062             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1587   1062             get_current_dirID:
1588   1062 29 30 16      mov b, [current_dirID]
1589   1065 06            sysret
1590   1066             
1591   1066             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1592   1066             ;; CD
1593   1066             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1594   1066             ; new dirID in B
1595   1066             cmd_cd:
1596   1066 FD 42 30 16   mov [current_dirID], b
1597   106A 06            sysret  
1598   106B             
1599   106B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1600   106B             ;; LS
1601   106B             ;; dirID in B
1602   106B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1603   106B             cmd_ls:
1604   106B FD 77         inc b        ; metadata sector
1605   106D 38 00 00      mov c, 0        ; reset LBA to 0
1606   1070 22 01         mov ah, $01      ; disk read
1607   1072 3B DA 28      mov d, transient_area
1608   1075 07 20 0B      call ide_read_sect    ; read directory
1609   1078 FD 10         cla
1610   107A 42 28 16      mov [index], a    ; reset entry index
1611   107D             cmd_ls_L1:
1612   107D BD 00         cmp byte [d], 0    ; check for NULL
1613   107F C6 0F 11      je cmd_ls_next
1614   1082             cmd_ls_non_null:
1615   1082 1F 18 00      mov al, [d + 24]
1616   1085 87 38         and al, %00111000
1617   1087 FD A2 03      shr al, 3
1618   108A 22 00         mov ah, 0          ; file type
1619   108C B7 4D 16      mov a, [a + file_type]      
1620   108F 23            mov ah, al
1621   1090 07 4E 01      call putchar
1622   1093 1F 18 00      mov al, [d + 24]
1623   1096 87 01         and al, %00000001
1624   1098 22 00         mov ah, 0
1625   109A B7 48 16      mov a, [a + file_attrib]    ; read
1626   109D 23            mov ah, al
1627   109E 07 4E 01      call putchar
1628   10A1 1F 18 00      mov al, [d + 24]
1629   10A4 87 02         and al, %00000010
1630   10A6 22 00         mov ah, 0
1631   10A8 B7 48 16      mov a, [a + file_attrib]    ; write
1632   10AB 23            mov ah, al
1633   10AC 07 4E 01      call putchar
1634   10AF 1F 18 00      mov al, [d + 24]
1635   10B2 87 04         and al, %00000100
1636   10B4 22 00         mov ah, 0
1637   10B6 B7 48 16      mov a, [a + file_attrib]    ; execute
1638   10B9 23            mov ah, al
1639   10BA 07 4E 01      call putchar
1640   10BD 22 20         mov ah, $20
1641   10BF 07 4E 01      call putchar  
1642   10C2 16 1B 00      mov a, [d + 27]
1643   10C5 07 B1 02      call print_u16d        ; filesize
1644   10C8 22 20         mov ah, $20
1645   10CA 07 4E 01      call putchar  
1646   10CD 16 19 00      mov a, [d + 25]
1647   10D0 07 B1 02      call print_u16d      ; dirID / LBA
1648   10D3 22 20         mov ah, $20
1649   10D5 07 4E 01      call putchar
1650   10D8             ; print date
1651   10D8 33 1D 00      mov bl, [d + 29]      ; day
1652   10DB 07 24 03      call print_u8x
1653   10DE 22 20         mov ah, $20
1654   10E0 07 4E 01      call putchar  
1655   10E3 1F 1E 00      mov al, [d + 30]      ; month
1656   10E6 FD 9E 02      shl al, 2
1657   10E9 DA            push d
1658   10EA 3B 3A 17      mov d, s_months
1659   10ED 22 00         mov ah, 0
1660   10EF 59            add d, a
1661   10F0 07 88 02      call puts
1662   10F3 E7            pop d
1663   10F4 22 20         mov ah, $20
1664   10F6 07 4E 01      call putchar
1665   10F9 2E 20         mov bl, $20
1666   10FB 07 24 03      call print_u8x
1667   10FE 33 1F 00      mov bl, [d + 31]      ; year
1668   1101 07 24 03      call print_u8x  
1669   1104 22 20         mov ah, $20
1670   1106 07 4E 01      call putchar  
1671   1109 07 88 02      call puts        ; print filename  
1672   110C 07 35 02      call printnl
1673   110F             cmd_ls_next:
1674   110F 14 28 16      mov a, [index]
1675   1112 77            inc a
1676   1113 42 28 16      mov [index], a
1677   1116 AF 10 00      cmp a, FST_FILES_PER_DIR
1678   1119 C6 22 11      je cmd_ls_end
1679   111C 58 20 00      add d, 32      
1680   111F 0A 7D 10      jmp cmd_ls_L1  
1681   1122             cmd_ls_end:
1682   1122 06            sysret
1683   1123             
1684   1123             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1685   1123             ;; pad string to 32 chars
1686   1123             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1687   1123             ; count in C
1688   1123             padding:
1689   1123 D7            push a
1690   1124 D8            push b
1691   1125 10 20 00      mov a, 32
1692   1128 28            mov b, c
1693   1129 60            sub a, b
1694   112A 39            mov c, a
1695   112B             padding_L1:
1696   112B 22 20         mov ah, $20
1697   112D 07 4E 01      call putchar
1698   1130 7E            dec c
1699   1131 C2 00 00      cmp c, 0
1700   1134 C7 2B 11      jne padding_L1
1701   1137 E5            pop b
1702   1138 E4            pop a
1703   1139 09            ret
1704   113A             
1705   113A             
1706   113A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1707   113A             ;; finds an empty data block
1708   113A             ;; block LBA returned in B
1709   113A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1710   113A             fs_find_empty_block:
1711   113A 26 A0 00      mov b, FS_LBA_START    ; raw files starting block
1712   113D 38 00 00      mov c, 0            ; reset LBA to 0
1713   1140             fs_find_empty_block_L1:  
1714   1140 22 01         mov ah, $01      ; disk read
1715   1142 3B DA 26      mov d, transient_area - 512
1716   1145 07 20 0B      call ide_read_sect    ; read sector
1717   1148 BD 00         cmp byte [d], 0
1718   114A C6 53 11      je fs_find_empty_block_found_null
1719   114D 55 20 00      add b, FS_SECTORS_PER_FILE
1720   1150 0A 40 11      jmp fs_find_empty_block_L1
1721   1153             fs_find_empty_block_found_null:
1722   1153 09            ret
1723   1154             
1724   1154             ; file structure:
1725   1154             ; 512 bytes header
1726   1154             ; header used to tell whether the block is free
1727   1154             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1728   1154             ;; CREATE NEW TEXTFILE
1729   1154             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1730   1154             cmd_mktxt:
1731   1154 FD 4E         mov si, d
1732   1156 FD 4F DA 28   mov di, transient_area
1733   115A 38 00 40      mov c, FS_SECTORS_PER_FILE * 512
1734   115D 04            load          ; load data from user-space
1735   115E 07 3A 11      call fs_find_empty_block  ; look for empty data blocks
1736   1161 D8            push b        ; save empty block LBA
1737   1162             ;create header file by grabbing file name from parameter  
1738   1162 3B DA 2A      mov d, transient_area + 512      ; pointer to file contents
1739   1165               ;call gettxt
1740   1165 07 83 00      call strlen            ; get length of the text file
1741   1168 D9            push c              ; save length
1742   1169 19 01         mov al, 1
1743   116B 3D DA 28      mov [transient_area], al          ; mark sectors as USED (not NULL)
1744   116E 3B DA 28      mov d, transient_area
1745   1171             cmd_mktxt_L2:
1746   1171 38 00 00      mov c, 0
1747   1174 22 20         mov ah, FS_SECTORS_PER_FILE    ; number of sectors to write
1748   1176 07 46 0B      call ide_write_sect      ; write sectors
1749   1179             ; now we add the file to the current directory!
1750   1179             cmd_mktxt_add_to_dir:  
1751   1179 14 30 16      mov a, [current_dirID]
1752   117C 77            inc a
1753   117D 27            mov b, a          ; metadata sector
1754   117E 38 00 00      mov c, 0
1755   1181 FD 79         mov g, b          ; save LBA
1756   1183 3B DA 26      mov d, transient_area - 512
1757   1186 22 01         mov ah, $01      ; disk read
1758   1188 07 20 0B      call ide_read_sect    ; read metadata sector
1759   118B             cmd_mktxt_add_to_dir_L2:
1760   118B BD 00         cmp byte[d], 0
1761   118D C6 96 11      je cmd_mktxt_add_to_dir_null
1762   1190 58 20 00      add d, FST_ENTRY_SIZE
1763   1193 0A 8B 11      jmp cmd_mktxt_add_to_dir_L2    ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1764   1196             cmd_mktxt_add_to_dir_null:
1765   1196 FD 4D DB 28   mov si, transient_area + 1    ; filename located after the data block 'USED' marker byte
1766   119A FD 50         mov di, d
1767   119C 07 A8 00      call strcpy      ; copy file name
1768   119F 58 18 00      add d, 24      ; skip name
1769   11A2 19 03         mov al, %00000011  ; type=file, no execute, write, read
1770   11A4 3E            mov [d], al      
1771   11A5 58 03 00      add d, 3
1772   11A8 E4            pop a
1773   11A9 43            mov [d], a
1774   11AA 63 02 00      sub d, 2
1775   11AD E5            pop b        ; get file LBA
1776   11AE FD 43         mov [d], b      ; save LBA  
1777   11B0               
1778   11B0               ; set file creation date  
1779   11B0 58 04 00      add d, 4
1780   11B3 19 04         mov al, 4
1781   11B5 05 01         syscall sys_rtc
1782   11B7 1A            mov al, ah
1783   11B8 3E            mov [d], al      ; set day
1784   11B9               
1785   11B9 79            inc d
1786   11BA 19 05         mov al, 5
1787   11BC 05 01         syscall sys_rtc
1788   11BE 1A            mov al, ah
1789   11BF 3E            mov [d], al      ; set month
1790   11C0               
1791   11C0 79            inc d
1792   11C1 19 06         mov al, 6
1793   11C3 05 01         syscall sys_rtc
1794   11C5 1A            mov al, ah
1795   11C6 3E            mov [d], al      ; set year
1796   11C7               
1797   11C7             ; write sector into disk for new directory entry
1798   11C7 FD 27         mov b, g
1799   11C9 38 00 00      mov c, 0
1800   11CC 3B DA 26      mov d, transient_area - 512
1801   11CF 22 01         mov ah, $01      ; disk write, 1 sector
1802   11D1 07 46 0B      call ide_write_sect    ; write sector
1803   11D4 06            sysret
1804   11D5             
1805   11D5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1806   11D5             ;; CREATE NEW BINARY FILE
1807   11D5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1808   11D5             ; search for first null block
1809   11D5             cmd_mkbin:
1810   11D5 FD 4E         mov si, d
1811   11D7 FD 4F DA 1C   mov di, temp_data
1812   11DB 38 00 02      mov c, 512
1813   11DE 04            load          ; load data from user-space
1814   11DF               
1815   11DF 26 A0 00      mov b, FS_LBA_START    ; files start when directories end
1816   11E2 38 00 00      mov c, 0        ; reset LBA to 0
1817   11E5             cmd_mkbin_L1:  
1818   11E5 22 01         mov ah, $01      ; disk read
1819   11E7 3B DA 28      mov d, transient_area
1820   11EA 07 20 0B      call ide_read_sect    ; read sector
1821   11ED BD 00         cmp byte[d], 0      ; check for NULL
1822   11EF C6 F8 11      je cmd_mkbin_found_null
1823   11F2 55 20 00      add b, FS_SECTORS_PER_FILE
1824   11F5 0A E5 11      jmp cmd_mkbin_L1
1825   11F8             cmd_mkbin_found_null:
1826   11F8 D8            push b        ; save LBA
1827   11F9             ;create header file by grabbing file name from parameter
1828   11F9 FD 4F DA 2A   mov di, transient_area + 512  ; pointer to file contents
1829   11FD 07 F5 15      call _load_hex      ; load binary hex
1830   1200 D9            push c          ; save size (nbr of bytes)
1831   1201 19 01         mov al, 1
1832   1203 3D DA 28      mov [transient_area], al    ; mark sectors as USED (not NULL)
1833   1206 FD 10         cla
1834   1208 42 28 16      mov [index], a
1835   120B 3B DA 28      mov d, transient_area
1836   120E 13            mov a, d
1837   120F 42 2A 16      mov [buffer_addr], a
1838   1212             cmd_mkbin_L2:
1839   1212 38 00 00      mov c, 0
1840   1215 22 01         mov ah, $01        ; disk write, 1 sector
1841   1217 07 46 0B      call ide_write_sect      ; write sector
1842   121A 14 28 16      mov a, [index]
1843   121D 77            inc a
1844   121E 42 28 16      mov [index], a
1845   1221 AF 20 00      cmp a, FS_SECTORS_PER_FILE    ; remove 1 from this because we dont count the header sector
1846   1224 C6 36 12      je cmd_mkbin_add_to_dir
1847   1227 FD 77         inc b
1848   1229 14 2A 16      mov a, [buffer_addr]
1849   122C 53 00 02      add a, 512
1850   122F 42 2A 16      mov [buffer_addr], a
1851   1232 3C            mov d, a
1852   1233 0A 12 12      jmp cmd_mkbin_L2
1853   1236             ; now we add the file to the current directory!
1854   1236             cmd_mkbin_add_to_dir:  
1855   1236 14 30 16      mov a, [current_dirID]
1856   1239 77            inc a
1857   123A 27            mov b, a          ; metadata sector
1858   123B 38 00 00      mov c, 0
1859   123E FD 79         mov g, b          ; save LBA
1860   1240 3B DA 28      mov d, transient_area
1861   1243 22 01         mov ah, $01      ; disk read
1862   1245 07 20 0B      call ide_read_sect    ; read metadata sector
1863   1248             cmd_mkbin_add_to_dir_L2:
1864   1248 BD 00         cmp byte[d], 0
1865   124A C6 53 12      je cmd_mkbin_add_to_dir_null
1866   124D 58 20 00      add d, FST_ENTRY_SIZE
1867   1250 0A 48 12      jmp cmd_mkbin_add_to_dir_L2    ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1868   1253             cmd_mkbin_add_to_dir_null:
1869   1253 FD 4D DA 1C   mov si, temp_data
1870   1257 FD 50         mov di, d
1871   1259 07 A8 00      call strcpy      ; copy file name
1872   125C 58 18 00      add d, 24      ; skip name
1873   125F 19 07         mov al, %00000111    ;type=file, execute, write, read, 
1874   1261 3E            mov [d], al
1875   1262 58 03 00      add d, 3
1876   1265 E4            pop a
1877   1266 43            mov [d], a
1878   1267 63 02 00      sub d, 2
1879   126A E5            pop b        ; get file LBA
1880   126B FD 43         mov [d], b      ; save LBA
1881   126D               
1882   126D               ; set file creation date  
1883   126D 58 04 00      add d, 4
1884   1270 19 04         mov al, 4
1885   1272 05 01         syscall sys_rtc
1886   1274 1A            mov al, ah
1887   1275 3E            mov [d], al      ; set day
1888   1276               
1889   1276 79            inc d
1890   1277 19 05         mov al, 5
1891   1279 05 01         syscall sys_rtc
1892   127B 1A            mov al, ah
1893   127C 3E            mov [d], al      ; set month
1894   127D               
1895   127D 79            inc d
1896   127E 19 06         mov al, 6
1897   1280 05 01         syscall sys_rtc
1898   1282 1A            mov al, ah
1899   1283 3E            mov [d], al      ; set year
1900   1284               
1901   1284             ; write sector into disk for new directory entry
1902   1284 FD 27         mov b, g
1903   1286 38 00 00      mov c, 0
1904   1289 3B DA 28      mov d, transient_area
1905   128C 22 01         mov ah, $01      ; disk write, 1 sector
1906   128E 07 46 0B      call ide_write_sect    ; write sector
1907   1291 06            sysret
1908   1292             
1909   1292                   
1910   1292             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1911   1292             ;; PWD - PRINT WORKING DIRECTORY
1912   1292             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;    
1913   1292             cmd_pwd:
1914   1292 3B DA 1A      mov d, filename
1915   1295 19 00         mov al, 0
1916   1297 3E            mov [d], al        ; initialize path string 
1917   1298 14 30 16      mov a, [current_dirID]
1918   129B 07 54 0E      call get_path_from_dirID_E0
1919   129E 3B DA 1A      mov d, filename
1920   12A1 07 3C 00      call strrev
1921   12A4 07 88 02      call puts
1922   12A7 07 35 02      call printnl
1923   12AA 06            sysret
1924   12AB             
1925   12AB             
1926   12AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1927   12AB             ;; get current directory LBA
1928   12AB             ;; A: returned LBA
1929   12AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:
1930   12AB             cmd_get_curr_dir_LBA:
1931   12AB 14 30 16      mov a, [current_dirID]
1932   12AE 06            sysret
1933   12AF             
1934   12AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1935   12AF             ;; LOAD FILE INTO MEM
1936   12AF             ;; file loaded to transient_area
1937   12AF             ;; D: filename pointer
1938   12AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:
1939   12AF             cmd_loadfile_user:
1940   12AF FD 4E         mov si, d
1941   12B1 FD 4F DA 1A   mov di, filename
1942   12B5 38 00 01      mov c, 256
1943   12B8 04            load
1944   12B9 07 BD 12      call cmd_loadfile
1945   12BC 06            sysret
1946   12BD             
1947   12BD             cmd_loadfile:
1948   12BD 14 30 16      mov a, [current_dirID]
1949   12C0 77            inc a        ; metadata sector
1950   12C1 27            mov b, a
1951   12C2 38 00 00      mov c, 0        ; reset LBA to 0
1952   12C5 22 01         mov ah, $01      ; disk read
1953   12C7 3B DA 26      mov d, transient_area-512
1954   12CA 07 20 0B      call ide_read_sect    ; read directory
1955   12CD FD 10         cla
1956   12CF 42 28 16      mov [index], a    ; reset file counter
1957   12D2             cmd_loadfile_L1:
1958   12D2 FD 4E         mov si, d
1959   12D4 FD 4F DA 1A   mov di, filename
1960   12D8 07 93 00      call strcmp
1961   12DB C6 F1 12      je cmd_loadfile_found_entry
1962   12DE 58 20 00      add d, 32
1963   12E1 14 28 16      mov a, [index]
1964   12E4 77            inc a
1965   12E5 42 28 16      mov [index], a
1966   12E8 AF 10 00      cmp a, FST_FILES_PER_DIR
1967   12EB C6 FF 12      je cmd_loadfile_not_found
1968   12EE 0A D2 12      jmp cmd_loadfile_L1
1969   12F1             cmd_loadfile_found_entry:
1970   12F1 58 19 00      add d, 25      ; get to dirID of file in disk
1971   12F4 2A            mov b, [d]      ; get LBA
1972   12F5 FD 77         inc b        ; add 1 to B because the LBA for data comes after the header sector
1973   12F7 3B DA 28      mov d, transient_area
1974   12FA 22 1F         mov ah, FS_SECTORS_PER_FILE-1    ; number of sectors
1975   12FC 07 20 0B      call ide_read_sect        ; read sector
1976   12FF             cmd_loadfile_not_found:
1977   12FF 09            ret
1978   1300             
1979   1300             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1980   1300             ;; CAT
1981   1300             ;; userspace destination data pointer in D
1982   1300             ;; filename starts at D, but is overwritten after the read is made
1983   1300             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:
1984   1300             cmd_cat:
1985   1300 DA            push d          ; save userspace file data destination
1986   1301 FD 4E         mov si, d
1987   1303 FD 4F DA 1C   mov di, temp_data
1988   1307 38 00 02      mov c, 512
1989   130A 04            load          ; copy filename from user-space
1990   130B 29 30 16      mov b, [current_dirID]
1991   130E FD 77         inc b        ; metadata sector
1992   1310 38 00 00      mov c, 0        ; reset LBA to 0
1993   1313 22 01         mov ah, $01      ; disk read
1994   1315 3B DA 26      mov d, transient_area-512
1995   1318 07 20 0B      call ide_read_sect    ; read directory
1996   131B FD 10         cla
1997   131D 42 28 16      mov [index], a    ; reset file counter
1998   1320             cmd_cat_L1:
1999   1320 FD 4E         mov si, d
2000   1322 FD 4F DA 1C   mov di, temp_data
2001   1326 07 93 00      call strcmp
2002   1329 C6 3F 13      je cmd_cat_found_entry
2003   132C 58 20 00      add d, 32
2004   132F 14 28 16      mov a, [index]
2005   1332 77            inc a
2006   1333 42 28 16      mov [index], a
2007   1336 AF 10 00      cmp a, FST_FILES_PER_DIR
2008   1339 C6 5A 13      je cmd_cat_not_found
2009   133C 0A 20 13      jmp cmd_cat_L1
2010   133F             cmd_cat_found_entry:
2011   133F 58 19 00      add d, 25      ; get to dirID of file in disk
2012   1342 2A            mov b, [d]      ; get LBA
2013   1343 FD 77         inc b        ; add 1 to B because the LBA for data comes after the header sector 
2014   1345 3B DA 28      mov d, transient_area  
2015   1348 38 00 00      mov c, 0
2016   134B 22 1F         mov ah, FS_SECTORS_PER_FILE-1  ; nbr sectors
2017   134D 07 20 0B      call ide_read_sect    ; read sectors
2018   1350 F0            pop di            ; write userspace file data destination to DI
2019   1351 FD 4D DA 28   mov si, transient_area    ; data origin
2020   1355 38 00 3E      mov c, 512*(FS_SECTORS_PER_FILE-1)
2021   1358 03            store
2022   1359 06            sysret
2023   135A             cmd_cat_not_found:
2024   135A E7            pop d
2025   135B 06            sysret
2026   135C             
2027   135C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2028   135C             ;; RMDIR - remove DIR by dirID
2029   135C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2030   135C             ; deletes a directory entry in the given directory's file list 
2031   135C             ; also deletes the actual directory entry in the FST
2032   135C             ; synopsis: rmdir /usr/local/testdir
2033   135C             ; B = dirID
2034   135C             cmd_rmdir:
2035   135C FD 79         mov g, b
2036   135E 11            mov a, b
2037   135F 07 90 0E      call get_parentID_from_dirID  ; now get the directory's parent, in A
2038   1362 D7            push a            ; save dirID
2039   1363             ; search for directory's entry in the parent's directory then and delete it
2040   1363 77            inc a            ; metadata sector
2041   1364 27            mov b, a
2042   1365 38 00 00      mov c, 0          ; reset LBA to 0
2043   1368 22 01         mov ah, $01          ;
2044   136A 3B DA 28      mov d, transient_area
2045   136D 07 20 0B      call ide_read_sect      ; read directory
2046   1370 FD 10         cla
2047   1372 42 28 16      mov [index], a        ; reset file counter
2048   1375 FD 27         mov b, g          ; retrieve directory's dirID
2049   1377             cmd_rmdir_L1:
2050   1377 16 19 00      mov a, [d + 25]        ; get entry's dirID/LBA value
2051   137A B0            cmp a, b          ; compare dirID's to find the directory
2052   137B C6 91 13      je cmd_rmdir_found_entry
2053   137E 58 20 00      add d, 32
2054   1381 14 28 16      mov a, [index]
2055   1384 77            inc a
2056   1385 42 28 16      mov [index], a
2057   1388 AF 10 00      cmp a, FST_FILES_PER_DIR
2058   138B C6 B6 13      je cmd_rmdir_not_found
2059   138E 0A 77 13      jmp cmd_rmdir_L1
2060   1391             cmd_rmdir_found_entry:
2061   1391 FD 10         cla
2062   1393 3E            mov [d], al          ; make filename NULL
2063   1394 44 19 00      mov [d + 25], a        ; clear dirID/LBA as well not to generate problems with previously deleted directories
2064   1397 E5            pop b
2065   1398 FD 77         inc b            ; metadata sector
2066   139A 38 00 00      mov c, 0          ; reset LBA to 0
2067   139D 22 01         mov ah, $01          ; 
2068   139F 3B DA 28      mov d, transient_area
2069   13A2 07 46 0B      call ide_write_sect      ; write sector and erase file's entry in the current DIR
2070   13A5             
2071   13A5 FD 27         mov b, g
2072   13A7 3B DA 28      mov d, transient_area  
2073   13AA FD 10         cla
2074   13AC 3E            mov [d], al          ; make directory's name header NULL for re-use
2075   13AD 38 00 00      mov c, 0
2076   13B0 22 01         mov ah, $01          ; disk write 1 sect
2077   13B2 07 46 0B      call ide_write_sect      ; delete directory given by dirID in B
2078   13B5 06            sysret
2079   13B6             cmd_rmdir_not_found:
2080   13B6 E5            pop b
2081   13B7 06            sysret
2082   13B8             
2083   13B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2084   13B8             ;; RM - remove file
2085   13B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2086   13B8             ; frees up the data sectors for the file further down the disk
2087   13B8             ; deletes file entry in the directory's file list 
2088   13B8             cmd_rm:
2089   13B8 FD 4E         mov si, d
2090   13BA FD 4F DA 1C   mov di, temp_data
2091   13BE 38 00 02      mov c, 512
2092   13C1 04            load          ; load data from user-space
2093   13C2 14 30 16      mov a, [current_dirID]
2094   13C5 77            inc a        ; metadata sector
2095   13C6 27            mov b, a
2096   13C7 38 00 00      mov c, 0        ; reset LBA to 0
2097   13CA 22 01         mov ah, $01      ; disk read
2098   13CC 3B DA 28      mov d, transient_area
2099   13CF 07 20 0B      call ide_read_sect    ; read directory
2100   13D2 10 00 00      mov a, 0
2101   13D5 42 28 16      mov [index], a    ; reset file counter
2102   13D8             cmd_rm_L1:
2103   13D8 FD 4E         mov si, d
2104   13DA FD 4F DA 1C   mov di, temp_data
2105   13DE 07 93 00      call strcmp
2106   13E1 C6 F7 13      je cmd_rm_found_entry
2107   13E4 58 20 00      add d, 32
2108   13E7 14 28 16      mov a, [index]
2109   13EA 77            inc a
2110   13EB 42 28 16      mov [index], a
2111   13EE AF 10 00      cmp a, FST_FILES_PER_DIR
2112   13F1 C6 1F 14      je cmd_rm_not_found
2113   13F4 0A D8 13      jmp cmd_rm_L1
2114   13F7             cmd_rm_found_entry:
2115   13F7 2B 19 00      mov b, [d + 25]      ; get LBA
2116   13FA FD 79         mov g, b        ; save LBA
2117   13FC 19 00         mov al, 0
2118   13FE 3E            mov [d], al      ; make file entry NULL
2119   13FF 14 30 16      mov a, [current_dirID]
2120   1402 77            inc a        ; metadata sector
2121   1403 27            mov b, a
2122   1404 38 00 00      mov c, 0        ; reset LBA to 0
2123   1407 22 01         mov ah, $01      ; disk write
2124   1409 3B DA 28      mov d, transient_area
2125   140C 07 46 0B      call ide_write_sect    ; write sector and erase file's entry in the current DIR
2126   140F 3B DA 28      mov d, transient_area  
2127   1412 19 00         mov al, 0
2128   1414 3E            mov [d], al      ; make file's data header NULL for re-use
2129   1415 38 00 00      mov c, 0
2130   1418 FD 27         mov b, g        ; get data header LBA
2131   141A 22 01         mov ah, $01          ; disk write 1 sect
2132   141C 07 46 0B      call ide_write_sect        ; write sector
2133   141F             cmd_rm_not_found:  
2134   141F 06            sysret  
2135   1420             
2136   1420             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2137   1420             ;; mv - move / change file name
2138   1420             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2139   1420             cmd_mv:
2140   1420 FD 4E         mov si, d
2141   1422 FD 4F DA 1C   mov di, temp_data
2142   1426 38 00 02      mov c, 512
2143   1429 04            load            ; load data from user-space
2144   142A 14 30 16      mov a, [current_dirID]
2145   142D 77            inc a            ; metadata sector
2146   142E 27            mov b, a  
2147   142F 38 00 00      mov c, 0          ; reset LBA to 0
2148   1432 22 01         mov ah, $01        ; disk read
2149   1434 3B DA 28      mov d, transient_area
2150   1437 07 20 0B      call ide_read_sect    ;read directory
2151   143A FD 10         cla
2152   143C 42 28 16      mov [index], a        ;reset file counter
2153   143F             cmd_mv_L1:
2154   143F FD 4E         mov si, d
2155   1441 FD 4F DA 1C   mov di, temp_data
2156   1445 07 93 00      call strcmp
2157   1448 C6 5E 14      je cmd_mv_found_entry
2158   144B 58 20 00      add d, 32
2159   144E 14 28 16      mov a, [index]
2160   1451 77            inc a
2161   1452 42 28 16      mov [index], a
2162   1455 AF 10 00      cmp a, FST_FILES_PER_DIR
2163   1458 C6 90 14      je cmd_mv_not_found
2164   145B 0A 3F 14      jmp cmd_mv_L1
2165   145E             cmd_mv_found_entry:  
2166   145E DA            push d
2167   145F FD 4D 5A 1D   mov si, temp_data + 128  ; (0...127) = original filename , (128...255) = new name
2168   1463 FD 50         mov di, d
2169   1465 07 A8 00      call strcpy  
2170   1468 38 00 00      mov c, 0
2171   146B 3B DA 28      mov d, transient_area
2172   146E 22 01         mov ah, $01          ;disk write 1 sect
2173   1470 07 46 0B      call ide_write_sect      ;write sector
2174   1473 E7            pop d
2175   1474             ;;;;;;;; need to check whether its a dir or a file here ;;;;;;;;;;;;;;
2176   1474 2B 19 00      mov b, [d + 25]        ; get the dirID of the directory so we can locate its own entry in the list
2177   1477 22 01         mov ah, $01
2178   1479 3B DA 28      mov d, transient_area
2179   147C 38 00 00      mov c, 0
2180   147F 07 20 0B      call ide_read_sect      ; read directory entry
2181   1482 FD 4D 5A 1D   mov si, temp_data + 128
2182   1486 FD 50         mov di, d
2183   1488 07 A8 00      call strcpy          ; change directory's name
2184   148B 22 01         mov ah, $01
2185   148D 07 46 0B      call ide_write_sect      ; rewrite directory back to disk
2186   1490             cmd_mv_not_found:
2187   1490 06            sysret
2188   1491             
2189   1491             kernel_reset_vector:  
2190   1491 FD 49 FF F7   mov bp, STACK_BEGIN
2191   1495 FD 47 FF F7   mov sp, STACK_BEGIN
2192   1499               
2193   1499 19 80         mov al, %10000000
2194   149B FD 0F         stomsk          ; mask out timer interrupt for now (only allow UART to interrupt)
2195   149D FD 0C         sti  
2196   149F             
2197   149F 0C            lodstat
2198   14A0 87 DF         and al, %11011111  ; disable display register loading
2199   14A2 0D            stostat
2200   14A3               
2201   14A3             ; reset fifo pointers
2202   14A3 10 DA 1E      mov a, fifo
2203   14A6 3B 2C 16      mov d, fifo_pi
2204   14A9 43            mov [d], a
2205   14AA 3B 2E 16      mov d, fifo_pr
2206   14AD 43            mov [d], a  
2207   14AE 19 02         mov al, 2
2208   14B0 05 03         syscall sys_io      ; enable uart in interrupt mode
2209   14B2               
2210   14B2 3B 88 16      mov d, s_kernel_started
2211   14B5 07 88 02      call puts
2212   14B8               
2213   14B8 3B AD 16      mov d, s_prompt_init
2214   14BB 07 88 02      call puts
2215   14BE             
2216   14BE 19 10         mov al, 16
2217   14C0 05 04         syscall sys_filesystem    ; set root dirID
2218   14C2             
2219   14C2 3B 32 16      mov d, s_init_path
2220   14C5 05 05         syscall sys_fork    ; launch init as a new process
2221   14C7             
2222   14C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2223   14C7             ;;; Process Index in A
2224   14C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2225   14C7             find_free_proc:
2226   14C7 FD 4D CB 18   mov si, proc_availab_table + 1      ; skip process 0 (kernel)
2227   14CB             find_free_proc_L0:
2228   14CB F6            lodsb            ; get process state
2229   14CC B9 00         cmp al, 0
2230   14CE C6 D4 14      je find_free_proc_free      ; if free, jump
2231   14D1 0A CB 14      jmp find_free_proc_L0      ; else, goto next
2232   14D4             find_free_proc_free:
2233   14D4 4E            mov a, si
2234   14D5 5F CB 18      sub a, 1 + proc_availab_table        ; get process index
2235   14D8 09            ret
2236   14D9               
2237   14D9             
2238   14D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2239   14D9             ;;; Process Index in AL
2240   14D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2241   14D9             proc_memory_map:
2242   14D9 22 00         mov ah, 0
2243   14DB 27            mov b, a      ; page in BL, 0 in BH
2244   14DC FD 9D 05      shl a, 5      ; multiply by 32
2245   14DF 39            mov c, a      ; save in C
2246   14E0 57 20 00      add c, 32
2247   14E3             proc_memory_map_L0:
2248   14E3 02            pagemap
2249   14E4 55 00 08      add b, $0800          ; increase page number (msb 5 bits of BH only)
2250   14E7 53 01 00      add a, 1            ; increase both 
2251   14EA B1            cmp a, c            ; check to see if we reached the end of memory
2252   14EB C7 E3 14      jne proc_memory_map_L0
2253   14EE 09            ret
2254   14EF               
2255   14EF             
2256   14EF             cmd_terminate_proc:
2257   14EF 51 05 00      add sp, 5    ; clear stack of the values that were pushed by the interrupt (SP, Status, PC)
2258   14F2                       ; since they will not be used for anything here.
2259   14F2 1D 27 16      mov al, [active_proc_index]
2260   14F5 22 00         mov ah, 0  
2261   14F7 FD 9D 05      shl a, 5            ; x32
2262   14FA 53 DA 18      add a, proc_names
2263   14FD 3C            mov d, a
2264   14FE 19 00         mov al, 0
2265   1500 3E            mov [d], al      ; nullify process name
2266   1501             
2267   1501 1D 27 16      mov al, [active_proc_index]
2268   1504 22 00         mov ah, 0  
2269   1506 3C            mov d, a
2270   1507 19 00         mov al, 0
2271   1509 3F CA 18      mov [d + proc_availab_table], al          ; make process empty again
2272   150C               
2273   150C 1D 26 16      mov al, [nbr_active_procs]      ; decrease nbr of active processes
2274   150F 80            dec al
2275   1510 3D 26 16      mov [nbr_active_procs], al
2276   1513             
2277   1513             ; now load the shell process again
2278   1513 19 02         mov al, 2        ; next process = process 2 = shell
2279   1515 3D 27 16      mov [active_proc_index], al    ; set next active proc
2280   1518             
2281   1518             ; calculate LUT entry for next process
2282   1518 22 00         mov ah, 0
2283   151A FD 99         shl a              ; x2
2284   151C B7 E5 15      mov a, [proc_table_convert + a]    ; get process state start index  
2285   151F               
2286   151F 4D            mov si, a            ; source is proc state block
2287   1520 48            mov a, sp
2288   1521 5F 13 00      sub a, 19
2289   1524 4F            mov di, a            ; destination is kernel stack
2290   1525             ; restore SP
2291   1525 7D            dec a
2292   1526 47            mov sp, a
2293   1527 38 14 00      mov c, 20
2294   152A FD F5         rep movsb
2295   152C             ; set VM process
2296   152C 1D 27 16      mov al, [active_proc_index]
2297   152F 01            setptb
2298   1530                 
2299   1530 4C            popa
2300   1531 06            sysret
2301   1532             
2302   1532             cmd_pause_proc:
2303   1532             ; save all registers into kernel stack
2304   1532 4B            pusha
2305   1533 22 00         mov ah, 0
2306   1535 1D 27 16      mov al, [active_proc_index]
2307   1538 FD 99         shl a              ; x2
2308   153A B7 E5 15      mov a, [proc_table_convert + a]  ; get process state start index
2309   153D                 
2310   153D 4F            mov di, a
2311   153E 48            mov a, sp
2312   153F 77            inc a
2313   1540 4D            mov si, a
2314   1541 38 14 00      mov c, 20
2315   1544 FD F5         rep movsb          ; save process state!
2316   1546             ; restore kernel stack position to point before interrupt arrived
2317   1546 51 14 00      add sp, 20
2318   1549             ; now load the shell process again
2319   1549 19 02         mov al, 2        ; next process = process 2 = shell
2320   154B 3D 27 16      mov [active_proc_index], al    ; set next active proc
2321   154E             
2322   154E             ; calculate LUT entry for next process
2323   154E 22 00         mov ah, 0
2324   1550 FD 99         shl a              ; x2
2325   1552 B7 E5 15      mov a, [proc_table_convert + a]    ; get process state start index  
2326   1555               
2327   1555 4D            mov si, a            ; source is proc state block
2328   1556 48            mov a, sp
2329   1557 5F 13 00      sub a, 19
2330   155A 4F            mov di, a            ; destination is kernel stack
2331   155B             ; restore SP
2332   155B 7D            dec a
2333   155C 47            mov sp, a
2334   155D 38 14 00      mov c, 20
2335   1560 FD F5         rep movsb
2336   1562             ; set VM process
2337   1562 1D 27 16      mov al, [active_proc_index]
2338   1565 01            setptb
2339   1566                 
2340   1566 4C            popa
2341   1567 06            sysret
2342   1568             
2343   1568             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2344   1568             ;; fork a new process
2345   1568             ;; D = path of the process file to be forked
2346   1568             ;; B = arguments ptr
2347   1568             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2348   1568             cmd_fork:
2349   1568             ; we save the active process first  
2350   1568 4B            pusha
2351   1569 22 00         mov ah, 0
2352   156B 1D 27 16      mov al, [active_proc_index]
2353   156E FD 99         shl a              ; x2
2354   1570 B7 E5 15      mov a, [proc_table_convert + a]    ; get process state table's start index
2355   1573               
2356   1573 4F            mov di, a
2357   1574 48            mov a, sp
2358   1575 77            inc a
2359   1576 4D            mov si, a
2360   1577 38 14 00      mov c, 20
2361   157A FD F5         rep movsb          ; save process state!
2362   157C             ; restore kernel stack position to point before interrupt arrived
2363   157C 51 14 00      add sp, 20
2364   157F               
2365   157F FD 4E         mov si, d        ; copy the file path
2366   1581 FD 4F DA 1C   mov di, temp_data
2367   1585 38 00 02      mov c, 512
2368   1588 04            load
2369   1589 11            mov a, b
2370   158A 4D            mov si, a        ; copy the arguments
2371   158B FD 4F DA 26   mov di, scrap_sector
2372   158F 38 00 02      mov c, 512
2373   1592 04            load
2374   1593 07 D6 0F      call loadfile_from_path    ; load the process file from disk by path (path is in temp_data)
2375   1596                             ; the file data is loaded into transient_area
2376   1596             ; now we allocate a new process  
2377   1596 07 C7 14      call find_free_proc      ; index in A
2378   1599 01            setptb
2379   159A 07 D9 14      call proc_memory_map      ; map process memory pages
2380   159D             ; copy arguments into process's memory
2381   159D FD 4D DA 26   mov si, scrap_sector
2382   15A1 FD 4F 00 00   mov di, 0
2383   15A5 38 00 02      mov c, 512
2384   15A8 03            store
2385   15A9             ; now copy process binary data into process's memory
2386   15A9 FD 4D DA 28   mov si, transient_area
2387   15AD FD 4F 00 04   mov di, PROC_TEXT_ORG    ; code origin address for all user processes
2388   15B1 38 00 40      mov c, FS_FILE_SIZE      ; size of memory space to copy, which is equal to the max file size in disk (for now)
2389   15B4 03            store            ; copy process data
2390   15B5                 
2391   15B5 07 C7 14      call find_free_proc      ; index in A
2392   15B8 3D 27 16      mov [active_proc_index], al    ; set new active process
2393   15BB FD 9D 05      shl a, 5            ; x32
2394   15BE 53 DA 18      add a, proc_names
2395   15C1 4F            mov di, a
2396   15C2 FD 4D DA 1C   mov si, temp_data      ; copy and store process filename
2397   15C6 07 A8 00      call strcpy
2398   15C9               
2399   15C9 07 C7 14      call find_free_proc      ; index in A
2400   15CC 3C            mov d, a
2401   15CD 19 01         mov al, 1
2402   15CF 3F CA 18      mov [d + proc_availab_table], al          ; make process busy
2403   15D2               
2404   15D2 1D 26 16      mov al, [nbr_active_procs]      ; increase nbr of active processes
2405   15D5 7A            inc al
2406   15D6 3D 26 16      mov [nbr_active_procs], al
2407   15D9             ; launch process
2408   15D9 FD D7 FF FF   push word $FFFF 
2409   15DD FD DB 0E      push byte %00001110    ; dma_ack = 0, interrupts enabled = 1, mode = user, paging = on, halt=0, display_reg_load=0, dir=0
2410   15E0 FD D7 00 04   push word PROC_TEXT_ORG
2411   15E4 06            sysret
2412   15E5             
2413   15E5             proc_table_convert:
2414   15E5 8A 17         .dw proc_state_table + 0
2415   15E7 9E 17         .dw proc_state_table + 20
2416   15E9 B2 17         .dw proc_state_table + 40
2417   15EB C6 17         .dw proc_state_table + 60
2418   15ED DA 17         .dw proc_state_table + 80
2419   15EF EE 17         .dw proc_state_table + 100
2420   15F1 02 18         .dw proc_state_table + 120
2421   15F3 16 18         .dw proc_state_table + 140
2422   15F5               
2423   15F5             ; ************************************************************
2424   15F5             ; GET HEX FILE
2425   15F5             ; di = destination address
2426   15F5             ; return length in bytes in C
2427   15F5             ; ************************************************************
2428   15F5             _load_hex:
2429   15F5 D2            push bp
2430   15F6 9B            mov bp, sp
2431   15F7 D7            push a
2432   15F8 D8            push b
2433   15F9 DA            push d
2434   15FA E2            push si
2435   15FB E3            push di
2436   15FC 52 00 80      sub sp, $8000        ; string data block
2437   15FF 38 00 00      mov c, 0
2438   1602 48            mov a, sp
2439   1603 77            inc a
2440   1604 3C            mov d, a        ; start of string data block
2441   1605 07 55 01      call gets        ; get program string
2442   1608 4D            mov si, a
2443   1609             __load_hex_loop:
2444   1609 F6            lodsb          ; load from [SI] to AL
2445   160A B9 00         cmp al, 0        ; check if ASCII 0
2446   160C C6 1A 16      jz __load_hex_ret
2447   160F 36            mov bh, al
2448   1610 F6            lodsb
2449   1611 2F            mov bl, al
2450   1612 07 03 01      call atoi        ; convert ASCII byte in B to int (to AL)
2451   1615 F7            stosb          ; store AL to [DI]
2452   1616 78            inc c
2453   1617 0A 09 16      jmp __load_hex_loop
2454   161A             __load_hex_ret:
2455   161A 51 00 80      add sp, $8000
2456   161D F0            pop di
2457   161E EF            pop si
2458   161F E7            pop d
2459   1620 E5            pop b
2460   1621 E4            pop a
2461   1622 9C            mov sp, bp
2462   1623 F1            pop bp
2463   1624 09            ret
2464   1625             
2465   1625             ; synopsis: look insIDE a certain DIRECTORY for files/directories
2466   1625             ; BEFORE CALLING THIS FUNCTION, CD INTO REQUIRED DIRECTORY
2467   1625             ; for each entry insIDE DIRECTORY:
2468   1625             ;  if entry is a file:
2469   1625             ;    compare filename to searched filename
2470   1625             ;    if filenames are the same, print filename
2471   1625             ;  else if entry is a directory:
2472   1625             ;    cd to the given directory
2473   1625             ;    recursively call cmd_find
2474   1625             ;    cd outsIDE previous directory
2475   1625             ;  if current entry == last entry, return
2476   1625             ; endfor
2477   1625             ;    
2478   1625             ;  
2479   1625             f_find:
2480   1625               
2481   1625 09            ret
2482   1626             
2483   1626             
2484   1626             
2485   1626 00          nbr_active_procs:  .db 0
2486   1627 01          active_proc_index:  .db 1
2487   1628             
2488   1628 00 00       index:        .dw 0
2489   162A 00 00       buffer_addr:    .dw 0
2490   162C             
2491   162C DA 1E       fifo_pi:      .dw fifo
2492   162E DA 1E       fifo_pr:      .dw fifo
2493   1630             
2494   1630             ; file system variables
2495   1630 00 00       current_dirID:    .dw 0        ; keep dirID of current directory
2496   1632 2F 73 62 69 s_init_path:    .db "/sbin/init", 0
2496   1636 6E 2F 69 6E 
2496   163A 69 74 00 
2497   163D             
2498   163D 2E 2E 00    s_parent_dir:    .db "..", 0
2499   1640 2E 00       s_current_dir:    .db ".", 0
2500   1642 2F 00       s_fslash:       .db "/", 0
2501   1644 20 23 20 00 s_hash:        .db " # ", 0
2502   1648 2D 72 77 20 file_attrib:    .db "-rw x"      ; chars at multiples of 2
2502   164C 78 
2503   164D 2D 64 63    file_type:      .db "-dc"
2504   1650 50 49 44 20 s_ps_header:    .db "PID COMMAND\n", 0
2504   1654 43 4F 4D 4D 
2504   1658 41 4E 44 0A 
2504   165C 00 
2505   165D 53 6F 6C 2D s_host:       .db "Sol-1:", 0
2505   1661 31 3A 00 
2506   1664 53 6F 6C 61 s_uname:      .db "Solarium\n", 0
2506   1668 72 69 75 6D 
2506   166C 0A 00 
2507   166E             
2508   166E 72 6F 6F 74 s_root:        .db "root\n", 0
2508   1672 0A 00 
2509   1674             
2510   1674 69 6E 74 65 s_int_en:      .db "interrupts enabled\n", 0
2510   1678 72 72 75 70 
2510   167C 74 73 20 65 
2510   1680 6E 61 62 6C 
2510   1684 65 64 0A 00 
2511   1688 6B 65 72 6E s_kernel_started:  .db "kernel started\n", 0
2511   168C 65 6C 20 73 
2511   1690 74 61 72 74 
2511   1694 65 64 0A 00 
2512   1698 65 6E 74 65 s_procname:      .db "enter process name: ", 0
2512   169C 72 20 70 72 
2512   16A0 6F 63 65 73 
2512   16A4 73 20 6E 61 
2512   16A8 6D 65 3A 20 
2512   16AC 00 
2513   16AD 73 74 61 72 s_prompt_init:    .db "starting init\n", 0
2513   16B1 74 69 6E 67 
2513   16B5 20 69 6E 69 
2513   16B9 74 0A 00 
2514   16BC 0A 73 6F 66 s_priviledge:    .db "\nsoftware failure: privilege exception\n", 0
2514   16C0 74 77 61 72 
2514   16C4 65 20 66 61 
2514   16C8 69 6C 75 72 
2514   16CC 65 3A 20 70 
2514   16D0 72 69 76 69 
2514   16D4 6C 65 67 65 
2514   16D8 20 65 78 63 
2514   16DC 65 70 74 69 
2514   16E0 6F 6E 0A 00 
2515   16E4 0A 65 78 63 s_divzero:      .db "\nexception: zero division\n", 0
2515   16E8 65 70 74 69 
2515   16EC 6F 6E 3A 20 
2515   16F0 7A 65 72 6F 
2515   16F4 20 64 69 76 
2515   16F8 69 73 69 6F 
2515   16FC 6E 0A 00 
2516   16FF             
2517   16FF 59 65 61 72 s_set_year:      .db "Year: ", 0
2517   1703 3A 20 00 
2518   1706 4D 6F 6E 74 s_set_month:    .db "Month: ", 0
2518   170A 68 3A 20 00 
2519   170E 44 61 79 3A s_set_day:      .db "Day: ", 0
2519   1712 20 00 
2520   1714 57 65 65 6B s_set_week:      .db "Weekday: ", 0
2520   1718 64 61 79 3A 
2520   171C 20 00 
2521   171E 48 6F 75 72 s_set_hours:    .db "Hours: ", 0
2521   1722 73 3A 20 00 
2522   1726 4D 69 6E 75 s_set_minutes:    .db "Minutes: ", 0
2522   172A 74 65 73 3A 
2522   172E 20 00 
2523   1730 53 65 63 6F s_set_seconds:    .db "Seconds: ", 0
2523   1734 6E 64 73 3A 
2523   1738 20 00 
2524   173A 20 20 20 00 s_months:      .db "   ", 0
2525   173E 4A 61 6E 00           .db "Jan", 0
2526   1742 46 65 62 00           .db "Feb", 0
2527   1746 4D 61 72 00           .db "Mar", 0
2528   174A 41 70 72 00           .db "Apr", 0
2529   174E 4D 61 79 00           .db "May", 0
2530   1752 4A 75 6E 00           .db "Jun", 0
2531   1756 4A 75 6C 00           .db "Jul", 0
2532   175A 41 75 67 00           .db "Aug", 0
2533   175E 53 65 70 00           .db "Sep", 0
2534   1762 4F 63 74 00           .db "Oct", 0
2535   1766 4E 6F 76 00           .db "Nov", 0
2536   176A 44 65 63 00           .db "Dec", 0
2537   176E 53 75 6E 00 s_week:        .db "Sun", 0 
2538   1772 4D 6F 6E 00           .db "Mon", 0 
2539   1776 54 75 65 00           .db "Tue", 0 
2540   177A 57 65 64 00           .db "Wed", 0 
2541   177E 54 68 75 00           .db "Thu", 0 
2542   1782 46 72 69 00           .db "Fri", 0 
2543   1786 53 61 74 00           .db "Sat", 0
2544   178A             
2545   178A 00 00 00 00 proc_state_table:  .fill 16 * 20, 0  ; for 15 processes max
2545   178E 00 00 00 00 
2545   1792 00 00 00 00 
2545   1796 00 00 00 00 
2545   179A 00 00 00 00 
2545   179E 00 00 00 00 
2545   17A2 00 00 00 00 
2545   17A6 00 00 00 00 
2545   17AA 00 00 00 00 
2545   17AE 00 00 00 00 
2545   17B2 00 00 00 00 
2545   17B6 00 00 00 00 
2545   17BA 00 00 00 00 
2545   17BE 00 00 00 00 
2545   17C2 00 00 00 00 
2545   17C6 00 00 00 00 
2545   17CA 00 00 00 00 
2545   17CE 00 00 00 00 
2545   17D2 00 00 00 00 
2545   17D6 00 00 00 00 
2545   17DA 00 00 00 00 
2545   17DE 00 00 00 00 
2545   17E2 00 00 00 00 
2545   17E6 00 00 00 00 
2545   17EA 00 00 00 00 
2545   17EE 00 00 00 00 
2545   17F2 00 00 00 00 
2545   17F6 00 00 00 00 
2545   17FA 00 00 00 00 
2545   17FE 00 00 00 00 
2545   1802 00 00 00 00 
2545   1806 00 00 00 00 
2545   180A 00 00 00 00 
2545   180E 00 00 00 00 
2545   1812 00 00 00 00 
2545   1816 00 00 00 00 
2545   181A 00 00 00 00 
2545   181E 00 00 00 00 
2545   1822 00 00 00 00 
2545   1826 00 00 00 00 
2545   182A 00 00 00 00 
2545   182E 00 00 00 00 
2545   1832 00 00 00 00 
2545   1836 00 00 00 00 
2545   183A 00 00 00 00 
2545   183E 00 00 00 00 
2545   1842 00 00 00 00 
2545   1846 00 00 00 00 
2545   184A 00 00 00 00 
2545   184E 00 00 00 00 
2545   1852 00 00 00 00 
2545   1856 00 00 00 00 
2545   185A 00 00 00 00 
2545   185E 00 00 00 00 
2545   1862 00 00 00 00 
2545   1866 00 00 00 00 
2545   186A 00 00 00 00 
2545   186E 00 00 00 00 
2545   1872 00 00 00 00 
2545   1876 00 00 00 00 
2545   187A 00 00 00 00 
2545   187E 00 00 00 00 
2545   1882 00 00 00 00 
2545   1886 00 00 00 00 
2545   188A 00 00 00 00 
2545   188E 00 00 00 00 
2545   1892 00 00 00 00 
2545   1896 00 00 00 00 
2545   189A 00 00 00 00 
2545   189E 00 00 00 00 
2545   18A2 00 00 00 00 
2545   18A6 00 00 00 00 
2545   18AA 00 00 00 00 
2545   18AE 00 00 00 00 
2545   18B2 00 00 00 00 
2545   18B6 00 00 00 00 
2545   18BA 00 00 00 00 
2545   18BE 00 00 00 00 
2545   18C2 00 00 00 00 
2545   18C6 00 00 00 00 
2546   18CA 00 00 00 00 proc_availab_table:  .fill 16, 0      ; space for 15 processes. 0 = process empty, 1 = process taken
2546   18CE 00 00 00 00 
2546   18D2 00 00 00 00 
2546   18D6 00 00 00 00 
2547   18DA 00 00 00 00 proc_names:      .fill 16 * 32, 0  ; process names
2547   18DE 00 00 00 00 
2547   18E2 00 00 00 00 
2547   18E6 00 00 00 00 
2547   18EA 00 00 00 00 
2547   18EE 00 00 00 00 
2547   18F2 00 00 00 00 
2547   18F6 00 00 00 00 
2547   18FA 00 00 00 00 
2547   18FE 00 00 00 00 
2547   1902 00 00 00 00 
2547   1906 00 00 00 00 
2547   190A 00 00 00 00 
2547   190E 00 00 00 00 
2547   1912 00 00 00 00 
2547   1916 00 00 00 00 
2547   191A 00 00 00 00 
2547   191E 00 00 00 00 
2547   1922 00 00 00 00 
2547   1926 00 00 00 00 
2547   192A 00 00 00 00 
2547   192E 00 00 00 00 
2547   1932 00 00 00 00 
2547   1936 00 00 00 00 
2547   193A 00 00 00 00 
2547   193E 00 00 00 00 
2547   1942 00 00 00 00 
2547   1946 00 00 00 00 
2547   194A 00 00 00 00 
2547   194E 00 00 00 00 
2547   1952 00 00 00 00 
2547   1956 00 00 00 00 
2547   195A 00 00 00 00 
2547   195E 00 00 00 00 
2547   1962 00 00 00 00 
2547   1966 00 00 00 00 
2547   196A 00 00 00 00 
2547   196E 00 00 00 00 
2547   1972 00 00 00 00 
2547   1976 00 00 00 00 
2547   197A 00 00 00 00 
2547   197E 00 00 00 00 
2547   1982 00 00 00 00 
2547   1986 00 00 00 00 
2547   198A 00 00 00 00 
2547   198E 00 00 00 00 
2547   1992 00 00 00 00 
2547   1996 00 00 00 00 
2547   199A 00 00 00 00 
2547   199E 00 00 00 00 
2547   19A2 00 00 00 00 
2547   19A6 00 00 00 00 
2547   19AA 00 00 00 00 
2547   19AE 00 00 00 00 
2547   19B2 00 00 00 00 
2547   19B6 00 00 00 00 
2547   19BA 00 00 00 00 
2547   19BE 00 00 00 00 
2547   19C2 00 00 00 00 
2547   19C6 00 00 00 00 
2547   19CA 00 00 00 00 
2547   19CE 00 00 00 00 
2547   19D2 00 00 00 00 
2547   19D6 00 00 00 00 
2547   19DA 00 00 00 00 
2547   19DE 00 00 00 00 
2547   19E2 00 00 00 00 
2547   19E6 00 00 00 00 
2547   19EA 00 00 00 00 
2547   19EE 00 00 00 00 
2547   19F2 00 00 00 00 
2547   19F6 00 00 00 00 
2547   19FA 00 00 00 00 
2547   19FE 00 00 00 00 
2547   1A02 00 00 00 00 
2547   1A06 00 00 00 00 
2547   1A0A 00 00 00 00 
2547   1A0E 00 00 00 00 
2547   1A12 00 00 00 00 
2547   1A16 00 00 00 00 
2547   1A1A 00 00 00 00 
2547   1A1E 00 00 00 00 
2547   1A22 00 00 00 00 
2547   1A26 00 00 00 00 
2547   1A2A 00 00 00 00 
2547   1A2E 00 00 00 00 
2547   1A32 00 00 00 00 
2547   1A36 00 00 00 00 
2547   1A3A 00 00 00 00 
2547   1A3E 00 00 00 00 
2547   1A42 00 00 00 00 
2547   1A46 00 00 00 00 
2547   1A4A 00 00 00 00 
2547   1A4E 00 00 00 00 
2547   1A52 00 00 00 00 
2547   1A56 00 00 00 00 
2547   1A5A 00 00 00 00 
2547   1A5E 00 00 00 00 
2547   1A62 00 00 00 00 
2547   1A66 00 00 00 00 
2547   1A6A 00 00 00 00 
2547   1A6E 00 00 00 00 
2547   1A72 00 00 00 00 
2547   1A76 00 00 00 00 
2547   1A7A 00 00 00 00 
2547   1A7E 00 00 00 00 
2547   1A82 00 00 00 00 
2547   1A86 00 00 00 00 
2547   1A8A 00 00 00 00 
2547   1A8E 00 00 00 00 
2547   1A92 00 00 00 00 
2547   1A96 00 00 00 00 
2547   1A9A 00 00 00 00 
2547   1A9E 00 00 00 00 
2547   1AA2 00 00 00 00 
2547   1AA6 00 00 00 00 
2547   1AAA 00 00 00 00 
2547   1AAE 00 00 00 00 
2547   1AB2 00 00 00 00 
2547   1AB6 00 00 00 00 
2547   1ABA 00 00 00 00 
2547   1ABE 00 00 00 00 
2547   1AC2 00 00 00 00 
2547   1AC6 00 00 00 00 
2547   1ACA 00 00 00 00 
2547   1ACE 00 00 00 00 
2547   1AD2 00 00 00 00 
2547   1AD6 00 00 00 00 
2548   1ADA 00 00 00 00 filename:      .fill 512, 0    ; holds a path for file search
2548   1ADE 00 00 00 00 
2548   1AE2 00 00 00 00 
2548   1AE6 00 00 00 00 
2548   1AEA 00 00 00 00 
2548   1AEE 00 00 00 00 
2548   1AF2 00 00 00 00 
2548   1AF6 00 00 00 00 
2548   1AFA 00 00 00 00 
2548   1AFE 00 00 00 00 
2548   1B02 00 00 00 00 
2548   1B06 00 00 00 00 
2548   1B0A 00 00 00 00 
2548   1B0E 00 00 00 00 
2548   1B12 00 00 00 00 
2548   1B16 00 00 00 00 
2548   1B1A 00 00 00 00 
2548   1B1E 00 00 00 00 
2548   1B22 00 00 00 00 
2548   1B26 00 00 00 00 
2548   1B2A 00 00 00 00 
2548   1B2E 00 00 00 00 
2548   1B32 00 00 00 00 
2548   1B36 00 00 00 00 
2548   1B3A 00 00 00 00 
2548   1B3E 00 00 00 00 
2548   1B42 00 00 00 00 
2548   1B46 00 00 00 00 
2548   1B4A 00 00 00 00 
2548   1B4E 00 00 00 00 
2548   1B52 00 00 00 00 
2548   1B56 00 00 00 00 
2548   1B5A 00 00 00 00 
2548   1B5E 00 00 00 00 
2548   1B62 00 00 00 00 
2548   1B66 00 00 00 00 
2548   1B6A 00 00 00 00 
2548   1B6E 00 00 00 00 
2548   1B72 00 00 00 00 
2548   1B76 00 00 00 00 
2548   1B7A 00 00 00 00 
2548   1B7E 00 00 00 00 
2548   1B82 00 00 00 00 
2548   1B86 00 00 00 00 
2548   1B8A 00 00 00 00 
2548   1B8E 00 00 00 00 
2548   1B92 00 00 00 00 
2548   1B96 00 00 00 00 
2548   1B9A 00 00 00 00 
2548   1B9E 00 00 00 00 
2548   1BA2 00 00 00 00 
2548   1BA6 00 00 00 00 
2548   1BAA 00 00 00 00 
2548   1BAE 00 00 00 00 
2548   1BB2 00 00 00 00 
2548   1BB6 00 00 00 00 
2548   1BBA 00 00 00 00 
2548   1BBE 00 00 00 00 
2548   1BC2 00 00 00 00 
2548   1BC6 00 00 00 00 
2548   1BCA 00 00 00 00 
2548   1BCE 00 00 00 00 
2548   1BD2 00 00 00 00 
2548   1BD6 00 00 00 00 
2548   1BDA 00 00 00 00 
2548   1BDE 00 00 00 00 
2548   1BE2 00 00 00 00 
2548   1BE6 00 00 00 00 
2548   1BEA 00 00 00 00 
2548   1BEE 00 00 00 00 
2548   1BF2 00 00 00 00 
2548   1BF6 00 00 00 00 
2548   1BFA 00 00 00 00 
2548   1BFE 00 00 00 00 
2548   1C02 00 00 00 00 
2548   1C06 00 00 00 00 
2548   1C0A 00 00 00 00 
2548   1C0E 00 00 00 00 
2548   1C12 00 00 00 00 
2548   1C16 00 00 00 00 
2548   1C1A 00 00 00 00 
2548   1C1E 00 00 00 00 
2548   1C22 00 00 00 00 
2548   1C26 00 00 00 00 
2548   1C2A 00 00 00 00 
2548   1C2E 00 00 00 00 
2548   1C32 00 00 00 00 
2548   1C36 00 00 00 00 
2548   1C3A 00 00 00 00 
2548   1C3E 00 00 00 00 
2548   1C42 00 00 00 00 
2548   1C46 00 00 00 00 
2548   1C4A 00 00 00 00 
2548   1C4E 00 00 00 00 
2548   1C52 00 00 00 00 
2548   1C56 00 00 00 00 
2548   1C5A 00 00 00 00 
2548   1C5E 00 00 00 00 
2548   1C62 00 00 00 00 
2548   1C66 00 00 00 00 
2548   1C6A 00 00 00 00 
2548   1C6E 00 00 00 00 
2548   1C72 00 00 00 00 
2548   1C76 00 00 00 00 
2548   1C7A 00 00 00 00 
2548   1C7E 00 00 00 00 
2548   1C82 00 00 00 00 
2548   1C86 00 00 00 00 
2548   1C8A 00 00 00 00 
2548   1C8E 00 00 00 00 
2548   1C92 00 00 00 00 
2548   1C96 00 00 00 00 
2548   1C9A 00 00 00 00 
2548   1C9E 00 00 00 00 
2548   1CA2 00 00 00 00 
2548   1CA6 00 00 00 00 
2548   1CAA 00 00 00 00 
2548   1CAE 00 00 00 00 
2548   1CB2 00 00 00 00 
2548   1CB6 00 00 00 00 
2548   1CBA 00 00 00 00 
2548   1CBE 00 00 00 00 
2548   1CC2 00 00 00 00 
2548   1CC6 00 00 00 00 
2548   1CCA 00 00 00 00 
2548   1CCE 00 00 00 00 
2548   1CD2 00 00 00 00 
2548   1CD6 00 00 00 00 
2549   1CDA 00 00 00 00 temp_data:      .fill 512, 0       ;  user space data
2549   1CDE 00 00 00 00 
2549   1CE2 00 00 00 00 
2549   1CE6 00 00 00 00 
2549   1CEA 00 00 00 00 
2549   1CEE 00 00 00 00 
2549   1CF2 00 00 00 00 
2549   1CF6 00 00 00 00 
2549   1CFA 00 00 00 00 
2549   1CFE 00 00 00 00 
2549   1D02 00 00 00 00 
2549   1D06 00 00 00 00 
2549   1D0A 00 00 00 00 
2549   1D0E 00 00 00 00 
2549   1D12 00 00 00 00 
2549   1D16 00 00 00 00 
2549   1D1A 00 00 00 00 
2549   1D1E 00 00 00 00 
2549   1D22 00 00 00 00 
2549   1D26 00 00 00 00 
2549   1D2A 00 00 00 00 
2549   1D2E 00 00 00 00 
2549   1D32 00 00 00 00 
2549   1D36 00 00 00 00 
2549   1D3A 00 00 00 00 
2549   1D3E 00 00 00 00 
2549   1D42 00 00 00 00 
2549   1D46 00 00 00 00 
2549   1D4A 00 00 00 00 
2549   1D4E 00 00 00 00 
2549   1D52 00 00 00 00 
2549   1D56 00 00 00 00 
2549   1D5A 00 00 00 00 
2549   1D5E 00 00 00 00 
2549   1D62 00 00 00 00 
2549   1D66 00 00 00 00 
2549   1D6A 00 00 00 00 
2549   1D6E 00 00 00 00 
2549   1D72 00 00 00 00 
2549   1D76 00 00 00 00 
2549   1D7A 00 00 00 00 
2549   1D7E 00 00 00 00 
2549   1D82 00 00 00 00 
2549   1D86 00 00 00 00 
2549   1D8A 00 00 00 00 
2549   1D8E 00 00 00 00 
2549   1D92 00 00 00 00 
2549   1D96 00 00 00 00 
2549   1D9A 00 00 00 00 
2549   1D9E 00 00 00 00 
2549   1DA2 00 00 00 00 
2549   1DA6 00 00 00 00 
2549   1DAA 00 00 00 00 
2549   1DAE 00 00 00 00 
2549   1DB2 00 00 00 00 
2549   1DB6 00 00 00 00 
2549   1DBA 00 00 00 00 
2549   1DBE 00 00 00 00 
2549   1DC2 00 00 00 00 
2549   1DC6 00 00 00 00 
2549   1DCA 00 00 00 00 
2549   1DCE 00 00 00 00 
2549   1DD2 00 00 00 00 
2549   1DD6 00 00 00 00 
2549   1DDA 00 00 00 00 
2549   1DDE 00 00 00 00 
2549   1DE2 00 00 00 00 
2549   1DE6 00 00 00 00 
2549   1DEA 00 00 00 00 
2549   1DEE 00 00 00 00 
2549   1DF2 00 00 00 00 
2549   1DF6 00 00 00 00 
2549   1DFA 00 00 00 00 
2549   1DFE 00 00 00 00 
2549   1E02 00 00 00 00 
2549   1E06 00 00 00 00 
2549   1E0A 00 00 00 00 
2549   1E0E 00 00 00 00 
2549   1E12 00 00 00 00 
2549   1E16 00 00 00 00 
2549   1E1A 00 00 00 00 
2549   1E1E 00 00 00 00 
2549   1E22 00 00 00 00 
2549   1E26 00 00 00 00 
2549   1E2A 00 00 00 00 
2549   1E2E 00 00 00 00 
2549   1E32 00 00 00 00 
2549   1E36 00 00 00 00 
2549   1E3A 00 00 00 00 
2549   1E3E 00 00 00 00 
2549   1E42 00 00 00 00 
2549   1E46 00 00 00 00 
2549   1E4A 00 00 00 00 
2549   1E4E 00 00 00 00 
2549   1E52 00 00 00 00 
2549   1E56 00 00 00 00 
2549   1E5A 00 00 00 00 
2549   1E5E 00 00 00 00 
2549   1E62 00 00 00 00 
2549   1E66 00 00 00 00 
2549   1E6A 00 00 00 00 
2549   1E6E 00 00 00 00 
2549   1E72 00 00 00 00 
2549   1E76 00 00 00 00 
2549   1E7A 00 00 00 00 
2549   1E7E 00 00 00 00 
2549   1E82 00 00 00 00 
2549   1E86 00 00 00 00 
2549   1E8A 00 00 00 00 
2549   1E8E 00 00 00 00 
2549   1E92 00 00 00 00 
2549   1E96 00 00 00 00 
2549   1E9A 00 00 00 00 
2549   1E9E 00 00 00 00 
2549   1EA2 00 00 00 00 
2549   1EA6 00 00 00 00 
2549   1EAA 00 00 00 00 
2549   1EAE 00 00 00 00 
2549   1EB2 00 00 00 00 
2549   1EB6 00 00 00 00 
2549   1EBA 00 00 00 00 
2549   1EBE 00 00 00 00 
2549   1EC2 00 00 00 00 
2549   1EC6 00 00 00 00 
2549   1ECA 00 00 00 00 
2549   1ECE 00 00 00 00 
2549   1ED2 00 00 00 00 
2549   1ED6 00 00 00 00 
2550   1EDA FF FF FF FF fifo:        .fill FIFO_SIZE
2550   1EDE FF FF FF FF 
2550   1EE2 FF FF FF FF 
2550   1EE6 FF FF FF FF 
2550   1EEA FF FF FF FF 
2550   1EEE FF FF FF FF 
2550   1EF2 FF FF FF FF 
2550   1EF6 FF FF FF FF 
2550   1EFA FF FF FF FF 
2550   1EFE FF FF FF FF 
2550   1F02 FF FF FF FF 
2550   1F06 FF FF FF FF 
2550   1F0A FF FF FF FF 
2550   1F0E FF FF FF FF 
2550   1F12 FF FF FF FF 
2550   1F16 FF FF FF FF 
2550   1F1A FF FF FF FF 
2550   1F1E FF FF FF FF 
2550   1F22 FF FF FF FF 
2550   1F26 FF FF FF FF 
2550   1F2A FF FF FF FF 
2550   1F2E FF FF FF FF 
2550   1F32 FF FF FF FF 
2550   1F36 FF FF FF FF 
2550   1F3A FF FF FF FF 
2550   1F3E FF FF FF FF 
2550   1F42 FF FF FF FF 
2550   1F46 FF FF FF FF 
2550   1F4A FF FF FF FF 
2550   1F4E FF FF FF FF 
2550   1F52 FF FF FF FF 
2550   1F56 FF FF FF FF 
2550   1F5A FF FF FF FF 
2550   1F5E FF FF FF FF 
2550   1F62 FF FF FF FF 
2550   1F66 FF FF FF FF 
2550   1F6A FF FF FF FF 
2550   1F6E FF FF FF FF 
2550   1F72 FF FF FF FF 
2550   1F76 FF FF FF FF 
2550   1F7A FF FF FF FF 
2550   1F7E FF FF FF FF 
2550   1F82 FF FF FF FF 
2550   1F86 FF FF FF FF 
2550   1F8A FF FF FF FF 
2550   1F8E FF FF FF FF 
2550   1F92 FF FF FF FF 
2550   1F96 FF FF FF FF 
2550   1F9A FF FF FF FF 
2550   1F9E FF FF FF FF 
2550   1FA2 FF FF FF FF 
2550   1FA6 FF FF FF FF 
2550   1FAA FF FF FF FF 
2550   1FAE FF FF FF FF 
2550   1FB2 FF FF FF FF 
2550   1FB6 FF FF FF FF 
2550   1FBA FF FF FF FF 
2550   1FBE FF FF FF FF 
2550   1FC2 FF FF FF FF 
2550   1FC6 FF FF FF FF 
2550   1FCA FF FF FF FF 
2550   1FCE FF FF FF FF 
2550   1FD2 FF FF FF FF 
2550   1FD6 FF FF FF FF 
2550   1FDA FF FF FF FF 
2550   1FDE FF FF FF FF 
2550   1FE2 FF FF FF FF 
2550   1FE6 FF FF FF FF 
2550   1FEA FF FF FF FF 
2550   1FEE FF FF FF FF 
2550   1FF2 FF FF FF FF 
2550   1FF6 FF FF FF FF 
2550   1FFA FF FF FF FF 
2550   1FFE FF FF FF FF 
2550   2002 FF FF FF FF 
2550   2006 FF FF FF FF 
2550   200A FF FF FF FF 
2550   200E FF FF FF FF 
2550   2012 FF FF FF FF 
2550   2016 FF FF FF FF 
2550   201A FF FF FF FF 
2550   201E FF FF FF FF 
2550   2022 FF FF FF FF 
2550   2026 FF FF FF FF 
2550   202A FF FF FF FF 
2550   202E FF FF FF FF 
2550   2032 FF FF FF FF 
2550   2036 FF FF FF FF 
2550   203A FF FF FF FF 
2550   203E FF FF FF FF 
2550   2042 FF FF FF FF 
2550   2046 FF FF FF FF 
2550   204A FF FF FF FF 
2550   204E FF FF FF FF 
2550   2052 FF FF FF FF 
2550   2056 FF FF FF FF 
2550   205A FF FF FF FF 
2550   205E FF FF FF FF 
2550   2062 FF FF FF FF 
2550   2066 FF FF FF FF 
2550   206A FF FF FF FF 
2550   206E FF FF FF FF 
2550   2072 FF FF FF FF 
2550   2076 FF FF FF FF 
2550   207A FF FF FF FF 
2550   207E FF FF FF FF 
2550   2082 FF FF FF FF 
2550   2086 FF FF FF FF 
2550   208A FF FF FF FF 
2550   208E FF FF FF FF 
2550   2092 FF FF FF FF 
2550   2096 FF FF FF FF 
2550   209A FF FF FF FF 
2550   209E FF FF FF FF 
2550   20A2 FF FF FF FF 
2550   20A6 FF FF FF FF 
2550   20AA FF FF FF FF 
2550   20AE FF FF FF FF 
2550   20B2 FF FF FF FF 
2550   20B6 FF FF FF FF 
2550   20BA FF FF FF FF 
2550   20BE FF FF FF FF 
2550   20C2 FF FF FF FF 
2550   20C6 FF FF FF FF 
2550   20CA FF FF FF FF 
2550   20CE FF FF FF FF 
2550   20D2 FF FF FF FF 
2550   20D6 FF FF FF FF 
2550   20DA FF FF FF FF 
2550   20DE FF FF FF FF 
2550   20E2 FF FF FF FF 
2550   20E6 FF FF FF FF 
2550   20EA FF FF FF FF 
2550   20EE FF FF FF FF 
2550   20F2 FF FF FF FF 
2550   20F6 FF FF FF FF 
2550   20FA FF FF FF FF 
2550   20FE FF FF FF FF 
2550   2102 FF FF FF FF 
2550   2106 FF FF FF FF 
2550   210A FF FF FF FF 
2550   210E FF FF FF FF 
2550   2112 FF FF FF FF 
2550   2116 FF FF FF FF 
2550   211A FF FF FF FF 
2550   211E FF FF FF FF 
2550   2122 FF FF FF FF 
2550   2126 FF FF FF FF 
2550   212A FF FF FF FF 
2550   212E FF FF FF FF 
2550   2132 FF FF FF FF 
2550   2136 FF FF FF FF 
2550   213A FF FF FF FF 
2550   213E FF FF FF FF 
2550   2142 FF FF FF FF 
2550   2146 FF FF FF FF 
2550   214A FF FF FF FF 
2550   214E FF FF FF FF 
2550   2152 FF FF FF FF 
2550   2156 FF FF FF FF 
2550   215A FF FF FF FF 
2550   215E FF FF FF FF 
2550   2162 FF FF FF FF 
2550   2166 FF FF FF FF 
2550   216A FF FF FF FF 
2550   216E FF FF FF FF 
2550   2172 FF FF FF FF 
2550   2176 FF FF FF FF 
2550   217A FF FF FF FF 
2550   217E FF FF FF FF 
2550   2182 FF FF FF FF 
2550   2186 FF FF FF FF 
2550   218A FF FF FF FF 
2550   218E FF FF FF FF 
2550   2192 FF FF FF FF 
2550   2196 FF FF FF FF 
2550   219A FF FF FF FF 
2550   219E FF FF FF FF 
2550   21A2 FF FF FF FF 
2550   21A6 FF FF FF FF 
2550   21AA FF FF FF FF 
2550   21AE FF FF FF FF 
2550   21B2 FF FF FF FF 
2550   21B6 FF FF FF FF 
2550   21BA FF FF FF FF 
2550   21BE FF FF FF FF 
2550   21C2 FF FF FF FF 
2550   21C6 FF FF FF FF 
2550   21CA FF FF FF FF 
2550   21CE FF FF FF FF 
2550   21D2 FF FF FF FF 
2550   21D6 FF FF FF FF 
2550   21DA FF FF FF FF 
2550   21DE FF FF FF FF 
2550   21E2 FF FF FF FF 
2550   21E6 FF FF FF FF 
2550   21EA FF FF FF FF 
2550   21EE FF FF FF FF 
2550   21F2 FF FF FF FF 
2550   21F6 FF FF FF FF 
2550   21FA FF FF FF FF 
2550   21FE FF FF FF FF 
2550   2202 FF FF FF FF 
2550   2206 FF FF FF FF 
2550   220A FF FF FF FF 
2550   220E FF FF FF FF 
2550   2212 FF FF FF FF 
2550   2216 FF FF FF FF 
2550   221A FF FF FF FF 
2550   221E FF FF FF FF 
2550   2222 FF FF FF FF 
2550   2226 FF FF FF FF 
2550   222A FF FF FF FF 
2550   222E FF FF FF FF 
2550   2232 FF FF FF FF 
2550   2236 FF FF FF FF 
2550   223A FF FF FF FF 
2550   223E FF FF FF FF 
2550   2242 FF FF FF FF 
2550   2246 FF FF FF FF 
2550   224A FF FF FF FF 
2550   224E FF FF FF FF 
2550   2252 FF FF FF FF 
2550   2256 FF FF FF FF 
2550   225A FF FF FF FF 
2550   225E FF FF FF FF 
2550   2262 FF FF FF FF 
2550   2266 FF FF FF FF 
2550   226A FF FF FF FF 
2550   226E FF FF FF FF 
2550   2272 FF FF FF FF 
2550   2276 FF FF FF FF 
2550   227A FF FF FF FF 
2550   227E FF FF FF FF 
2550   2282 FF FF FF FF 
2550   2286 FF FF FF FF 
2550   228A FF FF FF FF 
2550   228E FF FF FF FF 
2550   2292 FF FF FF FF 
2550   2296 FF FF FF FF 
2550   229A FF FF FF FF 
2550   229E FF FF FF FF 
2550   22A2 FF FF FF FF 
2550   22A6 FF FF FF FF 
2550   22AA FF FF FF FF 
2550   22AE FF FF FF FF 
2550   22B2 FF FF FF FF 
2550   22B6 FF FF FF FF 
2550   22BA FF FF FF FF 
2550   22BE FF FF FF FF 
2550   22C2 FF FF FF FF 
2550   22C6 FF FF FF FF 
2550   22CA FF FF FF FF 
2550   22CE FF FF FF FF 
2550   22D2 FF FF FF FF 
2550   22D6 FF FF FF FF 
2550   22DA FF FF FF FF 
2550   22DE FF FF FF FF 
2550   22E2 FF FF FF FF 
2550   22E6 FF FF FF FF 
2550   22EA FF FF FF FF 
2550   22EE FF FF FF FF 
2550   22F2 FF FF FF FF 
2550   22F6 FF FF FF FF 
2550   22FA FF FF FF FF 
2550   22FE FF FF FF FF 
2550   2302 FF FF FF FF 
2550   2306 FF FF FF FF 
2550   230A FF FF FF FF 
2550   230E FF FF FF FF 
2550   2312 FF FF FF FF 
2550   2316 FF FF FF FF 
2550   231A FF FF FF FF 
2550   231E FF FF FF FF 
2550   2322 FF FF FF FF 
2550   2326 FF FF FF FF 
2550   232A FF FF FF FF 
2550   232E FF FF FF FF 
2550   2332 FF FF FF FF 
2550   2336 FF FF FF FF 
2550   233A FF FF FF FF 
2550   233E FF FF FF FF 
2550   2342 FF FF FF FF 
2550   2346 FF FF FF FF 
2550   234A FF FF FF FF 
2550   234E FF FF FF FF 
2550   2352 FF FF FF FF 
2550   2356 FF FF FF FF 
2550   235A FF FF FF FF 
2550   235E FF FF FF FF 
2550   2362 FF FF FF FF 
2550   2366 FF FF FF FF 
2550   236A FF FF FF FF 
2550   236E FF FF FF FF 
2550   2372 FF FF FF FF 
2550   2376 FF FF FF FF 
2550   237A FF FF FF FF 
2550   237E FF FF FF FF 
2550   2382 FF FF FF FF 
2550   2386 FF FF FF FF 
2550   238A FF FF FF FF 
2550   238E FF FF FF FF 
2550   2392 FF FF FF FF 
2550   2396 FF FF FF FF 
2550   239A FF FF FF FF 
2550   239E FF FF FF FF 
2550   23A2 FF FF FF FF 
2550   23A6 FF FF FF FF 
2550   23AA FF FF FF FF 
2550   23AE FF FF FF FF 
2550   23B2 FF FF FF FF 
2550   23B6 FF FF FF FF 
2550   23BA FF FF FF FF 
2550   23BE FF FF FF FF 
2550   23C2 FF FF FF FF 
2550   23C6 FF FF FF FF 
2550   23CA FF FF FF FF 
2550   23CE FF FF FF FF 
2550   23D2 FF FF FF FF 
2550   23D6 FF FF FF FF 
2550   23DA FF FF FF FF 
2550   23DE FF FF FF FF 
2550   23E2 FF FF FF FF 
2550   23E6 FF FF FF FF 
2550   23EA FF FF FF FF 
2550   23EE FF FF FF FF 
2550   23F2 FF FF FF FF 
2550   23F6 FF FF FF FF 
2550   23FA FF FF FF FF 
2550   23FE FF FF FF FF 
2550   2402 FF FF FF FF 
2550   2406 FF FF FF FF 
2550   240A FF FF FF FF 
2550   240E FF FF FF FF 
2550   2412 FF FF FF FF 
2550   2416 FF FF FF FF 
2550   241A FF FF FF FF 
2550   241E FF FF FF FF 
2550   2422 FF FF FF FF 
2550   2426 FF FF FF FF 
2550   242A FF FF FF FF 
2550   242E FF FF FF FF 
2550   2432 FF FF FF FF 
2550   2436 FF FF FF FF 
2550   243A FF FF FF FF 
2550   243E FF FF FF FF 
2550   2442 FF FF FF FF 
2550   2446 FF FF FF FF 
2550   244A FF FF FF FF 
2550   244E FF FF FF FF 
2550   2452 FF FF FF FF 
2550   2456 FF FF FF FF 
2550   245A FF FF FF FF 
2550   245E FF FF FF FF 
2550   2462 FF FF FF FF 
2550   2466 FF FF FF FF 
2550   246A FF FF FF FF 
2550   246E FF FF FF FF 
2550   2472 FF FF FF FF 
2550   2476 FF FF FF FF 
2550   247A FF FF FF FF 
2550   247E FF FF FF FF 
2550   2482 FF FF FF FF 
2550   2486 FF FF FF FF 
2550   248A FF FF FF FF 
2550   248E FF FF FF FF 
2550   2492 FF FF FF FF 
2550   2496 FF FF FF FF 
2550   249A FF FF FF FF 
2550   249E FF FF FF FF 
2550   24A2 FF FF FF FF 
2550   24A6 FF FF FF FF 
2550   24AA FF FF FF FF 
2550   24AE FF FF FF FF 
2550   24B2 FF FF FF FF 
2550   24B6 FF FF FF FF 
2550   24BA FF FF FF FF 
2550   24BE FF FF FF FF 
2550   24C2 FF FF FF FF 
2550   24C6 FF FF FF FF 
2550   24CA FF FF FF FF 
2550   24CE FF FF FF FF 
2550   24D2 FF FF FF FF 
2550   24D6 FF FF FF FF 
2550   24DA FF FF FF FF 
2550   24DE FF FF FF FF 
2550   24E2 FF FF FF FF 
2550   24E6 FF FF FF FF 
2550   24EA FF FF FF FF 
2550   24EE FF FF FF FF 
2550   24F2 FF FF FF FF 
2550   24F6 FF FF FF FF 
2550   24FA FF FF FF FF 
2550   24FE FF FF FF FF 
2550   2502 FF FF FF FF 
2550   2506 FF FF FF FF 
2550   250A FF FF FF FF 
2550   250E FF FF FF FF 
2550   2512 FF FF FF FF 
2550   2516 FF FF FF FF 
2550   251A FF FF FF FF 
2550   251E FF FF FF FF 
2550   2522 FF FF FF FF 
2550   2526 FF FF FF FF 
2550   252A FF FF FF FF 
2550   252E FF FF FF FF 
2550   2532 FF FF FF FF 
2550   2536 FF FF FF FF 
2550   253A FF FF FF FF 
2550   253E FF FF FF FF 
2550   2542 FF FF FF FF 
2550   2546 FF FF FF FF 
2550   254A FF FF FF FF 
2550   254E FF FF FF FF 
2550   2552 FF FF FF FF 
2550   2556 FF FF FF FF 
2550   255A FF FF FF FF 
2550   255E FF FF FF FF 
2550   2562 FF FF FF FF 
2550   2566 FF FF FF FF 
2550   256A FF FF FF FF 
2550   256E FF FF FF FF 
2550   2572 FF FF FF FF 
2550   2576 FF FF FF FF 
2550   257A FF FF FF FF 
2550   257E FF FF FF FF 
2550   2582 FF FF FF FF 
2550   2586 FF FF FF FF 
2550   258A FF FF FF FF 
2550   258E FF FF FF FF 
2550   2592 FF FF FF FF 
2550   2596 FF FF FF FF 
2550   259A FF FF FF FF 
2550   259E FF FF FF FF 
2550   25A2 FF FF FF FF 
2550   25A6 FF FF FF FF 
2550   25AA FF FF FF FF 
2550   25AE FF FF FF FF 
2550   25B2 FF FF FF FF 
2550   25B6 FF FF FF FF 
2550   25BA FF FF FF FF 
2550   25BE FF FF FF FF 
2550   25C2 FF FF FF FF 
2550   25C6 FF FF FF FF 
2550   25CA FF FF FF FF 
2550   25CE FF FF FF FF 
2550   25D2 FF FF FF FF 
2550   25D6 FF FF FF FF 
2550   25DA FF FF FF FF 
2550   25DE FF FF FF FF 
2550   25E2 FF FF FF FF 
2550   25E6 FF FF FF FF 
2550   25EA FF FF FF FF 
2550   25EE FF FF FF FF 
2550   25F2 FF FF FF FF 
2550   25F6 FF FF FF FF 
2550   25FA FF FF FF FF 
2550   25FE FF FF FF FF 
2550   2602 FF FF FF FF 
2550   2606 FF FF FF FF 
2550   260A FF FF FF FF 
2550   260E FF FF FF FF 
2550   2612 FF FF FF FF 
2550   2616 FF FF FF FF 
2550   261A FF FF FF FF 
2550   261E FF FF FF FF 
2550   2622 FF FF FF FF 
2550   2626 FF FF FF FF 
2550   262A FF FF FF FF 
2550   262E FF FF FF FF 
2550   2632 FF FF FF FF 
2550   2636 FF FF FF FF 
2550   263A FF FF FF FF 
2550   263E FF FF FF FF 
2550   2642 FF FF FF FF 
2550   2646 FF FF FF FF 
2550   264A FF FF FF FF 
2550   264E FF FF FF FF 
2550   2652 FF FF FF FF 
2550   2656 FF FF FF FF 
2550   265A FF FF FF FF 
2550   265E FF FF FF FF 
2550   2662 FF FF FF FF 
2550   2666 FF FF FF FF 
2550   266A FF FF FF FF 
2550   266E FF FF FF FF 
2550   2672 FF FF FF FF 
2550   2676 FF FF FF FF 
2550   267A FF FF FF FF 
2550   267E FF FF FF FF 
2550   2682 FF FF FF FF 
2550   2686 FF FF FF FF 
2550   268A FF FF FF FF 
2550   268E FF FF FF FF 
2550   2692 FF FF FF FF 
2550   2696 FF FF FF FF 
2550   269A FF FF FF FF 
2550   269E FF FF FF FF 
2550   26A2 FF FF FF FF 
2550   26A6 FF FF FF FF 
2550   26AA FF FF FF FF 
2550   26AE FF FF FF FF 
2550   26B2 FF FF FF FF 
2550   26B6 FF FF FF FF 
2550   26BA FF FF FF FF 
2550   26BE FF FF FF FF 
2550   26C2 FF FF FF FF 
2550   26C6 FF FF FF FF 
2550   26CA FF FF FF FF 
2550   26CE FF FF FF FF 
2550   26D2 FF FF FF FF 
2550   26D6 FF FF FF FF 
2551   26DA             
2552   26DA FF FF FF FF scrap_sector:    .fill 512    ; scrap sector
2552   26DE FF FF FF FF 
2552   26E2 FF FF FF FF 
2552   26E6 FF FF FF FF 
2552   26EA FF FF FF FF 
2552   26EE FF FF FF FF 
2552   26F2 FF FF FF FF 
2552   26F6 FF FF FF FF 
2552   26FA FF FF FF FF 
2552   26FE FF FF FF FF 
2552   2702 FF FF FF FF 
2552   2706 FF FF FF FF 
2552   270A FF FF FF FF 
2552   270E FF FF FF FF 
2552   2712 FF FF FF FF 
2552   2716 FF FF FF FF 
2552   271A FF FF FF FF 
2552   271E FF FF FF FF 
2552   2722 FF FF FF FF 
2552   2726 FF FF FF FF 
2552   272A FF FF FF FF 
2552   272E FF FF FF FF 
2552   2732 FF FF FF FF 
2552   2736 FF FF FF FF 
2552   273A FF FF FF FF 
2552   273E FF FF FF FF 
2552   2742 FF FF FF FF 
2552   2746 FF FF FF FF 
2552   274A FF FF FF FF 
2552   274E FF FF FF FF 
2552   2752 FF FF FF FF 
2552   2756 FF FF FF FF 
2552   275A FF FF FF FF 
2552   275E FF FF FF FF 
2552   2762 FF FF FF FF 
2552   2766 FF FF FF FF 
2552   276A FF FF FF FF 
2552   276E FF FF FF FF 
2552   2772 FF FF FF FF 
2552   2776 FF FF FF FF 
2552   277A FF FF FF FF 
2552   277E FF FF FF FF 
2552   2782 FF FF FF FF 
2552   2786 FF FF FF FF 
2552   278A FF FF FF FF 
2552   278E FF FF FF FF 
2552   2792 FF FF FF FF 
2552   2796 FF FF FF FF 
2552   279A FF FF FF FF 
2552   279E FF FF FF FF 
2552   27A2 FF FF FF FF 
2552   27A6 FF FF FF FF 
2552   27AA FF FF FF FF 
2552   27AE FF FF FF FF 
2552   27B2 FF FF FF FF 
2552   27B6 FF FF FF FF 
2552   27BA FF FF FF FF 
2552   27BE FF FF FF FF 
2552   27C2 FF FF FF FF 
2552   27C6 FF FF FF FF 
2552   27CA FF FF FF FF 
2552   27CE FF FF FF FF 
2552   27D2 FF FF FF FF 
2552   27D6 FF FF FF FF 
2552   27DA FF FF FF FF 
2552   27DE FF FF FF FF 
2552   27E2 FF FF FF FF 
2552   27E6 FF FF FF FF 
2552   27EA FF FF FF FF 
2552   27EE FF FF FF FF 
2552   27F2 FF FF FF FF 
2552   27F6 FF FF FF FF 
2552   27FA FF FF FF FF 
2552   27FE FF FF FF FF 
2552   2802 FF FF FF FF 
2552   2806 FF FF FF FF 
2552   280A FF FF FF FF 
2552   280E FF FF FF FF 
2552   2812 FF FF FF FF 
2552   2816 FF FF FF FF 
2552   281A FF FF FF FF 
2552   281E FF FF FF FF 
2552   2822 FF FF FF FF 
2552   2826 FF FF FF FF 
2552   282A FF FF FF FF 
2552   282E FF FF FF FF 
2552   2832 FF FF FF FF 
2552   2836 FF FF FF FF 
2552   283A FF FF FF FF 
2552   283E FF FF FF FF 
2552   2842 FF FF FF FF 
2552   2846 FF FF FF FF 
2552   284A FF FF FF FF 
2552   284E FF FF FF FF 
2552   2852 FF FF FF FF 
2552   2856 FF FF FF FF 
2552   285A FF FF FF FF 
2552   285E FF FF FF FF 
2552   2862 FF FF FF FF 
2552   2866 FF FF FF FF 
2552   286A FF FF FF FF 
2552   286E FF FF FF FF 
2552   2872 FF FF FF FF 
2552   2876 FF FF FF FF 
2552   287A FF FF FF FF 
2552   287E FF FF FF FF 
2552   2882 FF FF FF FF 
2552   2886 FF FF FF FF 
2552   288A FF FF FF FF 
2552   288E FF FF FF FF 
2552   2892 FF FF FF FF 
2552   2896 FF FF FF FF 
2552   289A FF FF FF FF 
2552   289E FF FF FF FF 
2552   28A2 FF FF FF FF 
2552   28A6 FF FF FF FF 
2552   28AA FF FF FF FF 
2552   28AE FF FF FF FF 
2552   28B2 FF FF FF FF 
2552   28B6 FF FF FF FF 
2552   28BA FF FF FF FF 
2552   28BE FF FF FF FF 
2552   28C2 FF FF FF FF 
2552   28C6 FF FF FF FF 
2552   28CA FF FF FF FF 
2552   28CE FF FF FF FF 
2552   28D2 FF FF FF FF 
2552   28D6 FF FF FF FF 
2553   28DA 00          transient_area:    .db 0      ; beginning of the transient memory area. used for disk reads and other purposes    
2554   28DB             
2555   28DB             
2556   28DB             .end
tasm: Number of errors = 0
