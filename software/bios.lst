0001   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002   0000             ; 74 SERIES MINICOMPUTER BIOS VERSION 1.0
0003   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004   0000             
0005   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006   0000             ; MEMORY MAP
0007   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008   0000             ; 0000		ROM BEGIN
0009   0000             ; ....
0010   0000             ; 7FFF		ROM END
0011   0000             ;
0012   0000             ; 8000		RAM begin
0013   0000             ; ....
0014   0000             ; F7FF		Stack root
0015   0000             
0016   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0017   0000             ; I/O MAP
0018   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0019   0000             ; FF80		UART 0		(16550)
0020   0000             ; FF90		UART 1		(16550)
0021   0000             ; FFA0		RTC			(M48T02)
0022   0000             ; FFB0		PIO 0		(8255)
0023   0000             ; FFC0		PIO 1		(8255)
0024   0000             ; FFD0		IDE			(Compact Flash / PATA)
0025   0000             ; FFE0		Timer		(8253)
0026   0000             ; FFF0		BIOS CONFIGURATION NV-RAM STORE AREA
0027   0000             
0028   0000             
0029   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030   0000             ; SYSTEM CONSTANTS / EQUATIONS
0031   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0032   0000             _UART0_DATA				.equ $FF80				; data
0033   0000             _UART0_DLAB_0			.equ $FF80				; divisor latch low byte
0034   0000             _UART0_DLAB_1			.equ $FF81				; divisor latch high byte
0035   0000             _UART0_IER				.equ $FF81				; Interrupt enable register
0036   0000             _UART0_FCR				.equ $FF82				; FIFO control register
0037   0000             _UART0_LCR				.equ $FF83				; line control register
0038   0000             _UART0_LSR				.equ $FF85				; line status register
0039   0000             
0040   0000             _IDE_BASE				.equ $FFD0				; IDE BASE
0041   0000             _IDE_R0					.equ _IDE_BASE + 0		; DATA PORT
0042   0000             _IDE_R1					.equ _IDE_BASE + 1		; READ: ERROR CODE, WRITE: FEATURE
0043   0000             _IDE_R2					.equ _IDE_BASE + 2		; NUMBER OF SECTORS TO TRANSFER
0044   0000             _IDE_R3					.equ _IDE_BASE + 3		; SECTOR ADDRESS LBA 0 [0:7]
0045   0000             _IDE_R4					.equ _IDE_BASE + 4		; SECTOR ADDRESS LBA 1 [8:15]
0046   0000             _IDE_R5					.equ _IDE_BASE + 5		; SECTOR ADDRESS LBA 2 [16:23]
0047   0000             _IDE_R6					.equ _IDE_BASE + 6		; SECTOR ADDRESS LBA 3 [24:27 (LSB)]
0048   0000             _IDE_R7					.equ _IDE_BASE + 7		; READ: STATUS, WRITE: COMMAND
0049   0000             
0050   0000             _7SEG_DISPLAY			.equ $FFB0				; BIOS POST CODE HEX DISPLAY (2 DIGITS)
0051   0000             _BIOS_POST_CTRL			.equ $FFB3				; BIOS POST DISPLAY CONTROL REGISTER, 80h = As Output
0052   0000             _PIO_A					.equ $FFB0		
0053   0000             _PIO_B					.equ $FFB1
0054   0000             _PIO_C					.equ $FFB2
0055   0000             _PIO_CONTROL			.equ $FFB3				; PIO CONTROL PORT
0056   0000             
0057   0000             _TIMER_C_0				.equ $FFE0				; TIMER COUNTER 0
0058   0000             _TIMER_C_1				.equ $FFE1				; TIMER COUNTER 1
0059   0000             _TIMER_C_2				.equ $FFE2				; TIMER COUNTER 2
0060   0000             _TIMER_CTRL				.equ $FFE3				; TIMER CONTROL REGISTER
0061   0000             
0062   0000             _STACK_BEGIN			.equ $F7FF				; beginning of stack
0063   0000             _GLOBAL_BASE			.equ $8000				; base of global variable block
0064   0000             
0065   0000             
0066   0000             boot_origin:			.equ _GLOBAL_BASE + 2 + 2
0067   0000             
0068   0000             IDE_buffer:				.equ _GLOBAL_BASE + 2 + 2 + 512
0069   0000             
0070   0000             NULL:					.equ 0
0071   0000             
0072   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0073   0000             ; GLOBAL SYSTEM VARIABLES
0074   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075   0000             
0076   0000             
0077   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0078   0000             ; EXTERNAL INTERRUPT TABLE
0079   0000             ; highest priority at lowest address
0080   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0081   0000 34 00       .dw INT_0
0082   0002 35 00       .dw INT_1
0083   0004 36 00       .dw INT_2
0084   0006 37 00       .dw INT_3
0085   0008 38 00       .dw INT_4
0086   000A 39 00       .dw INT_5
0087   000C 3A 00       .dw INT_6
0088   000E 3B 00       .dw INT_7
0089   0010             
0090   0010             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091   0010             ; RESET VECTOR DECLARATION
0092   0010             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0093   0010 C0 01       .dw BIOS_RESET_VECTOR
0094   0012             
0095   0012             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096   0012             ;; EXCEPTION VECTOR TABLE
0097   0012             ;; total of 7 entries, starting at address $0012
0098   0012             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099   0012 3C 00       .dw TRAP_PRIVILEGE	
0100   0014 52 00       .dw TRAP_DIV_ZERO	
0101   0016 5F 00       .dw UNDEFINED_OPCODE
0102   0018 00 00       .dw NULL
0103   001A 00 00       .dw NULL
0104   001C 00 00       .dw NULL
0105   001E 00 00       .dw NULL
0106   0020             
0107   0020             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108   0020             ;; SYSTEM CALL VECTOR TABLE
0109   0020             ;; starts at address $0020
0110   0020             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111   0020 45 00       .dw TRAP_BREAKPOINT
0112   0022 60 00       .dw RTC_SERVICES				
0113   0024 96 00       .dw UART_SERVICES				
0114   0026 EE 00       .dw IDE_SERVICES	
0115   0028 00 00       .dw NULL
0116   002A 00 00       .dw NULL
0117   002C 00 00       .dw NULL
0118   002E 00 00       .dw NULL
0119   0030 00 00       .dw NULL
0120   0032 00 00       .dw NULL	
0121   0034             
0122   0034             bios_bkpt	.equ 0
0123   0034             bios_rtc		.equ 1
0124   0034             bios_uart	.equ 2
0125   0034             bios_ide		.equ 3
0126   0034             
0127   0034             .export BIOS_RESET_VECTOR
0128   0034             .export IDE_buffer
0129   0034             .export boot_origin
0130   0034             .export bios_uart
0131   0034             .export bios_ide
0132   0034             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0133   0034             ; EXTERNAL INTERRUPTS' CODE BLOCK
0134   0034             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0135   0034             INT_0:
0136   0034 06          	sysret
0137   0035             INT_1:
0138   0035 06          	sysret
0139   0036             INT_2:
0140   0036 06          	sysret
0141   0037             INT_3:
0142   0037 06          	sysret
0143   0038             INT_4:
0144   0038 06          	sysret
0145   0039             INT_5:
0146   0039 06          	sysret
0147   003A             INT_6:	
0148   003A 06          	sysret
0149   003B             INT_7:
0150   003B 06          	sysret
0151   003C             
0152   003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0153   003C             ; EXCEPTIONS
0154   003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0155   003C             
0156   003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0157   003C             ; PRIVILEGE EXCEPTION
0158   003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0159   003C             TRAP_PRIVILEGE:
0160   003C DA          	push d
0161   003D             
0162   003D 3B B4 05    	mov d, s_priv1
0163   0040 07 82 02    	call puts
0164   0043             
0165   0043 E7          	pop d
0166   0044             							; enable interrupts
0167   0044 06          	sysret
0168   0045             
0169   0045             
0170   0045             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0171   0045             ; BREAKPOINT EXCEPTION
0172   0045             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0173   0045             TRAP_BREAKPOINT:
0174   0045 D7          	push a
0175   0046 DA          	push d
0176   0047 E1          	pushf
0177   0048             	
0178   0048 3B 9C 05    	mov d, s_bkpt
0179   004B 07 82 02    	call puts
0180   004E             	
0181   004E EE          	popf
0182   004F E7          	pop d
0183   0050 E4          	pop a
0184   0051             							; enable interrupts
0185   0051 06          	sysret
0186   0052             
0187   0052             
0188   0052             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0189   0052             ; DIVIDE BY ZERO EXCEPTION
0190   0052             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0191   0052             TRAP_DIV_ZERO:
0192   0052 D7          	push a
0193   0053 DA          	push d
0194   0054 E1          	pushf
0195   0055             	
0196   0055 3B FC 05    	mov d, s_divzero
0197   0058 07 82 02    	call puts
0198   005B             	
0199   005B EE          	popf
0200   005C E7          	pop d
0201   005D E4          	pop a
0202   005E             							; enable interrupts
0203   005E 06          	sysret
0204   005F             
0205   005F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0206   005F             ; UNDEFINED OPCODE EXCEPTION
0207   005F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208   005F             UNDEFINED_OPCODE:
0209   005F 06          	sysret
0210   0060             	
0211   0060             
0212   0060             	
0213   0060             
0214   0060             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0215   0060             ; RTC SERVICES INTERRUPT
0216   0060             ; RTC I/O bank = FFA0 to FFAF
0217   0060             ; FFA0 to FFA7 is scratch RAM
0218   0060             ; control register at $FFA8 [ W | R | S | Cal4..Cal0 ]
0219   0060             ; al = 0..6 -> get
0220   0060             ; al = 7..D -> set
0221   0060             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0222   0060             RTC_SERVICES:
0223   0060 DB          	push al
0224   0061 DA          	push d
0225   0062 B9 06       	cmp al, 6
0226   0064 D1 79 00    	jgu RTC_SET
0227   0067             RTC_GET:
0228   0067 6A A9       	add al, $A9			; generate RTC address to get to address A9 of clock
0229   0069 22 FF       	mov ah, $FF		
0230   006B 3C          	mov d, a				; get to FFA9 + offset
0231   006C F2 A8 FF 40 	mov byte[$FFA8], $40		; set R bit to 1
0232   0070 1E          	mov al, [d]			; get data
0233   0071 F2 A8 FF 00 	mov byte[$FFA8], 0		; reset R bit
0234   0075 23          	mov ah, al
0235   0076 E7          	pop d
0236   0077 E8          	pop al
0237   0078 06          	sysret
0238   0079             RTC_SET:
0239   0079 DD          	push bl
0240   007A 99          	mov bl, ah		; set data asIDE
0241   007B 6A A2       	add al, $A2		; generate RTC address to get to address A9 of clock
0242   007D 22 FF       	mov ah, $FF		
0243   007F 3C          	mov d, a		; get to FFA9 + offset
0244   0080 1B          	mov al, bl		; get data back
0245   0081 F2 A8 FF 80 	mov byte[$FFA8], $80	; set W bit to 1
0246   0085 3E          	mov [d], al		; set data
0247   0086 F2 A8 FF 00 	mov byte[$FFA8], 0		; reset write bit
0248   008A EA          	pop bl
0249   008B E7          	pop d
0250   008C E8          	pop al
0251   008D 06          	sysret
0252   008E             
0253   008E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0254   008E             ; INT 4
0255   008E             ; UART SERVICES INTERRUPT
0256   008E             ; al = option
0257   008E             ; ah = data
0258   008E             ; 0 = init, 1 = send, 2 = receive, 3 = receive with echo
0259   008E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260   008E             uart_serv_tbl:
0261   008E 9A 00       	.dw UART_INIT
0262   0090 B3 00       	.dw UART_SEND
0263   0092 C0 00       	.dw UART_RECEIVE
0264   0094 CD 00       	.dw UART_RECEIVE_E
0265   0096             UART_SERVICES:
0266   0096 FD 0A 8E 00 	jmp [uart_serv_tbl + al]
0267   009A             UART_INIT:
0268   009A F2 83 FF 83 	mov byte[_UART0_LCR], 83h			; 8 data, 1 stop, no parity	, divisor latch = 1, UART address 3 = Line Control Register
0269   009E F2 80 FF 03 	mov byte[_UART0_DLAB_0], 3			; baud = 38400, divisor latch low byte = 3
0270   00A2 F2 81 FF 00 	mov byte[_UART0_DLAB_1], 0			; divisor latch high byte = 0			
0271   00A6 F2 83 FF 03 	mov byte[_UART0_LCR], 3			; divisor latch = 0, UART address 3 = Line Control Register
0272   00AA F2 81 FF 00 	mov byte[_UART0_IER], 0			; disable all UART interrupts
0273   00AE F2 82 FF 00 	mov byte[_UART0_FCR], 0			; disable FIFO
0274   00B2 06          	sysret
0275   00B3             UART_SEND:
0276   00B3 1D 85 FF    	mov al, [_UART0_LSR]			; read Line Status Register
0277   00B6 93 20       	test al, 20h					; isolate Transmitter Empty
0278   00B8 C6 B3 00    	jz UART_SEND		
0279   00BB 1A          	mov al, ah
0280   00BC 3D 80 FF    	mov [_UART0_DATA], al			; write char to Transmitter Holding Register
0281   00BF 06          	sysret
0282   00C0             UART_RECEIVE:
0283   00C0 1D 85 FF    	mov al, [_UART0_LSR]			; read Line Status Register
0284   00C3 93 01       	test al, 1					; isolate Data Ready
0285   00C5 C6 C0 00    	jz UART_RECEIVE
0286   00C8 1D 80 FF    	mov al, [_UART0_DATA]			; get character
0287   00CB 23          	mov ah, al
0288   00CC 06          	sysret
0289   00CD             UART_RECEIVE_E:
0290   00CD 1D 85 FF    	mov al, [_UART0_LSR]			; read Line Status Register
0291   00D0 93 01       	test al, 1					; isolate Data Ready
0292   00D2 C6 CD 00    	jz UART_RECEIVE_E
0293   00D5 1D 80 FF    	mov al, [_UART0_DATA]			; get character
0294   00D8 23          	mov ah, al
0295   00D9             UART_RECEIVE_E_LOOP:
0296   00D9 1D 85 FF    	mov al, [_UART0_LSR]			; read Line Status Register
0297   00DC 93 20       	test al, 20h					; isolate Transmitter Empty
0298   00DE C6 D9 00    	jz UART_RECEIVE_E_LOOP
0299   00E1 1A          	mov al, ah
0300   00E2 3D 80 FF    	mov [_UART0_DATA], al			; write char to Transmitter Holding Register
0301   00E5 06          	sysret
0302   00E6             	
0303   00E6             
0304   00E6             
0305   00E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0306   00E6             ; IDE SERVICES INTERRUPT
0307   00E6             ; al = option
0308   00E6             ; 0 = ide reset, 1 = ide sleep, 2 = read sector, 3 = write sector
0309   00E6             ; IDE read/write sector
0310   00E6             ; 512 bytes
0311   00E6             ; user buffer pointer in D
0312   00E6             ; kernel buffer pointer = IDE_buffer
0313   00E6             ; AH = number of sectors
0314   00E6             ; CB = LBA bytes 3..0
0315   00E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0316   00E6             ide_serv_tbl:
0317   00E6 F2 00       	.dw IDE_RESET
0318   00E8 06 01       	.dw IDE_SLEEP
0319   00EA 15 01       	.dw IDE_READ_SECT
0320   00EC 36 01       	.dw IDE_WRITE_SECT
0321   00EE             IDE_SERVICES:
0322   00EE FD 0A E6 00 	jmp [ide_serv_tbl + al]	
0323   00F2             IDE_RESET:			
0324   00F2 F2 D7 FF 04 	mov byte[_IDE_R7], 4		; RESET IDE
0325   00F6 07 87 01    	call IDE_wait				; wait for IDE ready			 			
0326   00F9 F2 D6 FF E0 	mov byte[_IDE_R6], $E0		; LBA3= 0, MASTER, MODE= LBA				
0327   00FD F2 D1 FF 01 	mov byte[_IDE_R1], 1		; 8-BIT TRANSFERS			
0328   0101 F2 D7 FF EF 	mov byte[_IDE_R7], $EF		; SET FEATURE COMMAND
0329   0105 06          	sysret
0330   0106             IDE_SLEEP:
0331   0106 07 87 01    	call IDE_wait					; wait for IDE ready			 			
0332   0109 F2 D6 FF 40 	mov byte [_IDE_R6], %01000000	; lba[3:0](reserved), bit 6=1
0333   010D F2 D7 FF E6 	mov byte [_IDE_R7], $E6		; sleep command
0334   0111 07 87 01    	call IDE_wait					; wait for IDE ready
0335   0114 06          	sysret
0336   0115             IDE_READ_SECT:
0337   0115 1A          	mov al, ah
0338   0116 24          	mov ah, bl
0339   0117 42 D2 FF    	mov [_IDE_R2], a			; number of sectors (0..255)
0340   011A 1C          	mov al, bh
0341   011B 3D D4 FF    	mov [_IDE_R4], al
0342   011E 12          	mov a, c
0343   011F 3D D5 FF    	mov [_IDE_R5], al
0344   0122 1A          	mov al, ah
0345   0123 87 0F       	and al, %00001111
0346   0125 8B E0       	or al, %11100000			; mode lba, master
0347   0127 3D D6 FF    	mov [_IDE_R6], al
0348   012A 07 87 01    	call IDE_wait
0349   012D 19 20       	mov al, 20h
0350   012F 3D D7 FF    	mov [_IDE_R7], al			; read sector cmd
0351   0132 07 57 01    	call IDE_read	
0352   0135 06          	sysret
0353   0136             IDE_WRITE_SECT:
0354   0136 1A          	mov al, ah
0355   0137 24          	mov ah, bl
0356   0138 42 D2 FF    	mov [_IDE_R2], a			; number of sectors (0..255)
0357   013B 1C          	mov al, bh
0358   013C 3D D4 FF    	mov [_IDE_R4], al
0359   013F 12          	mov a, c
0360   0140 3D D5 FF    	mov [_IDE_R5], al
0361   0143 1A          	mov al, ah
0362   0144 87 0F       	and al, %00001111
0363   0146 8B E0       	or al, %11100000			; mode lba, master
0364   0148 3D D6 FF    	mov [_IDE_R6], al
0365   014B 07 87 01    	call IDE_wait
0366   014E 19 30       	mov al, 30h
0367   0150 3D D7 FF    	mov [_IDE_R7], al			; write sector cmd
0368   0153 07 6F 01    	call IDE_write			
0369   0156 06          	sysret
0370   0157             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0371   0157             ; READ IDE DATA
0372   0157             ; pointer in D
0373   0157             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0374   0157             IDE_read:
0375   0157 DB          	push al
0376   0158 DA          	push d
0377   0159             IDE_read_loop:
0378   0159 07 87 01    	call IDE_wait
0379   015C 1D D7 FF    	mov al, [_IDE_R7]
0380   015F 87 08       	and al, %00001000			; DRQ FLAG
0381   0161 C6 6C 01    	jz IDE_read_end
0382   0164 1D D0 FF    	mov al, [_IDE_R0]
0383   0167 3E          	mov [d], al
0384   0168 79          	inc d
0385   0169 0A 59 01    	jmp IDE_read_loop
0386   016C             IDE_read_end:
0387   016C E7          	pop d
0388   016D E8          	pop al
0389   016E 09          	ret
0390   016F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0391   016F             ; WRITE IDE DATA
0392   016F             ; data pointer in D
0393   016F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0394   016F             IDE_write:
0395   016F DB          	push al
0396   0170 DA          	push d
0397   0171             IDE_write_loop:
0398   0171 07 87 01    	call IDE_wait
0399   0174 1D D7 FF    	mov al, [_IDE_R7]
0400   0177 87 08       	and al, %00001000			; DRQ FLAG
0401   0179 C6 84 01    	jz IDE_write_end
0402   017C 1E          	mov al, [d]
0403   017D 3D D0 FF    	mov [_IDE_R0], al
0404   0180 79          	inc d 
0405   0181 0A 71 01    	jmp IDE_write_loop
0406   0184             IDE_write_end:
0407   0184 E7          	pop d
0408   0185 E8          	pop al
0409   0186 09          	ret
0410   0187             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0411   0187             ; wait for IDE to be ready
0412   0187             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0413   0187             IDE_wait:
0414   0187 1D D7 FF    	mov al, [_IDE_R7]	
0415   018A 87 80       	and al, 80h				; BUSY FLAG
0416   018C C7 87 01    	jnz IDE_wait
0417   018F 09          	ret
0418   0190             
0419   0190             	
0420   0190             	
0421   0190             ; ************************************************************
0422   0190             ; GET HEX FILE
0423   0190             ; di = destination address
0424   0190             ; return length in bytes in C
0425   0190             ; ************************************************************
0426   0190             _load_hex:
0427   0190 D2          	push bp
0428   0191 9B          	mov bp, sp
0429   0192 D7          	push a
0430   0193 D8          	push b
0431   0194 DA          	push d
0432   0195 E2          	push si
0433   0196 E3          	push di
0434   0197 52 00 60    	sub sp, $6000				; string data block
0435   019A 38 00 00    	mov c, 0
0436   019D             	
0437   019D 48          	mov a, sp
0438   019E 77          	inc a
0439   019F 3C          	mov d, a				; start of string data block
0440   01A0 07 F5 02    	call getse				; get program string
0441   01A3 4D          	mov si, a
0442   01A4             
0443   01A4             __load_hex_loop:
0444   01A4 F6          	lodsb					; load from [SI] to AL
0445   01A5 B9 00       	cmp al, 0				; check if ASCII 0
0446   01A7 C6 B5 01    	jz __load_hex_ret
0447   01AA 36          	mov bh, al
0448   01AB F6          	lodsb
0449   01AC 2F          	mov bl, al
0450   01AD 07 5E 03    	call atoi				; convert ASCII byte in B to int (to AL)
0451   01B0 F7          	stosb					; store AL to [DI]
0452   01B1 78          	inc c
0453   01B2 0A A4 01    	jmp __load_hex_loop
0454   01B5             __load_hex_ret:
0455   01B5 51 00 60    	add sp, $6000
0456   01B8 F0          	pop di
0457   01B9 EF          	pop si
0458   01BA E7          	pop d
0459   01BB E5          	pop b
0460   01BC E4          	pop a
0461   01BD 9C          	mov sp, bp
0462   01BE F1          	pop bp
0463   01BF 09          	ret
0464   01C0             	
0465   01C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0466   01C0             ; BIOS ENTRY POINT
0467   01C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0468   01C0             BIOS_RESET_VECTOR:
0469   01C0 19 20       	mov al, %00100000				; interrupts = OFF, mode = SUP, paging = OFF, halt-flag = OFF, display_load = ON
0470   01C2 0D          	stostat
0471   01C3             	
0472   01C3 10 FF F7    	mov a, _STACK_BEGIN
0473   01C6 47          	mov sp, a
0474   01C7 49          	mov bp, a			; setup stack and frame
0475   01C8             
0476   01C8 19 00       	mov al, 0
0477   01CA 05 02       	syscall bios_uart
0478   01CC             	
0479   01CC 3B EA 03    	mov d, s_welcome
0480   01CF 07 82 02    	call puts					; print welcome msg
0481   01D2             
0482   01D2 07 F2 01    	call BIOS_peripherals_setup
0483   01D5             	
0484   01D5             
0485   01D5 3B 3D 04    	mov d, s_boot1
0486   01D8 07 82 02    	call puts
0487   01DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
0488   01DB 38 00 00    	mov c, 0
0489   01DE 26 00 00    	mov b, 0					; start at disk sector 0
0490   01E1 3B 04 80    	mov d, boot_origin		; we read into the bios ide buffer
0491   01E4 10 02 01    	mov a, $0102				; disk read, 1 sector
0492   01E7 05 03       	syscall bios_ide			; read sector	
0493   01E9             	
0494   01E9 3B 53 04    	mov d, s_boot2
0495   01EC 07 82 02    	call puts
0496   01EF             
0497   01EF 0A 04 80    	jmp boot_origin
0498   01F2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0499   01F2             
0500   01F2             BIOS_peripherals_setup:
0501   01F2 3B AD 04    	mov d, s_init
0502   01F5 07 82 02    	call puts
0503   01F8             	
0504   01F8 3B 66 04    	mov d, s_bios3
0505   01FB 07 82 02    	call puts
0506   01FE 19 00       	mov al, 0						; reset ide
0507   0200 05 03       	syscall bios_ide	
0508   0202             	
0509   0202 3B 7C 04    	mov d, s_bios4
0510   0205 07 82 02    	call puts
0511   0208             	
0512   0208 19 30       	mov al, %00110000					; counter 0, load both bytes, mode 0, binary
0513   020A 3D E3 FF    	mov [_TIMER_CTRL], al
0514   020D 19 FF       	mov al, $FF
0515   020F 3D E0 FF    	mov [_TIMER_C_0], al				; load counter 0 low byte
0516   0212 3D E0 FF    	mov [_TIMER_C_0], al				; load counter 0 high byte
0517   0215             	
0518   0215 3B 92 04    	mov d, s_bios5
0519   0218 07 82 02    	call puts
0520   021B 19 80       	mov al, $80
0521   021D 3D B3 FF    	mov [_BIOS_POST_CTRL], al			; set PIO_A to output mode
0522   0220 19 00       	mov al, 0
0523   0222 3D B0 FF    	mov [_7SEG_DISPLAY], al			; post code = 00
0524   0225 09          	ret
0525   0226             
0526   0226             
0527   0226             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0528   0226             ; PRINT 16BIT HEX INTEGER
0529   0226             ; integer value in reg B
0530   0226             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0531   0226             PRINT_U16X:
0532   0226 E1          	pushf
0533   0227 D7          	push a
0534   0228 D8          	push b
0535   0229 DD          	push bl
0536   022A 30          	mov bl, bh
0537   022B 07 70 03    	call itoa				; convert bh to char in A
0538   022E 2F          	mov bl, al				; save al	
0539   022F 19 01       	mov al, 1
0540   0231 05 02       	syscall bios_uart				; display AH
0541   0233 24          	mov ah, bl				; retrieve al
0542   0234 19 01       	mov al, 1
0543   0236 05 02       	syscall bios_uart				; display AL
0544   0238             
0545   0238 EA          	pop bl
0546   0239 07 70 03    	call itoa				; convert bh to char in A
0547   023C 2F          	mov bl, al				; save al
0548   023D 19 01       	mov al, 1
0549   023F 05 02       	syscall bios_uart				; display AH
0550   0241 24          	mov ah, bl				; retrieve al
0551   0242 19 01       	mov al, 1
0552   0244 05 02       	syscall bios_uart				; display AL
0553   0246             
0554   0246 E5          	pop b
0555   0247 E4          	pop a
0556   0248 EE          	popf
0557   0249 09          	ret
0558   024A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0559   024A             ; INPUT 16BIT HEX INTEGER
0560   024A             ; read 16bit integer into A
0561   024A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562   024A             SCAN_U16X:
0563   024A F8 10 00    	enter 16
0564   024D E1          	pushf
0565   024E D8          	push b
0566   024F DA          	push d
0567   0250             
0568   0250 FA F1 FF    	lea d, [bp + -15]
0569   0253 07 F5 02    	call getse				; get number
0570   0256             
0571   0256 32          	mov bl, [d]
0572   0257 37          	mov bh, bl
0573   0258 33 01 00    	mov bl, [d + 1]
0574   025B 07 5E 03    	call atoi				; convert to int in AL
0575   025E 23          	mov ah, al				; move to AH
0576   025F             	
0577   025F 33 02 00    	mov bl, [d + 2]
0578   0262 37          	mov bh, bl
0579   0263 33 03 00    	mov bl, [d + 3]
0580   0266 07 5E 03    	call atoi				; convert to int in AL
0581   0269             	
0582   0269 E7          	pop d	
0583   026A E5          	pop b
0584   026B EE          	popf
0585   026C F9          	leave
0586   026D 09          	ret
0587   026E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0588   026E             ; PRINT 8BIT HEX INTEGER
0589   026E             ; byte value in reg BL
0590   026E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0591   026E             XPUT_U8:
0592   026E D7          	push a
0593   026F DD          	push bl
0594   0270 E1          	pushf
0595   0271             
0596   0271 07 70 03    	call itoa					; convert bl to char in A
0597   0274 2F          	mov bl, al					; save al	
0598   0275 19 01       	mov al, 1
0599   0277 05 02       	syscall bios_uart				; display AH
0600   0279 24          	mov ah, bl					; retrieve al
0601   027A 19 01       	mov al, 1
0602   027C 05 02       	syscall bios_uart				; display AL
0603   027E             	
0604   027E EE          	popf
0605   027F EA          	pop bl
0606   0280 E4          	pop a
0607   0281 09          	ret
0608   0282             
0609   0282             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0610   0282             ; PRINT NULL TERMINATED STRING
0611   0282             ; pointer in D
0612   0282             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0613   0282             puts:
0614   0282 D7          	push a
0615   0283 DA          	push d
0616   0284 E1          	pushf
0617   0285             puts_L1:
0618   0285 1E          	mov al, [d]
0619   0286 B9 00       	cmp al, 0
0620   0288 C6 9B 02    	jz puts_end
0621   028B             puts_L2:
0622   028B 1D 85 FF    	mov al, [_UART0_LSR]			; read Line Status Register
0623   028E 93 20       	test al, $20					; isolate Transmitter Empty
0624   0290 C6 8B 02    	jz puts_L2		
0625   0293 1E          	mov al, [d]
0626   0294 3D 80 FF    	mov [_UART0_DATA], al			; write char to Transmitter Holding Register
0627   0297 79          	inc d	
0628   0298 0A 85 02    	jmp puts_L1
0629   029B             puts_end:
0630   029B EE          	popf
0631   029C E7          	pop d
0632   029D E4          	pop a
0633   029E 09          	ret
0634   029F             
0635   029F             
0636   029F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0637   029F             ; putchar
0638   029F             ; char in ah
0639   029F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0640   029F             putchar:
0641   029F D7          	push a
0642   02A0 E1          	pushf
0643   02A1             putchar_L1:
0644   02A1 1D 85 FF    	mov al, [_UART0_LSR]			; read Line Status Register
0645   02A4 93 20       	test al, 20h					; isolate Transmitter Empty
0646   02A6 C6 A1 02    	jz putchar_L1		
0647   02A9 1A          	mov al, ah
0648   02AA 3D 80 FF    	mov [_UART0_DATA], al			; write char to Transmitter Holding Register
0649   02AD EE          	popf
0650   02AE E4          	pop a
0651   02AF 09          	ret
0652   02B0             	
0653   02B0             	
0654   02B0             	
0655   02B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0656   02B0             ;; INPUT A STRING with no echo
0657   02B0             ;; terminates with null
0658   02B0             ;; pointer in D
0659   02B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0660   02B0             gets:
0661   02B0 E1          	pushf
0662   02B1 D7          	push a
0663   02B2 DA          	push d
0664   02B3             gets_loop:
0665   02B3 19 02       	mov al, 2
0666   02B5 05 02       	syscall bios_uart			; receive in AH
0667   02B7 76 0A       	cmp ah, 0Ah				; LF
0668   02B9 C6 EE 02    	je gets_end
0669   02BC 76 0D       	cmp ah, 0Dh				; CR
0670   02BE C6 EE 02    	je gets_end
0671   02C1 76 5C       	cmp ah, $5C				; '\\'
0672   02C3 C6 CC 02    	je gets_escape
0673   02C6 1A          	mov al, ah
0674   02C7 3E          	mov [d], al
0675   02C8 79          	inc d
0676   02C9 0A B3 02    	jmp gets_loop
0677   02CC             gets_escape:
0678   02CC 19 02       	mov al, 2
0679   02CE 05 02       	syscall bios_uart			; receive in AH
0680   02D0 76 6E       	cmp ah, 'n'
0681   02D2 C6 E0 02    	je gets_LF
0682   02D5 76 72       	cmp ah, 'r'
0683   02D7 C6 E7 02    	je gets_CR
0684   02DA 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0685   02DB 3E          	mov [d], al
0686   02DC 79          	inc d
0687   02DD 0A B3 02    	jmp gets_loop
0688   02E0             gets_LF:
0689   02E0 19 0A       	mov al, $0A
0690   02E2 3E          	mov [d], al
0691   02E3 79          	inc d
0692   02E4 0A B3 02    	jmp gets_loop
0693   02E7             gets_CR:
0694   02E7 19 0D       	mov al, $0D
0695   02E9 3E          	mov [d], al
0696   02EA 79          	inc d
0697   02EB 0A B3 02    	jmp gets_loop
0698   02EE             gets_end:
0699   02EE 19 00       	mov al, 0
0700   02F0 3E          	mov [d], al				; terminate string
0701   02F1 E7          	pop d
0702   02F2 E4          	pop a
0703   02F3 EE          	popf
0704   02F4 09          	ret
0705   02F5             
0706   02F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0707   02F5             ;; INPUT A STRING with echo
0708   02F5             ;; terminates with null
0709   02F5             ;; pointer in D
0710   02F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0711   02F5             getse:
0712   02F5 E1          	pushf
0713   02F6 D7          	push a
0714   02F7 DA          	push d
0715   02F8             getse_loop:
0716   02F8 19 03       	mov al, 3
0717   02FA 05 02       	syscall bios_uart			; receive in AH
0718   02FC 76 0A       	cmp ah, 0Ah				; LF
0719   02FE C6 33 03    	je getse_end
0720   0301 76 0D       	cmp ah, 0Dh				; CR
0721   0303 C6 33 03    	je getse_end
0722   0306 76 5C       	cmp ah, $5C				; '\\'
0723   0308 C6 11 03    	je getse_escape
0724   030B 1A          	mov al, ah
0725   030C 3E          	mov [d], al
0726   030D 79          	inc d
0727   030E 0A F8 02    	jmp getse_loop
0728   0311             getse_escape:
0729   0311 19 03       	mov al, 3
0730   0313 05 02       	syscall bios_uart			; receive in AH
0731   0315 76 6E       	cmp ah, 'n'
0732   0317 C6 25 03    	je getse_LF
0733   031A 76 72       	cmp ah, 'r'
0734   031C C6 2C 03    	je getse_CR
0735   031F 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0736   0320 3E          	mov [d], al
0737   0321 79          	inc d
0738   0322 0A F8 02    	jmp getse_loop
0739   0325             getse_LF:
0740   0325 19 0A       	mov al, $0A
0741   0327 3E          	mov [d], al
0742   0328 79          	inc d
0743   0329 0A F8 02    	jmp getse_loop
0744   032C             getse_CR:
0745   032C 19 0D       	mov al, $0D
0746   032E 3E          	mov [d], al
0747   032F 79          	inc d
0748   0330 0A F8 02    	jmp getse_loop
0749   0333             getse_end:
0750   0333 19 00       	mov al, 0
0751   0335 3E          	mov [d], al				; terminate string
0752   0336 E7          	pop d
0753   0337 E4          	pop a
0754   0338 EE          	popf
0755   0339 09          	ret
0756   033A             
0757   033A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0758   033A             ; PRINT NEW LINE
0759   033A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0760   033A             put_nl:
0761   033A E1          	pushf
0762   033B D7          	push a
0763   033C 10 01 0A    	mov a, $0A01
0764   033F 05 02       	syscall bios_uart
0765   0341 10 01 0D    	mov a, $0D01
0766   0344 05 02       	syscall bios_uart
0767   0346 E4          	pop a
0768   0347 EE          	popf
0769   0348 09          	ret
0770   0349             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0771   0349             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0772   0349             ; ASCII in BL
0773   0349             ; result in AL
0774   0349             ; ascii for F = 0100 0110
0775   0349             ; ascii for 9 = 0011 1001
0776   0349             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0777   0349             hex_ascii_encode:
0778   0349 1B          	mov al, bl	
0779   034A 93 40       	test al, 40h				; test if letter or number
0780   034C C7 52 03    	jnz hex_letter
0781   034F 87 0F       	and al, 0Fh				; get number
0782   0351 09          	ret
0783   0352             hex_letter:
0784   0352 DC          	push ah
0785   0353 24          	mov ah, bl
0786   0354 07 AD 03    	call to_upper
0787   0357 1A          	mov al, ah	
0788   0358 87 0F       	and al, 0Fh				; get letter
0789   035A 6A 09       	add al, 9
0790   035C E9          	pop ah
0791   035D 09          	ret
0792   035E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0793   035E             ; ATOI
0794   035E             ; 2 letter hex string in B
0795   035E             ; 8bit integer returned in AL
0796   035E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0797   035E             atoi:
0798   035E E1          	pushf
0799   035F D8          	push b
0800   0360             		
0801   0360 07 49 03    	call hex_ascii_encode			; convert BL to 4bit code in AL
0802   0363 30          	mov bl, bh
0803   0364 DB          	push al					; save a
0804   0365 07 49 03    	call hex_ascii_encode
0805   0368 EA          	pop bl	
0806   0369 FD 9E 04    	shl al, 4
0807   036C 8C          	or al, bl
0808   036D             	
0809   036D E5          	pop b
0810   036E EE          	popf
0811   036F 09          	ret	
0812   0370             
0813   0370             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0814   0370             ; ITOA
0815   0370             ; 8bit value in BL
0816   0370             ; 2 byte ASCII result in A
0817   0370             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0818   0370             itoa:
0819   0370 E1          	pushf
0820   0371 DA          	push d
0821   0372 DE          	push	bh
0822   0373 DD          	push bl
0823   0374             
0824   0374 A7 00       	mov bh, 0
0825   0376             	
0826   0376 FD 87 0F    	and 	bl, $0F
0827   0379 3B 8C 05    	mov 	d, s_hex_digits
0828   037C 5A          	add 	d, b
0829   037D 1E          	mov 	al, [d]				; get ASCII
0830   037E EA          	pop 	bl
0831   037F 52 01 00    	sub sp, 1				; push bl back
0832   0382 DB          	push al
0833   0383             	
0834   0383 FD 87 F0    	and 	bl, $F0
0835   0386 FD A4 04    	shr 	bl, 4
0836   0389 3B 8C 05    	mov 	d, s_hex_digits
0837   038C 5A          	add 	d, b
0838   038D 1E          	mov 	al, [d]				; get ASCII
0839   038E             
0840   038E 23          	mov ah, al
0841   038F E8          	pop 	al	
0842   0390             	
0843   0390 EA          	pop 	bl
0844   0391 EB          	pop bh
0845   0392 E7          	pop 	d
0846   0393 EE          	popf
0847   0394 09          	ret
0848   0395             
0849   0395             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0850   0395             ; STRCMP
0851   0395             ; compare two strings
0852   0395             ; str1 in SI
0853   0395             ; str2 in DI
0854   0395             ; changes: AL SI DI
0855   0395             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0856   0395             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0857   0395             strcmp:
0858   0395             strcmp_loop:
0859   0395 F3          	cmpsb					; compare a byte of the strings
0860   0396 C7 A2 03    	jne strcmp_ret
0861   0399 FB FF FF    	lea d, [si + -1]
0862   039C 1E          	mov al, [d]
0863   039D B9 00       	cmp al, 0				; check if at end of string (null)
0864   039F C7 95 03    	jne strcmp_loop				; equal chars but not at end
0865   03A2             strcmp_ret:				
0866   03A2 09          	ret
0867   03A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0868   03A3             ; TO LOWER
0869   03A3             ; input in AL
0870   03A3             ; output in AL
0871   03A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0872   03A3             to_lower:
0873   03A3 E1          	pushf
0874   03A4 B9 5A       	cmp al, 'Z'
0875   03A6 D1 AB 03    	jgu to_lower_ret
0876   03A9 6A 20       	add al, 20h				; convert to lower case
0877   03AB             to_lower_ret:
0878   03AB EE          	popf
0879   03AC 09          	ret
0880   03AD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0881   03AD             ; TO UPPER
0882   03AD             ; input in AL
0883   03AD             ; output in AL
0884   03AD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0885   03AD             to_upper:
0886   03AD E1          	pushf
0887   03AE B9 61       	cmp al, 'a'
0888   03B0 C8 B5 03    	jlu to_upper_ret
0889   03B3 6F 20       	sub al, 20h				; convert to upper case
0890   03B5             to_upper_ret:
0891   03B5 EE          	popf
0892   03B6 09          	ret
0893   03B7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0894   03B7             ; PRINT DECIMAL INTEGER
0895   03B7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0896   03B7             print_decimal:
0897   03B7 09          	ret
0898   03B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0899   03B8             ; GET HEX FILE
0900   03B8             ; di = destination address
0901   03B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0902   03B8             load_hex:
0903   03B8 F8 00 60    	enter $6000
0904   03BB             	
0905   03BB 10 00 90    	mov a, $9000					; destination
0906   03BE 4F          	mov di, a	
0907   03BF             						; string data block
0908   03BF FA 01 A0    	lea d, [bp + -24575]			; start of string data block
0909   03C2 07 F5 02    	call getse					; get program string
0910   03C5 13          	mov a, d
0911   03C6 4D          	mov si, a
0912   03C7             load_hex_loop:
0913   03C7 F6          	lodsb					; load from [SI] to AL
0914   03C8 B9 00       	cmp al, 0				; check if ASCII 0
0915   03CA C6 D7 03    	jz load_hex_ret
0916   03CD 36          	mov bh, al
0917   03CE F6          	lodsb
0918   03CF 2F          	mov bl, al
0919   03D0 07 5E 03    	call atoi				; convert ASCII byte in B to int (to AL)
0920   03D3 F7          	stosb					; store AL to [DI]
0921   03D4 0A C7 03    	jmp load_hex_loop
0922   03D7             load_hex_ret:
0923   03D7 F9          	leave
0924   03D8 09          	ret
0925   03D9             
0926   03D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0927   03D9             ; HEX STRING TO BINARY
0928   03D9             ; di = destination address
0929   03D9             ; si = source
0930   03D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0931   03D9             hex_to_int:
0932   03D9             hex_to_int_L1:
0933   03D9 F6          	lodsb					; load from [SI] to AL
0934   03DA B9 00       	cmp al, 0				; check if ASCII 0
0935   03DC C6 E9 03    	jz hex_to_int_ret
0936   03DF 36          	mov bh, al
0937   03E0 F6          	lodsb
0938   03E1 2F          	mov bl, al
0939   03E2 07 5E 03    	call atoi				; convert ASCII byte in B to int (to AL)
0940   03E5 F7          	stosb					; store AL to [DI]
0941   03E6 0A D9 03    	jmp hex_to_int_L1
0942   03E9             hex_to_int_ret:
0943   03E9 09          	ret	
0944   03EA             		
0945   03EA             
0946   03EA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0947   03EA             ; DATA BLOCK
0948   03EA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0949   03EA 0A 0A 0D 53 s_welcome:		.db "\n\n\rSol-1 74HC HomebrewCPU MiniComputer\n"
0949   03EE 6F 6C 2D 31 
0949   03F2 20 37 34 48 
0949   03F6 43 20 48 6F 
0949   03FA 6D 65 62 72 
0949   03FE 65 77 43 50 
0949   0402 55 20 4D 69 
0949   0406 6E 69 43 6F 
0949   040A 6D 70 75 74 
0949   040E 65 72 0A 
0950   0411 42 49 4F 53 				.db "BIOS Version 0.1\n\n\r"
0950   0415 20 56 65 72 
0950   0419 73 69 6F 6E 
0950   041D 20 30 2E 31 
0950   0421 0A 0A 0D 
0951   0424 74 65 72 6D 				.db "terminal-1 initialized\n\r", 0
0951   0428 69 6E 61 6C 
0951   042C 2D 31 20 69 
0951   0430 6E 69 74 69 
0951   0434 61 6C 69 7A 
0951   0438 65 64 0A 0D 
0951   043C 00 
0952   043D             				
0953   043D 72 65 61 64 s_boot1:			.db "reading boot sector\n\r", 0
0953   0441 69 6E 67 20 
0953   0445 62 6F 6F 74 
0953   0449 20 73 65 63 
0953   044D 74 6F 72 0A 
0953   0451 0D 00 
0954   0453 62 6F 6F 74 s_boot2:			.db "boot-sector read\n\r", 0
0954   0457 2D 73 65 63 
0954   045B 74 6F 72 20 
0954   045F 72 65 61 64 
0954   0463 0A 0D 00 
0955   0466             
0956   0466             				
0957   0466 72 65 73 65 s_bios3: 		.db "resetting IDE-drive\n\r", 0
0957   046A 74 74 69 6E 
0957   046E 67 20 49 44 
0957   0472 45 2D 64 72 
0957   0476 69 76 65 0A 
0957   047A 0D 00 
0958   047C 63 6F 6E 66 s_bios4: 		.db "configuring Timer-1\n\r", 0
0958   0480 69 67 75 72 
0958   0484 69 6E 67 20 
0958   0488 54 69 6D 65 
0958   048C 72 2D 31 0A 
0958   0490 0D 00 
0959   0492 50 49 4F 2D s_bios5:	 		.db "PIO-A set to output mode\n\r", 0
0959   0496 41 20 73 65 
0959   049A 74 20 74 6F 
0959   049E 20 6F 75 74 
0959   04A2 70 75 74 20 
0959   04A6 6D 6F 64 65 
0959   04AA 0A 0D 00 
0960   04AD             
0961   04AD 65 6E 74 65 s_init:			.db "entering real-mode [supervisor on; paging off]\n\r"
0961   04B1 72 69 6E 67 
0961   04B5 20 72 65 61 
0961   04B9 6C 2D 6D 6F 
0961   04BD 64 65 20 5B 
0961   04C1 73 75 70 65 
0961   04C5 72 76 69 73 
0961   04C9 6F 72 20 6F 
0961   04CD 6E 3B 20 70 
0961   04D1 61 67 69 6E 
0961   04D5 67 20 6F 66 
0961   04D9 66 5D 0A 0D 
0962   04DD 69 6E 74 65 				.db "interrupts disabled\n\r"
0962   04E1 72 72 75 70 
0962   04E5 74 73 20 64 
0962   04E9 69 73 61 62 
0962   04ED 6C 65 64 0A 
0962   04F1 0D 
0963   04F2 64 69 73 70 				.db "display register loading enabled\n\r", 0
0963   04F6 6C 61 79 20 
0963   04FA 72 65 67 69 
0963   04FE 73 74 65 72 
0963   0502 20 6C 6F 61 
0963   0506 64 69 6E 67 
0963   050A 20 65 6E 61 
0963   050E 62 6C 65 64 
0963   0512 0A 0D 00 
0964   0515             
0965   0515 0A          s_nl_2:			.db "\n"
0966   0516 0A 0D 00    s_nl_1:			.db "\n\r", 0
0967   0519             
0968   0519 64 61 74 61 s_enter_prog:		.db "data: ", 0
0968   051D 3A 20 00 
0969   0520 6F 72 69 67 s_origin_addr:	.db "origin address: ", 0
0969   0524 69 6E 20 61 
0969   0528 64 64 72 65 
0969   052C 73 73 3A 20 
0969   0530 00 
0970   0531             
0971   0531 53 65 72 69 s_IDE_serial:		.db "Serial: ", 0
0971   0535 61 6C 3A 20 
0971   0539 00 
0972   053A 46 69 72 6D s_IDE_firm:		.db "Firmware: ", 0
0972   053E 77 61 72 65 
0972   0542 3A 20 00 
0973   0545 4D 6F 64 65 s_IDE_model:		.db "Model: ", 0
0973   0549 6C 3A 20 00 
0974   054D 4E 75 6D 62 s_sectors:		.db "Number of sectors: ", 0
0974   0551 65 72 20 6F 
0974   0555 66 20 73 65 
0974   0559 63 74 6F 72 
0974   055D 73 3A 20 00 
0975   0561 4C 42 41 20 s_LBA0:			.db "LBA 0: ", 0
0975   0565 30 3A 20 00 
0976   0569 4C 42 41 20 s_LBA1:			.db "LBA 1: ", 0
0976   056D 31 3A 20 00 
0977   0571 4C 42 41 20 s_LBA2:			.db "LBA 2: ", 0
0977   0575 32 3A 20 00 
0978   0579 4C 42 41 20 s_LBA3:			.db "LBA 3: ", 0
0978   057D 33 3A 20 00 
0979   0581 0A 0D 45 72 s_error:			.db "\n\rError.\n\r", 0
0979   0585 72 6F 72 2E 
0979   0589 0A 0D 00 
0980   058C             
0981   058C 30 31 32 33 s_hex_digits:		.db "0123456789ABCDEF"
0981   0590 34 35 36 37 
0981   0594 38 39 41 42 
0981   0598 43 44 45 46 
0982   059C 74 68 69 73 s_bkpt: 			.db "this is the breakpoint.", 0
0982   05A0 20 69 73 20 
0982   05A4 74 68 65 20 
0982   05A8 62 72 65 61 
0982   05AC 6B 70 6F 69 
0982   05B0 6E 74 2E 00 
0983   05B4             
0984   05B4             
0985   05B4 0A 0A 0D 73 s_priv1:			.db "\n\n\rsoftware failure: privilege exception "
0985   05B8 6F 66 74 77 
0985   05BC 61 72 65 20 
0985   05C0 66 61 69 6C 
0985   05C4 75 72 65 3A 
0985   05C8 20 70 72 69 
0985   05CC 76 69 6C 65 
0985   05D0 67 65 20 65 
0985   05D4 78 63 65 70 
0985   05D8 74 69 6F 6E 
0985   05DC 20 
0986   05DD 70 72 65 73 				.db "press any key to continue...\n\r", 0
0986   05E1 73 20 61 6E 
0986   05E5 79 20 6B 65 
0986   05E9 79 20 74 6F 
0986   05ED 20 63 6F 6E 
0986   05F1 74 69 6E 75 
0986   05F5 65 2E 2E 2E 
0986   05F9 0A 0D 00 
0987   05FC 0A 0D 65 78 s_divzero:		.db "\n\rexception: zero division\n\r", 0
0987   0600 63 65 70 74 
0987   0604 69 6F 6E 3A 
0987   0608 20 7A 65 72 
0987   060C 6F 20 64 69 
0987   0610 76 69 73 69 
0987   0614 6F 6E 0A 0D 
0987   0618 00 
0988   0619             
0989   0619             
0990   0619             
0991   0619             
0992   0619             
0993   0619             
0994   0619             .end
tasm: Number of errors = 0
