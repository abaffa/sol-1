0001   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002   0000             ; sol-1 assembler
0003   0000             ;
0004   0000             ; label1:
0005   0000             ; mov a, $FF
0006   0000             ; mov b, 21
0007   0000             ; mov a, b
0008   0000             ; mov a, label2
0009   0000             ; jmp label2
0010   0000             ; mov a, 1
0011   0000             ; mov b, 22
0012   0000             ; label2:
0013   0000             ; mov b, a
0014   0000             ; jmp label1
0015   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016   0000             .include "kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0017   0000             
0018   0400             .org PROC_TEXT_ORG			; origin at 1024
0019   0400             
0020   0400             asm_main:
0021   0400 FD 47 FF FF 	mov sp, $FFFF
0022   0404 FD 49 FF FF 	mov bp, $FFFF
0023   0408             
0024   0408 10 D9 0B    	mov a, program_buffer
0025   040B 42 D5 0A    	mov [prog], a
0026   040E             pre_scan:
0027   040E 07 36 09    	call get_token
0028   0411 1D D8 0A    	mov al, [tok]
0029   0414 B9 14       	cmp al, TOK_END
0030   0416 C6 38 04    	je pre_scan_end
0031   0419 14 D5 0A    	mov a, [prog]
0032   041C 3C          	mov d, a
0033   041D 1E          	mov al, [d]
0034   041E B9 3A       	cmp al, $3A 
0035   0420 C6 29 04    	je pre_scan_is_label
0036   0423 07 3A 04    	call find_EOL
0037   0426 0A 0E 04    	jmp pre_scan
0038   0429             pre_scan_is_label:
0039   0429 3B D9 0A    	mov d, tokstr
0040   042C 07 D6 06    	call puts
0041   042F 07 83 06    	call printnl
0042   0432 07 36 09    	call get_token
0043   0435 0A 0E 04    	jmp pre_scan
0044   0438             pre_scan_end:
0045   0438 05 0B       	syscall sys_terminate_proc
0046   043A             
0047   043A             find_EOL:
0048   043A 14 D5 0A    	mov a, [prog]
0049   043D 4D          	mov si, a
0050   043E             find_EOL_L0:
0051   043E F6          	lodsb
0052   043F B9 0A       	cmp al, $0A
0053   0441 C7 3E 04    	jne find_EOL_L0
0054   0444 4E          	mov a, si
0055   0445 42 D5 0A    	mov [prog], a
0056   0448 09          	ret
0057   0449             
0058   0449             mnemonic_tab:
0059   0449 6D 6F 76 20 	.db "mov a, @", 0
0059   044D 61 2C 20 40 
0059   0451 00 
0060   0452 6D 6F 76 20 	.db "mov a, b", 0
0060   0456 61 2C 20 62 
0060   045A 00 
0061   045B             
0062   045B 6D 6F 76 20 	.db "mov b, @", 0
0062   045F 62 2C 20 40 
0062   0463 00 
0063   0464 6D 6F 76 20 	.db "mov b, a", 0
0063   0468 62 2C 20 61 
0063   046C 00 
0064   046D             
0065   046D 6A 6D 70 20 	.db "jmp @", 0
0065   0471 40 00 
0066   0473 6A 6D 70 20 	.db "jmp a", 0
0066   0477 61 00 
0067   0479             
0068   0479 00          	.db 0
0069   047A             
0070   047A             instr_length_tab:
0071   047A 03          	.db 3
0072   047B 01          	.db 1
0073   047C             
0074   047C 03          	.db 3
0075   047D 01          	.db 1
0076   047E             	
0077   047E 03          	.db 3
0078   047F 01          	.db 1
0079   0480             
0080   0480             opcode_tab:
0081   0480 31 30 00    	.db "10", 0
0082   0483 31 31 00    	.db "11", 0
0083   0486             
0084   0486 32 36 00    	.db "26", 0
0085   0489 32 37 00    	.db "27", 0
0086   048C             
0087   048C 30 41 00    	.db "0A", 0
0088   048F 30 42 00    	.db "0B", 0
0089   0492             
0090   0492             .include "stdio.asm"
0001+  0492             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0492             ; stdio.s
0003+  0492             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0492             .include "string.asm"
0001++ 0492             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0492             ; string.s
0003++ 0492             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0492             
0005++ 0492             
0006++ 0492             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0492             ; strrev
0008++ 0492             ; reverse a string
0009++ 0492             ; D = string address
0010++ 0492             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0492             ; 01234
0012++ 0492             strrev:
0013++ 0492 4B          	pusha
0014++ 0493 07 D9 04    	call strlen	; length in C
0015++ 0496 12          	mov a, c
0016++ 0497 AF 01 00    	cmp a, 1
0017++ 049A D0 B4 04    	jleu strrev_end	; check string length. string len must be > 1
0018++ 049D 7D          	dec a
0019++ 049E FD 4E       	mov si, d	; beginning of string
0020++ 04A0 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 04A2 59          	add d, a	; end of string
0022++ 04A3 12          	mov a, c
0023++ 04A4 FD 9B       	shr a		; divide by 2
0024++ 04A6 39          	mov c, a	; C now counts the steps
0025++ 04A7             strrev_L0:
0026++ 04A7 32          	mov bl, [d]	; save load right-side char into BL
0027++ 04A8 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 04A9 3E          	mov [d], al	; store left char into right side
0029++ 04AA 1B          	mov al, bl
0030++ 04AB F7          	stosb		; store right-side char into left-side; increase DI
0031++ 04AC 7E          	dec c
0032++ 04AD 7F          	dec d
0033++ 04AE C2 00 00    	cmp c, 0
0034++ 04B1 C7 A7 04    	jne strrev_L0
0035++ 04B4             strrev_end:
0036++ 04B4 4C          	popa
0037++ 04B5 09          	ret
0038++ 04B6             	
0039++ 04B6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 04B6             ; strchr
0041++ 04B6             ; search string in D for char in AL
0042++ 04B6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 04B6             strchr:
0044++ 04B6             strchr_L0:
0045++ 04B6 32          	mov bl, [d]
0046++ 04B7 C1 00       	cmp bl, 0
0047++ 04B9 C6 C4 04    	je strchr_end
0048++ 04BC BA          	cmp al, bl
0049++ 04BD C6 C4 04    	je strchr_end
0050++ 04C0 79          	inc d
0051++ 04C1 0A B6 04    	jmp strchr_L0
0052++ 04C4             strchr_end:
0053++ 04C4 1B          	mov al, bl
0054++ 04C5 09          	ret
0055++ 04C6             
0056++ 04C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 04C6             ; strstr
0058++ 04C6             ; find sub-string
0059++ 04C6             ; str1 in SI
0060++ 04C6             ; str2 in DI
0061++ 04C6             ; SI points to end of source string
0062++ 04C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 04C6             strstr:
0064++ 04C6 DB          	push al
0065++ 04C7 DA          	push d
0066++ 04C8 E3          	push di
0067++ 04C9             strstr_loop:
0068++ 04C9 F3          	cmpsb					; compare a byte of the strings
0069++ 04CA C7 D5 04    	jne strstr_ret
0070++ 04CD FC 00 00    	lea d, [di + 0]
0071++ 04D0 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 04D2 C7 C9 04    	jne strstr_loop				; equal chars but not at end
0073++ 04D5             strstr_ret:
0074++ 04D5 F0          	pop di
0075++ 04D6 E7          	pop d
0076++ 04D7 E8          	pop al
0077++ 04D8 09          	ret
0078++ 04D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 04D9             ; length of null terminated string
0080++ 04D9             ; result in C
0081++ 04D9             ; pointer in D
0082++ 04D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 04D9             strlen:
0084++ 04D9 DA          	push d
0085++ 04DA 38 00 00    	mov c, 0
0086++ 04DD             strlen_L1:
0087++ 04DD BD 00       	cmp byte [d], 0
0088++ 04DF C6 E7 04    	je strlen_ret
0089++ 04E2 79          	inc d
0090++ 04E3 78          	inc c
0091++ 04E4 0A DD 04    	jmp strlen_L1
0092++ 04E7             strlen_ret:
0093++ 04E7 E7          	pop d
0094++ 04E8 09          	ret
0095++ 04E9             
0096++ 04E9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 04E9             ; STRCMP
0098++ 04E9             ; compare two strings
0099++ 04E9             ; str1 in SI
0100++ 04E9             ; str2 in DI
0101++ 04E9             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 04E9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 04E9             strcmp:
0104++ 04E9 DB          	push al
0105++ 04EA DA          	push d
0106++ 04EB E3          	push di
0107++ 04EC E2          	push si
0108++ 04ED             strcmp_loop:
0109++ 04ED F3          	cmpsb					; compare a byte of the strings
0110++ 04EE C7 F9 04    	jne strcmp_ret
0111++ 04F1 FB FF FF    	lea d, [si +- 1]
0112++ 04F4 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 04F6 C7 ED 04    	jne strcmp_loop				; equal chars but not at end
0114++ 04F9             strcmp_ret:
0115++ 04F9 EF          	pop si
0116++ 04FA F0          	pop di
0117++ 04FB E7          	pop d
0118++ 04FC E8          	pop al
0119++ 04FD 09          	ret
0120++ 04FE             
0121++ 04FE             
0122++ 04FE             ; STRCPY
0123++ 04FE             ; copy null terminated string from SI to DI
0124++ 04FE             ; source in SI
0125++ 04FE             ; destination in DI
0126++ 04FE             strcpy:
0127++ 04FE E2          	push si
0128++ 04FF E3          	push di
0129++ 0500 DB          	push al
0130++ 0501             strcpy_L1:
0131++ 0501 F6          	lodsb
0132++ 0502 F7          	stosb
0133++ 0503 B9 00       	cmp al, 0
0134++ 0505 C7 01 05    	jne strcpy_L1
0135++ 0508             strcpy_end:
0136++ 0508 E8          	pop al
0137++ 0509 F0          	pop di
0138++ 050A EF          	pop si
0139++ 050B 09          	ret
0140++ 050C             
0141++ 050C             ; STRCAT
0142++ 050C             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 050C             ; source in SI
0144++ 050C             ; destination in DI
0145++ 050C             strcat:
0146++ 050C E2          	push si
0147++ 050D E3          	push di
0148++ 050E D7          	push a
0149++ 050F DA          	push d
0150++ 0510 50          	mov a, di
0151++ 0511 3C          	mov d, a
0152++ 0512             strcat_goto_end_L1:
0153++ 0512 BD 00       	cmp byte[d], 0
0154++ 0514 C6 1B 05    	je strcat_start
0155++ 0517 79          	inc d
0156++ 0518 0A 12 05    	jmp strcat_goto_end_L1
0157++ 051B             strcat_start:
0158++ 051B FD 50       	mov di, d
0159++ 051D             strcat_L1:
0160++ 051D F6          	lodsb
0161++ 051E F7          	stosb
0162++ 051F B9 00       	cmp al, 0
0163++ 0521 C7 1D 05    	jne strcat_L1
0164++ 0524             strcat_end:
0165++ 0524 E7          	pop d
0166++ 0525 E4          	pop a
0167++ 0526 F0          	pop di
0168++ 0527 EF          	pop si
0169++ 0528 09          	ret
0005+  0529             
0006+  0529 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  052D 34 35 36 37 
0006+  0531 38 39 41 42 
0006+  0535 43 44 45 46 
0007+  0539             
0008+  0539 01 00       table_power:.dw 1
0009+  053B 0A 00       			.dw 10
0010+  053D 64 00       			.dw 100
0011+  053F E8 03       			.dw 1000
0012+  0541 10 27       			.dw 10000
0013+  0543             
0014+  0543             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0015+  0543             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0016+  0543             ; ASCII in BL
0017+  0543             ; result in AL
0018+  0543             ; ascii for F = 0100 0110
0019+  0543             ; ascii for 9 = 0011 1001
0020+  0543             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0021+  0543             hex_ascii_encode:
0022+  0543 1B          	mov al, bl
0023+  0544 93 40       	test al, $40				; test if letter or number
0024+  0546 C7 4C 05    	jnz hex_letter
0025+  0549 87 0F       	and al, $0F				; get number
0026+  054B 09          	ret
0027+  054C             hex_letter:
0028+  054C 87 0F       	and al, $0F				; get letter
0029+  054E 6A 09       	add al, 9
0030+  0550 09          	ret
0031+  0551             
0032+  0551             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0033+  0551             ; ATOI
0034+  0551             ; 2 letter hex string in B
0035+  0551             ; 8bit integer returned in AL
0036+  0551             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0037+  0551             atoi:
0038+  0551 D8          	push b
0039+  0552 07 43 05    	call hex_ascii_encode			; convert BL to 4bit code in AL
0040+  0555 30          	mov bl, bh
0041+  0556 DB          	push al					; save a
0042+  0557 07 43 05    	call hex_ascii_encode
0043+  055A EA          	pop bl	
0044+  055B FD 9E 04    	shl al, 4
0045+  055E 8C          	or al, bl
0046+  055F E5          	pop b
0047+  0560 09          	ret	
0048+  0561             
0049+  0561             
0050+  0561             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  0561             ; printf
0052+  0561             ; no need for explanations!
0053+  0561             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0054+  0561             printf:
0055+  0561 09          	ret
0056+  0562             
0057+  0562             
0058+  0562             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  0562             ; scanf
0060+  0562             ; no need for explanations!
0061+  0562             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  0562             scanf:
0063+  0562 09          	ret
0064+  0563             
0065+  0563             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  0563             ; ITOA
0067+  0563             ; 8bit value in BL
0068+  0563             ; 2 byte ASCII result in A
0069+  0563             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0070+  0563             itoa:
0071+  0563 DA          	push d
0072+  0564 D8          	push b
0073+  0565 A7 00       	mov bh, 0
0074+  0567 FD A4 04    	shr bl, 4	
0075+  056A 74          	mov d, b
0076+  056B 1F 29 05    	mov al, [d + s_hex_digits]
0077+  056E 23          	mov ah, al
0078+  056F             	
0079+  056F E5          	pop b
0080+  0570 D8          	push b
0081+  0571 A7 00       	mov bh, 0
0082+  0573 FD 87 0F    	and bl, $0F
0083+  0576 74          	mov d, b
0084+  0577 1F 29 05    	mov al, [d + s_hex_digits]
0085+  057A E5          	pop b
0086+  057B E7          	pop d
0087+  057C 09          	ret
0088+  057D             
0089+  057D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0090+  057D             ; HEX STRING TO BINARY
0091+  057D             ; di = destination address
0092+  057D             ; si = source
0093+  057D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0094+  057D             hex_to_int:
0095+  057D             hex_to_int_L1:
0096+  057D F6          	lodsb					; load from [SI] to AL
0097+  057E B9 00       	cmp al, 0				; check if ASCII 0
0098+  0580 C6 8D 05    	jz hex_to_int_ret
0099+  0583 36          	mov bh, al
0100+  0584 F6          	lodsb
0101+  0585 2F          	mov bl, al
0102+  0586 07 51 05    	call atoi				; convert ASCII byte in B to int (to AL)
0103+  0589 F7          	stosb					; store AL to [DI]
0104+  058A 0A 7D 05    	jmp hex_to_int_L1
0105+  058D             hex_to_int_ret:
0106+  058D 09          	ret		
0107+  058E             
0108+  058E             
0109+  058E             
0110+  058E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  058E             ; GETCHAR
0112+  058E             ; char in ah
0113+  058E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0114+  058E             getchar:
0115+  058E DB          	push al
0116+  058F             getchar_retry:
0117+  058F FD 0C       	sti
0118+  0591 19 01       	mov al, 1
0119+  0593 05 03       	syscall sys_io			; receive in AH
0120+  0595 B9 00       	cmp al, 0			; check if any char was receive
0121+  0597 C6 8F 05    	je getchar_retry
0122+  059A E8          	pop al
0123+  059B 09          	ret
0124+  059C             
0125+  059C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0126+  059C             ; PUTCHAR
0127+  059C             ; char in ah
0128+  059C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  059C             putchar:
0130+  059C D7          	push a
0131+  059D 19 00       	mov al, 0
0132+  059F 05 03       	syscall sys_io			; char in AH
0133+  05A1 E4          	pop a
0134+  05A2 09          	ret
0135+  05A3             
0136+  05A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0137+  05A3             ;; INPUT A STRING
0138+  05A3             ;; terminates with null
0139+  05A3             ;; pointer in D
0140+  05A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  05A3             gets:
0142+  05A3 D7          	push a
0143+  05A4 DA          	push d
0144+  05A5             gets_loop:
0145+  05A5 FD 0C       	sti
0146+  05A7 19 01       	mov al, 1
0147+  05A9 05 03       	syscall sys_io			; receive in AH
0148+  05AB B9 00       	cmp al, 0				; check error code (AL)
0149+  05AD C6 A5 05    	je gets_loop			; if no char received, retry
0150+  05B0             
0151+  05B0 76 1B       	cmp ah, 27
0152+  05B2 C6 D3 05    	je gets_telnet_escape
0153+  05B5 76 0A       	cmp ah, $0A				; LF
0154+  05B7 C6 2C 06    	je gets_end
0155+  05BA 76 0D       	cmp ah, $0D				; CR
0156+  05BC C6 2C 06    	je gets_end
0157+  05BF 76 5C       	cmp ah, $5C				; '\\'
0158+  05C1 C6 03 06    	je gets_escape
0159+  05C4             	
0160+  05C4 76 08       	cmp ah, $08			; check for backspace
0161+  05C6 C6 CF 05    	je gets_backspace
0162+  05C9             
0163+  05C9 1A          	mov al, ah
0164+  05CA 3E          	mov [d], al
0165+  05CB 79          	inc d
0166+  05CC 0A A5 05    	jmp gets_loop
0167+  05CF             gets_backspace:
0168+  05CF 7F          	dec d
0169+  05D0 0A A5 05    	jmp gets_loop
0170+  05D3             gets_telnet_escape:
0171+  05D3 FD 0C       	sti
0172+  05D5 19 01       	mov al, 1
0173+  05D7 05 03       	syscall sys_io				; receive in AH without echo
0174+  05D9 B9 00       	cmp al, 0					; check error code (AL)
0175+  05DB C6 D3 05    	je gets_telnet_escape		; if no char received, retry
0176+  05DE 76 5B       	cmp ah, '['
0177+  05E0 C7 A5 05    	jne gets_loop
0178+  05E3             gets_telnet_escape_phase2:
0179+  05E3 FD 0C       	sti
0180+  05E5 19 01       	mov al, 1
0181+  05E7 05 03       	syscall sys_io					; receive in AH without echo
0182+  05E9 B9 00       	cmp al, 0						; check error code (AL)
0183+  05EB C6 E3 05    	je gets_telnet_escape_phase2	; if no char received, retry
0184+  05EE 76 44       	cmp ah, 'D'
0185+  05F0 C6 FB 05    	je gets_left_arrow
0186+  05F3 76 43       	cmp ah, 'C'
0187+  05F5 C6 FF 05    	je gets_right_arrow
0188+  05F8 0A A5 05    	jmp gets_loop
0189+  05FB             gets_left_arrow:
0190+  05FB 7F          	dec d
0191+  05FC 0A A5 05    	jmp gets_loop
0192+  05FF             gets_right_arrow:
0193+  05FF 79          	inc d
0194+  0600 0A A5 05    	jmp gets_loop
0195+  0603             gets_escape:
0196+  0603 FD 0C       	sti
0197+  0605 19 01       	mov al, 1
0198+  0607 05 03       	syscall sys_io			; receive in AH
0199+  0609 B9 00       	cmp al, 0				; check error code (AL)
0200+  060B C6 03 06    	je gets_escape			; if no char received, retry
0201+  060E 76 6E       	cmp ah, 'n'
0202+  0610 C6 1E 06    	je gets_LF
0203+  0613 76 72       	cmp ah, 'r'
0204+  0615 C6 25 06    	je gets_CR
0205+  0618 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0206+  0619 3E          	mov [d], al
0207+  061A 79          	inc d
0208+  061B 0A A5 05    	jmp gets_loop
0209+  061E             gets_LF:
0210+  061E 19 0A       	mov al, $0A
0211+  0620 3E          	mov [d], al
0212+  0621 79          	inc d
0213+  0622 0A A5 05    	jmp gets_loop
0214+  0625             gets_CR:
0215+  0625 19 0D       	mov al, $0D
0216+  0627 3E          	mov [d], al
0217+  0628 79          	inc d
0218+  0629 0A A5 05    	jmp gets_loop
0219+  062C             gets_end:
0220+  062C 19 00       	mov al, 0
0221+  062E 3E          	mov [d], al				; terminate string
0222+  062F E7          	pop d
0223+  0630 E4          	pop a
0224+  0631 09          	ret
0225+  0632             
0226+  0632             
0227+  0632             
0228+  0632             
0229+  0632             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0230+  0632             ;; INPUT TEXT
0231+  0632             ;; terminated with CTRL+D
0232+  0632             ;; pointer in D
0233+  0632             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0234+  0632             gettxt:
0235+  0632 D7          	push a
0236+  0633 DA          	push d
0237+  0634             gettxt_loop:
0238+  0634 19 01       	mov al, 1
0239+  0636 05 03       	syscall sys_io			; receive in AH
0240+  0638 B9 00       	cmp al, 0				; check error code (AL)
0241+  063A C6 34 06    	je gettxt_loop		; if no char received, retry
0242+  063D 76 04       	cmp ah, 4			; EOT
0243+  063F C6 7D 06    	je gettxt_end
0244+  0642 76 08       	cmp ah, $08			; check for backspace
0245+  0644 C6 79 06    	je gettxt_backspace
0246+  0647 76 5C       	cmp ah, $5C				; '\\'
0247+  0649 C6 52 06    	je gettxt_escape
0248+  064C 1A          	mov al, ah
0249+  064D 3E          	mov [d], al
0250+  064E 79          	inc d
0251+  064F 0A 34 06    	jmp gettxt_loop
0252+  0652             gettxt_escape:
0253+  0652 19 01       	mov al, 1
0254+  0654 05 03       	syscall sys_io			; receive in AH
0255+  0656 B9 00       	cmp al, 0				; check error code (AL)
0256+  0658 C6 52 06    	je gettxt_escape		; if no char received, retry
0257+  065B 76 6E       	cmp ah, 'n'
0258+  065D C6 6B 06    	je gettxt_LF
0259+  0660 76 72       	cmp ah, 'r'
0260+  0662 C6 72 06    	je gettxt_CR
0261+  0665 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0262+  0666 3E          	mov [d], al
0263+  0667 79          	inc d
0264+  0668 0A 34 06    	jmp gettxt_loop
0265+  066B             gettxt_LF:
0266+  066B 19 0A       	mov al, $0A
0267+  066D 3E          	mov [d], al
0268+  066E 79          	inc d
0269+  066F 0A 34 06    	jmp gettxt_loop
0270+  0672             gettxt_CR:
0271+  0672 19 0D       	mov al, $0D
0272+  0674 3E          	mov [d], al
0273+  0675 79          	inc d
0274+  0676 0A 34 06    	jmp gettxt_loop
0275+  0679             gettxt_backspace:
0276+  0679 7F          	dec d
0277+  067A 0A 34 06    	jmp gettxt_loop
0278+  067D             gettxt_end:
0279+  067D 19 00       	mov al, 0
0280+  067F 3E          	mov [d], al				; terminate string
0281+  0680 E7          	pop d
0282+  0681 E4          	pop a
0283+  0682 09          	ret
0284+  0683             
0285+  0683             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0286+  0683             ; PRINT NEW LINE
0287+  0683             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  0683             printnl:
0289+  0683 D7          	push a
0290+  0684 10 00 0A    	mov a, $0A00
0291+  0687 05 03       	syscall sys_io
0292+  0689 10 00 0D    	mov a, $0D00
0293+  068C 05 03       	syscall sys_io
0294+  068E E4          	pop a
0295+  068F 09          	ret
0296+  0690             
0297+  0690             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0298+  0690             ; strtoint
0299+  0690             ; 4 digit hex string number in d
0300+  0690             ; integer returned in A
0301+  0690             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0302+  0690             strtointx:
0303+  0690 D8          	push b
0304+  0691 32          	mov bl, [d]
0305+  0692 37          	mov bh, bl
0306+  0693 33 01 00    	mov bl, [d + 1]
0307+  0696 07 51 05    	call atoi				; convert to int in AL
0308+  0699 23          	mov ah, al				; move to AH
0309+  069A 33 02 00    	mov bl, [d + 2]
0310+  069D 37          	mov bh, bl
0311+  069E 33 03 00    	mov bl, [d + 3]
0312+  06A1 07 51 05    	call atoi				; convert to int in AL
0313+  06A4 E5          	pop b
0314+  06A5 09          	ret
0315+  06A6             
0316+  06A6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0317+  06A6             ; strtoint
0318+  06A6             ; 5 digit base10 string number in d
0319+  06A6             ; integer returned in A
0320+  06A6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0321+  06A6             strtoint:
0322+  06A6 E2          	push si
0323+  06A7 D8          	push b
0324+  06A8 D9          	push c
0325+  06A9 DA          	push d
0326+  06AA 07 D9 04    	call strlen			; get string length in C
0327+  06AD 7E          	dec c
0328+  06AE FD 4E       	mov si, d
0329+  06B0 12          	mov a, c
0330+  06B1 FD 99       	shl a
0331+  06B3 3B 39 05    	mov d, table_power
0332+  06B6 59          	add d, a
0333+  06B7 38 00 00    	mov c, 0
0334+  06BA             strtoint_L0:
0335+  06BA F6          	lodsb			; load ASCII to al
0336+  06BB B9 00       	cmp al, 0
0337+  06BD C6 D0 06    	je strtoint_end
0338+  06C0 6F 30       	sub al, $30		; make into integer
0339+  06C2 22 00       	mov ah, 0
0340+  06C4 2A          	mov b, [d]
0341+  06C5 AC          	mul a, b			; result in B since it fits in 16bits
0342+  06C6 11          	mov a, b
0343+  06C7 28          	mov b, c
0344+  06C8 54          	add a, b
0345+  06C9 39          	mov c, a
0346+  06CA 63 02 00    	sub d, 2
0347+  06CD 0A BA 06    	jmp strtoint_L0
0348+  06D0             strtoint_end:
0349+  06D0 12          	mov a, c
0350+  06D1 E7          	pop d
0351+  06D2 E6          	pop c
0352+  06D3 E5          	pop b
0353+  06D4 EF          	pop si
0354+  06D5 09          	ret
0355+  06D6             
0356+  06D6             
0357+  06D6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0358+  06D6             ; PRINT NULL TERMINATED STRING
0359+  06D6             ; pointer in D
0360+  06D6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0361+  06D6             puts:
0362+  06D6 D7          	push a
0363+  06D7 DA          	push d
0364+  06D8             puts_L1:
0365+  06D8 1E          	mov al, [d]
0366+  06D9 B9 00       	cmp al, 0
0367+  06DB C6 E7 06    	jz puts_END
0368+  06DE 23          	mov ah, al
0369+  06DF 19 00       	mov al, 0
0370+  06E1 05 03       	syscall sys_io
0371+  06E3 79          	inc d
0372+  06E4 0A D8 06    	jmp puts_L1
0373+  06E7             puts_END:
0374+  06E7 E7          	pop d
0375+  06E8 E4          	pop a
0376+  06E9 09          	ret
0377+  06EA             
0378+  06EA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  06EA             ; PRINT N SIZE STRING
0380+  06EA             ; pointer in D
0381+  06EA             ; size in C
0382+  06EA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0383+  06EA             putsn:
0384+  06EA DB          	push al
0385+  06EB DA          	push d
0386+  06EC D9          	push c
0387+  06ED             putsn_L0:
0388+  06ED 1E          	mov al, [d]
0389+  06EE 23          	mov ah, al
0390+  06EF 19 00       	mov al, 0
0391+  06F1 05 03       	syscall sys_io
0392+  06F3 79          	inc d
0393+  06F4 7E          	dec c	
0394+  06F5 C2 00 00    	cmp c, 0
0395+  06F8 C7 ED 06    	jne putsn_L0
0396+  06FB             putsn_end:
0397+  06FB E6          	pop c
0398+  06FC E7          	pop d
0399+  06FD E8          	pop al
0400+  06FE 09          	ret
0401+  06FF             
0402+  06FF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0403+  06FF             ; print 16bit decimal number
0404+  06FF             ; input number in A
0405+  06FF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  06FF             print_u16d:
0407+  06FF D7          	push a
0408+  0700 D8          	push b
0409+  0701 26 10 27    	mov b, 10000
0410+  0704 AE          	div a, b			; get 10000 coeff.
0411+  0705 07 2B 07    	call print_number
0412+  0708 11          	mov a, b
0413+  0709 26 E8 03    	mov b, 1000
0414+  070C AE          	div a, b			; get 10000 coeff.
0415+  070D 07 2B 07    	call print_number
0416+  0710 11          	mov a, b
0417+  0711 26 64 00    	mov b, 100
0418+  0714 AE          	div a, b
0419+  0715 07 2B 07    	call print_number
0420+  0718 11          	mov a, b
0421+  0719 26 0A 00    	mov b, 10
0422+  071C AE          	div a, b
0423+  071D 07 2B 07    	call print_number
0424+  0720 11          	mov a, b
0425+  0721 6A 30       	add al, $30
0426+  0723 23          	mov ah, al
0427+  0724 19 00       	mov al, 0
0428+  0726 05 03       	syscall sys_io	; print coeff
0429+  0728 E5          	pop b
0430+  0729 E4          	pop a
0431+  072A 09          	ret
0432+  072B             
0433+  072B             
0434+  072B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0435+  072B             ; if A == 0, print space
0436+  072B             ; else print A
0437+  072B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0438+  072B             print_number:
0439+  072B 6A 30       	add al, $30
0440+  072D 23          	mov ah, al
0441+  072E 07 9C 05    	call putchar
0442+  0731 09          	ret
0443+  0732             
0444+  0732             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  0732             ; PRINT 16BIT HEX INTEGER
0446+  0732             ; integer value in reg B
0447+  0732             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  0732             print_u16x:
0449+  0732 D7          	push a
0450+  0733 D8          	push b
0451+  0734 DD          	push bl
0452+  0735 30          	mov bl, bh
0453+  0736 07 63 05    	call itoa				; convert bh to char in A
0454+  0739 2F          	mov bl, al				; save al
0455+  073A 19 00       	mov al, 0
0456+  073C 05 03       	syscall sys_io				; display AH
0457+  073E 24          	mov ah, bl				; retrieve al
0458+  073F 19 00       	mov al, 0
0459+  0741 05 03       	syscall sys_io				; display AL
0460+  0743             
0461+  0743 EA          	pop bl
0462+  0744 07 63 05    	call itoa				; convert bh to char in A
0463+  0747 2F          	mov bl, al				; save al
0464+  0748 19 00       	mov al, 0
0465+  074A 05 03       	syscall sys_io				; display AH
0466+  074C 24          	mov ah, bl				; retrieve al
0467+  074D 19 00       	mov al, 0
0468+  074F 05 03       	syscall sys_io				; display AL
0469+  0751             
0470+  0751 E5          	pop b
0471+  0752 E4          	pop a
0472+  0753 09          	ret
0473+  0754             
0474+  0754             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0475+  0754             ; INPUT 16BIT HEX INTEGER
0476+  0754             ; read 16bit integer into A
0477+  0754             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0478+  0754             scan_u16x:
0479+  0754 F8 10 00    	enter 16
0480+  0757 D8          	push b
0481+  0758 DA          	push d
0482+  0759             
0483+  0759 FA F1 FF    	lea d, [bp + -15]
0484+  075C 07 A3 05    	call gets				; get number
0485+  075F             
0486+  075F 32          	mov bl, [d]
0487+  0760 37          	mov bh, bl
0488+  0761 33 01 00    	mov bl, [d + 1]
0489+  0764 07 51 05    	call atoi				; convert to int in AL
0490+  0767 23          	mov ah, al				; move to AH
0491+  0768             
0492+  0768 33 02 00    	mov bl, [d + 2]
0493+  076B 37          	mov bh, bl
0494+  076C 33 03 00    	mov bl, [d + 3]
0495+  076F 07 51 05    	call atoi				; convert to int in AL
0496+  0772             
0497+  0772 E7          	pop d
0498+  0773 E5          	pop b
0499+  0774 F9          	leave
0500+  0775 09          	ret
0501+  0776             
0502+  0776             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0503+  0776             ; PRINT 8bit HEX INTEGER
0504+  0776             ; integer value in reg bl
0505+  0776             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0506+  0776             print_u8x:
0507+  0776 D7          	push a
0508+  0777 DD          	push bl
0509+  0778             
0510+  0778 07 63 05    	call itoa				; convert bl to char in A
0511+  077B 2F          	mov bl, al				; save al
0512+  077C 19 00       	mov al, 0
0513+  077E 05 03       	syscall sys_io				; display AH
0514+  0780 24          	mov ah, bl				; retrieve al
0515+  0781 19 00       	mov al, 0
0516+  0783 05 03       	syscall sys_io				; display AL
0517+  0785             
0518+  0785 EA          	pop bl
0519+  0786 E4          	pop a
0520+  0787 09          	ret
0521+  0788             
0522+  0788             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0523+  0788             ; print 8bit decimal unsigned number
0524+  0788             ; input number in AL
0525+  0788             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0526+  0788             print_u8d:
0527+  0788 D7          	push a
0528+  0789 D8          	push b
0529+  078A             
0530+  078A 22 00       	mov ah, 0
0531+  078C 26 64 00    	mov b, 100
0532+  078F AE          	div a, b
0533+  0790 D8          	push b			; save remainder
0534+  0791 B9 00       	cmp al, 0
0535+  0793 C6 9D 07    	je skip100
0536+  0796 6A 30       	add al, $30
0537+  0798 23          	mov ah, al
0538+  0799 19 00       	mov al, 0
0539+  079B 05 03       	syscall sys_io	; print coeff
0540+  079D             skip100:
0541+  079D E4          	pop a
0542+  079E 22 00       	mov ah, 0
0543+  07A0 26 0A 00    	mov b, 10
0544+  07A3 AE          	div a, b
0545+  07A4 D8          	push b			; save remainder
0546+  07A5 B9 00       	cmp al, 0
0547+  07A7 C6 B1 07    	je skip10
0548+  07AA 6A 30       	add al, $30
0549+  07AC 23          	mov ah, al
0550+  07AD 19 00       	mov al, 0
0551+  07AF 05 03       	syscall sys_io	; print coeff
0552+  07B1             skip10:
0553+  07B1 E4          	pop a
0554+  07B2 1B          	mov al, bl
0555+  07B3 6A 30       	add al, $30
0556+  07B5 23          	mov ah, al
0557+  07B6 19 00       	mov al, 0
0558+  07B8 05 03       	syscall sys_io	; print coeff
0559+  07BA E5          	pop b
0560+  07BB E4          	pop a
0561+  07BC 09          	ret
0562+  07BD             
0563+  07BD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0564+  07BD             ; INPUT 8BIT HEX INTEGER
0565+  07BD             ; read 8bit integer into AL
0566+  07BD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0567+  07BD             scan_u8x:
0568+  07BD F8 04 00    	enter 4
0569+  07C0 D8          	push b
0570+  07C1 DA          	push d
0571+  07C2             
0572+  07C2 FA FD FF    	lea d, [bp + -3]
0573+  07C5 07 A3 05    	call gets				; get number
0574+  07C8             
0575+  07C8 32          	mov bl, [d]
0576+  07C9 37          	mov bh, bl
0577+  07CA 33 01 00    	mov bl, [d + 1]
0578+  07CD 07 51 05    	call atoi				; convert to int in AL
0579+  07D0             
0580+  07D0 E7          	pop d
0581+  07D1 E5          	pop b
0582+  07D2 F9          	leave
0583+  07D3 09          	ret
0584+  07D4             
0585+  07D4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0586+  07D4             ; input decimal number
0587+  07D4             ; result in A
0588+  07D4             ; 655'\0'
0589+  07D4             ; low--------high
0590+  07D4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0591+  07D4             scan_u16d:
0592+  07D4 F8 08 00    	enter 8
0593+  07D7 E2          	push si
0594+  07D8 D8          	push b
0595+  07D9 D9          	push c
0596+  07DA DA          	push d
0597+  07DB FA F9 FF    	lea d, [bp +- 7]
0598+  07DE 07 A3 05    	call gets
0599+  07E1 07 D9 04    	call strlen			; get string length in C
0600+  07E4 7E          	dec c
0601+  07E5 FD 4E       	mov si, d
0602+  07E7 12          	mov a, c
0603+  07E8 FD 99       	shl a
0604+  07EA 3B 39 05    	mov d, table_power
0605+  07ED 59          	add d, a
0606+  07EE 38 00 00    	mov c, 0
0607+  07F1             mul_loop:
0608+  07F1 F6          	lodsb			; load ASCII to al
0609+  07F2 B9 00       	cmp al, 0
0610+  07F4 C6 07 08    	je mul_exit
0611+  07F7 6F 30       	sub al, $30		; make into integer
0612+  07F9 22 00       	mov ah, 0
0613+  07FB 2A          	mov b, [d]
0614+  07FC AC          	mul a, b			; result in B since it fits in 16bits
0615+  07FD 11          	mov a, b
0616+  07FE 28          	mov b, c
0617+  07FF 54          	add a, b
0618+  0800 39          	mov c, a
0619+  0801 63 02 00    	sub d, 2
0620+  0804 0A F1 07    	jmp mul_loop
0621+  0807             mul_exit:
0622+  0807 12          	mov a, c
0623+  0808 E7          	pop d
0624+  0809 E6          	pop c
0625+  080A E5          	pop b
0626+  080B EF          	pop si
0627+  080C F9          	leave
0628+  080D 09          	ret
0091   080E             .include "ctype.asm"
0001+  080E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  080E             ; ctype.s
0003+  080E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  080E             
0005+  080E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  080E             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  080E             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  080E             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  080E             ;; characters are supported.
0010+  080E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  080E             ;; isalnum 
0012+  080E             ;; isalpha 
0013+  080E             ;; islower 
0014+  080E             ;; isupper 
0015+  080E             ;; isdigit 
0016+  080E             ;; isxdigit
0017+  080E             ;; iscntrl 
0018+  080E             ;; isgraph 
0019+  080E             ;; isspace 
0020+  080E             ;; isblank 
0021+  080E             ;; isprint 
0022+  080E             ;; ispunct 
0023+  080E             ;; tolower 
0024+  080E             ;; toupper
0025+  080E             
0026+  080E             
0027+  080E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  080E             ;; IS ALPHANUMERIC
0029+  080E             ;; sets ZF according with result
0030+  080E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  080E             isalnum:
0032+  080E 07 2B 08    	call isalpha
0033+  0811 C6 17 08    	je isalnum_exit
0034+  0814 07 18 08    	call isdigit
0035+  0817             isalnum_exit:
0036+  0817 09          	ret	
0037+  0818             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0818             ;; IS DIGIT
0039+  0818             ;; sets ZF according with result
0040+  0818             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  0818             isdigit:
0042+  0818 DB          	push al
0043+  0819 B9 30       	cmp al, '0'
0044+  081B C8 27 08    	jlu isdigit_false
0045+  081E B9 39       	cmp al, '9'
0046+  0820 D1 27 08    	jgu isdigit_false
0047+  0823 87 00       	and al, 0	; set ZF
0048+  0825 E8          	pop al
0049+  0826 09          	ret
0050+  0827             isdigit_false:
0051+  0827 8B 01       	or al, 1	; clear ZF
0052+  0829 E8          	pop al
0053+  082A 09          	ret	
0054+  082B             	
0055+  082B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  082B             ;; IS ALPHA
0057+  082B             ;; sets ZF according with result
0058+  082B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  082B             isalpha:
0060+  082B DB          	push al
0061+  082C B9 5F       	cmp al, '_'
0062+  082E C6 4E 08    	je isalpha_true
0063+  0831 B9 2E       	cmp al, '.'
0064+  0833 C6 4E 08    	je isalpha_true
0065+  0836 B9 41       	cmp al, 'A'
0066+  0838 C8 4A 08    	jlu isalpha_false
0067+  083B B9 7A       	cmp al, 'z'
0068+  083D D1 4A 08    	jgu isalpha_false
0069+  0840 B9 5A       	cmp al, 'Z'
0070+  0842 D0 4E 08    	jleu isalpha_true
0071+  0845 B9 61       	cmp al, 'a'
0072+  0847 C9 4E 08    	jgeu isalpha_true
0073+  084A             isalpha_false:
0074+  084A 8B 01       	or al, 1	; clear ZF
0075+  084C E8          	pop al
0076+  084D 09          	ret
0077+  084E             isalpha_true:
0078+  084E 87 00       	and al, 0	; set ZF
0079+  0850 E8          	pop al
0080+  0851 09          	ret
0081+  0852             
0082+  0852             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  0852             ;; IS PATH-ALPHA
0084+  0852             ;; sets ZF according with result
0085+  0852             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  0852             ispath:
0087+  0852 DB          	push al
0088+  0853 07 18 08    	call isdigit
0089+  0856 C6 80 08    	je ispath_true
0090+  0859 B9 5F       	cmp al, '_'
0091+  085B C6 80 08    	je ispath_true
0092+  085E B9 2F       	cmp al, '/'
0093+  0860 C6 80 08    	je ispath_true
0094+  0863 B9 2E       	cmp al, '.'
0095+  0865 C6 80 08    	je ispath_true
0096+  0868 B9 41       	cmp al, 'A'
0097+  086A C8 7C 08    	jlu ispath_false
0098+  086D B9 7A       	cmp al, 'z'
0099+  086F D1 7C 08    	jgu ispath_false
0100+  0872 B9 5A       	cmp al, 'Z'
0101+  0874 D0 80 08    	jleu ispath_true
0102+  0877 B9 61       	cmp al, 'a'
0103+  0879 C9 80 08    	jgeu ispath_true
0104+  087C             ispath_false:
0105+  087C 8B 01       	or al, 1	; clear ZF
0106+  087E E8          	pop al
0107+  087F 09          	ret
0108+  0880             ispath_true:
0109+  0880 87 00       	and al, 0	; set ZF
0110+  0882 E8          	pop al
0111+  0883 09          	ret
0112+  0884             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  0884             ;; IS SPACE
0114+  0884             ;; sets ZF according with result
0115+  0884             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  0884             isspace:
0117+  0884 B9 20       	cmp al, $20		; ' '
0118+  0886 C6 9A 08    	je isspace_exit
0119+  0889 B9 09       	cmp al, $09		; '\t'
0120+  088B C6 9A 08    	je isspace_exit
0121+  088E B9 0A       	cmp al, $0A		; '\n'
0122+  0890 C6 9A 08    	je isspace_exit
0123+  0893 B9 0D       	cmp al, $0D		; '\r'
0124+  0895 C6 9A 08    	je isspace_exit
0125+  0898 B9 0B       	cmp al, $0B		; '\v'
0126+  089A             isspace_exit:
0127+  089A 09          	ret	
0128+  089B             
0129+  089B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  089B             ; TO LOWER
0131+  089B             ; input in AL
0132+  089B             ; output in AL
0133+  089B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  089B             to_lower:
0135+  089B B9 5A       	cmp al, 'Z'
0136+  089D D1 A2 08    	jgu to_lower_ret
0137+  08A0 6A 20       	add al, $20				; convert to lower case
0138+  08A2             to_lower_ret:
0139+  08A2 09          	ret
0140+  08A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  08A3             ; TO UPPER
0142+  08A3             ; input in AL
0143+  08A3             ; output in AL
0144+  08A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  08A3             to_upper:
0146+  08A3 B9 61       	cmp al, 'a'
0147+  08A5 C8 AA 08    	jlu to_upper_ret
0148+  08A8 6F 20       	sub al, $20			; convert to upper case
0149+  08AA             to_upper_ret:
0150+  08AA 09          	ret
0151+  08AB             
0092   08AB             .include "token.asm"
0001+  08AB             TOKTYP_IDENTIFIER	.equ 0
0002+  08AB             TOKTYP_KEYWORD		.equ 1
0003+  08AB             TOKTYP_DELIMITER	.equ 2
0004+  08AB             TOKTYP_STRING		.equ 3
0005+  08AB             TOKTYP_CHAR			.equ 4
0006+  08AB             TOKTYP_NUMERIC		.equ 5
0007+  08AB             TOKTYP_END			.equ 6
0008+  08AB             
0009+  08AB             TOK_NULL			.equ 0
0010+  08AB             TOK_FSLASH			.equ 1
0011+  08AB             TOK_TIMES 			.equ 2
0012+  08AB             TOK_PLUS 			.equ 3
0013+  08AB             TOK_MINUS 			.equ 4
0014+  08AB             TOK_DOT				.equ 5
0015+  08AB             TOK_SEMI			.equ 6
0016+  08AB             TOK_ANGLE			.equ 7
0017+  08AB             TOK_TILDE			.equ 8
0018+  08AB             TOK_EQUAL			.equ 9
0019+  08AB             TOK_COLON			.equ 10
0020+  08AB             TOK_COMMA			.equ 11
0021+  08AB             
0022+  08AB             TOK_END				.equ 20
0023+  08AB             
0024+  08AB             
0025+  08AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  08AB             ;; read a full command argment from shell input buffer
0027+  08AB             ;; argument is written into tokstr
0028+  08AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  08AB             get_arg:
0030+  08AB D7          	push a
0031+  08AC E2          	push si
0032+  08AD E3          	push di
0033+  08AE 19 00       	mov al, 0
0034+  08B0 3D D9 0A    	mov [tokstr], al			; nullify tokstr string
0035+  08B3 14 D5 0A    	mov a, [prog]
0036+  08B6 4D          	mov si, a
0037+  08B7 FD 4F D9 0A 	mov di, tokstr
0038+  08BB             get_arg_skip_spaces:
0039+  08BB F6          	lodsb
0040+  08BC 07 84 08    	call isspace
0041+  08BF C6 BB 08    	je get_arg_skip_spaces
0042+  08C2             get_arg_L0:
0043+  08C2 B9 3B       	cmp al, $3B				; check if is ';'
0044+  08C4 C6 D1 08    	je get_arg_end
0045+  08C7 B9 00       	cmp al, 0
0046+  08C9 C6 D1 08    	je get_arg_end			; check if end of input
0047+  08CC F7          	stosb
0048+  08CD F6          	lodsb
0049+  08CE 0A C2 08    	jmp get_arg_L0
0050+  08D1             get_arg_end:
0051+  08D1 19 00       	mov al, 0
0052+  08D3 F7          	stosb
0053+  08D4 D5 01 00    	sub si, 1
0054+  08D7 4E          	mov a, si
0055+  08D8 42 D5 0A    	mov [prog], a		; update pointer
0056+  08DB F0          	pop di
0057+  08DC EF          	pop si
0058+  08DD E4          	pop a
0059+  08DE 09          	ret
0060+  08DF             
0061+  08DF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  08DF             ;; read a path formation from shell input buffer
0063+  08DF             ;; path is written into tokstr
0064+  08DF             ;; /usr/bin
0065+  08DF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  08DF             get_path:
0067+  08DF D7          	push a
0068+  08E0 E2          	push si
0069+  08E1 E3          	push di
0070+  08E2 19 00       	mov al, 0
0071+  08E4 3D D9 0A    	mov [tokstr], al			; nullify tokstr string
0072+  08E7 14 D5 0A    	mov a, [prog]
0073+  08EA 4D          	mov si, a
0074+  08EB FD 4F D9 0A 	mov di, tokstr
0075+  08EF             get_path_skip_spaces:
0076+  08EF F6          	lodsb
0077+  08F0 07 84 08    	call isspace
0078+  08F3 C6 EF 08    	je get_path_skip_spaces
0079+  08F6             get_path_is_pathchar:
0080+  08F6 F7          	stosb
0081+  08F7 F6          	lodsb
0082+  08F8 07 0E 08    	call isalnum			;check if is alphanumeric
0083+  08FB C6 F6 08    	je get_path_is_pathchar
0084+  08FE B9 2F       	cmp al, '/'				; check if is '/'
0085+  0900 C6 F6 08    	je get_path_is_pathchar
0086+  0903 19 00       	mov al, 0
0087+  0905 F7          	stosb
0088+  0906 D5 01 00    	sub si, 1
0089+  0909 4E          	mov a, si
0090+  090A 42 D5 0A    	mov [prog], a		; update pointer
0091+  090D             get_path_end:
0092+  090D F0          	pop di
0093+  090E EF          	pop si
0094+  090F E4          	pop a
0095+  0910 09          	ret
0096+  0911             
0097+  0911             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  0911             ;; read a line
0099+  0911             ;; line is written into tokstr
0100+  0911             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  0911             get_line:
0102+  0911 D7          	push a
0103+  0912 E2          	push si
0104+  0913 E3          	push di
0105+  0914 19 00       	mov al, 0
0106+  0916 3D D9 0A    	mov [tokstr], al			; nullify tokstr string
0107+  0919 14 D5 0A    	mov a, [prog]
0108+  091C 4D          	mov si, a
0109+  091D FD 4F D9 0A 	mov di, tokstr
0110+  0921             get_line_L0:
0111+  0921 F6          	lodsb
0112+  0922 B9 0A       	cmp al, $0A		; check for new line
0113+  0924 C6 2B 09    	je get_line_exit
0114+  0927 F7          	stosb
0115+  0928 0A 21 09    	jmp get_line_L0
0116+  092B             get_line_exit:
0117+  092B 19 00       	mov al, 0
0118+  092D F7          	stosb
0119+  092E 4E          	mov a, si
0120+  092F 42 D5 0A    	mov [prog], a		; update pointer
0121+  0932 F0          	pop di
0122+  0933 EF          	pop si
0123+  0934 E4          	pop a
0124+  0935 09          	ret
0125+  0936             
0126+  0936             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  0936             ;; token parser
0128+  0936             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  0936             get_token:
0130+  0936 D7          	push a
0131+  0937 DA          	push d
0132+  0938 E2          	push si
0133+  0939 E3          	push di
0134+  093A 19 00       	mov al, 0
0135+  093C 3D D9 0A    	mov [tokstr], al			; nullify tokstr string
0136+  093F 19 00       	mov al, TOK_NULL
0137+  0941 3D D8 0A    	mov [tok], al				; nullify token
0138+  0944 14 D5 0A    	mov a, [prog]
0139+  0947 4D          	mov si, a
0140+  0948 FD 4F D9 0A 	mov di, tokstr
0141+  094C             get_tok_skip_spaces:
0142+  094C F6          	lodsb
0143+  094D 07 84 08    	call isspace
0144+  0950 C6 4C 09    	je get_tok_skip_spaces
0145+  0953 B9 00       	cmp al, 0			; check for end of input (NULL)
0146+  0955 C6 3A 0A    	je get_token_end
0147+  0958 B9 23       	cmp al, '#'			; comments!
0148+  095A C6 68 0A    	je get_tok_comment
0149+  095D 07 0E 08    	call isalnum
0150+  0960 C6 47 0A    	jz is_alphanumeric
0151+  0963             ; other token types
0152+  0963             get_token_slash:
0153+  0963 B9 2F       	cmp al, '/'				; check if '/'
0154+  0965 C7 7D 09    	jne get_token_minus
0155+  0968 F7          	stosb					; store '/' into token string
0156+  0969 19 00       	mov al, 0
0157+  096B F7          	stosb					; terminate token string
0158+  096C 19 01       	mov al, TOK_FSLASH
0159+  096E 3D D8 0A    	mov [tok], al			
0160+  0971 19 02       	mov al, TOKTYP_DELIMITER
0161+  0973 3D D7 0A    	mov [toktyp], al
0162+  0976 4E          	mov a, si
0163+  0977 42 D5 0A    	mov [prog], a		; update pointer
0164+  097A 0A 63 0A    	jmp get_token_return
0165+  097D             get_token_minus:
0166+  097D B9 2D       	cmp al, '-'				; check if '-'
0167+  097F C7 97 09    	jne get_token_comma
0168+  0982 F7          	stosb					; store '-' into token string
0169+  0983 19 00       	mov al, 0
0170+  0985 F7          	stosb					; terminate token string
0171+  0986 19 04       	mov al, TOK_MINUS
0172+  0988 3D D8 0A    	mov [tok], al			
0173+  098B 19 02       	mov al, TOKTYP_DELIMITER
0174+  098D 3D D7 0A    	mov [toktyp], al
0175+  0990 4E          	mov a, si
0176+  0991 42 D5 0A    	mov [prog], a		; update pointer
0177+  0994 0A 63 0A    	jmp get_token_return
0178+  0997             get_token_comma:
0179+  0997 B9 2C       	cmp al, ','				; check if ','
0180+  0999 C7 B1 09    	jne get_token_semi
0181+  099C F7          	stosb					; store ',' into token string
0182+  099D 19 00       	mov al, 0
0183+  099F F7          	stosb					; terminate token string
0184+  09A0 19 0B       	mov al, TOK_COMMA
0185+  09A2 3D D8 0A    	mov [tok], al			
0186+  09A5 19 02       	mov al, TOKTYP_DELIMITER
0187+  09A7 3D D7 0A    	mov [toktyp], al
0188+  09AA 4E          	mov a, si
0189+  09AB 42 D5 0A    	mov [prog], a		; update pointer
0190+  09AE 0A 63 0A    	jmp get_token_return
0191+  09B1             get_token_semi:
0192+  09B1 B9 3B       	cmp al, $3B				; check if ';'
0193+  09B3 C7 CB 09    	jne get_token_colon
0194+  09B6 F7          	stosb					; store ';' into token string
0195+  09B7 19 00       	mov al, 0
0196+  09B9 F7          	stosb					; terminate token string
0197+  09BA 19 06       	mov al, TOK_SEMI
0198+  09BC 3D D8 0A    	mov [tok], al			
0199+  09BF 19 02       	mov al, TOKTYP_DELIMITER
0200+  09C1 3D D7 0A    	mov [toktyp], al
0201+  09C4 4E          	mov a, si
0202+  09C5 42 D5 0A    	mov [prog], a		; update pointer
0203+  09C8 0A 63 0A    	jmp get_token_return
0204+  09CB             get_token_colon:
0205+  09CB B9 3A       	cmp al, $3A				; check if ':'
0206+  09CD C7 E5 09    	jne get_token_angle
0207+  09D0 F7          	stosb					; store ':' into token string
0208+  09D1 19 00       	mov al, 0
0209+  09D3 F7          	stosb					; terminate token string
0210+  09D4 19 0A       	mov al, TOK_COLON
0211+  09D6 3D D8 0A    	mov [tok], al			
0212+  09D9 19 02       	mov al, TOKTYP_DELIMITER
0213+  09DB 3D D7 0A    	mov [toktyp], al
0214+  09DE 4E          	mov a, si
0215+  09DF 42 D5 0A    	mov [prog], a		; update pointer
0216+  09E2 0A 63 0A    	jmp get_token_return
0217+  09E5             get_token_angle:
0218+  09E5 B9 3E       	cmp al, $3E				; check if '>'
0219+  09E7 C7 FF 09    	jne get_token_tilde
0220+  09EA F7          	stosb					; store '>' into token string
0221+  09EB 19 00       	mov al, 0
0222+  09ED F7          	stosb					; terminate token string
0223+  09EE 19 07       	mov al, TOK_ANGLE
0224+  09F0 3D D8 0A    	mov [tok], al			
0225+  09F3 19 02       	mov al, TOKTYP_DELIMITER
0226+  09F5 3D D7 0A    	mov [toktyp], al
0227+  09F8 4E          	mov a, si
0228+  09F9 42 D5 0A    	mov [prog], a		; update pointer
0229+  09FC 0A 63 0A    	jmp get_token_return
0230+  09FF             get_token_tilde:
0231+  09FF B9 7E       	cmp al, '~'				; check if '~'
0232+  0A01 C7 19 0A    	jne get_token_equal
0233+  0A04 F7          	stosb					; store '~' into token string
0234+  0A05 19 00       	mov al, 0
0235+  0A07 F7          	stosb					; terminate token string
0236+  0A08 19 08       	mov al, TOK_TILDE
0237+  0A0A 3D D8 0A    	mov [tok], al			
0238+  0A0D 19 02       	mov al, TOKTYP_DELIMITER
0239+  0A0F 3D D7 0A    	mov [toktyp], al
0240+  0A12 4E          	mov a, si
0241+  0A13 42 D5 0A    	mov [prog], a		; update pointer
0242+  0A16 0A 63 0A    	jmp get_token_return
0243+  0A19             get_token_equal:
0244+  0A19 B9 3D       	cmp al, '='				; check if '='
0245+  0A1B C7 33 0A    	jne get_token_skip
0246+  0A1E F7          	stosb					; store '=' into token string
0247+  0A1F 19 00       	mov al, 0
0248+  0A21 F7          	stosb					; terminate token string
0249+  0A22 19 09       	mov al, TOK_EQUAL
0250+  0A24 3D D8 0A    	mov [tok], al			
0251+  0A27 19 02       	mov al, TOKTYP_DELIMITER
0252+  0A29 3D D7 0A    	mov [toktyp], al
0253+  0A2C 4E          	mov a, si
0254+  0A2D 42 D5 0A    	mov [prog], a		; update pointer
0255+  0A30 0A 63 0A    	jmp get_token_return
0256+  0A33             get_token_skip:
0257+  0A33 4E          	mov a, si
0258+  0A34 42 D5 0A    	mov [prog], a		; update pointer
0259+  0A37 0A 63 0A    	jmp get_token_return
0260+  0A3A             get_token_end:				; end of file token
0261+  0A3A 19 14       	mov al, TOK_END
0262+  0A3C 3D D8 0A    	mov [tok], al
0263+  0A3F 19 06       	mov al, TOKTYP_END
0264+  0A41 3D D7 0A    	mov [toktyp], al
0265+  0A44 0A 63 0A    	jmp get_token_return
0266+  0A47             is_alphanumeric:
0267+  0A47 F7          	stosb
0268+  0A48 F6          	lodsb
0269+  0A49 07 0E 08    	call isalnum			;check if is alphanumeric
0270+  0A4C C6 47 0A    	jz is_alphanumeric
0271+  0A4F B9 2E       	cmp al, $2E				; check if is '.'
0272+  0A51 C6 47 0A    	je is_alphanumeric
0273+  0A54 19 00       	mov al, 0
0274+  0A56 F7          	stosb
0275+  0A57 19 00       	mov al, TOKTYP_IDENTIFIER
0276+  0A59 3D D7 0A    	mov [toktyp], al
0277+  0A5C D5 01 00    	sub si, 1
0278+  0A5F 4E          	mov a, si
0279+  0A60 42 D5 0A    	mov [prog], a		; update pointer
0280+  0A63             get_token_return:
0281+  0A63 F0          	pop di
0282+  0A64 EF          	pop si
0283+  0A65 E7          	pop d
0284+  0A66 E4          	pop a
0285+  0A67 09          	ret
0286+  0A68             get_tok_comment:
0287+  0A68 F6          	lodsb
0288+  0A69 B9 0A       	cmp al, $0A			; new line
0289+  0A6B C7 68 0A    	jne get_tok_comment
0290+  0A6E 0A 4C 09    	jmp get_tok_skip_spaces
0291+  0A71             
0292+  0A71             
0293+  0A71             get_number:
0294+  0A71 D7          	push a
0295+  0A72 DA          	push d
0296+  0A73 E2          	push si
0297+  0A74 E3          	push di
0298+  0A75 19 00       	mov al, 0
0299+  0A77 3D D9 0A    	mov [tokstr], al			; nullify tokstr string
0300+  0A7A 19 00       	mov al, TOK_NULL
0301+  0A7C 3D D8 0A    	mov [tok], al				; nullify token
0302+  0A7F 14 D5 0A    	mov a, [prog]
0303+  0A82 4D          	mov si, a
0304+  0A83 FD 4F D9 0A 	mov di, tokstr
0305+  0A87             get_number_skip_spaces:
0306+  0A87 F6          	lodsb
0307+  0A88 07 84 08    	call isspace
0308+  0A8B C6 87 0A    	je get_number_skip_spaces
0309+  0A8E B9 00       	cmp al, 0			; check for end of input (NULL)
0310+  0A90 C7 A0 0A    	jne get_number_L0
0311+  0A93 19 14       	mov al, TOK_END
0312+  0A95 3D D8 0A    	mov [tok], al
0313+  0A98 19 06       	mov al, TOKTYP_END
0314+  0A9A 3D D7 0A    	mov [toktyp], al
0315+  0A9D 0A B7 0A    	jmp get_number_return
0316+  0AA0             get_number_L0:
0317+  0AA0 F7          	stosb
0318+  0AA1 F6          	lodsb
0319+  0AA2 07 18 08    	call isdigit			;check if is numeric
0320+  0AA5 C6 A0 0A    	jz get_number_L0
0321+  0AA8 19 00       	mov al, 0
0322+  0AAA F7          	stosb
0323+  0AAB 19 05       	mov al, TOKTYP_NUMERIC
0324+  0AAD 3D D7 0A    	mov [toktyp], al
0325+  0AB0 D5 01 00    	sub si, 1
0326+  0AB3 4E          	mov a, si
0327+  0AB4 42 D5 0A    	mov [prog], a		; update pointer
0328+  0AB7             get_number_return:
0329+  0AB7 F0          	pop di
0330+  0AB8 EF          	pop si
0331+  0AB9 E7          	pop d
0332+  0ABA E4          	pop a
0333+  0ABB 09          	ret
0334+  0ABC             
0335+  0ABC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  0ABC             ;; PUT BACK TOKEN
0337+  0ABC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
0338+  0ABC             putback:
0339+  0ABC D7          	push a
0340+  0ABD E2          	push si
0341+  0ABE FD 4D D9 0A 	mov si, tokstr	
0342+  0AC2             putback_loop:
0343+  0AC2 F6          	lodsb
0344+  0AC3 B9 00       	cmp al, 0
0345+  0AC5 C6 D2 0A    	je putback_end
0346+  0AC8 14 D5 0A    	mov a, [prog]
0347+  0ACB 7D          	dec a
0348+  0ACC 42 D5 0A    	mov [prog], a			; update pointer
0349+  0ACF 0A C2 0A    	jmp putback_loop
0350+  0AD2             putback_end:
0351+  0AD2 EF          	pop si
0352+  0AD3 E4          	pop a
0353+  0AD4 09          	ret
0354+  0AD5             
0355+  0AD5             
0356+  0AD5             
0357+  0AD5             
0358+  0AD5 00 00       prog:		.dw 0			; pointer to current position in buffer
0359+  0AD7             
0360+  0AD7 00          toktyp: 	.db 0			; token type symbol
0361+  0AD8 00          tok:		.db 0			; current token symbol
0362+  0AD9 00 00 00 00 tokstr:		.fill 256, 0	; token as a string
0362+  0ADD 00 00 00 00 
0362+  0AE1 00 00 00 00 
0362+  0AE5 00 00 00 00 
0362+  0AE9 00 00 00 00 
0362+  0AED 00 00 00 00 
0362+  0AF1 00 00 00 00 
0362+  0AF5 00 00 00 00 
0362+  0AF9 00 00 00 00 
0362+  0AFD 00 00 00 00 
0362+  0B01 00 00 00 00 
0362+  0B05 00 00 00 00 
0362+  0B09 00 00 00 00 
0362+  0B0D 00 00 00 00 
0362+  0B11 00 00 00 00 
0362+  0B15 00 00 00 00 
0362+  0B19 00 00 00 00 
0362+  0B1D 00 00 00 00 
0362+  0B21 00 00 00 00 
0362+  0B25 00 00 00 00 
0362+  0B29 00 00 00 00 
0362+  0B2D 00 00 00 00 
0362+  0B31 00 00 00 00 
0362+  0B35 00 00 00 00 
0362+  0B39 00 00 00 00 
0362+  0B3D 00 00 00 00 
0362+  0B41 00 00 00 00 
0362+  0B45 00 00 00 00 
0362+  0B49 00 00 00 00 
0362+  0B4D 00 00 00 00 
0362+  0B51 00 00 00 00 
0362+  0B55 00 00 00 00 
0362+  0B59 00 00 00 00 
0362+  0B5D 00 00 00 00 
0362+  0B61 00 00 00 00 
0362+  0B65 00 00 00 00 
0362+  0B69 00 00 00 00 
0362+  0B6D 00 00 00 00 
0362+  0B71 00 00 00 00 
0362+  0B75 00 00 00 00 
0362+  0B79 00 00 00 00 
0362+  0B7D 00 00 00 00 
0362+  0B81 00 00 00 00 
0362+  0B85 00 00 00 00 
0362+  0B89 00 00 00 00 
0362+  0B8D 00 00 00 00 
0362+  0B91 00 00 00 00 
0362+  0B95 00 00 00 00 
0362+  0B99 00 00 00 00 
0362+  0B9D 00 00 00 00 
0362+  0BA1 00 00 00 00 
0362+  0BA5 00 00 00 00 
0362+  0BA9 00 00 00 00 
0362+  0BAD 00 00 00 00 
0362+  0BB1 00 00 00 00 
0362+  0BB5 00 00 00 00 
0362+  0BB9 00 00 00 00 
0362+  0BBD 00 00 00 00 
0362+  0BC1 00 00 00 00 
0362+  0BC5 00 00 00 00 
0362+  0BC9 00 00 00 00 
0362+  0BCD 00 00 00 00 
0362+  0BD1 00 00 00 00 
0362+  0BD5 00 00 00 00 
0093   0BD9             
0094   0BD9             ;label_tab:		.fill 32 * 64, 0		; 64 labels of 32 chars each
0095   0BD9             ;label_addr_tab:	.fill 2 * 64, 0			; 64 words
0096   0BD9             
0097   0BD9             ;output_buffer:	.fill 64		; 4KB for now
0098   0BD9 6D 6F 76 20 program_buffer:	.db "mov a, 23\nmov b, a\nlabel1:\n"
0098   0BDD 61 2C 20 32 
0098   0BE1 33 0A 6D 6F 
0098   0BE5 76 20 62 2C 
0098   0BE9 20 61 0A 6C 
0098   0BED 61 62 65 6C 
0098   0BF1 31 3A 0A 
0099   0BF4 6D 6F 76 20 				.db "mov a, b\nmov b, 45\njmp label2\n"
0099   0BF8 61 2C 20 62 
0099   0BFC 0A 6D 6F 76 
0099   0C00 20 62 2C 20 
0099   0C04 34 35 0A 6A 
0099   0C08 6D 70 20 6C 
0099   0C0C 61 62 65 6C 
0099   0C10 32 0A 
0100   0C12 6C 61 62 65 				.db "label2:\nmov a, 34\njmp label1\n\n", 0
0100   0C16 6C 32 3A 0A 
0100   0C1A 6D 6F 76 20 
0100   0C1E 61 2C 20 33 
0100   0C22 34 0A 6A 6D 
0100   0C26 70 20 6C 61 
0100   0C2A 62 65 6C 31 
0100   0C2E 0A 0A 00 
0101   0C31             
0102   0C31 00 00 00 00 temp_tokstr: .fill 64, 0
0102   0C35 00 00 00 00 
0102   0C39 00 00 00 00 
0102   0C3D 00 00 00 00 
0102   0C41 00 00 00 00 
0102   0C45 00 00 00 00 
0102   0C49 00 00 00 00 
0102   0C4D 00 00 00 00 
0102   0C51 00 00 00 00 
0102   0C55 00 00 00 00 
0102   0C59 00 00 00 00 
0102   0C5D 00 00 00 00 
0102   0C61 00 00 00 00 
0102   0C65 00 00 00 00 
0102   0C69 00 00 00 00 
0102   0C6D 00 00 00 00 
0103   0C71             
0104   0C71             .end
0105   0C71             
tasm: Number of errors = 0
