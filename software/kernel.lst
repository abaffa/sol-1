0001   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002   0000             ; KERNEL
0003   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0005   0000             ; MEMORY MAP
0006   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007   0000             ; 0000		ROM BEGIN
0008   0000             ; ....
0009   0000             ; 7FFF		ROM END
0010   0000             ;
0011   0000             ; 8000		RAM begin
0012   0000             ; ....
0013   0000             ; F7FF		Stack root
0014   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0015   0000             ; I/O MAP
0016   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0017   0000             ; FF80		UART 0		(16550)
0018   0000             ; FF90		UART 1		(16550)
0019   0000             ; FFA0		RTC		(M48T02)
0020   0000             ; FFB0		PIO 0		(8255)
0021   0000             ; FFC0		PIO 1		(8255)
0022   0000             ; FFD0		IDE		(Compact Flash / PATA)
0023   0000             ; FFE0		Timer		(8253)
0024   0000             ; FFF0		BIOS CONFIGURATION NV-RAM STORE AREA
0025   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026   0000             ; SYSTEM CONSTANTS / EQUATIONS
0027   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028   0000             _UART0_DATA			.equ $FF80				; data
0029   0000             _UART0_DLAB_0		.equ $FF80				; divisor latch low byte
0030   0000             _UART0_DLAB_1		.equ $FF81				; divisor latch high byte
0031   0000             _UART0_IER			.equ $FF81				; Interrupt enable register
0032   0000             _UART0_FCR			.equ $FF82				; FIFO control register
0033   0000             _UART0_LCR			.equ $FF83				; line control register
0034   0000             _UART0_LSR			.equ $FF85				; line status register
0035   0000             
0036   0000             _IDE_BASE			.equ $FFD0				; IDE BASE
0037   0000             _IDE_R0				.equ _IDE_BASE + 0		; DATA PORT
0038   0000             _IDE_R1				.equ _IDE_BASE + 1		; READ: ERROR CODE, WRITE: FEATURE
0039   0000             _IDE_R2				.equ _IDE_BASE + 2		; NUMBER OF SECTORS TO TRANSFER
0040   0000             _IDE_R3				.equ _IDE_BASE + 3		; SECTOR ADDRESS LBA 0 [0:7]
0041   0000             _IDE_R4				.equ _IDE_BASE + 4		; SECTOR ADDRESS LBA 1 [8:15]
0042   0000             _IDE_R5				.equ _IDE_BASE + 5		; SECTOR ADDRESS LBA 2 [16:23]
0043   0000             _IDE_R6				.equ _IDE_BASE + 6		; SECTOR ADDRESS LBA 3 [24:27 (LSB)]
0044   0000             _IDE_R7				.equ _IDE_BASE + 7		; READ: STATUS, WRITE: COMMAND
0045   0000             
0046   0000             _7SEG_DISPLAY		.equ $FFB0				; BIOS POST CODE HEX DISPLAY (2 DIGITS)
0047   0000             _BIOS_POST_CTRL		.equ $FFB3				; BIOS POST DISPLAY CONTROL REGISTER, 80h = As Output
0048   0000             _PIO_A				.equ $FFB0		
0049   0000             _PIO_B				.equ $FFB1
0050   0000             _PIO_C				.equ $FFB2
0051   0000             _PIO_CONTROL		.equ $FFB3				; PIO CONTROL PORT
0052   0000             
0053   0000             _TIMER_C_0			.equ $FFE0				; TIMER COUNTER 0
0054   0000             _TIMER_C_1			.equ $FFE1				; TIMER COUNTER 1
0055   0000             _TIMER_C_2			.equ $FFE2				; TIMER COUNTER 2
0056   0000             _TIMER_CTRL			.equ $FFE3				; TIMER CONTROL REGISTER
0057   0000             
0058   0000             STACK_BEGIN			.equ $F7FF				; beginning of stack
0059   0000             FIFO_SIZE			.equ (1024*2)
0060   0000             
0061   0000             PROC_TEXT_ORG		.equ $400
0062   0000             NULL				.equ 0
0063   0000             
0064   0000             
0065   0000             ; for the next iteration:
0066   0000             ; boot-sector(1) | kernel-sectors(32) | inode-bitmap | rawdata-bitmap | inode-table | raw-disk-data
0067   0000             ;
0068   0000             ; inode-table format:
0069   0000             ;	file-type(f, d)
0070   0000             ;	permissons
0071   0000             ;	link-count
0072   0000             ;	filesize
0073   0000             ;	time-stamps
0074   0000             ;	15 data block pointers
0075   0000             ;	single-indirect pointer
0076   0000             ;
0077   0000             
0078   0000             ; for now:
0079   0000             ; boot-sector(1) | kernel-sectors(32) | rawdata-bitmap() | raw-disk-data
0080   0000             ;
0081   0000             ; filename (24)
0082   0000             ; attributes (1) 			:|0|0|file_type(3bits)|x|w|r|
0083   0000             ; LBA (2)					: location of raw data for file entry, or dirID for directory entry
0084   0000             ; size (2)					: filesize
0085   0000             ; day (1)					 
0086   0000             ; month (1)
0087   0000             ; year (1)
0088   0000             ; packet size = 32 bytes	: total packet size in bytes
0089   0000             ;
0090   0000             FST_ENTRY_SIZE			.equ 32
0091   0000             FST_FILES_PER_SECT		.equ (512 / FST_ENTRY_SIZE)
0092   0000             FST_FILES_PER_DIR		.equ 16
0093   0000             FST_NBR_DIRECTORIES		.equ 64
0094   0000             						; 1 sector for header, the rest is for the list of files/dirs
0095   0000             FST_SECTORS_PER_DIR		.equ (1 + (FST_ENTRY_SIZE * FST_FILES_PER_DIR / 512))		
0096   0000             FST_TOTAL_SECTORS		.equ (FST_SECTORS_PER_DIR * FST_NBR_DIRECTORIES)
0097   0000             FST_LBA_START			.equ 32
0098   0000             FST_LBA_END				.equ (FST_LBA_START + FST_TOTAL_SECTORS - 1)
0099   0000             
0100   0000             FS_NBR_FILES 			.equ (FST_NBR_DIRECTORIES * FST_FILES_PER_DIR)
0101   0000             FS_SECTORS_PER_FILE		.equ 32				; the first sector is always a header with a NULL parameter (first byte)
0102   0000             											; so that we know which blocks are free or taken
0103   0000             FS_FILE_SIZE			.equ (FS_SECTORS_PER_FILE * 512)									
0104   0000             FS_TOTAL_SECTORS		.equ (FS_NBR_FILES * FS_SECTORS_PER_FILE)
0105   0000             FS_LBA_START			.equ (FST_LBA_END + 1)
0106   0000             FS_LBA_END				.equ (FS_LBA_START + FS_NBR_FILES - 1)
0107   0000             
0108   0000             CF_CARD_LBA_SIZE		.equ $800			; temporary small size
0109   0000             
0110   0000             ROOT_dirID:				.equ FST_LBA_START
0111   0000             
0112   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113   0000             ; GLOBAL SYSTEM VARIABLES
0114   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115   0000             
0116   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0117   0000             ; EXTERNAL INTERRUPT TABLE
0118   0000             ; highest priority at lowest address
0119   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0120   0000 87 07       .dw int_0
0121   0002 88 07       .dw int_1
0122   0004 89 07       .dw int_2
0123   0006 8A 07       .dw int_3
0124   0008 8B 07       .dw int_4
0125   000A 8C 07       .dw int_5
0126   000C 8D 07       .dw int_6
0127   000E D9 07       .dw int_7
0128   0010             
0129   0010             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130   0010             ; RESET VECTOR DECLARATION
0131   0010             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0132   0010 91 14       .dw KERNEL_RESET_VECTOR
0133   0012             
0134   0012             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0135   0012             ;; EXCEPTION VECTOR TABLE
0136   0012             ;; total of 7 entries, starting at address $0012
0137   0012             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138   0012 A3 08       .dw trap_privilege
0139   0014 C0 09       .dw trap_div_zero
0140   0016 CD 09       .dw undefined_opcode
0141   0018 00 00       .dw NULL
0142   001A 00 00       .dw NULL
0143   001C 00 00       .dw NULL
0144   001E 00 00       .dw NULL
0145   0020             
0146   0020             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0147   0020             ;; SYSTEM CALL VECTOR TABLE
0148   0020             ;; starts at address $0020
0149   0020             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0150   0020 AF 08       .dw trap_breakpoint
0151   0022 CE 09       .dw rtc_services						
0152   0024 F1 0A       .dw IDE_services_kernel
0153   0026 B1 0B       .dw io_services
0154   0028 3D 0C       .dw file_system
0155   002A 68 15       .dw cmd_fork
0156   002C 68 08       .dw list_procs
0157   002E 00 0A       .dw datetime_services
0158   0030 24 08       .dw syscall_reboot
0159   0032 32 15       .dw cmd_pause_proc
0160   0034 30 08       .dw resume_proc
0161   0036 EF 14       .dw cmd_terminate_proc
0162   0038 12 08       .dw cmd_system
0163   003A CA 0C       .dw cmd_boot_installer
0164   003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0165   003C             ;; FILE INCLUDES
0166   003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0167   003C             .include "bios.exp"	; to obtain the BIOS_RESET_VECTOR location (for reboots)
0001+  003C             BIOS_RESET_VECTOR .EQU  $01c0
0002+  003C             IDE_buffer       .EQU  $8204
0003+  003C             boot_origin      .EQU  $8004
0004+  003C             bios_uart        .EQU  $0002
0005+  003C             bios_ide         .EQU  $0003
0168   003C             .include "stdio.asm"
0001+  003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  003C             ; stdio.s
0003+  003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  003C             .include "string.asm"
0001++ 003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 003C             ; string.s
0003++ 003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 003C             
0005++ 003C             
0006++ 003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 003C             ; strrev
0008++ 003C             ; reverse a string
0009++ 003C             ; D = string address
0010++ 003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 003C             ; 01234
0012++ 003C             strrev:
0013++ 003C 4B          	pusha
0014++ 003D 07 83 00    	call strlen	; length in C
0015++ 0040 12          	mov a, c
0016++ 0041 AF 01 00    	cmp a, 1
0017++ 0044 D0 5E 00    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0047 7D          	dec a
0019++ 0048 FD 4E       	mov si, d	; beginning of string
0020++ 004A FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 004C 59          	add d, a	; end of string
0022++ 004D 12          	mov a, c
0023++ 004E FD 9B       	shr a		; divide by 2
0024++ 0050 39          	mov c, a	; C now counts the steps
0025++ 0051             strrev_L0:
0026++ 0051 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0052 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0053 3E          	mov [d], al	; store left char into right side
0029++ 0054 1B          	mov al, bl
0030++ 0055 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0056 7E          	dec c
0032++ 0057 7F          	dec d
0033++ 0058 C2 00 00    	cmp c, 0
0034++ 005B C7 51 00    	jne strrev_L0
0035++ 005E             strrev_end:
0036++ 005E 4C          	popa
0037++ 005F 09          	ret
0038++ 0060             	
0039++ 0060             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0060             ; strchr
0041++ 0060             ; search string in D for char in AL
0042++ 0060             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0060             strchr:
0044++ 0060             strchr_L0:
0045++ 0060 32          	mov bl, [d]
0046++ 0061 C1 00       	cmp bl, 0
0047++ 0063 C6 6E 00    	je strchr_end
0048++ 0066 BA          	cmp al, bl
0049++ 0067 C6 6E 00    	je strchr_end
0050++ 006A 79          	inc d
0051++ 006B 0A 60 00    	jmp strchr_L0
0052++ 006E             strchr_end:
0053++ 006E 1B          	mov al, bl
0054++ 006F 09          	ret
0055++ 0070             
0056++ 0070             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0070             ; strstr
0058++ 0070             ; find sub-string
0059++ 0070             ; str1 in SI
0060++ 0070             ; str2 in DI
0061++ 0070             ; SI points to end of source string
0062++ 0070             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0070             strstr:
0064++ 0070 DB          	push al
0065++ 0071 DA          	push d
0066++ 0072 E3          	push di
0067++ 0073             strstr_loop:
0068++ 0073 F3          	cmpsb					; compare a byte of the strings
0069++ 0074 C7 7F 00    	jne strstr_ret
0070++ 0077 FC 00 00    	lea d, [di + 0]
0071++ 007A BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 007C C7 73 00    	jne strstr_loop				; equal chars but not at end
0073++ 007F             strstr_ret:
0074++ 007F F0          	pop di
0075++ 0080 E7          	pop d
0076++ 0081 E8          	pop al
0077++ 0082 09          	ret
0078++ 0083             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0083             ; length of null terminated string
0080++ 0083             ; result in C
0081++ 0083             ; pointer in D
0082++ 0083             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0083             strlen:
0084++ 0083 DA          	push d
0085++ 0084 38 00 00    	mov c, 0
0086++ 0087             strlen_L1:
0087++ 0087 BD 00       	cmp byte [d], 0
0088++ 0089 C6 91 00    	je strlen_ret
0089++ 008C 79          	inc d
0090++ 008D 78          	inc c
0091++ 008E 0A 87 00    	jmp strlen_L1
0092++ 0091             strlen_ret:
0093++ 0091 E7          	pop d
0094++ 0092 09          	ret
0095++ 0093             
0096++ 0093             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0093             ; STRCMP
0098++ 0093             ; compare two strings
0099++ 0093             ; str1 in SI
0100++ 0093             ; str2 in DI
0101++ 0093             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0093             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0093             strcmp:
0104++ 0093 DB          	push al
0105++ 0094 DA          	push d
0106++ 0095 E3          	push di
0107++ 0096 E2          	push si
0108++ 0097             strcmp_loop:
0109++ 0097 F3          	cmpsb					; compare a byte of the strings
0110++ 0098 C7 A3 00    	jne strcmp_ret
0111++ 009B FB FF FF    	lea d, [si +- 1]
0112++ 009E BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 00A0 C7 97 00    	jne strcmp_loop				; equal chars but not at end
0114++ 00A3             strcmp_ret:
0115++ 00A3 EF          	pop si
0116++ 00A4 F0          	pop di
0117++ 00A5 E7          	pop d
0118++ 00A6 E8          	pop al
0119++ 00A7 09          	ret
0120++ 00A8             
0121++ 00A8             
0122++ 00A8             ; STRCPY
0123++ 00A8             ; copy null terminated string from SI to DI
0124++ 00A8             ; source in SI
0125++ 00A8             ; destination in DI
0126++ 00A8             strcpy:
0127++ 00A8 E2          	push si
0128++ 00A9 E3          	push di
0129++ 00AA DB          	push al
0130++ 00AB             strcpy_L1:
0131++ 00AB F6          	lodsb
0132++ 00AC F7          	stosb
0133++ 00AD B9 00       	cmp al, 0
0134++ 00AF C7 AB 00    	jne strcpy_L1
0135++ 00B2             strcpy_end:
0136++ 00B2 E8          	pop al
0137++ 00B3 F0          	pop di
0138++ 00B4 EF          	pop si
0139++ 00B5 09          	ret
0140++ 00B6             
0141++ 00B6             ; STRCAT
0142++ 00B6             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 00B6             ; source in SI
0144++ 00B6             ; destination in DI
0145++ 00B6             strcat:
0146++ 00B6 E2          	push si
0147++ 00B7 E3          	push di
0148++ 00B8 D7          	push a
0149++ 00B9 DA          	push d
0150++ 00BA 50          	mov a, di
0151++ 00BB 3C          	mov d, a
0152++ 00BC             strcat_goto_end_L1:
0153++ 00BC BD 00       	cmp byte[d], 0
0154++ 00BE C6 C5 00    	je strcat_start
0155++ 00C1 79          	inc d
0156++ 00C2 0A BC 00    	jmp strcat_goto_end_L1
0157++ 00C5             strcat_start:
0158++ 00C5 FD 50       	mov di, d
0159++ 00C7             strcat_L1:
0160++ 00C7 F6          	lodsb
0161++ 00C8 F7          	stosb
0162++ 00C9 B9 00       	cmp al, 0
0163++ 00CB C7 C7 00    	jne strcat_L1
0164++ 00CE             strcat_end:
0165++ 00CE E7          	pop d
0166++ 00CF E4          	pop a
0167++ 00D0 F0          	pop di
0168++ 00D1 EF          	pop si
0169++ 00D2 09          	ret
0005+  00D3             
0006+  00D3 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  00D7 34 35 36 37 
0006+  00DB 38 39 41 42 
0006+  00DF 43 44 45 46 
0007+  00E3 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  00E7 1B 5B 48 00 
0008+  00EB             
0009+  00EB 01 00       table_power:.dw 1
0010+  00ED 0A 00       			.dw 10
0011+  00EF 64 00       			.dw 100
0012+  00F1 E8 03       			.dw 1000
0013+  00F3 10 27       			.dw 10000
0014+  00F5             
0015+  00F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  00F5             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  00F5             ; ASCII in BL
0018+  00F5             ; result in AL
0019+  00F5             ; ascii for F = 0100 0110
0020+  00F5             ; ascii for 9 = 0011 1001
0021+  00F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  00F5             hex_ascii_encode:
0023+  00F5 1B          	mov al, bl
0024+  00F6 93 40       	test al, $40				; test if letter or number
0025+  00F8 C7 FE 00    	jnz hex_letter
0026+  00FB 87 0F       	and al, $0F				; get number
0027+  00FD 09          	ret
0028+  00FE             hex_letter:
0029+  00FE 87 0F       	and al, $0F				; get letter
0030+  0100 6A 09       	add al, 9
0031+  0102 09          	ret
0032+  0103             
0033+  0103             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  0103             ; ATOI
0035+  0103             ; 2 letter hex string in B
0036+  0103             ; 8bit integer returned in AL
0037+  0103             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0103             atoi:
0039+  0103 D8          	push b
0040+  0104 07 F5 00    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  0107 30          	mov bl, bh
0042+  0108 DB          	push al					; save a
0043+  0109 07 F5 00    	call hex_ascii_encode
0044+  010C EA          	pop bl	
0045+  010D FD 9E 04    	shl al, 4
0046+  0110 8C          	or al, bl
0047+  0111 E5          	pop b
0048+  0112 09          	ret	
0049+  0113             
0050+  0113             
0051+  0113             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  0113             ; printf
0053+  0113             ; no need for explanations!
0054+  0113             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0113             printf:
0056+  0113 09          	ret
0057+  0114             
0058+  0114             
0059+  0114             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  0114             ; scanf
0061+  0114             ; no need for explanations!
0062+  0114             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  0114             scanf:
0064+  0114 09          	ret
0065+  0115             
0066+  0115             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  0115             ; ITOA
0068+  0115             ; 8bit value in BL
0069+  0115             ; 2 byte ASCII result in A
0070+  0115             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  0115             itoa:
0072+  0115 DA          	push d
0073+  0116 D8          	push b
0074+  0117 A7 00       	mov bh, 0
0075+  0119 FD A4 04    	shr bl, 4	
0076+  011C 74          	mov d, b
0077+  011D 1F D3 00    	mov al, [d + s_hex_digits]
0078+  0120 23          	mov ah, al
0079+  0121             	
0080+  0121 E5          	pop b
0081+  0122 D8          	push b
0082+  0123 A7 00       	mov bh, 0
0083+  0125 FD 87 0F    	and bl, $0F
0084+  0128 74          	mov d, b
0085+  0129 1F D3 00    	mov al, [d + s_hex_digits]
0086+  012C E5          	pop b
0087+  012D E7          	pop d
0088+  012E 09          	ret
0089+  012F             
0090+  012F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  012F             ; HEX STRING TO BINARY
0092+  012F             ; di = destination address
0093+  012F             ; si = source
0094+  012F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  012F             hex_to_int:
0096+  012F             hex_to_int_L1:
0097+  012F F6          	lodsb					; load from [SI] to AL
0098+  0130 B9 00       	cmp al, 0				; check if ASCII 0
0099+  0132 C6 3F 01    	jz hex_to_int_ret
0100+  0135 36          	mov bh, al
0101+  0136 F6          	lodsb
0102+  0137 2F          	mov bl, al
0103+  0138 07 03 01    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  013B F7          	stosb					; store AL to [DI]
0105+  013C 0A 2F 01    	jmp hex_to_int_L1
0106+  013F             hex_to_int_ret:
0107+  013F 09          	ret		
0108+  0140             
0109+  0140             
0110+  0140             
0111+  0140             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  0140             ; GETCHAR
0113+  0140             ; char in ah
0114+  0140             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  0140             getchar:
0116+  0140 DB          	push al
0117+  0141             getchar_retry:
0118+  0141 FD 0C       	sti
0119+  0143 19 01       	mov al, 1
0120+  0145 05 03       	syscall sys_io			; receive in AH
0121+  0147 B9 00       	cmp al, 0			; check if any char was receive
0122+  0149 C6 41 01    	je getchar_retry
0123+  014C E8          	pop al
0124+  014D 09          	ret
0125+  014E             
0126+  014E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  014E             ; PUTCHAR
0128+  014E             ; char in ah
0129+  014E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  014E             putchar:
0131+  014E D7          	push a
0132+  014F 19 00       	mov al, 0
0133+  0151 05 03       	syscall sys_io			; char in AH
0134+  0153 E4          	pop a
0135+  0154 09          	ret
0136+  0155             
0137+  0155             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  0155             ;; INPUT A STRING
0139+  0155             ;; terminates with null
0140+  0155             ;; pointer in D
0141+  0155             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  0155             gets:
0143+  0155 D7          	push a
0144+  0156 DA          	push d
0145+  0157             gets_loop:
0146+  0157 FD 0C       	sti
0147+  0159 19 01       	mov al, 1
0148+  015B 05 03       	syscall sys_io			; receive in AH
0149+  015D B9 00       	cmp al, 0				; check error code (AL)
0150+  015F C6 57 01    	je gets_loop			; if no char received, retry
0151+  0162             
0152+  0162 76 1B       	cmp ah, 27
0153+  0164 C6 85 01    	je gets_telnet_escape
0154+  0167 76 0A       	cmp ah, $0A				; LF
0155+  0169 C6 DE 01    	je gets_end
0156+  016C 76 0D       	cmp ah, $0D				; CR
0157+  016E C6 DE 01    	je gets_end
0158+  0171 76 5C       	cmp ah, $5C				; '\\'
0159+  0173 C6 B5 01    	je gets_escape
0160+  0176             	
0161+  0176 76 08       	cmp ah, $08			; check for backspace
0162+  0178 C6 81 01    	je gets_backspace
0163+  017B             
0164+  017B 1A          	mov al, ah
0165+  017C 3E          	mov [d], al
0166+  017D 79          	inc d
0167+  017E 0A 57 01    	jmp gets_loop
0168+  0181             gets_backspace:
0169+  0181 7F          	dec d
0170+  0182 0A 57 01    	jmp gets_loop
0171+  0185             gets_telnet_escape:
0172+  0185 FD 0C       	sti
0173+  0187 19 01       	mov al, 1
0174+  0189 05 03       	syscall sys_io				; receive in AH without echo
0175+  018B B9 00       	cmp al, 0					; check error code (AL)
0176+  018D C6 85 01    	je gets_telnet_escape		; if no char received, retry
0177+  0190 76 5B       	cmp ah, '['
0178+  0192 C7 57 01    	jne gets_loop
0179+  0195             gets_telnet_escape_phase2:
0180+  0195 FD 0C       	sti
0181+  0197 19 01       	mov al, 1
0182+  0199 05 03       	syscall sys_io					; receive in AH without echo
0183+  019B B9 00       	cmp al, 0						; check error code (AL)
0184+  019D C6 95 01    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  01A0 76 44       	cmp ah, 'D'
0186+  01A2 C6 AD 01    	je gets_left_arrow
0187+  01A5 76 43       	cmp ah, 'C'
0188+  01A7 C6 B1 01    	je gets_right_arrow
0189+  01AA 0A 57 01    	jmp gets_loop
0190+  01AD             gets_left_arrow:
0191+  01AD 7F          	dec d
0192+  01AE 0A 57 01    	jmp gets_loop
0193+  01B1             gets_right_arrow:
0194+  01B1 79          	inc d
0195+  01B2 0A 57 01    	jmp gets_loop
0196+  01B5             gets_escape:
0197+  01B5 FD 0C       	sti
0198+  01B7 19 01       	mov al, 1
0199+  01B9 05 03       	syscall sys_io			; receive in AH
0200+  01BB B9 00       	cmp al, 0				; check error code (AL)
0201+  01BD C6 B5 01    	je gets_escape			; if no char received, retry
0202+  01C0 76 6E       	cmp ah, 'n'
0203+  01C2 C6 D0 01    	je gets_LF
0204+  01C5 76 72       	cmp ah, 'r'
0205+  01C7 C6 D7 01    	je gets_CR
0206+  01CA 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  01CB 3E          	mov [d], al
0208+  01CC 79          	inc d
0209+  01CD 0A 57 01    	jmp gets_loop
0210+  01D0             gets_LF:
0211+  01D0 19 0A       	mov al, $0A
0212+  01D2 3E          	mov [d], al
0213+  01D3 79          	inc d
0214+  01D4 0A 57 01    	jmp gets_loop
0215+  01D7             gets_CR:
0216+  01D7 19 0D       	mov al, $0D
0217+  01D9 3E          	mov [d], al
0218+  01DA 79          	inc d
0219+  01DB 0A 57 01    	jmp gets_loop
0220+  01DE             gets_end:
0221+  01DE 19 00       	mov al, 0
0222+  01E0 3E          	mov [d], al				; terminate string
0223+  01E1 E7          	pop d
0224+  01E2 E4          	pop a
0225+  01E3 09          	ret
0226+  01E4             
0227+  01E4             
0228+  01E4             
0229+  01E4             
0230+  01E4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  01E4             ;; INPUT TEXT
0232+  01E4             ;; terminated with CTRL+D
0233+  01E4             ;; pointer in D
0234+  01E4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  01E4             gettxt:
0236+  01E4 D7          	push a
0237+  01E5 DA          	push d
0238+  01E6             gettxt_loop:
0239+  01E6 19 01       	mov al, 1
0240+  01E8 05 03       	syscall sys_io			; receive in AH
0241+  01EA B9 00       	cmp al, 0				; check error code (AL)
0242+  01EC C6 E6 01    	je gettxt_loop		; if no char received, retry
0243+  01EF 76 04       	cmp ah, 4			; EOT
0244+  01F1 C6 2F 02    	je gettxt_end
0245+  01F4 76 08       	cmp ah, $08			; check for backspace
0246+  01F6 C6 2B 02    	je gettxt_backspace
0247+  01F9 76 5C       	cmp ah, $5C				; '\\'
0248+  01FB C6 04 02    	je gettxt_escape
0249+  01FE 1A          	mov al, ah
0250+  01FF 3E          	mov [d], al
0251+  0200 79          	inc d
0252+  0201 0A E6 01    	jmp gettxt_loop
0253+  0204             gettxt_escape:
0254+  0204 19 01       	mov al, 1
0255+  0206 05 03       	syscall sys_io			; receive in AH
0256+  0208 B9 00       	cmp al, 0				; check error code (AL)
0257+  020A C6 04 02    	je gettxt_escape		; if no char received, retry
0258+  020D 76 6E       	cmp ah, 'n'
0259+  020F C6 1D 02    	je gettxt_LF
0260+  0212 76 72       	cmp ah, 'r'
0261+  0214 C6 24 02    	je gettxt_CR
0262+  0217 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  0218 3E          	mov [d], al
0264+  0219 79          	inc d
0265+  021A 0A E6 01    	jmp gettxt_loop
0266+  021D             gettxt_LF:
0267+  021D 19 0A       	mov al, $0A
0268+  021F 3E          	mov [d], al
0269+  0220 79          	inc d
0270+  0221 0A E6 01    	jmp gettxt_loop
0271+  0224             gettxt_CR:
0272+  0224 19 0D       	mov al, $0D
0273+  0226 3E          	mov [d], al
0274+  0227 79          	inc d
0275+  0228 0A E6 01    	jmp gettxt_loop
0276+  022B             gettxt_backspace:
0277+  022B 7F          	dec d
0278+  022C 0A E6 01    	jmp gettxt_loop
0279+  022F             gettxt_end:
0280+  022F 19 00       	mov al, 0
0281+  0231 3E          	mov [d], al				; terminate string
0282+  0232 E7          	pop d
0283+  0233 E4          	pop a
0284+  0234 09          	ret
0285+  0235             
0286+  0235             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  0235             ; PRINT NEW LINE
0288+  0235             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  0235             printnl:
0290+  0235 D7          	push a
0291+  0236 10 00 0A    	mov a, $0A00
0292+  0239 05 03       	syscall sys_io
0293+  023B 10 00 0D    	mov a, $0D00
0294+  023E 05 03       	syscall sys_io
0295+  0240 E4          	pop a
0296+  0241 09          	ret
0297+  0242             
0298+  0242             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  0242             ; strtoint
0300+  0242             ; 4 digit hex string number in d
0301+  0242             ; integer returned in A
0302+  0242             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  0242             strtointx:
0304+  0242 D8          	push b
0305+  0243 32          	mov bl, [d]
0306+  0244 37          	mov bh, bl
0307+  0245 33 01 00    	mov bl, [d + 1]
0308+  0248 07 03 01    	call atoi				; convert to int in AL
0309+  024B 23          	mov ah, al				; move to AH
0310+  024C 33 02 00    	mov bl, [d + 2]
0311+  024F 37          	mov bh, bl
0312+  0250 33 03 00    	mov bl, [d + 3]
0313+  0253 07 03 01    	call atoi				; convert to int in AL
0314+  0256 E5          	pop b
0315+  0257 09          	ret
0316+  0258             
0317+  0258             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  0258             ; strtoint
0319+  0258             ; 5 digit base10 string number in d
0320+  0258             ; integer returned in A
0321+  0258             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  0258             strtoint:
0323+  0258 E2          	push si
0324+  0259 D8          	push b
0325+  025A D9          	push c
0326+  025B DA          	push d
0327+  025C 07 83 00    	call strlen			; get string length in C
0328+  025F 7E          	dec c
0329+  0260 FD 4E       	mov si, d
0330+  0262 12          	mov a, c
0331+  0263 FD 99       	shl a
0332+  0265 3B EB 00    	mov d, table_power
0333+  0268 59          	add d, a
0334+  0269 38 00 00    	mov c, 0
0335+  026C             strtoint_L0:
0336+  026C F6          	lodsb			; load ASCII to al
0337+  026D B9 00       	cmp al, 0
0338+  026F C6 82 02    	je strtoint_end
0339+  0272 6F 30       	sub al, $30		; make into integer
0340+  0274 22 00       	mov ah, 0
0341+  0276 2A          	mov b, [d]
0342+  0277 AC          	mul a, b			; result in B since it fits in 16bits
0343+  0278 11          	mov a, b
0344+  0279 28          	mov b, c
0345+  027A 54          	add a, b
0346+  027B 39          	mov c, a
0347+  027C 63 02 00    	sub d, 2
0348+  027F 0A 6C 02    	jmp strtoint_L0
0349+  0282             strtoint_end:
0350+  0282 12          	mov a, c
0351+  0283 E7          	pop d
0352+  0284 E6          	pop c
0353+  0285 E5          	pop b
0354+  0286 EF          	pop si
0355+  0287 09          	ret
0356+  0288             
0357+  0288             
0358+  0288             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  0288             ; PRINT NULL TERMINATED STRING
0360+  0288             ; pointer in D
0361+  0288             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  0288             puts:
0363+  0288 D7          	push a
0364+  0289 DA          	push d
0365+  028A             puts_L1:
0366+  028A 1E          	mov al, [d]
0367+  028B B9 00       	cmp al, 0
0368+  028D C6 99 02    	jz puts_END
0369+  0290 23          	mov ah, al
0370+  0291 19 00       	mov al, 0
0371+  0293 05 03       	syscall sys_io
0372+  0295 79          	inc d
0373+  0296 0A 8A 02    	jmp puts_L1
0374+  0299             puts_END:
0375+  0299 E7          	pop d
0376+  029A E4          	pop a
0377+  029B 09          	ret
0378+  029C             
0379+  029C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  029C             ; PRINT N SIZE STRING
0381+  029C             ; pointer in D
0382+  029C             ; size in C
0383+  029C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  029C             putsn:
0385+  029C DB          	push al
0386+  029D DA          	push d
0387+  029E D9          	push c
0388+  029F             putsn_L0:
0389+  029F 1E          	mov al, [d]
0390+  02A0 23          	mov ah, al
0391+  02A1 19 00       	mov al, 0
0392+  02A3 05 03       	syscall sys_io
0393+  02A5 79          	inc d
0394+  02A6 7E          	dec c	
0395+  02A7 C2 00 00    	cmp c, 0
0396+  02AA C7 9F 02    	jne putsn_L0
0397+  02AD             putsn_end:
0398+  02AD E6          	pop c
0399+  02AE E7          	pop d
0400+  02AF E8          	pop al
0401+  02B0 09          	ret
0402+  02B1             
0403+  02B1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  02B1             ; print 16bit decimal number
0405+  02B1             ; input number in A
0406+  02B1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  02B1             print_u16d:
0408+  02B1 D7          	push a
0409+  02B2 D8          	push b
0410+  02B3 26 10 27    	mov b, 10000
0411+  02B6 AE          	div a, b			; get 10000's coeff.
0412+  02B7 07 D9 02    	call print_number
0413+  02BA 11          	mov a, b
0414+  02BB 26 E8 03    	mov b, 1000
0415+  02BE AE          	div a, b			; get 1000's coeff.
0416+  02BF 07 D9 02    	call print_number
0417+  02C2 11          	mov a, b
0418+  02C3 26 64 00    	mov b, 100
0419+  02C6 AE          	div a, b
0420+  02C7 07 D9 02    	call print_number
0421+  02CA 11          	mov a, b
0422+  02CB 26 0A 00    	mov b, 10
0423+  02CE AE          	div a, b
0424+  02CF 07 D9 02    	call print_number
0425+  02D2 1B          	mov al, bl			; 1's coeff in bl
0426+  02D3 07 D9 02    	call print_number
0427+  02D6 E5          	pop b
0428+  02D7 E4          	pop a
0429+  02D8 09          	ret
0430+  02D9             
0431+  02D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0432+  02D9             ; print AL
0433+  02D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0434+  02D9             print_number:
0435+  02D9 6A 30       	add al, $30
0436+  02DB 23          	mov ah, al
0437+  02DC 07 4E 01    	call putchar
0438+  02DF 09          	ret
0439+  02E0             
0440+  02E0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0441+  02E0             ; PRINT 16BIT HEX INTEGER
0442+  02E0             ; integer value in reg B
0443+  02E0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0444+  02E0             print_u16x:
0445+  02E0 D7          	push a
0446+  02E1 D8          	push b
0447+  02E2 DD          	push bl
0448+  02E3 30          	mov bl, bh
0449+  02E4 07 15 01    	call itoa				; convert bh to char in A
0450+  02E7 2F          	mov bl, al				; save al
0451+  02E8 19 00       	mov al, 0
0452+  02EA 05 03       	syscall sys_io				; display AH
0453+  02EC 24          	mov ah, bl				; retrieve al
0454+  02ED 19 00       	mov al, 0
0455+  02EF 05 03       	syscall sys_io				; display AL
0456+  02F1             
0457+  02F1 EA          	pop bl
0458+  02F2 07 15 01    	call itoa				; convert bh to char in A
0459+  02F5 2F          	mov bl, al				; save al
0460+  02F6 19 00       	mov al, 0
0461+  02F8 05 03       	syscall sys_io				; display AH
0462+  02FA 24          	mov ah, bl				; retrieve al
0463+  02FB 19 00       	mov al, 0
0464+  02FD 05 03       	syscall sys_io				; display AL
0465+  02FF             
0466+  02FF E5          	pop b
0467+  0300 E4          	pop a
0468+  0301 09          	ret
0469+  0302             
0470+  0302             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0471+  0302             ; INPUT 16BIT HEX INTEGER
0472+  0302             ; read 16bit integer into A
0473+  0302             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0474+  0302             scan_u16x:
0475+  0302 F8 10 00    	enter 16
0476+  0305 D8          	push b
0477+  0306 DA          	push d
0478+  0307             
0479+  0307 FA F1 FF    	lea d, [bp + -15]
0480+  030A 07 55 01    	call gets				; get number
0481+  030D             
0482+  030D 32          	mov bl, [d]
0483+  030E 37          	mov bh, bl
0484+  030F 33 01 00    	mov bl, [d + 1]
0485+  0312 07 03 01    	call atoi				; convert to int in AL
0486+  0315 23          	mov ah, al				; move to AH
0487+  0316             
0488+  0316 33 02 00    	mov bl, [d + 2]
0489+  0319 37          	mov bh, bl
0490+  031A 33 03 00    	mov bl, [d + 3]
0491+  031D 07 03 01    	call atoi				; convert to int in AL
0492+  0320             
0493+  0320 E7          	pop d
0494+  0321 E5          	pop b
0495+  0322 F9          	leave
0496+  0323 09          	ret
0497+  0324             
0498+  0324             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0499+  0324             ; PRINT 8bit HEX INTEGER
0500+  0324             ; integer value in reg bl
0501+  0324             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0502+  0324             print_u8x:
0503+  0324 D7          	push a
0504+  0325 DD          	push bl
0505+  0326             
0506+  0326 07 15 01    	call itoa				; convert bl to char in A
0507+  0329 2F          	mov bl, al				; save al
0508+  032A 19 00       	mov al, 0
0509+  032C 05 03       	syscall sys_io				; display AH
0510+  032E 24          	mov ah, bl				; retrieve al
0511+  032F 19 00       	mov al, 0
0512+  0331 05 03       	syscall sys_io				; display AL
0513+  0333             
0514+  0333 EA          	pop bl
0515+  0334 E4          	pop a
0516+  0335 09          	ret
0517+  0336             
0518+  0336             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0519+  0336             ; print 8bit decimal unsigned number
0520+  0336             ; input number in AL
0521+  0336             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0522+  0336             print_u8d:
0523+  0336 D7          	push a
0524+  0337 D8          	push b
0525+  0338             
0526+  0338 22 00       	mov ah, 0
0527+  033A 26 64 00    	mov b, 100
0528+  033D AE          	div a, b
0529+  033E D8          	push b			; save remainder
0530+  033F B9 00       	cmp al, 0
0531+  0341 C6 4B 03    	je skip100
0532+  0344 6A 30       	add al, $30
0533+  0346 23          	mov ah, al
0534+  0347 19 00       	mov al, 0
0535+  0349 05 03       	syscall sys_io	; print coeff
0536+  034B             skip100:
0537+  034B E4          	pop a
0538+  034C 22 00       	mov ah, 0
0539+  034E 26 0A 00    	mov b, 10
0540+  0351 AE          	div a, b
0541+  0352 D8          	push b			; save remainder
0542+  0353 B9 00       	cmp al, 0
0543+  0355 C6 5F 03    	je skip10
0544+  0358 6A 30       	add al, $30
0545+  035A 23          	mov ah, al
0546+  035B 19 00       	mov al, 0
0547+  035D 05 03       	syscall sys_io	; print coeff
0548+  035F             skip10:
0549+  035F E4          	pop a
0550+  0360 1B          	mov al, bl
0551+  0361 6A 30       	add al, $30
0552+  0363 23          	mov ah, al
0553+  0364 19 00       	mov al, 0
0554+  0366 05 03       	syscall sys_io	; print coeff
0555+  0368 E5          	pop b
0556+  0369 E4          	pop a
0557+  036A 09          	ret
0558+  036B             
0559+  036B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0560+  036B             ; INPUT 8BIT HEX INTEGER
0561+  036B             ; read 8bit integer into AL
0562+  036B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0563+  036B             scan_u8x:
0564+  036B F8 04 00    	enter 4
0565+  036E D8          	push b
0566+  036F DA          	push d
0567+  0370             
0568+  0370 FA FD FF    	lea d, [bp + -3]
0569+  0373 07 55 01    	call gets				; get number
0570+  0376             
0571+  0376 32          	mov bl, [d]
0572+  0377 37          	mov bh, bl
0573+  0378 33 01 00    	mov bl, [d + 1]
0574+  037B 07 03 01    	call atoi				; convert to int in AL
0575+  037E             
0576+  037E E7          	pop d
0577+  037F E5          	pop b
0578+  0380 F9          	leave
0579+  0381 09          	ret
0580+  0382             
0581+  0382             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0582+  0382             ; input decimal number
0583+  0382             ; result in A
0584+  0382             ; 655'\0'
0585+  0382             ; low--------high
0586+  0382             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  0382             scan_u16d:
0588+  0382 F8 08 00    	enter 8
0589+  0385 E2          	push si
0590+  0386 D8          	push b
0591+  0387 D9          	push c
0592+  0388 DA          	push d
0593+  0389 FA F9 FF    	lea d, [bp +- 7]
0594+  038C 07 55 01    	call gets
0595+  038F 07 83 00    	call strlen			; get string length in C
0596+  0392 7E          	dec c
0597+  0393 FD 4E       	mov si, d
0598+  0395 12          	mov a, c
0599+  0396 FD 99       	shl a
0600+  0398 3B EB 00    	mov d, table_power
0601+  039B 59          	add d, a
0602+  039C 38 00 00    	mov c, 0
0603+  039F             mul_loop:
0604+  039F F6          	lodsb			; load ASCII to al
0605+  03A0 B9 00       	cmp al, 0
0606+  03A2 C6 B5 03    	je mul_exit
0607+  03A5 6F 30       	sub al, $30		; make into integer
0608+  03A7 22 00       	mov ah, 0
0609+  03A9 2A          	mov b, [d]
0610+  03AA AC          	mul a, b			; result in B since it fits in 16bits
0611+  03AB 11          	mov a, b
0612+  03AC 28          	mov b, c
0613+  03AD 54          	add a, b
0614+  03AE 39          	mov c, a
0615+  03AF 63 02 00    	sub d, 2
0616+  03B2 0A 9F 03    	jmp mul_loop
0617+  03B5             mul_exit:
0618+  03B5 12          	mov a, c
0619+  03B6 E7          	pop d
0620+  03B7 E6          	pop c
0621+  03B8 E5          	pop b
0622+  03B9 EF          	pop si
0623+  03BA F9          	leave
0624+  03BB 09          	ret
0169   03BC             .include "ctype.asm"
0001+  03BC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  03BC             ; ctype.s
0003+  03BC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  03BC             
0005+  03BC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  03BC             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  03BC             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  03BC             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  03BC             ;; characters are supported.
0010+  03BC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  03BC             ;; isalnum 
0012+  03BC             ;; isalpha 
0013+  03BC             ;; islower 
0014+  03BC             ;; isupper 
0015+  03BC             ;; isdigit 
0016+  03BC             ;; isxdigit
0017+  03BC             ;; iscntrl 
0018+  03BC             ;; isgraph 
0019+  03BC             ;; isspace 
0020+  03BC             ;; isblank 
0021+  03BC             ;; isprint 
0022+  03BC             ;; ispunct 
0023+  03BC             ;; tolower 
0024+  03BC             ;; toupper
0025+  03BC             
0026+  03BC             
0027+  03BC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  03BC             ;; IS ALPHANUMERIC
0029+  03BC             ;; sets ZF according with result
0030+  03BC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  03BC             isalnum:
0032+  03BC 07 D9 03    	call isalpha
0033+  03BF C6 C5 03    	je isalnum_exit
0034+  03C2 07 C6 03    	call isdigit
0035+  03C5             isalnum_exit:
0036+  03C5 09          	ret	
0037+  03C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  03C6             ;; IS DIGIT
0039+  03C6             ;; sets ZF according with result
0040+  03C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  03C6             isdigit:
0042+  03C6 DB          	push al
0043+  03C7 B9 30       	cmp al, '0'
0044+  03C9 C8 D5 03    	jlu isdigit_false
0045+  03CC B9 39       	cmp al, '9'
0046+  03CE D1 D5 03    	jgu isdigit_false
0047+  03D1 87 00       	and al, 0	; set ZF
0048+  03D3 E8          	pop al
0049+  03D4 09          	ret
0050+  03D5             isdigit_false:
0051+  03D5 8B 01       	or al, 1	; clear ZF
0052+  03D7 E8          	pop al
0053+  03D8 09          	ret	
0054+  03D9             	
0055+  03D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  03D9             ;; IS ALPHA
0057+  03D9             ;; sets ZF according with result
0058+  03D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  03D9             isalpha:
0060+  03D9 DB          	push al
0061+  03DA B9 5F       	cmp al, '_'
0062+  03DC C6 FC 03    	je isalpha_true
0063+  03DF B9 2E       	cmp al, '.'
0064+  03E1 C6 FC 03    	je isalpha_true
0065+  03E4 B9 41       	cmp al, 'A'
0066+  03E6 C8 F8 03    	jlu isalpha_false
0067+  03E9 B9 7A       	cmp al, 'z'
0068+  03EB D1 F8 03    	jgu isalpha_false
0069+  03EE B9 5A       	cmp al, 'Z'
0070+  03F0 D0 FC 03    	jleu isalpha_true
0071+  03F3 B9 61       	cmp al, 'a'
0072+  03F5 C9 FC 03    	jgeu isalpha_true
0073+  03F8             isalpha_false:
0074+  03F8 8B 01       	or al, 1	; clear ZF
0075+  03FA E8          	pop al
0076+  03FB 09          	ret
0077+  03FC             isalpha_true:
0078+  03FC 87 00       	and al, 0	; set ZF
0079+  03FE E8          	pop al
0080+  03FF 09          	ret
0081+  0400             
0082+  0400             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  0400             ;; IS PATH-ALPHA
0084+  0400             ;; sets ZF according with result
0085+  0400             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  0400             ispath:
0087+  0400 DB          	push al
0088+  0401 07 C6 03    	call isdigit
0089+  0404 C6 2E 04    	je ispath_true
0090+  0407 B9 5F       	cmp al, '_'
0091+  0409 C6 2E 04    	je ispath_true
0092+  040C B9 2F       	cmp al, '/'
0093+  040E C6 2E 04    	je ispath_true
0094+  0411 B9 2E       	cmp al, '.'
0095+  0413 C6 2E 04    	je ispath_true
0096+  0416 B9 41       	cmp al, 'A'
0097+  0418 C8 2A 04    	jlu ispath_false
0098+  041B B9 7A       	cmp al, 'z'
0099+  041D D1 2A 04    	jgu ispath_false
0100+  0420 B9 5A       	cmp al, 'Z'
0101+  0422 D0 2E 04    	jleu ispath_true
0102+  0425 B9 61       	cmp al, 'a'
0103+  0427 C9 2E 04    	jgeu ispath_true
0104+  042A             ispath_false:
0105+  042A 8B 01       	or al, 1	; clear ZF
0106+  042C E8          	pop al
0107+  042D 09          	ret
0108+  042E             ispath_true:
0109+  042E 87 00       	and al, 0	; set ZF
0110+  0430 E8          	pop al
0111+  0431 09          	ret
0112+  0432             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  0432             ;; IS SPACE
0114+  0432             ;; sets ZF according with result
0115+  0432             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  0432             isspace:
0117+  0432 B9 20       	cmp al, $20		; ' '
0118+  0434 C6 48 04    	je isspace_exit
0119+  0437 B9 09       	cmp al, $09		; '\t'
0120+  0439 C6 48 04    	je isspace_exit
0121+  043C B9 0A       	cmp al, $0A		; '\n'
0122+  043E C6 48 04    	je isspace_exit
0123+  0441 B9 0D       	cmp al, $0D		; '\r'
0124+  0443 C6 48 04    	je isspace_exit
0125+  0446 B9 0B       	cmp al, $0B		; '\v'
0126+  0448             isspace_exit:
0127+  0448 09          	ret	
0128+  0449             
0129+  0449             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0449             ; TO LOWER
0131+  0449             ; input in AL
0132+  0449             ; output in AL
0133+  0449             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  0449             to_lower:
0135+  0449 B9 5A       	cmp al, 'Z'
0136+  044B D1 50 04    	jgu to_lower_ret
0137+  044E 6A 20       	add al, $20				; convert to lower case
0138+  0450             to_lower_ret:
0139+  0450 09          	ret
0140+  0451             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  0451             ; TO UPPER
0142+  0451             ; input in AL
0143+  0451             ; output in AL
0144+  0451             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  0451             to_upper:
0146+  0451 B9 61       	cmp al, 'a'
0147+  0453 C8 58 04    	jlu to_upper_ret
0148+  0456 6F 20       	sub al, $20			; convert to upper case
0149+  0458             to_upper_ret:
0150+  0458 09          	ret
0151+  0459             
0170   0459             .include "token.asm"
0001+  0459             TOKTYP_IDENTIFIER	.equ 0
0002+  0459             TOKTYP_KEYWORD		.equ 1
0003+  0459             TOKTYP_DELIMITER	.equ 2
0004+  0459             TOKTYP_STRING		.equ 3
0005+  0459             TOKTYP_CHAR			.equ 4
0006+  0459             TOKTYP_NUMERIC		.equ 5
0007+  0459             TOKTYP_END			.equ 6
0008+  0459             
0009+  0459             TOK_NULL			.equ 0
0010+  0459             TOK_FSLASH			.equ 1
0011+  0459             TOK_TIMES 			.equ 2
0012+  0459             TOK_PLUS 			.equ 3
0013+  0459             TOK_MINUS 			.equ 4
0014+  0459             TOK_DOT				.equ 5
0015+  0459             TOK_SEMI			.equ 6
0016+  0459             TOK_ANGLE			.equ 7
0017+  0459             TOK_TILDE			.equ 8
0018+  0459             TOK_EQUAL			.equ 9
0019+  0459             TOK_COLON			.equ 10
0020+  0459             TOK_COMMA			.equ 11
0021+  0459             
0022+  0459             TOK_END				.equ 20
0023+  0459             
0024+  0459             
0025+  0459             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  0459             ;; read a full command argment from shell input buffer
0027+  0459             ;; argument is written into tokstr
0028+  0459             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  0459             get_arg:
0030+  0459 D7          	push a
0031+  045A E2          	push si
0032+  045B E3          	push di
0033+  045C 19 00       	mov al, 0
0034+  045E 3D 87 06    	mov [tokstr], al			; nullify tokstr string
0035+  0461 14 83 06    	mov a, [prog]
0036+  0464 4D          	mov si, a
0037+  0465 FD 4F 87 06 	mov di, tokstr
0038+  0469             get_arg_skip_spaces:
0039+  0469 F6          	lodsb
0040+  046A 07 32 04    	call isspace
0041+  046D C6 69 04    	je get_arg_skip_spaces
0042+  0470             get_arg_L0:
0043+  0470 B9 3B       	cmp al, $3B				; check if is ';'
0044+  0472 C6 7F 04    	je get_arg_end
0045+  0475 B9 00       	cmp al, 0
0046+  0477 C6 7F 04    	je get_arg_end			; check if end of input
0047+  047A F7          	stosb
0048+  047B F6          	lodsb
0049+  047C 0A 70 04    	jmp get_arg_L0
0050+  047F             get_arg_end:
0051+  047F 19 00       	mov al, 0
0052+  0481 F7          	stosb
0053+  0482 D5 01 00    	sub si, 1
0054+  0485 4E          	mov a, si
0055+  0486 42 83 06    	mov [prog], a		; update pointer
0056+  0489 F0          	pop di
0057+  048A EF          	pop si
0058+  048B E4          	pop a
0059+  048C 09          	ret
0060+  048D             
0061+  048D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  048D             ;; read a path formation from shell input buffer
0063+  048D             ;; path is written into tokstr
0064+  048D             ;; /usr/bin
0065+  048D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  048D             get_path:
0067+  048D D7          	push a
0068+  048E E2          	push si
0069+  048F E3          	push di
0070+  0490 19 00       	mov al, 0
0071+  0492 3D 87 06    	mov [tokstr], al			; nullify tokstr string
0072+  0495 14 83 06    	mov a, [prog]
0073+  0498 4D          	mov si, a
0074+  0499 FD 4F 87 06 	mov di, tokstr
0075+  049D             get_path_skip_spaces:
0076+  049D F6          	lodsb
0077+  049E 07 32 04    	call isspace
0078+  04A1 C6 9D 04    	je get_path_skip_spaces
0079+  04A4             get_path_is_pathchar:
0080+  04A4 F7          	stosb
0081+  04A5 F6          	lodsb
0082+  04A6 07 BC 03    	call isalnum			;check if is alphanumeric
0083+  04A9 C6 A4 04    	je get_path_is_pathchar
0084+  04AC B9 2F       	cmp al, '/'				; check if is '/'
0085+  04AE C6 A4 04    	je get_path_is_pathchar
0086+  04B1 19 00       	mov al, 0
0087+  04B3 F7          	stosb
0088+  04B4 D5 01 00    	sub si, 1
0089+  04B7 4E          	mov a, si
0090+  04B8 42 83 06    	mov [prog], a		; update pointer
0091+  04BB             get_path_end:
0092+  04BB F0          	pop di
0093+  04BC EF          	pop si
0094+  04BD E4          	pop a
0095+  04BE 09          	ret
0096+  04BF             
0097+  04BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  04BF             ;; read a line
0099+  04BF             ;; line is written into tokstr
0100+  04BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  04BF             get_line:
0102+  04BF D7          	push a
0103+  04C0 E2          	push si
0104+  04C1 E3          	push di
0105+  04C2 19 00       	mov al, 0
0106+  04C4 3D 87 06    	mov [tokstr], al			; nullify tokstr string
0107+  04C7 14 83 06    	mov a, [prog]
0108+  04CA 4D          	mov si, a
0109+  04CB FD 4F 87 06 	mov di, tokstr
0110+  04CF             get_line_L0:
0111+  04CF F6          	lodsb
0112+  04D0 B9 0A       	cmp al, $0A		; check for new line
0113+  04D2 C6 D9 04    	je get_line_exit
0114+  04D5 F7          	stosb
0115+  04D6 0A CF 04    	jmp get_line_L0
0116+  04D9             get_line_exit:
0117+  04D9 19 00       	mov al, 0
0118+  04DB F7          	stosb
0119+  04DC 4E          	mov a, si
0120+  04DD 42 83 06    	mov [prog], a		; update pointer
0121+  04E0 F0          	pop di
0122+  04E1 EF          	pop si
0123+  04E2 E4          	pop a
0124+  04E3 09          	ret
0125+  04E4             
0126+  04E4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  04E4             ;; token parser
0128+  04E4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  04E4             get_token:
0130+  04E4 D7          	push a
0131+  04E5 DA          	push d
0132+  04E6 E2          	push si
0133+  04E7 E3          	push di
0134+  04E8 19 00       	mov al, 0
0135+  04EA 3D 87 06    	mov [tokstr], al			; nullify tokstr string
0136+  04ED 19 00       	mov al, TOK_NULL
0137+  04EF 3D 86 06    	mov [tok], al				; nullify token
0138+  04F2 14 83 06    	mov a, [prog]
0139+  04F5 4D          	mov si, a
0140+  04F6 FD 4F 87 06 	mov di, tokstr
0141+  04FA             get_tok_skip_spaces:
0142+  04FA F6          	lodsb
0143+  04FB 07 32 04    	call isspace
0144+  04FE C6 FA 04    	je get_tok_skip_spaces
0145+  0501 B9 00       	cmp al, 0			; check for end of input (NULL)
0146+  0503 C6 E8 05    	je get_token_end
0147+  0506 B9 23       	cmp al, '#'			; comments!
0148+  0508 C6 16 06    	je get_tok_comment
0149+  050B 07 BC 03    	call isalnum
0150+  050E C6 F5 05    	jz is_alphanumeric
0151+  0511             ; other token types
0152+  0511             get_token_slash:
0153+  0511 B9 2F       	cmp al, '/'				; check if '/'
0154+  0513 C7 2B 05    	jne get_token_minus
0155+  0516 F7          	stosb					; store '/' into token string
0156+  0517 19 00       	mov al, 0
0157+  0519 F7          	stosb					; terminate token string
0158+  051A 19 01       	mov al, TOK_FSLASH
0159+  051C 3D 86 06    	mov [tok], al			
0160+  051F 19 02       	mov al, TOKTYP_DELIMITER
0161+  0521 3D 85 06    	mov [toktyp], al
0162+  0524 4E          	mov a, si
0163+  0525 42 83 06    	mov [prog], a		; update pointer
0164+  0528 0A 11 06    	jmp get_token_return
0165+  052B             get_token_minus:
0166+  052B B9 2D       	cmp al, '-'				; check if '-'
0167+  052D C7 45 05    	jne get_token_comma
0168+  0530 F7          	stosb					; store '-' into token string
0169+  0531 19 00       	mov al, 0
0170+  0533 F7          	stosb					; terminate token string
0171+  0534 19 04       	mov al, TOK_MINUS
0172+  0536 3D 86 06    	mov [tok], al			
0173+  0539 19 02       	mov al, TOKTYP_DELIMITER
0174+  053B 3D 85 06    	mov [toktyp], al
0175+  053E 4E          	mov a, si
0176+  053F 42 83 06    	mov [prog], a		; update pointer
0177+  0542 0A 11 06    	jmp get_token_return
0178+  0545             get_token_comma:
0179+  0545 B9 2C       	cmp al, ','				; check if ','
0180+  0547 C7 5F 05    	jne get_token_semi
0181+  054A F7          	stosb					; store ',' into token string
0182+  054B 19 00       	mov al, 0
0183+  054D F7          	stosb					; terminate token string
0184+  054E 19 0B       	mov al, TOK_COMMA
0185+  0550 3D 86 06    	mov [tok], al			
0186+  0553 19 02       	mov al, TOKTYP_DELIMITER
0187+  0555 3D 85 06    	mov [toktyp], al
0188+  0558 4E          	mov a, si
0189+  0559 42 83 06    	mov [prog], a		; update pointer
0190+  055C 0A 11 06    	jmp get_token_return
0191+  055F             get_token_semi:
0192+  055F B9 3B       	cmp al, $3B				; check if ';'
0193+  0561 C7 79 05    	jne get_token_colon
0194+  0564 F7          	stosb					; store ';' into token string
0195+  0565 19 00       	mov al, 0
0196+  0567 F7          	stosb					; terminate token string
0197+  0568 19 06       	mov al, TOK_SEMI
0198+  056A 3D 86 06    	mov [tok], al			
0199+  056D 19 02       	mov al, TOKTYP_DELIMITER
0200+  056F 3D 85 06    	mov [toktyp], al
0201+  0572 4E          	mov a, si
0202+  0573 42 83 06    	mov [prog], a		; update pointer
0203+  0576 0A 11 06    	jmp get_token_return
0204+  0579             get_token_colon:
0205+  0579 B9 3A       	cmp al, $3A				; check if ':'
0206+  057B C7 93 05    	jne get_token_angle
0207+  057E F7          	stosb					; store ':' into token string
0208+  057F 19 00       	mov al, 0
0209+  0581 F7          	stosb					; terminate token string
0210+  0582 19 0A       	mov al, TOK_COLON
0211+  0584 3D 86 06    	mov [tok], al			
0212+  0587 19 02       	mov al, TOKTYP_DELIMITER
0213+  0589 3D 85 06    	mov [toktyp], al
0214+  058C 4E          	mov a, si
0215+  058D 42 83 06    	mov [prog], a		; update pointer
0216+  0590 0A 11 06    	jmp get_token_return
0217+  0593             get_token_angle:
0218+  0593 B9 3E       	cmp al, $3E				; check if '>'
0219+  0595 C7 AD 05    	jne get_token_tilde
0220+  0598 F7          	stosb					; store '>' into token string
0221+  0599 19 00       	mov al, 0
0222+  059B F7          	stosb					; terminate token string
0223+  059C 19 07       	mov al, TOK_ANGLE
0224+  059E 3D 86 06    	mov [tok], al			
0225+  05A1 19 02       	mov al, TOKTYP_DELIMITER
0226+  05A3 3D 85 06    	mov [toktyp], al
0227+  05A6 4E          	mov a, si
0228+  05A7 42 83 06    	mov [prog], a		; update pointer
0229+  05AA 0A 11 06    	jmp get_token_return
0230+  05AD             get_token_tilde:
0231+  05AD B9 7E       	cmp al, '~'				; check if '~'
0232+  05AF C7 C7 05    	jne get_token_equal
0233+  05B2 F7          	stosb					; store '~' into token string
0234+  05B3 19 00       	mov al, 0
0235+  05B5 F7          	stosb					; terminate token string
0236+  05B6 19 08       	mov al, TOK_TILDE
0237+  05B8 3D 86 06    	mov [tok], al			
0238+  05BB 19 02       	mov al, TOKTYP_DELIMITER
0239+  05BD 3D 85 06    	mov [toktyp], al
0240+  05C0 4E          	mov a, si
0241+  05C1 42 83 06    	mov [prog], a		; update pointer
0242+  05C4 0A 11 06    	jmp get_token_return
0243+  05C7             get_token_equal:
0244+  05C7 B9 3D       	cmp al, '='				; check if '='
0245+  05C9 C7 E1 05    	jne get_token_skip
0246+  05CC F7          	stosb					; store '=' into token string
0247+  05CD 19 00       	mov al, 0
0248+  05CF F7          	stosb					; terminate token string
0249+  05D0 19 09       	mov al, TOK_EQUAL
0250+  05D2 3D 86 06    	mov [tok], al			
0251+  05D5 19 02       	mov al, TOKTYP_DELIMITER
0252+  05D7 3D 85 06    	mov [toktyp], al
0253+  05DA 4E          	mov a, si
0254+  05DB 42 83 06    	mov [prog], a		; update pointer
0255+  05DE 0A 11 06    	jmp get_token_return
0256+  05E1             get_token_skip:
0257+  05E1 4E          	mov a, si
0258+  05E2 42 83 06    	mov [prog], a		; update pointer
0259+  05E5 0A 11 06    	jmp get_token_return
0260+  05E8             get_token_end:				; end of file token
0261+  05E8 19 14       	mov al, TOK_END
0262+  05EA 3D 86 06    	mov [tok], al
0263+  05ED 19 06       	mov al, TOKTYP_END
0264+  05EF 3D 85 06    	mov [toktyp], al
0265+  05F2 0A 11 06    	jmp get_token_return
0266+  05F5             is_alphanumeric:
0267+  05F5 F7          	stosb
0268+  05F6 F6          	lodsb
0269+  05F7 07 BC 03    	call isalnum			;check if is alphanumeric
0270+  05FA C6 F5 05    	jz is_alphanumeric
0271+  05FD B9 2E       	cmp al, $2E				; check if is '.'
0272+  05FF C6 F5 05    	je is_alphanumeric
0273+  0602 19 00       	mov al, 0
0274+  0604 F7          	stosb
0275+  0605 19 00       	mov al, TOKTYP_IDENTIFIER
0276+  0607 3D 85 06    	mov [toktyp], al
0277+  060A D5 01 00    	sub si, 1
0278+  060D 4E          	mov a, si
0279+  060E 42 83 06    	mov [prog], a		; update pointer
0280+  0611             get_token_return:
0281+  0611 F0          	pop di
0282+  0612 EF          	pop si
0283+  0613 E7          	pop d
0284+  0614 E4          	pop a
0285+  0615 09          	ret
0286+  0616             get_tok_comment:
0287+  0616 F6          	lodsb
0288+  0617 B9 0A       	cmp al, $0A			; new line
0289+  0619 C7 16 06    	jne get_tok_comment
0290+  061C 0A FA 04    	jmp get_tok_skip_spaces
0291+  061F             
0292+  061F             
0293+  061F             get_number:
0294+  061F D7          	push a
0295+  0620 DA          	push d
0296+  0621 E2          	push si
0297+  0622 E3          	push di
0298+  0623 19 00       	mov al, 0
0299+  0625 3D 87 06    	mov [tokstr], al			; nullify tokstr string
0300+  0628 19 00       	mov al, TOK_NULL
0301+  062A 3D 86 06    	mov [tok], al				; nullify token
0302+  062D 14 83 06    	mov a, [prog]
0303+  0630 4D          	mov si, a
0304+  0631 FD 4F 87 06 	mov di, tokstr
0305+  0635             get_number_skip_spaces:
0306+  0635 F6          	lodsb
0307+  0636 07 32 04    	call isspace
0308+  0639 C6 35 06    	je get_number_skip_spaces
0309+  063C B9 00       	cmp al, 0			; check for end of input (NULL)
0310+  063E C7 4E 06    	jne get_number_L0
0311+  0641 19 14       	mov al, TOK_END
0312+  0643 3D 86 06    	mov [tok], al
0313+  0646 19 06       	mov al, TOKTYP_END
0314+  0648 3D 85 06    	mov [toktyp], al
0315+  064B 0A 65 06    	jmp get_number_return
0316+  064E             get_number_L0:
0317+  064E F7          	stosb
0318+  064F F6          	lodsb
0319+  0650 07 C6 03    	call isdigit			;check if is numeric
0320+  0653 C6 4E 06    	jz get_number_L0
0321+  0656 19 00       	mov al, 0
0322+  0658 F7          	stosb
0323+  0659 19 05       	mov al, TOKTYP_NUMERIC
0324+  065B 3D 85 06    	mov [toktyp], al
0325+  065E D5 01 00    	sub si, 1
0326+  0661 4E          	mov a, si
0327+  0662 42 83 06    	mov [prog], a		; update pointer
0328+  0665             get_number_return:
0329+  0665 F0          	pop di
0330+  0666 EF          	pop si
0331+  0667 E7          	pop d
0332+  0668 E4          	pop a
0333+  0669 09          	ret
0334+  066A             
0335+  066A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  066A             ;; PUT BACK TOKEN
0337+  066A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
0338+  066A             putback:
0339+  066A D7          	push a
0340+  066B E2          	push si
0341+  066C FD 4D 87 06 	mov si, tokstr	
0342+  0670             putback_loop:
0343+  0670 F6          	lodsb
0344+  0671 B9 00       	cmp al, 0
0345+  0673 C6 80 06    	je putback_end
0346+  0676 14 83 06    	mov a, [prog]
0347+  0679 7D          	dec a
0348+  067A 42 83 06    	mov [prog], a			; update pointer
0349+  067D 0A 70 06    	jmp putback_loop
0350+  0680             putback_end:
0351+  0680 EF          	pop si
0352+  0681 E4          	pop a
0353+  0682 09          	ret
0354+  0683             
0355+  0683             
0356+  0683             
0357+  0683             
0358+  0683 00 00       prog:		.dw 0			; pointer to current position in buffer
0359+  0685             
0360+  0685 00          toktyp: 	.db 0			; token type symbol
0361+  0686 00          tok:		.db 0			; current token symbol
0362+  0687 00 00 00 00 tokstr:		.fill 256, 0	; token as a string
0362+  068B 00 00 00 00 
0362+  068F 00 00 00 00 
0362+  0693 00 00 00 00 
0362+  0697 00 00 00 00 
0362+  069B 00 00 00 00 
0362+  069F 00 00 00 00 
0362+  06A3 00 00 00 00 
0362+  06A7 00 00 00 00 
0362+  06AB 00 00 00 00 
0362+  06AF 00 00 00 00 
0362+  06B3 00 00 00 00 
0362+  06B7 00 00 00 00 
0362+  06BB 00 00 00 00 
0362+  06BF 00 00 00 00 
0362+  06C3 00 00 00 00 
0362+  06C7 00 00 00 00 
0362+  06CB 00 00 00 00 
0362+  06CF 00 00 00 00 
0362+  06D3 00 00 00 00 
0362+  06D7 00 00 00 00 
0362+  06DB 00 00 00 00 
0362+  06DF 00 00 00 00 
0362+  06E3 00 00 00 00 
0362+  06E7 00 00 00 00 
0362+  06EB 00 00 00 00 
0362+  06EF 00 00 00 00 
0362+  06F3 00 00 00 00 
0362+  06F7 00 00 00 00 
0362+  06FB 00 00 00 00 
0362+  06FF 00 00 00 00 
0362+  0703 00 00 00 00 
0362+  0707 00 00 00 00 
0362+  070B 00 00 00 00 
0362+  070F 00 00 00 00 
0362+  0713 00 00 00 00 
0362+  0717 00 00 00 00 
0362+  071B 00 00 00 00 
0362+  071F 00 00 00 00 
0362+  0723 00 00 00 00 
0362+  0727 00 00 00 00 
0362+  072B 00 00 00 00 
0362+  072F 00 00 00 00 
0362+  0733 00 00 00 00 
0362+  0737 00 00 00 00 
0362+  073B 00 00 00 00 
0362+  073F 00 00 00 00 
0362+  0743 00 00 00 00 
0362+  0747 00 00 00 00 
0362+  074B 00 00 00 00 
0362+  074F 00 00 00 00 
0362+  0753 00 00 00 00 
0362+  0757 00 00 00 00 
0362+  075B 00 00 00 00 
0362+  075F 00 00 00 00 
0362+  0763 00 00 00 00 
0362+  0767 00 00 00 00 
0362+  076B 00 00 00 00 
0362+  076F 00 00 00 00 
0362+  0773 00 00 00 00 
0362+  0777 00 00 00 00 
0362+  077B 00 00 00 00 
0362+  077F 00 00 00 00 
0362+  0783 00 00 00 00 
0171   0787             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0172   0787             
0173   0787             sys_bkpt			.equ 0
0174   0787             sys_rtc				.equ 1
0175   0787             sys_IDE				.equ 2
0176   0787             sys_io				.equ 3
0177   0787             sys_fileio			.equ 4
0178   0787             sys_fork			.equ 5
0179   0787             sys_list			.equ 6
0180   0787             sys_datetime		.equ 7
0181   0787             sys_reboot			.equ 8
0182   0787             sys_pauseproc		.equ 9
0183   0787             sys_resumeproc		.equ 10
0184   0787             sys_terminate_proc	.equ 11
0185   0787             sys_system			.equ 12
0186   0787             sys_boot_install	.equ 13
0187   0787             
0188   0787             .export PROC_TEXT_ORG
0189   0787             .export sys_bkpt
0190   0787             .export sys_IDE
0191   0787             .export sys_io
0192   0787             .export sys_fileio
0193   0787             .export sys_fork
0194   0787             .export sys_list
0195   0787             .export sys_rtc
0196   0787             .export sys_datetime
0197   0787             .export sys_reboot
0198   0787             .export sys_pauseproc
0199   0787             .export sys_resumeproc
0200   0787             .export sys_terminate_proc
0201   0787             .export sys_system
0202   0787             .export sys_boot_install
0203   0787             
0204   0787             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0205   0787             ; EXTERNAL INTERRUPTS' CODE BLOCK
0206   0787             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0207   0787             ; uart
0208   0787             int_0:
0209   0787 06          	sysret
0210   0788             int_1:
0211   0788 06          	sysret
0212   0789             int_2:
0213   0789 06          	sysret
0214   078A             int_3:
0215   078A 06          	sysret
0216   078B             int_4:
0217   078B 06          	sysret
0218   078C             int_5:
0219   078C 06          	sysret
0220   078D             int_6:	
0221   078D             ; save all registers into kernel stack
0222   078D 4B          	pusha
0223   078E 22 00       	mov ah, 0
0224   0790 1D 27 16    	mov al, [active_proc_index]
0225   0793 FD 99       	shl a							; x2
0226   0795 B7 E5 15    	mov a, [proc_table_convert + a]	; get process state start index
0227   0798             		
0228   0798 4F          	mov di, a
0229   0799 48          	mov a, sp
0230   079A 77          	inc a
0231   079B 4D          	mov si, a
0232   079C 38 14 00    	mov c, 20
0233   079F FD F5       	rep movsb					; save process state!
0234   07A1             ; restore kernel stack position to point before interrupt arrived
0235   07A1 51 14 00    	add sp, 20
0236   07A4             ; now load next process in queue
0237   07A4 1D 27 16    	mov al, [active_proc_index]
0238   07A7 31 26 16    	mov bl, [nbr_active_procs]
0239   07AA BA          	cmp al, bl
0240   07AB C6 B2 07    	je int6_cycle_back
0241   07AE 7A          	inc al						; next process is next in the series
0242   07AF 0A B4 07    	jmp int6_continue
0243   07B2             int6_cycle_back:
0244   07B2 19 01       	mov al, 1				; next process = process 1
0245   07B4             int6_continue:
0246   07B4 3D 27 16    	mov [active_proc_index], al		; set next active proc
0247   07B7             
0248   07B7             ; calculate LUT entry for next process
0249   07B7 22 00       	mov ah, 0
0250   07B9 FD 99       	shl a							; x2
0251   07BB B7 E5 15    	mov a, [proc_table_convert + a]		; get process state start index	
0252   07BE             	
0253   07BE 4D          	mov si, a						; source is proc state block
0254   07BF 48          	mov a, sp
0255   07C0 5F 13 00    	sub a, 19
0256   07C3 4F          	mov di, a						; destination is kernel stack
0257   07C4             ; restore SP
0258   07C4 7D          	dec a
0259   07C5 47          	mov sp, a
0260   07C6 38 14 00    	mov c, 20
0261   07C9 FD F5       	rep movsb
0262   07CB             ; set VM process
0263   07CB 1D 27 16    	mov al, [active_proc_index]
0264   07CE 01          	setptb
0265   07CF             		
0266   07CF F2 E0 FF 00 	mov byte[_TIMER_C_0], 0				; load counter 0 low byte
0267   07D3 F2 E0 FF 10 	mov byte[_TIMER_C_0], $10				; load counter 0 high byte
0268   07D7             			
0269   07D7 4C          	popa
0270   07D8 06          	sysret
0271   07D9             
0272   07D9             int_7:
0273   07D9 D7          	push a
0274   07DA DA          	push d
0275   07DB E1          	pushf
0276   07DC             			
0277   07DC 14 2C 16    	mov a, [fifo_pi]
0278   07DF 3C          	mov d, a
0279   07E0             
0280   07E0 1D 80 FF    	mov al, [_UART0_DATA]	; get character
0281   07E3 B9 03       	cmp al, $03				; CTRL-C
0282   07E5 C6 02 08    	je CTRLC
0283   07E8 B9 1A       	cmp al, $1A				; CTRL-Z
0284   07EA C6 08 08    	je CTRLZ
0285   07ED 3E          	mov [d], al				; add to fifo
0286   07EE             	
0287   07EE 14 2C 16    	mov a, [fifo_pi]
0288   07F1 77          	inc a
0289   07F2 AF DA 26    	cmp a, fifo + FIFO_SIZE 				; check if pointer reached the end of the fifo
0290   07F5 C7 FB 07    	jne int_7_continue
0291   07F8 10 DA 1E    	mov a, fifo	
0292   07FB             int_7_continue:	
0293   07FB 42 2C 16    	mov [fifo_pi], a			; update fifo pointer
0294   07FE             	
0295   07FE EE          	popf
0296   07FF E7          	pop d
0297   0800 E4          	pop a	
0298   0801 06          	sysret
0299   0802             
0300   0802             CTRLC:
0301   0802 EE          	popf
0302   0803 E7          	pop d
0303   0804 E4          	pop a
0304   0805 0A EF 14    	jmp cmd_terminate_proc
0305   0808             
0306   0808             CTRLZ:
0307   0808 EE          	popf
0308   0809 E7          	pop d
0309   080A E4          	pop a
0310   080B 0A 32 15    	jmp cmd_pause_proc		; pause current process and go back to the shell
0311   080E             
0312   080E             cmd_system_jmptbl:
0313   080E 16 08       	.dw cmd_system_uname
0314   0810 1D 08       	.dw cmd_system_whoami
0315   0812             
0316   0812             cmd_system:
0317   0812 FD 0A 0E 08 	jmp [cmd_system_jmptbl + al]
0318   0816             cmd_system_uname:
0319   0816 3B 64 16    	mov d, s_uname
0320   0819 07 88 02    	call puts
0321   081C 06          	sysret
0322   081D             cmd_system_whoami:
0323   081D 3B 6E 16    	mov d, s_root
0324   0820 07 88 02    	call puts
0325   0823 06          	sysret
0326   0824             
0327   0824             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0328   0824             ; REBOOT SYSTEM
0329   0824             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0330   0824             syscall_reboot:
0331   0824 FD D7 FF FF 	push word $FFFF 
0332   0828 FD DB 00    	push byte %00000000				; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
0333   082B FD D7 C0 01 	push word BIOS_RESET_VECTOR		; and then push RESET VECTOR of the shell to the stack
0334   082F 06          	sysret
0335   0830             
0336   0830             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0337   0830             ;; switch to another process
0338   0830             ;; inputs:
0339   0830             ;; AL = new process number
0340   0830             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0341   0830             resume_proc:
0342   0830 FD 78       	mov g, a	; save the process number
0343   0832             ; save all registers into kernel stack
0344   0832 4B          	pusha
0345   0833 22 00       	mov ah, 0
0346   0835 1D 27 16    	mov al, [active_proc_index]
0347   0838 FD 99       	shl a							; x2
0348   083A B7 E5 15    	mov a, [proc_table_convert + a]	; get process state start index
0349   083D 4F          	mov di, a
0350   083E 48          	mov a, sp
0351   083F 77          	inc a
0352   0840 4D          	mov si, a
0353   0841 38 14 00    	mov c, 20
0354   0844 FD F5       	rep movsb					; save process state!
0355   0846             ; restore kernel stack position to point before interrupt arrived
0356   0846 51 14 00    	add sp, 20
0357   0849             ; now load the new process number!
0358   0849 FD 12       	mov a, g						; retrieve the process number argument that was saved in the beginning
0359   084B 3D 27 16    	mov [active_proc_index], al		; set new active proc
0360   084E             ; calculate LUT entry for next process
0361   084E 22 00       	mov ah, 0
0362   0850 FD 99       	shl a							; x2
0363   0852 B7 E5 15    	mov a, [proc_table_convert + a]		; get process state start index	
0364   0855             	
0365   0855 4D          	mov si, a						; source is proc state block
0366   0856 48          	mov a, sp
0367   0857 5F 13 00    	sub a, 19
0368   085A 4F          	mov di, a						; destination is kernel stack
0369   085B             ; restore SP
0370   085B 7D          	dec a
0371   085C 47          	mov sp, a
0372   085D 38 14 00    	mov c, 20
0373   0860 FD F5       	rep movsb
0374   0862             ; set VM process
0375   0862 1D 27 16    	mov al, [active_proc_index]
0376   0865 01          	setptb
0377   0866             			
0378   0866 4C          	popa
0379   0867 06          	sysret
0380   0868             
0381   0868             
0382   0868             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0383   0868             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384   0868             list_procs:
0385   0868 3B 50 16    	mov d, s_ps_header
0386   086B 07 88 02    	call puts
0387   086E 3B CB 18    	mov d, proc_availab_table + 1
0388   0871 38 01 00    	mov c, 1
0389   0874             list_procs_L0:	
0390   0874 BD 01       	cmp byte[d], 1
0391   0876 C7 9A 08    	jne list_procs_next
0392   0879 2D          	mov b, d
0393   087A 61 CA 18    	sub b, proc_availab_table
0394   087D FD 9F 05    	shl b, 5
0395   0880 DA          	push d
0396   0881 D8          	push b
0397   0882 28          	mov b, c
0398   0883 07 24 03    	call print_u8x
0399   0886 22 20       	mov ah, ' '
0400   0888 07 4E 01    	call putchar
0401   088B 07 4E 01    	call putchar
0402   088E E5          	pop b
0403   088F 74          	mov d, b
0404   0890 58 DA 18    	add d, proc_names
0405   0893 07 88 02    	call puts
0406   0896 07 35 02    	call printnl
0407   0899 E7          	pop d
0408   089A             list_procs_next:
0409   089A 79          	inc d
0410   089B 78          	inc c
0411   089C C2 09 00    	cmp c, 9
0412   089F C7 74 08    	jne list_procs_L0
0413   08A2             list_procs_end:
0414   08A2 06          	sysret
0415   08A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0416   08A3             ; PRIVILEGE EXCEPTION
0417   08A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418   08A3             trap_privilege:
0419   08A3 0A 24 08    	jmp syscall_reboot
0420   08A6 DA          	push d
0421   08A7             
0422   08A7 3B BC 16    	mov d, s_priviledge
0423   08AA 07 88 02    	call puts
0424   08AD             
0425   08AD E7          	pop d
0426   08AE             	
0427   08AE 06          	sysret
0428   08AF             
0429   08AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0430   08AF             ; BREAKPOINT EXCEPTION
0431   08AF             ; IMPORTANT: values in the stack are being pushed in big endian. i.e.: MSB at low address
0432   08AF             ; and LSB at high address. *** NEED TO CORRECT THIS IN THE MICROCODE and make it little endian again ***
0433   08AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0434   08AF             trap_breakpoint:
0435   08AF 4B          	pusha
0436   08B0             trap_break_prompt:
0437   08B0 3B 6A 09    	mov d, s_break1
0438   08B3 07 88 02    	call puts
0439   08B6 07 35 02    	call printnl
0440   08B9 07 82 03    	call scan_u16d
0441   08BC AF 00 00    	cmp a, 0
0442   08BF C6 CA 08    	je trap_break_regs
0443   08C2 AF 01 00    	cmp a, 1
0444   08C5 C6 ED 08    	je trap_break_mem
0445   08C8             trap_break_end:	
0446   08C8 4C          	popa
0447   08C9 06          	sysret
0448   08CA             trap_break_regs:
0449   08CA 48          	mov a, sp
0450   08CB 53 0E 00    	add a, 14	; back-track 7 registers
0451   08CE 3C          	mov d, a
0452   08CF 3A 07       	mov cl, 7
0453   08D1             trap_regs_L0:
0454   08D1 2A          	mov b, [d]
0455   08D2 FD AB       	swp b
0456   08D4 07 E0 02    	call print_u16x	; print register value
0457   08D7 07 35 02    	call printnl
0458   08DA 63 02 00    	sub d, 2
0459   08DD 71 01       	sub cl, 1
0460   08DF C3 00       	cmp cl, 0
0461   08E1 C7 D1 08    	jne trap_regs_L0
0462   08E4 0A B0 08    	jmp trap_break_prompt
0463   08E7 07 35 02    	call printnl
0464   08EA 0A B0 08    	jmp trap_break_prompt
0465   08ED             trap_break_mem:
0466   08ED 07 35 02    	call printnl
0467   08F0 07 02 03    	call scan_u16x
0468   08F3 4D          	mov si, a			; data source from user space
0469   08F4 FD 4F DA 26 	mov di, scrap_sector		; destination in kernel space
0470   08F8 38 00 02    	mov c, 512
0471   08FB 04          	load				; transfer data to kernel space!
0472   08FC 3B DA 26    	mov d, scrap_sector		; dump pointer in d
0473   08FF 38 00 00    	mov c, 0
0474   0902             dump_loop:
0475   0902 84          	mov al, cl
0476   0903 87 0F       	and al, $0F
0477   0905 C6 53 09    	jz print_base
0478   0908             back:
0479   0908 1E          	mov al, [d]				; read byte
0480   0909 2F          	mov bl, al
0481   090A 07 24 03    	call print_u8x
0482   090D 10 00 20    	mov a, $2000
0483   0910 05 03       	syscall sys_io			; space
0484   0912 84          	mov al, cl
0485   0913 87 0F       	and al, $0F
0486   0915 B9 0F       	cmp al, $0F
0487   0917 C6 28 09    	je print_ascii
0488   091A             back1:
0489   091A 79          	inc d
0490   091B 78          	inc c
0491   091C C2 00 02    	cmp c, 512
0492   091F C7 02 09    	jne dump_loop
0493   0922 07 35 02    	call printnl
0494   0925 0A B0 08    	jmp trap_break_prompt	; go to trap_breakpoint return point
0495   0928             print_ascii:
0496   0928 10 00 20    	mov a, $2000
0497   092B 05 03       	syscall sys_io
0498   092D 63 10 00    	sub d, 16
0499   0930 26 10 00    	mov b, 16
0500   0933             print_ascii_L:
0501   0933 79          	inc d
0502   0934 1E          	mov al, [d]				; read byte
0503   0935 B9 20       	cmp al, $20
0504   0937 C8 3F 09    	jlu dot
0505   093A B9 7E       	cmp al, $7E
0506   093C D0 47 09    	jleu ascii
0507   093F             dot:
0508   093F 10 00 2E    	mov a, $2E00
0509   0942 05 03       	syscall sys_io
0510   0944 0A 4C 09    	jmp ascii_continue
0511   0947             ascii:
0512   0947 23          	mov ah, al
0513   0948 19 00       	mov al, 0
0514   094A 05 03       	syscall sys_io
0515   094C             ascii_continue:
0516   094C FD A9 33 09 	loopb print_ascii_L
0517   0950 0A 1A 09    	jmp back1
0518   0953             print_base:
0519   0953 07 35 02    	call printnl
0520   0956 2D          	mov b, d
0521   0957 61 DA 26    	sub b, scrap_sector			; remove this later and fix address bases which display incorrectly
0522   095A 07 E0 02    	call print_u16x				; display row
0523   095D 10 00 3A    	mov a, $3A00
0524   0960 05 03       	syscall sys_io
0525   0962 10 00 20    	mov a, $2000
0526   0965 05 03       	syscall sys_io
0527   0967 0A 08 09    	jmp back
0528   096A             
0529   096A 0A 44 65 62 s_break1:	.db "\nDebugger entry point.\n"
0529   096E 75 67 67 65 
0529   0972 72 20 65 6E 
0529   0976 74 72 79 20 
0529   097A 70 6F 69 6E 
0529   097E 74 2E 0A 
0530   0981 30 2E 20 53 			.db "0. Show Registers\n"
0530   0985 68 6F 77 20 
0530   0989 52 65 67 69 
0530   098D 73 74 65 72 
0530   0991 73 0A 
0531   0993 31 2E 20 53 			.db "1. Show 512B RAM block\n"
0531   0997 68 6F 77 20 
0531   099B 35 31 32 42 
0531   099F 20 52 41 4D 
0531   09A3 20 62 6C 6F 
0531   09A7 63 6B 0A 
0532   09AA 32 2E 20 43 			.db "2. Continue Execution", 0
0532   09AE 6F 6E 74 69 
0532   09B2 6E 75 65 20 
0532   09B6 45 78 65 63 
0532   09BA 75 74 69 6F 
0532   09BE 6E 00 
0533   09C0             
0534   09C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535   09C0             ; DIVIDE BY ZERO EXCEPTION
0536   09C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0537   09C0             trap_div_zero:
0538   09C0 D7          	push a
0539   09C1 DA          	push d
0540   09C2 E1          	pushf
0541   09C3             		
0542   09C3 3B E4 16    	mov d, s_divzero
0543   09C6 07 88 02    	call puts
0544   09C9             	
0545   09C9 EE          	popf
0546   09CA E7          	pop d
0547   09CB E4          	pop a
0548   09CC             							; enable interrupts
0549   09CC 06          	sysret
0550   09CD             
0551   09CD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0552   09CD             ; UNDEFINED OPCODE EXCEPTION
0553   09CD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0554   09CD             undefined_opcode:
0555   09CD 06          	sysret
0556   09CE             
0557   09CE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0558   09CE             ; RTC SERVICES INTERRUPT
0559   09CE             ; RTC I/O bank = FFA0 to FFAF
0560   09CE             ; FFA0 to FFA7 is scratch RAM
0561   09CE             ; control register at $FFA8 [ W | R | S | Cal4..Cal0 ]
0562   09CE             ; al = 0..6 -> get
0563   09CE             ; al = 7..D -> set
0564   09CE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0565   09CE             rtc_services:
0566   09CE DB          	push al
0567   09CF DA          	push d
0568   09D0 B9 06       	cmp al, 6
0569   09D2 D1 E7 09    	jgu rtc_set
0570   09D5             rtc_get:
0571   09D5 6A A9       	add al, $A9			; generate RTC address to get to address A9 of clock
0572   09D7 22 FF       	mov ah, $FF		
0573   09D9 3C          	mov d, a				; get to FFA9 + offset
0574   09DA F2 A8 FF 40 	mov byte[$FFA8], $40		; set R bit to 1
0575   09DE 1E          	mov al, [d]			; get data
0576   09DF F2 A8 FF 00 	mov byte[$FFA8], 0		; reset R bit
0577   09E3 23          	mov ah, al
0578   09E4 E7          	pop d
0579   09E5 E8          	pop al
0580   09E6 06          	sysret
0581   09E7             rtc_set:
0582   09E7 DD          	push bl
0583   09E8 99          	mov bl, ah		; set data asIDE
0584   09E9 6A A2       	add al, $A2		; generate RTC address to get to address A9 of clock
0585   09EB 22 FF       	mov ah, $FF		
0586   09ED 3C          	mov d, a		; get to FFA9 + offset
0587   09EE 1B          	mov al, bl		; get data back
0588   09EF F2 A8 FF 80 	mov byte[$FFA8], $80	; set W bit to 1
0589   09F3 3E          	mov [d], al		; set data
0590   09F4 F2 A8 FF 00 	mov byte[$FFA8], 0		; reset write bit
0591   09F8 EA          	pop bl
0592   09F9 E7          	pop d
0593   09FA E8          	pop al
0594   09FB 06          	sysret
0595   09FC             
0596   09FC             datetime_serv_tbl:
0597   09FC 04 0A       	.dw print_date
0598   09FE 78 0A       	.dw set_date
0599   0A00             datetime_services:
0600   0A00 FD 0A FC 09 	jmp [datetime_serv_tbl + al]			
0601   0A04             print_date:
0602   0A04 10 00 0D    	mov a, $0D00				; print carriage return char
0603   0A07 19 03       	mov al, 3
0604   0A09 05 01       	syscall sys_rtc				; get week
0605   0A0B 1A          	mov al, ah
0606   0A0C 22 00       	mov ah, 0
0607   0A0E FD 9D 02    	shl a, 2					
0608   0A11 3B 6E 17    	mov d, s_week
0609   0A14 59          	add d, a
0610   0A15 07 88 02    	call puts
0611   0A18 10 00 20    	mov a, $2000
0612   0A1B 05 03       	syscall sys_io					; display ' '
0613   0A1D             	
0614   0A1D 19 04       	mov al, 4
0615   0A1F 05 01       	syscall sys_rtc					; get day
0616   0A21 99          	mov bl, ah
0617   0A22 07 24 03    	call print_u8x
0618   0A25 10 00 20    	mov a, $2000
0619   0A28 05 03       	syscall sys_io					; display ' '
0620   0A2A             ; there is a problem with the month displaying
0621   0A2A             ; the month is stored as BCD. so when retrieving the month, the value will be in binary
0622   0A2A             ; even though it is to be understood as BCD.
0623   0A2A             ; when retrieving the value and adding the string table address offset the value will go overboard!	
0624   0A2A 19 05       	mov al, 05
0625   0A2C 05 01       	syscall sys_rtc				; get month
0626   0A2E 1A          	mov al, ah
0627   0A2F 22 00       	mov ah, 0
0628   0A31 FD 9D 02    	shl a, 2					
0629   0A34 3B 3A 17    	mov d, s_months
0630   0A37 59          	add d, a
0631   0A38 07 88 02    	call puts
0632   0A3B             	
0633   0A3B 10 00 20    	mov a, $2000
0634   0A3E 05 03       	syscall sys_io			; display ' '
0635   0A40             	
0636   0A40 2E 20       	mov bl, $20
0637   0A42 07 24 03    	call print_u8x			; print 20 for year prefix
0638   0A45 19 06       	mov al, 06
0639   0A47 05 01       	syscall sys_rtc					; get year
0640   0A49 99          	mov bl, ah
0641   0A4A 07 24 03    	call print_u8x
0642   0A4D             	
0643   0A4D 10 00 20    	mov a, $2000	
0644   0A50 05 03       	syscall sys_io			; display ' '
0645   0A52             
0646   0A52 19 02       	mov al, 2
0647   0A54 05 01       	syscall sys_rtc					; get hours
0648   0A56 99          	mov bl, ah
0649   0A57 07 24 03    	call print_u8x
0650   0A5A 10 00 3A    	mov a, $3A00		
0651   0A5D 05 03       	syscall sys_io				; display ':'
0652   0A5F             
0653   0A5F 19 01       	mov al, 01
0654   0A61 05 01       	syscall sys_rtc					; get minutes
0655   0A63 99          	mov bl, ah
0656   0A64 07 24 03    	call print_u8x
0657   0A67 10 00 3A    	mov a, $3A00	
0658   0A6A 05 03       	syscall sys_io			; display ':'
0659   0A6C             
0660   0A6C 19 00       	mov al, 0
0661   0A6E 05 01       	syscall sys_rtc					; get seconds
0662   0A70 99          	mov bl, ah
0663   0A71 07 24 03    	call print_u8x
0664   0A74             	
0665   0A74 07 35 02    	call printnl
0666   0A77 06          	sysret
0667   0A78             	
0668   0A78             set_date:
0669   0A78 3B FF 16    	mov d, s_set_year
0670   0A7B 07 88 02    	call puts
0671   0A7E 07 6B 03    	call scan_u8x				; read integer into A
0672   0A81 FD 9D 08    	shl a, 8				; only AL used, move to AH
0673   0A84 19 0D       	mov al, 0Dh				; set RTC year
0674   0A86 05 01       	syscall sys_rtc					; set RTC
0675   0A88             	
0676   0A88 3B 06 17    	mov d, s_set_month
0677   0A8B 07 88 02    	call puts
0678   0A8E 07 6B 03    	call scan_u8x					; read integer into A
0679   0A91 FD 9D 08    	shl a, 8				; only AL used, move to AH
0680   0A94 19 0C       	mov al, 0Ch				; set RTC month
0681   0A96 05 01       	syscall sys_rtc					; set RTC
0682   0A98             
0683   0A98 3B 0E 17    	mov d, s_set_day
0684   0A9B 07 88 02    	call puts
0685   0A9E 07 6B 03    	call scan_u8x					; read integer into A
0686   0AA1 FD 9D 08    	shl a, 8				; only AL used, move to AH
0687   0AA4 19 0B       	mov al, 0Bh				; set RTC month
0688   0AA6 05 01       	syscall sys_rtc					; set RTC
0689   0AA8             
0690   0AA8 3B 14 17    	mov d, s_set_week
0691   0AAB 07 88 02    	call puts
0692   0AAE 07 6B 03    	call scan_u8x					; read integer into A
0693   0AB1 FD 9D 08    	shl a, 8				; only AL used, move to AH
0694   0AB4 19 0A       	mov al, 0Ah				; set RTC month
0695   0AB6 05 01       	syscall sys_rtc					; set RTC
0696   0AB8             
0697   0AB8 3B 1E 17    	mov d, s_set_hours
0698   0ABB 07 88 02    	call puts
0699   0ABE 07 6B 03    	call scan_u8x					; read integer into A
0700   0AC1 FD 9D 08    	shl a, 8				; only AL used, move to AH
0701   0AC4 19 09       	mov al, 09h				; set RTC month
0702   0AC6 05 01       	syscall sys_rtc					; set RTC
0703   0AC8             
0704   0AC8 3B 26 17    	mov d, s_set_minutes
0705   0ACB 07 88 02    	call puts
0706   0ACE 07 6B 03    	call scan_u8x					; read integer into A
0707   0AD1 FD 9D 08    	shl a, 8				; only AL used, move to AH
0708   0AD4 19 08       	mov al, 08h				; set RTC month
0709   0AD6 05 01       	syscall sys_rtc					; set RTC
0710   0AD8             
0711   0AD8 3B 30 17    	mov d, s_set_seconds
0712   0ADB 07 88 02    	call puts
0713   0ADE 07 6B 03    	call scan_u8x					; read integer into A
0714   0AE1 FD 9D 08    	shl a, 8					; only AL used, move to AH
0715   0AE4 19 07       	mov al, 07h				; set RTC month
0716   0AE6 05 01       	syscall sys_rtc					; set RTC
0717   0AE8 06          	sysret
0718   0AE9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0719   0AE9             ; IDE SERVICES INTERRUPT
0720   0AE9             ; al = option
0721   0AE9             ; 0 = IDE reset, 1 = IDE sleep, 2 = read sector, 3 = write sector
0722   0AE9             ; IDE read/write sector
0723   0AE9             ; 512 bytes
0724   0AE9             ; user buffer pointer in D
0725   0AE9             ; AH = number of sectors
0726   0AE9             ; CB = LBA bytes 3..0
0727   0AE9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0728   0AE9             IDE_serv_tbl:
0729   0AE9 F5 0A       	.dw IDE_reset
0730   0AEB 09 0B       	.dw IDE_sleep
0731   0AED 18 0B       	.dw IDE_read_sect_wrapper
0732   0AEF 1C 0B       	.dw IDE_write_sect_wrapper
0733   0AF1             IDE_services_kernel:
0734   0AF1 FD 0A E9 0A 	jmp [IDE_serv_tbl + al]		
0735   0AF5             	
0736   0AF5             IDE_reset:			
0737   0AF5 F2 D7 FF 04 	mov byte[_IDE_R7], 4		; RESET IDE
0738   0AF9 07 A2 0B    	call IDE_wait				; wait for IDE ready			 			
0739   0AFC F2 D6 FF E0 	mov byte[_IDE_R6], $E0		; LBA3= 0, MASTER, MODE= LBA				
0740   0B00 F2 D1 FF 01 	mov byte[_IDE_R1], 1		; 8-BIT TRANSFERS			
0741   0B04 F2 D7 FF EF 	mov byte[_IDE_R7], $EF		; SET FEATURE COMMAND
0742   0B08 06          	sysret
0743   0B09             IDE_sleep:
0744   0B09 07 A2 0B    	call IDE_wait					; wait for IDE ready			 			
0745   0B0C F2 D6 FF 40 	mov byte [_IDE_R6], %01000000	; lba[3:0](reserved), bit 6=1
0746   0B10 F2 D7 FF E6 	mov byte [_IDE_R7], $E6		; sleep command
0747   0B14 07 A2 0B    	call IDE_wait					; wait for IDE ready
0748   0B17 06          	sysret
0749   0B18             IDE_read_sect_wrapper:
0750   0B18 07 20 0B    	call IDE_read_sect
0751   0B1B 06          	sysret
0752   0B1C             IDE_write_sect_wrapper:
0753   0B1C 07 46 0B    	call IDE_write_sect
0754   0B1F 06          	sysret
0755   0B20             IDE_read_sect:
0756   0B20 1A          	mov al, ah
0757   0B21 24          	mov ah, bl
0758   0B22 42 D2 FF    	mov [_IDE_R2], a			; number of sectors (0..255)
0759   0B25 1C          	mov al, bh
0760   0B26 3D D4 FF    	mov [_IDE_R4], al
0761   0B29 12          	mov a, c
0762   0B2A 3D D5 FF    	mov [_IDE_R5], al
0763   0B2D 1A          	mov al, ah
0764   0B2E 87 0F       	and al, %00001111
0765   0B30 8B E0       	or al, %11100000			; mode lba, master
0766   0B32 3D D6 FF    	mov [_IDE_R6], al
0767   0B35             IDE_read_sect_wait:
0768   0B35 1D D7 FF    	mov al, [_IDE_R7]	
0769   0B38 87 80       	and al, $80				; BUSY FLAG
0770   0B3A C7 35 0B    	jnz IDE_read_sect_wait
0771   0B3D 19 20       	mov al, $20
0772   0B3F 3D D7 FF    	mov [_IDE_R7], al			; read sector cmd
0773   0B42 07 6C 0B    	call IDE_read	
0774   0B45 09          	ret
0775   0B46             IDE_write_sect:
0776   0B46 1A          	mov al, ah
0777   0B47 24          	mov ah, bl
0778   0B48 42 D2 FF    	mov [_IDE_R2], a			; number of sectors (0..255)
0779   0B4B 1C          	mov al, bh
0780   0B4C 3D D4 FF    	mov [_IDE_R4], al
0781   0B4F 12          	mov a, c
0782   0B50 3D D5 FF    	mov [_IDE_R5], al
0783   0B53 1A          	mov al, ah
0784   0B54 87 0F       	and al, %00001111
0785   0B56 8B E0       	or al, %11100000			; mode lba, master
0786   0B58 3D D6 FF    	mov [_IDE_R6], al
0787   0B5B             IDE_write_sect_wait:
0788   0B5B 1D D7 FF    	mov al, [_IDE_R7]	
0789   0B5E 87 80       	and al, $80				; BUSY FLAG
0790   0B60 C7 5B 0B    	jnz IDE_write_sect_wait
0791   0B63 19 30       	mov al, $30
0792   0B65 3D D7 FF    	mov [_IDE_R7], al			; write sector cmd
0793   0B68 07 87 0B    	call IDE_write			
0794   0B6B 09          	ret
0795   0B6C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0796   0B6C             ; READ IDE DATA
0797   0B6C             ; pointer in D
0798   0B6C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0799   0B6C             IDE_read:
0800   0B6C DA          	push d
0801   0B6D             IDE_read_loop:
0802   0B6D 1D D7 FF    	mov al, [_IDE_R7]	
0803   0B70 87 80       	and al, 80h				; BUSY FLAG
0804   0B72 C7 6D 0B    	jnz IDE_read_loop			; wait loop
0805   0B75             	
0806   0B75 1D D7 FF    	mov al, [_IDE_R7]
0807   0B78 87 08       	and al, %00001000			; DRQ FLAG
0808   0B7A C6 85 0B    	jz IDE_read_end
0809   0B7D 1D D0 FF    	mov al, [_IDE_R0]
0810   0B80 3E          	mov [d], al
0811   0B81 79          	inc d
0812   0B82 0A 6D 0B    	jmp IDE_read_loop
0813   0B85             IDE_read_end:
0814   0B85 E7          	pop d
0815   0B86 09          	ret
0816   0B87             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0817   0B87             ; WRITE IDE DATA
0818   0B87             ; data pointer in D
0819   0B87             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0820   0B87             IDE_write:
0821   0B87 DA          	push d
0822   0B88             IDE_write_loop:
0823   0B88 1D D7 FF    	mov al, [_IDE_R7]	
0824   0B8B 87 80       	and al, 80h				; BUSY FLAG
0825   0B8D C7 88 0B    	jnz IDE_write_loop			; wait loop
0826   0B90             	
0827   0B90 1D D7 FF    	mov al, [_IDE_R7]
0828   0B93 87 08       	and al, %00001000			; DRQ FLAG
0829   0B95 C6 A0 0B    	jz IDE_write_end
0830   0B98 1E          	mov al, [d]
0831   0B99 3D D0 FF    	mov [_IDE_R0], al
0832   0B9C 79          	inc d 
0833   0B9D 0A 88 0B    	jmp IDE_write_loop
0834   0BA0             IDE_write_end:
0835   0BA0 E7          	pop d
0836   0BA1 09          	ret
0837   0BA2             
0838   0BA2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0839   0BA2             ; wait for IDE to be ready
0840   0BA2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0841   0BA2             IDE_wait:
0842   0BA2 1D D7 FF    	mov al, [_IDE_R7]	
0843   0BA5 87 80       	and al, 80h				; BUSY FLAG
0844   0BA7 C7 A2 0B    	jnz IDE_wait
0845   0BAA 09          	ret
0846   0BAB             
0847   0BAB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0848   0BAB             ; i/o interrupt
0849   0BAB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0850   0BAB             io_services_jmp:
0851   0BAB CE 0B       	.dw io_putchar
0852   0BAD DB 0B       	.dw io_getchar
0853   0BAF B5 0B       	.dw io_uart_init
0854   0BB1             
0855   0BB1             io_services:
0856   0BB1 FD 0A AB 0B 	jmp [io_services_jmp + al]
0857   0BB5             io_uart_init:
0858   0BB5 F2 83 FF 83 	mov byte[_UART0_LCR], $83			; 8 data, 1 stop, no parity	, divisor latch = 1, UART address 3 = Line Control Register
0859   0BB9 F2 80 FF 03 	mov byte[_UART0_DLAB_0], 3			; baud = 38400, divisor latch low byte = 3
0860   0BBD F2 81 FF 00 	mov byte[_UART0_DLAB_1], 0			; divisor latch high byte = 0			
0861   0BC1 F2 83 FF 03 	mov byte[_UART0_LCR], 3			; UART address 3 = Line Control Register
0862   0BC5 F2 81 FF 01 	mov byte[_UART0_IER], 1			; enable interrupt: receive data available
0863   0BC9 F2 82 FF 00 	mov byte[_UART0_FCR], 0			; disable FIFO
0864   0BCD 06          	sysret
0865   0BCE             ; char in ah
0866   0BCE             io_putchar:
0867   0BCE             io_putchar_L0:
0868   0BCE 1D 85 FF    	mov al, [_UART0_LSR]			; read Line Status Register
0869   0BD1 93 20       	test al, $20					; isolate Transmitter Empty
0870   0BD3 C6 CE 0B    	jz io_putchar_L0		
0871   0BD6 1A          	mov al, ah
0872   0BD7 3D 80 FF    	mov [_UART0_DATA], al			; write char to Transmitter Holding Register
0873   0BDA 06          	sysret
0874   0BDB             ; char in ah
0875   0BDB             ; al = sucess code
0876   0BDB             io_getchar:
0877   0BDB D8          	push b
0878   0BDC DA          	push d
0879   0BDD             io_getchar_L0:	
0880   0BDD 14 2E 16    	mov a, [fifo_pr]
0881   0BE0 29 2C 16    	mov b, [fifo_pi]
0882   0BE3 B0          	cmp a, b
0883   0BE4 C6 0C 0C    	je io_getchar_fail
0884   0BE7             	
0885   0BE7 3C          	mov d, a
0886   0BE8 1E          	mov al, [d]
0887   0BE9 DB          	push al
0888   0BEA             	
0889   0BEA 14 2E 16    	mov a, [fifo_pr]
0890   0BED 77          	inc a
0891   0BEE AF DA 26    	cmp a, fifo + FIFO_SIZE				; check if pointer reached the end of the fifo
0892   0BF1 C7 F7 0B    	jne io_getchar_cont
0893   0BF4 10 DA 1E    	mov a, fifo	
0894   0BF7             io_getchar_cont:	
0895   0BF7 42 2E 16    	mov [fifo_pr], a			; update fifo pointer
0896   0BFA             	
0897   0BFA E9          	pop ah
0898   0BFB             ; here we just echo the char back to the console
0899   0BFB             io_getchar_echo_L0:
0900   0BFB 1D 85 FF    	mov al, [_UART0_LSR]			; read Line Status Register
0901   0BFE 93 20       	test al, $20					; isolate Transmitter Empty
0902   0C00 C6 FB 0B    	jz io_getchar_echo_L0
0903   0C03 1A          	mov al, ah
0904   0C04 3D 80 FF    	mov [_UART0_DATA], al			; write char to Transmitter Holding Register
0905   0C07             
0906   0C07 19 01       	mov al, 1		; AL = 1 means a char successfully received
0907   0C09 E7          	pop d
0908   0C0A E5          	pop b
0909   0C0B 06          	sysret
0910   0C0C             io_getchar_fail:
0911   0C0C E7          	pop d
0912   0C0D E5          	pop b
0913   0C0E 19 00       	mov al, 0			; AL = 0 means no char received
0914   0C10 06          	sysret
0915   0C11             
0916   0C11             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0917   0C11             ;; FILE SYSTEM DATA
0918   0C11             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0919   0C11             ; infor for : IDE SERVICES INTERRUPT
0920   0C11             ; IDE read/write 512-byte sector
0921   0C11             ; al = option
0922   0C11             ; user buffer pointer in D
0923   0C11             ; AH = number of sectors
0924   0C11             ; CB = LBA bytes 3..0	
0925   0C11             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0926   0C11             ;; FILE SYSTEM DATA STRUCTURE
0927   0C11             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0928   0C11             ; for a directory we have the header first, followed by metadata
0929   0C11             ; header 1 sector (512 bytes)
0930   0C11             ; metadata 1 sector (512 bytes)
0931   0C11             ; HEADER ENTRIES:
0932   0C11             ; filename (64)
0933   0C11             ; parent dir LBA (2) -  to be used for faster backwards navigation...
0934   0C11             ;
0935   0C11             ; metadata entries:
0936   0C11             ; filename (24)
0937   0C11             ; attributes (1)	|_|_|file_type(3bits)|x|w|r| types: file, directory, character device
0938   0C11             ; LBA (2)
0939   0C11             ; size (2)
0940   0C11             ; day (1)
0941   0C11             ; month (1)
0942   0C11             ; year (1)
0943   0C11             ; packet size = 32 bytes
0944   0C11             ;
0945   0C11             ; first directory on disk is the root directory '/'
0946   0C11             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0947   0C11             ;; FILE SYSTEM DISK FORMATTING
0948   0C11             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0949   0C11             ; writes FST_TOTAL_SECTORS + FS_NBR_FILES disk sectors  with 0's
0950   0C11             ; this is the file system table formating
0951   0C11             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0952   0C11             file_system_jmptbl:
0953   0C11 41 0C       	.dw file_system_mkfs
0954   0C13 EC 0C       	.dw cmd_fs_space
0955   0C15 ED 0C       	.dw cmd_mkdir
0956   0C17 66 10       	.dw cmd_cd
0957   0C19 6B 10       	.dw cmd_ls
0958   0C1B 54 11       	.dw cmd_mktxt
0959   0C1D D5 11       	.dw cmd_mkbin
0960   0C1F 92 12       	.dw cmd_pwd
0961   0C21 00 13       	.dw cmd_cat
0962   0C23 5C 13       	.dw cmd_rmdir					; 9
0963   0C25 B8 13       	.dw cmd_rm
0964   0C27 00 00       	.dw 0
0965   0C29 00 00       	.dw 0
0966   0C2B 00 00       	.dw 0							; 13
0967   0C2D 70 0C       	.dw fileio_chmod				; 14
0968   0C2F 20 14       	.dw cmd_mv						; 15
0969   0C31 69 0C       	.dw cd_goto_root				; 16
0970   0C33 62 10       	.dw get_current_dirID			; 17
0971   0C35 3E 0E       	.dw get_path_from_dirID			; 18
0972   0C37 A4 0E       	.dw get_dirID_from_path_user	; 19
0973   0C39 BE 0F       	.dw loadfile_from_path_user		; 20	
0974   0C3B 2E 0F       	.dw file_exists_by_path_user	; 21
0975   0C3D             file_system:
0976   0C3D FD 0A 11 0C 	jmp [file_system_jmptbl + al]
0977   0C41             
0978   0C41             file_system_mkfs:	
0979   0C41 FD 4F DA 28 	mov di, transient_area
0980   0C45 19 00       	mov al, 0
0981   0C47 38 00 02    	mov c, 512
0982   0C4A FD F7       	rep stosb
0983   0C4C 26 20 00    	mov b, FST_LBA_START
0984   0C4F 38 00 00    	mov c, 0				; reset LBA to 0
0985   0C52             file_system_mkfs_L1:	
0986   0C52 22 01       	mov ah, $01			; one sect
0987   0C54 3B DA 28    	mov d, transient_area
0988   0C57 07 46 0B    	call IDE_write_sect
0989   0C5A FD 77       	inc b
0990   0C5C C0 00 08    	cmp b, CF_CARD_LBA_SIZE
0991   0C5F C7 52 0C    	jne file_system_mkfs_L1
0992   0C62             file_system_mkfs_create_root:
0993   0C62 10 20 00    	mov a, ROOT_dirID
0994   0C65 42 30 16    	mov [current_dirID], a		; set current directory LBA to ROOT
0995   0C68 06          	sysret	
0996   0C69             	
0997   0C69             cd_goto_root:
0998   0C69 10 20 00    	mov a, ROOT_dirID
0999   0C6C 42 30 16    	mov [current_dirID], a		; set current directory LBA to ROOT
1000   0C6F 06          	sysret	
1001   0C70             
1002   0C70             ; filename in D (userspace data)
1003   0C70             ; permission in BL
1004   0C70             fileio_chmod:
1005   0C70 DD          	push bl
1006   0C71 FD 4E       	mov si, d
1007   0C73 FD 4F DA 1C 	mov di, temp_data
1008   0C77 38 80 00    	mov c, 128
1009   0C7A 04          	load					; load filename from user-space
1010   0C7B             		
1011   0C7B 14 30 16    	mov a, [current_dirID]
1012   0C7E 77          	inc a				; metadata sector
1013   0C7F 27          	mov b, a
1014   0C80 38 00 00    	mov c, 0				; reset LBA to 0
1015   0C83 22 01       	mov ah, $01			; disk read
1016   0C85 3B DA 28    	mov d, transient_area
1017   0C88 07 20 0B    	call IDE_read_sect		; read directory
1018   0C8B FD 10       	cla
1019   0C8D 42 28 16    	mov [index], a		; reset file counter
1020   0C90             fileio_chmod_L1:
1021   0C90 FD 4E       	mov si, d
1022   0C92 FD 4F DA 1C 	mov di, temp_data
1023   0C96 07 93 00    	call strcmp
1024   0C99 C6 B0 0C    	je fileio_chmod_found_entry
1025   0C9C             
1026   0C9C 58 20 00    	add d, 32
1027   0C9F 14 28 16    	mov a, [index]
1028   0CA2 77          	inc a
1029   0CA3 42 28 16    	mov [index], a
1030   0CA6 AF 10 00    	cmp a, FST_FILES_PER_DIR
1031   0CA9 C7 90 0C    	jne fileio_chmod_L1
1032   0CAC EA          	pop bl
1033   0CAD 0A C9 0C    	jmp fileio_chmod_not_found
1034   0CB0             fileio_chmod_found_entry:	
1035   0CB0 FD 79       	mov g, b					; save LBA
1036   0CB2 EA          	pop bl						; retrieve saved permission value
1037   0CB3 1F 18 00    	mov al, [d + 24]			; read file permissions
1038   0CB6 87 F8       	and al, %11111000			; remove all permissions, keep other flags
1039   0CB8 8C          	or al, bl					; set new permissions
1040   0CB9 3F 18 00    	mov [d + 24], al			; write new permissions
1041   0CBC 38 00 00    	mov c, 0
1042   0CBF 3B DA 28    	mov d, transient_area
1043   0CC2 22 01       	mov ah, $01				; disk write 1 sect
1044   0CC4 FD 27       	mov b, g					; retrieve LBA
1045   0CC6 07 46 0B    	call IDE_write_sect		; write sector
1046   0CC9             fileio_chmod_not_found:
1047   0CC9 06          	sysret
1048   0CCA             
1049   0CCA             ;; bootloader installer
1050   0CCA             ;; kernel LBA address in A
1051   0CCA             cmd_boot_installer:
1052   0CCA D7          	push a
1053   0CCB 26 00 00    	mov b, 0
1054   0CCE 38 00 00    	mov c, 0
1055   0CD1 22 01       	mov ah, $01				; 1 sector
1056   0CD3 3B DA 28    	mov d, transient_area
1057   0CD6 07 20 0B    	call IDE_read_sect			; read sector
1058   0CD9             	
1059   0CD9 E4          	pop a
1060   0CDA 44 FE 01    	mov [d + 510], a		; update LBA address
1061   0CDD 26 00 00    	mov b, 0
1062   0CE0 38 00 00    	mov c, 0
1063   0CE3 22 01       	mov ah, $01				; 1 sector
1064   0CE5 3B DA 28    	mov d, transient_area
1065   0CE8 07 46 0B    	call IDE_write_sect		; write sector
1066   0CEB             	
1067   0CEB 06          	sysret
1068   0CEC             
1069   0CEC             cmd_fs_space:
1070   0CEC 06          	sysret
1071   0CED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1072   0CED             ;; CREATE NEW DIRECTORY
1073   0CED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1074   0CED             ; search list for NULL name entry. add new directory to list
1075   0CED             cmd_mkdir:
1076   0CED FD 4E       	mov si, d
1077   0CEF FD 4F DA 1C 	mov di, temp_data
1078   0CF3 38 00 02    	mov c, 512
1079   0CF6 04          	load						; load data from user-space
1080   0CF7 26 22 00    	mov b, FST_LBA_START + 2 	; start at 2 because LBA  0 is ROOT (this would also cause issues 								
1081   0CFA             								; when checking for NULL name, since root has a NULL name)
1082   0CFA 38 00 00    	mov c, 0					; reset LBA to 0
1083   0CFD             cmd_mkdir_L1:	
1084   0CFD 22 01       	mov ah, $01			; disk read
1085   0CFF 3B DA 28    	mov d, transient_area
1086   0D02 07 20 0B    	call IDE_read_sect		; read sector
1087   0D05 BD 00       	cmp byte[d], 0			; check for NULL
1088   0D07 C6 10 0D    	je cmd_mkdir_found_null
1089   0D0A 55 02 00    	add b, FST_SECTORS_PER_DIR					; skip directory
1090   0D0D 0A FD 0C    	jmp cmd_mkdir_L1
1091   0D10             cmd_mkdir_found_null:
1092   0D10             ;create header file by grabbing dir name from parameter
1093   0D10 D8          	push b				; save new directory's LBA
1094   0D11 38 40 00    	mov c, 64
1095   0D14 FD 4D DA 1C 	mov si, temp_data
1096   0D18 FD 4F DA 28 	mov di, transient_area
1097   0D1C FD F5       	rep movsb					; copy dirname from temp_data to transient_area
1098   0D1E 14 30 16    	mov a, [current_dirID]
1099   0D21 42 1A 29    	mov [transient_area + 64], a		; store parent directory LBA
1100   0D24 19 00       	mov al, 0
1101   0D26 FD 4F DA 2A 	mov di, transient_area + 512
1102   0D2A 38 00 02    	mov c, 512
1103   0D2D FD F7       	rep stosb					; clean buffer
1104   0D2F 38 00 00    	mov c, 0				; reset LBA(c) to 0
1105   0D32             ; write directory entry sectors
1106   0D32 3B DA 28    	mov d, transient_area
1107   0D35 22 02       	mov ah, $02			; disk write, 2 sectors
1108   0D37 07 46 0B    	call IDE_write_sect		; write sector
1109   0D3A             ; now we need to add the new directory to the list, insIDE the current directory
1110   0D3A 14 30 16    	mov a, [current_dirID]
1111   0D3D 53 01 00    	add a, 1
1112   0D40 27          	mov b, a					; metadata sector
1113   0D41 38 00 00    	mov c, 0
1114   0D44 FD 79       	mov g, b					; save LBA
1115   0D46 3B DA 28    	mov d, transient_area
1116   0D49 22 01       	mov ah, $01			; disk read
1117   0D4B 07 20 0B    	call IDE_read_sect		; read metadata sector
1118   0D4E             cmd_mkdir_L2:
1119   0D4E BD 00       	cmp byte[d], 0
1120   0D50 C6 59 0D    	je cmd_mkdir_found_null2
1121   0D53 58 20 00    	add d, FST_ENTRY_SIZE
1122   0D56 0A 4E 0D    	jmp cmd_mkdir_L2					; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1123   0D59             cmd_mkdir_found_null2:
1124   0D59 FD 4D DA 1C 	mov si, temp_data
1125   0D5D FD 50       	mov di, d
1126   0D5F 07 A8 00    	call strcpy			; copy directory name
1127   0D62 58 18 00    	add d, 24			; goto ATTRIBUTES
1128   0D65 19 0B       	mov al, %00001011		;directory, no execute, write, read
1129   0D67 3E          	mov [d], al			
1130   0D68 79          	inc d
1131   0D69 E5          	pop b
1132   0D6A D8          	push b				; push LBA back
1133   0D6B FD 43       	mov [d], b			; save LBA
1134   0D6D             ; set file creation date	
1135   0D6D 58 04 00    	add d, 4
1136   0D70 19 04       	mov al, 4
1137   0D72 05 01       	syscall sys_rtc
1138   0D74 1A          	mov al, ah
1139   0D75 3E          	mov [d], al			; set day
1140   0D76 79          	inc d
1141   0D77 19 05       	mov al, 5
1142   0D79 05 01       	syscall sys_rtc
1143   0D7B 1A          	mov al, ah
1144   0D7C 3E          	mov [d], al			; set month
1145   0D7D 79          	inc d
1146   0D7E 19 06       	mov al, 6
1147   0D80 05 01       	syscall sys_rtc
1148   0D82 1A          	mov al, ah
1149   0D83 3E          	mov [d], al			; set year
1150   0D84             ; write sector into disk for new directory entry
1151   0D84 FD 27       	mov b, g
1152   0D86 38 00 00    	mov c, 0
1153   0D89 3B DA 28    	mov d, transient_area
1154   0D8C 22 01       	mov ah, $01			; disk write, 1 sector
1155   0D8E 07 46 0B    	call IDE_write_sect		; write sector
1156   0D91             
1157   0D91             ; after adding the new directory's information to its parent directory's list
1158   0D91             ; we need to now enter the new directory, and to it add two new directories!
1159   0D91             ; which directories do we need to add ? '..' and '.' are the directories needed.
1160   0D91             ; importantly, note that these two new directories are only entries in the list
1161   0D91             ; and do not have actual physical entries in the disk as real directories.
1162   0D91             ; i.e. they only exist as list entries in the new directory created so that
1163   0D91             ; the new directory can reference its parent and itself
1164   0D91             ;
1165   0D91             ; we need to add both '..' and '.'
1166   0D91             ; this first section is for '..' and on the section below we do the same for '.'
1167   0D91 E4          	pop a						; retrieve the new directory's LBA	
1168   0D92 D7          	push a						; and save again
1169   0D93 53 01 00    	add a, 1
1170   0D96 27          	mov b, a					; metadata sector
1171   0D97 38 00 00    	mov c, 0
1172   0D9A FD 79       	mov g, b					; save LBA
1173   0D9C 3B DA 28    	mov d, transient_area
1174   0D9F 22 01       	mov ah, $01			; disk read
1175   0DA1 07 20 0B    	call IDE_read_sect		; read metadata sector
1176   0DA4             cmd_mkdir_L3:
1177   0DA4 BD 00       	cmp byte[d], 0
1178   0DA6 C6 AF 0D    	je cmd_mkdir_found_null3
1179   0DA9 58 20 00    	add d, FST_ENTRY_SIZE
1180   0DAC 0A A4 0D    	jmp cmd_mkdir_L3	; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1181   0DAF             cmd_mkdir_found_null3:
1182   0DAF FD 4D 3D 16 	mov si, s_parent_dir
1183   0DB3 FD 50       	mov di, d
1184   0DB5 07 A8 00    	call strcpy			; copy directory name
1185   0DB8 58 18 00    	add d, 24			; goto ATTRIBUTES
1186   0DBB 19 0B       	mov al, %00001011		;directory, no execute, write, read, 
1187   0DBD 3E          	mov [d], al			
1188   0DBE 79          	inc d
1189   0DBF 29 30 16    	mov b, [current_dirID]	; retrieve the parent directorys LBA
1190   0DC2 FD 43       	mov [d], b			; save LBA
1191   0DC4             ; set file creation date	
1192   0DC4 58 04 00    	add d, 4
1193   0DC7 19 04       	mov al, 4
1194   0DC9 05 01       	syscall sys_rtc
1195   0DCB 1A          	mov al, ah
1196   0DCC 3E          	mov [d], al			; set day
1197   0DCD 79          	inc d
1198   0DCE 19 05       	mov al, 5
1199   0DD0 05 01       	syscall sys_rtc
1200   0DD2 1A          	mov al, ah
1201   0DD3 3E          	mov [d], al			; set month
1202   0DD4 79          	inc d
1203   0DD5 19 06       	mov al, 6
1204   0DD7 05 01       	syscall sys_rtc
1205   0DD9 1A          	mov al, ah
1206   0DDA 3E          	mov [d], al			; set year
1207   0DDB             ; write sector into disk for new directory entry
1208   0DDB FD 27       	mov b, g
1209   0DDD 38 00 00    	mov c, 0
1210   0DE0 3B DA 28    	mov d, transient_area
1211   0DE3 22 01       	mov ah, $01			; disk write, 1 sector
1212   0DE5 07 46 0B    	call IDE_write_sect		; write sector
1213   0DE8             
1214   0DE8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1215   0DE8             ; like we did above for '..', we need to now add the '.' directory to the list.
1216   0DE8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1217   0DE8 E4          	pop a						; retrieve the new directory's LBA	
1218   0DE9 D7          	push a
1219   0DEA 53 01 00    	add a, 1
1220   0DED 27          	mov b, a					; metadata sector
1221   0DEE 38 00 00    	mov c, 0
1222   0DF1 FD 79       	mov g, b					; save LBA
1223   0DF3 3B DA 28    	mov d, transient_area
1224   0DF6 22 01       	mov ah, $01				; disk read
1225   0DF8 07 20 0B    	call IDE_read_sect				; read metadata sector
1226   0DFB             cmd_mkdir_L4:
1227   0DFB BD 00       	cmp byte[d], 0
1228   0DFD C6 06 0E    	je cmd_mkdir_found_null4
1229   0E00 58 20 00    	add d, FST_ENTRY_SIZE
1230   0E03 0A FB 0D    	jmp cmd_mkdir_L4	; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1231   0E06             cmd_mkdir_found_null4:
1232   0E06 FD 4D 40 16 	mov si, s_current_dir
1233   0E0A FD 50       	mov di, d
1234   0E0C 07 A8 00    	call strcpy			; copy directory name
1235   0E0F 58 18 00    	add d, 24			; goto ATTRIBUTES
1236   0E12 19 0B       	mov al, %00001011		;directory, no execute, write, read, 
1237   0E14 3E          	mov [d], al			
1238   0E15 79          	inc d
1239   0E16 E5          	pop b				; new directory's LBA itself. for self-referential directory entry '.'
1240   0E17 FD 43       	mov [d], b			; save LBA
1241   0E19             ; set file creation date	
1242   0E19 58 04 00    	add d, 4
1243   0E1C 19 04       	mov al, 4
1244   0E1E 05 01       	syscall sys_rtc
1245   0E20 1A          	mov al, ah
1246   0E21 3E          	mov [d], al			; set day
1247   0E22 79          	inc d
1248   0E23 19 05       	mov al, 5
1249   0E25 05 01       	syscall sys_rtc
1250   0E27 1A          	mov al, ah
1251   0E28 3E          	mov [d], al			; set month
1252   0E29 79          	inc d
1253   0E2A 19 06       	mov al, 6
1254   0E2C 05 01       	syscall sys_rtc
1255   0E2E 1A          	mov al, ah
1256   0E2F 3E          	mov [d], al			; set year
1257   0E30             ; write sector into disk for new directory entry
1258   0E30 FD 27       	mov b, g
1259   0E32 38 00 00    	mov c, 0
1260   0E35 3B DA 28    	mov d, transient_area
1261   0E38 22 01       	mov ah, $01			; disk write, 1 sector
1262   0E3A 07 46 0B    	call IDE_write_sect		; write sector
1263   0E3D             cmd_mkdir_end:
1264   0E3D 06          	sysret
1265   0E3E             
1266   0E3E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1267   0E3E             ;; get path from a given directory dirID
1268   0E3E             ;; pseudo code:
1269   0E3E             ;	get_path_from_dirID(int dirID, char *D){
1270   0E3E             ;		if(dirID == 0){
1271   0E3E             ;			reverse path in D;
1272   0E3E             ;			return;
1273   0E3E             ;		}
1274   0E3E             ;		else{
1275   0E3E             ;			copy directory name to end of D;
1276   0E3E             ;			add '/' to end of D;
1277   0E3E             ;			parentID = get parent directory ID;
1278   0E3E             ;			get_path_from_dirID(parentID, D);
1279   0E3E             ;		}
1280   0E3E             ;	}
1281   0E3E             ;; A = dirID
1282   0E3E             ;; D = generated path string pointer
1283   0E3E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1284   0E3E             ;; sample path: /usr/bin
1285   0E3E             get_path_from_dirID:
1286   0E3E 3B DA 1A    	mov d, filename
1287   0E41 19 00       	mov al, 0
1288   0E43 3E          	mov [d], al				; initialize path string 
1289   0E44 14 30 16    	mov a, [current_dirID]
1290   0E47 07 54 0E    	call get_path_from_dirID_E0
1291   0E4A 3B DA 1A    	mov d, filename
1292   0E4D 07 3C 00    	call strrev
1293   0E50 07 88 02    	call puts
1294   0E53 06          	sysret
1295   0E54             get_path_from_dirID_E0:
1296   0E54 07 73 0E    	call get_dirname_from_dirID
1297   0E57 FD 4D 42 16 	mov si, s_fslash
1298   0E5B FD 50       	mov di, d
1299   0E5D 07 B6 00    	call strcat						; add '/' to end of path
1300   0E60 AF 20 00    	cmp a, ROOT_dirID				; check if we are at the root directory
1301   0E63 C6 72 0E    	je get_path_from_dirID_root
1302   0E66 07 90 0E    	call get_parentID_from_dirID	; use current ID (A) to find parentID (into A)
1303   0E69 AF 20 00    	cmp a, ROOT_dirID				; check if we are at the root directory
1304   0E6C C6 72 0E    	je get_path_from_dirID_root
1305   0E6F 07 54 0E    	call get_path_from_dirID_E0		; recursively call itself
1306   0E72             get_path_from_dirID_root:
1307   0E72 09          	ret
1308   0E73             
1309   0E73             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1310   0E73             ;; inputs:
1311   0E73             ;; A = directory ID
1312   0E73             ;; outputs:
1313   0E73             ;; D = pointer to directory name string
1314   0E73             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1315   0E73             get_dirname_from_dirID:
1316   0E73 D7          	push a
1317   0E74 D8          	push b
1318   0E75 DA          	push d
1319   0E76 27          	mov b, a
1320   0E77 38 00 00    	mov c, 0				; reset LBA to 0
1321   0E7A 22 01       	mov ah, $01			; disk read
1322   0E7C 3B DA 26    	mov d, transient_area - 512
1323   0E7F 07 20 0B    	call IDE_read_sect			; read directory
1324   0E82 07 3C 00    	call strrev				; reverse dir name before copying
1325   0E85 FD 4E       	mov si, d
1326   0E87 E7          	pop d					; destination address = D value pushed at beginning
1327   0E88 FD 50       	mov di, d
1328   0E8A 07 B6 00    	call strcat				; copy filename to D
1329   0E8D E5          	pop b
1330   0E8E E4          	pop a
1331   0E8F 09          	ret
1332   0E90             
1333   0E90             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1334   0E90             ;; inputs:
1335   0E90             ;; A = directory ID
1336   0E90             ;; outputs:
1337   0E90             ;; A = parent directory ID
1338   0E90             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1339   0E90             get_parentID_from_dirID:
1340   0E90 D8          	push b
1341   0E91 DA          	push d
1342   0E92 27          	mov b, a
1343   0E93 38 00 00    	mov c, 0				; reset LBA to 0
1344   0E96 22 01       	mov ah, $01			; disk read
1345   0E98 3B DA 26    	mov d, transient_area - 512
1346   0E9B 07 20 0B    	call IDE_read_sect			; read directory
1347   0E9E 16 40 00    	mov a, [d + 64]			; copy parent ID value to A
1348   0EA1 E7          	pop d
1349   0EA2 E5          	pop b
1350   0EA3 09          	ret
1351   0EA4             
1352   0EA4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1353   0EA4             ;; get dirID from a given path string
1354   0EA4             ;; inputs:
1355   0EA4             ;; D = path pointer 
1356   0EA4             ;; outputs:
1357   0EA4             ;; A = dirID
1358   0EA4             ;; if dir non existent, A = FFFF (fail code)
1359   0EA4             ;; /usr/local/bin		- absolute
1360   0EA4             ;; local/bin/games		- relative
1361   0EA4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1362   0EA4             get_dirID_from_path_user:
1363   0EA4 FD 4E       	mov si, d
1364   0EA6 FD 4F DA 1C 	mov di, temp_data
1365   0EAA 38 00 02    	mov c, 512
1366   0EAD 04          	load
1367   0EAE 07 B2 0E    	call get_dirID_from_path
1368   0EB1 06          	sysret
1369   0EB2             
1370   0EB2             get_dirID_from_path:
1371   0EB2 26 DA 1C    	mov b, temp_data
1372   0EB5 FD 42 83 06 	mov [prog], b			; token pointer set to path string
1373   0EB9 07 E4 04    	call get_token
1374   0EBC 31 86 06    	mov bl, [tok]
1375   0EBF C1 01       	cmp bl, TOK_FSLASH
1376   0EC1 C6 CD 0E    	je get_dirID_from_path_abs 
1377   0EC4 14 30 16    	mov a, [current_dirID]
1378   0EC7 07 6A 06    	call putback
1379   0ECA 0A D0 0E    	jmp get_dirID_from_path_E0
1380   0ECD             get_dirID_from_path_abs:
1381   0ECD 10 20 00    	mov a, ROOT_dirID
1382   0ED0             get_dirID_from_path_E0:
1383   0ED0 07 E4 04    	call get_token
1384   0ED3 31 85 06    	mov bl, [toktyp]
1385   0ED6 C1 00       	cmp bl, TOKTYP_IDENTIFIER
1386   0ED8 C7 29 0F    	jne get_dirID_from_path_end	; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1387   0EDB             
1388   0EDB FD 4D 87 06 	mov si, tokstr
1389   0EDF FD 4F DA 1A 	mov di, filename
1390   0EE3 07 A8 00    	call strcpy				
1391   0EE6 77          	inc a					; metadata sector
1392   0EE7 27          	mov b, a
1393   0EE8 38 00 00    	mov c, 0				; reset LBA to 0
1394   0EEB 22 01       	mov ah, $01			; disk read
1395   0EED 3B DA 28    	mov d, transient_area
1396   0EF0 07 20 0B    	call IDE_read_sect		; read directory
1397   0EF3 FD 10       	cla
1398   0EF5 42 28 16    	mov [index], a
1399   0EF8             get_dirID_from_path_L1:
1400   0EF8 FD 4E       	mov si, d
1401   0EFA FD 4F DA 1A 	mov di, filename
1402   0EFE 07 93 00    	call strcmp
1403   0F01 C6 17 0F    	je get_dirID_from_path_name_equal	
1404   0F04 58 20 00    	add d, 32
1405   0F07 14 28 16    	mov a, [index]
1406   0F0A 77          	inc a
1407   0F0B 42 28 16    	mov [index], a
1408   0F0E AF 10 00    	cmp a, FST_FILES_PER_DIR
1409   0F11 C6 2A 0F    	je get_dirID_from_path_fail
1410   0F14 0A F8 0E    	jmp get_dirID_from_path_L1
1411   0F17             get_dirID_from_path_name_equal:
1412   0F17 58 19 00    	add d, 25					; 
1413   0F1A 15          	mov a, [d]					; set result register A = dirID
1414   0F1B 07 E4 04    	call get_token
1415   0F1E 31 86 06    	mov bl, [tok]
1416   0F21 C1 01       	cmp bl, TOK_FSLASH			; check if there are more elements in the path
1417   0F23 C6 D0 0E    	je get_dirID_from_path_E0
1418   0F26 07 6A 06    	call putback
1419   0F29             get_dirID_from_path_end:
1420   0F29 09          	ret
1421   0F2A             get_dirID_from_path_fail:
1422   0F2A 10 FF FF    	mov A, $FFFF
1423   0F2D 09          	ret
1424   0F2E             
1425   0F2E             
1426   0F2E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1427   0F2E             ;; check if file exists by a given path string
1428   0F2E             ;; inputs:
1429   0F2E             ;; D = path pointer 
1430   0F2E             ;; OUTPUTS:
1431   0F2E             ;; A = success code, if file exists gives LBA, else, give 0
1432   0F2E             ;; /usr/local/bin/ed
1433   0F2E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1434   0F2E             file_exists_by_path_user:
1435   0F2E FD 4E       	mov si, d
1436   0F30 FD 4F DA 1C 	mov di, temp_data
1437   0F34 38 00 02    	mov c, 512
1438   0F37 04          	load
1439   0F38 07 3C 0F    	call file_exists_by_path
1440   0F3B 06          	sysret
1441   0F3C             file_exists_by_path:
1442   0F3C 26 DA 1C    	mov b, temp_data
1443   0F3F FD 42 83 06 	mov [prog], b			; token pointer set to path string
1444   0F43 07 E4 04    	call get_token
1445   0F46 31 86 06    	mov bl, [tok]
1446   0F49 C1 01       	cmp bl, TOK_FSLASH
1447   0F4B C6 57 0F    	je  file_exists_by_path_abs
1448   0F4E 14 30 16    	mov a, [current_dirID]
1449   0F51 07 6A 06    	call putback
1450   0F54 0A 5A 0F    	jmp file_exists_by_path_E0
1451   0F57             file_exists_by_path_abs:
1452   0F57 10 20 00    	mov a, ROOT_dirID
1453   0F5A             file_exists_by_path_E0:
1454   0F5A 07 E4 04    	call get_token
1455   0F5D 31 85 06    	mov bl, [toktyp]
1456   0F60 C1 00       	cmp bl, TOKTYP_IDENTIFIER
1457   0F62 C7 BA 0F    	jne file_exists_by_path_end	; check if there are tokens after '/'
1458   0F65 FD 4D 87 06 	mov si, tokstr
1459   0F69 FD 4F DA 1A 	mov di, filename
1460   0F6D 07 A8 00    	call strcpy				
1461   0F70 77          	inc a					; metadata sector
1462   0F71 27          	mov b, a
1463   0F72 38 00 00    	mov c, 0				; reset LBA to 0
1464   0F75 22 01       	mov ah, $01			; disk read
1465   0F77 3B DA 28    	mov d, transient_area
1466   0F7A 07 20 0B    	call IDE_read_sect		; read directory
1467   0F7D FD 10       	cla
1468   0F7F 42 28 16    	mov [index], a
1469   0F82             file_exists_by_path_L1:
1470   0F82 FD 4E       	mov si, d
1471   0F84 FD 4F DA 1A 	mov di, filename
1472   0F88 07 93 00    	call strcmp
1473   0F8B C6 A1 0F    	je 	file_exists_by_path_name_equal
1474   0F8E 58 20 00    	add d, 32
1475   0F91 14 28 16    	mov a, [index]
1476   0F94 77          	inc a
1477   0F95 42 28 16    	mov [index], a
1478   0F98 AF 10 00    	cmp a, FST_FILES_PER_DIR
1479   0F9B C6 BA 0F    	je file_exists_by_path_end
1480   0F9E 0A 82 0F    	jmp file_exists_by_path_L1
1481   0FA1             file_exists_by_path_name_equal:
1482   0FA1 33 18 00    	mov bl, [d + 24]
1483   0FA4 FD 87 38    	and bl, %00111000			; directory flag
1484   0FA7 C1 08       	cmp bl, %00001000			; is dir?
1485   0FA9 C6 B0 0F    	je file_exists_by_path_isdir;
1486   0FAC             ; entry is a file
1487   0FAC 16 19 00    	mov a, [d + 25]			; get and return LBA of file
1488   0FAF 09          	ret
1489   0FB0             file_exists_by_path_isdir:
1490   0FB0 58 19 00    	add d, 25					; 
1491   0FB3 15          	mov a, [d]					; set result register A = dirID
1492   0FB4 07 E4 04    	call get_token
1493   0FB7 0A 5A 0F    	jmp file_exists_by_path_E0
1494   0FBA             file_exists_by_path_end:
1495   0FBA 10 00 00    	mov a, 0			; return 0 because file was not found
1496   0FBD 09          	ret
1497   0FBE             
1498   0FBE             
1499   0FBE             
1500   0FBE             
1501   0FBE             
1502   0FBE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1503   0FBE             ;; load file data from a given path string
1504   0FBE             ;; inputs:
1505   0FBE             ;; D = path pointer 
1506   0FBE             ;; DI = userspace program data destination
1507   0FBE             ;; /usr/local/bin/ed
1508   0FBE             ;; ./ed
1509   0FBE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1510   0FBE             loadfile_from_path_user:
1511   0FBE E3          	push di
1512   0FBF FD 4E       	mov si, d
1513   0FC1 FD 4F DA 1C 	mov di, temp_data
1514   0FC5 38 00 02    	mov c, 512
1515   0FC8 04          	load
1516   0FC9 07 D6 0F    	call loadfile_from_path
1517   0FCC F0          	pop di
1518   0FCD FD 4D DA 28 	mov si, transient_area
1519   0FD1 38 00 3E    	mov c, 512 * (FS_SECTORS_PER_FILE-1)
1520   0FD4 03          	store
1521   0FD5 06          	sysret
1522   0FD6             loadfile_from_path:
1523   0FD6 26 DA 1C    	mov b, temp_data
1524   0FD9 FD 42 83 06 	mov [prog], b			; token pointer set to path string
1525   0FDD 07 E4 04    	call get_token
1526   0FE0 31 86 06    	mov bl, [tok]
1527   0FE3 C1 01       	cmp bl, TOK_FSLASH
1528   0FE5 C6 F1 0F    	je loadfile_from_path_abs 
1529   0FE8 14 30 16    	mov a, [current_dirID]
1530   0FEB 07 6A 06    	call putback
1531   0FEE 0A F4 0F    	jmp loadfile_from_path_E0
1532   0FF1             loadfile_from_path_abs:
1533   0FF1 10 20 00    	mov a, ROOT_dirID
1534   0FF4             loadfile_from_path_E0:
1535   0FF4 07 E4 04    	call get_token
1536   0FF7 31 85 06    	mov bl, [toktyp]
1537   0FFA C1 00       	cmp bl, TOKTYP_IDENTIFIER
1538   0FFC C7 61 10    	jne loadfile_from_path_end	; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1539   0FFF FD 4D 87 06 	mov si, tokstr
1540   1003 FD 4F DA 1A 	mov di, filename
1541   1007 07 A8 00    	call strcpy				
1542   100A 77          	inc a					; metadata sector
1543   100B 27          	mov b, a
1544   100C 38 00 00    	mov c, 0				; reset LBA to 0
1545   100F 22 01       	mov ah, $01			; disk read
1546   1011 3B DA 28    	mov d, transient_area
1547   1014 07 20 0B    	call IDE_read_sect		; read directory
1548   1017 FD 10       	cla
1549   1019 42 28 16    	mov [index], a
1550   101C             loadfile_from_path_L1:
1551   101C FD 4E       	mov si, d
1552   101E FD 4F DA 1A 	mov di, filename
1553   1022 07 93 00    	call strcmp
1554   1025 C6 3B 10    	je loadfile_from_path_name_equal	
1555   1028 58 20 00    	add d, 32
1556   102B 14 28 16    	mov a, [index]
1557   102E 77          	inc a
1558   102F 42 28 16    	mov [index], a
1559   1032 AF 10 00    	cmp a, FST_FILES_PER_DIR
1560   1035 C6 61 10    	je loadfile_from_path_end
1561   1038 0A 1C 10    	jmp loadfile_from_path_L1
1562   103B             loadfile_from_path_name_equal:
1563   103B 33 18 00    	mov bl, [d + 24]
1564   103E FD 87 38    	and bl, %00111000			; directory flag
1565   1041 C1 08       	cmp bl, %00001000			; is dir?
1566   1043 C6 57 10    	je loadfile_isdirectory	;
1567   1046             ; entry is a file
1568   1046 2B 19 00    	mov b, [d + 25]			; get LBA
1569   1049 FD 77       	inc b				; add 1 to B because the LBA for data comes after the header sector
1570   104B 3B DA 28    	mov d, transient_area
1571   104E 38 00 00    	mov c, 0
1572   1051 22 1F       	mov ah, FS_SECTORS_PER_FILE-1		; number of sectors
1573   1053 07 20 0B    	call IDE_read_sect				; read sector
1574   1056 09          	ret
1575   1057             loadfile_isdirectory:
1576   1057 58 19 00    	add d, 25					; 
1577   105A 15          	mov a, [d]					; set result register A = dirID
1578   105B 07 E4 04    	call get_token
1579   105E 0A F4 0F    	jmp loadfile_from_path_E0
1580   1061             loadfile_from_path_end:
1581   1061 09          	ret
1582   1062             
1583   1062             
1584   1062             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1585   1062             ;; return the ID of the current directory
1586   1062             ;; ID returned in B
1587   1062             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1588   1062             get_current_dirID:
1589   1062 29 30 16    	mov b, [current_dirID]
1590   1065 06          	sysret
1591   1066             
1592   1066             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1593   1066             ;; CD
1594   1066             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1595   1066             ; new dirID in B
1596   1066             cmd_cd:
1597   1066 FD 42 30 16 	mov [current_dirID], b
1598   106A 06          	sysret	
1599   106B             
1600   106B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1601   106B             ;; LS
1602   106B             ;; dirID in B
1603   106B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1604   106B             cmd_ls:
1605   106B FD 77       	inc b				; metadata sector
1606   106D 38 00 00    	mov c, 0				; reset LBA to 0
1607   1070 22 01       	mov ah, $01			; disk read
1608   1072 3B DA 28    	mov d, transient_area
1609   1075 07 20 0B    	call IDE_read_sect		; read directory
1610   1078 FD 10       	cla
1611   107A 42 28 16    	mov [index], a		; reset entry index
1612   107D             cmd_ls_L1:
1613   107D BD 00       	cmp byte [d], 0		; check for NULL
1614   107F C6 0F 11    	je cmd_ls_next
1615   1082             cmd_ls_non_null:
1616   1082 1F 18 00    	mov al, [d + 24]
1617   1085 87 38       	and al, %00111000
1618   1087 FD A2 03    	shr al, 3
1619   108A 22 00       	mov ah, 0					; file type
1620   108C B7 4D 16    	mov a, [a + file_type]			
1621   108F 23          	mov ah, al
1622   1090 07 4E 01    	call putchar
1623   1093 1F 18 00    	mov al, [d + 24]
1624   1096 87 01       	and al, %00000001
1625   1098 22 00       	mov ah, 0
1626   109A B7 48 16    	mov a, [a + file_attrib]		; read
1627   109D 23          	mov ah, al
1628   109E 07 4E 01    	call putchar
1629   10A1 1F 18 00    	mov al, [d + 24]
1630   10A4 87 02       	and al, %00000010
1631   10A6 22 00       	mov ah, 0
1632   10A8 B7 48 16    	mov a, [a + file_attrib]		; write
1633   10AB 23          	mov ah, al
1634   10AC 07 4E 01    	call putchar
1635   10AF 1F 18 00    	mov al, [d + 24]
1636   10B2 87 04       	and al, %00000100
1637   10B4 22 00       	mov ah, 0
1638   10B6 B7 48 16    	mov a, [a + file_attrib]		; execute
1639   10B9 23          	mov ah, al
1640   10BA 07 4E 01    	call putchar
1641   10BD 22 20       	mov ah, $20
1642   10BF 07 4E 01    	call putchar	
1643   10C2 16 1B 00    	mov a, [d + 27]
1644   10C5 07 B1 02    	call print_u16d				; filesize
1645   10C8 22 20       	mov ah, $20
1646   10CA 07 4E 01    	call putchar	
1647   10CD 16 19 00    	mov a, [d + 25]
1648   10D0 07 B1 02    	call print_u16d			; dirID / LBA
1649   10D3 22 20       	mov ah, $20
1650   10D5 07 4E 01    	call putchar
1651   10D8             ; print date
1652   10D8 33 1D 00    	mov bl, [d + 29]			; day
1653   10DB 07 24 03    	call print_u8x
1654   10DE 22 20       	mov ah, $20
1655   10E0 07 4E 01    	call putchar	
1656   10E3 1F 1E 00    	mov al, [d + 30]			; month
1657   10E6 FD 9E 02    	shl al, 2
1658   10E9 DA          	push d
1659   10EA 3B 3A 17    	mov d, s_months
1660   10ED 22 00       	mov ah, 0
1661   10EF 59          	add d, a
1662   10F0 07 88 02    	call puts
1663   10F3 E7          	pop d
1664   10F4 22 20       	mov ah, $20
1665   10F6 07 4E 01    	call putchar
1666   10F9 2E 20       	mov bl, $20
1667   10FB 07 24 03    	call print_u8x
1668   10FE 33 1F 00    	mov bl, [d + 31]			; year
1669   1101 07 24 03    	call print_u8x	
1670   1104 22 20       	mov ah, $20
1671   1106 07 4E 01    	call putchar	
1672   1109 07 88 02    	call puts				; print filename	
1673   110C 07 35 02    	call printnl
1674   110F             cmd_ls_next:
1675   110F 14 28 16    	mov a, [index]
1676   1112 77          	inc a
1677   1113 42 28 16    	mov [index], a
1678   1116 AF 10 00    	cmp a, FST_FILES_PER_DIR
1679   1119 C6 22 11    	je cmd_ls_end
1680   111C 58 20 00    	add d, 32			
1681   111F 0A 7D 10    	jmp cmd_ls_L1	
1682   1122             cmd_ls_end:
1683   1122 06          	sysret
1684   1123             
1685   1123             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1686   1123             ;; pad string to 32 chars
1687   1123             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1688   1123             ; count in C
1689   1123             padding:
1690   1123 D7          	push a
1691   1124 D8          	push b
1692   1125 10 20 00    	mov a, 32
1693   1128 28          	mov b, c
1694   1129 60          	sub a, b
1695   112A 39          	mov c, a
1696   112B             padding_L1:
1697   112B 22 20       	mov ah, $20
1698   112D 07 4E 01    	call putchar
1699   1130 7E          	dec c
1700   1131 C2 00 00    	cmp c, 0
1701   1134 C7 2B 11    	jne padding_L1
1702   1137 E5          	pop b
1703   1138 E4          	pop a
1704   1139 09          	ret
1705   113A             
1706   113A             
1707   113A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1708   113A             ;; finds an empty data block
1709   113A             ;; block LBA returned in B
1710   113A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1711   113A             fs_find_empty_block:
1712   113A 26 A0 00    	mov b, FS_LBA_START		; raw files starting block
1713   113D 38 00 00    	mov c, 0						; reset LBA to 0
1714   1140             fs_find_empty_block_L1:	
1715   1140 22 01       	mov ah, $01			; disk read
1716   1142 3B DA 26    	mov d, transient_area - 512
1717   1145 07 20 0B    	call IDE_read_sect		; read sector
1718   1148 BD 00       	cmp byte [d], 0
1719   114A C6 53 11    	je fs_find_empty_block_found_null
1720   114D 55 20 00    	add b, FS_SECTORS_PER_FILE
1721   1150 0A 40 11    	jmp fs_find_empty_block_L1
1722   1153             fs_find_empty_block_found_null:
1723   1153 09          	ret
1724   1154             
1725   1154             ; file structure:
1726   1154             ; 512 bytes header
1727   1154             ; header used to tell whether the block is free
1728   1154             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1729   1154             ;; CREATE NEW TEXTFILE
1730   1154             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1731   1154             cmd_mktxt:
1732   1154 FD 4E       	mov si, d
1733   1156 FD 4F DA 28 	mov di, transient_area
1734   115A 38 00 40    	mov c, FS_SECTORS_PER_FILE * 512
1735   115D 04          	load					; load data from user-space
1736   115E 07 3A 11    	call fs_find_empty_block	; look for empty data blocks
1737   1161 D8          	push b				; save empty block LBA
1738   1162             ;create header file by grabbing file name from parameter	
1739   1162 3B DA 2A    	mov d, transient_area + 512			; pointer to file contents
1740   1165             	;call gettxt
1741   1165 07 83 00    	call strlen						; get length of the text file
1742   1168 D9          	push c							; save length
1743   1169 19 01       	mov al, 1
1744   116B 3D DA 28    	mov [transient_area], al					; mark sectors as USED (not NULL)
1745   116E 3B DA 28    	mov d, transient_area
1746   1171             cmd_mktxt_L2:
1747   1171 38 00 00    	mov c, 0
1748   1174 22 20       	mov ah, FS_SECTORS_PER_FILE		; number of sectors to write
1749   1176 07 46 0B    	call IDE_write_sect			; write sectors
1750   1179             ; now we add the file to the current directory!
1751   1179             cmd_mktxt_add_to_dir:	
1752   1179 14 30 16    	mov a, [current_dirID]
1753   117C 77          	inc a
1754   117D 27          	mov b, a					; metadata sector
1755   117E 38 00 00    	mov c, 0
1756   1181 FD 79       	mov g, b					; save LBA
1757   1183 3B DA 26    	mov d, transient_area - 512
1758   1186 22 01       	mov ah, $01			; disk read
1759   1188 07 20 0B    	call IDE_read_sect		; read metadata sector
1760   118B             cmd_mktxt_add_to_dir_L2:
1761   118B BD 00       	cmp byte[d], 0
1762   118D C6 96 11    	je cmd_mktxt_add_to_dir_null
1763   1190 58 20 00    	add d, FST_ENTRY_SIZE
1764   1193 0A 8B 11    	jmp cmd_mktxt_add_to_dir_L2		; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1765   1196             cmd_mktxt_add_to_dir_null:
1766   1196 FD 4D DB 28 	mov si, transient_area + 1		; filename located after the data block 'USED' marker byte
1767   119A FD 50       	mov di, d
1768   119C 07 A8 00    	call strcpy			; copy file name
1769   119F 58 18 00    	add d, 24			; skip name
1770   11A2 19 03       	mov al, %00000011	; type=file, no execute, write, read
1771   11A4 3E          	mov [d], al			
1772   11A5 58 03 00    	add d, 3
1773   11A8 E4          	pop a
1774   11A9 43          	mov [d], a
1775   11AA 63 02 00    	sub d, 2
1776   11AD E5          	pop b				; get file LBA
1777   11AE FD 43       	mov [d], b			; save LBA	
1778   11B0             	
1779   11B0             	; set file creation date	
1780   11B0 58 04 00    	add d, 4
1781   11B3 19 04       	mov al, 4
1782   11B5 05 01       	syscall sys_rtc
1783   11B7 1A          	mov al, ah
1784   11B8 3E          	mov [d], al			; set day
1785   11B9             	
1786   11B9 79          	inc d
1787   11BA 19 05       	mov al, 5
1788   11BC 05 01       	syscall sys_rtc
1789   11BE 1A          	mov al, ah
1790   11BF 3E          	mov [d], al			; set month
1791   11C0             	
1792   11C0 79          	inc d
1793   11C1 19 06       	mov al, 6
1794   11C3 05 01       	syscall sys_rtc
1795   11C5 1A          	mov al, ah
1796   11C6 3E          	mov [d], al			; set year
1797   11C7             	
1798   11C7             ; write sector into disk for new directory entry
1799   11C7 FD 27       	mov b, g
1800   11C9 38 00 00    	mov c, 0
1801   11CC 3B DA 26    	mov d, transient_area - 512
1802   11CF 22 01       	mov ah, $01			; disk write, 1 sector
1803   11D1 07 46 0B    	call IDE_write_sect		; write sector
1804   11D4 06          	sysret
1805   11D5             
1806   11D5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1807   11D5             ;; CREATE NEW BINARY FILE
1808   11D5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1809   11D5             ; search for first null block
1810   11D5             cmd_mkbin:
1811   11D5 FD 4E       	mov si, d
1812   11D7 FD 4F DA 1C 	mov di, temp_data
1813   11DB 38 00 02    	mov c, 512
1814   11DE 04          	load					; load data from user-space
1815   11DF             	
1816   11DF 26 A0 00    	mov b, FS_LBA_START		; files start when directories end
1817   11E2 38 00 00    	mov c, 0				; reset LBA to 0
1818   11E5             cmd_mkbin_L1:	
1819   11E5 22 01       	mov ah, $01			; disk read
1820   11E7 3B DA 28    	mov d, transient_area
1821   11EA 07 20 0B    	call IDE_read_sect		; read sector
1822   11ED BD 00       	cmp byte[d], 0			; check for NULL
1823   11EF C6 F8 11    	je cmd_mkbin_found_null
1824   11F2 55 20 00    	add b, FS_SECTORS_PER_FILE
1825   11F5 0A E5 11    	jmp cmd_mkbin_L1
1826   11F8             cmd_mkbin_found_null:
1827   11F8 D8          	push b				; save LBA
1828   11F9             ;create header file by grabbing file name from parameter
1829   11F9 FD 4F DA 2A 	mov di, transient_area + 512	; pointer to file contents
1830   11FD 07 F5 15    	call _load_hex			; load binary hex
1831   1200 D9          	push c					; save size (nbr of bytes)
1832   1201 19 01       	mov al, 1
1833   1203 3D DA 28    	mov [transient_area], al		; mark sectors as USED (not NULL)
1834   1206 FD 10       	cla
1835   1208 42 28 16    	mov [index], a
1836   120B 3B DA 28    	mov d, transient_area
1837   120E 13          	mov a, d
1838   120F 42 2A 16    	mov [buffer_addr], a
1839   1212             cmd_mkbin_L2:
1840   1212 38 00 00    	mov c, 0
1841   1215 22 01       	mov ah, $01				; disk write, 1 sector
1842   1217 07 46 0B    	call IDE_write_sect			; write sector
1843   121A 14 28 16    	mov a, [index]
1844   121D 77          	inc a
1845   121E 42 28 16    	mov [index], a
1846   1221 AF 20 00    	cmp a, FS_SECTORS_PER_FILE		; remove 1 from this because we dont count the header sector
1847   1224 C6 36 12    	je cmd_mkbin_add_to_dir
1848   1227 FD 77       	inc b
1849   1229 14 2A 16    	mov a, [buffer_addr]
1850   122C 53 00 02    	add a, 512
1851   122F 42 2A 16    	mov [buffer_addr], a
1852   1232 3C          	mov d, a
1853   1233 0A 12 12    	jmp cmd_mkbin_L2
1854   1236             ; now we add the file to the current directory!
1855   1236             cmd_mkbin_add_to_dir:	
1856   1236 14 30 16    	mov a, [current_dirID]
1857   1239 77          	inc a
1858   123A 27          	mov b, a					; metadata sector
1859   123B 38 00 00    	mov c, 0
1860   123E FD 79       	mov g, b					; save LBA
1861   1240 3B DA 28    	mov d, transient_area
1862   1243 22 01       	mov ah, $01			; disk read
1863   1245 07 20 0B    	call IDE_read_sect		; read metadata sector
1864   1248             cmd_mkbin_add_to_dir_L2:
1865   1248 BD 00       	cmp byte[d], 0
1866   124A C6 53 12    	je cmd_mkbin_add_to_dir_null
1867   124D 58 20 00    	add d, FST_ENTRY_SIZE
1868   1250 0A 48 12    	jmp cmd_mkbin_add_to_dir_L2		; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1869   1253             cmd_mkbin_add_to_dir_null:
1870   1253 FD 4D DA 1C 	mov si, temp_data
1871   1257 FD 50       	mov di, d
1872   1259 07 A8 00    	call strcpy			; copy file name
1873   125C 58 18 00    	add d, 24			; skip name
1874   125F 19 07       	mov al, %00000111		;type=file, execute, write, read, 
1875   1261 3E          	mov [d], al
1876   1262 58 03 00    	add d, 3
1877   1265 E4          	pop a
1878   1266 43          	mov [d], a
1879   1267 63 02 00    	sub d, 2
1880   126A E5          	pop b				; get file LBA
1881   126B FD 43       	mov [d], b			; save LBA
1882   126D             	
1883   126D             	; set file creation date	
1884   126D 58 04 00    	add d, 4
1885   1270 19 04       	mov al, 4
1886   1272 05 01       	syscall sys_rtc
1887   1274 1A          	mov al, ah
1888   1275 3E          	mov [d], al			; set day
1889   1276             	
1890   1276 79          	inc d
1891   1277 19 05       	mov al, 5
1892   1279 05 01       	syscall sys_rtc
1893   127B 1A          	mov al, ah
1894   127C 3E          	mov [d], al			; set month
1895   127D             	
1896   127D 79          	inc d
1897   127E 19 06       	mov al, 6
1898   1280 05 01       	syscall sys_rtc
1899   1282 1A          	mov al, ah
1900   1283 3E          	mov [d], al			; set year
1901   1284             	
1902   1284             ; write sector into disk for new directory entry
1903   1284 FD 27       	mov b, g
1904   1286 38 00 00    	mov c, 0
1905   1289 3B DA 28    	mov d, transient_area
1906   128C 22 01       	mov ah, $01			; disk write, 1 sector
1907   128E 07 46 0B    	call IDE_write_sect		; write sector
1908   1291 06          	sysret
1909   1292             
1910   1292             			
1911   1292             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1912   1292             ;; PWD - PRINT WORKING DIRECTORY
1913   1292             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		
1914   1292             cmd_pwd:
1915   1292 3B DA 1A    	mov d, filename
1916   1295 19 00       	mov al, 0
1917   1297 3E          	mov [d], al				; initialize path string 
1918   1298 14 30 16    	mov a, [current_dirID]
1919   129B 07 54 0E    	call get_path_from_dirID_E0
1920   129E 3B DA 1A    	mov d, filename
1921   12A1 07 3C 00    	call strrev
1922   12A4 07 88 02    	call puts
1923   12A7 07 35 02    	call printnl
1924   12AA 06          	sysret
1925   12AB             
1926   12AB             
1927   12AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1928   12AB             ;; get current directory LBA
1929   12AB             ;; A: returned LBA
1930   12AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:
1931   12AB             cmd_get_curr_dir_LBA:
1932   12AB 14 30 16    	mov a, [current_dirID]
1933   12AE 06          	sysret
1934   12AF             
1935   12AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1936   12AF             ;; LOAD FILE INTO MEM
1937   12AF             ;; file loaded to transient_area
1938   12AF             ;; D: filename pointer
1939   12AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:
1940   12AF             cmd_loadfile_user:
1941   12AF FD 4E       	mov si, d
1942   12B1 FD 4F DA 1A 	mov di, filename
1943   12B5 38 00 01    	mov c, 256
1944   12B8 04          	load
1945   12B9 07 BD 12    	call cmd_loadfile
1946   12BC 06          	sysret
1947   12BD             
1948   12BD             cmd_loadfile:
1949   12BD 14 30 16    	mov a, [current_dirID]
1950   12C0 77          	inc a				; metadata sector
1951   12C1 27          	mov b, a
1952   12C2 38 00 00    	mov c, 0				; reset LBA to 0
1953   12C5 22 01       	mov ah, $01			; disk read
1954   12C7 3B DA 26    	mov d, transient_area-512
1955   12CA 07 20 0B    	call IDE_read_sect		; read directory
1956   12CD FD 10       	cla
1957   12CF 42 28 16    	mov [index], a		; reset file counter
1958   12D2             cmd_loadfile_L1:
1959   12D2 FD 4E       	mov si, d
1960   12D4 FD 4F DA 1A 	mov di, filename
1961   12D8 07 93 00    	call strcmp
1962   12DB C6 F1 12    	je cmd_loadfile_found_entry
1963   12DE 58 20 00    	add d, 32
1964   12E1 14 28 16    	mov a, [index]
1965   12E4 77          	inc a
1966   12E5 42 28 16    	mov [index], a
1967   12E8 AF 10 00    	cmp a, FST_FILES_PER_DIR
1968   12EB C6 FF 12    	je cmd_loadfile_not_found
1969   12EE 0A D2 12    	jmp cmd_loadfile_L1
1970   12F1             cmd_loadfile_found_entry:
1971   12F1 58 19 00    	add d, 25			; get to dirID of file in disk
1972   12F4 2A          	mov b, [d]			; get LBA
1973   12F5 FD 77       	inc b				; add 1 to B because the LBA for data comes after the header sector
1974   12F7 3B DA 28    	mov d, transient_area
1975   12FA 22 1F       	mov ah, FS_SECTORS_PER_FILE-1		; number of sectors
1976   12FC 07 20 0B    	call IDE_read_sect				; read sector
1977   12FF             cmd_loadfile_not_found:
1978   12FF 09          	ret
1979   1300             
1980   1300             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1981   1300             ;; CAT
1982   1300             ;; userspace destination data pointer in D
1983   1300             ;; filename starts at D, but is overwritten after the read is made
1984   1300             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:
1985   1300             cmd_cat:
1986   1300 DA          	push d					; save userspace file data destination
1987   1301 FD 4E       	mov si, d
1988   1303 FD 4F DA 1C 	mov di, temp_data
1989   1307 38 00 02    	mov c, 512
1990   130A 04          	load					; copy filename from user-space
1991   130B 29 30 16    	mov b, [current_dirID]
1992   130E FD 77       	inc b				; metadata sector
1993   1310 38 00 00    	mov c, 0				; reset LBA to 0
1994   1313 22 01       	mov ah, $01			; disk read
1995   1315 3B DA 26    	mov d, transient_area-512
1996   1318 07 20 0B    	call IDE_read_sect		; read directory
1997   131B FD 10       	cla
1998   131D 42 28 16    	mov [index], a		; reset file counter
1999   1320             cmd_cat_L1:
2000   1320 FD 4E       	mov si, d
2001   1322 FD 4F DA 1C 	mov di, temp_data
2002   1326 07 93 00    	call strcmp
2003   1329 C6 3F 13    	je cmd_cat_found_entry
2004   132C 58 20 00    	add d, 32
2005   132F 14 28 16    	mov a, [index]
2006   1332 77          	inc a
2007   1333 42 28 16    	mov [index], a
2008   1336 AF 10 00    	cmp a, FST_FILES_PER_DIR
2009   1339 C6 5A 13    	je cmd_cat_not_found
2010   133C 0A 20 13    	jmp cmd_cat_L1
2011   133F             cmd_cat_found_entry:
2012   133F 58 19 00    	add d, 25			; get to dirID of file in disk
2013   1342 2A          	mov b, [d]			; get LBA
2014   1343 FD 77       	inc b				; add 1 to B because the LBA for data comes after the header sector 
2015   1345 3B DA 28    	mov d, transient_area	
2016   1348 38 00 00    	mov c, 0
2017   134B 22 1F       	mov ah, FS_SECTORS_PER_FILE-1	; nbr sectors
2018   134D 07 20 0B    	call IDE_read_sect		; read sectors
2019   1350 F0          	pop di						; write userspace file data destination to DI
2020   1351 FD 4D DA 28 	mov si, transient_area		; data origin
2021   1355 38 00 3E    	mov c, 512*(FS_SECTORS_PER_FILE-1)
2022   1358 03          	store
2023   1359 06          	sysret
2024   135A             cmd_cat_not_found:
2025   135A E7          	pop d
2026   135B 06          	sysret
2027   135C             
2028   135C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2029   135C             ;; RMDIR - remove DIR by dirID
2030   135C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2031   135C             ; deletes a directory entry in the given directory's file list 
2032   135C             ; also deletes the actual directory entry in the FST
2033   135C             ; synopsis: rmdir /usr/local/testdir
2034   135C             ; B = dirID
2035   135C             cmd_rmdir:
2036   135C FD 79       	mov g, b
2037   135E 11          	mov a, b
2038   135F 07 90 0E    	call get_parentID_from_dirID	; now get the directory's parent, in A
2039   1362 D7          	push a						; save dirID
2040   1363             ; search for directory's entry in the parent's directory then and delete it
2041   1363 77          	inc a						; metadata sector
2042   1364 27          	mov b, a
2043   1365 38 00 00    	mov c, 0					; reset LBA to 0
2044   1368 22 01       	mov ah, $01					;
2045   136A 3B DA 28    	mov d, transient_area
2046   136D 07 20 0B    	call IDE_read_sect			; read directory
2047   1370 FD 10       	cla
2048   1372 42 28 16    	mov [index], a				; reset file counter
2049   1375 FD 27       	mov b, g					; retrieve directory's dirID
2050   1377             cmd_rmdir_L1:
2051   1377 16 19 00    	mov a, [d + 25]				; get entry's dirID/LBA value
2052   137A B0          	cmp a, b					; compare dirID's to find the directory
2053   137B C6 91 13    	je cmd_rmdir_found_entry
2054   137E 58 20 00    	add d, 32
2055   1381 14 28 16    	mov a, [index]
2056   1384 77          	inc a
2057   1385 42 28 16    	mov [index], a
2058   1388 AF 10 00    	cmp a, FST_FILES_PER_DIR
2059   138B C6 B6 13    	je cmd_rmdir_not_found
2060   138E 0A 77 13    	jmp cmd_rmdir_L1
2061   1391             cmd_rmdir_found_entry:
2062   1391 FD 10       	cla
2063   1393 3E          	mov [d], al					; make filename NULL
2064   1394 44 19 00    	mov [d + 25], a				; clear dirID/LBA as well not to generate problems with previously deleted directories
2065   1397 E5          	pop b
2066   1398 FD 77       	inc b						; metadata sector
2067   139A 38 00 00    	mov c, 0					; reset LBA to 0
2068   139D 22 01       	mov ah, $01					; 
2069   139F 3B DA 28    	mov d, transient_area
2070   13A2 07 46 0B    	call IDE_write_sect			; write sector and erase file's entry in the current DIR
2071   13A5             
2072   13A5 FD 27       	mov b, g
2073   13A7 3B DA 28    	mov d, transient_area	
2074   13AA FD 10       	cla
2075   13AC 3E          	mov [d], al					; make directory's name header NULL for re-use
2076   13AD 38 00 00    	mov c, 0
2077   13B0 22 01       	mov ah, $01					; disk write 1 sect
2078   13B2 07 46 0B    	call IDE_write_sect			; delete directory given by dirID in B
2079   13B5 06          	sysret
2080   13B6             cmd_rmdir_not_found:
2081   13B6 E5          	pop b
2082   13B7 06          	sysret
2083   13B8             
2084   13B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2085   13B8             ;; RM - remove file
2086   13B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2087   13B8             ; frees up the data sectors for the file further down the disk
2088   13B8             ; deletes file entry in the directory's file list 
2089   13B8             cmd_rm:
2090   13B8 FD 4E       	mov si, d
2091   13BA FD 4F DA 1C 	mov di, temp_data
2092   13BE 38 00 02    	mov c, 512
2093   13C1 04          	load					; load data from user-space
2094   13C2 14 30 16    	mov a, [current_dirID]
2095   13C5 77          	inc a				; metadata sector
2096   13C6 27          	mov b, a
2097   13C7 38 00 00    	mov c, 0				; reset LBA to 0
2098   13CA 22 01       	mov ah, $01			; disk read
2099   13CC 3B DA 28    	mov d, transient_area
2100   13CF 07 20 0B    	call IDE_read_sect		; read directory
2101   13D2 10 00 00    	mov a, 0
2102   13D5 42 28 16    	mov [index], a		; reset file counter
2103   13D8             cmd_rm_L1:
2104   13D8 FD 4E       	mov si, d
2105   13DA FD 4F DA 1C 	mov di, temp_data
2106   13DE 07 93 00    	call strcmp
2107   13E1 C6 F7 13    	je cmd_rm_found_entry
2108   13E4 58 20 00    	add d, 32
2109   13E7 14 28 16    	mov a, [index]
2110   13EA 77          	inc a
2111   13EB 42 28 16    	mov [index], a
2112   13EE AF 10 00    	cmp a, FST_FILES_PER_DIR
2113   13F1 C6 1F 14    	je cmd_rm_not_found
2114   13F4 0A D8 13    	jmp cmd_rm_L1
2115   13F7             cmd_rm_found_entry:
2116   13F7 2B 19 00    	mov b, [d + 25]			; get LBA
2117   13FA FD 79       	mov g, b				; save LBA
2118   13FC 19 00       	mov al, 0
2119   13FE 3E          	mov [d], al			; make file entry NULL
2120   13FF 14 30 16    	mov a, [current_dirID]
2121   1402 77          	inc a				; metadata sector
2122   1403 27          	mov b, a
2123   1404 38 00 00    	mov c, 0				; reset LBA to 0
2124   1407 22 01       	mov ah, $01			; disk write
2125   1409 3B DA 28    	mov d, transient_area
2126   140C 07 46 0B    	call IDE_write_sect		; write sector and erase file's entry in the current DIR
2127   140F 3B DA 28    	mov d, transient_area	
2128   1412 19 00       	mov al, 0
2129   1414 3E          	mov [d], al			; make file's data header NULL for re-use
2130   1415 38 00 00    	mov c, 0
2131   1418 FD 27       	mov b, g				; get data header LBA
2132   141A 22 01       	mov ah, $01					; disk write 1 sect
2133   141C 07 46 0B    	call IDE_write_sect				; write sector
2134   141F             cmd_rm_not_found:	
2135   141F 06          	sysret	
2136   1420             
2137   1420             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2138   1420             ;; mv - move / change file name
2139   1420             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2140   1420             cmd_mv:
2141   1420 FD 4E       	mov si, d
2142   1422 FD 4F DA 1C 	mov di, temp_data
2143   1426 38 00 02    	mov c, 512
2144   1429 04          	load						; load data from user-space
2145   142A 14 30 16    	mov a, [current_dirID]
2146   142D 77          	inc a						; metadata sector
2147   142E 27          	mov b, a	
2148   142F 38 00 00    	mov c, 0					; reset LBA to 0
2149   1432 22 01       	mov ah, $01				; disk read
2150   1434 3B DA 28    	mov d, transient_area
2151   1437 07 20 0B    	call IDE_read_sect		;read directory
2152   143A FD 10       	cla
2153   143C 42 28 16    	mov [index], a				;reset file counter
2154   143F             cmd_mv_L1:
2155   143F FD 4E       	mov si, d
2156   1441 FD 4F DA 1C 	mov di, temp_data
2157   1445 07 93 00    	call strcmp
2158   1448 C6 5E 14    	je cmd_mv_found_entry
2159   144B 58 20 00    	add d, 32
2160   144E 14 28 16    	mov a, [index]
2161   1451 77          	inc a
2162   1452 42 28 16    	mov [index], a
2163   1455 AF 10 00    	cmp a, FST_FILES_PER_DIR
2164   1458 C6 90 14    	je cmd_mv_not_found
2165   145B 0A 3F 14    	jmp cmd_mv_L1
2166   145E             cmd_mv_found_entry:	
2167   145E DA          	push d
2168   145F FD 4D 5A 1D 	mov si, temp_data + 128	; (0...127) = original filename , (128...255) = new name
2169   1463 FD 50       	mov di, d
2170   1465 07 A8 00    	call strcpy	
2171   1468 38 00 00    	mov c, 0
2172   146B 3B DA 28    	mov d, transient_area
2173   146E 22 01       	mov ah, $01					;disk write 1 sect
2174   1470 07 46 0B    	call IDE_write_sect			;write sector
2175   1473 E7          	pop d
2176   1474             ;;;;;;;; need to check whether its a dir or a file here ;;;;;;;;;;;;;;
2177   1474 2B 19 00    	mov b, [d + 25]				; get the dirID of the directory so we can locate its own entry in the list
2178   1477 22 01       	mov ah, $01
2179   1479 3B DA 28    	mov d, transient_area
2180   147C 38 00 00    	mov c, 0
2181   147F 07 20 0B    	call IDE_read_sect			; read directory entry
2182   1482 FD 4D 5A 1D 	mov si, temp_data + 128
2183   1486 FD 50       	mov di, d
2184   1488 07 A8 00    	call strcpy					; change directory's name
2185   148B 22 01       	mov ah, $01
2186   148D 07 46 0B    	call IDE_write_sect			; rewrite directory back to disk
2187   1490             cmd_mv_not_found:
2188   1490 06          	sysret
2189   1491             
2190   1491             KERNEL_RESET_VECTOR:	
2191   1491 FD 49 FF F7 	mov bp, STACK_BEGIN
2192   1495 FD 47 FF F7 	mov sp, STACK_BEGIN
2193   1499             	
2194   1499 19 80       	mov al, %10000000
2195   149B FD 0F       	stomsk					; mask out timer interrupt for now (only allow UART to interrupt)
2196   149D FD 0C       	sti	
2197   149F             
2198   149F 0C          	lodstat
2199   14A0 87 DF       	and al, %11011111	; disable display register loading
2200   14A2 0D          	stostat
2201   14A3             	
2202   14A3             ; reset fifo pointers
2203   14A3 10 DA 1E    	mov a, fifo
2204   14A6 3B 2C 16    	mov d, fifo_pi
2205   14A9 43          	mov [d], a
2206   14AA 3B 2E 16    	mov d, fifo_pr
2207   14AD 43          	mov [d], a	
2208   14AE 19 02       	mov al, 2
2209   14B0 05 03       	syscall sys_io			; enable uart in interrupt mode
2210   14B2             	
2211   14B2 3B 88 16    	mov d, s_kernel_started
2212   14B5 07 88 02    	call puts
2213   14B8             	
2214   14B8 3B AD 16    	mov d, s_prompt_init
2215   14BB 07 88 02    	call puts
2216   14BE             
2217   14BE 19 10       	mov al, 16
2218   14C0 05 04       	syscall sys_fileio		; set root dirID
2219   14C2             
2220   14C2 3B 32 16    	mov d, s_init_path
2221   14C5 05 05       	syscall sys_fork		; launch init as a new process
2222   14C7             
2223   14C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2224   14C7             ;;; Process Index in A
2225   14C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2226   14C7             find_free_proc:
2227   14C7 FD 4D CB 18 	mov si, proc_availab_table + 1			; skip process 0 (kernel)
2228   14CB             find_free_proc_L0:
2229   14CB F6          	lodsb						; get process state
2230   14CC B9 00       	cmp al, 0
2231   14CE C6 D4 14    	je find_free_proc_free			; if free, jump
2232   14D1 0A CB 14    	jmp find_free_proc_L0			; else, goto next
2233   14D4             find_free_proc_free:
2234   14D4 4E          	mov a, si
2235   14D5 5F CB 18    	sub a, 1 + proc_availab_table				; get process index
2236   14D8 09          	ret
2237   14D9             	
2238   14D9             
2239   14D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2240   14D9             ;;; Process Index in AL
2241   14D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2242   14D9             proc_memory_map:
2243   14D9 22 00       	mov ah, 0
2244   14DB 27          	mov b, a			; page in BL, 0 in BH
2245   14DC FD 9D 05    	shl a, 5			; multiply by 32
2246   14DF 39          	mov c, a			; save in C
2247   14E0 57 20 00    	add c, 32
2248   14E3             proc_memory_map_L0:
2249   14E3 02          	pagemap
2250   14E4 55 00 08    	add b, $0800					; increase page number (msb 5 bits of BH only)
2251   14E7 53 01 00    	add a, 1						; increase both 
2252   14EA B1          	cmp a, c						; check to see if we reached the end of memory
2253   14EB C7 E3 14    	jne proc_memory_map_L0
2254   14EE 09          	ret
2255   14EF             	
2256   14EF             
2257   14EF             cmd_terminate_proc:
2258   14EF 51 05 00    	add sp, 5		; clear stack of the values that were pushed by the interrupt (SP, Status, PC)
2259   14F2             					; since they will not be used for anything here.
2260   14F2 1D 27 16    	mov al, [active_proc_index]
2261   14F5 22 00       	mov ah, 0	
2262   14F7 FD 9D 05    	shl a, 5						; x32
2263   14FA 53 DA 18    	add a, proc_names
2264   14FD 3C          	mov d, a
2265   14FE 19 00       	mov al, 0
2266   1500 3E          	mov [d], al			; nullify process name
2267   1501             
2268   1501 1D 27 16    	mov al, [active_proc_index]
2269   1504 22 00       	mov ah, 0	
2270   1506 3C          	mov d, a
2271   1507 19 00       	mov al, 0
2272   1509 3F CA 18    	mov [d + proc_availab_table], al					; make process empty again
2273   150C             	
2274   150C 1D 26 16    	mov al, [nbr_active_procs]			; decrease nbr of active processes
2275   150F 80          	dec al
2276   1510 3D 26 16    	mov [nbr_active_procs], al
2277   1513             
2278   1513             ; now load the shell process again
2279   1513 19 02       	mov al, 2				; next process = process 2 = shell
2280   1515 3D 27 16    	mov [active_proc_index], al		; set next active proc
2281   1518             
2282   1518             ; calculate LUT entry for next process
2283   1518 22 00       	mov ah, 0
2284   151A FD 99       	shl a							; x2
2285   151C B7 E5 15    	mov a, [proc_table_convert + a]		; get process state start index	
2286   151F             	
2287   151F 4D          	mov si, a						; source is proc state block
2288   1520 48          	mov a, sp
2289   1521 5F 13 00    	sub a, 19
2290   1524 4F          	mov di, a						; destination is kernel stack
2291   1525             ; restore SP
2292   1525 7D          	dec a
2293   1526 47          	mov sp, a
2294   1527 38 14 00    	mov c, 20
2295   152A FD F5       	rep movsb
2296   152C             ; set VM process
2297   152C 1D 27 16    	mov al, [active_proc_index]
2298   152F 01          	setptb
2299   1530             		
2300   1530 4C          	popa
2301   1531 06          	sysret
2302   1532             
2303   1532             cmd_pause_proc:
2304   1532             ; save all registers into kernel stack
2305   1532 4B          	pusha
2306   1533 22 00       	mov ah, 0
2307   1535 1D 27 16    	mov al, [active_proc_index]
2308   1538 FD 99       	shl a							; x2
2309   153A B7 E5 15    	mov a, [proc_table_convert + a]	; get process state start index
2310   153D             		
2311   153D 4F          	mov di, a
2312   153E 48          	mov a, sp
2313   153F 77          	inc a
2314   1540 4D          	mov si, a
2315   1541 38 14 00    	mov c, 20
2316   1544 FD F5       	rep movsb					; save process state!
2317   1546             ; restore kernel stack position to point before interrupt arrived
2318   1546 51 14 00    	add sp, 20
2319   1549             ; now load the shell process again
2320   1549 19 02       	mov al, 2				; next process = process 2 = shell
2321   154B 3D 27 16    	mov [active_proc_index], al		; set next active proc
2322   154E             
2323   154E             ; calculate LUT entry for next process
2324   154E 22 00       	mov ah, 0
2325   1550 FD 99       	shl a							; x2
2326   1552 B7 E5 15    	mov a, [proc_table_convert + a]		; get process state start index	
2327   1555             	
2328   1555 4D          	mov si, a						; source is proc state block
2329   1556 48          	mov a, sp
2330   1557 5F 13 00    	sub a, 19
2331   155A 4F          	mov di, a						; destination is kernel stack
2332   155B             ; restore SP
2333   155B 7D          	dec a
2334   155C 47          	mov sp, a
2335   155D 38 14 00    	mov c, 20
2336   1560 FD F5       	rep movsb
2337   1562             ; set VM process
2338   1562 1D 27 16    	mov al, [active_proc_index]
2339   1565 01          	setptb
2340   1566             		
2341   1566 4C          	popa
2342   1567 06          	sysret
2343   1568             
2344   1568             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2345   1568             ;; fork a new process
2346   1568             ;; D = path of the process file to be forked
2347   1568             ;; B = arguments ptr
2348   1568             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2349   1568             cmd_fork:
2350   1568             ; we save the active process first	
2351   1568 4B          	pusha
2352   1569 22 00       	mov ah, 0
2353   156B 1D 27 16    	mov al, [active_proc_index]
2354   156E FD 99       	shl a							; x2
2355   1570 B7 E5 15    	mov a, [proc_table_convert + a]		; get process state table's start index
2356   1573             	
2357   1573 4F          	mov di, a
2358   1574 48          	mov a, sp
2359   1575 77          	inc a
2360   1576 4D          	mov si, a
2361   1577 38 14 00    	mov c, 20
2362   157A FD F5       	rep movsb					; save process state!
2363   157C             ; restore kernel stack position to point before interrupt arrived
2364   157C 51 14 00    	add sp, 20
2365   157F             	
2366   157F FD 4E       	mov si, d				; copy the file path
2367   1581 FD 4F DA 1C 	mov di, temp_data
2368   1585 38 00 02    	mov c, 512
2369   1588 04          	load
2370   1589 11          	mov a, b
2371   158A 4D          	mov si, a				; copy the arguments
2372   158B FD 4F DA 26 	mov di, scrap_sector
2373   158F 38 00 02    	mov c, 512
2374   1592 04          	load
2375   1593 07 D6 0F    	call loadfile_from_path		; load the process file from disk by path (path is in temp_data)
2376   1596             								; the file data is loaded into transient_area
2377   1596             ; now we allocate a new process	
2378   1596 07 C7 14    	call find_free_proc			; index in A
2379   1599 01          	setptb
2380   159A 07 D9 14    	call proc_memory_map			; map process memory pages
2381   159D             ; copy arguments into process's memory
2382   159D FD 4D DA 26 	mov si, scrap_sector
2383   15A1 FD 4F 00 00 	mov di, 0
2384   15A5 38 00 02    	mov c, 512
2385   15A8 03          	store
2386   15A9             ; now copy process binary data into process's memory
2387   15A9 FD 4D DA 28 	mov si, transient_area
2388   15AD FD 4F 00 04 	mov di, PROC_TEXT_ORG		; code origin address for all user processes
2389   15B1 38 00 40    	mov c, FS_FILE_SIZE			; size of memory space to copy, which is equal to the max file size in disk (for now)
2390   15B4 03          	store						; copy process data
2391   15B5             		
2392   15B5 07 C7 14    	call find_free_proc			; index in A
2393   15B8 3D 27 16    	mov [active_proc_index], al		; set new active process
2394   15BB FD 9D 05    	shl a, 5						; x32
2395   15BE 53 DA 18    	add a, proc_names
2396   15C1 4F          	mov di, a
2397   15C2 FD 4D DA 1C 	mov si, temp_data			; copy and store process filename
2398   15C6 07 A8 00    	call strcpy
2399   15C9             	
2400   15C9 07 C7 14    	call find_free_proc			; index in A
2401   15CC 3C          	mov d, a
2402   15CD 19 01       	mov al, 1
2403   15CF 3F CA 18    	mov [d + proc_availab_table], al					; make process busy
2404   15D2             	
2405   15D2 1D 26 16    	mov al, [nbr_active_procs]			; increase nbr of active processes
2406   15D5 7A          	inc al
2407   15D6 3D 26 16    	mov [nbr_active_procs], al
2408   15D9             ; launch process
2409   15D9 FD D7 FF FF 	push word $FFFF 
2410   15DD FD DB 0E    	push byte %00001110		; dma_ack = 0, interrupts enabled = 1, mode = user, paging = on, halt=0, display_reg_load=0, dir=0
2411   15E0 FD D7 00 04 	push word PROC_TEXT_ORG
2412   15E4 06          	sysret
2413   15E5             
2414   15E5             proc_table_convert:
2415   15E5 8A 17       	.dw proc_state_table + 0
2416   15E7 9E 17       	.dw proc_state_table + 20
2417   15E9 B2 17       	.dw proc_state_table + 40
2418   15EB C6 17       	.dw proc_state_table + 60
2419   15ED DA 17       	.dw proc_state_table + 80
2420   15EF EE 17       	.dw proc_state_table + 100
2421   15F1 02 18       	.dw proc_state_table + 120
2422   15F3 16 18       	.dw proc_state_table + 140
2423   15F5             	
2424   15F5             ; ************************************************************
2425   15F5             ; GET HEX FILE
2426   15F5             ; di = destination address
2427   15F5             ; return length in bytes in C
2428   15F5             ; ************************************************************
2429   15F5             _load_hex:
2430   15F5 D2          	push bp
2431   15F6 9B          	mov bp, sp
2432   15F7 D7          	push a
2433   15F8 D8          	push b
2434   15F9 DA          	push d
2435   15FA E2          	push si
2436   15FB E3          	push di
2437   15FC 52 00 80    	sub sp, $8000				; string data block
2438   15FF 38 00 00    	mov c, 0
2439   1602 48          	mov a, sp
2440   1603 77          	inc a
2441   1604 3C          	mov d, a				; start of string data block
2442   1605 07 55 01    	call gets				; get program string
2443   1608 4D          	mov si, a
2444   1609             __load_hex_loop:
2445   1609 F6          	lodsb					; load from [SI] to AL
2446   160A B9 00       	cmp al, 0				; check if ASCII 0
2447   160C C6 1A 16    	jz __load_hex_ret
2448   160F 36          	mov bh, al
2449   1610 F6          	lodsb
2450   1611 2F          	mov bl, al
2451   1612 07 03 01    	call atoi				; convert ASCII byte in B to int (to AL)
2452   1615 F7          	stosb					; store AL to [DI]
2453   1616 78          	inc c
2454   1617 0A 09 16    	jmp __load_hex_loop
2455   161A             __load_hex_ret:
2456   161A 51 00 80    	add sp, $8000
2457   161D F0          	pop di
2458   161E EF          	pop si
2459   161F E7          	pop d
2460   1620 E5          	pop b
2461   1621 E4          	pop a
2462   1622 9C          	mov sp, bp
2463   1623 F1          	pop bp
2464   1624 09          	ret
2465   1625             
2466   1625             ; synopsis: look insIDE a certain DIRECTORY for files/directories
2467   1625             ; BEFORE CALLING THIS FUNCTION, CD INTO REQUIRED DIRECTORY
2468   1625             ; for each entry insIDE DIRECTORY:
2469   1625             ;	if entry is a file:
2470   1625             ;		compare filename to searched filename
2471   1625             ;		if filenames are the same, print filename
2472   1625             ;	else if entry is a directory:
2473   1625             ;		cd to the given directory
2474   1625             ;		recursively call cmd_find
2475   1625             ;		cd outsIDE previous directory
2476   1625             ;	if current entry == last entry, return
2477   1625             ; endfor
2478   1625             ;		
2479   1625             ;	
2480   1625             f_find:
2481   1625             	
2482   1625 09          	ret
2483   1626             
2484   1626             
2485   1626             
2486   1626 00          nbr_active_procs:	.db 0
2487   1627 01          active_proc_index:	.db 1
2488   1628             
2489   1628 00 00       index:				.dw 0
2490   162A 00 00       buffer_addr:		.dw 0
2491   162C             
2492   162C DA 1E       fifo_pi:			.dw fifo
2493   162E DA 1E       fifo_pr:			.dw fifo
2494   1630             
2495   1630             ; file system variables
2496   1630 00 00       current_dirID:		.dw 0				; keep dirID of current directory
2497   1632 2F 73 62 69 s_init_path:		.db "/sbin/init", 0
2497   1636 6E 2F 69 6E 
2497   163A 69 74 00 
2498   163D             
2499   163D 2E 2E 00    s_parent_dir:		.db "..", 0
2500   1640 2E 00       s_current_dir:		.db ".", 0
2501   1642 2F 00       s_fslash: 			.db "/", 0
2502   1644 20 23 20 00 s_hash:				.db " # ", 0
2503   1648 2D 72 77 20 file_attrib:		.db "-rw x"			; chars at multiples of 2
2503   164C 78 
2504   164D 2D 64 63    file_type:			.db "-dc"
2505   1650 50 49 44 20 s_ps_header:		.db "PID COMMAND\n", 0
2505   1654 43 4F 4D 4D 
2505   1658 41 4E 44 0A 
2505   165C 00 
2506   165D 53 6F 6C 2D s_host: 			.db "Sol-1:", 0
2506   1661 31 3A 00 
2507   1664 53 6F 6C 61 s_uname:			.db "Solarium\n", 0
2507   1668 72 69 75 6D 
2507   166C 0A 00 
2508   166E             
2509   166E 72 6F 6F 74 s_root:				.db "root\n", 0
2509   1672 0A 00 
2510   1674             
2511   1674 69 6E 74 65 s_int_en:			.db "interrupts enabled\n", 0
2511   1678 72 72 75 70 
2511   167C 74 73 20 65 
2511   1680 6E 61 62 6C 
2511   1684 65 64 0A 00 
2512   1688 6B 65 72 6E s_kernel_started:	.db "kernel started\n", 0
2512   168C 65 6C 20 73 
2512   1690 74 61 72 74 
2512   1694 65 64 0A 00 
2513   1698 65 6E 74 65 s_procname:			.db "enter process name: ", 0
2513   169C 72 20 70 72 
2513   16A0 6F 63 65 73 
2513   16A4 73 20 6E 61 
2513   16A8 6D 65 3A 20 
2513   16AC 00 
2514   16AD 73 74 61 72 s_prompt_init:		.db "starting init\n", 0
2514   16B1 74 69 6E 67 
2514   16B5 20 69 6E 69 
2514   16B9 74 0A 00 
2515   16BC 0A 73 6F 66 s_priviledge:		.db "\nsoftware failure: privilege exception\n", 0
2515   16C0 74 77 61 72 
2515   16C4 65 20 66 61 
2515   16C8 69 6C 75 72 
2515   16CC 65 3A 20 70 
2515   16D0 72 69 76 69 
2515   16D4 6C 65 67 65 
2515   16D8 20 65 78 63 
2515   16DC 65 70 74 69 
2515   16E0 6F 6E 0A 00 
2516   16E4 0A 65 78 63 s_divzero:			.db "\nexception: zero division\n", 0
2516   16E8 65 70 74 69 
2516   16EC 6F 6E 3A 20 
2516   16F0 7A 65 72 6F 
2516   16F4 20 64 69 76 
2516   16F8 69 73 69 6F 
2516   16FC 6E 0A 00 
2517   16FF             
2518   16FF 59 65 61 72 s_set_year:			.db "Year: ", 0
2518   1703 3A 20 00 
2519   1706 4D 6F 6E 74 s_set_month:		.db "Month: ", 0
2519   170A 68 3A 20 00 
2520   170E 44 61 79 3A s_set_day:			.db "Day: ", 0
2520   1712 20 00 
2521   1714 57 65 65 6B s_set_week:			.db "Weekday: ", 0
2521   1718 64 61 79 3A 
2521   171C 20 00 
2522   171E 48 6F 75 72 s_set_hours:		.db "Hours: ", 0
2522   1722 73 3A 20 00 
2523   1726 4D 69 6E 75 s_set_minutes:		.db "Minutes: ", 0
2523   172A 74 65 73 3A 
2523   172E 20 00 
2524   1730 53 65 63 6F s_set_seconds:		.db "Seconds: ", 0
2524   1734 6E 64 73 3A 
2524   1738 20 00 
2525   173A 20 20 20 00 s_months:			.db "   ", 0
2526   173E 4A 61 6E 00 					.db "Jan", 0
2527   1742 46 65 62 00 					.db "Feb", 0
2528   1746 4D 61 72 00 					.db "Mar", 0
2529   174A 41 70 72 00 					.db "Apr", 0
2530   174E 4D 61 79 00 					.db "May", 0
2531   1752 4A 75 6E 00 					.db "Jun", 0
2532   1756 4A 75 6C 00 					.db "Jul", 0
2533   175A 41 75 67 00 					.db "Aug", 0
2534   175E 53 65 70 00 					.db "Sep", 0
2535   1762 4F 63 74 00 					.db "Oct", 0
2536   1766 4E 6F 76 00 					.db "Nov", 0
2537   176A 44 65 63 00 					.db "Dec", 0
2538   176E 53 75 6E 00 s_week:				.db "Sun", 0 
2539   1772 4D 6F 6E 00 					.db "Mon", 0 
2540   1776 54 75 65 00 					.db "Tue", 0 
2541   177A 57 65 64 00 					.db "Wed", 0 
2542   177E 54 68 75 00 					.db "Thu", 0 
2543   1782 46 72 69 00 					.db "Fri", 0 
2544   1786 53 61 74 00 					.db "Sat", 0
2545   178A             
2546   178A 00 00 00 00 proc_state_table:	.fill 16 * 20, 0	; for 15 processes max
2546   178E 00 00 00 00 
2546   1792 00 00 00 00 
2546   1796 00 00 00 00 
2546   179A 00 00 00 00 
2546   179E 00 00 00 00 
2546   17A2 00 00 00 00 
2546   17A6 00 00 00 00 
2546   17AA 00 00 00 00 
2546   17AE 00 00 00 00 
2546   17B2 00 00 00 00 
2546   17B6 00 00 00 00 
2546   17BA 00 00 00 00 
2546   17BE 00 00 00 00 
2546   17C2 00 00 00 00 
2546   17C6 00 00 00 00 
2546   17CA 00 00 00 00 
2546   17CE 00 00 00 00 
2546   17D2 00 00 00 00 
2546   17D6 00 00 00 00 
2546   17DA 00 00 00 00 
2546   17DE 00 00 00 00 
2546   17E2 00 00 00 00 
2546   17E6 00 00 00 00 
2546   17EA 00 00 00 00 
2546   17EE 00 00 00 00 
2546   17F2 00 00 00 00 
2546   17F6 00 00 00 00 
2546   17FA 00 00 00 00 
2546   17FE 00 00 00 00 
2546   1802 00 00 00 00 
2546   1806 00 00 00 00 
2546   180A 00 00 00 00 
2546   180E 00 00 00 00 
2546   1812 00 00 00 00 
2546   1816 00 00 00 00 
2546   181A 00 00 00 00 
2546   181E 00 00 00 00 
2546   1822 00 00 00 00 
2546   1826 00 00 00 00 
2546   182A 00 00 00 00 
2546   182E 00 00 00 00 
2546   1832 00 00 00 00 
2546   1836 00 00 00 00 
2546   183A 00 00 00 00 
2546   183E 00 00 00 00 
2546   1842 00 00 00 00 
2546   1846 00 00 00 00 
2546   184A 00 00 00 00 
2546   184E 00 00 00 00 
2546   1852 00 00 00 00 
2546   1856 00 00 00 00 
2546   185A 00 00 00 00 
2546   185E 00 00 00 00 
2546   1862 00 00 00 00 
2546   1866 00 00 00 00 
2546   186A 00 00 00 00 
2546   186E 00 00 00 00 
2546   1872 00 00 00 00 
2546   1876 00 00 00 00 
2546   187A 00 00 00 00 
2546   187E 00 00 00 00 
2546   1882 00 00 00 00 
2546   1886 00 00 00 00 
2546   188A 00 00 00 00 
2546   188E 00 00 00 00 
2546   1892 00 00 00 00 
2546   1896 00 00 00 00 
2546   189A 00 00 00 00 
2546   189E 00 00 00 00 
2546   18A2 00 00 00 00 
2546   18A6 00 00 00 00 
2546   18AA 00 00 00 00 
2546   18AE 00 00 00 00 
2546   18B2 00 00 00 00 
2546   18B6 00 00 00 00 
2546   18BA 00 00 00 00 
2546   18BE 00 00 00 00 
2546   18C2 00 00 00 00 
2546   18C6 00 00 00 00 
2547   18CA 00 00 00 00 proc_availab_table:	.fill 16, 0			; space for 15 processes. 0 = process empty, 1 = process taken
2547   18CE 00 00 00 00 
2547   18D2 00 00 00 00 
2547   18D6 00 00 00 00 
2548   18DA 00 00 00 00 proc_names:			.fill 16 * 32, 0	; process names
2548   18DE 00 00 00 00 
2548   18E2 00 00 00 00 
2548   18E6 00 00 00 00 
2548   18EA 00 00 00 00 
2548   18EE 00 00 00 00 
2548   18F2 00 00 00 00 
2548   18F6 00 00 00 00 
2548   18FA 00 00 00 00 
2548   18FE 00 00 00 00 
2548   1902 00 00 00 00 
2548   1906 00 00 00 00 
2548   190A 00 00 00 00 
2548   190E 00 00 00 00 
2548   1912 00 00 00 00 
2548   1916 00 00 00 00 
2548   191A 00 00 00 00 
2548   191E 00 00 00 00 
2548   1922 00 00 00 00 
2548   1926 00 00 00 00 
2548   192A 00 00 00 00 
2548   192E 00 00 00 00 
2548   1932 00 00 00 00 
2548   1936 00 00 00 00 
2548   193A 00 00 00 00 
2548   193E 00 00 00 00 
2548   1942 00 00 00 00 
2548   1946 00 00 00 00 
2548   194A 00 00 00 00 
2548   194E 00 00 00 00 
2548   1952 00 00 00 00 
2548   1956 00 00 00 00 
2548   195A 00 00 00 00 
2548   195E 00 00 00 00 
2548   1962 00 00 00 00 
2548   1966 00 00 00 00 
2548   196A 00 00 00 00 
2548   196E 00 00 00 00 
2548   1972 00 00 00 00 
2548   1976 00 00 00 00 
2548   197A 00 00 00 00 
2548   197E 00 00 00 00 
2548   1982 00 00 00 00 
2548   1986 00 00 00 00 
2548   198A 00 00 00 00 
2548   198E 00 00 00 00 
2548   1992 00 00 00 00 
2548   1996 00 00 00 00 
2548   199A 00 00 00 00 
2548   199E 00 00 00 00 
2548   19A2 00 00 00 00 
2548   19A6 00 00 00 00 
2548   19AA 00 00 00 00 
2548   19AE 00 00 00 00 
2548   19B2 00 00 00 00 
2548   19B6 00 00 00 00 
2548   19BA 00 00 00 00 
2548   19BE 00 00 00 00 
2548   19C2 00 00 00 00 
2548   19C6 00 00 00 00 
2548   19CA 00 00 00 00 
2548   19CE 00 00 00 00 
2548   19D2 00 00 00 00 
2548   19D6 00 00 00 00 
2548   19DA 00 00 00 00 
2548   19DE 00 00 00 00 
2548   19E2 00 00 00 00 
2548   19E6 00 00 00 00 
2548   19EA 00 00 00 00 
2548   19EE 00 00 00 00 
2548   19F2 00 00 00 00 
2548   19F6 00 00 00 00 
2548   19FA 00 00 00 00 
2548   19FE 00 00 00 00 
2548   1A02 00 00 00 00 
2548   1A06 00 00 00 00 
2548   1A0A 00 00 00 00 
2548   1A0E 00 00 00 00 
2548   1A12 00 00 00 00 
2548   1A16 00 00 00 00 
2548   1A1A 00 00 00 00 
2548   1A1E 00 00 00 00 
2548   1A22 00 00 00 00 
2548   1A26 00 00 00 00 
2548   1A2A 00 00 00 00 
2548   1A2E 00 00 00 00 
2548   1A32 00 00 00 00 
2548   1A36 00 00 00 00 
2548   1A3A 00 00 00 00 
2548   1A3E 00 00 00 00 
2548   1A42 00 00 00 00 
2548   1A46 00 00 00 00 
2548   1A4A 00 00 00 00 
2548   1A4E 00 00 00 00 
2548   1A52 00 00 00 00 
2548   1A56 00 00 00 00 
2548   1A5A 00 00 00 00 
2548   1A5E 00 00 00 00 
2548   1A62 00 00 00 00 
2548   1A66 00 00 00 00 
2548   1A6A 00 00 00 00 
2548   1A6E 00 00 00 00 
2548   1A72 00 00 00 00 
2548   1A76 00 00 00 00 
2548   1A7A 00 00 00 00 
2548   1A7E 00 00 00 00 
2548   1A82 00 00 00 00 
2548   1A86 00 00 00 00 
2548   1A8A 00 00 00 00 
2548   1A8E 00 00 00 00 
2548   1A92 00 00 00 00 
2548   1A96 00 00 00 00 
2548   1A9A 00 00 00 00 
2548   1A9E 00 00 00 00 
2548   1AA2 00 00 00 00 
2548   1AA6 00 00 00 00 
2548   1AAA 00 00 00 00 
2548   1AAE 00 00 00 00 
2548   1AB2 00 00 00 00 
2548   1AB6 00 00 00 00 
2548   1ABA 00 00 00 00 
2548   1ABE 00 00 00 00 
2548   1AC2 00 00 00 00 
2548   1AC6 00 00 00 00 
2548   1ACA 00 00 00 00 
2548   1ACE 00 00 00 00 
2548   1AD2 00 00 00 00 
2548   1AD6 00 00 00 00 
2549   1ADA 00 00 00 00 filename:			.fill 512, 0		; holds a path for file search
2549   1ADE 00 00 00 00 
2549   1AE2 00 00 00 00 
2549   1AE6 00 00 00 00 
2549   1AEA 00 00 00 00 
2549   1AEE 00 00 00 00 
2549   1AF2 00 00 00 00 
2549   1AF6 00 00 00 00 
2549   1AFA 00 00 00 00 
2549   1AFE 00 00 00 00 
2549   1B02 00 00 00 00 
2549   1B06 00 00 00 00 
2549   1B0A 00 00 00 00 
2549   1B0E 00 00 00 00 
2549   1B12 00 00 00 00 
2549   1B16 00 00 00 00 
2549   1B1A 00 00 00 00 
2549   1B1E 00 00 00 00 
2549   1B22 00 00 00 00 
2549   1B26 00 00 00 00 
2549   1B2A 00 00 00 00 
2549   1B2E 00 00 00 00 
2549   1B32 00 00 00 00 
2549   1B36 00 00 00 00 
2549   1B3A 00 00 00 00 
2549   1B3E 00 00 00 00 
2549   1B42 00 00 00 00 
2549   1B46 00 00 00 00 
2549   1B4A 00 00 00 00 
2549   1B4E 00 00 00 00 
2549   1B52 00 00 00 00 
2549   1B56 00 00 00 00 
2549   1B5A 00 00 00 00 
2549   1B5E 00 00 00 00 
2549   1B62 00 00 00 00 
2549   1B66 00 00 00 00 
2549   1B6A 00 00 00 00 
2549   1B6E 00 00 00 00 
2549   1B72 00 00 00 00 
2549   1B76 00 00 00 00 
2549   1B7A 00 00 00 00 
2549   1B7E 00 00 00 00 
2549   1B82 00 00 00 00 
2549   1B86 00 00 00 00 
2549   1B8A 00 00 00 00 
2549   1B8E 00 00 00 00 
2549   1B92 00 00 00 00 
2549   1B96 00 00 00 00 
2549   1B9A 00 00 00 00 
2549   1B9E 00 00 00 00 
2549   1BA2 00 00 00 00 
2549   1BA6 00 00 00 00 
2549   1BAA 00 00 00 00 
2549   1BAE 00 00 00 00 
2549   1BB2 00 00 00 00 
2549   1BB6 00 00 00 00 
2549   1BBA 00 00 00 00 
2549   1BBE 00 00 00 00 
2549   1BC2 00 00 00 00 
2549   1BC6 00 00 00 00 
2549   1BCA 00 00 00 00 
2549   1BCE 00 00 00 00 
2549   1BD2 00 00 00 00 
2549   1BD6 00 00 00 00 
2549   1BDA 00 00 00 00 
2549   1BDE 00 00 00 00 
2549   1BE2 00 00 00 00 
2549   1BE6 00 00 00 00 
2549   1BEA 00 00 00 00 
2549   1BEE 00 00 00 00 
2549   1BF2 00 00 00 00 
2549   1BF6 00 00 00 00 
2549   1BFA 00 00 00 00 
2549   1BFE 00 00 00 00 
2549   1C02 00 00 00 00 
2549   1C06 00 00 00 00 
2549   1C0A 00 00 00 00 
2549   1C0E 00 00 00 00 
2549   1C12 00 00 00 00 
2549   1C16 00 00 00 00 
2549   1C1A 00 00 00 00 
2549   1C1E 00 00 00 00 
2549   1C22 00 00 00 00 
2549   1C26 00 00 00 00 
2549   1C2A 00 00 00 00 
2549   1C2E 00 00 00 00 
2549   1C32 00 00 00 00 
2549   1C36 00 00 00 00 
2549   1C3A 00 00 00 00 
2549   1C3E 00 00 00 00 
2549   1C42 00 00 00 00 
2549   1C46 00 00 00 00 
2549   1C4A 00 00 00 00 
2549   1C4E 00 00 00 00 
2549   1C52 00 00 00 00 
2549   1C56 00 00 00 00 
2549   1C5A 00 00 00 00 
2549   1C5E 00 00 00 00 
2549   1C62 00 00 00 00 
2549   1C66 00 00 00 00 
2549   1C6A 00 00 00 00 
2549   1C6E 00 00 00 00 
2549   1C72 00 00 00 00 
2549   1C76 00 00 00 00 
2549   1C7A 00 00 00 00 
2549   1C7E 00 00 00 00 
2549   1C82 00 00 00 00 
2549   1C86 00 00 00 00 
2549   1C8A 00 00 00 00 
2549   1C8E 00 00 00 00 
2549   1C92 00 00 00 00 
2549   1C96 00 00 00 00 
2549   1C9A 00 00 00 00 
2549   1C9E 00 00 00 00 
2549   1CA2 00 00 00 00 
2549   1CA6 00 00 00 00 
2549   1CAA 00 00 00 00 
2549   1CAE 00 00 00 00 
2549   1CB2 00 00 00 00 
2549   1CB6 00 00 00 00 
2549   1CBA 00 00 00 00 
2549   1CBE 00 00 00 00 
2549   1CC2 00 00 00 00 
2549   1CC6 00 00 00 00 
2549   1CCA 00 00 00 00 
2549   1CCE 00 00 00 00 
2549   1CD2 00 00 00 00 
2549   1CD6 00 00 00 00 
2550   1CDA 00 00 00 00 temp_data:			.fill 512, 0   		;  user space data
2550   1CDE 00 00 00 00 
2550   1CE2 00 00 00 00 
2550   1CE6 00 00 00 00 
2550   1CEA 00 00 00 00 
2550   1CEE 00 00 00 00 
2550   1CF2 00 00 00 00 
2550   1CF6 00 00 00 00 
2550   1CFA 00 00 00 00 
2550   1CFE 00 00 00 00 
2550   1D02 00 00 00 00 
2550   1D06 00 00 00 00 
2550   1D0A 00 00 00 00 
2550   1D0E 00 00 00 00 
2550   1D12 00 00 00 00 
2550   1D16 00 00 00 00 
2550   1D1A 00 00 00 00 
2550   1D1E 00 00 00 00 
2550   1D22 00 00 00 00 
2550   1D26 00 00 00 00 
2550   1D2A 00 00 00 00 
2550   1D2E 00 00 00 00 
2550   1D32 00 00 00 00 
2550   1D36 00 00 00 00 
2550   1D3A 00 00 00 00 
2550   1D3E 00 00 00 00 
2550   1D42 00 00 00 00 
2550   1D46 00 00 00 00 
2550   1D4A 00 00 00 00 
2550   1D4E 00 00 00 00 
2550   1D52 00 00 00 00 
2550   1D56 00 00 00 00 
2550   1D5A 00 00 00 00 
2550   1D5E 00 00 00 00 
2550   1D62 00 00 00 00 
2550   1D66 00 00 00 00 
2550   1D6A 00 00 00 00 
2550   1D6E 00 00 00 00 
2550   1D72 00 00 00 00 
2550   1D76 00 00 00 00 
2550   1D7A 00 00 00 00 
2550   1D7E 00 00 00 00 
2550   1D82 00 00 00 00 
2550   1D86 00 00 00 00 
2550   1D8A 00 00 00 00 
2550   1D8E 00 00 00 00 
2550   1D92 00 00 00 00 
2550   1D96 00 00 00 00 
2550   1D9A 00 00 00 00 
2550   1D9E 00 00 00 00 
2550   1DA2 00 00 00 00 
2550   1DA6 00 00 00 00 
2550   1DAA 00 00 00 00 
2550   1DAE 00 00 00 00 
2550   1DB2 00 00 00 00 
2550   1DB6 00 00 00 00 
2550   1DBA 00 00 00 00 
2550   1DBE 00 00 00 00 
2550   1DC2 00 00 00 00 
2550   1DC6 00 00 00 00 
2550   1DCA 00 00 00 00 
2550   1DCE 00 00 00 00 
2550   1DD2 00 00 00 00 
2550   1DD6 00 00 00 00 
2550   1DDA 00 00 00 00 
2550   1DDE 00 00 00 00 
2550   1DE2 00 00 00 00 
2550   1DE6 00 00 00 00 
2550   1DEA 00 00 00 00 
2550   1DEE 00 00 00 00 
2550   1DF2 00 00 00 00 
2550   1DF6 00 00 00 00 
2550   1DFA 00 00 00 00 
2550   1DFE 00 00 00 00 
2550   1E02 00 00 00 00 
2550   1E06 00 00 00 00 
2550   1E0A 00 00 00 00 
2550   1E0E 00 00 00 00 
2550   1E12 00 00 00 00 
2550   1E16 00 00 00 00 
2550   1E1A 00 00 00 00 
2550   1E1E 00 00 00 00 
2550   1E22 00 00 00 00 
2550   1E26 00 00 00 00 
2550   1E2A 00 00 00 00 
2550   1E2E 00 00 00 00 
2550   1E32 00 00 00 00 
2550   1E36 00 00 00 00 
2550   1E3A 00 00 00 00 
2550   1E3E 00 00 00 00 
2550   1E42 00 00 00 00 
2550   1E46 00 00 00 00 
2550   1E4A 00 00 00 00 
2550   1E4E 00 00 00 00 
2550   1E52 00 00 00 00 
2550   1E56 00 00 00 00 
2550   1E5A 00 00 00 00 
2550   1E5E 00 00 00 00 
2550   1E62 00 00 00 00 
2550   1E66 00 00 00 00 
2550   1E6A 00 00 00 00 
2550   1E6E 00 00 00 00 
2550   1E72 00 00 00 00 
2550   1E76 00 00 00 00 
2550   1E7A 00 00 00 00 
2550   1E7E 00 00 00 00 
2550   1E82 00 00 00 00 
2550   1E86 00 00 00 00 
2550   1E8A 00 00 00 00 
2550   1E8E 00 00 00 00 
2550   1E92 00 00 00 00 
2550   1E96 00 00 00 00 
2550   1E9A 00 00 00 00 
2550   1E9E 00 00 00 00 
2550   1EA2 00 00 00 00 
2550   1EA6 00 00 00 00 
2550   1EAA 00 00 00 00 
2550   1EAE 00 00 00 00 
2550   1EB2 00 00 00 00 
2550   1EB6 00 00 00 00 
2550   1EBA 00 00 00 00 
2550   1EBE 00 00 00 00 
2550   1EC2 00 00 00 00 
2550   1EC6 00 00 00 00 
2550   1ECA 00 00 00 00 
2550   1ECE 00 00 00 00 
2550   1ED2 00 00 00 00 
2550   1ED6 00 00 00 00 
2551   1EDA FF FF FF FF fifo:				.fill FIFO_SIZE
2551   1EDE FF FF FF FF 
2551   1EE2 FF FF FF FF 
2551   1EE6 FF FF FF FF 
2551   1EEA FF FF FF FF 
2551   1EEE FF FF FF FF 
2551   1EF2 FF FF FF FF 
2551   1EF6 FF FF FF FF 
2551   1EFA FF FF FF FF 
2551   1EFE FF FF FF FF 
2551   1F02 FF FF FF FF 
2551   1F06 FF FF FF FF 
2551   1F0A FF FF FF FF 
2551   1F0E FF FF FF FF 
2551   1F12 FF FF FF FF 
2551   1F16 FF FF FF FF 
2551   1F1A FF FF FF FF 
2551   1F1E FF FF FF FF 
2551   1F22 FF FF FF FF 
2551   1F26 FF FF FF FF 
2551   1F2A FF FF FF FF 
2551   1F2E FF FF FF FF 
2551   1F32 FF FF FF FF 
2551   1F36 FF FF FF FF 
2551   1F3A FF FF FF FF 
2551   1F3E FF FF FF FF 
2551   1F42 FF FF FF FF 
2551   1F46 FF FF FF FF 
2551   1F4A FF FF FF FF 
2551   1F4E FF FF FF FF 
2551   1F52 FF FF FF FF 
2551   1F56 FF FF FF FF 
2551   1F5A FF FF FF FF 
2551   1F5E FF FF FF FF 
2551   1F62 FF FF FF FF 
2551   1F66 FF FF FF FF 
2551   1F6A FF FF FF FF 
2551   1F6E FF FF FF FF 
2551   1F72 FF FF FF FF 
2551   1F76 FF FF FF FF 
2551   1F7A FF FF FF FF 
2551   1F7E FF FF FF FF 
2551   1F82 FF FF FF FF 
2551   1F86 FF FF FF FF 
2551   1F8A FF FF FF FF 
2551   1F8E FF FF FF FF 
2551   1F92 FF FF FF FF 
2551   1F96 FF FF FF FF 
2551   1F9A FF FF FF FF 
2551   1F9E FF FF FF FF 
2551   1FA2 FF FF FF FF 
2551   1FA6 FF FF FF FF 
2551   1FAA FF FF FF FF 
2551   1FAE FF FF FF FF 
2551   1FB2 FF FF FF FF 
2551   1FB6 FF FF FF FF 
2551   1FBA FF FF FF FF 
2551   1FBE FF FF FF FF 
2551   1FC2 FF FF FF FF 
2551   1FC6 FF FF FF FF 
2551   1FCA FF FF FF FF 
2551   1FCE FF FF FF FF 
2551   1FD2 FF FF FF FF 
2551   1FD6 FF FF FF FF 
2551   1FDA FF FF FF FF 
2551   1FDE FF FF FF FF 
2551   1FE2 FF FF FF FF 
2551   1FE6 FF FF FF FF 
2551   1FEA FF FF FF FF 
2551   1FEE FF FF FF FF 
2551   1FF2 FF FF FF FF 
2551   1FF6 FF FF FF FF 
2551   1FFA FF FF FF FF 
2551   1FFE FF FF FF FF 
2551   2002 FF FF FF FF 
2551   2006 FF FF FF FF 
2551   200A FF FF FF FF 
2551   200E FF FF FF FF 
2551   2012 FF FF FF FF 
2551   2016 FF FF FF FF 
2551   201A FF FF FF FF 
2551   201E FF FF FF FF 
2551   2022 FF FF FF FF 
2551   2026 FF FF FF FF 
2551   202A FF FF FF FF 
2551   202E FF FF FF FF 
2551   2032 FF FF FF FF 
2551   2036 FF FF FF FF 
2551   203A FF FF FF FF 
2551   203E FF FF FF FF 
2551   2042 FF FF FF FF 
2551   2046 FF FF FF FF 
2551   204A FF FF FF FF 
2551   204E FF FF FF FF 
2551   2052 FF FF FF FF 
2551   2056 FF FF FF FF 
2551   205A FF FF FF FF 
2551   205E FF FF FF FF 
2551   2062 FF FF FF FF 
2551   2066 FF FF FF FF 
2551   206A FF FF FF FF 
2551   206E FF FF FF FF 
2551   2072 FF FF FF FF 
2551   2076 FF FF FF FF 
2551   207A FF FF FF FF 
2551   207E FF FF FF FF 
2551   2082 FF FF FF FF 
2551   2086 FF FF FF FF 
2551   208A FF FF FF FF 
2551   208E FF FF FF FF 
2551   2092 FF FF FF FF 
2551   2096 FF FF FF FF 
2551   209A FF FF FF FF 
2551   209E FF FF FF FF 
2551   20A2 FF FF FF FF 
2551   20A6 FF FF FF FF 
2551   20AA FF FF FF FF 
2551   20AE FF FF FF FF 
2551   20B2 FF FF FF FF 
2551   20B6 FF FF FF FF 
2551   20BA FF FF FF FF 
2551   20BE FF FF FF FF 
2551   20C2 FF FF FF FF 
2551   20C6 FF FF FF FF 
2551   20CA FF FF FF FF 
2551   20CE FF FF FF FF 
2551   20D2 FF FF FF FF 
2551   20D6 FF FF FF FF 
2551   20DA FF FF FF FF 
2551   20DE FF FF FF FF 
2551   20E2 FF FF FF FF 
2551   20E6 FF FF FF FF 
2551   20EA FF FF FF FF 
2551   20EE FF FF FF FF 
2551   20F2 FF FF FF FF 
2551   20F6 FF FF FF FF 
2551   20FA FF FF FF FF 
2551   20FE FF FF FF FF 
2551   2102 FF FF FF FF 
2551   2106 FF FF FF FF 
2551   210A FF FF FF FF 
2551   210E FF FF FF FF 
2551   2112 FF FF FF FF 
2551   2116 FF FF FF FF 
2551   211A FF FF FF FF 
2551   211E FF FF FF FF 
2551   2122 FF FF FF FF 
2551   2126 FF FF FF FF 
2551   212A FF FF FF FF 
2551   212E FF FF FF FF 
2551   2132 FF FF FF FF 
2551   2136 FF FF FF FF 
2551   213A FF FF FF FF 
2551   213E FF FF FF FF 
2551   2142 FF FF FF FF 
2551   2146 FF FF FF FF 
2551   214A FF FF FF FF 
2551   214E FF FF FF FF 
2551   2152 FF FF FF FF 
2551   2156 FF FF FF FF 
2551   215A FF FF FF FF 
2551   215E FF FF FF FF 
2551   2162 FF FF FF FF 
2551   2166 FF FF FF FF 
2551   216A FF FF FF FF 
2551   216E FF FF FF FF 
2551   2172 FF FF FF FF 
2551   2176 FF FF FF FF 
2551   217A FF FF FF FF 
2551   217E FF FF FF FF 
2551   2182 FF FF FF FF 
2551   2186 FF FF FF FF 
2551   218A FF FF FF FF 
2551   218E FF FF FF FF 
2551   2192 FF FF FF FF 
2551   2196 FF FF FF FF 
2551   219A FF FF FF FF 
2551   219E FF FF FF FF 
2551   21A2 FF FF FF FF 
2551   21A6 FF FF FF FF 
2551   21AA FF FF FF FF 
2551   21AE FF FF FF FF 
2551   21B2 FF FF FF FF 
2551   21B6 FF FF FF FF 
2551   21BA FF FF FF FF 
2551   21BE FF FF FF FF 
2551   21C2 FF FF FF FF 
2551   21C6 FF FF FF FF 
2551   21CA FF FF FF FF 
2551   21CE FF FF FF FF 
2551   21D2 FF FF FF FF 
2551   21D6 FF FF FF FF 
2551   21DA FF FF FF FF 
2551   21DE FF FF FF FF 
2551   21E2 FF FF FF FF 
2551   21E6 FF FF FF FF 
2551   21EA FF FF FF FF 
2551   21EE FF FF FF FF 
2551   21F2 FF FF FF FF 
2551   21F6 FF FF FF FF 
2551   21FA FF FF FF FF 
2551   21FE FF FF FF FF 
2551   2202 FF FF FF FF 
2551   2206 FF FF FF FF 
2551   220A FF FF FF FF 
2551   220E FF FF FF FF 
2551   2212 FF FF FF FF 
2551   2216 FF FF FF FF 
2551   221A FF FF FF FF 
2551   221E FF FF FF FF 
2551   2222 FF FF FF FF 
2551   2226 FF FF FF FF 
2551   222A FF FF FF FF 
2551   222E FF FF FF FF 
2551   2232 FF FF FF FF 
2551   2236 FF FF FF FF 
2551   223A FF FF FF FF 
2551   223E FF FF FF FF 
2551   2242 FF FF FF FF 
2551   2246 FF FF FF FF 
2551   224A FF FF FF FF 
2551   224E FF FF FF FF 
2551   2252 FF FF FF FF 
2551   2256 FF FF FF FF 
2551   225A FF FF FF FF 
2551   225E FF FF FF FF 
2551   2262 FF FF FF FF 
2551   2266 FF FF FF FF 
2551   226A FF FF FF FF 
2551   226E FF FF FF FF 
2551   2272 FF FF FF FF 
2551   2276 FF FF FF FF 
2551   227A FF FF FF FF 
2551   227E FF FF FF FF 
2551   2282 FF FF FF FF 
2551   2286 FF FF FF FF 
2551   228A FF FF FF FF 
2551   228E FF FF FF FF 
2551   2292 FF FF FF FF 
2551   2296 FF FF FF FF 
2551   229A FF FF FF FF 
2551   229E FF FF FF FF 
2551   22A2 FF FF FF FF 
2551   22A6 FF FF FF FF 
2551   22AA FF FF FF FF 
2551   22AE FF FF FF FF 
2551   22B2 FF FF FF FF 
2551   22B6 FF FF FF FF 
2551   22BA FF FF FF FF 
2551   22BE FF FF FF FF 
2551   22C2 FF FF FF FF 
2551   22C6 FF FF FF FF 
2551   22CA FF FF FF FF 
2551   22CE FF FF FF FF 
2551   22D2 FF FF FF FF 
2551   22D6 FF FF FF FF 
2551   22DA FF FF FF FF 
2551   22DE FF FF FF FF 
2551   22E2 FF FF FF FF 
2551   22E6 FF FF FF FF 
2551   22EA FF FF FF FF 
2551   22EE FF FF FF FF 
2551   22F2 FF FF FF FF 
2551   22F6 FF FF FF FF 
2551   22FA FF FF FF FF 
2551   22FE FF FF FF FF 
2551   2302 FF FF FF FF 
2551   2306 FF FF FF FF 
2551   230A FF FF FF FF 
2551   230E FF FF FF FF 
2551   2312 FF FF FF FF 
2551   2316 FF FF FF FF 
2551   231A FF FF FF FF 
2551   231E FF FF FF FF 
2551   2322 FF FF FF FF 
2551   2326 FF FF FF FF 
2551   232A FF FF FF FF 
2551   232E FF FF FF FF 
2551   2332 FF FF FF FF 
2551   2336 FF FF FF FF 
2551   233A FF FF FF FF 
2551   233E FF FF FF FF 
2551   2342 FF FF FF FF 
2551   2346 FF FF FF FF 
2551   234A FF FF FF FF 
2551   234E FF FF FF FF 
2551   2352 FF FF FF FF 
2551   2356 FF FF FF FF 
2551   235A FF FF FF FF 
2551   235E FF FF FF FF 
2551   2362 FF FF FF FF 
2551   2366 FF FF FF FF 
2551   236A FF FF FF FF 
2551   236E FF FF FF FF 
2551   2372 FF FF FF FF 
2551   2376 FF FF FF FF 
2551   237A FF FF FF FF 
2551   237E FF FF FF FF 
2551   2382 FF FF FF FF 
2551   2386 FF FF FF FF 
2551   238A FF FF FF FF 
2551   238E FF FF FF FF 
2551   2392 FF FF FF FF 
2551   2396 FF FF FF FF 
2551   239A FF FF FF FF 
2551   239E FF FF FF FF 
2551   23A2 FF FF FF FF 
2551   23A6 FF FF FF FF 
2551   23AA FF FF FF FF 
2551   23AE FF FF FF FF 
2551   23B2 FF FF FF FF 
2551   23B6 FF FF FF FF 
2551   23BA FF FF FF FF 
2551   23BE FF FF FF FF 
2551   23C2 FF FF FF FF 
2551   23C6 FF FF FF FF 
2551   23CA FF FF FF FF 
2551   23CE FF FF FF FF 
2551   23D2 FF FF FF FF 
2551   23D6 FF FF FF FF 
2551   23DA FF FF FF FF 
2551   23DE FF FF FF FF 
2551   23E2 FF FF FF FF 
2551   23E6 FF FF FF FF 
2551   23EA FF FF FF FF 
2551   23EE FF FF FF FF 
2551   23F2 FF FF FF FF 
2551   23F6 FF FF FF FF 
2551   23FA FF FF FF FF 
2551   23FE FF FF FF FF 
2551   2402 FF FF FF FF 
2551   2406 FF FF FF FF 
2551   240A FF FF FF FF 
2551   240E FF FF FF FF 
2551   2412 FF FF FF FF 
2551   2416 FF FF FF FF 
2551   241A FF FF FF FF 
2551   241E FF FF FF FF 
2551   2422 FF FF FF FF 
2551   2426 FF FF FF FF 
2551   242A FF FF FF FF 
2551   242E FF FF FF FF 
2551   2432 FF FF FF FF 
2551   2436 FF FF FF FF 
2551   243A FF FF FF FF 
2551   243E FF FF FF FF 
2551   2442 FF FF FF FF 
2551   2446 FF FF FF FF 
2551   244A FF FF FF FF 
2551   244E FF FF FF FF 
2551   2452 FF FF FF FF 
2551   2456 FF FF FF FF 
2551   245A FF FF FF FF 
2551   245E FF FF FF FF 
2551   2462 FF FF FF FF 
2551   2466 FF FF FF FF 
2551   246A FF FF FF FF 
2551   246E FF FF FF FF 
2551   2472 FF FF FF FF 
2551   2476 FF FF FF FF 
2551   247A FF FF FF FF 
2551   247E FF FF FF FF 
2551   2482 FF FF FF FF 
2551   2486 FF FF FF FF 
2551   248A FF FF FF FF 
2551   248E FF FF FF FF 
2551   2492 FF FF FF FF 
2551   2496 FF FF FF FF 
2551   249A FF FF FF FF 
2551   249E FF FF FF FF 
2551   24A2 FF FF FF FF 
2551   24A6 FF FF FF FF 
2551   24AA FF FF FF FF 
2551   24AE FF FF FF FF 
2551   24B2 FF FF FF FF 
2551   24B6 FF FF FF FF 
2551   24BA FF FF FF FF 
2551   24BE FF FF FF FF 
2551   24C2 FF FF FF FF 
2551   24C6 FF FF FF FF 
2551   24CA FF FF FF FF 
2551   24CE FF FF FF FF 
2551   24D2 FF FF FF FF 
2551   24D6 FF FF FF FF 
2551   24DA FF FF FF FF 
2551   24DE FF FF FF FF 
2551   24E2 FF FF FF FF 
2551   24E6 FF FF FF FF 
2551   24EA FF FF FF FF 
2551   24EE FF FF FF FF 
2551   24F2 FF FF FF FF 
2551   24F6 FF FF FF FF 
2551   24FA FF FF FF FF 
2551   24FE FF FF FF FF 
2551   2502 FF FF FF FF 
2551   2506 FF FF FF FF 
2551   250A FF FF FF FF 
2551   250E FF FF FF FF 
2551   2512 FF FF FF FF 
2551   2516 FF FF FF FF 
2551   251A FF FF FF FF 
2551   251E FF FF FF FF 
2551   2522 FF FF FF FF 
2551   2526 FF FF FF FF 
2551   252A FF FF FF FF 
2551   252E FF FF FF FF 
2551   2532 FF FF FF FF 
2551   2536 FF FF FF FF 
2551   253A FF FF FF FF 
2551   253E FF FF FF FF 
2551   2542 FF FF FF FF 
2551   2546 FF FF FF FF 
2551   254A FF FF FF FF 
2551   254E FF FF FF FF 
2551   2552 FF FF FF FF 
2551   2556 FF FF FF FF 
2551   255A FF FF FF FF 
2551   255E FF FF FF FF 
2551   2562 FF FF FF FF 
2551   2566 FF FF FF FF 
2551   256A FF FF FF FF 
2551   256E FF FF FF FF 
2551   2572 FF FF FF FF 
2551   2576 FF FF FF FF 
2551   257A FF FF FF FF 
2551   257E FF FF FF FF 
2551   2582 FF FF FF FF 
2551   2586 FF FF FF FF 
2551   258A FF FF FF FF 
2551   258E FF FF FF FF 
2551   2592 FF FF FF FF 
2551   2596 FF FF FF FF 
2551   259A FF FF FF FF 
2551   259E FF FF FF FF 
2551   25A2 FF FF FF FF 
2551   25A6 FF FF FF FF 
2551   25AA FF FF FF FF 
2551   25AE FF FF FF FF 
2551   25B2 FF FF FF FF 
2551   25B6 FF FF FF FF 
2551   25BA FF FF FF FF 
2551   25BE FF FF FF FF 
2551   25C2 FF FF FF FF 
2551   25C6 FF FF FF FF 
2551   25CA FF FF FF FF 
2551   25CE FF FF FF FF 
2551   25D2 FF FF FF FF 
2551   25D6 FF FF FF FF 
2551   25DA FF FF FF FF 
2551   25DE FF FF FF FF 
2551   25E2 FF FF FF FF 
2551   25E6 FF FF FF FF 
2551   25EA FF FF FF FF 
2551   25EE FF FF FF FF 
2551   25F2 FF FF FF FF 
2551   25F6 FF FF FF FF 
2551   25FA FF FF FF FF 
2551   25FE FF FF FF FF 
2551   2602 FF FF FF FF 
2551   2606 FF FF FF FF 
2551   260A FF FF FF FF 
2551   260E FF FF FF FF 
2551   2612 FF FF FF FF 
2551   2616 FF FF FF FF 
2551   261A FF FF FF FF 
2551   261E FF FF FF FF 
2551   2622 FF FF FF FF 
2551   2626 FF FF FF FF 
2551   262A FF FF FF FF 
2551   262E FF FF FF FF 
2551   2632 FF FF FF FF 
2551   2636 FF FF FF FF 
2551   263A FF FF FF FF 
2551   263E FF FF FF FF 
2551   2642 FF FF FF FF 
2551   2646 FF FF FF FF 
2551   264A FF FF FF FF 
2551   264E FF FF FF FF 
2551   2652 FF FF FF FF 
2551   2656 FF FF FF FF 
2551   265A FF FF FF FF 
2551   265E FF FF FF FF 
2551   2662 FF FF FF FF 
2551   2666 FF FF FF FF 
2551   266A FF FF FF FF 
2551   266E FF FF FF FF 
2551   2672 FF FF FF FF 
2551   2676 FF FF FF FF 
2551   267A FF FF FF FF 
2551   267E FF FF FF FF 
2551   2682 FF FF FF FF 
2551   2686 FF FF FF FF 
2551   268A FF FF FF FF 
2551   268E FF FF FF FF 
2551   2692 FF FF FF FF 
2551   2696 FF FF FF FF 
2551   269A FF FF FF FF 
2551   269E FF FF FF FF 
2551   26A2 FF FF FF FF 
2551   26A6 FF FF FF FF 
2551   26AA FF FF FF FF 
2551   26AE FF FF FF FF 
2551   26B2 FF FF FF FF 
2551   26B6 FF FF FF FF 
2551   26BA FF FF FF FF 
2551   26BE FF FF FF FF 
2551   26C2 FF FF FF FF 
2551   26C6 FF FF FF FF 
2551   26CA FF FF FF FF 
2551   26CE FF FF FF FF 
2551   26D2 FF FF FF FF 
2551   26D6 FF FF FF FF 
2552   26DA             
2553   26DA FF FF FF FF scrap_sector:		.fill 512		; scrap sector
2553   26DE FF FF FF FF 
2553   26E2 FF FF FF FF 
2553   26E6 FF FF FF FF 
2553   26EA FF FF FF FF 
2553   26EE FF FF FF FF 
2553   26F2 FF FF FF FF 
2553   26F6 FF FF FF FF 
2553   26FA FF FF FF FF 
2553   26FE FF FF FF FF 
2553   2702 FF FF FF FF 
2553   2706 FF FF FF FF 
2553   270A FF FF FF FF 
2553   270E FF FF FF FF 
2553   2712 FF FF FF FF 
2553   2716 FF FF FF FF 
2553   271A FF FF FF FF 
2553   271E FF FF FF FF 
2553   2722 FF FF FF FF 
2553   2726 FF FF FF FF 
2553   272A FF FF FF FF 
2553   272E FF FF FF FF 
2553   2732 FF FF FF FF 
2553   2736 FF FF FF FF 
2553   273A FF FF FF FF 
2553   273E FF FF FF FF 
2553   2742 FF FF FF FF 
2553   2746 FF FF FF FF 
2553   274A FF FF FF FF 
2553   274E FF FF FF FF 
2553   2752 FF FF FF FF 
2553   2756 FF FF FF FF 
2553   275A FF FF FF FF 
2553   275E FF FF FF FF 
2553   2762 FF FF FF FF 
2553   2766 FF FF FF FF 
2553   276A FF FF FF FF 
2553   276E FF FF FF FF 
2553   2772 FF FF FF FF 
2553   2776 FF FF FF FF 
2553   277A FF FF FF FF 
2553   277E FF FF FF FF 
2553   2782 FF FF FF FF 
2553   2786 FF FF FF FF 
2553   278A FF FF FF FF 
2553   278E FF FF FF FF 
2553   2792 FF FF FF FF 
2553   2796 FF FF FF FF 
2553   279A FF FF FF FF 
2553   279E FF FF FF FF 
2553   27A2 FF FF FF FF 
2553   27A6 FF FF FF FF 
2553   27AA FF FF FF FF 
2553   27AE FF FF FF FF 
2553   27B2 FF FF FF FF 
2553   27B6 FF FF FF FF 
2553   27BA FF FF FF FF 
2553   27BE FF FF FF FF 
2553   27C2 FF FF FF FF 
2553   27C6 FF FF FF FF 
2553   27CA FF FF FF FF 
2553   27CE FF FF FF FF 
2553   27D2 FF FF FF FF 
2553   27D6 FF FF FF FF 
2553   27DA FF FF FF FF 
2553   27DE FF FF FF FF 
2553   27E2 FF FF FF FF 
2553   27E6 FF FF FF FF 
2553   27EA FF FF FF FF 
2553   27EE FF FF FF FF 
2553   27F2 FF FF FF FF 
2553   27F6 FF FF FF FF 
2553   27FA FF FF FF FF 
2553   27FE FF FF FF FF 
2553   2802 FF FF FF FF 
2553   2806 FF FF FF FF 
2553   280A FF FF FF FF 
2553   280E FF FF FF FF 
2553   2812 FF FF FF FF 
2553   2816 FF FF FF FF 
2553   281A FF FF FF FF 
2553   281E FF FF FF FF 
2553   2822 FF FF FF FF 
2553   2826 FF FF FF FF 
2553   282A FF FF FF FF 
2553   282E FF FF FF FF 
2553   2832 FF FF FF FF 
2553   2836 FF FF FF FF 
2553   283A FF FF FF FF 
2553   283E FF FF FF FF 
2553   2842 FF FF FF FF 
2553   2846 FF FF FF FF 
2553   284A FF FF FF FF 
2553   284E FF FF FF FF 
2553   2852 FF FF FF FF 
2553   2856 FF FF FF FF 
2553   285A FF FF FF FF 
2553   285E FF FF FF FF 
2553   2862 FF FF FF FF 
2553   2866 FF FF FF FF 
2553   286A FF FF FF FF 
2553   286E FF FF FF FF 
2553   2872 FF FF FF FF 
2553   2876 FF FF FF FF 
2553   287A FF FF FF FF 
2553   287E FF FF FF FF 
2553   2882 FF FF FF FF 
2553   2886 FF FF FF FF 
2553   288A FF FF FF FF 
2553   288E FF FF FF FF 
2553   2892 FF FF FF FF 
2553   2896 FF FF FF FF 
2553   289A FF FF FF FF 
2553   289E FF FF FF FF 
2553   28A2 FF FF FF FF 
2553   28A6 FF FF FF FF 
2553   28AA FF FF FF FF 
2553   28AE FF FF FF FF 
2553   28B2 FF FF FF FF 
2553   28B6 FF FF FF FF 
2553   28BA FF FF FF FF 
2553   28BE FF FF FF FF 
2553   28C2 FF FF FF FF 
2553   28C6 FF FF FF FF 
2553   28CA FF FF FF FF 
2553   28CE FF FF FF FF 
2553   28D2 FF FF FF FF 
2553   28D6 FF FF FF FF 
2554   28DA 00          transient_area:		.db 0			; beginning of the transient memory area. used for disk reads and other purposes		
2555   28DB             
2556   28DB             
2557   28DB             .end
tasm: Number of errors = 0
