0001   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002   0000             ; KERNEL
0003   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0005   0000             ; MEMORY MAP
0006   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007   0000             ; 0000		ROM BEGIN
0008   0000             ; ....
0009   0000             ; 7FFF		ROM END
0010   0000             ;
0011   0000             ; 8000		RAM begin
0012   0000             ; ....
0013   0000             ; F7FF		Stack root
0014   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0015   0000             ; I/O MAP
0016   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0017   0000             ; FF80		UART 0		(16550)
0018   0000             ; FF90		UART 1		(16550)
0019   0000             ; FFA0		RTC		(M48T02)
0020   0000             ; FFB0		PIO 0		(8255)
0021   0000             ; FFC0		PIO 1		(8255)
0022   0000             ; FFD0		IDE		(Compact Flash / PATA)
0023   0000             ; FFE0		Timer		(8253)
0024   0000             ; FFF0		BIOS CONFIGURATION NV-RAM STORE AREA
0025   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026   0000             ; SYSTEM CONSTANTS / EQUATIONS
0027   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028   0000             _UART0_DATA			.equ $FF80				; data
0029   0000             _UART0_DLAB_0		.equ $FF80				; divisor latch low byte
0030   0000             _UART0_DLAB_1		.equ $FF81				; divisor latch high byte
0031   0000             _UART0_IER			.equ $FF81				; Interrupt enable register
0032   0000             _UART0_FCR			.equ $FF82				; FIFO control register
0033   0000             _UART0_LCR			.equ $FF83				; line control register
0034   0000             _UART0_LSR			.equ $FF85				; line status register
0035   0000             
0036   0000             _IDE_BASE			.equ $FFD0				; IDE BASE
0037   0000             _IDE_R0				.equ _IDE_BASE + 0		; DATA PORT
0038   0000             _IDE_R1				.equ _IDE_BASE + 1		; READ: ERROR CODE, WRITE: FEATURE
0039   0000             _IDE_R2				.equ _IDE_BASE + 2		; NUMBER OF SECTORS TO TRANSFER
0040   0000             _IDE_R3				.equ _IDE_BASE + 3		; SECTOR ADDRESS LBA 0 [0:7]
0041   0000             _IDE_R4				.equ _IDE_BASE + 4		; SECTOR ADDRESS LBA 1 [8:15]
0042   0000             _IDE_R5				.equ _IDE_BASE + 5		; SECTOR ADDRESS LBA 2 [16:23]
0043   0000             _IDE_R6				.equ _IDE_BASE + 6		; SECTOR ADDRESS LBA 3 [24:27 (LSB)]
0044   0000             _IDE_R7				.equ _IDE_BASE + 7		; READ: STATUS, WRITE: COMMAND
0045   0000             
0046   0000             _7SEG_DISPLAY		.equ $FFB0				; BIOS POST CODE HEX DISPLAY (2 DIGITS)
0047   0000             _BIOS_POST_CTRL		.equ $FFB3				; BIOS POST DISPLAY CONTROL REGISTER, 80h = As Output
0048   0000             _PIO_A				.equ $FFB0		
0049   0000             _PIO_B				.equ $FFB1
0050   0000             _PIO_C				.equ $FFB2
0051   0000             _PIO_CONTROL		.equ $FFB3				; PIO CONTROL PORT
0052   0000             
0053   0000             _TIMER_C_0			.equ $FFE0				; TIMER COUNTER 0
0054   0000             _TIMER_C_1			.equ $FFE1				; TIMER COUNTER 1
0055   0000             _TIMER_C_2			.equ $FFE2				; TIMER COUNTER 2
0056   0000             _TIMER_CTRL			.equ $FFE3				; TIMER CONTROL REGISTER
0057   0000             
0058   0000             STACK_BEGIN			.equ $F7FF				; beginning of stack
0059   0000             FIFO_SIZE			.equ (1024*2)
0060   0000             
0061   0000             PROC_TEXT_ORG		.equ $400
0062   0000             NULL				.equ 0
0063   0000             
0064   0000             
0065   0000             ; for the next iteration:
0066   0000             ; boot-sector(1) | kernel-sectors(32) | inode-bitmap | rawdata-bitmap | inode-table | raw-disk-data
0067   0000             ;
0068   0000             ; inode-table format:
0069   0000             ;	file-type(f, d)
0070   0000             ;	permissons
0071   0000             ;	link-count
0072   0000             ;	filesize
0073   0000             ;	time-stamps
0074   0000             ;	15 data block pointers
0075   0000             ;	single-indirect pointer
0076   0000             ;
0077   0000             
0078   0000             ; for now:
0079   0000             ; boot-sector(1) | kernel-sectors(32) | rawdata-bitmap() | raw-disk-data
0080   0000             ;
0081   0000             ; filename (24)
0082   0000             ; attributes (1) 			:|0|0|file_type(3bits)|x|w|r|
0083   0000             ; LBA (2)					: location of raw data for file entry, or dirID for directory entry
0084   0000             ; size (2)					: filesize
0085   0000             ; day (1)					 
0086   0000             ; month (1)
0087   0000             ; year (1)
0088   0000             ; packet size = 32 bytes	: total packet size in bytes
0089   0000             ;
0090   0000             FST_ENTRY_SIZE			.equ 32
0091   0000             FST_FILES_PER_SECT		.equ (512 / FST_ENTRY_SIZE)
0092   0000             FST_FILES_PER_DIR		.equ 16
0093   0000             FST_NBR_DIRECTORIES		.equ 64
0094   0000             						; 1 sector for header, the rest is for the list of files/dirs
0095   0000             FST_SECTORS_PER_DIR		.equ (1 + (FST_ENTRY_SIZE * FST_FILES_PER_DIR / 512))		
0096   0000             FST_TOTAL_SECTORS		.equ (FST_SECTORS_PER_DIR * FST_NBR_DIRECTORIES)
0097   0000             FST_LBA_START			.equ 32
0098   0000             FST_LBA_END				.equ (FST_LBA_START + FST_TOTAL_SECTORS - 1)
0099   0000             
0100   0000             FS_NBR_FILES 			.equ (FST_NBR_DIRECTORIES * FST_FILES_PER_DIR)
0101   0000             FS_SECTORS_PER_FILE		.equ 32				; the first sector is always a header with a NULL parameter (first byte)
0102   0000             											; so that we know which blocks are free or taken
0103   0000             FS_FILE_SIZE			.equ (FS_SECTORS_PER_FILE * 512)									
0104   0000             FS_TOTAL_SECTORS		.equ (FS_NBR_FILES * FS_SECTORS_PER_FILE)
0105   0000             FS_LBA_START			.equ (FST_LBA_END + 1)
0106   0000             FS_LBA_END				.equ (FS_LBA_START + FS_NBR_FILES - 1)
0107   0000             
0108   0000             CF_CARD_LBA_SIZE		.equ $800			; temporary small size
0109   0000             
0110   0000             ROOT_dirID:				.equ FST_LBA_START
0111   0000             
0112   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113   0000             ; GLOBAL SYSTEM VARIABLES
0114   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115   0000             
0116   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0117   0000             ; EXTERNAL INTERRUPT TABLE
0118   0000             ; highest priority at lowest address
0119   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0120   0000 83 07       .dw int_0
0121   0002 84 07       .dw int_1
0122   0004 85 07       .dw int_2
0123   0006 86 07       .dw int_3
0124   0008 87 07       .dw int_4
0125   000A 88 07       .dw int_5
0126   000C 89 07       .dw int_6
0127   000E D5 07       .dw int_7
0128   0010             
0129   0010             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130   0010             ; RESET VECTOR DECLARATION
0131   0010             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0132   0010 8D 14       .dw KERNEL_RESET_VECTOR
0133   0012             
0134   0012             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0135   0012             ;; EXCEPTION VECTOR TABLE
0136   0012             ;; total of 7 entries, starting at address $0012
0137   0012             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138   0012 9F 08       .dw trap_privilege
0139   0014 BC 09       .dw trap_div_zero
0140   0016 C9 09       .dw undefined_opcode
0141   0018 00 00       .dw NULL
0142   001A 00 00       .dw NULL
0143   001C 00 00       .dw NULL
0144   001E 00 00       .dw NULL
0145   0020             
0146   0020             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0147   0020             ;; SYSTEM CALL VECTOR TABLE
0148   0020             ;; starts at address $0020
0149   0020             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0150   0020 AB 08       .dw trap_breakpoint
0151   0022 CA 09       .dw rtc_services						
0152   0024 ED 0A       .dw IDE_services_kernel
0153   0026 AD 0B       .dw io_services
0154   0028 39 0C       .dw file_system
0155   002A 64 15       .dw cmd_fork
0156   002C 64 08       .dw list_procs
0157   002E FC 09       .dw datetime_services
0158   0030 20 08       .dw syscall_reboot
0159   0032 2E 15       .dw cmd_pause_proc
0160   0034 2C 08       .dw resume_proc
0161   0036 EB 14       .dw cmd_terminate_proc
0162   0038 0E 08       .dw cmd_system
0163   003A C6 0C       .dw cmd_boot_installer
0164   003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0165   003C             ;; FILE INCLUDES
0166   003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0167   003C             .include "bios.exp"	; to obtain the BIOS_RESET_VECTOR location (for reboots)
0001+  003C             BIOS_RESET_VECTOR .EQU  $01c0
0002+  003C             IDE_buffer       .EQU  $8204
0003+  003C             boot_origin      .EQU  $8004
0004+  003C             bios_uart        .EQU  $0002
0005+  003C             bios_ide         .EQU  $0003
0168   003C             .include "stdio.asm"
0001+  003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  003C             ; stdio.s
0003+  003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  003C             .include "string.asm"
0001++ 003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 003C             ; string.s
0003++ 003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 003C             
0005++ 003C             
0006++ 003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 003C             ; strrev
0008++ 003C             ; reverse a string
0009++ 003C             ; D = string address
0010++ 003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 003C             ; 01234
0012++ 003C             strrev:
0013++ 003C 4B          	pusha
0014++ 003D 07 83 00    	call strlen	; length in C
0015++ 0040 12          	mov a, c
0016++ 0041 AF 01 00    	cmp a, 1
0017++ 0044 D0 5E 00    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0047 7D          	dec a
0019++ 0048 FD 4E       	mov si, d	; beginning of string
0020++ 004A FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 004C 59          	add d, a	; end of string
0022++ 004D 12          	mov a, c
0023++ 004E FD 9B       	shr a		; divide by 2
0024++ 0050 39          	mov c, a	; C now counts the steps
0025++ 0051             strrev_L0:
0026++ 0051 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0052 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0053 3E          	mov [d], al	; store left char into right side
0029++ 0054 1B          	mov al, bl
0030++ 0055 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0056 7E          	dec c
0032++ 0057 7F          	dec d
0033++ 0058 C2 00 00    	cmp c, 0
0034++ 005B C7 51 00    	jne strrev_L0
0035++ 005E             strrev_end:
0036++ 005E 4C          	popa
0037++ 005F 09          	ret
0038++ 0060             	
0039++ 0060             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0060             ; strchr
0041++ 0060             ; search string in D for char in AL
0042++ 0060             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0060             strchr:
0044++ 0060             strchr_L0:
0045++ 0060 32          	mov bl, [d]
0046++ 0061 C1 00       	cmp bl, 0
0047++ 0063 C6 6E 00    	je strchr_end
0048++ 0066 BA          	cmp al, bl
0049++ 0067 C6 6E 00    	je strchr_end
0050++ 006A 79          	inc d
0051++ 006B 0A 60 00    	jmp strchr_L0
0052++ 006E             strchr_end:
0053++ 006E 1B          	mov al, bl
0054++ 006F 09          	ret
0055++ 0070             
0056++ 0070             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0070             ; strstr
0058++ 0070             ; find sub-string
0059++ 0070             ; str1 in SI
0060++ 0070             ; str2 in DI
0061++ 0070             ; SI points to end of source string
0062++ 0070             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0070             strstr:
0064++ 0070 DB          	push al
0065++ 0071 DA          	push d
0066++ 0072 E3          	push di
0067++ 0073             strstr_loop:
0068++ 0073 F3          	cmpsb					; compare a byte of the strings
0069++ 0074 C7 7F 00    	jne strstr_ret
0070++ 0077 FC 00 00    	lea d, [di + 0]
0071++ 007A BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 007C C7 73 00    	jne strstr_loop				; equal chars but not at end
0073++ 007F             strstr_ret:
0074++ 007F F0          	pop di
0075++ 0080 E7          	pop d
0076++ 0081 E8          	pop al
0077++ 0082 09          	ret
0078++ 0083             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0083             ; length of null terminated string
0080++ 0083             ; result in C
0081++ 0083             ; pointer in D
0082++ 0083             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0083             strlen:
0084++ 0083 DA          	push d
0085++ 0084 38 00 00    	mov c, 0
0086++ 0087             strlen_L1:
0087++ 0087 BD 00       	cmp byte [d], 0
0088++ 0089 C6 91 00    	je strlen_ret
0089++ 008C 79          	inc d
0090++ 008D 78          	inc c
0091++ 008E 0A 87 00    	jmp strlen_L1
0092++ 0091             strlen_ret:
0093++ 0091 E7          	pop d
0094++ 0092 09          	ret
0095++ 0093             
0096++ 0093             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0093             ; STRCMP
0098++ 0093             ; compare two strings
0099++ 0093             ; str1 in SI
0100++ 0093             ; str2 in DI
0101++ 0093             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0093             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0093             strcmp:
0104++ 0093 DB          	push al
0105++ 0094 DA          	push d
0106++ 0095 E3          	push di
0107++ 0096 E2          	push si
0108++ 0097             strcmp_loop:
0109++ 0097 F3          	cmpsb					; compare a byte of the strings
0110++ 0098 C7 A3 00    	jne strcmp_ret
0111++ 009B FB FF FF    	lea d, [si +- 1]
0112++ 009E BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 00A0 C7 97 00    	jne strcmp_loop				; equal chars but not at end
0114++ 00A3             strcmp_ret:
0115++ 00A3 EF          	pop si
0116++ 00A4 F0          	pop di
0117++ 00A5 E7          	pop d
0118++ 00A6 E8          	pop al
0119++ 00A7 09          	ret
0120++ 00A8             
0121++ 00A8             
0122++ 00A8             ; STRCPY
0123++ 00A8             ; copy null terminated string from SI to DI
0124++ 00A8             ; source in SI
0125++ 00A8             ; destination in DI
0126++ 00A8             strcpy:
0127++ 00A8 E2          	push si
0128++ 00A9 E3          	push di
0129++ 00AA DB          	push al
0130++ 00AB             strcpy_L1:
0131++ 00AB F6          	lodsb
0132++ 00AC F7          	stosb
0133++ 00AD B9 00       	cmp al, 0
0134++ 00AF C7 AB 00    	jne strcpy_L1
0135++ 00B2             strcpy_end:
0136++ 00B2 E8          	pop al
0137++ 00B3 F0          	pop di
0138++ 00B4 EF          	pop si
0139++ 00B5 09          	ret
0140++ 00B6             
0141++ 00B6             ; STRCAT
0142++ 00B6             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 00B6             ; source in SI
0144++ 00B6             ; destination in DI
0145++ 00B6             strcat:
0146++ 00B6 E2          	push si
0147++ 00B7 E3          	push di
0148++ 00B8 D7          	push a
0149++ 00B9 DA          	push d
0150++ 00BA 50          	mov a, di
0151++ 00BB 3C          	mov d, a
0152++ 00BC             strcat_goto_end_L1:
0153++ 00BC BD 00       	cmp byte[d], 0
0154++ 00BE C6 C5 00    	je strcat_start
0155++ 00C1 79          	inc d
0156++ 00C2 0A BC 00    	jmp strcat_goto_end_L1
0157++ 00C5             strcat_start:
0158++ 00C5 FD 50       	mov di, d
0159++ 00C7             strcat_L1:
0160++ 00C7 F6          	lodsb
0161++ 00C8 F7          	stosb
0162++ 00C9 B9 00       	cmp al, 0
0163++ 00CB C7 C7 00    	jne strcat_L1
0164++ 00CE             strcat_end:
0165++ 00CE E7          	pop d
0166++ 00CF E4          	pop a
0167++ 00D0 F0          	pop di
0168++ 00D1 EF          	pop si
0169++ 00D2 09          	ret
0005+  00D3             
0006+  00D3 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  00D7 34 35 36 37 
0006+  00DB 38 39 41 42 
0006+  00DF 43 44 45 46 
0007+  00E3             
0008+  00E3 01 00       table_power:.dw 1
0009+  00E5 0A 00       			.dw 10
0010+  00E7 64 00       			.dw 100
0011+  00E9 E8 03       			.dw 1000
0012+  00EB 10 27       			.dw 10000
0013+  00ED             
0014+  00ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0015+  00ED             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0016+  00ED             ; ASCII in BL
0017+  00ED             ; result in AL
0018+  00ED             ; ascii for F = 0100 0110
0019+  00ED             ; ascii for 9 = 0011 1001
0020+  00ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0021+  00ED             hex_ascii_encode:
0022+  00ED 1B          	mov al, bl
0023+  00EE 93 40       	test al, $40				; test if letter or number
0024+  00F0 C7 F6 00    	jnz hex_letter
0025+  00F3 87 0F       	and al, $0F				; get number
0026+  00F5 09          	ret
0027+  00F6             hex_letter:
0028+  00F6 87 0F       	and al, $0F				; get letter
0029+  00F8 6A 09       	add al, 9
0030+  00FA 09          	ret
0031+  00FB             
0032+  00FB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0033+  00FB             ; ATOI
0034+  00FB             ; 2 letter hex string in B
0035+  00FB             ; 8bit integer returned in AL
0036+  00FB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0037+  00FB             atoi:
0038+  00FB D8          	push b
0039+  00FC 07 ED 00    	call hex_ascii_encode			; convert BL to 4bit code in AL
0040+  00FF 30          	mov bl, bh
0041+  0100 DB          	push al					; save a
0042+  0101 07 ED 00    	call hex_ascii_encode
0043+  0104 EA          	pop bl	
0044+  0105 FD 9E 04    	shl al, 4
0045+  0108 8C          	or al, bl
0046+  0109 E5          	pop b
0047+  010A 09          	ret	
0048+  010B             
0049+  010B             
0050+  010B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  010B             ; printf
0052+  010B             ; no need for explanations!
0053+  010B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0054+  010B             printf:
0055+  010B 09          	ret
0056+  010C             
0057+  010C             
0058+  010C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  010C             ; scanf
0060+  010C             ; no need for explanations!
0061+  010C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  010C             scanf:
0063+  010C 09          	ret
0064+  010D             
0065+  010D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  010D             ; ITOA
0067+  010D             ; 8bit value in BL
0068+  010D             ; 2 byte ASCII result in A
0069+  010D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0070+  010D             itoa:
0071+  010D DA          	push d
0072+  010E D8          	push b
0073+  010F A7 00       	mov bh, 0
0074+  0111 FD A4 04    	shr bl, 4	
0075+  0114 74          	mov d, b
0076+  0115 1F D3 00    	mov al, [d + s_hex_digits]
0077+  0118 23          	mov ah, al
0078+  0119             	
0079+  0119 E5          	pop b
0080+  011A D8          	push b
0081+  011B A7 00       	mov bh, 0
0082+  011D FD 87 0F    	and bl, $0F
0083+  0120 74          	mov d, b
0084+  0121 1F D3 00    	mov al, [d + s_hex_digits]
0085+  0124 E5          	pop b
0086+  0125 E7          	pop d
0087+  0126 09          	ret
0088+  0127             
0089+  0127             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0090+  0127             ; HEX STRING TO BINARY
0091+  0127             ; di = destination address
0092+  0127             ; si = source
0093+  0127             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0094+  0127             hex_to_int:
0095+  0127             hex_to_int_L1:
0096+  0127 F6          	lodsb					; load from [SI] to AL
0097+  0128 B9 00       	cmp al, 0				; check if ASCII 0
0098+  012A C6 37 01    	jz hex_to_int_ret
0099+  012D 36          	mov bh, al
0100+  012E F6          	lodsb
0101+  012F 2F          	mov bl, al
0102+  0130 07 FB 00    	call atoi				; convert ASCII byte in B to int (to AL)
0103+  0133 F7          	stosb					; store AL to [DI]
0104+  0134 0A 27 01    	jmp hex_to_int_L1
0105+  0137             hex_to_int_ret:
0106+  0137 09          	ret		
0107+  0138             
0108+  0138             
0109+  0138             
0110+  0138             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  0138             ; GETCHAR
0112+  0138             ; char in ah
0113+  0138             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0114+  0138             getchar:
0115+  0138 DB          	push al
0116+  0139             getchar_retry:
0117+  0139 FD 0C       	sti
0118+  013B 19 01       	mov al, 1
0119+  013D 05 03       	syscall sys_io			; receive in AH
0120+  013F B9 00       	cmp al, 0			; check if any char was receive
0121+  0141 C6 39 01    	je getchar_retry
0122+  0144 E8          	pop al
0123+  0145 09          	ret
0124+  0146             
0125+  0146             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0126+  0146             ; PUTCHAR
0127+  0146             ; char in ah
0128+  0146             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  0146             putchar:
0130+  0146 D7          	push a
0131+  0147 19 00       	mov al, 0
0132+  0149 05 03       	syscall sys_io			; char in AH
0133+  014B E4          	pop a
0134+  014C 09          	ret
0135+  014D             
0136+  014D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0137+  014D             ;; INPUT A STRING
0138+  014D             ;; terminates with null
0139+  014D             ;; pointer in D
0140+  014D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  014D             gets:
0142+  014D D7          	push a
0143+  014E DA          	push d
0144+  014F             gets_loop:
0145+  014F FD 0C       	sti
0146+  0151 19 01       	mov al, 1
0147+  0153 05 03       	syscall sys_io			; receive in AH
0148+  0155 B9 00       	cmp al, 0				; check error code (AL)
0149+  0157 C6 4F 01    	je gets_loop			; if no char received, retry
0150+  015A             
0151+  015A 76 1B       	cmp ah, 27
0152+  015C C6 7D 01    	je gets_telnet_escape
0153+  015F 76 0A       	cmp ah, $0A				; LF
0154+  0161 C6 D6 01    	je gets_end
0155+  0164 76 0D       	cmp ah, $0D				; CR
0156+  0166 C6 D6 01    	je gets_end
0157+  0169 76 5C       	cmp ah, $5C				; '\\'
0158+  016B C6 AD 01    	je gets_escape
0159+  016E             	
0160+  016E 76 08       	cmp ah, $08			; check for backspace
0161+  0170 C6 79 01    	je gets_backspace
0162+  0173             
0163+  0173 1A          	mov al, ah
0164+  0174 3E          	mov [d], al
0165+  0175 79          	inc d
0166+  0176 0A 4F 01    	jmp gets_loop
0167+  0179             gets_backspace:
0168+  0179 7F          	dec d
0169+  017A 0A 4F 01    	jmp gets_loop
0170+  017D             gets_telnet_escape:
0171+  017D FD 0C       	sti
0172+  017F 19 01       	mov al, 1
0173+  0181 05 03       	syscall sys_io				; receive in AH without echo
0174+  0183 B9 00       	cmp al, 0					; check error code (AL)
0175+  0185 C6 7D 01    	je gets_telnet_escape		; if no char received, retry
0176+  0188 76 5B       	cmp ah, '['
0177+  018A C7 4F 01    	jne gets_loop
0178+  018D             gets_telnet_escape_phase2:
0179+  018D FD 0C       	sti
0180+  018F 19 01       	mov al, 1
0181+  0191 05 03       	syscall sys_io					; receive in AH without echo
0182+  0193 B9 00       	cmp al, 0						; check error code (AL)
0183+  0195 C6 8D 01    	je gets_telnet_escape_phase2	; if no char received, retry
0184+  0198 76 44       	cmp ah, 'D'
0185+  019A C6 A5 01    	je gets_left_arrow
0186+  019D 76 43       	cmp ah, 'C'
0187+  019F C6 A9 01    	je gets_right_arrow
0188+  01A2 0A 4F 01    	jmp gets_loop
0189+  01A5             gets_left_arrow:
0190+  01A5 7F          	dec d
0191+  01A6 0A 4F 01    	jmp gets_loop
0192+  01A9             gets_right_arrow:
0193+  01A9 79          	inc d
0194+  01AA 0A 4F 01    	jmp gets_loop
0195+  01AD             gets_escape:
0196+  01AD FD 0C       	sti
0197+  01AF 19 01       	mov al, 1
0198+  01B1 05 03       	syscall sys_io			; receive in AH
0199+  01B3 B9 00       	cmp al, 0				; check error code (AL)
0200+  01B5 C6 AD 01    	je gets_escape			; if no char received, retry
0201+  01B8 76 6E       	cmp ah, 'n'
0202+  01BA C6 C8 01    	je gets_LF
0203+  01BD 76 72       	cmp ah, 'r'
0204+  01BF C6 CF 01    	je gets_CR
0205+  01C2 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0206+  01C3 3E          	mov [d], al
0207+  01C4 79          	inc d
0208+  01C5 0A 4F 01    	jmp gets_loop
0209+  01C8             gets_LF:
0210+  01C8 19 0A       	mov al, $0A
0211+  01CA 3E          	mov [d], al
0212+  01CB 79          	inc d
0213+  01CC 0A 4F 01    	jmp gets_loop
0214+  01CF             gets_CR:
0215+  01CF 19 0D       	mov al, $0D
0216+  01D1 3E          	mov [d], al
0217+  01D2 79          	inc d
0218+  01D3 0A 4F 01    	jmp gets_loop
0219+  01D6             gets_end:
0220+  01D6 19 00       	mov al, 0
0221+  01D8 3E          	mov [d], al				; terminate string
0222+  01D9 E7          	pop d
0223+  01DA E4          	pop a
0224+  01DB 09          	ret
0225+  01DC             
0226+  01DC             
0227+  01DC             
0228+  01DC             
0229+  01DC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0230+  01DC             ;; INPUT TEXT
0231+  01DC             ;; terminated with CTRL+D
0232+  01DC             ;; pointer in D
0233+  01DC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0234+  01DC             gettxt:
0235+  01DC D7          	push a
0236+  01DD DA          	push d
0237+  01DE             gettxt_loop:
0238+  01DE 19 01       	mov al, 1
0239+  01E0 05 03       	syscall sys_io			; receive in AH
0240+  01E2 B9 00       	cmp al, 0				; check error code (AL)
0241+  01E4 C6 DE 01    	je gettxt_loop		; if no char received, retry
0242+  01E7 76 04       	cmp ah, 4			; EOT
0243+  01E9 C6 27 02    	je gettxt_end
0244+  01EC 76 08       	cmp ah, $08			; check for backspace
0245+  01EE C6 23 02    	je gettxt_backspace
0246+  01F1 76 5C       	cmp ah, $5C				; '\\'
0247+  01F3 C6 FC 01    	je gettxt_escape
0248+  01F6 1A          	mov al, ah
0249+  01F7 3E          	mov [d], al
0250+  01F8 79          	inc d
0251+  01F9 0A DE 01    	jmp gettxt_loop
0252+  01FC             gettxt_escape:
0253+  01FC 19 01       	mov al, 1
0254+  01FE 05 03       	syscall sys_io			; receive in AH
0255+  0200 B9 00       	cmp al, 0				; check error code (AL)
0256+  0202 C6 FC 01    	je gettxt_escape		; if no char received, retry
0257+  0205 76 6E       	cmp ah, 'n'
0258+  0207 C6 15 02    	je gettxt_LF
0259+  020A 76 72       	cmp ah, 'r'
0260+  020C C6 1C 02    	je gettxt_CR
0261+  020F 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0262+  0210 3E          	mov [d], al
0263+  0211 79          	inc d
0264+  0212 0A DE 01    	jmp gettxt_loop
0265+  0215             gettxt_LF:
0266+  0215 19 0A       	mov al, $0A
0267+  0217 3E          	mov [d], al
0268+  0218 79          	inc d
0269+  0219 0A DE 01    	jmp gettxt_loop
0270+  021C             gettxt_CR:
0271+  021C 19 0D       	mov al, $0D
0272+  021E 3E          	mov [d], al
0273+  021F 79          	inc d
0274+  0220 0A DE 01    	jmp gettxt_loop
0275+  0223             gettxt_backspace:
0276+  0223 7F          	dec d
0277+  0224 0A DE 01    	jmp gettxt_loop
0278+  0227             gettxt_end:
0279+  0227 19 00       	mov al, 0
0280+  0229 3E          	mov [d], al				; terminate string
0281+  022A E7          	pop d
0282+  022B E4          	pop a
0283+  022C 09          	ret
0284+  022D             
0285+  022D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0286+  022D             ; PRINT NEW LINE
0287+  022D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  022D             printnl:
0289+  022D D7          	push a
0290+  022E 10 00 0A    	mov a, $0A00
0291+  0231 05 03       	syscall sys_io
0292+  0233 10 00 0D    	mov a, $0D00
0293+  0236 05 03       	syscall sys_io
0294+  0238 E4          	pop a
0295+  0239 09          	ret
0296+  023A             
0297+  023A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0298+  023A             ; strtoint
0299+  023A             ; 4 digit hex string number in d
0300+  023A             ; integer returned in A
0301+  023A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0302+  023A             strtointx:
0303+  023A D8          	push b
0304+  023B 32          	mov bl, [d]
0305+  023C 37          	mov bh, bl
0306+  023D 33 01 00    	mov bl, [d + 1]
0307+  0240 07 FB 00    	call atoi				; convert to int in AL
0308+  0243 23          	mov ah, al				; move to AH
0309+  0244 33 02 00    	mov bl, [d + 2]
0310+  0247 37          	mov bh, bl
0311+  0248 33 03 00    	mov bl, [d + 3]
0312+  024B 07 FB 00    	call atoi				; convert to int in AL
0313+  024E E5          	pop b
0314+  024F 09          	ret
0315+  0250             
0316+  0250             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0317+  0250             ; strtoint
0318+  0250             ; 5 digit base10 string number in d
0319+  0250             ; integer returned in A
0320+  0250             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0321+  0250             strtoint:
0322+  0250 E2          	push si
0323+  0251 D8          	push b
0324+  0252 D9          	push c
0325+  0253 DA          	push d
0326+  0254 07 83 00    	call strlen			; get string length in C
0327+  0257 7E          	dec c
0328+  0258 FD 4E       	mov si, d
0329+  025A 12          	mov a, c
0330+  025B FD 99       	shl a
0331+  025D 3B E3 00    	mov d, table_power
0332+  0260 59          	add d, a
0333+  0261 38 00 00    	mov c, 0
0334+  0264             strtoint_L0:
0335+  0264 F6          	lodsb			; load ASCII to al
0336+  0265 B9 00       	cmp al, 0
0337+  0267 C6 7A 02    	je strtoint_end
0338+  026A 6F 30       	sub al, $30		; make into integer
0339+  026C 22 00       	mov ah, 0
0340+  026E 2A          	mov b, [d]
0341+  026F AC          	mul a, b			; result in B since it fits in 16bits
0342+  0270 11          	mov a, b
0343+  0271 28          	mov b, c
0344+  0272 54          	add a, b
0345+  0273 39          	mov c, a
0346+  0274 63 02 00    	sub d, 2
0347+  0277 0A 64 02    	jmp strtoint_L0
0348+  027A             strtoint_end:
0349+  027A 12          	mov a, c
0350+  027B E7          	pop d
0351+  027C E6          	pop c
0352+  027D E5          	pop b
0353+  027E EF          	pop si
0354+  027F 09          	ret
0355+  0280             
0356+  0280             
0357+  0280             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0358+  0280             ; PRINT NULL TERMINATED STRING
0359+  0280             ; pointer in D
0360+  0280             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0361+  0280             puts:
0362+  0280 D7          	push a
0363+  0281 DA          	push d
0364+  0282             puts_L1:
0365+  0282 1E          	mov al, [d]
0366+  0283 B9 00       	cmp al, 0
0367+  0285 C6 91 02    	jz puts_END
0368+  0288 23          	mov ah, al
0369+  0289 19 00       	mov al, 0
0370+  028B 05 03       	syscall sys_io
0371+  028D 79          	inc d
0372+  028E 0A 82 02    	jmp puts_L1
0373+  0291             puts_END:
0374+  0291 E7          	pop d
0375+  0292 E4          	pop a
0376+  0293 09          	ret
0377+  0294             
0378+  0294             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  0294             ; PRINT N SIZE STRING
0380+  0294             ; pointer in D
0381+  0294             ; size in C
0382+  0294             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0383+  0294             putsn:
0384+  0294 DB          	push al
0385+  0295 DA          	push d
0386+  0296 D9          	push c
0387+  0297             putsn_L0:
0388+  0297 1E          	mov al, [d]
0389+  0298 23          	mov ah, al
0390+  0299 19 00       	mov al, 0
0391+  029B 05 03       	syscall sys_io
0392+  029D 79          	inc d
0393+  029E 7E          	dec c	
0394+  029F C2 00 00    	cmp c, 0
0395+  02A2 C7 97 02    	jne putsn_L0
0396+  02A5             putsn_end:
0397+  02A5 E6          	pop c
0398+  02A6 E7          	pop d
0399+  02A7 E8          	pop al
0400+  02A8 09          	ret
0401+  02A9             
0402+  02A9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0403+  02A9             ; print 16bit decimal number
0404+  02A9             ; input number in A
0405+  02A9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  02A9             print_u16d:
0407+  02A9 D7          	push a
0408+  02AA D8          	push b
0409+  02AB 26 10 27    	mov b, 10000
0410+  02AE AE          	div a, b			; get 10000 coeff.
0411+  02AF 07 D5 02    	call print_number
0412+  02B2 11          	mov a, b
0413+  02B3 26 E8 03    	mov b, 1000
0414+  02B6 AE          	div a, b			; get 10000 coeff.
0415+  02B7 07 D5 02    	call print_number
0416+  02BA 11          	mov a, b
0417+  02BB 26 64 00    	mov b, 100
0418+  02BE AE          	div a, b
0419+  02BF 07 D5 02    	call print_number
0420+  02C2 11          	mov a, b
0421+  02C3 26 0A 00    	mov b, 10
0422+  02C6 AE          	div a, b
0423+  02C7 07 D5 02    	call print_number
0424+  02CA 11          	mov a, b
0425+  02CB 6A 30       	add al, $30
0426+  02CD 23          	mov ah, al
0427+  02CE 19 00       	mov al, 0
0428+  02D0 05 03       	syscall sys_io	; print coeff
0429+  02D2 E5          	pop b
0430+  02D3 E4          	pop a
0431+  02D4 09          	ret
0432+  02D5             
0433+  02D5             
0434+  02D5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0435+  02D5             ; if A == 0, print space
0436+  02D5             ; else print A
0437+  02D5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0438+  02D5             print_number:
0439+  02D5 6A 30       	add al, $30
0440+  02D7 23          	mov ah, al
0441+  02D8 07 46 01    	call putchar
0442+  02DB 09          	ret
0443+  02DC             
0444+  02DC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  02DC             ; PRINT 16BIT HEX INTEGER
0446+  02DC             ; integer value in reg B
0447+  02DC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  02DC             print_u16x:
0449+  02DC D7          	push a
0450+  02DD D8          	push b
0451+  02DE DD          	push bl
0452+  02DF 30          	mov bl, bh
0453+  02E0 07 0D 01    	call itoa				; convert bh to char in A
0454+  02E3 2F          	mov bl, al				; save al
0455+  02E4 19 00       	mov al, 0
0456+  02E6 05 03       	syscall sys_io				; display AH
0457+  02E8 24          	mov ah, bl				; retrieve al
0458+  02E9 19 00       	mov al, 0
0459+  02EB 05 03       	syscall sys_io				; display AL
0460+  02ED             
0461+  02ED EA          	pop bl
0462+  02EE 07 0D 01    	call itoa				; convert bh to char in A
0463+  02F1 2F          	mov bl, al				; save al
0464+  02F2 19 00       	mov al, 0
0465+  02F4 05 03       	syscall sys_io				; display AH
0466+  02F6 24          	mov ah, bl				; retrieve al
0467+  02F7 19 00       	mov al, 0
0468+  02F9 05 03       	syscall sys_io				; display AL
0469+  02FB             
0470+  02FB E5          	pop b
0471+  02FC E4          	pop a
0472+  02FD 09          	ret
0473+  02FE             
0474+  02FE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0475+  02FE             ; INPUT 16BIT HEX INTEGER
0476+  02FE             ; read 16bit integer into A
0477+  02FE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0478+  02FE             scan_u16x:
0479+  02FE F8 10 00    	enter 16
0480+  0301 D8          	push b
0481+  0302 DA          	push d
0482+  0303             
0483+  0303 FA F1 FF    	lea d, [bp + -15]
0484+  0306 07 4D 01    	call gets				; get number
0485+  0309             
0486+  0309 32          	mov bl, [d]
0487+  030A 37          	mov bh, bl
0488+  030B 33 01 00    	mov bl, [d + 1]
0489+  030E 07 FB 00    	call atoi				; convert to int in AL
0490+  0311 23          	mov ah, al				; move to AH
0491+  0312             
0492+  0312 33 02 00    	mov bl, [d + 2]
0493+  0315 37          	mov bh, bl
0494+  0316 33 03 00    	mov bl, [d + 3]
0495+  0319 07 FB 00    	call atoi				; convert to int in AL
0496+  031C             
0497+  031C E7          	pop d
0498+  031D E5          	pop b
0499+  031E F9          	leave
0500+  031F 09          	ret
0501+  0320             
0502+  0320             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0503+  0320             ; PRINT 8bit HEX INTEGER
0504+  0320             ; integer value in reg bl
0505+  0320             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0506+  0320             print_u8x:
0507+  0320 D7          	push a
0508+  0321 DD          	push bl
0509+  0322             
0510+  0322 07 0D 01    	call itoa				; convert bl to char in A
0511+  0325 2F          	mov bl, al				; save al
0512+  0326 19 00       	mov al, 0
0513+  0328 05 03       	syscall sys_io				; display AH
0514+  032A 24          	mov ah, bl				; retrieve al
0515+  032B 19 00       	mov al, 0
0516+  032D 05 03       	syscall sys_io				; display AL
0517+  032F             
0518+  032F EA          	pop bl
0519+  0330 E4          	pop a
0520+  0331 09          	ret
0521+  0332             
0522+  0332             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0523+  0332             ; print 8bit decimal unsigned number
0524+  0332             ; input number in AL
0525+  0332             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0526+  0332             print_u8d:
0527+  0332 D7          	push a
0528+  0333 D8          	push b
0529+  0334             
0530+  0334 22 00       	mov ah, 0
0531+  0336 26 64 00    	mov b, 100
0532+  0339 AE          	div a, b
0533+  033A D8          	push b			; save remainder
0534+  033B B9 00       	cmp al, 0
0535+  033D C6 47 03    	je skip100
0536+  0340 6A 30       	add al, $30
0537+  0342 23          	mov ah, al
0538+  0343 19 00       	mov al, 0
0539+  0345 05 03       	syscall sys_io	; print coeff
0540+  0347             skip100:
0541+  0347 E4          	pop a
0542+  0348 22 00       	mov ah, 0
0543+  034A 26 0A 00    	mov b, 10
0544+  034D AE          	div a, b
0545+  034E D8          	push b			; save remainder
0546+  034F B9 00       	cmp al, 0
0547+  0351 C6 5B 03    	je skip10
0548+  0354 6A 30       	add al, $30
0549+  0356 23          	mov ah, al
0550+  0357 19 00       	mov al, 0
0551+  0359 05 03       	syscall sys_io	; print coeff
0552+  035B             skip10:
0553+  035B E4          	pop a
0554+  035C 1B          	mov al, bl
0555+  035D 6A 30       	add al, $30
0556+  035F 23          	mov ah, al
0557+  0360 19 00       	mov al, 0
0558+  0362 05 03       	syscall sys_io	; print coeff
0559+  0364 E5          	pop b
0560+  0365 E4          	pop a
0561+  0366 09          	ret
0562+  0367             
0563+  0367             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0564+  0367             ; INPUT 8BIT HEX INTEGER
0565+  0367             ; read 8bit integer into AL
0566+  0367             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0567+  0367             scan_u8x:
0568+  0367 F8 04 00    	enter 4
0569+  036A D8          	push b
0570+  036B DA          	push d
0571+  036C             
0572+  036C FA FD FF    	lea d, [bp + -3]
0573+  036F 07 4D 01    	call gets				; get number
0574+  0372             
0575+  0372 32          	mov bl, [d]
0576+  0373 37          	mov bh, bl
0577+  0374 33 01 00    	mov bl, [d + 1]
0578+  0377 07 FB 00    	call atoi				; convert to int in AL
0579+  037A             
0580+  037A E7          	pop d
0581+  037B E5          	pop b
0582+  037C F9          	leave
0583+  037D 09          	ret
0584+  037E             
0585+  037E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0586+  037E             ; input decimal number
0587+  037E             ; result in A
0588+  037E             ; 655'\0'
0589+  037E             ; low--------high
0590+  037E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0591+  037E             scan_u16d:
0592+  037E F8 08 00    	enter 8
0593+  0381 E2          	push si
0594+  0382 D8          	push b
0595+  0383 D9          	push c
0596+  0384 DA          	push d
0597+  0385 FA F9 FF    	lea d, [bp +- 7]
0598+  0388 07 4D 01    	call gets
0599+  038B 07 83 00    	call strlen			; get string length in C
0600+  038E 7E          	dec c
0601+  038F FD 4E       	mov si, d
0602+  0391 12          	mov a, c
0603+  0392 FD 99       	shl a
0604+  0394 3B E3 00    	mov d, table_power
0605+  0397 59          	add d, a
0606+  0398 38 00 00    	mov c, 0
0607+  039B             mul_loop:
0608+  039B F6          	lodsb			; load ASCII to al
0609+  039C B9 00       	cmp al, 0
0610+  039E C6 B1 03    	je mul_exit
0611+  03A1 6F 30       	sub al, $30		; make into integer
0612+  03A3 22 00       	mov ah, 0
0613+  03A5 2A          	mov b, [d]
0614+  03A6 AC          	mul a, b			; result in B since it fits in 16bits
0615+  03A7 11          	mov a, b
0616+  03A8 28          	mov b, c
0617+  03A9 54          	add a, b
0618+  03AA 39          	mov c, a
0619+  03AB 63 02 00    	sub d, 2
0620+  03AE 0A 9B 03    	jmp mul_loop
0621+  03B1             mul_exit:
0622+  03B1 12          	mov a, c
0623+  03B2 E7          	pop d
0624+  03B3 E6          	pop c
0625+  03B4 E5          	pop b
0626+  03B5 EF          	pop si
0627+  03B6 F9          	leave
0628+  03B7 09          	ret
0169   03B8             .include "ctype.asm"
0001+  03B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  03B8             ; ctype.s
0003+  03B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  03B8             
0005+  03B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  03B8             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  03B8             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  03B8             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  03B8             ;; characters are supported.
0010+  03B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  03B8             ;; isalnum 
0012+  03B8             ;; isalpha 
0013+  03B8             ;; islower 
0014+  03B8             ;; isupper 
0015+  03B8             ;; isdigit 
0016+  03B8             ;; isxdigit
0017+  03B8             ;; iscntrl 
0018+  03B8             ;; isgraph 
0019+  03B8             ;; isspace 
0020+  03B8             ;; isblank 
0021+  03B8             ;; isprint 
0022+  03B8             ;; ispunct 
0023+  03B8             ;; tolower 
0024+  03B8             ;; toupper
0025+  03B8             
0026+  03B8             
0027+  03B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  03B8             ;; IS ALPHANUMERIC
0029+  03B8             ;; sets ZF according with result
0030+  03B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  03B8             isalnum:
0032+  03B8 07 D5 03    	call isalpha
0033+  03BB C6 C1 03    	je isalnum_exit
0034+  03BE 07 C2 03    	call isdigit
0035+  03C1             isalnum_exit:
0036+  03C1 09          	ret	
0037+  03C2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  03C2             ;; IS DIGIT
0039+  03C2             ;; sets ZF according with result
0040+  03C2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  03C2             isdigit:
0042+  03C2 DB          	push al
0043+  03C3 B9 30       	cmp al, '0'
0044+  03C5 C8 D1 03    	jlu isdigit_false
0045+  03C8 B9 39       	cmp al, '9'
0046+  03CA D1 D1 03    	jgu isdigit_false
0047+  03CD 87 00       	and al, 0	; set ZF
0048+  03CF E8          	pop al
0049+  03D0 09          	ret
0050+  03D1             isdigit_false:
0051+  03D1 8B 01       	or al, 1	; clear ZF
0052+  03D3 E8          	pop al
0053+  03D4 09          	ret	
0054+  03D5             	
0055+  03D5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  03D5             ;; IS ALPHA
0057+  03D5             ;; sets ZF according with result
0058+  03D5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  03D5             isalpha:
0060+  03D5 DB          	push al
0061+  03D6 B9 5F       	cmp al, '_'
0062+  03D8 C6 F8 03    	je isalpha_true
0063+  03DB B9 2E       	cmp al, '.'
0064+  03DD C6 F8 03    	je isalpha_true
0065+  03E0 B9 41       	cmp al, 'A'
0066+  03E2 C8 F4 03    	jlu isalpha_false
0067+  03E5 B9 7A       	cmp al, 'z'
0068+  03E7 D1 F4 03    	jgu isalpha_false
0069+  03EA B9 5A       	cmp al, 'Z'
0070+  03EC D0 F8 03    	jleu isalpha_true
0071+  03EF B9 61       	cmp al, 'a'
0072+  03F1 C9 F8 03    	jgeu isalpha_true
0073+  03F4             isalpha_false:
0074+  03F4 8B 01       	or al, 1	; clear ZF
0075+  03F6 E8          	pop al
0076+  03F7 09          	ret
0077+  03F8             isalpha_true:
0078+  03F8 87 00       	and al, 0	; set ZF
0079+  03FA E8          	pop al
0080+  03FB 09          	ret
0081+  03FC             
0082+  03FC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  03FC             ;; IS PATH-ALPHA
0084+  03FC             ;; sets ZF according with result
0085+  03FC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  03FC             ispath:
0087+  03FC DB          	push al
0088+  03FD 07 C2 03    	call isdigit
0089+  0400 C6 2A 04    	je ispath_true
0090+  0403 B9 5F       	cmp al, '_'
0091+  0405 C6 2A 04    	je ispath_true
0092+  0408 B9 2F       	cmp al, '/'
0093+  040A C6 2A 04    	je ispath_true
0094+  040D B9 2E       	cmp al, '.'
0095+  040F C6 2A 04    	je ispath_true
0096+  0412 B9 41       	cmp al, 'A'
0097+  0414 C8 26 04    	jlu ispath_false
0098+  0417 B9 7A       	cmp al, 'z'
0099+  0419 D1 26 04    	jgu ispath_false
0100+  041C B9 5A       	cmp al, 'Z'
0101+  041E D0 2A 04    	jleu ispath_true
0102+  0421 B9 61       	cmp al, 'a'
0103+  0423 C9 2A 04    	jgeu ispath_true
0104+  0426             ispath_false:
0105+  0426 8B 01       	or al, 1	; clear ZF
0106+  0428 E8          	pop al
0107+  0429 09          	ret
0108+  042A             ispath_true:
0109+  042A 87 00       	and al, 0	; set ZF
0110+  042C E8          	pop al
0111+  042D 09          	ret
0112+  042E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  042E             ;; IS SPACE
0114+  042E             ;; sets ZF according with result
0115+  042E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  042E             isspace:
0117+  042E B9 20       	cmp al, $20		; ' '
0118+  0430 C6 44 04    	je isspace_exit
0119+  0433 B9 09       	cmp al, $09		; '\t'
0120+  0435 C6 44 04    	je isspace_exit
0121+  0438 B9 0A       	cmp al, $0A		; '\n'
0122+  043A C6 44 04    	je isspace_exit
0123+  043D B9 0D       	cmp al, $0D		; '\r'
0124+  043F C6 44 04    	je isspace_exit
0125+  0442 B9 0B       	cmp al, $0B		; '\v'
0126+  0444             isspace_exit:
0127+  0444 09          	ret	
0128+  0445             
0129+  0445             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0445             ; TO LOWER
0131+  0445             ; input in AL
0132+  0445             ; output in AL
0133+  0445             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  0445             to_lower:
0135+  0445 B9 5A       	cmp al, 'Z'
0136+  0447 D1 4C 04    	jgu to_lower_ret
0137+  044A 6A 20       	add al, $20				; convert to lower case
0138+  044C             to_lower_ret:
0139+  044C 09          	ret
0140+  044D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  044D             ; TO UPPER
0142+  044D             ; input in AL
0143+  044D             ; output in AL
0144+  044D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  044D             to_upper:
0146+  044D B9 61       	cmp al, 'a'
0147+  044F C8 54 04    	jlu to_upper_ret
0148+  0452 6F 20       	sub al, $20			; convert to upper case
0149+  0454             to_upper_ret:
0150+  0454 09          	ret
0151+  0455             
0170   0455             .include "token.asm"
0001+  0455             TOKTYP_IDENTIFIER	.equ 0
0002+  0455             TOKTYP_KEYWORD		.equ 1
0003+  0455             TOKTYP_DELIMITER	.equ 2
0004+  0455             TOKTYP_STRING		.equ 3
0005+  0455             TOKTYP_CHAR			.equ 4
0006+  0455             TOKTYP_NUMERIC		.equ 5
0007+  0455             TOKTYP_END			.equ 6
0008+  0455             
0009+  0455             TOK_NULL			.equ 0
0010+  0455             TOK_FSLASH			.equ 1
0011+  0455             TOK_TIMES 			.equ 2
0012+  0455             TOK_PLUS 			.equ 3
0013+  0455             TOK_MINUS 			.equ 4
0014+  0455             TOK_DOT				.equ 5
0015+  0455             TOK_SEMI			.equ 6
0016+  0455             TOK_ANGLE			.equ 7
0017+  0455             TOK_TILDE			.equ 8
0018+  0455             TOK_EQUAL			.equ 9
0019+  0455             TOK_COLON			.equ 10
0020+  0455             TOK_COMMA			.equ 11
0021+  0455             
0022+  0455             TOK_END				.equ 20
0023+  0455             
0024+  0455             
0025+  0455             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  0455             ;; read a full command argment from shell input buffer
0027+  0455             ;; argument is written into tokstr
0028+  0455             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  0455             get_arg:
0030+  0455 D7          	push a
0031+  0456 E2          	push si
0032+  0457 E3          	push di
0033+  0458 19 00       	mov al, 0
0034+  045A 3D 83 06    	mov [tokstr], al			; nullify tokstr string
0035+  045D 14 7F 06    	mov a, [prog]
0036+  0460 4D          	mov si, a
0037+  0461 FD 4F 83 06 	mov di, tokstr
0038+  0465             get_arg_skip_spaces:
0039+  0465 F6          	lodsb
0040+  0466 07 2E 04    	call isspace
0041+  0469 C6 65 04    	je get_arg_skip_spaces
0042+  046C             get_arg_L0:
0043+  046C B9 3B       	cmp al, $3B				; check if is ';'
0044+  046E C6 7B 04    	je get_arg_end
0045+  0471 B9 00       	cmp al, 0
0046+  0473 C6 7B 04    	je get_arg_end			; check if end of input
0047+  0476 F7          	stosb
0048+  0477 F6          	lodsb
0049+  0478 0A 6C 04    	jmp get_arg_L0
0050+  047B             get_arg_end:
0051+  047B 19 00       	mov al, 0
0052+  047D F7          	stosb
0053+  047E D5 01 00    	sub si, 1
0054+  0481 4E          	mov a, si
0055+  0482 42 7F 06    	mov [prog], a		; update pointer
0056+  0485 F0          	pop di
0057+  0486 EF          	pop si
0058+  0487 E4          	pop a
0059+  0488 09          	ret
0060+  0489             
0061+  0489             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  0489             ;; read a path formation from shell input buffer
0063+  0489             ;; path is written into tokstr
0064+  0489             ;; /usr/bin
0065+  0489             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  0489             get_path:
0067+  0489 D7          	push a
0068+  048A E2          	push si
0069+  048B E3          	push di
0070+  048C 19 00       	mov al, 0
0071+  048E 3D 83 06    	mov [tokstr], al			; nullify tokstr string
0072+  0491 14 7F 06    	mov a, [prog]
0073+  0494 4D          	mov si, a
0074+  0495 FD 4F 83 06 	mov di, tokstr
0075+  0499             get_path_skip_spaces:
0076+  0499 F6          	lodsb
0077+  049A 07 2E 04    	call isspace
0078+  049D C6 99 04    	je get_path_skip_spaces
0079+  04A0             get_path_is_pathchar:
0080+  04A0 F7          	stosb
0081+  04A1 F6          	lodsb
0082+  04A2 07 B8 03    	call isalnum			;check if is alphanumeric
0083+  04A5 C6 A0 04    	je get_path_is_pathchar
0084+  04A8 B9 2F       	cmp al, '/'				; check if is '/'
0085+  04AA C6 A0 04    	je get_path_is_pathchar
0086+  04AD 19 00       	mov al, 0
0087+  04AF F7          	stosb
0088+  04B0 D5 01 00    	sub si, 1
0089+  04B3 4E          	mov a, si
0090+  04B4 42 7F 06    	mov [prog], a		; update pointer
0091+  04B7             get_path_end:
0092+  04B7 F0          	pop di
0093+  04B8 EF          	pop si
0094+  04B9 E4          	pop a
0095+  04BA 09          	ret
0096+  04BB             
0097+  04BB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  04BB             ;; read a line
0099+  04BB             ;; line is written into tokstr
0100+  04BB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  04BB             get_line:
0102+  04BB D7          	push a
0103+  04BC E2          	push si
0104+  04BD E3          	push di
0105+  04BE 19 00       	mov al, 0
0106+  04C0 3D 83 06    	mov [tokstr], al			; nullify tokstr string
0107+  04C3 14 7F 06    	mov a, [prog]
0108+  04C6 4D          	mov si, a
0109+  04C7 FD 4F 83 06 	mov di, tokstr
0110+  04CB             get_line_L0:
0111+  04CB F6          	lodsb
0112+  04CC B9 0A       	cmp al, $0A		; check for new line
0113+  04CE C6 D5 04    	je get_line_exit
0114+  04D1 F7          	stosb
0115+  04D2 0A CB 04    	jmp get_line_L0
0116+  04D5             get_line_exit:
0117+  04D5 19 00       	mov al, 0
0118+  04D7 F7          	stosb
0119+  04D8 4E          	mov a, si
0120+  04D9 42 7F 06    	mov [prog], a		; update pointer
0121+  04DC F0          	pop di
0122+  04DD EF          	pop si
0123+  04DE E4          	pop a
0124+  04DF 09          	ret
0125+  04E0             
0126+  04E0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  04E0             ;; token parser
0128+  04E0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  04E0             get_token:
0130+  04E0 D7          	push a
0131+  04E1 DA          	push d
0132+  04E2 E2          	push si
0133+  04E3 E3          	push di
0134+  04E4 19 00       	mov al, 0
0135+  04E6 3D 83 06    	mov [tokstr], al			; nullify tokstr string
0136+  04E9 19 00       	mov al, TOK_NULL
0137+  04EB 3D 82 06    	mov [tok], al				; nullify token
0138+  04EE 14 7F 06    	mov a, [prog]
0139+  04F1 4D          	mov si, a
0140+  04F2 FD 4F 83 06 	mov di, tokstr
0141+  04F6             get_tok_skip_spaces:
0142+  04F6 F6          	lodsb
0143+  04F7 07 2E 04    	call isspace
0144+  04FA C6 F6 04    	je get_tok_skip_spaces
0145+  04FD B9 00       	cmp al, 0			; check for end of input (NULL)
0146+  04FF C6 E4 05    	je get_token_end
0147+  0502 B9 23       	cmp al, '#'			; comments!
0148+  0504 C6 12 06    	je get_tok_comment
0149+  0507 07 B8 03    	call isalnum
0150+  050A C6 F1 05    	jz is_alphanumeric
0151+  050D             ; other token types
0152+  050D             get_token_slash:
0153+  050D B9 2F       	cmp al, '/'				; check if '/'
0154+  050F C7 27 05    	jne get_token_minus
0155+  0512 F7          	stosb					; store '/' into token string
0156+  0513 19 00       	mov al, 0
0157+  0515 F7          	stosb					; terminate token string
0158+  0516 19 01       	mov al, TOK_FSLASH
0159+  0518 3D 82 06    	mov [tok], al			
0160+  051B 19 02       	mov al, TOKTYP_DELIMITER
0161+  051D 3D 81 06    	mov [toktyp], al
0162+  0520 4E          	mov a, si
0163+  0521 42 7F 06    	mov [prog], a		; update pointer
0164+  0524 0A 0D 06    	jmp get_token_return
0165+  0527             get_token_minus:
0166+  0527 B9 2D       	cmp al, '-'				; check if '-'
0167+  0529 C7 41 05    	jne get_token_comma
0168+  052C F7          	stosb					; store '-' into token string
0169+  052D 19 00       	mov al, 0
0170+  052F F7          	stosb					; terminate token string
0171+  0530 19 04       	mov al, TOK_MINUS
0172+  0532 3D 82 06    	mov [tok], al			
0173+  0535 19 02       	mov al, TOKTYP_DELIMITER
0174+  0537 3D 81 06    	mov [toktyp], al
0175+  053A 4E          	mov a, si
0176+  053B 42 7F 06    	mov [prog], a		; update pointer
0177+  053E 0A 0D 06    	jmp get_token_return
0178+  0541             get_token_comma:
0179+  0541 B9 2C       	cmp al, ','				; check if ','
0180+  0543 C7 5B 05    	jne get_token_semi
0181+  0546 F7          	stosb					; store ',' into token string
0182+  0547 19 00       	mov al, 0
0183+  0549 F7          	stosb					; terminate token string
0184+  054A 19 0B       	mov al, TOK_COMMA
0185+  054C 3D 82 06    	mov [tok], al			
0186+  054F 19 02       	mov al, TOKTYP_DELIMITER
0187+  0551 3D 81 06    	mov [toktyp], al
0188+  0554 4E          	mov a, si
0189+  0555 42 7F 06    	mov [prog], a		; update pointer
0190+  0558 0A 0D 06    	jmp get_token_return
0191+  055B             get_token_semi:
0192+  055B B9 3B       	cmp al, $3B				; check if ';'
0193+  055D C7 75 05    	jne get_token_colon
0194+  0560 F7          	stosb					; store ';' into token string
0195+  0561 19 00       	mov al, 0
0196+  0563 F7          	stosb					; terminate token string
0197+  0564 19 06       	mov al, TOK_SEMI
0198+  0566 3D 82 06    	mov [tok], al			
0199+  0569 19 02       	mov al, TOKTYP_DELIMITER
0200+  056B 3D 81 06    	mov [toktyp], al
0201+  056E 4E          	mov a, si
0202+  056F 42 7F 06    	mov [prog], a		; update pointer
0203+  0572 0A 0D 06    	jmp get_token_return
0204+  0575             get_token_colon:
0205+  0575 B9 3A       	cmp al, $3A				; check if ':'
0206+  0577 C7 8F 05    	jne get_token_angle
0207+  057A F7          	stosb					; store ':' into token string
0208+  057B 19 00       	mov al, 0
0209+  057D F7          	stosb					; terminate token string
0210+  057E 19 0A       	mov al, TOK_COLON
0211+  0580 3D 82 06    	mov [tok], al			
0212+  0583 19 02       	mov al, TOKTYP_DELIMITER
0213+  0585 3D 81 06    	mov [toktyp], al
0214+  0588 4E          	mov a, si
0215+  0589 42 7F 06    	mov [prog], a		; update pointer
0216+  058C 0A 0D 06    	jmp get_token_return
0217+  058F             get_token_angle:
0218+  058F B9 3E       	cmp al, $3E				; check if '>'
0219+  0591 C7 A9 05    	jne get_token_tilde
0220+  0594 F7          	stosb					; store '>' into token string
0221+  0595 19 00       	mov al, 0
0222+  0597 F7          	stosb					; terminate token string
0223+  0598 19 07       	mov al, TOK_ANGLE
0224+  059A 3D 82 06    	mov [tok], al			
0225+  059D 19 02       	mov al, TOKTYP_DELIMITER
0226+  059F 3D 81 06    	mov [toktyp], al
0227+  05A2 4E          	mov a, si
0228+  05A3 42 7F 06    	mov [prog], a		; update pointer
0229+  05A6 0A 0D 06    	jmp get_token_return
0230+  05A9             get_token_tilde:
0231+  05A9 B9 7E       	cmp al, '~'				; check if '~'
0232+  05AB C7 C3 05    	jne get_token_equal
0233+  05AE F7          	stosb					; store '~' into token string
0234+  05AF 19 00       	mov al, 0
0235+  05B1 F7          	stosb					; terminate token string
0236+  05B2 19 08       	mov al, TOK_TILDE
0237+  05B4 3D 82 06    	mov [tok], al			
0238+  05B7 19 02       	mov al, TOKTYP_DELIMITER
0239+  05B9 3D 81 06    	mov [toktyp], al
0240+  05BC 4E          	mov a, si
0241+  05BD 42 7F 06    	mov [prog], a		; update pointer
0242+  05C0 0A 0D 06    	jmp get_token_return
0243+  05C3             get_token_equal:
0244+  05C3 B9 3D       	cmp al, '='				; check if '='
0245+  05C5 C7 DD 05    	jne get_token_skip
0246+  05C8 F7          	stosb					; store '=' into token string
0247+  05C9 19 00       	mov al, 0
0248+  05CB F7          	stosb					; terminate token string
0249+  05CC 19 09       	mov al, TOK_EQUAL
0250+  05CE 3D 82 06    	mov [tok], al			
0251+  05D1 19 02       	mov al, TOKTYP_DELIMITER
0252+  05D3 3D 81 06    	mov [toktyp], al
0253+  05D6 4E          	mov a, si
0254+  05D7 42 7F 06    	mov [prog], a		; update pointer
0255+  05DA 0A 0D 06    	jmp get_token_return
0256+  05DD             get_token_skip:
0257+  05DD 4E          	mov a, si
0258+  05DE 42 7F 06    	mov [prog], a		; update pointer
0259+  05E1 0A 0D 06    	jmp get_token_return
0260+  05E4             get_token_end:				; end of file token
0261+  05E4 19 14       	mov al, TOK_END
0262+  05E6 3D 82 06    	mov [tok], al
0263+  05E9 19 06       	mov al, TOKTYP_END
0264+  05EB 3D 81 06    	mov [toktyp], al
0265+  05EE 0A 0D 06    	jmp get_token_return
0266+  05F1             is_alphanumeric:
0267+  05F1 F7          	stosb
0268+  05F2 F6          	lodsb
0269+  05F3 07 B8 03    	call isalnum			;check if is alphanumeric
0270+  05F6 C6 F1 05    	jz is_alphanumeric
0271+  05F9 B9 2E       	cmp al, $2E				; check if is '.'
0272+  05FB C6 F1 05    	je is_alphanumeric
0273+  05FE 19 00       	mov al, 0
0274+  0600 F7          	stosb
0275+  0601 19 00       	mov al, TOKTYP_IDENTIFIER
0276+  0603 3D 81 06    	mov [toktyp], al
0277+  0606 D5 01 00    	sub si, 1
0278+  0609 4E          	mov a, si
0279+  060A 42 7F 06    	mov [prog], a		; update pointer
0280+  060D             get_token_return:
0281+  060D F0          	pop di
0282+  060E EF          	pop si
0283+  060F E7          	pop d
0284+  0610 E4          	pop a
0285+  0611 09          	ret
0286+  0612             get_tok_comment:
0287+  0612 F6          	lodsb
0288+  0613 B9 0A       	cmp al, $0A			; new line
0289+  0615 C7 12 06    	jne get_tok_comment
0290+  0618 0A F6 04    	jmp get_tok_skip_spaces
0291+  061B             
0292+  061B             
0293+  061B             get_number:
0294+  061B D7          	push a
0295+  061C DA          	push d
0296+  061D E2          	push si
0297+  061E E3          	push di
0298+  061F 19 00       	mov al, 0
0299+  0621 3D 83 06    	mov [tokstr], al			; nullify tokstr string
0300+  0624 19 00       	mov al, TOK_NULL
0301+  0626 3D 82 06    	mov [tok], al				; nullify token
0302+  0629 14 7F 06    	mov a, [prog]
0303+  062C 4D          	mov si, a
0304+  062D FD 4F 83 06 	mov di, tokstr
0305+  0631             get_number_skip_spaces:
0306+  0631 F6          	lodsb
0307+  0632 07 2E 04    	call isspace
0308+  0635 C6 31 06    	je get_number_skip_spaces
0309+  0638 B9 00       	cmp al, 0			; check for end of input (NULL)
0310+  063A C7 4A 06    	jne get_number_L0
0311+  063D 19 14       	mov al, TOK_END
0312+  063F 3D 82 06    	mov [tok], al
0313+  0642 19 06       	mov al, TOKTYP_END
0314+  0644 3D 81 06    	mov [toktyp], al
0315+  0647 0A 61 06    	jmp get_number_return
0316+  064A             get_number_L0:
0317+  064A F7          	stosb
0318+  064B F6          	lodsb
0319+  064C 07 C2 03    	call isdigit			;check if is numeric
0320+  064F C6 4A 06    	jz get_number_L0
0321+  0652 19 00       	mov al, 0
0322+  0654 F7          	stosb
0323+  0655 19 05       	mov al, TOKTYP_NUMERIC
0324+  0657 3D 81 06    	mov [toktyp], al
0325+  065A D5 01 00    	sub si, 1
0326+  065D 4E          	mov a, si
0327+  065E 42 7F 06    	mov [prog], a		; update pointer
0328+  0661             get_number_return:
0329+  0661 F0          	pop di
0330+  0662 EF          	pop si
0331+  0663 E7          	pop d
0332+  0664 E4          	pop a
0333+  0665 09          	ret
0334+  0666             
0335+  0666             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  0666             ;; PUT BACK TOKEN
0337+  0666             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
0338+  0666             putback:
0339+  0666 D7          	push a
0340+  0667 E2          	push si
0341+  0668 FD 4D 83 06 	mov si, tokstr	
0342+  066C             putback_loop:
0343+  066C F6          	lodsb
0344+  066D B9 00       	cmp al, 0
0345+  066F C6 7C 06    	je putback_end
0346+  0672 14 7F 06    	mov a, [prog]
0347+  0675 7D          	dec a
0348+  0676 42 7F 06    	mov [prog], a			; update pointer
0349+  0679 0A 6C 06    	jmp putback_loop
0350+  067C             putback_end:
0351+  067C EF          	pop si
0352+  067D E4          	pop a
0353+  067E 09          	ret
0354+  067F             
0355+  067F             
0356+  067F             
0357+  067F             
0358+  067F 00 00       prog:		.dw 0			; pointer to current position in buffer
0359+  0681             
0360+  0681 00          toktyp: 	.db 0			; token type symbol
0361+  0682 00          tok:		.db 0			; current token symbol
0362+  0683 00 00 00 00 tokstr:		.fill 256, 0	; token as a string
0362+  0687 00 00 00 00 
0362+  068B 00 00 00 00 
0362+  068F 00 00 00 00 
0362+  0693 00 00 00 00 
0362+  0697 00 00 00 00 
0362+  069B 00 00 00 00 
0362+  069F 00 00 00 00 
0362+  06A3 00 00 00 00 
0362+  06A7 00 00 00 00 
0362+  06AB 00 00 00 00 
0362+  06AF 00 00 00 00 
0362+  06B3 00 00 00 00 
0362+  06B7 00 00 00 00 
0362+  06BB 00 00 00 00 
0362+  06BF 00 00 00 00 
0362+  06C3 00 00 00 00 
0362+  06C7 00 00 00 00 
0362+  06CB 00 00 00 00 
0362+  06CF 00 00 00 00 
0362+  06D3 00 00 00 00 
0362+  06D7 00 00 00 00 
0362+  06DB 00 00 00 00 
0362+  06DF 00 00 00 00 
0362+  06E3 00 00 00 00 
0362+  06E7 00 00 00 00 
0362+  06EB 00 00 00 00 
0362+  06EF 00 00 00 00 
0362+  06F3 00 00 00 00 
0362+  06F7 00 00 00 00 
0362+  06FB 00 00 00 00 
0362+  06FF 00 00 00 00 
0362+  0703 00 00 00 00 
0362+  0707 00 00 00 00 
0362+  070B 00 00 00 00 
0362+  070F 00 00 00 00 
0362+  0713 00 00 00 00 
0362+  0717 00 00 00 00 
0362+  071B 00 00 00 00 
0362+  071F 00 00 00 00 
0362+  0723 00 00 00 00 
0362+  0727 00 00 00 00 
0362+  072B 00 00 00 00 
0362+  072F 00 00 00 00 
0362+  0733 00 00 00 00 
0362+  0737 00 00 00 00 
0362+  073B 00 00 00 00 
0362+  073F 00 00 00 00 
0362+  0743 00 00 00 00 
0362+  0747 00 00 00 00 
0362+  074B 00 00 00 00 
0362+  074F 00 00 00 00 
0362+  0753 00 00 00 00 
0362+  0757 00 00 00 00 
0362+  075B 00 00 00 00 
0362+  075F 00 00 00 00 
0362+  0763 00 00 00 00 
0362+  0767 00 00 00 00 
0362+  076B 00 00 00 00 
0362+  076F 00 00 00 00 
0362+  0773 00 00 00 00 
0362+  0777 00 00 00 00 
0362+  077B 00 00 00 00 
0362+  077F 00 00 00 00 
0171   0783             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0172   0783             
0173   0783             sys_bkpt			.equ 0
0174   0783             sys_rtc				.equ 1
0175   0783             sys_IDE				.equ 2
0176   0783             sys_io				.equ 3
0177   0783             sys_fileio			.equ 4
0178   0783             sys_fork			.equ 5
0179   0783             sys_list			.equ 6
0180   0783             sys_datetime		.equ 7
0181   0783             sys_reboot			.equ 8
0182   0783             sys_pauseproc		.equ 9
0183   0783             sys_resumeproc		.equ 10
0184   0783             sys_terminate_proc	.equ 11
0185   0783             sys_system			.equ 12
0186   0783             sys_boot_install	.equ 13
0187   0783             
0188   0783             .export PROC_TEXT_ORG
0189   0783             .export sys_bkpt
0190   0783             .export sys_IDE
0191   0783             .export sys_io
0192   0783             .export sys_fileio
0193   0783             .export sys_fork
0194   0783             .export sys_list
0195   0783             .export sys_rtc
0196   0783             .export sys_datetime
0197   0783             .export sys_reboot
0198   0783             .export sys_pauseproc
0199   0783             .export sys_resumeproc
0200   0783             .export sys_terminate_proc
0201   0783             .export sys_system
0202   0783             .export sys_boot_install
0203   0783             
0204   0783             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0205   0783             ; EXTERNAL INTERRUPTS' CODE BLOCK
0206   0783             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0207   0783             ; uart
0208   0783             int_0:
0209   0783 06          	sysret
0210   0784             int_1:
0211   0784 06          	sysret
0212   0785             int_2:
0213   0785 06          	sysret
0214   0786             int_3:
0215   0786 06          	sysret
0216   0787             int_4:
0217   0787 06          	sysret
0218   0788             int_5:
0219   0788 06          	sysret
0220   0789             int_6:	
0221   0789             ; save all registers into kernel stack
0222   0789 4B          	pusha
0223   078A 22 00       	mov ah, 0
0224   078C 1D 23 16    	mov al, [active_proc_index]
0225   078F FD 99       	shl a							; x2
0226   0791 B7 E1 15    	mov a, [proc_table_convert + a]	; get process state start index
0227   0794             		
0228   0794 4F          	mov di, a
0229   0795 48          	mov a, sp
0230   0796 77          	inc a
0231   0797 4D          	mov si, a
0232   0798 38 14 00    	mov c, 20
0233   079B FD F5       	rep movsb					; save process state!
0234   079D             ; restore kernel stack position to point before interrupt arrived
0235   079D 51 14 00    	add sp, 20
0236   07A0             ; now load next process in queue
0237   07A0 1D 23 16    	mov al, [active_proc_index]
0238   07A3 31 22 16    	mov bl, [nbr_active_procs]
0239   07A6 BA          	cmp al, bl
0240   07A7 C6 AE 07    	je int6_cycle_back
0241   07AA 7A          	inc al						; next process is next in the series
0242   07AB 0A B0 07    	jmp int6_continue
0243   07AE             int6_cycle_back:
0244   07AE 19 01       	mov al, 1				; next process = process 1
0245   07B0             int6_continue:
0246   07B0 3D 23 16    	mov [active_proc_index], al		; set next active proc
0247   07B3             
0248   07B3             ; calculate LUT entry for next process
0249   07B3 22 00       	mov ah, 0
0250   07B5 FD 99       	shl a							; x2
0251   07B7 B7 E1 15    	mov a, [proc_table_convert + a]		; get process state start index	
0252   07BA             	
0253   07BA 4D          	mov si, a						; source is proc state block
0254   07BB 48          	mov a, sp
0255   07BC 5F 13 00    	sub a, 19
0256   07BF 4F          	mov di, a						; destination is kernel stack
0257   07C0             ; restore SP
0258   07C0 7D          	dec a
0259   07C1 47          	mov sp, a
0260   07C2 38 14 00    	mov c, 20
0261   07C5 FD F5       	rep movsb
0262   07C7             ; set VM process
0263   07C7 1D 23 16    	mov al, [active_proc_index]
0264   07CA 01          	setptb
0265   07CB             		
0266   07CB F2 E0 FF 00 	mov byte[_TIMER_C_0], 0				; load counter 0 low byte
0267   07CF F2 E0 FF 10 	mov byte[_TIMER_C_0], $10				; load counter 0 high byte
0268   07D3             			
0269   07D3 4C          	popa
0270   07D4 06          	sysret
0271   07D5             
0272   07D5             int_7:
0273   07D5 D7          	push a
0274   07D6 DA          	push d
0275   07D7 E1          	pushf
0276   07D8             			
0277   07D8 14 28 16    	mov a, [fifo_pi]
0278   07DB 3C          	mov d, a
0279   07DC             
0280   07DC 1D 80 FF    	mov al, [_UART0_DATA]	; get character
0281   07DF B9 03       	cmp al, $03				; CTRL-C
0282   07E1 C6 FE 07    	je CTRLC
0283   07E4 B9 1A       	cmp al, $1A				; CTRL-Z
0284   07E6 C6 04 08    	je CTRLZ
0285   07E9 3E          	mov [d], al				; add to fifo
0286   07EA             	
0287   07EA 14 28 16    	mov a, [fifo_pi]
0288   07ED 77          	inc a
0289   07EE AF DF 26    	cmp a, fifo + FIFO_SIZE 				; check if pointer reached the end of the fifo
0290   07F1 C7 F7 07    	jne int_7_continue
0291   07F4 10 DF 1E    	mov a, fifo	
0292   07F7             int_7_continue:	
0293   07F7 42 28 16    	mov [fifo_pi], a			; update fifo pointer
0294   07FA             	
0295   07FA EE          	popf
0296   07FB E7          	pop d
0297   07FC E4          	pop a	
0298   07FD 06          	sysret
0299   07FE             
0300   07FE             CTRLC:
0301   07FE EE          	popf
0302   07FF E7          	pop d
0303   0800 E4          	pop a
0304   0801 0A EB 14    	jmp cmd_terminate_proc
0305   0804             
0306   0804             CTRLZ:
0307   0804 EE          	popf
0308   0805 E7          	pop d
0309   0806 E4          	pop a
0310   0807 0A 2E 15    	jmp cmd_pause_proc		; pause current process and go back to the shell
0311   080A             
0312   080A             cmd_system_jmptbl:
0313   080A 12 08       	.dw cmd_system_uname
0314   080C 19 08       	.dw cmd_system_whoami
0315   080E             
0316   080E             cmd_system:
0317   080E FD 0A 0A 08 	jmp [cmd_system_jmptbl + al]
0318   0812             cmd_system_uname:
0319   0812 3B 69 16    	mov d, s_uname
0320   0815 07 80 02    	call puts
0321   0818 06          	sysret
0322   0819             cmd_system_whoami:
0323   0819 3B 73 16    	mov d, s_root
0324   081C 07 80 02    	call puts
0325   081F 06          	sysret
0326   0820             
0327   0820             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0328   0820             ; REBOOT SYSTEM
0329   0820             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0330   0820             syscall_reboot:
0331   0820 FD D7 FF FF 	push word $FFFF 
0332   0824 FD DB 00    	push byte %00000000				; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
0333   0827 FD D7 C0 01 	push word BIOS_RESET_VECTOR		; and then push RESET VECTOR of the shell to the stack
0334   082B 06          	sysret
0335   082C             
0336   082C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0337   082C             ;; switch to another process
0338   082C             ;; inputs:
0339   082C             ;; AL = new process number
0340   082C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0341   082C             resume_proc:
0342   082C FD 78       	mov g, a	; save the process number
0343   082E             ; save all registers into kernel stack
0344   082E 4B          	pusha
0345   082F 22 00       	mov ah, 0
0346   0831 1D 23 16    	mov al, [active_proc_index]
0347   0834 FD 99       	shl a							; x2
0348   0836 B7 E1 15    	mov a, [proc_table_convert + a]	; get process state start index
0349   0839 4F          	mov di, a
0350   083A 48          	mov a, sp
0351   083B 77          	inc a
0352   083C 4D          	mov si, a
0353   083D 38 14 00    	mov c, 20
0354   0840 FD F5       	rep movsb					; save process state!
0355   0842             ; restore kernel stack position to point before interrupt arrived
0356   0842 51 14 00    	add sp, 20
0357   0845             ; now load the new process number!
0358   0845 FD 12       	mov a, g						; retrieve the process number argument that was saved in the beginning
0359   0847 3D 23 16    	mov [active_proc_index], al		; set new active proc
0360   084A             ; calculate LUT entry for next process
0361   084A 22 00       	mov ah, 0
0362   084C FD 99       	shl a							; x2
0363   084E B7 E1 15    	mov a, [proc_table_convert + a]		; get process state start index	
0364   0851             	
0365   0851 4D          	mov si, a						; source is proc state block
0366   0852 48          	mov a, sp
0367   0853 5F 13 00    	sub a, 19
0368   0856 4F          	mov di, a						; destination is kernel stack
0369   0857             ; restore SP
0370   0857 7D          	dec a
0371   0858 47          	mov sp, a
0372   0859 38 14 00    	mov c, 20
0373   085C FD F5       	rep movsb
0374   085E             ; set VM process
0375   085E 1D 23 16    	mov al, [active_proc_index]
0376   0861 01          	setptb
0377   0862             			
0378   0862 4C          	popa
0379   0863 06          	sysret
0380   0864             
0381   0864             
0382   0864             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0383   0864             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384   0864             list_procs:
0385   0864 3B 4C 16    	mov d, s_ps_header
0386   0867 07 80 02    	call puts
0387   086A 3B D0 18    	mov d, proc_availab_table + 1
0388   086D 38 01 00    	mov c, 1
0389   0870             list_procs_L0:	
0390   0870 BD 01       	cmp byte[d], 1
0391   0872 C7 96 08    	jne list_procs_next
0392   0875 2D          	mov b, d
0393   0876 61 CF 18    	sub b, proc_availab_table
0394   0879 FD 9F 05    	shl b, 5
0395   087C DA          	push d
0396   087D D8          	push b
0397   087E 28          	mov b, c
0398   087F 07 20 03    	call print_u8x
0399   0882 22 20       	mov ah, ' '
0400   0884 07 46 01    	call putchar
0401   0887 07 46 01    	call putchar
0402   088A E5          	pop b
0403   088B 74          	mov d, b
0404   088C 58 DF 18    	add d, proc_names
0405   088F 07 80 02    	call puts
0406   0892 07 2D 02    	call printnl
0407   0895 E7          	pop d
0408   0896             list_procs_next:
0409   0896 79          	inc d
0410   0897 78          	inc c
0411   0898 C2 09 00    	cmp c, 9
0412   089B C7 70 08    	jne list_procs_L0
0413   089E             list_procs_end:
0414   089E 06          	sysret
0415   089F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0416   089F             ; PRIVILEGE EXCEPTION
0417   089F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418   089F             trap_privilege:
0419   089F 0A 20 08    	jmp syscall_reboot
0420   08A2 DA          	push d
0421   08A3             
0422   08A3 3B C1 16    	mov d, s_priviledge
0423   08A6 07 80 02    	call puts
0424   08A9             
0425   08A9 E7          	pop d
0426   08AA             	
0427   08AA 06          	sysret
0428   08AB             
0429   08AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0430   08AB             ; BREAKPOINT EXCEPTION
0431   08AB             ; IMPORTANT: values in the stack are being pushed in big endian. i.e.: MSB at low address
0432   08AB             ; and LSB at high address. *** NEED TO CORRECT THIS IN THE MICROCODE and make it little endian again ***
0433   08AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0434   08AB             trap_breakpoint:
0435   08AB 4B          	pusha
0436   08AC             trap_break_prompt:
0437   08AC 3B 66 09    	mov d, s_break1
0438   08AF 07 80 02    	call puts
0439   08B2 07 2D 02    	call printnl
0440   08B5 07 7E 03    	call scan_u16d
0441   08B8 AF 00 00    	cmp a, 0
0442   08BB C6 C6 08    	je trap_break_regs
0443   08BE AF 01 00    	cmp a, 1
0444   08C1 C6 E9 08    	je trap_break_mem
0445   08C4             trap_break_end:	
0446   08C4 4C          	popa
0447   08C5 06          	sysret
0448   08C6             trap_break_regs:
0449   08C6 48          	mov a, sp
0450   08C7 53 0E 00    	add a, 14	; back-track 7 registers
0451   08CA 3C          	mov d, a
0452   08CB 3A 07       	mov cl, 7
0453   08CD             trap_regs_L0:
0454   08CD 2A          	mov b, [d]
0455   08CE FD AB       	swp b
0456   08D0 07 DC 02    	call print_u16x	; print register value
0457   08D3 07 2D 02    	call printnl
0458   08D6 63 02 00    	sub d, 2
0459   08D9 71 01       	sub cl, 1
0460   08DB C3 00       	cmp cl, 0
0461   08DD C7 CD 08    	jne trap_regs_L0
0462   08E0 0A AC 08    	jmp trap_break_prompt
0463   08E3 07 2D 02    	call printnl
0464   08E6 0A AC 08    	jmp trap_break_prompt
0465   08E9             trap_break_mem:
0466   08E9 07 2D 02    	call printnl
0467   08EC 07 FE 02    	call scan_u16x
0468   08EF 4D          	mov si, a			; data source from user space
0469   08F0 FD 4F DF 26 	mov di, scrap_sector		; destination in kernel space
0470   08F4 38 00 02    	mov c, 512
0471   08F7 04          	load				; transfer data to kernel space!
0472   08F8 3B DF 26    	mov d, scrap_sector		; dump pointer in d
0473   08FB 38 00 00    	mov c, 0
0474   08FE             dump_loop:
0475   08FE 84          	mov al, cl
0476   08FF 87 0F       	and al, $0F
0477   0901 C6 4F 09    	jz print_base
0478   0904             back:
0479   0904 1E          	mov al, [d]				; read byte
0480   0905 2F          	mov bl, al
0481   0906 07 20 03    	call print_u8x
0482   0909 10 00 20    	mov a, $2000
0483   090C 05 03       	syscall sys_io			; space
0484   090E 84          	mov al, cl
0485   090F 87 0F       	and al, $0F
0486   0911 B9 0F       	cmp al, $0F
0487   0913 C6 24 09    	je print_ascii
0488   0916             back1:
0489   0916 79          	inc d
0490   0917 78          	inc c
0491   0918 C2 00 02    	cmp c, 512
0492   091B C7 FE 08    	jne dump_loop
0493   091E 07 2D 02    	call printnl
0494   0921 0A AC 08    	jmp trap_break_prompt	; go to trap_breakpoint return point
0495   0924             print_ascii:
0496   0924 10 00 20    	mov a, $2000
0497   0927 05 03       	syscall sys_io
0498   0929 63 10 00    	sub d, 16
0499   092C 26 10 00    	mov b, 16
0500   092F             print_ascii_L:
0501   092F 79          	inc d
0502   0930 1E          	mov al, [d]				; read byte
0503   0931 B9 20       	cmp al, $20
0504   0933 C8 3B 09    	jlu dot
0505   0936 B9 7E       	cmp al, $7E
0506   0938 D0 43 09    	jleu ascii
0507   093B             dot:
0508   093B 10 00 2E    	mov a, $2E00
0509   093E 05 03       	syscall sys_io
0510   0940 0A 48 09    	jmp ascii_continue
0511   0943             ascii:
0512   0943 23          	mov ah, al
0513   0944 19 00       	mov al, 0
0514   0946 05 03       	syscall sys_io
0515   0948             ascii_continue:
0516   0948 FD A9 2F 09 	loopb print_ascii_L
0517   094C 0A 16 09    	jmp back1
0518   094F             print_base:
0519   094F 07 2D 02    	call printnl
0520   0952 2D          	mov b, d
0521   0953 61 DF 26    	sub b, scrap_sector			; remove this later and fix address bases which display incorrectly
0522   0956 07 DC 02    	call print_u16x				; display row
0523   0959 10 00 3A    	mov a, $3A00
0524   095C 05 03       	syscall sys_io
0525   095E 10 00 20    	mov a, $2000
0526   0961 05 03       	syscall sys_io
0527   0963 0A 04 09    	jmp back
0528   0966             
0529   0966 0A 44 65 62 s_break1:	.db "\nDebugger entry point.\n"
0529   096A 75 67 67 65 
0529   096E 72 20 65 6E 
0529   0972 74 72 79 20 
0529   0976 70 6F 69 6E 
0529   097A 74 2E 0A 
0530   097D 30 2E 20 53 			.db "0. Show Registers\n"
0530   0981 68 6F 77 20 
0530   0985 52 65 67 69 
0530   0989 73 74 65 72 
0530   098D 73 0A 
0531   098F 31 2E 20 53 			.db "1. Show 512B RAM block\n"
0531   0993 68 6F 77 20 
0531   0997 35 31 32 42 
0531   099B 20 52 41 4D 
0531   099F 20 62 6C 6F 
0531   09A3 63 6B 0A 
0532   09A6 32 2E 20 43 			.db "2. Continue Execution", 0
0532   09AA 6F 6E 74 69 
0532   09AE 6E 75 65 20 
0532   09B2 45 78 65 63 
0532   09B6 75 74 69 6F 
0532   09BA 6E 00 
0533   09BC             
0534   09BC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535   09BC             ; DIVIDE BY ZERO EXCEPTION
0536   09BC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0537   09BC             trap_div_zero:
0538   09BC D7          	push a
0539   09BD DA          	push d
0540   09BE E1          	pushf
0541   09BF             		
0542   09BF 3B E9 16    	mov d, s_divzero
0543   09C2 07 80 02    	call puts
0544   09C5             	
0545   09C5 EE          	popf
0546   09C6 E7          	pop d
0547   09C7 E4          	pop a
0548   09C8             							; enable interrupts
0549   09C8 06          	sysret
0550   09C9             
0551   09C9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0552   09C9             ; UNDEFINED OPCODE EXCEPTION
0553   09C9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0554   09C9             undefined_opcode:
0555   09C9 06          	sysret
0556   09CA             
0557   09CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0558   09CA             ; RTC SERVICES INTERRUPT
0559   09CA             ; RTC I/O bank = FFA0 to FFAF
0560   09CA             ; FFA0 to FFA7 is scratch RAM
0561   09CA             ; control register at $FFA8 [ W | R | S | Cal4..Cal0 ]
0562   09CA             ; al = 0..6 -> get
0563   09CA             ; al = 7..D -> set
0564   09CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0565   09CA             rtc_services:
0566   09CA DB          	push al
0567   09CB DA          	push d
0568   09CC B9 06       	cmp al, 6
0569   09CE D1 E3 09    	jgu rtc_set
0570   09D1             rtc_get:
0571   09D1 6A A9       	add al, $A9			; generate RTC address to get to address A9 of clock
0572   09D3 22 FF       	mov ah, $FF		
0573   09D5 3C          	mov d, a				; get to FFA9 + offset
0574   09D6 F2 A8 FF 40 	mov byte[$FFA8], $40		; set R bit to 1
0575   09DA 1E          	mov al, [d]			; get data
0576   09DB F2 A8 FF 00 	mov byte[$FFA8], 0		; reset R bit
0577   09DF 23          	mov ah, al
0578   09E0 E7          	pop d
0579   09E1 E8          	pop al
0580   09E2 06          	sysret
0581   09E3             rtc_set:
0582   09E3 DD          	push bl
0583   09E4 99          	mov bl, ah		; set data asIDE
0584   09E5 6A A2       	add al, $A2		; generate RTC address to get to address A9 of clock
0585   09E7 22 FF       	mov ah, $FF		
0586   09E9 3C          	mov d, a		; get to FFA9 + offset
0587   09EA 1B          	mov al, bl		; get data back
0588   09EB F2 A8 FF 80 	mov byte[$FFA8], $80	; set W bit to 1
0589   09EF 3E          	mov [d], al		; set data
0590   09F0 F2 A8 FF 00 	mov byte[$FFA8], 0		; reset write bit
0591   09F4 EA          	pop bl
0592   09F5 E7          	pop d
0593   09F6 E8          	pop al
0594   09F7 06          	sysret
0595   09F8             
0596   09F8             datetime_serv_tbl:
0597   09F8 00 0A       	.dw print_date
0598   09FA 74 0A       	.dw set_date
0599   09FC             datetime_services:
0600   09FC FD 0A F8 09 	jmp [datetime_serv_tbl + al]			
0601   0A00             print_date:
0602   0A00 10 00 0D    	mov a, $0D00				; print carriage return char
0603   0A03 19 03       	mov al, 3
0604   0A05 05 01       	syscall sys_rtc				; get week
0605   0A07 1A          	mov al, ah
0606   0A08 22 00       	mov ah, 0
0607   0A0A FD 9D 02    	shl a, 2					
0608   0A0D 3B 73 17    	mov d, s_week
0609   0A10 59          	add d, a
0610   0A11 07 80 02    	call puts
0611   0A14 10 00 20    	mov a, $2000
0612   0A17 05 03       	syscall sys_io					; display ' '
0613   0A19             	
0614   0A19 19 04       	mov al, 4
0615   0A1B 05 01       	syscall sys_rtc					; get day
0616   0A1D 99          	mov bl, ah
0617   0A1E 07 20 03    	call print_u8x
0618   0A21 10 00 20    	mov a, $2000
0619   0A24 05 03       	syscall sys_io					; display ' '
0620   0A26             ; there is a problem with the month displaying
0621   0A26             ; the month is stored as BCD. so when retrieving the month, the value will be in binary
0622   0A26             ; even though it is to be understood as BCD.
0623   0A26             ; when retrieving the value and adding the string table address offset the value will go overboard!	
0624   0A26 19 05       	mov al, 05
0625   0A28 05 01       	syscall sys_rtc				; get month
0626   0A2A 1A          	mov al, ah
0627   0A2B 22 00       	mov ah, 0
0628   0A2D FD 9D 02    	shl a, 2					
0629   0A30 3B 3F 17    	mov d, s_months
0630   0A33 59          	add d, a
0631   0A34 07 80 02    	call puts
0632   0A37             	
0633   0A37 10 00 20    	mov a, $2000
0634   0A3A 05 03       	syscall sys_io			; display ' '
0635   0A3C             	
0636   0A3C 2E 20       	mov bl, $20
0637   0A3E 07 20 03    	call print_u8x			; print 20 for year prefix
0638   0A41 19 06       	mov al, 06
0639   0A43 05 01       	syscall sys_rtc					; get year
0640   0A45 99          	mov bl, ah
0641   0A46 07 20 03    	call print_u8x
0642   0A49             	
0643   0A49 10 00 20    	mov a, $2000	
0644   0A4C 05 03       	syscall sys_io			; display ' '
0645   0A4E             
0646   0A4E 19 02       	mov al, 2
0647   0A50 05 01       	syscall sys_rtc					; get hours
0648   0A52 99          	mov bl, ah
0649   0A53 07 20 03    	call print_u8x
0650   0A56 10 00 3A    	mov a, $3A00		
0651   0A59 05 03       	syscall sys_io				; display ':'
0652   0A5B             
0653   0A5B 19 01       	mov al, 01
0654   0A5D 05 01       	syscall sys_rtc					; get minutes
0655   0A5F 99          	mov bl, ah
0656   0A60 07 20 03    	call print_u8x
0657   0A63 10 00 3A    	mov a, $3A00	
0658   0A66 05 03       	syscall sys_io			; display ':'
0659   0A68             
0660   0A68 19 00       	mov al, 0
0661   0A6A 05 01       	syscall sys_rtc					; get seconds
0662   0A6C 99          	mov bl, ah
0663   0A6D 07 20 03    	call print_u8x
0664   0A70             	
0665   0A70 07 2D 02    	call printnl
0666   0A73 06          	sysret
0667   0A74             	
0668   0A74             set_date:
0669   0A74 3B 04 17    	mov d, s_set_year
0670   0A77 07 80 02    	call puts
0671   0A7A 07 67 03    	call scan_u8x				; read integer into A
0672   0A7D FD 9D 08    	shl a, 8				; only AL used, move to AH
0673   0A80 19 0D       	mov al, 0Dh				; set RTC year
0674   0A82 05 01       	syscall sys_rtc					; set RTC
0675   0A84             	
0676   0A84 3B 0B 17    	mov d, s_set_month
0677   0A87 07 80 02    	call puts
0678   0A8A 07 67 03    	call scan_u8x					; read integer into A
0679   0A8D FD 9D 08    	shl a, 8				; only AL used, move to AH
0680   0A90 19 0C       	mov al, 0Ch				; set RTC month
0681   0A92 05 01       	syscall sys_rtc					; set RTC
0682   0A94             
0683   0A94 3B 13 17    	mov d, s_set_day
0684   0A97 07 80 02    	call puts
0685   0A9A 07 67 03    	call scan_u8x					; read integer into A
0686   0A9D FD 9D 08    	shl a, 8				; only AL used, move to AH
0687   0AA0 19 0B       	mov al, 0Bh				; set RTC month
0688   0AA2 05 01       	syscall sys_rtc					; set RTC
0689   0AA4             
0690   0AA4 3B 19 17    	mov d, s_set_week
0691   0AA7 07 80 02    	call puts
0692   0AAA 07 67 03    	call scan_u8x					; read integer into A
0693   0AAD FD 9D 08    	shl a, 8				; only AL used, move to AH
0694   0AB0 19 0A       	mov al, 0Ah				; set RTC month
0695   0AB2 05 01       	syscall sys_rtc					; set RTC
0696   0AB4             
0697   0AB4 3B 23 17    	mov d, s_set_hours
0698   0AB7 07 80 02    	call puts
0699   0ABA 07 67 03    	call scan_u8x					; read integer into A
0700   0ABD FD 9D 08    	shl a, 8				; only AL used, move to AH
0701   0AC0 19 09       	mov al, 09h				; set RTC month
0702   0AC2 05 01       	syscall sys_rtc					; set RTC
0703   0AC4             
0704   0AC4 3B 2B 17    	mov d, s_set_minutes
0705   0AC7 07 80 02    	call puts
0706   0ACA 07 67 03    	call scan_u8x					; read integer into A
0707   0ACD FD 9D 08    	shl a, 8				; only AL used, move to AH
0708   0AD0 19 08       	mov al, 08h				; set RTC month
0709   0AD2 05 01       	syscall sys_rtc					; set RTC
0710   0AD4             
0711   0AD4 3B 35 17    	mov d, s_set_seconds
0712   0AD7 07 80 02    	call puts
0713   0ADA 07 67 03    	call scan_u8x					; read integer into A
0714   0ADD FD 9D 08    	shl a, 8					; only AL used, move to AH
0715   0AE0 19 07       	mov al, 07h				; set RTC month
0716   0AE2 05 01       	syscall sys_rtc					; set RTC
0717   0AE4 06          	sysret
0718   0AE5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0719   0AE5             ; IDE SERVICES INTERRUPT
0720   0AE5             ; al = option
0721   0AE5             ; 0 = IDE reset, 1 = IDE sleep, 2 = read sector, 3 = write sector
0722   0AE5             ; IDE read/write sector
0723   0AE5             ; 512 bytes
0724   0AE5             ; user buffer pointer in D
0725   0AE5             ; AH = number of sectors
0726   0AE5             ; CB = LBA bytes 3..0
0727   0AE5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0728   0AE5             IDE_serv_tbl:
0729   0AE5 F1 0A       	.dw IDE_reset
0730   0AE7 05 0B       	.dw IDE_sleep
0731   0AE9 14 0B       	.dw IDE_read_sect_wrapper
0732   0AEB 18 0B       	.dw IDE_write_sect_wrapper
0733   0AED             IDE_services_kernel:
0734   0AED FD 0A E5 0A 	jmp [IDE_serv_tbl + al]		
0735   0AF1             	
0736   0AF1             IDE_reset:			
0737   0AF1 F2 D7 FF 04 	mov byte[_IDE_R7], 4		; RESET IDE
0738   0AF5 07 9E 0B    	call IDE_wait				; wait for IDE ready			 			
0739   0AF8 F2 D6 FF E0 	mov byte[_IDE_R6], $E0		; LBA3= 0, MASTER, MODE= LBA				
0740   0AFC F2 D1 FF 01 	mov byte[_IDE_R1], 1		; 8-BIT TRANSFERS			
0741   0B00 F2 D7 FF EF 	mov byte[_IDE_R7], $EF		; SET FEATURE COMMAND
0742   0B04 06          	sysret
0743   0B05             IDE_sleep:
0744   0B05 07 9E 0B    	call IDE_wait					; wait for IDE ready			 			
0745   0B08 F2 D6 FF 40 	mov byte [_IDE_R6], %01000000	; lba[3:0](reserved), bit 6=1
0746   0B0C F2 D7 FF E6 	mov byte [_IDE_R7], $E6		; sleep command
0747   0B10 07 9E 0B    	call IDE_wait					; wait for IDE ready
0748   0B13 06          	sysret
0749   0B14             IDE_read_sect_wrapper:
0750   0B14 07 1C 0B    	call IDE_read_sect
0751   0B17 06          	sysret
0752   0B18             IDE_write_sect_wrapper:
0753   0B18 07 42 0B    	call IDE_write_sect
0754   0B1B 06          	sysret
0755   0B1C             IDE_read_sect:
0756   0B1C 1A          	mov al, ah
0757   0B1D 24          	mov ah, bl
0758   0B1E 42 D2 FF    	mov [_IDE_R2], a			; number of sectors (0..255)
0759   0B21 1C          	mov al, bh
0760   0B22 3D D4 FF    	mov [_IDE_R4], al
0761   0B25 12          	mov a, c
0762   0B26 3D D5 FF    	mov [_IDE_R5], al
0763   0B29 1A          	mov al, ah
0764   0B2A 87 0F       	and al, %00001111
0765   0B2C 8B E0       	or al, %11100000			; mode lba, master
0766   0B2E 3D D6 FF    	mov [_IDE_R6], al
0767   0B31             IDE_read_sect_wait:
0768   0B31 1D D7 FF    	mov al, [_IDE_R7]	
0769   0B34 87 80       	and al, $80				; BUSY FLAG
0770   0B36 C7 31 0B    	jnz IDE_read_sect_wait
0771   0B39 19 20       	mov al, $20
0772   0B3B 3D D7 FF    	mov [_IDE_R7], al			; read sector cmd
0773   0B3E 07 68 0B    	call IDE_read	
0774   0B41 09          	ret
0775   0B42             IDE_write_sect:
0776   0B42 1A          	mov al, ah
0777   0B43 24          	mov ah, bl
0778   0B44 42 D2 FF    	mov [_IDE_R2], a			; number of sectors (0..255)
0779   0B47 1C          	mov al, bh
0780   0B48 3D D4 FF    	mov [_IDE_R4], al
0781   0B4B 12          	mov a, c
0782   0B4C 3D D5 FF    	mov [_IDE_R5], al
0783   0B4F 1A          	mov al, ah
0784   0B50 87 0F       	and al, %00001111
0785   0B52 8B E0       	or al, %11100000			; mode lba, master
0786   0B54 3D D6 FF    	mov [_IDE_R6], al
0787   0B57             IDE_write_sect_wait:
0788   0B57 1D D7 FF    	mov al, [_IDE_R7]	
0789   0B5A 87 80       	and al, $80				; BUSY FLAG
0790   0B5C C7 57 0B    	jnz IDE_write_sect_wait
0791   0B5F 19 30       	mov al, $30
0792   0B61 3D D7 FF    	mov [_IDE_R7], al			; write sector cmd
0793   0B64 07 83 0B    	call IDE_write			
0794   0B67 09          	ret
0795   0B68             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0796   0B68             ; READ IDE DATA
0797   0B68             ; pointer in D
0798   0B68             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0799   0B68             IDE_read:
0800   0B68 DA          	push d
0801   0B69             IDE_read_loop:
0802   0B69 1D D7 FF    	mov al, [_IDE_R7]	
0803   0B6C 87 80       	and al, 80h				; BUSY FLAG
0804   0B6E C7 69 0B    	jnz IDE_read_loop			; wait loop
0805   0B71             	
0806   0B71 1D D7 FF    	mov al, [_IDE_R7]
0807   0B74 87 08       	and al, %00001000			; DRQ FLAG
0808   0B76 C6 81 0B    	jz IDE_read_end
0809   0B79 1D D0 FF    	mov al, [_IDE_R0]
0810   0B7C 3E          	mov [d], al
0811   0B7D 79          	inc d
0812   0B7E 0A 69 0B    	jmp IDE_read_loop
0813   0B81             IDE_read_end:
0814   0B81 E7          	pop d
0815   0B82 09          	ret
0816   0B83             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0817   0B83             ; WRITE IDE DATA
0818   0B83             ; data pointer in D
0819   0B83             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0820   0B83             IDE_write:
0821   0B83 DA          	push d
0822   0B84             IDE_write_loop:
0823   0B84 1D D7 FF    	mov al, [_IDE_R7]	
0824   0B87 87 80       	and al, 80h				; BUSY FLAG
0825   0B89 C7 84 0B    	jnz IDE_write_loop			; wait loop
0826   0B8C             	
0827   0B8C 1D D7 FF    	mov al, [_IDE_R7]
0828   0B8F 87 08       	and al, %00001000			; DRQ FLAG
0829   0B91 C6 9C 0B    	jz IDE_write_end
0830   0B94 1E          	mov al, [d]
0831   0B95 3D D0 FF    	mov [_IDE_R0], al
0832   0B98 79          	inc d 
0833   0B99 0A 84 0B    	jmp IDE_write_loop
0834   0B9C             IDE_write_end:
0835   0B9C E7          	pop d
0836   0B9D 09          	ret
0837   0B9E             
0838   0B9E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0839   0B9E             ; wait for IDE to be ready
0840   0B9E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0841   0B9E             IDE_wait:
0842   0B9E 1D D7 FF    	mov al, [_IDE_R7]	
0843   0BA1 87 80       	and al, 80h				; BUSY FLAG
0844   0BA3 C7 9E 0B    	jnz IDE_wait
0845   0BA6 09          	ret
0846   0BA7             
0847   0BA7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0848   0BA7             ; i/o interrupt
0849   0BA7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0850   0BA7             io_services_jmp:
0851   0BA7 CA 0B       	.dw io_putchar
0852   0BA9 D7 0B       	.dw io_getchar
0853   0BAB B1 0B       	.dw io_uart_init
0854   0BAD             
0855   0BAD             io_services:
0856   0BAD FD 0A A7 0B 	jmp [io_services_jmp + al]
0857   0BB1             io_uart_init:
0858   0BB1 F2 83 FF 83 	mov byte[_UART0_LCR], $83			; 8 data, 1 stop, no parity	, divisor latch = 1, UART address 3 = Line Control Register
0859   0BB5 F2 80 FF 03 	mov byte[_UART0_DLAB_0], 3			; baud = 38400, divisor latch low byte = 3
0860   0BB9 F2 81 FF 00 	mov byte[_UART0_DLAB_1], 0			; divisor latch high byte = 0			
0861   0BBD F2 83 FF 03 	mov byte[_UART0_LCR], 3			; UART address 3 = Line Control Register
0862   0BC1 F2 81 FF 01 	mov byte[_UART0_IER], 1			; enable interrupt: receive data available
0863   0BC5 F2 82 FF 00 	mov byte[_UART0_FCR], 0			; disable FIFO
0864   0BC9 06          	sysret
0865   0BCA             ; char in ah
0866   0BCA             io_putchar:
0867   0BCA             io_putchar_L0:
0868   0BCA 1D 85 FF    	mov al, [_UART0_LSR]			; read Line Status Register
0869   0BCD 93 20       	test al, $20					; isolate Transmitter Empty
0870   0BCF C6 CA 0B    	jz io_putchar_L0		
0871   0BD2 1A          	mov al, ah
0872   0BD3 3D 80 FF    	mov [_UART0_DATA], al			; write char to Transmitter Holding Register
0873   0BD6 06          	sysret
0874   0BD7             ; char in ah
0875   0BD7             ; al = sucess code
0876   0BD7             io_getchar:
0877   0BD7 D8          	push b
0878   0BD8 DA          	push d
0879   0BD9             io_getchar_L0:	
0880   0BD9 14 2A 16    	mov a, [fifo_pr]
0881   0BDC 29 28 16    	mov b, [fifo_pi]
0882   0BDF B0          	cmp a, b
0883   0BE0 C6 08 0C    	je io_getchar_fail
0884   0BE3             	
0885   0BE3 3C          	mov d, a
0886   0BE4 1E          	mov al, [d]
0887   0BE5 DB          	push al
0888   0BE6             	
0889   0BE6 14 2A 16    	mov a, [fifo_pr]
0890   0BE9 77          	inc a
0891   0BEA AF DF 26    	cmp a, fifo + FIFO_SIZE				; check if pointer reached the end of the fifo
0892   0BED C7 F3 0B    	jne io_getchar_cont
0893   0BF0 10 DF 1E    	mov a, fifo	
0894   0BF3             io_getchar_cont:	
0895   0BF3 42 2A 16    	mov [fifo_pr], a			; update fifo pointer
0896   0BF6             	
0897   0BF6 E9          	pop ah
0898   0BF7             ; here we just echo the char back to the console
0899   0BF7             io_getchar_echo_L0:
0900   0BF7 1D 85 FF    	mov al, [_UART0_LSR]			; read Line Status Register
0901   0BFA 93 20       	test al, $20					; isolate Transmitter Empty
0902   0BFC C6 F7 0B    	jz io_getchar_echo_L0
0903   0BFF 1A          	mov al, ah
0904   0C00 3D 80 FF    	mov [_UART0_DATA], al			; write char to Transmitter Holding Register
0905   0C03             
0906   0C03 19 01       	mov al, 1		; AL = 1 means a char successfully received
0907   0C05 E7          	pop d
0908   0C06 E5          	pop b
0909   0C07 06          	sysret
0910   0C08             io_getchar_fail:
0911   0C08 E7          	pop d
0912   0C09 E5          	pop b
0913   0C0A 19 00       	mov al, 0			; AL = 0 means no char received
0914   0C0C 06          	sysret
0915   0C0D             
0916   0C0D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0917   0C0D             ;; FILE SYSTEM DATA
0918   0C0D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0919   0C0D             ; infor for : IDE SERVICES INTERRUPT
0920   0C0D             ; IDE read/write 512-byte sector
0921   0C0D             ; al = option
0922   0C0D             ; user buffer pointer in D
0923   0C0D             ; AH = number of sectors
0924   0C0D             ; CB = LBA bytes 3..0	
0925   0C0D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0926   0C0D             ;; FILE SYSTEM DATA STRUCTURE
0927   0C0D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0928   0C0D             ; for a directory we have the header first, followed by metadata
0929   0C0D             ; header 1 sector (512 bytes)
0930   0C0D             ; metadata 1 sector (512 bytes)
0931   0C0D             ; HEADER ENTRIES:
0932   0C0D             ; filename (64)
0933   0C0D             ; parent dir LBA (2) -  to be used for faster backwards navigation...
0934   0C0D             ;
0935   0C0D             ; metadata entries:
0936   0C0D             ; filename (24)
0937   0C0D             ; attributes (1)	|_|_|file_type(3bits)|x|w|r| types: file, directory, character device
0938   0C0D             ; LBA (2)
0939   0C0D             ; size (2)
0940   0C0D             ; day (1)
0941   0C0D             ; month (1)
0942   0C0D             ; year (1)
0943   0C0D             ; packet size = 32 bytes
0944   0C0D             ;
0945   0C0D             ; first directory on disk is the root directory '/'
0946   0C0D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0947   0C0D             ;; FILE SYSTEM DISK FORMATTING
0948   0C0D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0949   0C0D             ; writes FST_TOTAL_SECTORS + FS_NBR_FILES disk sectors  with 0's
0950   0C0D             ; this is the file system table formating
0951   0C0D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0952   0C0D             file_system_jmptbl:
0953   0C0D 3D 0C       	.dw file_system_mkfs
0954   0C0F E8 0C       	.dw cmd_fs_space
0955   0C11 E9 0C       	.dw cmd_mkdir
0956   0C13 62 10       	.dw cmd_cd
0957   0C15 67 10       	.dw cmd_ls
0958   0C17 50 11       	.dw cmd_mktxt
0959   0C19 D1 11       	.dw cmd_mkbin
0960   0C1B 8E 12       	.dw cmd_pwd
0961   0C1D FC 12       	.dw cmd_cat
0962   0C1F 58 13       	.dw cmd_rmdir					; 9
0963   0C21 B4 13       	.dw cmd_rm
0964   0C23 00 00       	.dw 0
0965   0C25 00 00       	.dw 0
0966   0C27 00 00       	.dw 0							; 13
0967   0C29 6C 0C       	.dw fileio_chmod				; 14
0968   0C2B 1C 14       	.dw cmd_mv						; 15
0969   0C2D 65 0C       	.dw cd_goto_root				; 16
0970   0C2F 5E 10       	.dw get_current_dirID			; 17
0971   0C31 3A 0E       	.dw get_path_from_dirID			; 18
0972   0C33 A0 0E       	.dw get_dirID_from_path_user	; 19
0973   0C35 BA 0F       	.dw loadfile_from_path_user		; 20	
0974   0C37 2A 0F       	.dw file_exists_by_path_user	; 21
0975   0C39             file_system:
0976   0C39 FD 0A 0D 0C 	jmp [file_system_jmptbl + al]
0977   0C3D             
0978   0C3D             file_system_mkfs:	
0979   0C3D FD 4F DF 28 	mov di, transient_area
0980   0C41 19 00       	mov al, 0
0981   0C43 38 00 02    	mov c, 512
0982   0C46 FD F7       	rep stosb
0983   0C48 26 20 00    	mov b, FST_LBA_START
0984   0C4B 38 00 00    	mov c, 0				; reset LBA to 0
0985   0C4E             file_system_mkfs_L1:	
0986   0C4E 22 01       	mov ah, $01			; one sect
0987   0C50 3B DF 28    	mov d, transient_area
0988   0C53 07 42 0B    	call IDE_write_sect
0989   0C56 FD 77       	inc b
0990   0C58 C0 00 08    	cmp b, CF_CARD_LBA_SIZE
0991   0C5B C7 4E 0C    	jne file_system_mkfs_L1
0992   0C5E             file_system_mkfs_create_root:
0993   0C5E 10 20 00    	mov a, ROOT_dirID
0994   0C61 42 2C 16    	mov [current_dirID], a		; set current directory LBA to ROOT
0995   0C64 06          	sysret	
0996   0C65             	
0997   0C65             cd_goto_root:
0998   0C65 10 20 00    	mov a, ROOT_dirID
0999   0C68 42 2C 16    	mov [current_dirID], a		; set current directory LBA to ROOT
1000   0C6B 06          	sysret	
1001   0C6C             
1002   0C6C             ; filename in D (userspace data)
1003   0C6C             ; permission in BL
1004   0C6C             fileio_chmod:
1005   0C6C DD          	push bl
1006   0C6D FD 4E       	mov si, d
1007   0C6F FD 4F DF 1C 	mov di, temp_data
1008   0C73 38 80 00    	mov c, 128
1009   0C76 04          	load					; load filename from user-space
1010   0C77             		
1011   0C77 14 2C 16    	mov a, [current_dirID]
1012   0C7A 77          	inc a				; metadata sector
1013   0C7B 27          	mov b, a
1014   0C7C 38 00 00    	mov c, 0				; reset LBA to 0
1015   0C7F 22 01       	mov ah, $01			; disk read
1016   0C81 3B DF 28    	mov d, transient_area
1017   0C84 07 1C 0B    	call IDE_read_sect		; read directory
1018   0C87 FD 10       	cla
1019   0C89 42 24 16    	mov [index], a		; reset file counter
1020   0C8C             fileio_chmod_L1:
1021   0C8C FD 4E       	mov si, d
1022   0C8E FD 4F DF 1C 	mov di, temp_data
1023   0C92 07 93 00    	call strcmp
1024   0C95 C6 AC 0C    	je fileio_chmod_found_entry
1025   0C98             
1026   0C98 58 20 00    	add d, 32
1027   0C9B 14 24 16    	mov a, [index]
1028   0C9E 77          	inc a
1029   0C9F 42 24 16    	mov [index], a
1030   0CA2 AF 10 00    	cmp a, FST_FILES_PER_DIR
1031   0CA5 C7 8C 0C    	jne fileio_chmod_L1
1032   0CA8 EA          	pop bl
1033   0CA9 0A C5 0C    	jmp fileio_chmod_not_found
1034   0CAC             fileio_chmod_found_entry:	
1035   0CAC FD 79       	mov g, b					; save LBA
1036   0CAE EA          	pop bl						; retrieve saved permission value
1037   0CAF 1F 18 00    	mov al, [d + 24]			; read file permissions
1038   0CB2 87 F8       	and al, %11111000			; remove all permissions, keep other flags
1039   0CB4 8C          	or al, bl					; set new permissions
1040   0CB5 3F 18 00    	mov [d + 24], al			; write new permissions
1041   0CB8 38 00 00    	mov c, 0
1042   0CBB 3B DF 28    	mov d, transient_area
1043   0CBE 22 01       	mov ah, $01				; disk write 1 sect
1044   0CC0 FD 27       	mov b, g					; retrieve LBA
1045   0CC2 07 42 0B    	call IDE_write_sect		; write sector
1046   0CC5             fileio_chmod_not_found:
1047   0CC5 06          	sysret
1048   0CC6             
1049   0CC6             ;; bootloader installer
1050   0CC6             ;; kernel LBA address in A
1051   0CC6             cmd_boot_installer:
1052   0CC6 D7          	push a
1053   0CC7 26 00 00    	mov b, 0
1054   0CCA 38 00 00    	mov c, 0
1055   0CCD 22 01       	mov ah, $01				; 1 sector
1056   0CCF 3B DF 28    	mov d, transient_area
1057   0CD2 07 1C 0B    	call IDE_read_sect			; read sector
1058   0CD5             	
1059   0CD5 E4          	pop a
1060   0CD6 44 FE 01    	mov [d + 510], a		; update LBA address
1061   0CD9 26 00 00    	mov b, 0
1062   0CDC 38 00 00    	mov c, 0
1063   0CDF 22 01       	mov ah, $01				; 1 sector
1064   0CE1 3B DF 28    	mov d, transient_area
1065   0CE4 07 42 0B    	call IDE_write_sect		; write sector
1066   0CE7             	
1067   0CE7 06          	sysret
1068   0CE8             
1069   0CE8             cmd_fs_space:
1070   0CE8 06          	sysret
1071   0CE9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1072   0CE9             ;; CREATE NEW DIRECTORY
1073   0CE9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1074   0CE9             ; search list for NULL name entry. add new directory to list
1075   0CE9             cmd_mkdir:
1076   0CE9 FD 4E       	mov si, d
1077   0CEB FD 4F DF 1C 	mov di, temp_data
1078   0CEF 38 00 02    	mov c, 512
1079   0CF2 04          	load						; load data from user-space
1080   0CF3 26 22 00    	mov b, FST_LBA_START + 2 	; start at 2 because LBA  0 is ROOT (this would also cause issues 								
1081   0CF6             								; when checking for NULL name, since root has a NULL name)
1082   0CF6 38 00 00    	mov c, 0					; reset LBA to 0
1083   0CF9             cmd_mkdir_L1:	
1084   0CF9 22 01       	mov ah, $01			; disk read
1085   0CFB 3B DF 28    	mov d, transient_area
1086   0CFE 07 1C 0B    	call IDE_read_sect		; read sector
1087   0D01 BD 00       	cmp byte[d], 0			; check for NULL
1088   0D03 C6 0C 0D    	je cmd_mkdir_found_null
1089   0D06 55 02 00    	add b, FST_SECTORS_PER_DIR					; skip directory
1090   0D09 0A F9 0C    	jmp cmd_mkdir_L1
1091   0D0C             cmd_mkdir_found_null:
1092   0D0C             ;create header file by grabbing dir name from parameter
1093   0D0C D8          	push b				; save new directory's LBA
1094   0D0D 38 40 00    	mov c, 64
1095   0D10 FD 4D DF 1C 	mov si, temp_data
1096   0D14 FD 4F DF 28 	mov di, transient_area
1097   0D18 FD F5       	rep movsb					; copy dirname from temp_data to transient_area
1098   0D1A 14 2C 16    	mov a, [current_dirID]
1099   0D1D 42 1F 29    	mov [transient_area + 64], a		; store parent directory LBA
1100   0D20 19 00       	mov al, 0
1101   0D22 FD 4F DF 2A 	mov di, transient_area + 512
1102   0D26 38 00 02    	mov c, 512
1103   0D29 FD F7       	rep stosb					; clean buffer
1104   0D2B 38 00 00    	mov c, 0				; reset LBA(c) to 0
1105   0D2E             ; write directory entry sectors
1106   0D2E 3B DF 28    	mov d, transient_area
1107   0D31 22 02       	mov ah, $02			; disk write, 2 sectors
1108   0D33 07 42 0B    	call IDE_write_sect		; write sector
1109   0D36             ; now we need to add the new directory to the list, insIDE the current directory
1110   0D36 14 2C 16    	mov a, [current_dirID]
1111   0D39 53 01 00    	add a, 1
1112   0D3C 27          	mov b, a					; metadata sector
1113   0D3D 38 00 00    	mov c, 0
1114   0D40 FD 79       	mov g, b					; save LBA
1115   0D42 3B DF 28    	mov d, transient_area
1116   0D45 22 01       	mov ah, $01			; disk read
1117   0D47 07 1C 0B    	call IDE_read_sect		; read metadata sector
1118   0D4A             cmd_mkdir_L2:
1119   0D4A BD 00       	cmp byte[d], 0
1120   0D4C C6 55 0D    	je cmd_mkdir_found_null2
1121   0D4F 58 20 00    	add d, FST_ENTRY_SIZE
1122   0D52 0A 4A 0D    	jmp cmd_mkdir_L2					; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1123   0D55             cmd_mkdir_found_null2:
1124   0D55 FD 4D DF 1C 	mov si, temp_data
1125   0D59 FD 50       	mov di, d
1126   0D5B 07 A8 00    	call strcpy			; copy directory name
1127   0D5E 58 18 00    	add d, 24			; goto ATTRIBUTES
1128   0D61 19 0B       	mov al, %00001011		;directory, no execute, write, read
1129   0D63 3E          	mov [d], al			
1130   0D64 79          	inc d
1131   0D65 E5          	pop b
1132   0D66 D8          	push b				; push LBA back
1133   0D67 FD 43       	mov [d], b			; save LBA
1134   0D69             ; set file creation date	
1135   0D69 58 04 00    	add d, 4
1136   0D6C 19 04       	mov al, 4
1137   0D6E 05 01       	syscall sys_rtc
1138   0D70 1A          	mov al, ah
1139   0D71 3E          	mov [d], al			; set day
1140   0D72 79          	inc d
1141   0D73 19 05       	mov al, 5
1142   0D75 05 01       	syscall sys_rtc
1143   0D77 1A          	mov al, ah
1144   0D78 3E          	mov [d], al			; set month
1145   0D79 79          	inc d
1146   0D7A 19 06       	mov al, 6
1147   0D7C 05 01       	syscall sys_rtc
1148   0D7E 1A          	mov al, ah
1149   0D7F 3E          	mov [d], al			; set year
1150   0D80             ; write sector into disk for new directory entry
1151   0D80 FD 27       	mov b, g
1152   0D82 38 00 00    	mov c, 0
1153   0D85 3B DF 28    	mov d, transient_area
1154   0D88 22 01       	mov ah, $01			; disk write, 1 sector
1155   0D8A 07 42 0B    	call IDE_write_sect		; write sector
1156   0D8D             
1157   0D8D             ; after adding the new directory's information to its parent directory's list
1158   0D8D             ; we need to now enter the new directory, and to it add two new directories!
1159   0D8D             ; which directories do we need to add ? '..' and '.' are the directories needed.
1160   0D8D             ; importantly, note that these two new directories are only entries in the list
1161   0D8D             ; and do not have actual physical entries in the disk as real directories.
1162   0D8D             ; i.e. they only exist as list entries in the new directory created so that
1163   0D8D             ; the new directory can reference its parent and itself
1164   0D8D             ;
1165   0D8D             ; we need to add both '..' and '.'
1166   0D8D             ; this first section is for '..' and on the section below we do the same for '.'
1167   0D8D E4          	pop a						; retrieve the new directory's LBA	
1168   0D8E D7          	push a						; and save again
1169   0D8F 53 01 00    	add a, 1
1170   0D92 27          	mov b, a					; metadata sector
1171   0D93 38 00 00    	mov c, 0
1172   0D96 FD 79       	mov g, b					; save LBA
1173   0D98 3B DF 28    	mov d, transient_area
1174   0D9B 22 01       	mov ah, $01			; disk read
1175   0D9D 07 1C 0B    	call IDE_read_sect		; read metadata sector
1176   0DA0             cmd_mkdir_L3:
1177   0DA0 BD 00       	cmp byte[d], 0
1178   0DA2 C6 AB 0D    	je cmd_mkdir_found_null3
1179   0DA5 58 20 00    	add d, FST_ENTRY_SIZE
1180   0DA8 0A A0 0D    	jmp cmd_mkdir_L3	; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1181   0DAB             cmd_mkdir_found_null3:
1182   0DAB FD 4D 39 16 	mov si, s_parent_dir
1183   0DAF FD 50       	mov di, d
1184   0DB1 07 A8 00    	call strcpy			; copy directory name
1185   0DB4 58 18 00    	add d, 24			; goto ATTRIBUTES
1186   0DB7 19 0B       	mov al, %00001011		;directory, no execute, write, read, 
1187   0DB9 3E          	mov [d], al			
1188   0DBA 79          	inc d
1189   0DBB 29 2C 16    	mov b, [current_dirID]	; retrieve the parent directorys LBA
1190   0DBE FD 43       	mov [d], b			; save LBA
1191   0DC0             ; set file creation date	
1192   0DC0 58 04 00    	add d, 4
1193   0DC3 19 04       	mov al, 4
1194   0DC5 05 01       	syscall sys_rtc
1195   0DC7 1A          	mov al, ah
1196   0DC8 3E          	mov [d], al			; set day
1197   0DC9 79          	inc d
1198   0DCA 19 05       	mov al, 5
1199   0DCC 05 01       	syscall sys_rtc
1200   0DCE 1A          	mov al, ah
1201   0DCF 3E          	mov [d], al			; set month
1202   0DD0 79          	inc d
1203   0DD1 19 06       	mov al, 6
1204   0DD3 05 01       	syscall sys_rtc
1205   0DD5 1A          	mov al, ah
1206   0DD6 3E          	mov [d], al			; set year
1207   0DD7             ; write sector into disk for new directory entry
1208   0DD7 FD 27       	mov b, g
1209   0DD9 38 00 00    	mov c, 0
1210   0DDC 3B DF 28    	mov d, transient_area
1211   0DDF 22 01       	mov ah, $01			; disk write, 1 sector
1212   0DE1 07 42 0B    	call IDE_write_sect		; write sector
1213   0DE4             
1214   0DE4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1215   0DE4             ; like we did above for '..', we need to now add the '.' directory to the list.
1216   0DE4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1217   0DE4 E4          	pop a						; retrieve the new directory's LBA	
1218   0DE5 D7          	push a
1219   0DE6 53 01 00    	add a, 1
1220   0DE9 27          	mov b, a					; metadata sector
1221   0DEA 38 00 00    	mov c, 0
1222   0DED FD 79       	mov g, b					; save LBA
1223   0DEF 3B DF 28    	mov d, transient_area
1224   0DF2 22 01       	mov ah, $01				; disk read
1225   0DF4 07 1C 0B    	call IDE_read_sect				; read metadata sector
1226   0DF7             cmd_mkdir_L4:
1227   0DF7 BD 00       	cmp byte[d], 0
1228   0DF9 C6 02 0E    	je cmd_mkdir_found_null4
1229   0DFC 58 20 00    	add d, FST_ENTRY_SIZE
1230   0DFF 0A F7 0D    	jmp cmd_mkdir_L4	; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1231   0E02             cmd_mkdir_found_null4:
1232   0E02 FD 4D 3C 16 	mov si, s_current_dir
1233   0E06 FD 50       	mov di, d
1234   0E08 07 A8 00    	call strcpy			; copy directory name
1235   0E0B 58 18 00    	add d, 24			; goto ATTRIBUTES
1236   0E0E 19 0B       	mov al, %00001011		;directory, no execute, write, read, 
1237   0E10 3E          	mov [d], al			
1238   0E11 79          	inc d
1239   0E12 E5          	pop b				; new directory's LBA itself. for self-referential directory entry '.'
1240   0E13 FD 43       	mov [d], b			; save LBA
1241   0E15             ; set file creation date	
1242   0E15 58 04 00    	add d, 4
1243   0E18 19 04       	mov al, 4
1244   0E1A 05 01       	syscall sys_rtc
1245   0E1C 1A          	mov al, ah
1246   0E1D 3E          	mov [d], al			; set day
1247   0E1E 79          	inc d
1248   0E1F 19 05       	mov al, 5
1249   0E21 05 01       	syscall sys_rtc
1250   0E23 1A          	mov al, ah
1251   0E24 3E          	mov [d], al			; set month
1252   0E25 79          	inc d
1253   0E26 19 06       	mov al, 6
1254   0E28 05 01       	syscall sys_rtc
1255   0E2A 1A          	mov al, ah
1256   0E2B 3E          	mov [d], al			; set year
1257   0E2C             ; write sector into disk for new directory entry
1258   0E2C FD 27       	mov b, g
1259   0E2E 38 00 00    	mov c, 0
1260   0E31 3B DF 28    	mov d, transient_area
1261   0E34 22 01       	mov ah, $01			; disk write, 1 sector
1262   0E36 07 42 0B    	call IDE_write_sect		; write sector
1263   0E39             cmd_mkdir_end:
1264   0E39 06          	sysret
1265   0E3A             
1266   0E3A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1267   0E3A             ;; get path from a given directory dirID
1268   0E3A             ;; pseudo code:
1269   0E3A             ;	get_path_from_dirID(int dirID, char *D){
1270   0E3A             ;		if(dirID == 0){
1271   0E3A             ;			reverse path in D;
1272   0E3A             ;			return;
1273   0E3A             ;		}
1274   0E3A             ;		else{
1275   0E3A             ;			copy directory name to end of D;
1276   0E3A             ;			add '/' to end of D;
1277   0E3A             ;			parentID = get parent directory ID;
1278   0E3A             ;			get_path_from_dirID(parentID, D);
1279   0E3A             ;		}
1280   0E3A             ;	}
1281   0E3A             ;; A = dirID
1282   0E3A             ;; D = generated path string pointer
1283   0E3A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1284   0E3A             ;; sample path: /usr/bin
1285   0E3A             get_path_from_dirID:
1286   0E3A 3B DF 1A    	mov d, filename
1287   0E3D 19 00       	mov al, 0
1288   0E3F 3E          	mov [d], al				; initialize path string 
1289   0E40 14 2C 16    	mov a, [current_dirID]
1290   0E43 07 50 0E    	call get_path_from_dirID_E0
1291   0E46 3B DF 1A    	mov d, filename
1292   0E49 07 3C 00    	call strrev
1293   0E4C 07 80 02    	call puts
1294   0E4F 06          	sysret
1295   0E50             get_path_from_dirID_E0:
1296   0E50 07 6F 0E    	call get_dirname_from_dirID
1297   0E53 FD 4D 3E 16 	mov si, s_fslash
1298   0E57 FD 50       	mov di, d
1299   0E59 07 B6 00    	call strcat						; add '/' to end of path
1300   0E5C AF 20 00    	cmp a, ROOT_dirID				; check if we are at the root directory
1301   0E5F C6 6E 0E    	je get_path_from_dirID_root
1302   0E62 07 8C 0E    	call get_parentID_from_dirID	; use current ID (A) to find parentID (into A)
1303   0E65 AF 20 00    	cmp a, ROOT_dirID				; check if we are at the root directory
1304   0E68 C6 6E 0E    	je get_path_from_dirID_root
1305   0E6B 07 50 0E    	call get_path_from_dirID_E0		; recursively call itself
1306   0E6E             get_path_from_dirID_root:
1307   0E6E 09          	ret
1308   0E6F             
1309   0E6F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1310   0E6F             ;; inputs:
1311   0E6F             ;; A = directory ID
1312   0E6F             ;; outputs:
1313   0E6F             ;; D = pointer to directory name string
1314   0E6F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1315   0E6F             get_dirname_from_dirID:
1316   0E6F D7          	push a
1317   0E70 D8          	push b
1318   0E71 DA          	push d
1319   0E72 27          	mov b, a
1320   0E73 38 00 00    	mov c, 0				; reset LBA to 0
1321   0E76 22 01       	mov ah, $01			; disk read
1322   0E78 3B DF 26    	mov d, transient_area - 512
1323   0E7B 07 1C 0B    	call IDE_read_sect			; read directory
1324   0E7E 07 3C 00    	call strrev				; reverse dir name before copying
1325   0E81 FD 4E       	mov si, d
1326   0E83 E7          	pop d					; destination address = D value pushed at beginning
1327   0E84 FD 50       	mov di, d
1328   0E86 07 B6 00    	call strcat				; copy filename to D
1329   0E89 E5          	pop b
1330   0E8A E4          	pop a
1331   0E8B 09          	ret
1332   0E8C             
1333   0E8C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1334   0E8C             ;; inputs:
1335   0E8C             ;; A = directory ID
1336   0E8C             ;; outputs:
1337   0E8C             ;; A = parent directory ID
1338   0E8C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1339   0E8C             get_parentID_from_dirID:
1340   0E8C D8          	push b
1341   0E8D DA          	push d
1342   0E8E 27          	mov b, a
1343   0E8F 38 00 00    	mov c, 0				; reset LBA to 0
1344   0E92 22 01       	mov ah, $01			; disk read
1345   0E94 3B DF 26    	mov d, transient_area - 512
1346   0E97 07 1C 0B    	call IDE_read_sect			; read directory
1347   0E9A 16 40 00    	mov a, [d + 64]			; copy parent ID value to A
1348   0E9D E7          	pop d
1349   0E9E E5          	pop b
1350   0E9F 09          	ret
1351   0EA0             
1352   0EA0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1353   0EA0             ;; get dirID from a given path string
1354   0EA0             ;; inputs:
1355   0EA0             ;; D = path pointer 
1356   0EA0             ;; outputs:
1357   0EA0             ;; A = dirID
1358   0EA0             ;; if dir non existent, A = FFFF (fail code)
1359   0EA0             ;; /usr/local/bin		- absolute
1360   0EA0             ;; local/bin/games		- relative
1361   0EA0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1362   0EA0             get_dirID_from_path_user:
1363   0EA0 FD 4E       	mov si, d
1364   0EA2 FD 4F DF 1C 	mov di, temp_data
1365   0EA6 38 00 02    	mov c, 512
1366   0EA9 04          	load
1367   0EAA 07 AE 0E    	call get_dirID_from_path
1368   0EAD 06          	sysret
1369   0EAE             
1370   0EAE             get_dirID_from_path:
1371   0EAE 26 DF 1C    	mov b, temp_data
1372   0EB1 FD 42 7F 06 	mov [prog], b			; token pointer set to path string
1373   0EB5 07 E0 04    	call get_token
1374   0EB8 31 82 06    	mov bl, [tok]
1375   0EBB C1 01       	cmp bl, TOK_FSLASH
1376   0EBD C6 C9 0E    	je get_dirID_from_path_abs 
1377   0EC0 14 2C 16    	mov a, [current_dirID]
1378   0EC3 07 66 06    	call putback
1379   0EC6 0A CC 0E    	jmp get_dirID_from_path_E0
1380   0EC9             get_dirID_from_path_abs:
1381   0EC9 10 20 00    	mov a, ROOT_dirID
1382   0ECC             get_dirID_from_path_E0:
1383   0ECC 07 E0 04    	call get_token
1384   0ECF 31 81 06    	mov bl, [toktyp]
1385   0ED2 C1 00       	cmp bl, TOKTYP_IDENTIFIER
1386   0ED4 C7 25 0F    	jne get_dirID_from_path_end	; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1387   0ED7             
1388   0ED7 FD 4D 83 06 	mov si, tokstr
1389   0EDB FD 4F DF 1A 	mov di, filename
1390   0EDF 07 A8 00    	call strcpy				
1391   0EE2 77          	inc a					; metadata sector
1392   0EE3 27          	mov b, a
1393   0EE4 38 00 00    	mov c, 0				; reset LBA to 0
1394   0EE7 22 01       	mov ah, $01			; disk read
1395   0EE9 3B DF 28    	mov d, transient_area
1396   0EEC 07 1C 0B    	call IDE_read_sect		; read directory
1397   0EEF FD 10       	cla
1398   0EF1 42 24 16    	mov [index], a
1399   0EF4             get_dirID_from_path_L1:
1400   0EF4 FD 4E       	mov si, d
1401   0EF6 FD 4F DF 1A 	mov di, filename
1402   0EFA 07 93 00    	call strcmp
1403   0EFD C6 13 0F    	je get_dirID_from_path_name_equal	
1404   0F00 58 20 00    	add d, 32
1405   0F03 14 24 16    	mov a, [index]
1406   0F06 77          	inc a
1407   0F07 42 24 16    	mov [index], a
1408   0F0A AF 10 00    	cmp a, FST_FILES_PER_DIR
1409   0F0D C6 26 0F    	je get_dirID_from_path_fail
1410   0F10 0A F4 0E    	jmp get_dirID_from_path_L1
1411   0F13             get_dirID_from_path_name_equal:
1412   0F13 58 19 00    	add d, 25					; 
1413   0F16 15          	mov a, [d]					; set result register A = dirID
1414   0F17 07 E0 04    	call get_token
1415   0F1A 31 82 06    	mov bl, [tok]
1416   0F1D C1 01       	cmp bl, TOK_FSLASH			; check if there are more elements in the path
1417   0F1F C6 CC 0E    	je get_dirID_from_path_E0
1418   0F22 07 66 06    	call putback
1419   0F25             get_dirID_from_path_end:
1420   0F25 09          	ret
1421   0F26             get_dirID_from_path_fail:
1422   0F26 10 FF FF    	mov A, $FFFF
1423   0F29 09          	ret
1424   0F2A             
1425   0F2A             
1426   0F2A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1427   0F2A             ;; check if file exists by a given path string
1428   0F2A             ;; inputs:
1429   0F2A             ;; D = path pointer 
1430   0F2A             ;; OUTPUTS:
1431   0F2A             ;; A = success code, if file exists gives LBA, else, give 0
1432   0F2A             ;; /usr/local/bin/ed
1433   0F2A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1434   0F2A             file_exists_by_path_user:
1435   0F2A FD 4E       	mov si, d
1436   0F2C FD 4F DF 1C 	mov di, temp_data
1437   0F30 38 00 02    	mov c, 512
1438   0F33 04          	load
1439   0F34 07 38 0F    	call file_exists_by_path
1440   0F37 06          	sysret
1441   0F38             file_exists_by_path:
1442   0F38 26 DF 1C    	mov b, temp_data
1443   0F3B FD 42 7F 06 	mov [prog], b			; token pointer set to path string
1444   0F3F 07 E0 04    	call get_token
1445   0F42 31 82 06    	mov bl, [tok]
1446   0F45 C1 01       	cmp bl, TOK_FSLASH
1447   0F47 C6 53 0F    	je  file_exists_by_path_abs
1448   0F4A 14 2C 16    	mov a, [current_dirID]
1449   0F4D 07 66 06    	call putback
1450   0F50 0A 56 0F    	jmp file_exists_by_path_E0
1451   0F53             file_exists_by_path_abs:
1452   0F53 10 20 00    	mov a, ROOT_dirID
1453   0F56             file_exists_by_path_E0:
1454   0F56 07 E0 04    	call get_token
1455   0F59 31 81 06    	mov bl, [toktyp]
1456   0F5C C1 00       	cmp bl, TOKTYP_IDENTIFIER
1457   0F5E C7 B6 0F    	jne file_exists_by_path_end	; check if there are tokens after '/'
1458   0F61 FD 4D 83 06 	mov si, tokstr
1459   0F65 FD 4F DF 1A 	mov di, filename
1460   0F69 07 A8 00    	call strcpy				
1461   0F6C 77          	inc a					; metadata sector
1462   0F6D 27          	mov b, a
1463   0F6E 38 00 00    	mov c, 0				; reset LBA to 0
1464   0F71 22 01       	mov ah, $01			; disk read
1465   0F73 3B DF 28    	mov d, transient_area
1466   0F76 07 1C 0B    	call IDE_read_sect		; read directory
1467   0F79 FD 10       	cla
1468   0F7B 42 24 16    	mov [index], a
1469   0F7E             file_exists_by_path_L1:
1470   0F7E FD 4E       	mov si, d
1471   0F80 FD 4F DF 1A 	mov di, filename
1472   0F84 07 93 00    	call strcmp
1473   0F87 C6 9D 0F    	je 	file_exists_by_path_name_equal
1474   0F8A 58 20 00    	add d, 32
1475   0F8D 14 24 16    	mov a, [index]
1476   0F90 77          	inc a
1477   0F91 42 24 16    	mov [index], a
1478   0F94 AF 10 00    	cmp a, FST_FILES_PER_DIR
1479   0F97 C6 B6 0F    	je file_exists_by_path_end
1480   0F9A 0A 7E 0F    	jmp file_exists_by_path_L1
1481   0F9D             file_exists_by_path_name_equal:
1482   0F9D 33 18 00    	mov bl, [d + 24]
1483   0FA0 FD 87 38    	and bl, %00111000			; directory flag
1484   0FA3 C1 08       	cmp bl, %00001000			; is dir?
1485   0FA5 C6 AC 0F    	je file_exists_by_path_isdir;
1486   0FA8             ; entry is a file
1487   0FA8 16 19 00    	mov a, [d + 25]			; get and return LBA of file
1488   0FAB 09          	ret
1489   0FAC             file_exists_by_path_isdir:
1490   0FAC 58 19 00    	add d, 25					; 
1491   0FAF 15          	mov a, [d]					; set result register A = dirID
1492   0FB0 07 E0 04    	call get_token
1493   0FB3 0A 56 0F    	jmp file_exists_by_path_E0
1494   0FB6             file_exists_by_path_end:
1495   0FB6 10 00 00    	mov a, 0			; return 0 because file was not found
1496   0FB9 09          	ret
1497   0FBA             
1498   0FBA             
1499   0FBA             
1500   0FBA             
1501   0FBA             
1502   0FBA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1503   0FBA             ;; load file data from a given path string
1504   0FBA             ;; inputs:
1505   0FBA             ;; D = path pointer 
1506   0FBA             ;; DI = userspace program data destination
1507   0FBA             ;; /usr/local/bin/ed
1508   0FBA             ;; ./ed
1509   0FBA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1510   0FBA             loadfile_from_path_user:
1511   0FBA E3          	push di
1512   0FBB FD 4E       	mov si, d
1513   0FBD FD 4F DF 1C 	mov di, temp_data
1514   0FC1 38 00 02    	mov c, 512
1515   0FC4 04          	load
1516   0FC5 07 D2 0F    	call loadfile_from_path
1517   0FC8 F0          	pop di
1518   0FC9 FD 4D DF 28 	mov si, transient_area
1519   0FCD 38 00 3E    	mov c, 512 * (FS_SECTORS_PER_FILE-1)
1520   0FD0 03          	store
1521   0FD1 06          	sysret
1522   0FD2             loadfile_from_path:
1523   0FD2 26 DF 1C    	mov b, temp_data
1524   0FD5 FD 42 7F 06 	mov [prog], b			; token pointer set to path string
1525   0FD9 07 E0 04    	call get_token
1526   0FDC 31 82 06    	mov bl, [tok]
1527   0FDF C1 01       	cmp bl, TOK_FSLASH
1528   0FE1 C6 ED 0F    	je loadfile_from_path_abs 
1529   0FE4 14 2C 16    	mov a, [current_dirID]
1530   0FE7 07 66 06    	call putback
1531   0FEA 0A F0 0F    	jmp loadfile_from_path_E0
1532   0FED             loadfile_from_path_abs:
1533   0FED 10 20 00    	mov a, ROOT_dirID
1534   0FF0             loadfile_from_path_E0:
1535   0FF0 07 E0 04    	call get_token
1536   0FF3 31 81 06    	mov bl, [toktyp]
1537   0FF6 C1 00       	cmp bl, TOKTYP_IDENTIFIER
1538   0FF8 C7 5D 10    	jne loadfile_from_path_end	; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1539   0FFB FD 4D 83 06 	mov si, tokstr
1540   0FFF FD 4F DF 1A 	mov di, filename
1541   1003 07 A8 00    	call strcpy				
1542   1006 77          	inc a					; metadata sector
1543   1007 27          	mov b, a
1544   1008 38 00 00    	mov c, 0				; reset LBA to 0
1545   100B 22 01       	mov ah, $01			; disk read
1546   100D 3B DF 28    	mov d, transient_area
1547   1010 07 1C 0B    	call IDE_read_sect		; read directory
1548   1013 FD 10       	cla
1549   1015 42 24 16    	mov [index], a
1550   1018             loadfile_from_path_L1:
1551   1018 FD 4E       	mov si, d
1552   101A FD 4F DF 1A 	mov di, filename
1553   101E 07 93 00    	call strcmp
1554   1021 C6 37 10    	je loadfile_from_path_name_equal	
1555   1024 58 20 00    	add d, 32
1556   1027 14 24 16    	mov a, [index]
1557   102A 77          	inc a
1558   102B 42 24 16    	mov [index], a
1559   102E AF 10 00    	cmp a, FST_FILES_PER_DIR
1560   1031 C6 5D 10    	je loadfile_from_path_end
1561   1034 0A 18 10    	jmp loadfile_from_path_L1
1562   1037             loadfile_from_path_name_equal:
1563   1037 33 18 00    	mov bl, [d + 24]
1564   103A FD 87 38    	and bl, %00111000			; directory flag
1565   103D C1 08       	cmp bl, %00001000			; is dir?
1566   103F C6 53 10    	je loadfile_isdirectory	;
1567   1042             ; entry is a file
1568   1042 2B 19 00    	mov b, [d + 25]			; get LBA
1569   1045 FD 77       	inc b				; add 1 to B because the LBA for data comes after the header sector
1570   1047 3B DF 28    	mov d, transient_area
1571   104A 38 00 00    	mov c, 0
1572   104D 22 1F       	mov ah, FS_SECTORS_PER_FILE-1		; number of sectors
1573   104F 07 1C 0B    	call IDE_read_sect				; read sector
1574   1052 09          	ret
1575   1053             loadfile_isdirectory:
1576   1053 58 19 00    	add d, 25					; 
1577   1056 15          	mov a, [d]					; set result register A = dirID
1578   1057 07 E0 04    	call get_token
1579   105A 0A F0 0F    	jmp loadfile_from_path_E0
1580   105D             loadfile_from_path_end:
1581   105D 09          	ret
1582   105E             
1583   105E             
1584   105E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1585   105E             ;; return the ID of the current directory
1586   105E             ;; ID returned in B
1587   105E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1588   105E             get_current_dirID:
1589   105E 29 2C 16    	mov b, [current_dirID]
1590   1061 06          	sysret
1591   1062             
1592   1062             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1593   1062             ;; CD
1594   1062             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1595   1062             ; new dirID in B
1596   1062             cmd_cd:
1597   1062 FD 42 2C 16 	mov [current_dirID], b
1598   1066 06          	sysret	
1599   1067             
1600   1067             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1601   1067             ;; LS
1602   1067             ;; dirID in B
1603   1067             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1604   1067             cmd_ls:
1605   1067 FD 77       	inc b				; metadata sector
1606   1069 38 00 00    	mov c, 0				; reset LBA to 0
1607   106C 22 01       	mov ah, $01			; disk read
1608   106E 3B DF 28    	mov d, transient_area
1609   1071 07 1C 0B    	call IDE_read_sect		; read directory
1610   1074 FD 10       	cla
1611   1076 42 24 16    	mov [index], a		; reset entry index
1612   1079             cmd_ls_L1:
1613   1079 BD 00       	cmp byte [d], 0		; check for NULL
1614   107B C6 0B 11    	je cmd_ls_next
1615   107E             cmd_ls_non_null:
1616   107E 1F 18 00    	mov al, [d + 24]
1617   1081 87 38       	and al, %00111000
1618   1083 FD A2 03    	shr al, 3
1619   1086 22 00       	mov ah, 0					; file type
1620   1088 B7 49 16    	mov a, [a + file_type]			
1621   108B 23          	mov ah, al
1622   108C 07 46 01    	call putchar
1623   108F 1F 18 00    	mov al, [d + 24]
1624   1092 87 01       	and al, %00000001
1625   1094 22 00       	mov ah, 0
1626   1096 B7 44 16    	mov a, [a + file_attrib]		; read
1627   1099 23          	mov ah, al
1628   109A 07 46 01    	call putchar
1629   109D 1F 18 00    	mov al, [d + 24]
1630   10A0 87 02       	and al, %00000010
1631   10A2 22 00       	mov ah, 0
1632   10A4 B7 44 16    	mov a, [a + file_attrib]		; write
1633   10A7 23          	mov ah, al
1634   10A8 07 46 01    	call putchar
1635   10AB 1F 18 00    	mov al, [d + 24]
1636   10AE 87 04       	and al, %00000100
1637   10B0 22 00       	mov ah, 0
1638   10B2 B7 44 16    	mov a, [a + file_attrib]		; execute
1639   10B5 23          	mov ah, al
1640   10B6 07 46 01    	call putchar
1641   10B9 22 20       	mov ah, $20
1642   10BB 07 46 01    	call putchar	
1643   10BE 16 1B 00    	mov a, [d + 27]
1644   10C1 07 A9 02    	call print_u16d				; filesize
1645   10C4 22 20       	mov ah, $20
1646   10C6 07 46 01    	call putchar	
1647   10C9 16 19 00    	mov a, [d + 25]
1648   10CC 07 A9 02    	call print_u16d			; dirID / LBA
1649   10CF 22 20       	mov ah, $20
1650   10D1 07 46 01    	call putchar
1651   10D4             ; print date
1652   10D4 33 1D 00    	mov bl, [d + 29]			; day
1653   10D7 07 20 03    	call print_u8x
1654   10DA 22 20       	mov ah, $20
1655   10DC 07 46 01    	call putchar	
1656   10DF 1F 1E 00    	mov al, [d + 30]			; month
1657   10E2 FD 9E 02    	shl al, 2
1658   10E5 DA          	push d
1659   10E6 3B 3F 17    	mov d, s_months
1660   10E9 22 00       	mov ah, 0
1661   10EB 59          	add d, a
1662   10EC 07 80 02    	call puts
1663   10EF E7          	pop d
1664   10F0 22 20       	mov ah, $20
1665   10F2 07 46 01    	call putchar
1666   10F5 2E 20       	mov bl, $20
1667   10F7 07 20 03    	call print_u8x
1668   10FA 33 1F 00    	mov bl, [d + 31]			; year
1669   10FD 07 20 03    	call print_u8x	
1670   1100 22 20       	mov ah, $20
1671   1102 07 46 01    	call putchar	
1672   1105 07 80 02    	call puts				; print filename	
1673   1108 07 2D 02    	call printnl
1674   110B             cmd_ls_next:
1675   110B 14 24 16    	mov a, [index]
1676   110E 77          	inc a
1677   110F 42 24 16    	mov [index], a
1678   1112 AF 10 00    	cmp a, FST_FILES_PER_DIR
1679   1115 C6 1E 11    	je cmd_ls_end
1680   1118 58 20 00    	add d, 32			
1681   111B 0A 79 10    	jmp cmd_ls_L1	
1682   111E             cmd_ls_end:
1683   111E 06          	sysret
1684   111F             
1685   111F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1686   111F             ;; pad string to 32 chars
1687   111F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1688   111F             ; count in C
1689   111F             padding:
1690   111F D7          	push a
1691   1120 D8          	push b
1692   1121 10 20 00    	mov a, 32
1693   1124 28          	mov b, c
1694   1125 60          	sub a, b
1695   1126 39          	mov c, a
1696   1127             padding_L1:
1697   1127 22 20       	mov ah, $20
1698   1129 07 46 01    	call putchar
1699   112C 7E          	dec c
1700   112D C2 00 00    	cmp c, 0
1701   1130 C7 27 11    	jne padding_L1
1702   1133 E5          	pop b
1703   1134 E4          	pop a
1704   1135 09          	ret
1705   1136             
1706   1136             
1707   1136             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1708   1136             ;; finds an empty data block
1709   1136             ;; block LBA returned in B
1710   1136             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1711   1136             fs_find_empty_block:
1712   1136 26 A0 00    	mov b, FS_LBA_START		; raw files starting block
1713   1139 38 00 00    	mov c, 0						; reset LBA to 0
1714   113C             fs_find_empty_block_L1:	
1715   113C 22 01       	mov ah, $01			; disk read
1716   113E 3B DF 26    	mov d, transient_area - 512
1717   1141 07 1C 0B    	call IDE_read_sect		; read sector
1718   1144 BD 00       	cmp byte [d], 0
1719   1146 C6 4F 11    	je fs_find_empty_block_found_null
1720   1149 55 20 00    	add b, FS_SECTORS_PER_FILE
1721   114C 0A 3C 11    	jmp fs_find_empty_block_L1
1722   114F             fs_find_empty_block_found_null:
1723   114F 09          	ret
1724   1150             
1725   1150             ; file structure:
1726   1150             ; 512 bytes header
1727   1150             ; header used to tell whether the block is free
1728   1150             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1729   1150             ;; CREATE NEW TEXTFILE
1730   1150             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1731   1150             cmd_mktxt:
1732   1150 FD 4E       	mov si, d
1733   1152 FD 4F DF 28 	mov di, transient_area
1734   1156 38 00 40    	mov c, FS_SECTORS_PER_FILE * 512
1735   1159 04          	load					; load data from user-space
1736   115A 07 36 11    	call fs_find_empty_block	; look for empty data blocks
1737   115D D8          	push b				; save empty block LBA
1738   115E             ;create header file by grabbing file name from parameter	
1739   115E 3B DF 2A    	mov d, transient_area + 512			; pointer to file contents
1740   1161             	;call gettxt
1741   1161 07 83 00    	call strlen						; get length of the text file
1742   1164 D9          	push c							; save length
1743   1165 19 01       	mov al, 1
1744   1167 3D DF 28    	mov [transient_area], al					; mark sectors as USED (not NULL)
1745   116A 3B DF 28    	mov d, transient_area
1746   116D             cmd_mktxt_L2:
1747   116D 38 00 00    	mov c, 0
1748   1170 22 20       	mov ah, FS_SECTORS_PER_FILE		; number of sectors to write
1749   1172 07 42 0B    	call IDE_write_sect			; write sectors
1750   1175             ; now we add the file to the current directory!
1751   1175             cmd_mktxt_add_to_dir:	
1752   1175 14 2C 16    	mov a, [current_dirID]
1753   1178 77          	inc a
1754   1179 27          	mov b, a					; metadata sector
1755   117A 38 00 00    	mov c, 0
1756   117D FD 79       	mov g, b					; save LBA
1757   117F 3B DF 26    	mov d, transient_area - 512
1758   1182 22 01       	mov ah, $01			; disk read
1759   1184 07 1C 0B    	call IDE_read_sect		; read metadata sector
1760   1187             cmd_mktxt_add_to_dir_L2:
1761   1187 BD 00       	cmp byte[d], 0
1762   1189 C6 92 11    	je cmd_mktxt_add_to_dir_null
1763   118C 58 20 00    	add d, FST_ENTRY_SIZE
1764   118F 0A 87 11    	jmp cmd_mktxt_add_to_dir_L2		; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1765   1192             cmd_mktxt_add_to_dir_null:
1766   1192 FD 4D E0 28 	mov si, transient_area + 1		; filename located after the data block 'USED' marker byte
1767   1196 FD 50       	mov di, d
1768   1198 07 A8 00    	call strcpy			; copy file name
1769   119B 58 18 00    	add d, 24			; skip name
1770   119E 19 03       	mov al, %00000011	; type=file, no execute, write, read
1771   11A0 3E          	mov [d], al			
1772   11A1 58 03 00    	add d, 3
1773   11A4 E4          	pop a
1774   11A5 43          	mov [d], a
1775   11A6 63 02 00    	sub d, 2
1776   11A9 E5          	pop b				; get file LBA
1777   11AA FD 43       	mov [d], b			; save LBA	
1778   11AC             	
1779   11AC             	; set file creation date	
1780   11AC 58 04 00    	add d, 4
1781   11AF 19 04       	mov al, 4
1782   11B1 05 01       	syscall sys_rtc
1783   11B3 1A          	mov al, ah
1784   11B4 3E          	mov [d], al			; set day
1785   11B5             	
1786   11B5 79          	inc d
1787   11B6 19 05       	mov al, 5
1788   11B8 05 01       	syscall sys_rtc
1789   11BA 1A          	mov al, ah
1790   11BB 3E          	mov [d], al			; set month
1791   11BC             	
1792   11BC 79          	inc d
1793   11BD 19 06       	mov al, 6
1794   11BF 05 01       	syscall sys_rtc
1795   11C1 1A          	mov al, ah
1796   11C2 3E          	mov [d], al			; set year
1797   11C3             	
1798   11C3             ; write sector into disk for new directory entry
1799   11C3 FD 27       	mov b, g
1800   11C5 38 00 00    	mov c, 0
1801   11C8 3B DF 26    	mov d, transient_area - 512
1802   11CB 22 01       	mov ah, $01			; disk write, 1 sector
1803   11CD 07 42 0B    	call IDE_write_sect		; write sector
1804   11D0 06          	sysret
1805   11D1             
1806   11D1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1807   11D1             ;; CREATE NEW BINARY FILE
1808   11D1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1809   11D1             ; search for first null block
1810   11D1             cmd_mkbin:
1811   11D1 FD 4E       	mov si, d
1812   11D3 FD 4F DF 1C 	mov di, temp_data
1813   11D7 38 00 02    	mov c, 512
1814   11DA 04          	load					; load data from user-space
1815   11DB             	
1816   11DB 26 A0 00    	mov b, FS_LBA_START		; files start when directories end
1817   11DE 38 00 00    	mov c, 0				; reset LBA to 0
1818   11E1             cmd_mkbin_L1:	
1819   11E1 22 01       	mov ah, $01			; disk read
1820   11E3 3B DF 28    	mov d, transient_area
1821   11E6 07 1C 0B    	call IDE_read_sect		; read sector
1822   11E9 BD 00       	cmp byte[d], 0			; check for NULL
1823   11EB C6 F4 11    	je cmd_mkbin_found_null
1824   11EE 55 20 00    	add b, FS_SECTORS_PER_FILE
1825   11F1 0A E1 11    	jmp cmd_mkbin_L1
1826   11F4             cmd_mkbin_found_null:
1827   11F4 D8          	push b				; save LBA
1828   11F5             ;create header file by grabbing file name from parameter
1829   11F5 FD 4F DF 2A 	mov di, transient_area + 512	; pointer to file contents
1830   11F9 07 F1 15    	call _load_hex			; load binary hex
1831   11FC D9          	push c					; save size (nbr of bytes)
1832   11FD 19 01       	mov al, 1
1833   11FF 3D DF 28    	mov [transient_area], al		; mark sectors as USED (not NULL)
1834   1202 FD 10       	cla
1835   1204 42 24 16    	mov [index], a
1836   1207 3B DF 28    	mov d, transient_area
1837   120A 13          	mov a, d
1838   120B 42 26 16    	mov [buffer_addr], a
1839   120E             cmd_mkbin_L2:
1840   120E 38 00 00    	mov c, 0
1841   1211 22 01       	mov ah, $01				; disk write, 1 sector
1842   1213 07 42 0B    	call IDE_write_sect			; write sector
1843   1216 14 24 16    	mov a, [index]
1844   1219 77          	inc a
1845   121A 42 24 16    	mov [index], a
1846   121D AF 20 00    	cmp a, FS_SECTORS_PER_FILE		; remove 1 from this because we dont count the header sector
1847   1220 C6 32 12    	je cmd_mkbin_add_to_dir
1848   1223 FD 77       	inc b
1849   1225 14 26 16    	mov a, [buffer_addr]
1850   1228 53 00 02    	add a, 512
1851   122B 42 26 16    	mov [buffer_addr], a
1852   122E 3C          	mov d, a
1853   122F 0A 0E 12    	jmp cmd_mkbin_L2
1854   1232             ; now we add the file to the current directory!
1855   1232             cmd_mkbin_add_to_dir:	
1856   1232 14 2C 16    	mov a, [current_dirID]
1857   1235 77          	inc a
1858   1236 27          	mov b, a					; metadata sector
1859   1237 38 00 00    	mov c, 0
1860   123A FD 79       	mov g, b					; save LBA
1861   123C 3B DF 28    	mov d, transient_area
1862   123F 22 01       	mov ah, $01			; disk read
1863   1241 07 1C 0B    	call IDE_read_sect		; read metadata sector
1864   1244             cmd_mkbin_add_to_dir_L2:
1865   1244 BD 00       	cmp byte[d], 0
1866   1246 C6 4F 12    	je cmd_mkbin_add_to_dir_null
1867   1249 58 20 00    	add d, FST_ENTRY_SIZE
1868   124C 0A 44 12    	jmp cmd_mkbin_add_to_dir_L2		; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1869   124F             cmd_mkbin_add_to_dir_null:
1870   124F FD 4D DF 1C 	mov si, temp_data
1871   1253 FD 50       	mov di, d
1872   1255 07 A8 00    	call strcpy			; copy file name
1873   1258 58 18 00    	add d, 24			; skip name
1874   125B 19 07       	mov al, %00000111		;type=file, execute, write, read, 
1875   125D 3E          	mov [d], al
1876   125E 58 03 00    	add d, 3
1877   1261 E4          	pop a
1878   1262 43          	mov [d], a
1879   1263 63 02 00    	sub d, 2
1880   1266 E5          	pop b				; get file LBA
1881   1267 FD 43       	mov [d], b			; save LBA
1882   1269             	
1883   1269             	; set file creation date	
1884   1269 58 04 00    	add d, 4
1885   126C 19 04       	mov al, 4
1886   126E 05 01       	syscall sys_rtc
1887   1270 1A          	mov al, ah
1888   1271 3E          	mov [d], al			; set day
1889   1272             	
1890   1272 79          	inc d
1891   1273 19 05       	mov al, 5
1892   1275 05 01       	syscall sys_rtc
1893   1277 1A          	mov al, ah
1894   1278 3E          	mov [d], al			; set month
1895   1279             	
1896   1279 79          	inc d
1897   127A 19 06       	mov al, 6
1898   127C 05 01       	syscall sys_rtc
1899   127E 1A          	mov al, ah
1900   127F 3E          	mov [d], al			; set year
1901   1280             	
1902   1280             ; write sector into disk for new directory entry
1903   1280 FD 27       	mov b, g
1904   1282 38 00 00    	mov c, 0
1905   1285 3B DF 28    	mov d, transient_area
1906   1288 22 01       	mov ah, $01			; disk write, 1 sector
1907   128A 07 42 0B    	call IDE_write_sect		; write sector
1908   128D 06          	sysret
1909   128E             
1910   128E             			
1911   128E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1912   128E             ;; PWD - PRINT WORKING DIRECTORY
1913   128E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		
1914   128E             cmd_pwd:
1915   128E 3B DF 1A    	mov d, filename
1916   1291 19 00       	mov al, 0
1917   1293 3E          	mov [d], al				; initialize path string 
1918   1294 14 2C 16    	mov a, [current_dirID]
1919   1297 07 50 0E    	call get_path_from_dirID_E0
1920   129A 3B DF 1A    	mov d, filename
1921   129D 07 3C 00    	call strrev
1922   12A0 07 80 02    	call puts
1923   12A3 07 2D 02    	call printnl
1924   12A6 06          	sysret
1925   12A7             
1926   12A7             
1927   12A7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1928   12A7             ;; get current directory LBA
1929   12A7             ;; A: returned LBA
1930   12A7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:
1931   12A7             cmd_get_curr_dir_LBA:
1932   12A7 14 2C 16    	mov a, [current_dirID]
1933   12AA 06          	sysret
1934   12AB             
1935   12AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1936   12AB             ;; LOAD FILE INTO MEM
1937   12AB             ;; file loaded to transient_area
1938   12AB             ;; D: filename pointer
1939   12AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:
1940   12AB             cmd_loadfile_user:
1941   12AB FD 4E       	mov si, d
1942   12AD FD 4F DF 1A 	mov di, filename
1943   12B1 38 00 01    	mov c, 256
1944   12B4 04          	load
1945   12B5 07 B9 12    	call cmd_loadfile
1946   12B8 06          	sysret
1947   12B9             
1948   12B9             cmd_loadfile:
1949   12B9 14 2C 16    	mov a, [current_dirID]
1950   12BC 77          	inc a				; metadata sector
1951   12BD 27          	mov b, a
1952   12BE 38 00 00    	mov c, 0				; reset LBA to 0
1953   12C1 22 01       	mov ah, $01			; disk read
1954   12C3 3B DF 26    	mov d, transient_area-512
1955   12C6 07 1C 0B    	call IDE_read_sect		; read directory
1956   12C9 FD 10       	cla
1957   12CB 42 24 16    	mov [index], a		; reset file counter
1958   12CE             cmd_loadfile_L1:
1959   12CE FD 4E       	mov si, d
1960   12D0 FD 4F DF 1A 	mov di, filename
1961   12D4 07 93 00    	call strcmp
1962   12D7 C6 ED 12    	je cmd_loadfile_found_entry
1963   12DA 58 20 00    	add d, 32
1964   12DD 14 24 16    	mov a, [index]
1965   12E0 77          	inc a
1966   12E1 42 24 16    	mov [index], a
1967   12E4 AF 10 00    	cmp a, FST_FILES_PER_DIR
1968   12E7 C6 FB 12    	je cmd_loadfile_not_found
1969   12EA 0A CE 12    	jmp cmd_loadfile_L1
1970   12ED             cmd_loadfile_found_entry:
1971   12ED 58 19 00    	add d, 25			; get to dirID of file in disk
1972   12F0 2A          	mov b, [d]			; get LBA
1973   12F1 FD 77       	inc b				; add 1 to B because the LBA for data comes after the header sector
1974   12F3 3B DF 28    	mov d, transient_area
1975   12F6 22 1F       	mov ah, FS_SECTORS_PER_FILE-1		; number of sectors
1976   12F8 07 1C 0B    	call IDE_read_sect				; read sector
1977   12FB             cmd_loadfile_not_found:
1978   12FB 09          	ret
1979   12FC             
1980   12FC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1981   12FC             ;; CAT
1982   12FC             ;; userspace destination data pointer in D
1983   12FC             ;; filename starts at D, but is overwritten after the read is made
1984   12FC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:
1985   12FC             cmd_cat:
1986   12FC DA          	push d					; save userspace file data destination
1987   12FD FD 4E       	mov si, d
1988   12FF FD 4F DF 1C 	mov di, temp_data
1989   1303 38 00 02    	mov c, 512
1990   1306 04          	load					; copy filename from user-space
1991   1307 29 2C 16    	mov b, [current_dirID]
1992   130A FD 77       	inc b				; metadata sector
1993   130C 38 00 00    	mov c, 0				; reset LBA to 0
1994   130F 22 01       	mov ah, $01			; disk read
1995   1311 3B DF 26    	mov d, transient_area-512
1996   1314 07 1C 0B    	call IDE_read_sect		; read directory
1997   1317 FD 10       	cla
1998   1319 42 24 16    	mov [index], a		; reset file counter
1999   131C             cmd_cat_L1:
2000   131C FD 4E       	mov si, d
2001   131E FD 4F DF 1C 	mov di, temp_data
2002   1322 07 93 00    	call strcmp
2003   1325 C6 3B 13    	je cmd_cat_found_entry
2004   1328 58 20 00    	add d, 32
2005   132B 14 24 16    	mov a, [index]
2006   132E 77          	inc a
2007   132F 42 24 16    	mov [index], a
2008   1332 AF 10 00    	cmp a, FST_FILES_PER_DIR
2009   1335 C6 56 13    	je cmd_cat_not_found
2010   1338 0A 1C 13    	jmp cmd_cat_L1
2011   133B             cmd_cat_found_entry:
2012   133B 58 19 00    	add d, 25			; get to dirID of file in disk
2013   133E 2A          	mov b, [d]			; get LBA
2014   133F FD 77       	inc b				; add 1 to B because the LBA for data comes after the header sector 
2015   1341 3B DF 28    	mov d, transient_area	
2016   1344 38 00 00    	mov c, 0
2017   1347 22 1F       	mov ah, FS_SECTORS_PER_FILE-1	; nbr sectors
2018   1349 07 1C 0B    	call IDE_read_sect		; read sectors
2019   134C F0          	pop di						; write userspace file data destination to DI
2020   134D FD 4D DF 28 	mov si, transient_area		; data origin
2021   1351 38 00 3E    	mov c, 512*(FS_SECTORS_PER_FILE-1)
2022   1354 03          	store
2023   1355 06          	sysret
2024   1356             cmd_cat_not_found:
2025   1356 E7          	pop d
2026   1357 06          	sysret
2027   1358             
2028   1358             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2029   1358             ;; RMDIR - remove DIR by dirID
2030   1358             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2031   1358             ; deletes a directory entry in the given directory's file list 
2032   1358             ; also deletes the actual directory entry in the FST
2033   1358             ; synopsis: rmdir /usr/local/testdir
2034   1358             ; B = dirID
2035   1358             cmd_rmdir:
2036   1358 FD 79       	mov g, b
2037   135A 11          	mov a, b
2038   135B 07 8C 0E    	call get_parentID_from_dirID	; now get the directory's parent, in A
2039   135E D7          	push a						; save dirID
2040   135F             ; search for directory's entry in the parent's directory then and delete it
2041   135F 77          	inc a						; metadata sector
2042   1360 27          	mov b, a
2043   1361 38 00 00    	mov c, 0					; reset LBA to 0
2044   1364 22 01       	mov ah, $01					;
2045   1366 3B DF 28    	mov d, transient_area
2046   1369 07 1C 0B    	call IDE_read_sect			; read directory
2047   136C FD 10       	cla
2048   136E 42 24 16    	mov [index], a				; reset file counter
2049   1371 FD 27       	mov b, g					; retrieve directory's dirID
2050   1373             cmd_rmdir_L1:
2051   1373 16 19 00    	mov a, [d + 25]				; get entry's dirID/LBA value
2052   1376 B0          	cmp a, b					; compare dirID's to find the directory
2053   1377 C6 8D 13    	je cmd_rmdir_found_entry
2054   137A 58 20 00    	add d, 32
2055   137D 14 24 16    	mov a, [index]
2056   1380 77          	inc a
2057   1381 42 24 16    	mov [index], a
2058   1384 AF 10 00    	cmp a, FST_FILES_PER_DIR
2059   1387 C6 B2 13    	je cmd_rmdir_not_found
2060   138A 0A 73 13    	jmp cmd_rmdir_L1
2061   138D             cmd_rmdir_found_entry:
2062   138D FD 10       	cla
2063   138F 3E          	mov [d], al					; make filename NULL
2064   1390 44 19 00    	mov [d + 25], a				; clear dirID/LBA as well not to generate problems with previously deleted directories
2065   1393 E5          	pop b
2066   1394 FD 77       	inc b						; metadata sector
2067   1396 38 00 00    	mov c, 0					; reset LBA to 0
2068   1399 22 01       	mov ah, $01					; 
2069   139B 3B DF 28    	mov d, transient_area
2070   139E 07 42 0B    	call IDE_write_sect			; write sector and erase file's entry in the current DIR
2071   13A1             
2072   13A1 FD 27       	mov b, g
2073   13A3 3B DF 28    	mov d, transient_area	
2074   13A6 FD 10       	cla
2075   13A8 3E          	mov [d], al					; make directory's name header NULL for re-use
2076   13A9 38 00 00    	mov c, 0
2077   13AC 22 01       	mov ah, $01					; disk write 1 sect
2078   13AE 07 42 0B    	call IDE_write_sect			; delete directory given by dirID in B
2079   13B1 06          	sysret
2080   13B2             cmd_rmdir_not_found:
2081   13B2 E5          	pop b
2082   13B3 06          	sysret
2083   13B4             
2084   13B4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2085   13B4             ;; RM - remove file
2086   13B4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2087   13B4             ; frees up the data sectors for the file further down the disk
2088   13B4             ; deletes file entry in the directory's file list 
2089   13B4             cmd_rm:
2090   13B4 FD 4E       	mov si, d
2091   13B6 FD 4F DF 1C 	mov di, temp_data
2092   13BA 38 00 02    	mov c, 512
2093   13BD 04          	load					; load data from user-space
2094   13BE 14 2C 16    	mov a, [current_dirID]
2095   13C1 77          	inc a				; metadata sector
2096   13C2 27          	mov b, a
2097   13C3 38 00 00    	mov c, 0				; reset LBA to 0
2098   13C6 22 01       	mov ah, $01			; disk read
2099   13C8 3B DF 28    	mov d, transient_area
2100   13CB 07 1C 0B    	call IDE_read_sect		; read directory
2101   13CE 10 00 00    	mov a, 0
2102   13D1 42 24 16    	mov [index], a		; reset file counter
2103   13D4             cmd_rm_L1:
2104   13D4 FD 4E       	mov si, d
2105   13D6 FD 4F DF 1C 	mov di, temp_data
2106   13DA 07 93 00    	call strcmp
2107   13DD C6 F3 13    	je cmd_rm_found_entry
2108   13E0 58 20 00    	add d, 32
2109   13E3 14 24 16    	mov a, [index]
2110   13E6 77          	inc a
2111   13E7 42 24 16    	mov [index], a
2112   13EA AF 10 00    	cmp a, FST_FILES_PER_DIR
2113   13ED C6 1B 14    	je cmd_rm_not_found
2114   13F0 0A D4 13    	jmp cmd_rm_L1
2115   13F3             cmd_rm_found_entry:
2116   13F3 2B 19 00    	mov b, [d + 25]			; get LBA
2117   13F6 FD 79       	mov g, b				; save LBA
2118   13F8 19 00       	mov al, 0
2119   13FA 3E          	mov [d], al			; make file entry NULL
2120   13FB 14 2C 16    	mov a, [current_dirID]
2121   13FE 77          	inc a				; metadata sector
2122   13FF 27          	mov b, a
2123   1400 38 00 00    	mov c, 0				; reset LBA to 0
2124   1403 22 01       	mov ah, $01			; disk write
2125   1405 3B DF 28    	mov d, transient_area
2126   1408 07 42 0B    	call IDE_write_sect		; write sector and erase file's entry in the current DIR
2127   140B 3B DF 28    	mov d, transient_area	
2128   140E 19 00       	mov al, 0
2129   1410 3E          	mov [d], al			; make file's data header NULL for re-use
2130   1411 38 00 00    	mov c, 0
2131   1414 FD 27       	mov b, g				; get data header LBA
2132   1416 22 01       	mov ah, $01					; disk write 1 sect
2133   1418 07 42 0B    	call IDE_write_sect				; write sector
2134   141B             cmd_rm_not_found:	
2135   141B 06          	sysret	
2136   141C             
2137   141C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2138   141C             ;; mv - move / change file name
2139   141C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2140   141C             cmd_mv:
2141   141C FD 4E       	mov si, d
2142   141E FD 4F DF 1C 	mov di, temp_data
2143   1422 38 00 02    	mov c, 512
2144   1425 04          	load						; load data from user-space
2145   1426 14 2C 16    	mov a, [current_dirID]
2146   1429 77          	inc a						; metadata sector
2147   142A 27          	mov b, a	
2148   142B 38 00 00    	mov c, 0					; reset LBA to 0
2149   142E 22 01       	mov ah, $01				; disk read
2150   1430 3B DF 28    	mov d, transient_area
2151   1433 07 1C 0B    	call IDE_read_sect		;read directory
2152   1436 FD 10       	cla
2153   1438 42 24 16    	mov [index], a				;reset file counter
2154   143B             cmd_mv_L1:
2155   143B FD 4E       	mov si, d
2156   143D FD 4F DF 1C 	mov di, temp_data
2157   1441 07 93 00    	call strcmp
2158   1444 C6 5A 14    	je cmd_mv_found_entry
2159   1447 58 20 00    	add d, 32
2160   144A 14 24 16    	mov a, [index]
2161   144D 77          	inc a
2162   144E 42 24 16    	mov [index], a
2163   1451 AF 10 00    	cmp a, FST_FILES_PER_DIR
2164   1454 C6 8C 14    	je cmd_mv_not_found
2165   1457 0A 3B 14    	jmp cmd_mv_L1
2166   145A             cmd_mv_found_entry:	
2167   145A DA          	push d
2168   145B FD 4D 5F 1D 	mov si, temp_data + 128	; (0...127) = original filename , (128...255) = new name
2169   145F FD 50       	mov di, d
2170   1461 07 A8 00    	call strcpy	
2171   1464 38 00 00    	mov c, 0
2172   1467 3B DF 28    	mov d, transient_area
2173   146A 22 01       	mov ah, $01					;disk write 1 sect
2174   146C 07 42 0B    	call IDE_write_sect			;write sector
2175   146F E7          	pop d
2176   1470             ;;;;;;;; need to check whether its a dir or a file here ;;;;;;;;;;;;;;
2177   1470 2B 19 00    	mov b, [d + 25]				; get the dirID of the directory so we can locate its own entry in the list
2178   1473 22 01       	mov ah, $01
2179   1475 3B DF 28    	mov d, transient_area
2180   1478 38 00 00    	mov c, 0
2181   147B 07 1C 0B    	call IDE_read_sect			; read directory entry
2182   147E FD 4D 5F 1D 	mov si, temp_data + 128
2183   1482 FD 50       	mov di, d
2184   1484 07 A8 00    	call strcpy					; change directory's name
2185   1487 22 01       	mov ah, $01
2186   1489 07 42 0B    	call IDE_write_sect			; rewrite directory back to disk
2187   148C             cmd_mv_not_found:
2188   148C 06          	sysret
2189   148D             
2190   148D             KERNEL_RESET_VECTOR:	
2191   148D FD 49 FF F7 	mov bp, STACK_BEGIN
2192   1491 FD 47 FF F7 	mov sp, STACK_BEGIN
2193   1495             	
2194   1495 19 80       	mov al, %10000000
2195   1497 FD 0F       	stomsk					; mask out timer interrupt for now (only allow UART to interrupt)
2196   1499 FD 0C       	sti	
2197   149B             
2198   149B 0C          	lodstat
2199   149C 87 BF       	and al, %10111111	; disable display register loading
2200   149E 0D          	stostat
2201   149F             	
2202   149F             ; reset fifo pointers
2203   149F 10 DF 1E    	mov a, fifo
2204   14A2 3B 28 16    	mov d, fifo_pi
2205   14A5 43          	mov [d], a
2206   14A6 3B 2A 16    	mov d, fifo_pr
2207   14A9 43          	mov [d], a	
2208   14AA 19 02       	mov al, 2
2209   14AC 05 03       	syscall sys_io			; enable uart in interrupt mode
2210   14AE             	
2211   14AE 3B 8D 16    	mov d, s_kernel_started
2212   14B1 07 80 02    	call puts
2213   14B4             	
2214   14B4 3B B2 16    	mov d, s_prompt_init
2215   14B7 07 80 02    	call puts
2216   14BA             
2217   14BA 19 10       	mov al, 16
2218   14BC 05 04       	syscall sys_fileio		; set root dirID
2219   14BE             
2220   14BE 3B 2E 16    	mov d, s_init_path
2221   14C1 05 05       	syscall sys_fork		; launch init as a new process
2222   14C3             
2223   14C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2224   14C3             ;;; Process Index in A
2225   14C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2226   14C3             find_free_proc:
2227   14C3 FD 4D D0 18 	mov si, proc_availab_table + 1			; skip process 0 (kernel)
2228   14C7             find_free_proc_L0:
2229   14C7 F6          	lodsb						; get process state
2230   14C8 B9 00       	cmp al, 0
2231   14CA C6 D0 14    	je find_free_proc_free			; if free, jump
2232   14CD 0A C7 14    	jmp find_free_proc_L0			; else, goto next
2233   14D0             find_free_proc_free:
2234   14D0 4E          	mov a, si
2235   14D1 5F D0 18    	sub a, 1 + proc_availab_table				; get process index
2236   14D4 09          	ret
2237   14D5             	
2238   14D5             
2239   14D5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2240   14D5             ;;; Process Index in AL
2241   14D5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2242   14D5             proc_memory_map:
2243   14D5 22 00       	mov ah, 0
2244   14D7 27          	mov b, a			; page in BL, 0 in BH
2245   14D8 FD 9D 05    	shl a, 5			; multiply by 32
2246   14DB 39          	mov c, a			; save in C
2247   14DC 57 20 00    	add c, 32
2248   14DF             proc_memory_map_L0:
2249   14DF 02          	pagemap
2250   14E0 55 00 08    	add b, $0800					; increase page number (msb 5 bits of BH only)
2251   14E3 53 01 00    	add a, 1						; increase both 
2252   14E6 B1          	cmp a, c						; check to see if we reached the end of memory
2253   14E7 C7 DF 14    	jne proc_memory_map_L0
2254   14EA 09          	ret
2255   14EB             	
2256   14EB             
2257   14EB             cmd_terminate_proc:
2258   14EB 51 05 00    	add sp, 5		; clear stack of the values that were pushed by the interrupt (SP, Status, PC)
2259   14EE             					; since they will not be used for anything here.
2260   14EE 1D 23 16    	mov al, [active_proc_index]
2261   14F1 22 00       	mov ah, 0	
2262   14F3 FD 9D 05    	shl a, 5						; x32
2263   14F6 53 DF 18    	add a, proc_names
2264   14F9 3C          	mov d, a
2265   14FA 19 00       	mov al, 0
2266   14FC 3E          	mov [d], al			; nullify process name
2267   14FD             
2268   14FD 1D 23 16    	mov al, [active_proc_index]
2269   1500 22 00       	mov ah, 0	
2270   1502 3C          	mov d, a
2271   1503 19 00       	mov al, 0
2272   1505 3F CF 18    	mov [d + proc_availab_table], al					; make process empty again
2273   1508             	
2274   1508 1D 22 16    	mov al, [nbr_active_procs]			; decrease nbr of active processes
2275   150B 80          	dec al
2276   150C 3D 22 16    	mov [nbr_active_procs], al
2277   150F             
2278   150F             ; now load the shell process again
2279   150F 19 02       	mov al, 2				; next process = process 2 = shell
2280   1511 3D 23 16    	mov [active_proc_index], al		; set next active proc
2281   1514             
2282   1514             ; calculate LUT entry for next process
2283   1514 22 00       	mov ah, 0
2284   1516 FD 99       	shl a							; x2
2285   1518 B7 E1 15    	mov a, [proc_table_convert + a]		; get process state start index	
2286   151B             	
2287   151B 4D          	mov si, a						; source is proc state block
2288   151C 48          	mov a, sp
2289   151D 5F 13 00    	sub a, 19
2290   1520 4F          	mov di, a						; destination is kernel stack
2291   1521             ; restore SP
2292   1521 7D          	dec a
2293   1522 47          	mov sp, a
2294   1523 38 14 00    	mov c, 20
2295   1526 FD F5       	rep movsb
2296   1528             ; set VM process
2297   1528 1D 23 16    	mov al, [active_proc_index]
2298   152B 01          	setptb
2299   152C             		
2300   152C 4C          	popa
2301   152D 06          	sysret
2302   152E             
2303   152E             cmd_pause_proc:
2304   152E             ; save all registers into kernel stack
2305   152E 4B          	pusha
2306   152F 22 00       	mov ah, 0
2307   1531 1D 23 16    	mov al, [active_proc_index]
2308   1534 FD 99       	shl a							; x2
2309   1536 B7 E1 15    	mov a, [proc_table_convert + a]	; get process state start index
2310   1539             		
2311   1539 4F          	mov di, a
2312   153A 48          	mov a, sp
2313   153B 77          	inc a
2314   153C 4D          	mov si, a
2315   153D 38 14 00    	mov c, 20
2316   1540 FD F5       	rep movsb					; save process state!
2317   1542             ; restore kernel stack position to point before interrupt arrived
2318   1542 51 14 00    	add sp, 20
2319   1545             ; now load the shell process again
2320   1545 19 02       	mov al, 2				; next process = process 2 = shell
2321   1547 3D 23 16    	mov [active_proc_index], al		; set next active proc
2322   154A             
2323   154A             ; calculate LUT entry for next process
2324   154A 22 00       	mov ah, 0
2325   154C FD 99       	shl a							; x2
2326   154E B7 E1 15    	mov a, [proc_table_convert + a]		; get process state start index	
2327   1551             	
2328   1551 4D          	mov si, a						; source is proc state block
2329   1552 48          	mov a, sp
2330   1553 5F 13 00    	sub a, 19
2331   1556 4F          	mov di, a						; destination is kernel stack
2332   1557             ; restore SP
2333   1557 7D          	dec a
2334   1558 47          	mov sp, a
2335   1559 38 14 00    	mov c, 20
2336   155C FD F5       	rep movsb
2337   155E             ; set VM process
2338   155E 1D 23 16    	mov al, [active_proc_index]
2339   1561 01          	setptb
2340   1562             		
2341   1562 4C          	popa
2342   1563 06          	sysret
2343   1564             
2344   1564             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2345   1564             ;; fork a new process
2346   1564             ;; D = path of the process file to be forked
2347   1564             ;; B = arguments ptr
2348   1564             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2349   1564             cmd_fork:
2350   1564             ; we save the active process first	
2351   1564 4B          	pusha
2352   1565 22 00       	mov ah, 0
2353   1567 1D 23 16    	mov al, [active_proc_index]
2354   156A FD 99       	shl a							; x2
2355   156C B7 E1 15    	mov a, [proc_table_convert + a]		; get process state table's start index
2356   156F             	
2357   156F 4F          	mov di, a
2358   1570 48          	mov a, sp
2359   1571 77          	inc a
2360   1572 4D          	mov si, a
2361   1573 38 14 00    	mov c, 20
2362   1576 FD F5       	rep movsb					; save process state!
2363   1578             ; restore kernel stack position to point before interrupt arrived
2364   1578 51 14 00    	add sp, 20
2365   157B             	
2366   157B FD 4E       	mov si, d				; copy the file path
2367   157D FD 4F DF 1C 	mov di, temp_data
2368   1581 38 00 02    	mov c, 512
2369   1584 04          	load
2370   1585 11          	mov a, b
2371   1586 4D          	mov si, a				; copy the arguments
2372   1587 FD 4F DF 26 	mov di, scrap_sector
2373   158B 38 00 02    	mov c, 512
2374   158E 04          	load
2375   158F 07 D2 0F    	call loadfile_from_path		; load the process file from disk by path (path is in temp_data)
2376   1592             								; the file data is loaded into transient_area
2377   1592             ; now we allocate a new process	
2378   1592 07 C3 14    	call find_free_proc			; index in A
2379   1595 01          	setptb
2380   1596 07 D5 14    	call proc_memory_map			; map process memory pages
2381   1599             ; copy arguments into process's memory
2382   1599 FD 4D DF 26 	mov si, scrap_sector
2383   159D FD 4F 00 00 	mov di, 0
2384   15A1 38 00 02    	mov c, 512
2385   15A4 03          	store
2386   15A5             ; now copy process binary data into process's memory
2387   15A5 FD 4D DF 28 	mov si, transient_area
2388   15A9 FD 4F 00 04 	mov di, PROC_TEXT_ORG		; code origin address for all user processes
2389   15AD 38 00 40    	mov c, FS_FILE_SIZE			; size of memory space to copy, which is equal to the max file size in disk (for now)
2390   15B0 03          	store						; copy process data
2391   15B1             		
2392   15B1 07 C3 14    	call find_free_proc			; index in A
2393   15B4 3D 23 16    	mov [active_proc_index], al		; set new active process
2394   15B7 FD 9D 05    	shl a, 5						; x32
2395   15BA 53 DF 18    	add a, proc_names
2396   15BD 4F          	mov di, a
2397   15BE FD 4D DF 1C 	mov si, temp_data			; copy and store process filename
2398   15C2 07 A8 00    	call strcpy
2399   15C5             	
2400   15C5 07 C3 14    	call find_free_proc			; index in A
2401   15C8 3C          	mov d, a
2402   15C9 19 01       	mov al, 1
2403   15CB 3F CF 18    	mov [d + proc_availab_table], al					; make process busy
2404   15CE             	
2405   15CE 1D 22 16    	mov al, [nbr_active_procs]			; increase nbr of active processes
2406   15D1 7A          	inc al
2407   15D2 3D 22 16    	mov [nbr_active_procs], al
2408   15D5             ; launch process
2409   15D5 FD D7 FF FF 	push word $FFFF 
2410   15D9 FD DB 0E    	push byte %00001110		; dma_ack = 0, interrupts enabled = 1, mode = user, paging = on, halt=0, display_reg_load=0, dir=0
2411   15DC FD D7 00 04 	push word PROC_TEXT_ORG
2412   15E0 06          	sysret
2413   15E1             
2414   15E1             proc_table_convert:
2415   15E1 8F 17       	.dw proc_state_table + 0
2416   15E3 A3 17       	.dw proc_state_table + 20
2417   15E5 B7 17       	.dw proc_state_table + 40
2418   15E7 CB 17       	.dw proc_state_table + 60
2419   15E9 DF 17       	.dw proc_state_table + 80
2420   15EB F3 17       	.dw proc_state_table + 100
2421   15ED 07 18       	.dw proc_state_table + 120
2422   15EF 1B 18       	.dw proc_state_table + 140
2423   15F1             	
2424   15F1             ; ************************************************************
2425   15F1             ; GET HEX FILE
2426   15F1             ; di = destination address
2427   15F1             ; return length in bytes in C
2428   15F1             ; ************************************************************
2429   15F1             _load_hex:
2430   15F1 D2          	push bp
2431   15F2 9B          	mov bp, sp
2432   15F3 D7          	push a
2433   15F4 D8          	push b
2434   15F5 DA          	push d
2435   15F6 E2          	push si
2436   15F7 E3          	push di
2437   15F8 52 00 60    	sub sp, $6000				; string data block
2438   15FB 38 00 00    	mov c, 0
2439   15FE 48          	mov a, sp
2440   15FF 77          	inc a
2441   1600 3C          	mov d, a				; start of string data block
2442   1601 07 4D 01    	call gets				; get program string
2443   1604 4D          	mov si, a
2444   1605             __load_hex_loop:
2445   1605 F6          	lodsb					; load from [SI] to AL
2446   1606 B9 00       	cmp al, 0				; check if ASCII 0
2447   1608 C6 16 16    	jz __load_hex_ret
2448   160B 36          	mov bh, al
2449   160C F6          	lodsb
2450   160D 2F          	mov bl, al
2451   160E 07 FB 00    	call atoi				; convert ASCII byte in B to int (to AL)
2452   1611 F7          	stosb					; store AL to [DI]
2453   1612 78          	inc c
2454   1613 0A 05 16    	jmp __load_hex_loop
2455   1616             __load_hex_ret:
2456   1616 51 00 60    	add sp, $6000
2457   1619 F0          	pop di
2458   161A EF          	pop si
2459   161B E7          	pop d
2460   161C E5          	pop b
2461   161D E4          	pop a
2462   161E 9C          	mov sp, bp
2463   161F F1          	pop bp
2464   1620 09          	ret
2465   1621             
2466   1621             ; synopsis: look insIDE a certain DIRECTORY for files/directories
2467   1621             ; BEFORE CALLING THIS FUNCTION, CD INTO REQUIRED DIRECTORY
2468   1621             ; for each entry insIDE DIRECTORY:
2469   1621             ;	if entry is a file:
2470   1621             ;		compare filename to searched filename
2471   1621             ;		if filenames are the same, print filename
2472   1621             ;	else if entry is a directory:
2473   1621             ;		cd to the given directory
2474   1621             ;		recursively call cmd_find
2475   1621             ;		cd outsIDE previous directory
2476   1621             ;	if current entry == last entry, return
2477   1621             ; endfor
2478   1621             ;		
2479   1621             ;	
2480   1621             f_find:
2481   1621             	
2482   1621 09          	ret
2483   1622             
2484   1622             
2485   1622             
2486   1622 00          nbr_active_procs:	.db 0
2487   1623 01          active_proc_index:	.db 1
2488   1624             
2489   1624 00 00       index:				.dw 0
2490   1626 00 00       buffer_addr:		.dw 0
2491   1628             
2492   1628 DF 1E       fifo_pi:			.dw fifo
2493   162A DF 1E       fifo_pr:			.dw fifo
2494   162C             
2495   162C             ; file system variables
2496   162C 00 00       current_dirID:		.dw 0				; keep dirID of current directory
2497   162E 2F 73 62 69 s_init_path:		.db "/sbin/init", 0
2497   1632 6E 2F 69 6E 
2497   1636 69 74 00 
2498   1639             
2499   1639 2E 2E 00    s_parent_dir:		.db "..", 0
2500   163C 2E 00       s_current_dir:		.db ".", 0
2501   163E 2F 00       s_fslash: 			.db "/", 0
2502   1640 20 23 20 00 s_hash:				.db " # ", 0
2503   1644 2D 72 77 20 file_attrib:		.db "-rw x"			; chars at multiples of 2
2503   1648 78 
2504   1649 2D 64 63    file_type:			.db "-dc"
2505   164C 50 49 44 20 s_ps_header:		.db "PID COMMAND\n", 0
2505   1650 43 4F 4D 4D 
2505   1654 41 4E 44 0A 
2505   1658 00 
2506   1659 72 6F 6F 74 s_host: 			.db "root@Solarium:", 0, 0
2506   165D 40 53 6F 6C 
2506   1661 61 72 69 75 
2506   1665 6D 3A 00 00 
2507   1669 53 6F 6C 61 s_uname:			.db "Solarium\n", 0
2507   166D 72 69 75 6D 
2507   1671 0A 00 
2508   1673             
2509   1673 72 6F 6F 74 s_root:				.db "root\n", 0
2509   1677 0A 00 
2510   1679             
2511   1679 69 6E 74 65 s_int_en:			.db "interrupts enabled\n", 0
2511   167D 72 72 75 70 
2511   1681 74 73 20 65 
2511   1685 6E 61 62 6C 
2511   1689 65 64 0A 00 
2512   168D 6B 65 72 6E s_kernel_started:	.db "kernel started\n", 0
2512   1691 65 6C 20 73 
2512   1695 74 61 72 74 
2512   1699 65 64 0A 00 
2513   169D 65 6E 74 65 s_procname:			.db "enter process name: ", 0
2513   16A1 72 20 70 72 
2513   16A5 6F 63 65 73 
2513   16A9 73 20 6E 61 
2513   16AD 6D 65 3A 20 
2513   16B1 00 
2514   16B2 73 74 61 72 s_prompt_init:		.db "starting init\n", 0
2514   16B6 74 69 6E 67 
2514   16BA 20 69 6E 69 
2514   16BE 74 0A 00 
2515   16C1 0A 73 6F 66 s_priviledge:		.db "\nsoftware failure: privilege exception\n", 0
2515   16C5 74 77 61 72 
2515   16C9 65 20 66 61 
2515   16CD 69 6C 75 72 
2515   16D1 65 3A 20 70 
2515   16D5 72 69 76 69 
2515   16D9 6C 65 67 65 
2515   16DD 20 65 78 63 
2515   16E1 65 70 74 69 
2515   16E5 6F 6E 0A 00 
2516   16E9 0A 65 78 63 s_divzero:			.db "\nexception: zero division\n", 0
2516   16ED 65 70 74 69 
2516   16F1 6F 6E 3A 20 
2516   16F5 7A 65 72 6F 
2516   16F9 20 64 69 76 
2516   16FD 69 73 69 6F 
2516   1701 6E 0A 00 
2517   1704             
2518   1704 59 65 61 72 s_set_year:			.db "Year: ", 0
2518   1708 3A 20 00 
2519   170B 4D 6F 6E 74 s_set_month:		.db "Month: ", 0
2519   170F 68 3A 20 00 
2520   1713 44 61 79 3A s_set_day:			.db "Day: ", 0
2520   1717 20 00 
2521   1719 57 65 65 6B s_set_week:			.db "Weekday: ", 0
2521   171D 64 61 79 3A 
2521   1721 20 00 
2522   1723 48 6F 75 72 s_set_hours:		.db "Hours: ", 0
2522   1727 73 3A 20 00 
2523   172B 4D 69 6E 75 s_set_minutes:		.db "Minutes: ", 0
2523   172F 74 65 73 3A 
2523   1733 20 00 
2524   1735 53 65 63 6F s_set_seconds:		.db "Seconds: ", 0
2524   1739 6E 64 73 3A 
2524   173D 20 00 
2525   173F 20 20 20 00 s_months:			.db "   ", 0
2526   1743 4A 61 6E 00 					.db "Jan", 0
2527   1747 46 65 62 00 					.db "Feb", 0
2528   174B 4D 61 72 00 					.db "Mar", 0
2529   174F 41 70 72 00 					.db "Apr", 0
2530   1753 4D 61 79 00 					.db "May", 0
2531   1757 4A 75 6E 00 					.db "Jun", 0
2532   175B 4A 75 6C 00 					.db "Jul", 0
2533   175F 41 75 67 00 					.db "Aug", 0
2534   1763 53 65 70 00 					.db "Sep", 0
2535   1767 4F 63 74 00 					.db "Oct", 0
2536   176B 4E 6F 76 00 					.db "Nov", 0
2537   176F 44 65 63 00 					.db "Dec", 0
2538   1773 53 75 6E 00 s_week:				.db "Sun", 0 
2539   1777 4D 6F 6E 00 					.db "Mon", 0 
2540   177B 54 75 65 00 					.db "Tue", 0 
2541   177F 57 65 64 00 					.db "Wed", 0 
2542   1783 54 68 75 00 					.db "Thu", 0 
2543   1787 46 72 69 00 					.db "Fri", 0 
2544   178B 53 61 74 00 					.db "Sat", 0
2545   178F             
2546   178F 00 00 00 00 proc_state_table:	.fill 16 * 20, 0	; for 15 processes max
2546   1793 00 00 00 00 
2546   1797 00 00 00 00 
2546   179B 00 00 00 00 
2546   179F 00 00 00 00 
2546   17A3 00 00 00 00 
2546   17A7 00 00 00 00 
2546   17AB 00 00 00 00 
2546   17AF 00 00 00 00 
2546   17B3 00 00 00 00 
2546   17B7 00 00 00 00 
2546   17BB 00 00 00 00 
2546   17BF 00 00 00 00 
2546   17C3 00 00 00 00 
2546   17C7 00 00 00 00 
2546   17CB 00 00 00 00 
2546   17CF 00 00 00 00 
2546   17D3 00 00 00 00 
2546   17D7 00 00 00 00 
2546   17DB 00 00 00 00 
2546   17DF 00 00 00 00 
2546   17E3 00 00 00 00 
2546   17E7 00 00 00 00 
2546   17EB 00 00 00 00 
2546   17EF 00 00 00 00 
2546   17F3 00 00 00 00 
2546   17F7 00 00 00 00 
2546   17FB 00 00 00 00 
2546   17FF 00 00 00 00 
2546   1803 00 00 00 00 
2546   1807 00 00 00 00 
2546   180B 00 00 00 00 
2546   180F 00 00 00 00 
2546   1813 00 00 00 00 
2546   1817 00 00 00 00 
2546   181B 00 00 00 00 
2546   181F 00 00 00 00 
2546   1823 00 00 00 00 
2546   1827 00 00 00 00 
2546   182B 00 00 00 00 
2546   182F 00 00 00 00 
2546   1833 00 00 00 00 
2546   1837 00 00 00 00 
2546   183B 00 00 00 00 
2546   183F 00 00 00 00 
2546   1843 00 00 00 00 
2546   1847 00 00 00 00 
2546   184B 00 00 00 00 
2546   184F 00 00 00 00 
2546   1853 00 00 00 00 
2546   1857 00 00 00 00 
2546   185B 00 00 00 00 
2546   185F 00 00 00 00 
2546   1863 00 00 00 00 
2546   1867 00 00 00 00 
2546   186B 00 00 00 00 
2546   186F 00 00 00 00 
2546   1873 00 00 00 00 
2546   1877 00 00 00 00 
2546   187B 00 00 00 00 
2546   187F 00 00 00 00 
2546   1883 00 00 00 00 
2546   1887 00 00 00 00 
2546   188B 00 00 00 00 
2546   188F 00 00 00 00 
2546   1893 00 00 00 00 
2546   1897 00 00 00 00 
2546   189B 00 00 00 00 
2546   189F 00 00 00 00 
2546   18A3 00 00 00 00 
2546   18A7 00 00 00 00 
2546   18AB 00 00 00 00 
2546   18AF 00 00 00 00 
2546   18B3 00 00 00 00 
2546   18B7 00 00 00 00 
2546   18BB 00 00 00 00 
2546   18BF 00 00 00 00 
2546   18C3 00 00 00 00 
2546   18C7 00 00 00 00 
2546   18CB 00 00 00 00 
2547   18CF 00 00 00 00 proc_availab_table:	.fill 16, 0			; space for 15 processes. 0 = process empty, 1 = process taken
2547   18D3 00 00 00 00 
2547   18D7 00 00 00 00 
2547   18DB 00 00 00 00 
2548   18DF 00 00 00 00 proc_names:			.fill 16 * 32, 0	; process names
2548   18E3 00 00 00 00 
2548   18E7 00 00 00 00 
2548   18EB 00 00 00 00 
2548   18EF 00 00 00 00 
2548   18F3 00 00 00 00 
2548   18F7 00 00 00 00 
2548   18FB 00 00 00 00 
2548   18FF 00 00 00 00 
2548   1903 00 00 00 00 
2548   1907 00 00 00 00 
2548   190B 00 00 00 00 
2548   190F 00 00 00 00 
2548   1913 00 00 00 00 
2548   1917 00 00 00 00 
2548   191B 00 00 00 00 
2548   191F 00 00 00 00 
2548   1923 00 00 00 00 
2548   1927 00 00 00 00 
2548   192B 00 00 00 00 
2548   192F 00 00 00 00 
2548   1933 00 00 00 00 
2548   1937 00 00 00 00 
2548   193B 00 00 00 00 
2548   193F 00 00 00 00 
2548   1943 00 00 00 00 
2548   1947 00 00 00 00 
2548   194B 00 00 00 00 
2548   194F 00 00 00 00 
2548   1953 00 00 00 00 
2548   1957 00 00 00 00 
2548   195B 00 00 00 00 
2548   195F 00 00 00 00 
2548   1963 00 00 00 00 
2548   1967 00 00 00 00 
2548   196B 00 00 00 00 
2548   196F 00 00 00 00 
2548   1973 00 00 00 00 
2548   1977 00 00 00 00 
2548   197B 00 00 00 00 
2548   197F 00 00 00 00 
2548   1983 00 00 00 00 
2548   1987 00 00 00 00 
2548   198B 00 00 00 00 
2548   198F 00 00 00 00 
2548   1993 00 00 00 00 
2548   1997 00 00 00 00 
2548   199B 00 00 00 00 
2548   199F 00 00 00 00 
2548   19A3 00 00 00 00 
2548   19A7 00 00 00 00 
2548   19AB 00 00 00 00 
2548   19AF 00 00 00 00 
2548   19B3 00 00 00 00 
2548   19B7 00 00 00 00 
2548   19BB 00 00 00 00 
2548   19BF 00 00 00 00 
2548   19C3 00 00 00 00 
2548   19C7 00 00 00 00 
2548   19CB 00 00 00 00 
2548   19CF 00 00 00 00 
2548   19D3 00 00 00 00 
2548   19D7 00 00 00 00 
2548   19DB 00 00 00 00 
2548   19DF 00 00 00 00 
2548   19E3 00 00 00 00 
2548   19E7 00 00 00 00 
2548   19EB 00 00 00 00 
2548   19EF 00 00 00 00 
2548   19F3 00 00 00 00 
2548   19F7 00 00 00 00 
2548   19FB 00 00 00 00 
2548   19FF 00 00 00 00 
2548   1A03 00 00 00 00 
2548   1A07 00 00 00 00 
2548   1A0B 00 00 00 00 
2548   1A0F 00 00 00 00 
2548   1A13 00 00 00 00 
2548   1A17 00 00 00 00 
2548   1A1B 00 00 00 00 
2548   1A1F 00 00 00 00 
2548   1A23 00 00 00 00 
2548   1A27 00 00 00 00 
2548   1A2B 00 00 00 00 
2548   1A2F 00 00 00 00 
2548   1A33 00 00 00 00 
2548   1A37 00 00 00 00 
2548   1A3B 00 00 00 00 
2548   1A3F 00 00 00 00 
2548   1A43 00 00 00 00 
2548   1A47 00 00 00 00 
2548   1A4B 00 00 00 00 
2548   1A4F 00 00 00 00 
2548   1A53 00 00 00 00 
2548   1A57 00 00 00 00 
2548   1A5B 00 00 00 00 
2548   1A5F 00 00 00 00 
2548   1A63 00 00 00 00 
2548   1A67 00 00 00 00 
2548   1A6B 00 00 00 00 
2548   1A6F 00 00 00 00 
2548   1A73 00 00 00 00 
2548   1A77 00 00 00 00 
2548   1A7B 00 00 00 00 
2548   1A7F 00 00 00 00 
2548   1A83 00 00 00 00 
2548   1A87 00 00 00 00 
2548   1A8B 00 00 00 00 
2548   1A8F 00 00 00 00 
2548   1A93 00 00 00 00 
2548   1A97 00 00 00 00 
2548   1A9B 00 00 00 00 
2548   1A9F 00 00 00 00 
2548   1AA3 00 00 00 00 
2548   1AA7 00 00 00 00 
2548   1AAB 00 00 00 00 
2548   1AAF 00 00 00 00 
2548   1AB3 00 00 00 00 
2548   1AB7 00 00 00 00 
2548   1ABB 00 00 00 00 
2548   1ABF 00 00 00 00 
2548   1AC3 00 00 00 00 
2548   1AC7 00 00 00 00 
2548   1ACB 00 00 00 00 
2548   1ACF 00 00 00 00 
2548   1AD3 00 00 00 00 
2548   1AD7 00 00 00 00 
2548   1ADB 00 00 00 00 
2549   1ADF 00 00 00 00 filename:			.fill 512, 0		; holds a path for file search
2549   1AE3 00 00 00 00 
2549   1AE7 00 00 00 00 
2549   1AEB 00 00 00 00 
2549   1AEF 00 00 00 00 
2549   1AF3 00 00 00 00 
2549   1AF7 00 00 00 00 
2549   1AFB 00 00 00 00 
2549   1AFF 00 00 00 00 
2549   1B03 00 00 00 00 
2549   1B07 00 00 00 00 
2549   1B0B 00 00 00 00 
2549   1B0F 00 00 00 00 
2549   1B13 00 00 00 00 
2549   1B17 00 00 00 00 
2549   1B1B 00 00 00 00 
2549   1B1F 00 00 00 00 
2549   1B23 00 00 00 00 
2549   1B27 00 00 00 00 
2549   1B2B 00 00 00 00 
2549   1B2F 00 00 00 00 
2549   1B33 00 00 00 00 
2549   1B37 00 00 00 00 
2549   1B3B 00 00 00 00 
2549   1B3F 00 00 00 00 
2549   1B43 00 00 00 00 
2549   1B47 00 00 00 00 
2549   1B4B 00 00 00 00 
2549   1B4F 00 00 00 00 
2549   1B53 00 00 00 00 
2549   1B57 00 00 00 00 
2549   1B5B 00 00 00 00 
2549   1B5F 00 00 00 00 
2549   1B63 00 00 00 00 
2549   1B67 00 00 00 00 
2549   1B6B 00 00 00 00 
2549   1B6F 00 00 00 00 
2549   1B73 00 00 00 00 
2549   1B77 00 00 00 00 
2549   1B7B 00 00 00 00 
2549   1B7F 00 00 00 00 
2549   1B83 00 00 00 00 
2549   1B87 00 00 00 00 
2549   1B8B 00 00 00 00 
2549   1B8F 00 00 00 00 
2549   1B93 00 00 00 00 
2549   1B97 00 00 00 00 
2549   1B9B 00 00 00 00 
2549   1B9F 00 00 00 00 
2549   1BA3 00 00 00 00 
2549   1BA7 00 00 00 00 
2549   1BAB 00 00 00 00 
2549   1BAF 00 00 00 00 
2549   1BB3 00 00 00 00 
2549   1BB7 00 00 00 00 
2549   1BBB 00 00 00 00 
2549   1BBF 00 00 00 00 
2549   1BC3 00 00 00 00 
2549   1BC7 00 00 00 00 
2549   1BCB 00 00 00 00 
2549   1BCF 00 00 00 00 
2549   1BD3 00 00 00 00 
2549   1BD7 00 00 00 00 
2549   1BDB 00 00 00 00 
2549   1BDF 00 00 00 00 
2549   1BE3 00 00 00 00 
2549   1BE7 00 00 00 00 
2549   1BEB 00 00 00 00 
2549   1BEF 00 00 00 00 
2549   1BF3 00 00 00 00 
2549   1BF7 00 00 00 00 
2549   1BFB 00 00 00 00 
2549   1BFF 00 00 00 00 
2549   1C03 00 00 00 00 
2549   1C07 00 00 00 00 
2549   1C0B 00 00 00 00 
2549   1C0F 00 00 00 00 
2549   1C13 00 00 00 00 
2549   1C17 00 00 00 00 
2549   1C1B 00 00 00 00 
2549   1C1F 00 00 00 00 
2549   1C23 00 00 00 00 
2549   1C27 00 00 00 00 
2549   1C2B 00 00 00 00 
2549   1C2F 00 00 00 00 
2549   1C33 00 00 00 00 
2549   1C37 00 00 00 00 
2549   1C3B 00 00 00 00 
2549   1C3F 00 00 00 00 
2549   1C43 00 00 00 00 
2549   1C47 00 00 00 00 
2549   1C4B 00 00 00 00 
2549   1C4F 00 00 00 00 
2549   1C53 00 00 00 00 
2549   1C57 00 00 00 00 
2549   1C5B 00 00 00 00 
2549   1C5F 00 00 00 00 
2549   1C63 00 00 00 00 
2549   1C67 00 00 00 00 
2549   1C6B 00 00 00 00 
2549   1C6F 00 00 00 00 
2549   1C73 00 00 00 00 
2549   1C77 00 00 00 00 
2549   1C7B 00 00 00 00 
2549   1C7F 00 00 00 00 
2549   1C83 00 00 00 00 
2549   1C87 00 00 00 00 
2549   1C8B 00 00 00 00 
2549   1C8F 00 00 00 00 
2549   1C93 00 00 00 00 
2549   1C97 00 00 00 00 
2549   1C9B 00 00 00 00 
2549   1C9F 00 00 00 00 
2549   1CA3 00 00 00 00 
2549   1CA7 00 00 00 00 
2549   1CAB 00 00 00 00 
2549   1CAF 00 00 00 00 
2549   1CB3 00 00 00 00 
2549   1CB7 00 00 00 00 
2549   1CBB 00 00 00 00 
2549   1CBF 00 00 00 00 
2549   1CC3 00 00 00 00 
2549   1CC7 00 00 00 00 
2549   1CCB 00 00 00 00 
2549   1CCF 00 00 00 00 
2549   1CD3 00 00 00 00 
2549   1CD7 00 00 00 00 
2549   1CDB 00 00 00 00 
2550   1CDF 00 00 00 00 temp_data:			.fill 512, 0   		;  user space data
2550   1CE3 00 00 00 00 
2550   1CE7 00 00 00 00 
2550   1CEB 00 00 00 00 
2550   1CEF 00 00 00 00 
2550   1CF3 00 00 00 00 
2550   1CF7 00 00 00 00 
2550   1CFB 00 00 00 00 
2550   1CFF 00 00 00 00 
2550   1D03 00 00 00 00 
2550   1D07 00 00 00 00 
2550   1D0B 00 00 00 00 
2550   1D0F 00 00 00 00 
2550   1D13 00 00 00 00 
2550   1D17 00 00 00 00 
2550   1D1B 00 00 00 00 
2550   1D1F 00 00 00 00 
2550   1D23 00 00 00 00 
2550   1D27 00 00 00 00 
2550   1D2B 00 00 00 00 
2550   1D2F 00 00 00 00 
2550   1D33 00 00 00 00 
2550   1D37 00 00 00 00 
2550   1D3B 00 00 00 00 
2550   1D3F 00 00 00 00 
2550   1D43 00 00 00 00 
2550   1D47 00 00 00 00 
2550   1D4B 00 00 00 00 
2550   1D4F 00 00 00 00 
2550   1D53 00 00 00 00 
2550   1D57 00 00 00 00 
2550   1D5B 00 00 00 00 
2550   1D5F 00 00 00 00 
2550   1D63 00 00 00 00 
2550   1D67 00 00 00 00 
2550   1D6B 00 00 00 00 
2550   1D6F 00 00 00 00 
2550   1D73 00 00 00 00 
2550   1D77 00 00 00 00 
2550   1D7B 00 00 00 00 
2550   1D7F 00 00 00 00 
2550   1D83 00 00 00 00 
2550   1D87 00 00 00 00 
2550   1D8B 00 00 00 00 
2550   1D8F 00 00 00 00 
2550   1D93 00 00 00 00 
2550   1D97 00 00 00 00 
2550   1D9B 00 00 00 00 
2550   1D9F 00 00 00 00 
2550   1DA3 00 00 00 00 
2550   1DA7 00 00 00 00 
2550   1DAB 00 00 00 00 
2550   1DAF 00 00 00 00 
2550   1DB3 00 00 00 00 
2550   1DB7 00 00 00 00 
2550   1DBB 00 00 00 00 
2550   1DBF 00 00 00 00 
2550   1DC3 00 00 00 00 
2550   1DC7 00 00 00 00 
2550   1DCB 00 00 00 00 
2550   1DCF 00 00 00 00 
2550   1DD3 00 00 00 00 
2550   1DD7 00 00 00 00 
2550   1DDB 00 00 00 00 
2550   1DDF 00 00 00 00 
2550   1DE3 00 00 00 00 
2550   1DE7 00 00 00 00 
2550   1DEB 00 00 00 00 
2550   1DEF 00 00 00 00 
2550   1DF3 00 00 00 00 
2550   1DF7 00 00 00 00 
2550   1DFB 00 00 00 00 
2550   1DFF 00 00 00 00 
2550   1E03 00 00 00 00 
2550   1E07 00 00 00 00 
2550   1E0B 00 00 00 00 
2550   1E0F 00 00 00 00 
2550   1E13 00 00 00 00 
2550   1E17 00 00 00 00 
2550   1E1B 00 00 00 00 
2550   1E1F 00 00 00 00 
2550   1E23 00 00 00 00 
2550   1E27 00 00 00 00 
2550   1E2B 00 00 00 00 
2550   1E2F 00 00 00 00 
2550   1E33 00 00 00 00 
2550   1E37 00 00 00 00 
2550   1E3B 00 00 00 00 
2550   1E3F 00 00 00 00 
2550   1E43 00 00 00 00 
2550   1E47 00 00 00 00 
2550   1E4B 00 00 00 00 
2550   1E4F 00 00 00 00 
2550   1E53 00 00 00 00 
2550   1E57 00 00 00 00 
2550   1E5B 00 00 00 00 
2550   1E5F 00 00 00 00 
2550   1E63 00 00 00 00 
2550   1E67 00 00 00 00 
2550   1E6B 00 00 00 00 
2550   1E6F 00 00 00 00 
2550   1E73 00 00 00 00 
2550   1E77 00 00 00 00 
2550   1E7B 00 00 00 00 
2550   1E7F 00 00 00 00 
2550   1E83 00 00 00 00 
2550   1E87 00 00 00 00 
2550   1E8B 00 00 00 00 
2550   1E8F 00 00 00 00 
2550   1E93 00 00 00 00 
2550   1E97 00 00 00 00 
2550   1E9B 00 00 00 00 
2550   1E9F 00 00 00 00 
2550   1EA3 00 00 00 00 
2550   1EA7 00 00 00 00 
2550   1EAB 00 00 00 00 
2550   1EAF 00 00 00 00 
2550   1EB3 00 00 00 00 
2550   1EB7 00 00 00 00 
2550   1EBB 00 00 00 00 
2550   1EBF 00 00 00 00 
2550   1EC3 00 00 00 00 
2550   1EC7 00 00 00 00 
2550   1ECB 00 00 00 00 
2550   1ECF 00 00 00 00 
2550   1ED3 00 00 00 00 
2550   1ED7 00 00 00 00 
2550   1EDB 00 00 00 00 
2551   1EDF FF FF FF FF fifo:				.fill FIFO_SIZE
2551   1EE3 FF FF FF FF 
2551   1EE7 FF FF FF FF 
2551   1EEB FF FF FF FF 
2551   1EEF FF FF FF FF 
2551   1EF3 FF FF FF FF 
2551   1EF7 FF FF FF FF 
2551   1EFB FF FF FF FF 
2551   1EFF FF FF FF FF 
2551   1F03 FF FF FF FF 
2551   1F07 FF FF FF FF 
2551   1F0B FF FF FF FF 
2551   1F0F FF FF FF FF 
2551   1F13 FF FF FF FF 
2551   1F17 FF FF FF FF 
2551   1F1B FF FF FF FF 
2551   1F1F FF FF FF FF 
2551   1F23 FF FF FF FF 
2551   1F27 FF FF FF FF 
2551   1F2B FF FF FF FF 
2551   1F2F FF FF FF FF 
2551   1F33 FF FF FF FF 
2551   1F37 FF FF FF FF 
2551   1F3B FF FF FF FF 
2551   1F3F FF FF FF FF 
2551   1F43 FF FF FF FF 
2551   1F47 FF FF FF FF 
2551   1F4B FF FF FF FF 
2551   1F4F FF FF FF FF 
2551   1F53 FF FF FF FF 
2551   1F57 FF FF FF FF 
2551   1F5B FF FF FF FF 
2551   1F5F FF FF FF FF 
2551   1F63 FF FF FF FF 
2551   1F67 FF FF FF FF 
2551   1F6B FF FF FF FF 
2551   1F6F FF FF FF FF 
2551   1F73 FF FF FF FF 
2551   1F77 FF FF FF FF 
2551   1F7B FF FF FF FF 
2551   1F7F FF FF FF FF 
2551   1F83 FF FF FF FF 
2551   1F87 FF FF FF FF 
2551   1F8B FF FF FF FF 
2551   1F8F FF FF FF FF 
2551   1F93 FF FF FF FF 
2551   1F97 FF FF FF FF 
2551   1F9B FF FF FF FF 
2551   1F9F FF FF FF FF 
2551   1FA3 FF FF FF FF 
2551   1FA7 FF FF FF FF 
2551   1FAB FF FF FF FF 
2551   1FAF FF FF FF FF 
2551   1FB3 FF FF FF FF 
2551   1FB7 FF FF FF FF 
2551   1FBB FF FF FF FF 
2551   1FBF FF FF FF FF 
2551   1FC3 FF FF FF FF 
2551   1FC7 FF FF FF FF 
2551   1FCB FF FF FF FF 
2551   1FCF FF FF FF FF 
2551   1FD3 FF FF FF FF 
2551   1FD7 FF FF FF FF 
2551   1FDB FF FF FF FF 
2551   1FDF FF FF FF FF 
2551   1FE3 FF FF FF FF 
2551   1FE7 FF FF FF FF 
2551   1FEB FF FF FF FF 
2551   1FEF FF FF FF FF 
2551   1FF3 FF FF FF FF 
2551   1FF7 FF FF FF FF 
2551   1FFB FF FF FF FF 
2551   1FFF FF FF FF FF 
2551   2003 FF FF FF FF 
2551   2007 FF FF FF FF 
2551   200B FF FF FF FF 
2551   200F FF FF FF FF 
2551   2013 FF FF FF FF 
2551   2017 FF FF FF FF 
2551   201B FF FF FF FF 
2551   201F FF FF FF FF 
2551   2023 FF FF FF FF 
2551   2027 FF FF FF FF 
2551   202B FF FF FF FF 
2551   202F FF FF FF FF 
2551   2033 FF FF FF FF 
2551   2037 FF FF FF FF 
2551   203B FF FF FF FF 
2551   203F FF FF FF FF 
2551   2043 FF FF FF FF 
2551   2047 FF FF FF FF 
2551   204B FF FF FF FF 
2551   204F FF FF FF FF 
2551   2053 FF FF FF FF 
2551   2057 FF FF FF FF 
2551   205B FF FF FF FF 
2551   205F FF FF FF FF 
2551   2063 FF FF FF FF 
2551   2067 FF FF FF FF 
2551   206B FF FF FF FF 
2551   206F FF FF FF FF 
2551   2073 FF FF FF FF 
2551   2077 FF FF FF FF 
2551   207B FF FF FF FF 
2551   207F FF FF FF FF 
2551   2083 FF FF FF FF 
2551   2087 FF FF FF FF 
2551   208B FF FF FF FF 
2551   208F FF FF FF FF 
2551   2093 FF FF FF FF 
2551   2097 FF FF FF FF 
2551   209B FF FF FF FF 
2551   209F FF FF FF FF 
2551   20A3 FF FF FF FF 
2551   20A7 FF FF FF FF 
2551   20AB FF FF FF FF 
2551   20AF FF FF FF FF 
2551   20B3 FF FF FF FF 
2551   20B7 FF FF FF FF 
2551   20BB FF FF FF FF 
2551   20BF FF FF FF FF 
2551   20C3 FF FF FF FF 
2551   20C7 FF FF FF FF 
2551   20CB FF FF FF FF 
2551   20CF FF FF FF FF 
2551   20D3 FF FF FF FF 
2551   20D7 FF FF FF FF 
2551   20DB FF FF FF FF 
2551   20DF FF FF FF FF 
2551   20E3 FF FF FF FF 
2551   20E7 FF FF FF FF 
2551   20EB FF FF FF FF 
2551   20EF FF FF FF FF 
2551   20F3 FF FF FF FF 
2551   20F7 FF FF FF FF 
2551   20FB FF FF FF FF 
2551   20FF FF FF FF FF 
2551   2103 FF FF FF FF 
2551   2107 FF FF FF FF 
2551   210B FF FF FF FF 
2551   210F FF FF FF FF 
2551   2113 FF FF FF FF 
2551   2117 FF FF FF FF 
2551   211B FF FF FF FF 
2551   211F FF FF FF FF 
2551   2123 FF FF FF FF 
2551   2127 FF FF FF FF 
2551   212B FF FF FF FF 
2551   212F FF FF FF FF 
2551   2133 FF FF FF FF 
2551   2137 FF FF FF FF 
2551   213B FF FF FF FF 
2551   213F FF FF FF FF 
2551   2143 FF FF FF FF 
2551   2147 FF FF FF FF 
2551   214B FF FF FF FF 
2551   214F FF FF FF FF 
2551   2153 FF FF FF FF 
2551   2157 FF FF FF FF 
2551   215B FF FF FF FF 
2551   215F FF FF FF FF 
2551   2163 FF FF FF FF 
2551   2167 FF FF FF FF 
2551   216B FF FF FF FF 
2551   216F FF FF FF FF 
2551   2173 FF FF FF FF 
2551   2177 FF FF FF FF 
2551   217B FF FF FF FF 
2551   217F FF FF FF FF 
2551   2183 FF FF FF FF 
2551   2187 FF FF FF FF 
2551   218B FF FF FF FF 
2551   218F FF FF FF FF 
2551   2193 FF FF FF FF 
2551   2197 FF FF FF FF 
2551   219B FF FF FF FF 
2551   219F FF FF FF FF 
2551   21A3 FF FF FF FF 
2551   21A7 FF FF FF FF 
2551   21AB FF FF FF FF 
2551   21AF FF FF FF FF 
2551   21B3 FF FF FF FF 
2551   21B7 FF FF FF FF 
2551   21BB FF FF FF FF 
2551   21BF FF FF FF FF 
2551   21C3 FF FF FF FF 
2551   21C7 FF FF FF FF 
2551   21CB FF FF FF FF 
2551   21CF FF FF FF FF 
2551   21D3 FF FF FF FF 
2551   21D7 FF FF FF FF 
2551   21DB FF FF FF FF 
2551   21DF FF FF FF FF 
2551   21E3 FF FF FF FF 
2551   21E7 FF FF FF FF 
2551   21EB FF FF FF FF 
2551   21EF FF FF FF FF 
2551   21F3 FF FF FF FF 
2551   21F7 FF FF FF FF 
2551   21FB FF FF FF FF 
2551   21FF FF FF FF FF 
2551   2203 FF FF FF FF 
2551   2207 FF FF FF FF 
2551   220B FF FF FF FF 
2551   220F FF FF FF FF 
2551   2213 FF FF FF FF 
2551   2217 FF FF FF FF 
2551   221B FF FF FF FF 
2551   221F FF FF FF FF 
2551   2223 FF FF FF FF 
2551   2227 FF FF FF FF 
2551   222B FF FF FF FF 
2551   222F FF FF FF FF 
2551   2233 FF FF FF FF 
2551   2237 FF FF FF FF 
2551   223B FF FF FF FF 
2551   223F FF FF FF FF 
2551   2243 FF FF FF FF 
2551   2247 FF FF FF FF 
2551   224B FF FF FF FF 
2551   224F FF FF FF FF 
2551   2253 FF FF FF FF 
2551   2257 FF FF FF FF 
2551   225B FF FF FF FF 
2551   225F FF FF FF FF 
2551   2263 FF FF FF FF 
2551   2267 FF FF FF FF 
2551   226B FF FF FF FF 
2551   226F FF FF FF FF 
2551   2273 FF FF FF FF 
2551   2277 FF FF FF FF 
2551   227B FF FF FF FF 
2551   227F FF FF FF FF 
2551   2283 FF FF FF FF 
2551   2287 FF FF FF FF 
2551   228B FF FF FF FF 
2551   228F FF FF FF FF 
2551   2293 FF FF FF FF 
2551   2297 FF FF FF FF 
2551   229B FF FF FF FF 
2551   229F FF FF FF FF 
2551   22A3 FF FF FF FF 
2551   22A7 FF FF FF FF 
2551   22AB FF FF FF FF 
2551   22AF FF FF FF FF 
2551   22B3 FF FF FF FF 
2551   22B7 FF FF FF FF 
2551   22BB FF FF FF FF 
2551   22BF FF FF FF FF 
2551   22C3 FF FF FF FF 
2551   22C7 FF FF FF FF 
2551   22CB FF FF FF FF 
2551   22CF FF FF FF FF 
2551   22D3 FF FF FF FF 
2551   22D7 FF FF FF FF 
2551   22DB FF FF FF FF 
2551   22DF FF FF FF FF 
2551   22E3 FF FF FF FF 
2551   22E7 FF FF FF FF 
2551   22EB FF FF FF FF 
2551   22EF FF FF FF FF 
2551   22F3 FF FF FF FF 
2551   22F7 FF FF FF FF 
2551   22FB FF FF FF FF 
2551   22FF FF FF FF FF 
2551   2303 FF FF FF FF 
2551   2307 FF FF FF FF 
2551   230B FF FF FF FF 
2551   230F FF FF FF FF 
2551   2313 FF FF FF FF 
2551   2317 FF FF FF FF 
2551   231B FF FF FF FF 
2551   231F FF FF FF FF 
2551   2323 FF FF FF FF 
2551   2327 FF FF FF FF 
2551   232B FF FF FF FF 
2551   232F FF FF FF FF 
2551   2333 FF FF FF FF 
2551   2337 FF FF FF FF 
2551   233B FF FF FF FF 
2551   233F FF FF FF FF 
2551   2343 FF FF FF FF 
2551   2347 FF FF FF FF 
2551   234B FF FF FF FF 
2551   234F FF FF FF FF 
2551   2353 FF FF FF FF 
2551   2357 FF FF FF FF 
2551   235B FF FF FF FF 
2551   235F FF FF FF FF 
2551   2363 FF FF FF FF 
2551   2367 FF FF FF FF 
2551   236B FF FF FF FF 
2551   236F FF FF FF FF 
2551   2373 FF FF FF FF 
2551   2377 FF FF FF FF 
2551   237B FF FF FF FF 
2551   237F FF FF FF FF 
2551   2383 FF FF FF FF 
2551   2387 FF FF FF FF 
2551   238B FF FF FF FF 
2551   238F FF FF FF FF 
2551   2393 FF FF FF FF 
2551   2397 FF FF FF FF 
2551   239B FF FF FF FF 
2551   239F FF FF FF FF 
2551   23A3 FF FF FF FF 
2551   23A7 FF FF FF FF 
2551   23AB FF FF FF FF 
2551   23AF FF FF FF FF 
2551   23B3 FF FF FF FF 
2551   23B7 FF FF FF FF 
2551   23BB FF FF FF FF 
2551   23BF FF FF FF FF 
2551   23C3 FF FF FF FF 
2551   23C7 FF FF FF FF 
2551   23CB FF FF FF FF 
2551   23CF FF FF FF FF 
2551   23D3 FF FF FF FF 
2551   23D7 FF FF FF FF 
2551   23DB FF FF FF FF 
2551   23DF FF FF FF FF 
2551   23E3 FF FF FF FF 
2551   23E7 FF FF FF FF 
2551   23EB FF FF FF FF 
2551   23EF FF FF FF FF 
2551   23F3 FF FF FF FF 
2551   23F7 FF FF FF FF 
2551   23FB FF FF FF FF 
2551   23FF FF FF FF FF 
2551   2403 FF FF FF FF 
2551   2407 FF FF FF FF 
2551   240B FF FF FF FF 
2551   240F FF FF FF FF 
2551   2413 FF FF FF FF 
2551   2417 FF FF FF FF 
2551   241B FF FF FF FF 
2551   241F FF FF FF FF 
2551   2423 FF FF FF FF 
2551   2427 FF FF FF FF 
2551   242B FF FF FF FF 
2551   242F FF FF FF FF 
2551   2433 FF FF FF FF 
2551   2437 FF FF FF FF 
2551   243B FF FF FF FF 
2551   243F FF FF FF FF 
2551   2443 FF FF FF FF 
2551   2447 FF FF FF FF 
2551   244B FF FF FF FF 
2551   244F FF FF FF FF 
2551   2453 FF FF FF FF 
2551   2457 FF FF FF FF 
2551   245B FF FF FF FF 
2551   245F FF FF FF FF 
2551   2463 FF FF FF FF 
2551   2467 FF FF FF FF 
2551   246B FF FF FF FF 
2551   246F FF FF FF FF 
2551   2473 FF FF FF FF 
2551   2477 FF FF FF FF 
2551   247B FF FF FF FF 
2551   247F FF FF FF FF 
2551   2483 FF FF FF FF 
2551   2487 FF FF FF FF 
2551   248B FF FF FF FF 
2551   248F FF FF FF FF 
2551   2493 FF FF FF FF 
2551   2497 FF FF FF FF 
2551   249B FF FF FF FF 
2551   249F FF FF FF FF 
2551   24A3 FF FF FF FF 
2551   24A7 FF FF FF FF 
2551   24AB FF FF FF FF 
2551   24AF FF FF FF FF 
2551   24B3 FF FF FF FF 
2551   24B7 FF FF FF FF 
2551   24BB FF FF FF FF 
2551   24BF FF FF FF FF 
2551   24C3 FF FF FF FF 
2551   24C7 FF FF FF FF 
2551   24CB FF FF FF FF 
2551   24CF FF FF FF FF 
2551   24D3 FF FF FF FF 
2551   24D7 FF FF FF FF 
2551   24DB FF FF FF FF 
2551   24DF FF FF FF FF 
2551   24E3 FF FF FF FF 
2551   24E7 FF FF FF FF 
2551   24EB FF FF FF FF 
2551   24EF FF FF FF FF 
2551   24F3 FF FF FF FF 
2551   24F7 FF FF FF FF 
2551   24FB FF FF FF FF 
2551   24FF FF FF FF FF 
2551   2503 FF FF FF FF 
2551   2507 FF FF FF FF 
2551   250B FF FF FF FF 
2551   250F FF FF FF FF 
2551   2513 FF FF FF FF 
2551   2517 FF FF FF FF 
2551   251B FF FF FF FF 
2551   251F FF FF FF FF 
2551   2523 FF FF FF FF 
2551   2527 FF FF FF FF 
2551   252B FF FF FF FF 
2551   252F FF FF FF FF 
2551   2533 FF FF FF FF 
2551   2537 FF FF FF FF 
2551   253B FF FF FF FF 
2551   253F FF FF FF FF 
2551   2543 FF FF FF FF 
2551   2547 FF FF FF FF 
2551   254B FF FF FF FF 
2551   254F FF FF FF FF 
2551   2553 FF FF FF FF 
2551   2557 FF FF FF FF 
2551   255B FF FF FF FF 
2551   255F FF FF FF FF 
2551   2563 FF FF FF FF 
2551   2567 FF FF FF FF 
2551   256B FF FF FF FF 
2551   256F FF FF FF FF 
2551   2573 FF FF FF FF 
2551   2577 FF FF FF FF 
2551   257B FF FF FF FF 
2551   257F FF FF FF FF 
2551   2583 FF FF FF FF 
2551   2587 FF FF FF FF 
2551   258B FF FF FF FF 
2551   258F FF FF FF FF 
2551   2593 FF FF FF FF 
2551   2597 FF FF FF FF 
2551   259B FF FF FF FF 
2551   259F FF FF FF FF 
2551   25A3 FF FF FF FF 
2551   25A7 FF FF FF FF 
2551   25AB FF FF FF FF 
2551   25AF FF FF FF FF 
2551   25B3 FF FF FF FF 
2551   25B7 FF FF FF FF 
2551   25BB FF FF FF FF 
2551   25BF FF FF FF FF 
2551   25C3 FF FF FF FF 
2551   25C7 FF FF FF FF 
2551   25CB FF FF FF FF 
2551   25CF FF FF FF FF 
2551   25D3 FF FF FF FF 
2551   25D7 FF FF FF FF 
2551   25DB FF FF FF FF 
2551   25DF FF FF FF FF 
2551   25E3 FF FF FF FF 
2551   25E7 FF FF FF FF 
2551   25EB FF FF FF FF 
2551   25EF FF FF FF FF 
2551   25F3 FF FF FF FF 
2551   25F7 FF FF FF FF 
2551   25FB FF FF FF FF 
2551   25FF FF FF FF FF 
2551   2603 FF FF FF FF 
2551   2607 FF FF FF FF 
2551   260B FF FF FF FF 
2551   260F FF FF FF FF 
2551   2613 FF FF FF FF 
2551   2617 FF FF FF FF 
2551   261B FF FF FF FF 
2551   261F FF FF FF FF 
2551   2623 FF FF FF FF 
2551   2627 FF FF FF FF 
2551   262B FF FF FF FF 
2551   262F FF FF FF FF 
2551   2633 FF FF FF FF 
2551   2637 FF FF FF FF 
2551   263B FF FF FF FF 
2551   263F FF FF FF FF 
2551   2643 FF FF FF FF 
2551   2647 FF FF FF FF 
2551   264B FF FF FF FF 
2551   264F FF FF FF FF 
2551   2653 FF FF FF FF 
2551   2657 FF FF FF FF 
2551   265B FF FF FF FF 
2551   265F FF FF FF FF 
2551   2663 FF FF FF FF 
2551   2667 FF FF FF FF 
2551   266B FF FF FF FF 
2551   266F FF FF FF FF 
2551   2673 FF FF FF FF 
2551   2677 FF FF FF FF 
2551   267B FF FF FF FF 
2551   267F FF FF FF FF 
2551   2683 FF FF FF FF 
2551   2687 FF FF FF FF 
2551   268B FF FF FF FF 
2551   268F FF FF FF FF 
2551   2693 FF FF FF FF 
2551   2697 FF FF FF FF 
2551   269B FF FF FF FF 
2551   269F FF FF FF FF 
2551   26A3 FF FF FF FF 
2551   26A7 FF FF FF FF 
2551   26AB FF FF FF FF 
2551   26AF FF FF FF FF 
2551   26B3 FF FF FF FF 
2551   26B7 FF FF FF FF 
2551   26BB FF FF FF FF 
2551   26BF FF FF FF FF 
2551   26C3 FF FF FF FF 
2551   26C7 FF FF FF FF 
2551   26CB FF FF FF FF 
2551   26CF FF FF FF FF 
2551   26D3 FF FF FF FF 
2551   26D7 FF FF FF FF 
2551   26DB FF FF FF FF 
2552   26DF             
2553   26DF FF FF FF FF scrap_sector:		.fill 512		; scrap sector
2553   26E3 FF FF FF FF 
2553   26E7 FF FF FF FF 
2553   26EB FF FF FF FF 
2553   26EF FF FF FF FF 
2553   26F3 FF FF FF FF 
2553   26F7 FF FF FF FF 
2553   26FB FF FF FF FF 
2553   26FF FF FF FF FF 
2553   2703 FF FF FF FF 
2553   2707 FF FF FF FF 
2553   270B FF FF FF FF 
2553   270F FF FF FF FF 
2553   2713 FF FF FF FF 
2553   2717 FF FF FF FF 
2553   271B FF FF FF FF 
2553   271F FF FF FF FF 
2553   2723 FF FF FF FF 
2553   2727 FF FF FF FF 
2553   272B FF FF FF FF 
2553   272F FF FF FF FF 
2553   2733 FF FF FF FF 
2553   2737 FF FF FF FF 
2553   273B FF FF FF FF 
2553   273F FF FF FF FF 
2553   2743 FF FF FF FF 
2553   2747 FF FF FF FF 
2553   274B FF FF FF FF 
2553   274F FF FF FF FF 
2553   2753 FF FF FF FF 
2553   2757 FF FF FF FF 
2553   275B FF FF FF FF 
2553   275F FF FF FF FF 
2553   2763 FF FF FF FF 
2553   2767 FF FF FF FF 
2553   276B FF FF FF FF 
2553   276F FF FF FF FF 
2553   2773 FF FF FF FF 
2553   2777 FF FF FF FF 
2553   277B FF FF FF FF 
2553   277F FF FF FF FF 
2553   2783 FF FF FF FF 
2553   2787 FF FF FF FF 
2553   278B FF FF FF FF 
2553   278F FF FF FF FF 
2553   2793 FF FF FF FF 
2553   2797 FF FF FF FF 
2553   279B FF FF FF FF 
2553   279F FF FF FF FF 
2553   27A3 FF FF FF FF 
2553   27A7 FF FF FF FF 
2553   27AB FF FF FF FF 
2553   27AF FF FF FF FF 
2553   27B3 FF FF FF FF 
2553   27B7 FF FF FF FF 
2553   27BB FF FF FF FF 
2553   27BF FF FF FF FF 
2553   27C3 FF FF FF FF 
2553   27C7 FF FF FF FF 
2553   27CB FF FF FF FF 
2553   27CF FF FF FF FF 
2553   27D3 FF FF FF FF 
2553   27D7 FF FF FF FF 
2553   27DB FF FF FF FF 
2553   27DF FF FF FF FF 
2553   27E3 FF FF FF FF 
2553   27E7 FF FF FF FF 
2553   27EB FF FF FF FF 
2553   27EF FF FF FF FF 
2553   27F3 FF FF FF FF 
2553   27F7 FF FF FF FF 
2553   27FB FF FF FF FF 
2553   27FF FF FF FF FF 
2553   2803 FF FF FF FF 
2553   2807 FF FF FF FF 
2553   280B FF FF FF FF 
2553   280F FF FF FF FF 
2553   2813 FF FF FF FF 
2553   2817 FF FF FF FF 
2553   281B FF FF FF FF 
2553   281F FF FF FF FF 
2553   2823 FF FF FF FF 
2553   2827 FF FF FF FF 
2553   282B FF FF FF FF 
2553   282F FF FF FF FF 
2553   2833 FF FF FF FF 
2553   2837 FF FF FF FF 
2553   283B FF FF FF FF 
2553   283F FF FF FF FF 
2553   2843 FF FF FF FF 
2553   2847 FF FF FF FF 
2553   284B FF FF FF FF 
2553   284F FF FF FF FF 
2553   2853 FF FF FF FF 
2553   2857 FF FF FF FF 
2553   285B FF FF FF FF 
2553   285F FF FF FF FF 
2553   2863 FF FF FF FF 
2553   2867 FF FF FF FF 
2553   286B FF FF FF FF 
2553   286F FF FF FF FF 
2553   2873 FF FF FF FF 
2553   2877 FF FF FF FF 
2553   287B FF FF FF FF 
2553   287F FF FF FF FF 
2553   2883 FF FF FF FF 
2553   2887 FF FF FF FF 
2553   288B FF FF FF FF 
2553   288F FF FF FF FF 
2553   2893 FF FF FF FF 
2553   2897 FF FF FF FF 
2553   289B FF FF FF FF 
2553   289F FF FF FF FF 
2553   28A3 FF FF FF FF 
2553   28A7 FF FF FF FF 
2553   28AB FF FF FF FF 
2553   28AF FF FF FF FF 
2553   28B3 FF FF FF FF 
2553   28B7 FF FF FF FF 
2553   28BB FF FF FF FF 
2553   28BF FF FF FF FF 
2553   28C3 FF FF FF FF 
2553   28C7 FF FF FF FF 
2553   28CB FF FF FF FF 
2553   28CF FF FF FF FF 
2553   28D3 FF FF FF FF 
2553   28D7 FF FF FF FF 
2553   28DB FF FF FF FF 
2554   28DF 00          transient_area:		.db 0			; beginning of the transient memory area. used for disk reads and other purposes		
2555   28E0             
2556   28E0             
2557   28E0             .end
tasm: Number of errors = 0
