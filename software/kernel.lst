0001   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002   0000             ; KERNEL
0003   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0005   0000             ; MEMORY MAP
0006   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007   0000             ; 0000		ROM BEGIN
0008   0000             ; ....
0009   0000             ; 7FFF		ROM END
0010   0000             ;
0011   0000             ; 8000		RAM begin
0012   0000             ; ....
0013   0000             ; F7FF		Stack root
0014   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0015   0000             ; I/O MAP
0016   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0017   0000             ; FF80		UART 0		(16550)
0018   0000             ; FF90		UART 1		(16550)
0019   0000             ; FFA0		RTC		(M48T02)
0020   0000             ; FFB0		PIO 0		(8255)
0021   0000             ; FFC0		PIO 1		(8255)
0022   0000             ; FFD0		IDE		(Compact Flash / PATA)
0023   0000             ; FFE0		Timer		(8253)
0024   0000             ; FFF0		BIOS CONFIGURATION NV-RAM STORE AREA
0025   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026   0000             ; SYSTEM CONSTANTS / EQUATIONS
0027   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028   0000             _UART0_DATA			.equ $FF80				; data
0029   0000             _UART0_DLAB_0		.equ $FF80				; divisor latch low byte
0030   0000             _UART0_DLAB_1		.equ $FF81				; divisor latch high byte
0031   0000             _UART0_IER			.equ $FF81				; Interrupt enable register
0032   0000             _UART0_FCR			.equ $FF82				; FIFO control register
0033   0000             _UART0_LCR			.equ $FF83				; line control register
0034   0000             _UART0_LSR			.equ $FF85				; line status register
0035   0000             
0036   0000             _IDE_BASE			.equ $FFD0				; IDE BASE
0037   0000             _IDE_R0				.equ _IDE_BASE + 0		; DATA PORT
0038   0000             _IDE_R1				.equ _IDE_BASE + 1		; READ: ERROR CODE, WRITE: FEATURE
0039   0000             _IDE_R2				.equ _IDE_BASE + 2		; NUMBER OF SECTORS TO TRANSFER
0040   0000             _IDE_R3				.equ _IDE_BASE + 3		; SECTOR ADDRESS LBA 0 [0:7]
0041   0000             _IDE_R4				.equ _IDE_BASE + 4		; SECTOR ADDRESS LBA 1 [8:15]
0042   0000             _IDE_R5				.equ _IDE_BASE + 5		; SECTOR ADDRESS LBA 2 [16:23]
0043   0000             _IDE_R6				.equ _IDE_BASE + 6		; SECTOR ADDRESS LBA 3 [24:27 (LSB)]
0044   0000             _IDE_R7				.equ _IDE_BASE + 7		; READ: STATUS, WRITE: COMMAND
0045   0000             
0046   0000             _7SEG_DISPLAY		.equ $FFB0				; BIOS POST CODE HEX DISPLAY (2 DIGITS)
0047   0000             _BIOS_POST_CTRL		.equ $FFB3				; BIOS POST DISPLAY CONTROL REGISTER, 80h = As Output
0048   0000             _PIO_A				.equ $FFB0		
0049   0000             _PIO_B				.equ $FFB1
0050   0000             _PIO_C				.equ $FFB2
0051   0000             _PIO_CONTROL		.equ $FFB3				; PIO CONTROL PORT
0052   0000             
0053   0000             _TIMER_C_0			.equ $FFE0				; TIMER COUNTER 0
0054   0000             _TIMER_C_1			.equ $FFE1				; TIMER COUNTER 1
0055   0000             _TIMER_C_2			.equ $FFE2				; TIMER COUNTER 2
0056   0000             _TIMER_CTRL			.equ $FFE3				; TIMER CONTROL REGISTER
0057   0000             
0058   0000             STACK_BEGIN			.equ $F7FF				; beginning of stack
0059   0000             FIFO_SIZE			.equ (1024*2)
0060   0000             
0061   0000             PROC_TEXT_ORG		.equ $400
0062   0000             NULL				.equ 0
0063   0000             
0064   0000             
0065   0000             ; for the next iteration:
0066   0000             ; boot-sector(1) | kernel-sectors(32) | inode-bitmap | rawdata-bitmap | inode-table | raw-disk-data
0067   0000             ;
0068   0000             ; inode-table format:
0069   0000             ;	file-type(f, d)
0070   0000             ;	permissons
0071   0000             ;	link-count
0072   0000             ;	filesize
0073   0000             ;	time-stamps
0074   0000             ;	15 data block pointers
0075   0000             ;	single-indirect pointer
0076   0000             ;
0077   0000             
0078   0000             ; for now:
0079   0000             ; boot-sector(1) | kernel-sectors(32) | rawdata-bitmap() | raw-disk-data
0080   0000             ;
0081   0000             ; filename (24)
0082   0000             ; attributes (1) 			:|0|0|file_type(3bits)|x|w|r|
0083   0000             ; LBA (2)					: location of raw data for file entry, or dirID for directory entry
0084   0000             ; size (2)					: filesize
0085   0000             ; day (1)					 
0086   0000             ; month (1)
0087   0000             ; year (1)
0088   0000             ; packet size = 32 bytes	: total packet size in bytes
0089   0000             ;
0090   0000             FST_ENTRY_SIZE			.equ 32
0091   0000             FST_FILES_PER_SECT		.equ (512 / FST_ENTRY_SIZE)
0092   0000             FST_FILES_PER_DIR		.equ 16
0093   0000             FST_NBR_DIRECTORIES		.equ 64
0094   0000             						; 1 sector for header, the rest is for the list of files/dirs
0095   0000             FST_SECTORS_PER_DIR		.equ (1 + (FST_ENTRY_SIZE * FST_FILES_PER_DIR / 512))		
0096   0000             FST_TOTAL_SECTORS		.equ (FST_SECTORS_PER_DIR * FST_NBR_DIRECTORIES)
0097   0000             FST_LBA_START			.equ 32
0098   0000             FST_LBA_END				.equ (FST_LBA_START + FST_TOTAL_SECTORS - 1)
0099   0000             
0100   0000             FS_NBR_FILES 			.equ (FST_NBR_DIRECTORIES * FST_FILES_PER_DIR)
0101   0000             FS_SECTORS_PER_FILE		.equ 32				; the first sector is always a header with a NULL parameter (first byte)
0102   0000             											; so that we know which blocks are free or taken
0103   0000             FS_FILE_SIZE			.equ (FS_SECTORS_PER_FILE * 512)									
0104   0000             FS_TOTAL_SECTORS		.equ (FS_NBR_FILES * FS_SECTORS_PER_FILE)
0105   0000             FS_LBA_START			.equ (FST_LBA_END + 1)
0106   0000             FS_LBA_END				.equ (FS_LBA_START + FS_NBR_FILES - 1)
0107   0000             
0108   0000             CF_CARD_LBA_SIZE		.equ $800			; temporary small size
0109   0000             
0110   0000             ROOT_dirID:				.equ FST_LBA_START
0111   0000             
0112   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113   0000             ; GLOBAL SYSTEM VARIABLES
0114   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115   0000             
0116   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0117   0000             ; EXTERNAL INTERRUPT TABLE
0118   0000             ; highest priority at lowest address
0119   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0120   0000 7E 07       .dw int_0
0121   0002 7F 07       .dw int_1
0122   0004 80 07       .dw int_2
0123   0006 81 07       .dw int_3
0124   0008 82 07       .dw int_4
0125   000A 83 07       .dw int_5
0126   000C 84 07       .dw int_6
0127   000E D0 07       .dw int_7
0128   0010             
0129   0010             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130   0010             ; RESET VECTOR DECLARATION
0131   0010             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0132   0010 88 14       .dw KERNEL_RESET_VECTOR
0133   0012             
0134   0012             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0135   0012             ;; EXCEPTION VECTOR TABLE
0136   0012             ;; total of 7 entries, starting at address $0012
0137   0012             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138   0012 9A 08       .dw trap_privilege
0139   0014 B7 09       .dw trap_div_zero
0140   0016 C4 09       .dw undefined_opcode
0141   0018 00 00       .dw NULL
0142   001A 00 00       .dw NULL
0143   001C 00 00       .dw NULL
0144   001E 00 00       .dw NULL
0145   0020             
0146   0020             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0147   0020             ;; SYSTEM CALL VECTOR TABLE
0148   0020             ;; starts at address $0020
0149   0020             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0150   0020 A6 08       .dw trap_breakpoint
0151   0022 C5 09       .dw rtc_services						
0152   0024 E8 0A       .dw IDE_services_kernel
0153   0026 A8 0B       .dw io_services
0154   0028 34 0C       .dw file_system
0155   002A 5B 15       .dw cmd_fork
0156   002C 5F 08       .dw list_procs
0157   002E F7 09       .dw datetime_services
0158   0030 1B 08       .dw syscall_reboot
0159   0032 25 15       .dw cmd_pause_proc
0160   0034 27 08       .dw resume_proc
0161   0036 E2 14       .dw cmd_terminate_proc
0162   0038 09 08       .dw cmd_system
0163   003A C1 0C       .dw cmd_boot_installer
0164   003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0165   003C             ;; FILE INCLUDES
0166   003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0167   003C             .include "bios.exp"	; to obtain the BIOS_RESET_VECTOR location (for reboots)
0001+  003C             BIOS_RESET_VECTOR .EQU  $01c0
0002+  003C             IDE_buffer       .EQU  $8204
0003+  003C             boot_origin      .EQU  $8004
0004+  003C             bios_uart        .EQU  $0002
0005+  003C             bios_ide         .EQU  $0003
0168   003C             .include "stdio.asm"
0001+  003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  003C             ; stdio.s
0003+  003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  003C             .include "string.asm"
0001++ 003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 003C             ; string.s
0003++ 003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 003C             
0005++ 003C             
0006++ 003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 003C             ; strrev
0008++ 003C             ; reverse a string
0009++ 003C             ; D = string address
0010++ 003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 003C             ; 01234
0012++ 003C             strrev:
0013++ 003C 4B          	pusha
0014++ 003D 07 83 00    	call strlen	; length in C
0015++ 0040 12          	mov a, c
0016++ 0041 AF 01 00    	cmp a, 1
0017++ 0044 D0 5E 00    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0047 7D          	dec a
0019++ 0048 FD 4E       	mov si, d	; beginning of string
0020++ 004A FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 004C 59          	add d, a	; end of string
0022++ 004D 12          	mov a, c
0023++ 004E FD 9B       	shr a		; divide by 2
0024++ 0050 39          	mov c, a	; C now counts the steps
0025++ 0051             strrev_L0:
0026++ 0051 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0052 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0053 3E          	mov [d], al	; store left char into right side
0029++ 0054 1B          	mov al, bl
0030++ 0055 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0056 7E          	dec c
0032++ 0057 7F          	dec d
0033++ 0058 C2 00 00    	cmp c, 0
0034++ 005B C7 51 00    	jne strrev_L0
0035++ 005E             strrev_end:
0036++ 005E 4C          	popa
0037++ 005F 09          	ret
0038++ 0060             	
0039++ 0060             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0060             ; strchr
0041++ 0060             ; search string in D for char in AL
0042++ 0060             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0060             strchr:
0044++ 0060             strchr_L0:
0045++ 0060 32          	mov bl, [d]
0046++ 0061 C1 00       	cmp bl, 0
0047++ 0063 C6 6E 00    	je strchr_end
0048++ 0066 BA          	cmp al, bl
0049++ 0067 C6 6E 00    	je strchr_end
0050++ 006A 79          	inc d
0051++ 006B 0A 60 00    	jmp strchr_L0
0052++ 006E             strchr_end:
0053++ 006E 1B          	mov al, bl
0054++ 006F 09          	ret
0055++ 0070             
0056++ 0070             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0070             ; strstr
0058++ 0070             ; find sub-string
0059++ 0070             ; str1 in SI
0060++ 0070             ; str2 in DI
0061++ 0070             ; SI points to end of source string
0062++ 0070             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0070             strstr:
0064++ 0070 DB          	push al
0065++ 0071 DA          	push d
0066++ 0072 E3          	push di
0067++ 0073             strstr_loop:
0068++ 0073 F3          	cmpsb					; compare a byte of the strings
0069++ 0074 C7 7F 00    	jne strstr_ret
0070++ 0077 FC 00 00    	lea d, [di + 0]
0071++ 007A BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 007C C7 73 00    	jne strstr_loop				; equal chars but not at end
0073++ 007F             strstr_ret:
0074++ 007F F0          	pop di
0075++ 0080 E7          	pop d
0076++ 0081 E8          	pop al
0077++ 0082 09          	ret
0078++ 0083             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0083             ; length of null terminated string
0080++ 0083             ; result in C
0081++ 0083             ; pointer in D
0082++ 0083             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0083             strlen:
0084++ 0083 DA          	push d
0085++ 0084 38 00 00    	mov c, 0
0086++ 0087             strlen_L1:
0087++ 0087 BD 00       	cmp byte [d], 0
0088++ 0089 C6 91 00    	je strlen_ret
0089++ 008C 79          	inc d
0090++ 008D 78          	inc c
0091++ 008E 0A 87 00    	jmp strlen_L1
0092++ 0091             strlen_ret:
0093++ 0091 E7          	pop d
0094++ 0092 09          	ret
0095++ 0093             
0096++ 0093             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0093             ; STRCMP
0098++ 0093             ; compare two strings
0099++ 0093             ; str1 in SI
0100++ 0093             ; str2 in DI
0101++ 0093             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0093             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0093             strcmp:
0104++ 0093 DB          	push al
0105++ 0094 DA          	push d
0106++ 0095 E3          	push di
0107++ 0096 E2          	push si
0108++ 0097             strcmp_loop:
0109++ 0097 F3          	cmpsb					; compare a byte of the strings
0110++ 0098 C7 A3 00    	jne strcmp_ret
0111++ 009B FB FF FF    	lea d, [si +- 1]
0112++ 009E BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 00A0 C7 97 00    	jne strcmp_loop				; equal chars but not at end
0114++ 00A3             strcmp_ret:
0115++ 00A3 EF          	pop si
0116++ 00A4 F0          	pop di
0117++ 00A5 E7          	pop d
0118++ 00A6 E8          	pop al
0119++ 00A7 09          	ret
0120++ 00A8             
0121++ 00A8             
0122++ 00A8             ; STRCPY
0123++ 00A8             ; copy null terminated string from SI to DI
0124++ 00A8             ; source in SI
0125++ 00A8             ; destination in DI
0126++ 00A8             strcpy:
0127++ 00A8 E2          	push si
0128++ 00A9 E3          	push di
0129++ 00AA DB          	push al
0130++ 00AB             strcpy_L1:
0131++ 00AB F6          	lodsb
0132++ 00AC F7          	stosb
0133++ 00AD B9 00       	cmp al, 0
0134++ 00AF C7 AB 00    	jne strcpy_L1
0135++ 00B2             strcpy_end:
0136++ 00B2 E8          	pop al
0137++ 00B3 F0          	pop di
0138++ 00B4 EF          	pop si
0139++ 00B5 09          	ret
0140++ 00B6             
0141++ 00B6             ; STRCAT
0142++ 00B6             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 00B6             ; source in SI
0144++ 00B6             ; destination in DI
0145++ 00B6             strcat:
0146++ 00B6 E2          	push si
0147++ 00B7 E3          	push di
0148++ 00B8 D7          	push a
0149++ 00B9 DA          	push d
0150++ 00BA 50          	mov a, di
0151++ 00BB 3C          	mov d, a
0152++ 00BC             strcat_goto_end_L1:
0153++ 00BC BD 00       	cmp byte[d], 0
0154++ 00BE C6 C5 00    	je strcat_start
0155++ 00C1 79          	inc d
0156++ 00C2 0A BC 00    	jmp strcat_goto_end_L1
0157++ 00C5             strcat_start:
0158++ 00C5 FD 50       	mov di, d
0159++ 00C7             strcat_L1:
0160++ 00C7 F6          	lodsb
0161++ 00C8 F7          	stosb
0162++ 00C9 B9 00       	cmp al, 0
0163++ 00CB C7 C7 00    	jne strcat_L1
0164++ 00CE             strcat_end:
0165++ 00CE E7          	pop d
0166++ 00CF E4          	pop a
0167++ 00D0 F0          	pop di
0168++ 00D1 EF          	pop si
0169++ 00D2 09          	ret
0005+  00D3             
0006+  00D3 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  00D7 34 35 36 37 
0006+  00DB 38 39 41 42 
0006+  00DF 43 44 45 46 
0007+  00E3             
0008+  00E3 01 00       table_power:.dw 1
0009+  00E5 0A 00       			.dw 10
0010+  00E7 64 00       			.dw 100
0011+  00E9 E8 03       			.dw 1000
0012+  00EB 10 27       			.dw 10000
0013+  00ED             
0014+  00ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0015+  00ED             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0016+  00ED             ; ASCII in BL
0017+  00ED             ; result in AL
0018+  00ED             ; ascii for F = 0100 0110
0019+  00ED             ; ascii for 9 = 0011 1001
0020+  00ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0021+  00ED             hex_ascii_encode:
0022+  00ED 1B          	mov al, bl
0023+  00EE 93 40       	test al, $40				; test if letter or number
0024+  00F0 C7 F6 00    	jnz hex_letter
0025+  00F3 87 0F       	and al, $0F				; get number
0026+  00F5 09          	ret
0027+  00F6             hex_letter:
0028+  00F6 87 0F       	and al, $0F				; get letter
0029+  00F8 6A 09       	add al, 9
0030+  00FA 09          	ret
0031+  00FB             
0032+  00FB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0033+  00FB             ; ATOI
0034+  00FB             ; 2 letter hex string in B
0035+  00FB             ; 8bit integer returned in AL
0036+  00FB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0037+  00FB             atoi:
0038+  00FB D8          	push b
0039+  00FC 07 ED 00    	call hex_ascii_encode			; convert BL to 4bit code in AL
0040+  00FF 30          	mov bl, bh
0041+  0100 DB          	push al					; save a
0042+  0101 07 ED 00    	call hex_ascii_encode
0043+  0104 EA          	pop bl	
0044+  0105 FD 9E 04    	shl al, 4
0045+  0108 8C          	or al, bl
0046+  0109 E5          	pop b
0047+  010A 09          	ret	
0048+  010B             
0049+  010B             
0050+  010B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  010B             ; printf
0052+  010B             ; no need for explanations!
0053+  010B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0054+  010B             printf:
0055+  010B 09          	ret
0056+  010C             
0057+  010C             
0058+  010C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  010C             ; scanf
0060+  010C             ; no need for explanations!
0061+  010C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  010C             scanf:
0063+  010C 09          	ret
0064+  010D             
0065+  010D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  010D             ; ITOA
0067+  010D             ; 8bit value in BL
0068+  010D             ; 2 byte ASCII result in A
0069+  010D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0070+  010D             itoa:
0071+  010D DA          	push d
0072+  010E D8          	push b
0073+  010F A7 00       	mov bh, 0
0074+  0111 FD A4 04    	shr bl, 4	
0075+  0114 74          	mov d, b
0076+  0115 1F D3 00    	mov al, [d + s_hex_digits]
0077+  0118 23          	mov ah, al
0078+  0119             	
0079+  0119 E5          	pop b
0080+  011A D8          	push b
0081+  011B A7 00       	mov bh, 0
0082+  011D FD 87 0F    	and bl, $0F
0083+  0120 74          	mov d, b
0084+  0121 1F D3 00    	mov al, [d + s_hex_digits]
0085+  0124 E5          	pop b
0086+  0125 E7          	pop d
0087+  0126 09          	ret
0088+  0127             
0089+  0127             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0090+  0127             ; HEX STRING TO BINARY
0091+  0127             ; di = destination address
0092+  0127             ; si = source
0093+  0127             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0094+  0127             hex_to_int:
0095+  0127             hex_to_int_L1:
0096+  0127 F6          	lodsb					; load from [SI] to AL
0097+  0128 B9 00       	cmp al, 0				; check if ASCII 0
0098+  012A C6 37 01    	jz hex_to_int_ret
0099+  012D 36          	mov bh, al
0100+  012E F6          	lodsb
0101+  012F 2F          	mov bl, al
0102+  0130 07 FB 00    	call atoi				; convert ASCII byte in B to int (to AL)
0103+  0133 F7          	stosb					; store AL to [DI]
0104+  0134 0A 27 01    	jmp hex_to_int_L1
0105+  0137             hex_to_int_ret:
0106+  0137 09          	ret		
0107+  0138             
0108+  0138             
0109+  0138             
0110+  0138             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  0138             ; GETCHAR
0112+  0138             ; char in ah
0113+  0138             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0114+  0138             getchar:
0115+  0138 DB          	push al
0116+  0139             getchar_retry:
0117+  0139 FD 0C       	sti
0118+  013B 19 01       	mov al, 1
0119+  013D 05 03       	syscall sys_io			; receive in AH
0120+  013F B9 00       	cmp al, 0			; check if any char was receive
0121+  0141 C6 39 01    	je getchar_retry
0122+  0144 E8          	pop al
0123+  0145 09          	ret
0124+  0146             
0125+  0146             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0126+  0146             ; PUTCHAR
0127+  0146             ; char in ah
0128+  0146             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  0146             putchar:
0130+  0146 D7          	push a
0131+  0147 19 00       	mov al, 0
0132+  0149 05 03       	syscall sys_io			; char in AH
0133+  014B E4          	pop a
0134+  014C 09          	ret
0135+  014D             
0136+  014D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0137+  014D             ;; INPUT A STRING
0138+  014D             ;; terminates with null
0139+  014D             ;; pointer in D
0140+  014D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  014D             gets:
0142+  014D D7          	push a
0143+  014E DA          	push d
0144+  014F             gets_loop:
0145+  014F FD 0C       	sti
0146+  0151 19 01       	mov al, 1
0147+  0153 05 03       	syscall sys_io			; receive in AH
0148+  0155 B9 00       	cmp al, 0				; check error code (AL)
0149+  0157 C6 4F 01    	je gets_loop			; if no char received, retry
0150+  015A             
0151+  015A 76 1B       	cmp ah, 27
0152+  015C C6 78 01    	je gets_telnet_escape
0153+  015F 76 0A       	cmp ah, $0A				; LF
0154+  0161 C6 D1 01    	je gets_end
0155+  0164 76 5C       	cmp ah, $5C				; '\\'
0156+  0166 C6 A8 01    	je gets_escape
0157+  0169             	
0158+  0169 76 08       	cmp ah, $08			; check for backspace
0159+  016B C6 74 01    	je gets_backspace
0160+  016E             
0161+  016E 1A          	mov al, ah
0162+  016F 3E          	mov [d], al
0163+  0170 79          	inc d
0164+  0171 0A 4F 01    	jmp gets_loop
0165+  0174             gets_backspace:
0166+  0174 7F          	dec d
0167+  0175 0A 4F 01    	jmp gets_loop
0168+  0178             gets_telnet_escape:
0169+  0178 FD 0C       	sti
0170+  017A 19 01       	mov al, 1
0171+  017C 05 03       	syscall sys_io				; receive in AH without echo
0172+  017E B9 00       	cmp al, 0					; check error code (AL)
0173+  0180 C6 78 01    	je gets_telnet_escape		; if no char received, retry
0174+  0183 76 5B       	cmp ah, '['
0175+  0185 C7 4F 01    	jne gets_loop
0176+  0188             gets_telnet_escape_phase2:
0177+  0188 FD 0C       	sti
0178+  018A 19 01       	mov al, 1
0179+  018C 05 03       	syscall sys_io					; receive in AH without echo
0180+  018E B9 00       	cmp al, 0						; check error code (AL)
0181+  0190 C6 88 01    	je gets_telnet_escape_phase2	; if no char received, retry
0182+  0193 76 44       	cmp ah, 'D'
0183+  0195 C6 A0 01    	je gets_left_arrow
0184+  0198 76 43       	cmp ah, 'C'
0185+  019A C6 A4 01    	je gets_right_arrow
0186+  019D 0A 4F 01    	jmp gets_loop
0187+  01A0             gets_left_arrow:
0188+  01A0 7F          	dec d
0189+  01A1 0A 4F 01    	jmp gets_loop
0190+  01A4             gets_right_arrow:
0191+  01A4 79          	inc d
0192+  01A5 0A 4F 01    	jmp gets_loop
0193+  01A8             gets_escape:
0194+  01A8 FD 0C       	sti
0195+  01AA 19 01       	mov al, 1
0196+  01AC 05 03       	syscall sys_io			; receive in AH
0197+  01AE B9 00       	cmp al, 0				; check error code (AL)
0198+  01B0 C6 A8 01    	je gets_escape			; if no char received, retry
0199+  01B3 76 6E       	cmp ah, 'n'
0200+  01B5 C6 C3 01    	je gets_LF
0201+  01B8 76 72       	cmp ah, 'r'
0202+  01BA C6 CA 01    	je gets_CR
0203+  01BD 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0204+  01BE 3E          	mov [d], al
0205+  01BF 79          	inc d
0206+  01C0 0A 4F 01    	jmp gets_loop
0207+  01C3             gets_LF:
0208+  01C3 19 0A       	mov al, $0A
0209+  01C5 3E          	mov [d], al
0210+  01C6 79          	inc d
0211+  01C7 0A 4F 01    	jmp gets_loop
0212+  01CA             gets_CR:
0213+  01CA 19 0D       	mov al, $0D
0214+  01CC 3E          	mov [d], al
0215+  01CD 79          	inc d
0216+  01CE 0A 4F 01    	jmp gets_loop
0217+  01D1             gets_end:
0218+  01D1 19 00       	mov al, 0
0219+  01D3 3E          	mov [d], al				; terminate string
0220+  01D4 E7          	pop d
0221+  01D5 E4          	pop a
0222+  01D6 09          	ret
0223+  01D7             
0224+  01D7             
0225+  01D7             
0226+  01D7             
0227+  01D7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0228+  01D7             ;; INPUT TEXT
0229+  01D7             ;; terminated with CTRL+D
0230+  01D7             ;; pointer in D
0231+  01D7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0232+  01D7             gettxt:
0233+  01D7 D7          	push a
0234+  01D8 DA          	push d
0235+  01D9             gettxt_loop:
0236+  01D9 19 01       	mov al, 1
0237+  01DB 05 03       	syscall sys_io			; receive in AH
0238+  01DD B9 00       	cmp al, 0				; check error code (AL)
0239+  01DF C6 D9 01    	je gettxt_loop		; if no char received, retry
0240+  01E2 76 04       	cmp ah, 4			; EOT
0241+  01E4 C6 22 02    	je gettxt_end
0242+  01E7 76 08       	cmp ah, $08			; check for backspace
0243+  01E9 C6 1E 02    	je gettxt_backspace
0244+  01EC 76 5C       	cmp ah, $5C				; '\\'
0245+  01EE C6 F7 01    	je gettxt_escape
0246+  01F1 1A          	mov al, ah
0247+  01F2 3E          	mov [d], al
0248+  01F3 79          	inc d
0249+  01F4 0A D9 01    	jmp gettxt_loop
0250+  01F7             gettxt_escape:
0251+  01F7 19 01       	mov al, 1
0252+  01F9 05 03       	syscall sys_io			; receive in AH
0253+  01FB B9 00       	cmp al, 0				; check error code (AL)
0254+  01FD C6 F7 01    	je gettxt_escape		; if no char received, retry
0255+  0200 76 6E       	cmp ah, 'n'
0256+  0202 C6 10 02    	je gettxt_LF
0257+  0205 76 72       	cmp ah, 'r'
0258+  0207 C6 17 02    	je gettxt_CR
0259+  020A 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0260+  020B 3E          	mov [d], al
0261+  020C 79          	inc d
0262+  020D 0A D9 01    	jmp gettxt_loop
0263+  0210             gettxt_LF:
0264+  0210 19 0A       	mov al, $0A
0265+  0212 3E          	mov [d], al
0266+  0213 79          	inc d
0267+  0214 0A D9 01    	jmp gettxt_loop
0268+  0217             gettxt_CR:
0269+  0217 19 0D       	mov al, $0D
0270+  0219 3E          	mov [d], al
0271+  021A 79          	inc d
0272+  021B 0A D9 01    	jmp gettxt_loop
0273+  021E             gettxt_backspace:
0274+  021E 7F          	dec d
0275+  021F 0A D9 01    	jmp gettxt_loop
0276+  0222             gettxt_end:
0277+  0222 19 00       	mov al, 0
0278+  0224 3E          	mov [d], al				; terminate string
0279+  0225 E7          	pop d
0280+  0226 E4          	pop a
0281+  0227 09          	ret
0282+  0228             
0283+  0228             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0284+  0228             ; PRINT NEW LINE
0285+  0228             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0286+  0228             printnl:
0287+  0228 D7          	push a
0288+  0229 10 00 0A    	mov a, $0A00
0289+  022C 05 03       	syscall sys_io
0290+  022E 10 00 0D    	mov a, $0D00
0291+  0231 05 03       	syscall sys_io
0292+  0233 E4          	pop a
0293+  0234 09          	ret
0294+  0235             
0295+  0235             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0296+  0235             ; strtoint
0297+  0235             ; 4 digit hex string number in d
0298+  0235             ; integer returned in A
0299+  0235             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0300+  0235             strtointx:
0301+  0235 D8          	push b
0302+  0236 32          	mov bl, [d]
0303+  0237 37          	mov bh, bl
0304+  0238 33 01 00    	mov bl, [d + 1]
0305+  023B 07 FB 00    	call atoi				; convert to int in AL
0306+  023E 23          	mov ah, al				; move to AH
0307+  023F 33 02 00    	mov bl, [d + 2]
0308+  0242 37          	mov bh, bl
0309+  0243 33 03 00    	mov bl, [d + 3]
0310+  0246 07 FB 00    	call atoi				; convert to int in AL
0311+  0249 E5          	pop b
0312+  024A 09          	ret
0313+  024B             
0314+  024B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0315+  024B             ; strtoint
0316+  024B             ; 5 digit base10 string number in d
0317+  024B             ; integer returned in A
0318+  024B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0319+  024B             strtoint:
0320+  024B E2          	push si
0321+  024C D8          	push b
0322+  024D D9          	push c
0323+  024E DA          	push d
0324+  024F 07 83 00    	call strlen			; get string length in C
0325+  0252 7E          	dec c
0326+  0253 FD 4E       	mov si, d
0327+  0255 12          	mov a, c
0328+  0256 FD 99       	shl a
0329+  0258 3B E3 00    	mov d, table_power
0330+  025B 59          	add d, a
0331+  025C 38 00 00    	mov c, 0
0332+  025F             strtoint_L0:
0333+  025F F6          	lodsb			; load ASCII to al
0334+  0260 B9 00       	cmp al, 0
0335+  0262 C6 75 02    	je strtoint_end
0336+  0265 6F 30       	sub al, $30		; make into integer
0337+  0267 22 00       	mov ah, 0
0338+  0269 2A          	mov b, [d]
0339+  026A AC          	mul a, b			; result in B since it fits in 16bits
0340+  026B 11          	mov a, b
0341+  026C 28          	mov b, c
0342+  026D 54          	add a, b
0343+  026E 39          	mov c, a
0344+  026F 63 02 00    	sub d, 2
0345+  0272 0A 5F 02    	jmp strtoint_L0
0346+  0275             strtoint_end:
0347+  0275 12          	mov a, c
0348+  0276 E7          	pop d
0349+  0277 E6          	pop c
0350+  0278 E5          	pop b
0351+  0279 EF          	pop si
0352+  027A 09          	ret
0353+  027B             
0354+  027B             
0355+  027B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  027B             ; PRINT NULL TERMINATED STRING
0357+  027B             ; pointer in D
0358+  027B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  027B             puts:
0360+  027B D7          	push a
0361+  027C DA          	push d
0362+  027D             puts_L1:
0363+  027D 1E          	mov al, [d]
0364+  027E B9 00       	cmp al, 0
0365+  0280 C6 8C 02    	jz puts_END
0366+  0283 23          	mov ah, al
0367+  0284 19 00       	mov al, 0
0368+  0286 05 03       	syscall sys_io
0369+  0288 79          	inc d
0370+  0289 0A 7D 02    	jmp puts_L1
0371+  028C             puts_END:
0372+  028C E7          	pop d
0373+  028D E4          	pop a
0374+  028E 09          	ret
0375+  028F             
0376+  028F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0377+  028F             ; PRINT N SIZE STRING
0378+  028F             ; pointer in D
0379+  028F             ; size in C
0380+  028F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0381+  028F             putsn:
0382+  028F DB          	push al
0383+  0290 DA          	push d
0384+  0291 D9          	push c
0385+  0292             putsn_L0:
0386+  0292 1E          	mov al, [d]
0387+  0293 23          	mov ah, al
0388+  0294 19 00       	mov al, 0
0389+  0296 05 03       	syscall sys_io
0390+  0298 79          	inc d
0391+  0299 7E          	dec c	
0392+  029A C2 00 00    	cmp c, 0
0393+  029D C7 92 02    	jne putsn_L0
0394+  02A0             putsn_end:
0395+  02A0 E6          	pop c
0396+  02A1 E7          	pop d
0397+  02A2 E8          	pop al
0398+  02A3 09          	ret
0399+  02A4             
0400+  02A4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0401+  02A4             ; print 16bit decimal number
0402+  02A4             ; input number in A
0403+  02A4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  02A4             print_u16d:
0405+  02A4 D7          	push a
0406+  02A5 D8          	push b
0407+  02A6 26 10 27    	mov b, 10000
0408+  02A9 AE          	div a, b			; get 10000 coeff.
0409+  02AA 07 D0 02    	call print_zero_or_space
0410+  02AD 11          	mov a, b
0411+  02AE 26 E8 03    	mov b, 1000
0412+  02B1 AE          	div a, b			; get 10000 coeff.
0413+  02B2 07 D0 02    	call print_zero_or_space
0414+  02B5 11          	mov a, b
0415+  02B6 26 64 00    	mov b, 100
0416+  02B9 AE          	div a, b
0417+  02BA 07 D0 02    	call print_zero_or_space
0418+  02BD 11          	mov a, b
0419+  02BE 26 0A 00    	mov b, 10
0420+  02C1 AE          	div a, b
0421+  02C2 07 D0 02    	call print_zero_or_space
0422+  02C5 11          	mov a, b
0423+  02C6 6A 30       	add al, $30
0424+  02C8 23          	mov ah, al
0425+  02C9 19 00       	mov al, 0
0426+  02CB 05 03       	syscall sys_io	; print coeff
0427+  02CD E5          	pop b
0428+  02CE E4          	pop a
0429+  02CF 09          	ret
0430+  02D0             
0431+  02D0             
0432+  02D0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0433+  02D0             ; if A == 0, print space
0434+  02D0             ; else print A
0435+  02D0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  02D0             print_zero_or_space:
0437+  02D0             	; cmp a, 0
0438+  02D0             	; jne print_number
0439+  02D0             	; mov ah, $20
0440+  02D0             	; call putchar
0441+  02D0             	; ret
0442+  02D0             print_number:
0443+  02D0 6A 30       	add al, $30
0444+  02D2 23          	mov ah, al
0445+  02D3 07 46 01    	call putchar
0446+  02D6 09          	ret
0447+  02D7             
0448+  02D7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  02D7             ; PRINT 16BIT HEX INTEGER
0450+  02D7             ; integer value in reg B
0451+  02D7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0452+  02D7             print_u16x:
0453+  02D7 D7          	push a
0454+  02D8 D8          	push b
0455+  02D9 DD          	push bl
0456+  02DA 30          	mov bl, bh
0457+  02DB 07 0D 01    	call itoa				; convert bh to char in A
0458+  02DE 2F          	mov bl, al				; save al
0459+  02DF 19 00       	mov al, 0
0460+  02E1 05 03       	syscall sys_io				; display AH
0461+  02E3 24          	mov ah, bl				; retrieve al
0462+  02E4 19 00       	mov al, 0
0463+  02E6 05 03       	syscall sys_io				; display AL
0464+  02E8             
0465+  02E8 EA          	pop bl
0466+  02E9 07 0D 01    	call itoa				; convert bh to char in A
0467+  02EC 2F          	mov bl, al				; save al
0468+  02ED 19 00       	mov al, 0
0469+  02EF 05 03       	syscall sys_io				; display AH
0470+  02F1 24          	mov ah, bl				; retrieve al
0471+  02F2 19 00       	mov al, 0
0472+  02F4 05 03       	syscall sys_io				; display AL
0473+  02F6             
0474+  02F6 E5          	pop b
0475+  02F7 E4          	pop a
0476+  02F8 09          	ret
0477+  02F9             
0478+  02F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  02F9             ; INPUT 16BIT HEX INTEGER
0480+  02F9             ; read 16bit integer into A
0481+  02F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0482+  02F9             scan_u16x:
0483+  02F9 F8 10 00    	enter 16
0484+  02FC D8          	push b
0485+  02FD DA          	push d
0486+  02FE             
0487+  02FE FA F1 FF    	lea d, [bp + -15]
0488+  0301 07 4D 01    	call gets				; get number
0489+  0304             
0490+  0304 32          	mov bl, [d]
0491+  0305 37          	mov bh, bl
0492+  0306 33 01 00    	mov bl, [d + 1]
0493+  0309 07 FB 00    	call atoi				; convert to int in AL
0494+  030C 23          	mov ah, al				; move to AH
0495+  030D             
0496+  030D 33 02 00    	mov bl, [d + 2]
0497+  0310 37          	mov bh, bl
0498+  0311 33 03 00    	mov bl, [d + 3]
0499+  0314 07 FB 00    	call atoi				; convert to int in AL
0500+  0317             
0501+  0317 E7          	pop d
0502+  0318 E5          	pop b
0503+  0319 F9          	leave
0504+  031A 09          	ret
0505+  031B             
0506+  031B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  031B             ; PRINT 8bit HEX INTEGER
0508+  031B             ; integer value in reg bl
0509+  031B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0510+  031B             print_u8x:
0511+  031B D7          	push a
0512+  031C DD          	push bl
0513+  031D             
0514+  031D 07 0D 01    	call itoa				; convert bl to char in A
0515+  0320 2F          	mov bl, al				; save al
0516+  0321 19 00       	mov al, 0
0517+  0323 05 03       	syscall sys_io				; display AH
0518+  0325 24          	mov ah, bl				; retrieve al
0519+  0326 19 00       	mov al, 0
0520+  0328 05 03       	syscall sys_io				; display AL
0521+  032A             
0522+  032A EA          	pop bl
0523+  032B E4          	pop a
0524+  032C 09          	ret
0525+  032D             
0526+  032D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  032D             ; print 8bit decimal unsigned number
0528+  032D             ; input number in AL
0529+  032D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0530+  032D             print_u8d:
0531+  032D D7          	push a
0532+  032E D8          	push b
0533+  032F             
0534+  032F 22 00       	mov ah, 0
0535+  0331 26 64 00    	mov b, 100
0536+  0334 AE          	div a, b
0537+  0335 D8          	push b			; save remainder
0538+  0336 B9 00       	cmp al, 0
0539+  0338 C6 42 03    	je skip100
0540+  033B 6A 30       	add al, $30
0541+  033D 23          	mov ah, al
0542+  033E 19 00       	mov al, 0
0543+  0340 05 03       	syscall sys_io	; print coeff
0544+  0342             skip100:
0545+  0342 E4          	pop a
0546+  0343 22 00       	mov ah, 0
0547+  0345 26 0A 00    	mov b, 10
0548+  0348 AE          	div a, b
0549+  0349 D8          	push b			; save remainder
0550+  034A B9 00       	cmp al, 0
0551+  034C C6 56 03    	je skip10
0552+  034F 6A 30       	add al, $30
0553+  0351 23          	mov ah, al
0554+  0352 19 00       	mov al, 0
0555+  0354 05 03       	syscall sys_io	; print coeff
0556+  0356             skip10:
0557+  0356 E4          	pop a
0558+  0357 1B          	mov al, bl
0559+  0358 6A 30       	add al, $30
0560+  035A 23          	mov ah, al
0561+  035B 19 00       	mov al, 0
0562+  035D 05 03       	syscall sys_io	; print coeff
0563+  035F E5          	pop b
0564+  0360 E4          	pop a
0565+  0361 09          	ret
0566+  0362             
0567+  0362             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  0362             ; INPUT 8BIT HEX INTEGER
0569+  0362             ; read 8bit integer into AL
0570+  0362             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0571+  0362             scan_u8x:
0572+  0362 F8 04 00    	enter 4
0573+  0365 D8          	push b
0574+  0366 DA          	push d
0575+  0367             
0576+  0367 FA FD FF    	lea d, [bp + -3]
0577+  036A 07 4D 01    	call gets				; get number
0578+  036D             
0579+  036D 32          	mov bl, [d]
0580+  036E 37          	mov bh, bl
0581+  036F 33 01 00    	mov bl, [d + 1]
0582+  0372 07 FB 00    	call atoi				; convert to int in AL
0583+  0375             
0584+  0375 E7          	pop d
0585+  0376 E5          	pop b
0586+  0377 F9          	leave
0587+  0378 09          	ret
0588+  0379             
0589+  0379             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0590+  0379             ; input decimal number
0591+  0379             ; result in A
0592+  0379             ; 655'\0'
0593+  0379             ; low--------high
0594+  0379             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0595+  0379             scan_u16d:
0596+  0379 F8 08 00    	enter 8
0597+  037C E2          	push si
0598+  037D D8          	push b
0599+  037E D9          	push c
0600+  037F DA          	push d
0601+  0380 FA F9 FF    	lea d, [bp +- 7]
0602+  0383 07 4D 01    	call gets
0603+  0386 07 83 00    	call strlen			; get string length in C
0604+  0389 7E          	dec c
0605+  038A FD 4E       	mov si, d
0606+  038C 12          	mov a, c
0607+  038D FD 99       	shl a
0608+  038F 3B E3 00    	mov d, table_power
0609+  0392 59          	add d, a
0610+  0393 38 00 00    	mov c, 0
0611+  0396             mul_loop:
0612+  0396 F6          	lodsb			; load ASCII to al
0613+  0397 B9 00       	cmp al, 0
0614+  0399 C6 AC 03    	je mul_exit
0615+  039C 6F 30       	sub al, $30		; make into integer
0616+  039E 22 00       	mov ah, 0
0617+  03A0 2A          	mov b, [d]
0618+  03A1 AC          	mul a, b			; result in B since it fits in 16bits
0619+  03A2 11          	mov a, b
0620+  03A3 28          	mov b, c
0621+  03A4 54          	add a, b
0622+  03A5 39          	mov c, a
0623+  03A6 63 02 00    	sub d, 2
0624+  03A9 0A 96 03    	jmp mul_loop
0625+  03AC             mul_exit:
0626+  03AC 12          	mov a, c
0627+  03AD E7          	pop d
0628+  03AE E6          	pop c
0629+  03AF E5          	pop b
0630+  03B0 EF          	pop si
0631+  03B1 F9          	leave
0632+  03B2 09          	ret
0169   03B3             .include "ctype.asm"
0001+  03B3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  03B3             ; ctype.s
0003+  03B3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  03B3             
0005+  03B3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  03B3             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  03B3             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  03B3             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  03B3             ;; characters are supported.
0010+  03B3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  03B3             ;; isalnum 
0012+  03B3             ;; isalpha 
0013+  03B3             ;; islower 
0014+  03B3             ;; isupper 
0015+  03B3             ;; isdigit 
0016+  03B3             ;; isxdigit
0017+  03B3             ;; iscntrl 
0018+  03B3             ;; isgraph 
0019+  03B3             ;; isspace 
0020+  03B3             ;; isblank 
0021+  03B3             ;; isprint 
0022+  03B3             ;; ispunct 
0023+  03B3             ;; tolower 
0024+  03B3             ;; toupper
0025+  03B3             
0026+  03B3             
0027+  03B3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  03B3             ;; IS ALPHANUMERIC
0029+  03B3             ;; sets ZF according with result
0030+  03B3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  03B3             isalnum:
0032+  03B3 07 D0 03    	call isalpha
0033+  03B6 C6 BC 03    	je isalnum_exit
0034+  03B9 07 BD 03    	call isdigit
0035+  03BC             isalnum_exit:
0036+  03BC 09          	ret	
0037+  03BD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  03BD             ;; IS DIGIT
0039+  03BD             ;; sets ZF according with result
0040+  03BD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  03BD             isdigit:
0042+  03BD DB          	push al
0043+  03BE B9 30       	cmp al, '0'
0044+  03C0 C8 CC 03    	jlu isdigit_false
0045+  03C3 B9 39       	cmp al, '9'
0046+  03C5 D1 CC 03    	jgu isdigit_false
0047+  03C8 87 00       	and al, 0	; set ZF
0048+  03CA E8          	pop al
0049+  03CB 09          	ret
0050+  03CC             isdigit_false:
0051+  03CC 8B 01       	or al, 1	; clear ZF
0052+  03CE E8          	pop al
0053+  03CF 09          	ret	
0054+  03D0             	
0055+  03D0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  03D0             ;; IS ALPHA
0057+  03D0             ;; sets ZF according with result
0058+  03D0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  03D0             isalpha:
0060+  03D0 DB          	push al
0061+  03D1 B9 5F       	cmp al, '_'
0062+  03D3 C6 F3 03    	je isalpha_true
0063+  03D6 B9 2E       	cmp al, '.'
0064+  03D8 C6 F3 03    	je isalpha_true
0065+  03DB B9 41       	cmp al, 'A'
0066+  03DD C8 EF 03    	jlu isalpha_false
0067+  03E0 B9 7A       	cmp al, 'z'
0068+  03E2 D1 EF 03    	jgu isalpha_false
0069+  03E5 B9 5A       	cmp al, 'Z'
0070+  03E7 D0 F3 03    	jleu isalpha_true
0071+  03EA B9 61       	cmp al, 'a'
0072+  03EC C9 F3 03    	jgeu isalpha_true
0073+  03EF             isalpha_false:
0074+  03EF 8B 01       	or al, 1	; clear ZF
0075+  03F1 E8          	pop al
0076+  03F2 09          	ret
0077+  03F3             isalpha_true:
0078+  03F3 87 00       	and al, 0	; set ZF
0079+  03F5 E8          	pop al
0080+  03F6 09          	ret
0081+  03F7             
0082+  03F7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  03F7             ;; IS PATH-ALPHA
0084+  03F7             ;; sets ZF according with result
0085+  03F7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  03F7             ispath:
0087+  03F7 DB          	push al
0088+  03F8 07 BD 03    	call isdigit
0089+  03FB C6 25 04    	je ispath_true
0090+  03FE B9 5F       	cmp al, '_'
0091+  0400 C6 25 04    	je ispath_true
0092+  0403 B9 2F       	cmp al, '/'
0093+  0405 C6 25 04    	je ispath_true
0094+  0408 B9 2E       	cmp al, '.'
0095+  040A C6 25 04    	je ispath_true
0096+  040D B9 41       	cmp al, 'A'
0097+  040F C8 21 04    	jlu ispath_false
0098+  0412 B9 7A       	cmp al, 'z'
0099+  0414 D1 21 04    	jgu ispath_false
0100+  0417 B9 5A       	cmp al, 'Z'
0101+  0419 D0 25 04    	jleu ispath_true
0102+  041C B9 61       	cmp al, 'a'
0103+  041E C9 25 04    	jgeu ispath_true
0104+  0421             ispath_false:
0105+  0421 8B 01       	or al, 1	; clear ZF
0106+  0423 E8          	pop al
0107+  0424 09          	ret
0108+  0425             ispath_true:
0109+  0425 87 00       	and al, 0	; set ZF
0110+  0427 E8          	pop al
0111+  0428 09          	ret
0112+  0429             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  0429             ;; IS SPACE
0114+  0429             ;; sets ZF according with result
0115+  0429             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  0429             isspace:
0117+  0429 B9 20       	cmp al, $20		; ' '
0118+  042B C6 3F 04    	je isspace_exit
0119+  042E B9 09       	cmp al, $09		; '\t'
0120+  0430 C6 3F 04    	je isspace_exit
0121+  0433 B9 0A       	cmp al, $0A		; '\n'
0122+  0435 C6 3F 04    	je isspace_exit
0123+  0438 B9 0D       	cmp al, $0D		; '\r'
0124+  043A C6 3F 04    	je isspace_exit
0125+  043D B9 0B       	cmp al, $0B		; '\v'
0126+  043F             isspace_exit:
0127+  043F 09          	ret	
0128+  0440             
0129+  0440             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0440             ; TO LOWER
0131+  0440             ; input in AL
0132+  0440             ; output in AL
0133+  0440             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  0440             to_lower:
0135+  0440 B9 5A       	cmp al, 'Z'
0136+  0442 D1 47 04    	jgu to_lower_ret
0137+  0445 6A 20       	add al, $20				; convert to lower case
0138+  0447             to_lower_ret:
0139+  0447 09          	ret
0140+  0448             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  0448             ; TO UPPER
0142+  0448             ; input in AL
0143+  0448             ; output in AL
0144+  0448             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  0448             to_upper:
0146+  0448 B9 61       	cmp al, 'a'
0147+  044A C8 4F 04    	jlu to_upper_ret
0148+  044D 6F 20       	sub al, $20			; convert to upper case
0149+  044F             to_upper_ret:
0150+  044F 09          	ret
0151+  0450             
0170   0450             .include "token.asm"
0001+  0450             TOKTYP_IDENTIFIER	.equ 0
0002+  0450             TOKTYP_KEYWORD		.equ 1
0003+  0450             TOKTYP_DELIMITER	.equ 2
0004+  0450             TOKTYP_STRING		.equ 3
0005+  0450             TOKTYP_CHAR			.equ 4
0006+  0450             TOKTYP_NUMERIC		.equ 5
0007+  0450             TOKTYP_END			.equ 6
0008+  0450             
0009+  0450             TOK_NULL			.equ 0
0010+  0450             TOK_FSLASH			.equ 1
0011+  0450             TOK_TIMES 			.equ 2
0012+  0450             TOK_PLUS 			.equ 3
0013+  0450             TOK_MINUS 			.equ 4
0014+  0450             TOK_DOT				.equ 5
0015+  0450             TOK_SEMI			.equ 6
0016+  0450             TOK_ANGLE			.equ 7
0017+  0450             TOK_TILDE			.equ 8
0018+  0450             TOK_EQUAL			.equ 9
0019+  0450             TOK_COLON			.equ 10
0020+  0450             TOK_COMMA			.equ 11
0021+  0450             
0022+  0450             TOK_END				.equ 20
0023+  0450             
0024+  0450             
0025+  0450             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  0450             ;; read a full command argment from shell input buffer
0027+  0450             ;; argument is written into tokstr
0028+  0450             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  0450             get_arg:
0030+  0450 D7          	push a
0031+  0451 E2          	push si
0032+  0452 E3          	push di
0033+  0453 19 00       	mov al, 0
0034+  0455 3D 7E 06    	mov [tokstr], al			; nullify tokstr string
0035+  0458 14 7A 06    	mov a, [prog]
0036+  045B 4D          	mov si, a
0037+  045C FD 4F 7E 06 	mov di, tokstr
0038+  0460             get_arg_skip_spaces:
0039+  0460 F6          	lodsb
0040+  0461 07 29 04    	call isspace
0041+  0464 C6 60 04    	je get_arg_skip_spaces
0042+  0467             get_arg_L0:
0043+  0467 B9 3B       	cmp al, $3B				; check if is ';'
0044+  0469 C6 76 04    	je get_arg_end
0045+  046C B9 00       	cmp al, 0
0046+  046E C6 76 04    	je get_arg_end			; check if end of input
0047+  0471 F7          	stosb
0048+  0472 F6          	lodsb
0049+  0473 0A 67 04    	jmp get_arg_L0
0050+  0476             get_arg_end:
0051+  0476 19 00       	mov al, 0
0052+  0478 F7          	stosb
0053+  0479 D5 01 00    	sub si, 1
0054+  047C 4E          	mov a, si
0055+  047D 42 7A 06    	mov [prog], a		; update pointer
0056+  0480 F0          	pop di
0057+  0481 EF          	pop si
0058+  0482 E4          	pop a
0059+  0483 09          	ret
0060+  0484             
0061+  0484             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  0484             ;; read a path formation from shell input buffer
0063+  0484             ;; path is written into tokstr
0064+  0484             ;; /usr/bin
0065+  0484             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  0484             get_path:
0067+  0484 D7          	push a
0068+  0485 E2          	push si
0069+  0486 E3          	push di
0070+  0487 19 00       	mov al, 0
0071+  0489 3D 7E 06    	mov [tokstr], al			; nullify tokstr string
0072+  048C 14 7A 06    	mov a, [prog]
0073+  048F 4D          	mov si, a
0074+  0490 FD 4F 7E 06 	mov di, tokstr
0075+  0494             get_path_skip_spaces:
0076+  0494 F6          	lodsb
0077+  0495 07 29 04    	call isspace
0078+  0498 C6 94 04    	je get_path_skip_spaces
0079+  049B             get_path_is_pathchar:
0080+  049B F7          	stosb
0081+  049C F6          	lodsb
0082+  049D 07 B3 03    	call isalnum			;check if is alphanumeric
0083+  04A0 C6 9B 04    	je get_path_is_pathchar
0084+  04A3 B9 2F       	cmp al, '/'				; check if is '/'
0085+  04A5 C6 9B 04    	je get_path_is_pathchar
0086+  04A8 19 00       	mov al, 0
0087+  04AA F7          	stosb
0088+  04AB D5 01 00    	sub si, 1
0089+  04AE 4E          	mov a, si
0090+  04AF 42 7A 06    	mov [prog], a		; update pointer
0091+  04B2             get_path_end:
0092+  04B2 F0          	pop di
0093+  04B3 EF          	pop si
0094+  04B4 E4          	pop a
0095+  04B5 09          	ret
0096+  04B6             
0097+  04B6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  04B6             ;; read a line
0099+  04B6             ;; line is written into tokstr
0100+  04B6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  04B6             get_line:
0102+  04B6 D7          	push a
0103+  04B7 E2          	push si
0104+  04B8 E3          	push di
0105+  04B9 19 00       	mov al, 0
0106+  04BB 3D 7E 06    	mov [tokstr], al			; nullify tokstr string
0107+  04BE 14 7A 06    	mov a, [prog]
0108+  04C1 4D          	mov si, a
0109+  04C2 FD 4F 7E 06 	mov di, tokstr
0110+  04C6             get_line_L0:
0111+  04C6 F6          	lodsb
0112+  04C7 B9 0A       	cmp al, $0A		; check for new line
0113+  04C9 C6 D0 04    	je get_line_exit
0114+  04CC F7          	stosb
0115+  04CD 0A C6 04    	jmp get_line_L0
0116+  04D0             get_line_exit:
0117+  04D0 19 00       	mov al, 0
0118+  04D2 F7          	stosb
0119+  04D3 4E          	mov a, si
0120+  04D4 42 7A 06    	mov [prog], a		; update pointer
0121+  04D7 F0          	pop di
0122+  04D8 EF          	pop si
0123+  04D9 E4          	pop a
0124+  04DA 09          	ret
0125+  04DB             
0126+  04DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  04DB             ;; token parser
0128+  04DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  04DB             get_token:
0130+  04DB D7          	push a
0131+  04DC DA          	push d
0132+  04DD E2          	push si
0133+  04DE E3          	push di
0134+  04DF 19 00       	mov al, 0
0135+  04E1 3D 7E 06    	mov [tokstr], al			; nullify tokstr string
0136+  04E4 19 00       	mov al, TOK_NULL
0137+  04E6 3D 7D 06    	mov [tok], al				; nullify token
0138+  04E9 14 7A 06    	mov a, [prog]
0139+  04EC 4D          	mov si, a
0140+  04ED FD 4F 7E 06 	mov di, tokstr
0141+  04F1             get_tok_skip_spaces:
0142+  04F1 F6          	lodsb
0143+  04F2 07 29 04    	call isspace
0144+  04F5 C6 F1 04    	je get_tok_skip_spaces
0145+  04F8 B9 00       	cmp al, 0			; check for end of input (NULL)
0146+  04FA C6 DF 05    	je get_token_end
0147+  04FD B9 23       	cmp al, '#'			; comments!
0148+  04FF C6 0D 06    	je get_tok_comment
0149+  0502 07 B3 03    	call isalnum
0150+  0505 C6 EC 05    	jz is_alphanumeric
0151+  0508             ; other token types
0152+  0508             get_token_slash:
0153+  0508 B9 2F       	cmp al, '/'				; check if '/'
0154+  050A C7 22 05    	jne get_token_minus
0155+  050D F7          	stosb					; store '/' into token string
0156+  050E 19 00       	mov al, 0
0157+  0510 F7          	stosb					; terminate token string
0158+  0511 19 01       	mov al, TOK_FSLASH
0159+  0513 3D 7D 06    	mov [tok], al			
0160+  0516 19 02       	mov al, TOKTYP_DELIMITER
0161+  0518 3D 7C 06    	mov [toktyp], al
0162+  051B 4E          	mov a, si
0163+  051C 42 7A 06    	mov [prog], a		; update pointer
0164+  051F 0A 08 06    	jmp get_token_return
0165+  0522             get_token_minus:
0166+  0522 B9 2D       	cmp al, '-'				; check if '-'
0167+  0524 C7 3C 05    	jne get_token_comma
0168+  0527 F7          	stosb					; store '-' into token string
0169+  0528 19 00       	mov al, 0
0170+  052A F7          	stosb					; terminate token string
0171+  052B 19 04       	mov al, TOK_MINUS
0172+  052D 3D 7D 06    	mov [tok], al			
0173+  0530 19 02       	mov al, TOKTYP_DELIMITER
0174+  0532 3D 7C 06    	mov [toktyp], al
0175+  0535 4E          	mov a, si
0176+  0536 42 7A 06    	mov [prog], a		; update pointer
0177+  0539 0A 08 06    	jmp get_token_return
0178+  053C             get_token_comma:
0179+  053C B9 2C       	cmp al, ','				; check if ','
0180+  053E C7 56 05    	jne get_token_semi
0181+  0541 F7          	stosb					; store ',' into token string
0182+  0542 19 00       	mov al, 0
0183+  0544 F7          	stosb					; terminate token string
0184+  0545 19 0B       	mov al, TOK_COMMA
0185+  0547 3D 7D 06    	mov [tok], al			
0186+  054A 19 02       	mov al, TOKTYP_DELIMITER
0187+  054C 3D 7C 06    	mov [toktyp], al
0188+  054F 4E          	mov a, si
0189+  0550 42 7A 06    	mov [prog], a		; update pointer
0190+  0553 0A 08 06    	jmp get_token_return
0191+  0556             get_token_semi:
0192+  0556 B9 3B       	cmp al, $3B				; check if ';'
0193+  0558 C7 70 05    	jne get_token_colon
0194+  055B F7          	stosb					; store ';' into token string
0195+  055C 19 00       	mov al, 0
0196+  055E F7          	stosb					; terminate token string
0197+  055F 19 06       	mov al, TOK_SEMI
0198+  0561 3D 7D 06    	mov [tok], al			
0199+  0564 19 02       	mov al, TOKTYP_DELIMITER
0200+  0566 3D 7C 06    	mov [toktyp], al
0201+  0569 4E          	mov a, si
0202+  056A 42 7A 06    	mov [prog], a		; update pointer
0203+  056D 0A 08 06    	jmp get_token_return
0204+  0570             get_token_colon:
0205+  0570 B9 3A       	cmp al, $3A				; check if ':'
0206+  0572 C7 8A 05    	jne get_token_angle
0207+  0575 F7          	stosb					; store ':' into token string
0208+  0576 19 00       	mov al, 0
0209+  0578 F7          	stosb					; terminate token string
0210+  0579 19 0A       	mov al, TOK_COLON
0211+  057B 3D 7D 06    	mov [tok], al			
0212+  057E 19 02       	mov al, TOKTYP_DELIMITER
0213+  0580 3D 7C 06    	mov [toktyp], al
0214+  0583 4E          	mov a, si
0215+  0584 42 7A 06    	mov [prog], a		; update pointer
0216+  0587 0A 08 06    	jmp get_token_return
0217+  058A             get_token_angle:
0218+  058A B9 3E       	cmp al, $3E				; check if '>'
0219+  058C C7 A4 05    	jne get_token_tilde
0220+  058F F7          	stosb					; store '>' into token string
0221+  0590 19 00       	mov al, 0
0222+  0592 F7          	stosb					; terminate token string
0223+  0593 19 07       	mov al, TOK_ANGLE
0224+  0595 3D 7D 06    	mov [tok], al			
0225+  0598 19 02       	mov al, TOKTYP_DELIMITER
0226+  059A 3D 7C 06    	mov [toktyp], al
0227+  059D 4E          	mov a, si
0228+  059E 42 7A 06    	mov [prog], a		; update pointer
0229+  05A1 0A 08 06    	jmp get_token_return
0230+  05A4             get_token_tilde:
0231+  05A4 B9 7E       	cmp al, '~'				; check if '~'
0232+  05A6 C7 BE 05    	jne get_token_equal
0233+  05A9 F7          	stosb					; store '~' into token string
0234+  05AA 19 00       	mov al, 0
0235+  05AC F7          	stosb					; terminate token string
0236+  05AD 19 08       	mov al, TOK_TILDE
0237+  05AF 3D 7D 06    	mov [tok], al			
0238+  05B2 19 02       	mov al, TOKTYP_DELIMITER
0239+  05B4 3D 7C 06    	mov [toktyp], al
0240+  05B7 4E          	mov a, si
0241+  05B8 42 7A 06    	mov [prog], a		; update pointer
0242+  05BB 0A 08 06    	jmp get_token_return
0243+  05BE             get_token_equal:
0244+  05BE B9 3D       	cmp al, '='				; check if '='
0245+  05C0 C7 D8 05    	jne get_token_skip
0246+  05C3 F7          	stosb					; store '=' into token string
0247+  05C4 19 00       	mov al, 0
0248+  05C6 F7          	stosb					; terminate token string
0249+  05C7 19 09       	mov al, TOK_EQUAL
0250+  05C9 3D 7D 06    	mov [tok], al			
0251+  05CC 19 02       	mov al, TOKTYP_DELIMITER
0252+  05CE 3D 7C 06    	mov [toktyp], al
0253+  05D1 4E          	mov a, si
0254+  05D2 42 7A 06    	mov [prog], a		; update pointer
0255+  05D5 0A 08 06    	jmp get_token_return
0256+  05D8             get_token_skip:
0257+  05D8 4E          	mov a, si
0258+  05D9 42 7A 06    	mov [prog], a		; update pointer
0259+  05DC 0A 08 06    	jmp get_token_return
0260+  05DF             get_token_end:				; end of file token
0261+  05DF 19 14       	mov al, TOK_END
0262+  05E1 3D 7D 06    	mov [tok], al
0263+  05E4 19 06       	mov al, TOKTYP_END
0264+  05E6 3D 7C 06    	mov [toktyp], al
0265+  05E9 0A 08 06    	jmp get_token_return
0266+  05EC             is_alphanumeric:
0267+  05EC F7          	stosb
0268+  05ED F6          	lodsb
0269+  05EE 07 B3 03    	call isalnum			;check if is alphanumeric
0270+  05F1 C6 EC 05    	jz is_alphanumeric
0271+  05F4 B9 2E       	cmp al, $2E				; check if is '.'
0272+  05F6 C6 EC 05    	je is_alphanumeric
0273+  05F9 19 00       	mov al, 0
0274+  05FB F7          	stosb
0275+  05FC 19 00       	mov al, TOKTYP_IDENTIFIER
0276+  05FE 3D 7C 06    	mov [toktyp], al
0277+  0601 D5 01 00    	sub si, 1
0278+  0604 4E          	mov a, si
0279+  0605 42 7A 06    	mov [prog], a		; update pointer
0280+  0608             get_token_return:
0281+  0608 F0          	pop di
0282+  0609 EF          	pop si
0283+  060A E7          	pop d
0284+  060B E4          	pop a
0285+  060C 09          	ret
0286+  060D             get_tok_comment:
0287+  060D F6          	lodsb
0288+  060E B9 0A       	cmp al, $0A			; new line
0289+  0610 C7 0D 06    	jne get_tok_comment
0290+  0613 0A F1 04    	jmp get_tok_skip_spaces
0291+  0616             
0292+  0616             
0293+  0616             get_number:
0294+  0616 D7          	push a
0295+  0617 DA          	push d
0296+  0618 E2          	push si
0297+  0619 E3          	push di
0298+  061A 19 00       	mov al, 0
0299+  061C 3D 7E 06    	mov [tokstr], al			; nullify tokstr string
0300+  061F 19 00       	mov al, TOK_NULL
0301+  0621 3D 7D 06    	mov [tok], al				; nullify token
0302+  0624 14 7A 06    	mov a, [prog]
0303+  0627 4D          	mov si, a
0304+  0628 FD 4F 7E 06 	mov di, tokstr
0305+  062C             get_number_skip_spaces:
0306+  062C F6          	lodsb
0307+  062D 07 29 04    	call isspace
0308+  0630 C6 2C 06    	je get_number_skip_spaces
0309+  0633 B9 00       	cmp al, 0			; check for end of input (NULL)
0310+  0635 C7 45 06    	jne get_number_L0
0311+  0638 19 14       	mov al, TOK_END
0312+  063A 3D 7D 06    	mov [tok], al
0313+  063D 19 06       	mov al, TOKTYP_END
0314+  063F 3D 7C 06    	mov [toktyp], al
0315+  0642 0A 5C 06    	jmp get_number_return
0316+  0645             get_number_L0:
0317+  0645 F7          	stosb
0318+  0646 F6          	lodsb
0319+  0647 07 BD 03    	call isdigit			;check if is numeric
0320+  064A C6 45 06    	jz get_number_L0
0321+  064D 19 00       	mov al, 0
0322+  064F F7          	stosb
0323+  0650 19 05       	mov al, TOKTYP_NUMERIC
0324+  0652 3D 7C 06    	mov [toktyp], al
0325+  0655 D5 01 00    	sub si, 1
0326+  0658 4E          	mov a, si
0327+  0659 42 7A 06    	mov [prog], a		; update pointer
0328+  065C             get_number_return:
0329+  065C F0          	pop di
0330+  065D EF          	pop si
0331+  065E E7          	pop d
0332+  065F E4          	pop a
0333+  0660 09          	ret
0334+  0661             
0335+  0661             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  0661             ;; PUT BACK TOKEN
0337+  0661             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
0338+  0661             putback:
0339+  0661 D7          	push a
0340+  0662 E2          	push si
0341+  0663 FD 4D 7E 06 	mov si, tokstr	
0342+  0667             putback_loop:
0343+  0667 F6          	lodsb
0344+  0668 B9 00       	cmp al, 0
0345+  066A C6 77 06    	je putback_end
0346+  066D 14 7A 06    	mov a, [prog]
0347+  0670 7D          	dec a
0348+  0671 42 7A 06    	mov [prog], a			; update pointer
0349+  0674 0A 67 06    	jmp putback_loop
0350+  0677             putback_end:
0351+  0677 EF          	pop si
0352+  0678 E4          	pop a
0353+  0679 09          	ret
0354+  067A             
0355+  067A             
0356+  067A             
0357+  067A             
0358+  067A 00 00       prog:		.dw 0			; pointer to current position in buffer
0359+  067C             
0360+  067C 00          toktyp: 	.db 0			; token type symbol
0361+  067D 00          tok:		.db 0			; current token symbol
0362+  067E 00 00 00 00 tokstr:		.fill 256, 0	; token as a string
0362+  0682 00 00 00 00 
0362+  0686 00 00 00 00 
0362+  068A 00 00 00 00 
0362+  068E 00 00 00 00 
0362+  0692 00 00 00 00 
0362+  0696 00 00 00 00 
0362+  069A 00 00 00 00 
0362+  069E 00 00 00 00 
0362+  06A2 00 00 00 00 
0362+  06A6 00 00 00 00 
0362+  06AA 00 00 00 00 
0362+  06AE 00 00 00 00 
0362+  06B2 00 00 00 00 
0362+  06B6 00 00 00 00 
0362+  06BA 00 00 00 00 
0362+  06BE 00 00 00 00 
0362+  06C2 00 00 00 00 
0362+  06C6 00 00 00 00 
0362+  06CA 00 00 00 00 
0362+  06CE 00 00 00 00 
0362+  06D2 00 00 00 00 
0362+  06D6 00 00 00 00 
0362+  06DA 00 00 00 00 
0362+  06DE 00 00 00 00 
0362+  06E2 00 00 00 00 
0362+  06E6 00 00 00 00 
0362+  06EA 00 00 00 00 
0362+  06EE 00 00 00 00 
0362+  06F2 00 00 00 00 
0362+  06F6 00 00 00 00 
0362+  06FA 00 00 00 00 
0362+  06FE 00 00 00 00 
0362+  0702 00 00 00 00 
0362+  0706 00 00 00 00 
0362+  070A 00 00 00 00 
0362+  070E 00 00 00 00 
0362+  0712 00 00 00 00 
0362+  0716 00 00 00 00 
0362+  071A 00 00 00 00 
0362+  071E 00 00 00 00 
0362+  0722 00 00 00 00 
0362+  0726 00 00 00 00 
0362+  072A 00 00 00 00 
0362+  072E 00 00 00 00 
0362+  0732 00 00 00 00 
0362+  0736 00 00 00 00 
0362+  073A 00 00 00 00 
0362+  073E 00 00 00 00 
0362+  0742 00 00 00 00 
0362+  0746 00 00 00 00 
0362+  074A 00 00 00 00 
0362+  074E 00 00 00 00 
0362+  0752 00 00 00 00 
0362+  0756 00 00 00 00 
0362+  075A 00 00 00 00 
0362+  075E 00 00 00 00 
0362+  0762 00 00 00 00 
0362+  0766 00 00 00 00 
0362+  076A 00 00 00 00 
0362+  076E 00 00 00 00 
0362+  0772 00 00 00 00 
0362+  0776 00 00 00 00 
0362+  077A 00 00 00 00 
0171   077E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0172   077E             
0173   077E             sys_bkpt			.equ 0
0174   077E             sys_rtc				.equ 1
0175   077E             sys_IDE				.equ 2
0176   077E             sys_io				.equ 3
0177   077E             sys_fileio			.equ 4
0178   077E             sys_fork			.equ 5
0179   077E             sys_list			.equ 6
0180   077E             sys_datetime		.equ 7
0181   077E             sys_reboot			.equ 8
0182   077E             sys_pauseproc		.equ 9
0183   077E             sys_resumeproc		.equ 10
0184   077E             sys_terminate_proc	.equ 11
0185   077E             sys_system			.equ 12
0186   077E             sys_boot_install	.equ 13
0187   077E             
0188   077E             .export PROC_TEXT_ORG
0189   077E             .export sys_bkpt
0190   077E             .export sys_IDE
0191   077E             .export sys_io
0192   077E             .export sys_fileio
0193   077E             .export sys_fork
0194   077E             .export sys_list
0195   077E             .export sys_rtc
0196   077E             .export sys_datetime
0197   077E             .export sys_reboot
0198   077E             .export sys_pauseproc
0199   077E             .export sys_resumeproc
0200   077E             .export sys_terminate_proc
0201   077E             .export sys_system
0202   077E             .export sys_boot_install
0203   077E             
0204   077E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0205   077E             ; EXTERNAL INTERRUPTS' CODE BLOCK
0206   077E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0207   077E             ; uart
0208   077E             int_0:
0209   077E 06          	sysret
0210   077F             int_1:
0211   077F 06          	sysret
0212   0780             int_2:
0213   0780 06          	sysret
0214   0781             int_3:
0215   0781 06          	sysret
0216   0782             int_4:
0217   0782 06          	sysret
0218   0783             int_5:
0219   0783 06          	sysret
0220   0784             int_6:	
0221   0784             ; save all registers into kernel stack
0222   0784 4B          	pusha
0223   0785 22 00       	mov ah, 0
0224   0787 1D 1A 16    	mov al, [active_proc_index]
0225   078A FD 99       	shl a							; x2
0226   078C B7 D8 15    	mov a, [proc_table_convert + a]	; get process state start index
0227   078F             		
0228   078F 4F          	mov di, a
0229   0790 48          	mov a, sp
0230   0791 77          	inc a
0231   0792 4D          	mov si, a
0232   0793 38 14 00    	mov c, 20
0233   0796 FD F5       	rep movsb					; save process state!
0234   0798             ; restore kernel stack position to point before interrupt arrived
0235   0798 51 14 00    	add sp, 20
0236   079B             ; now load next process in queue
0237   079B 1D 1A 16    	mov al, [active_proc_index]
0238   079E 31 19 16    	mov bl, [nbr_active_procs]
0239   07A1 BA          	cmp al, bl
0240   07A2 C6 A9 07    	je int6_cycle_back
0241   07A5 7A          	inc al						; next process is next in the series
0242   07A6 0A AB 07    	jmp int6_continue
0243   07A9             int6_cycle_back:
0244   07A9 19 01       	mov al, 1				; next process = process 1
0245   07AB             int6_continue:
0246   07AB 3D 1A 16    	mov [active_proc_index], al		; set next active proc
0247   07AE             
0248   07AE             ; calculate LUT entry for next process
0249   07AE 22 00       	mov ah, 0
0250   07B0 FD 99       	shl a							; x2
0251   07B2 B7 D8 15    	mov a, [proc_table_convert + a]		; get process state start index	
0252   07B5             	
0253   07B5 4D          	mov si, a						; source is proc state block
0254   07B6 48          	mov a, sp
0255   07B7 5F 13 00    	sub a, 19
0256   07BA 4F          	mov di, a						; destination is kernel stack
0257   07BB             ; restore SP
0258   07BB 7D          	dec a
0259   07BC 47          	mov sp, a
0260   07BD 38 14 00    	mov c, 20
0261   07C0 FD F5       	rep movsb
0262   07C2             ; set VM process
0263   07C2 1D 1A 16    	mov al, [active_proc_index]
0264   07C5 01          	setptb
0265   07C6             		
0266   07C6 F2 E0 FF 00 	mov byte[_TIMER_C_0], 0				; load counter 0 low byte
0267   07CA F2 E0 FF 10 	mov byte[_TIMER_C_0], $10				; load counter 0 high byte
0268   07CE             			
0269   07CE 4C          	popa
0270   07CF 06          	sysret
0271   07D0             
0272   07D0             int_7:
0273   07D0 D7          	push a
0274   07D1 DA          	push d
0275   07D2 E1          	pushf
0276   07D3             			
0277   07D3 14 1F 16    	mov a, [fifo_pi]
0278   07D6 3C          	mov d, a
0279   07D7             
0280   07D7 1D 80 FF    	mov al, [_UART0_DATA]	; get character
0281   07DA B9 03       	cmp al, $03				; CTRL-C
0282   07DC C6 F9 07    	je CTRLC
0283   07DF B9 1A       	cmp al, $1A				; CTRL-Z
0284   07E1 C6 FF 07    	je CTRLZ
0285   07E4 3E          	mov [d], al				; add to fifo
0286   07E5             	
0287   07E5 14 1F 16    	mov a, [fifo_pi]
0288   07E8 77          	inc a
0289   07E9 AF CB 26    	cmp a, fifo + FIFO_SIZE 				; check if pointer reached the end of the fifo
0290   07EC C7 F2 07    	jne int_7_continue
0291   07EF 10 CB 1E    	mov a, fifo	
0292   07F2             int_7_continue:	
0293   07F2 42 1F 16    	mov [fifo_pi], a			; update fifo pointer
0294   07F5             	
0295   07F5 EE          	popf
0296   07F6 E7          	pop d
0297   07F7 E4          	pop a	
0298   07F8 06          	sysret
0299   07F9             
0300   07F9             CTRLC:
0301   07F9 EE          	popf
0302   07FA E7          	pop d
0303   07FB E4          	pop a
0304   07FC 0A E2 14    	jmp cmd_terminate_proc
0305   07FF             
0306   07FF             CTRLZ:
0307   07FF EE          	popf
0308   0800 E7          	pop d
0309   0801 E4          	pop a
0310   0802 0A 25 15    	jmp cmd_pause_proc		; pause current process and go back to the shell
0311   0805             
0312   0805             cmd_system_jmptbl:
0313   0805 0D 08       	.dw cmd_system_uname
0314   0807 14 08       	.dw cmd_system_whoami
0315   0809             
0316   0809             cmd_system:
0317   0809 FD 0A 05 08 	jmp [cmd_system_jmptbl + al]
0318   080D             cmd_system_uname:
0319   080D 3B 57 16    	mov d, s_uname
0320   0810 07 7B 02    	call puts
0321   0813 06          	sysret
0322   0814             cmd_system_whoami:
0323   0814 3B 5F 16    	mov d, s_root
0324   0817 07 7B 02    	call puts
0325   081A 06          	sysret
0326   081B             
0327   081B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0328   081B             ; REBOOT SYSTEM
0329   081B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0330   081B             syscall_reboot:
0331   081B FD D7 FF FF 	push word $FFFF 
0332   081F FD DB 00    	push byte %00000000				; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
0333   0822 FD D7 C0 01 	push word BIOS_RESET_VECTOR		; and then push RESET VECTOR of the shell to the stack
0334   0826 06          	sysret
0335   0827             
0336   0827             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0337   0827             ;; switch to another process
0338   0827             ;; inputs:
0339   0827             ;; AL = new process number
0340   0827             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0341   0827             resume_proc:
0342   0827 FD 78       	mov g, a	; save the process number
0343   0829             ; save all registers into kernel stack
0344   0829 4B          	pusha
0345   082A 22 00       	mov ah, 0
0346   082C 1D 1A 16    	mov al, [active_proc_index]
0347   082F FD 99       	shl a							; x2
0348   0831 B7 D8 15    	mov a, [proc_table_convert + a]	; get process state start index
0349   0834 4F          	mov di, a
0350   0835 48          	mov a, sp
0351   0836 77          	inc a
0352   0837 4D          	mov si, a
0353   0838 38 14 00    	mov c, 20
0354   083B FD F5       	rep movsb					; save process state!
0355   083D             ; restore kernel stack position to point before interrupt arrived
0356   083D 51 14 00    	add sp, 20
0357   0840             ; now load the new process number!
0358   0840 FD 12       	mov a, g						; retrieve the process number argument that was saved in the beginning
0359   0842 3D 1A 16    	mov [active_proc_index], al		; set new active proc
0360   0845             ; calculate LUT entry for next process
0361   0845 22 00       	mov ah, 0
0362   0847 FD 99       	shl a							; x2
0363   0849 B7 D8 15    	mov a, [proc_table_convert + a]		; get process state start index	
0364   084C             	
0365   084C 4D          	mov si, a						; source is proc state block
0366   084D 48          	mov a, sp
0367   084E 5F 13 00    	sub a, 19
0368   0851 4F          	mov di, a						; destination is kernel stack
0369   0852             ; restore SP
0370   0852 7D          	dec a
0371   0853 47          	mov sp, a
0372   0854 38 14 00    	mov c, 20
0373   0857 FD F5       	rep movsb
0374   0859             ; set VM process
0375   0859 1D 1A 16    	mov al, [active_proc_index]
0376   085C 01          	setptb
0377   085D             			
0378   085D 4C          	popa
0379   085E 06          	sysret
0380   085F             
0381   085F             
0382   085F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0383   085F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384   085F             list_procs:
0385   085F 3B 43 16    	mov d, s_ps_header
0386   0862 07 7B 02    	call puts
0387   0865 3B BC 18    	mov d, proc_availab_table + 1
0388   0868 38 01 00    	mov c, 1
0389   086B             list_procs_L0:	
0390   086B BD 01       	cmp byte[d], 1
0391   086D C7 91 08    	jne list_procs_next
0392   0870 2D          	mov b, d
0393   0871 61 BB 18    	sub b, proc_availab_table
0394   0874 FD 9F 05    	shl b, 5
0395   0877 DA          	push d
0396   0878 D8          	push b
0397   0879 28          	mov b, c
0398   087A 07 1B 03    	call print_u8x
0399   087D 22 20       	mov ah, ' '
0400   087F 07 46 01    	call putchar
0401   0882 07 46 01    	call putchar
0402   0885 E5          	pop b
0403   0886 74          	mov d, b
0404   0887 58 CB 18    	add d, proc_names
0405   088A 07 7B 02    	call puts
0406   088D 07 28 02    	call printnl
0407   0890 E7          	pop d
0408   0891             list_procs_next:
0409   0891 79          	inc d
0410   0892 78          	inc c
0411   0893 C2 09 00    	cmp c, 9
0412   0896 C7 6B 08    	jne list_procs_L0
0413   0899             list_procs_end:
0414   0899 06          	sysret
0415   089A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0416   089A             ; PRIVILEGE EXCEPTION
0417   089A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418   089A             trap_privilege:
0419   089A 0A 1B 08    	jmp syscall_reboot
0420   089D DA          	push d
0421   089E             
0422   089E 3B AD 16    	mov d, s_priviledge
0423   08A1 07 7B 02    	call puts
0424   08A4             
0425   08A4 E7          	pop d
0426   08A5             	
0427   08A5 06          	sysret
0428   08A6             
0429   08A6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0430   08A6             ; BREAKPOINT EXCEPTION
0431   08A6             ; IMPORTANT: values in the stack are being pushed in big endian. i.e.: MSB at low address
0432   08A6             ; and LSB at high address. *** NEED TO CORRECT THIS IN THE MICROCODE and make it little endian again ***
0433   08A6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0434   08A6             trap_breakpoint:
0435   08A6 4B          	pusha
0436   08A7             trap_break_prompt:
0437   08A7 3B 61 09    	mov d, s_break1
0438   08AA 07 7B 02    	call puts
0439   08AD 07 28 02    	call printnl
0440   08B0 07 79 03    	call scan_u16d
0441   08B3 AF 00 00    	cmp a, 0
0442   08B6 C6 C1 08    	je trap_break_regs
0443   08B9 AF 01 00    	cmp a, 1
0444   08BC C6 E4 08    	je trap_break_mem
0445   08BF             trap_break_end:	
0446   08BF 4C          	popa
0447   08C0 06          	sysret
0448   08C1             trap_break_regs:
0449   08C1 48          	mov a, sp
0450   08C2 53 0E 00    	add a, 14	; back-track 7 registers
0451   08C5 3C          	mov d, a
0452   08C6 3A 07       	mov cl, 7
0453   08C8             trap_regs_L0:
0454   08C8 2A          	mov b, [d]
0455   08C9 FD AB       	swp b
0456   08CB 07 D7 02    	call print_u16x	; print register value
0457   08CE 07 28 02    	call printnl
0458   08D1 63 02 00    	sub d, 2
0459   08D4 71 01       	sub cl, 1
0460   08D6 C3 00       	cmp cl, 0
0461   08D8 C7 C8 08    	jne trap_regs_L0
0462   08DB 0A A7 08    	jmp trap_break_prompt
0463   08DE 07 28 02    	call printnl
0464   08E1 0A A7 08    	jmp trap_break_prompt
0465   08E4             trap_break_mem:
0466   08E4 07 28 02    	call printnl
0467   08E7 07 F9 02    	call scan_u16x
0468   08EA 4D          	mov si, a			; data source from user space
0469   08EB FD 4F CB 26 	mov di, scrap_sector		; destination in kernel space
0470   08EF 38 00 02    	mov c, 512
0471   08F2 04          	load				; transfer data to kernel space!
0472   08F3 3B CB 26    	mov d, scrap_sector		; dump pointer in d
0473   08F6 38 00 00    	mov c, 0
0474   08F9             dump_loop:
0475   08F9 84          	mov al, cl
0476   08FA 87 0F       	and al, $0F
0477   08FC C6 4A 09    	jz print_base
0478   08FF             back:
0479   08FF 1E          	mov al, [d]				; read byte
0480   0900 2F          	mov bl, al
0481   0901 07 1B 03    	call print_u8x
0482   0904 10 00 20    	mov a, $2000
0483   0907 05 03       	syscall sys_io			; space
0484   0909 84          	mov al, cl
0485   090A 87 0F       	and al, $0F
0486   090C B9 0F       	cmp al, $0F
0487   090E C6 1F 09    	je print_ascii
0488   0911             back1:
0489   0911 79          	inc d
0490   0912 78          	inc c
0491   0913 C2 00 02    	cmp c, 512
0492   0916 C7 F9 08    	jne dump_loop
0493   0919 07 28 02    	call printnl
0494   091C 0A A7 08    	jmp trap_break_prompt	; go to trap_breakpoint return point
0495   091F             print_ascii:
0496   091F 10 00 20    	mov a, $2000
0497   0922 05 03       	syscall sys_io
0498   0924 63 10 00    	sub d, 16
0499   0927 26 10 00    	mov b, 16
0500   092A             print_ascii_L:
0501   092A 79          	inc d
0502   092B 1E          	mov al, [d]				; read byte
0503   092C B9 20       	cmp al, $20
0504   092E C8 36 09    	jlu dot
0505   0931 B9 7E       	cmp al, $7E
0506   0933 D0 3E 09    	jleu ascii
0507   0936             dot:
0508   0936 10 00 2E    	mov a, $2E00
0509   0939 05 03       	syscall sys_io
0510   093B 0A 43 09    	jmp ascii_continue
0511   093E             ascii:
0512   093E 23          	mov ah, al
0513   093F 19 00       	mov al, 0
0514   0941 05 03       	syscall sys_io
0515   0943             ascii_continue:
0516   0943 FD A9 2A 09 	loopb print_ascii_L
0517   0947 0A 11 09    	jmp back1
0518   094A             print_base:
0519   094A 07 28 02    	call printnl
0520   094D 2D          	mov b, d
0521   094E 61 CB 26    	sub b, scrap_sector			; remove this later and fix address bases which display incorrectly
0522   0951 07 D7 02    	call print_u16x				; display row
0523   0954 10 00 3A    	mov a, $3A00
0524   0957 05 03       	syscall sys_io
0525   0959 10 00 20    	mov a, $2000
0526   095C 05 03       	syscall sys_io
0527   095E 0A FF 08    	jmp back
0528   0961             
0529   0961 0A 44 65 62 s_break1:	.db "\nDebugger entry point.\n"
0529   0965 75 67 67 65 
0529   0969 72 20 65 6E 
0529   096D 74 72 79 20 
0529   0971 70 6F 69 6E 
0529   0975 74 2E 0A 
0530   0978 30 2E 20 53 			.db "0. Show Registers\n"
0530   097C 68 6F 77 20 
0530   0980 52 65 67 69 
0530   0984 73 74 65 72 
0530   0988 73 0A 
0531   098A 31 2E 20 53 			.db "1. Show 512B RAM block\n"
0531   098E 68 6F 77 20 
0531   0992 35 31 32 42 
0531   0996 20 52 41 4D 
0531   099A 20 62 6C 6F 
0531   099E 63 6B 0A 
0532   09A1 32 2E 20 43 			.db "2. Continue Execution", 0
0532   09A5 6F 6E 74 69 
0532   09A9 6E 75 65 20 
0532   09AD 45 78 65 63 
0532   09B1 75 74 69 6F 
0532   09B5 6E 00 
0533   09B7             
0534   09B7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535   09B7             ; DIVIDE BY ZERO EXCEPTION
0536   09B7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0537   09B7             trap_div_zero:
0538   09B7 D7          	push a
0539   09B8 DA          	push d
0540   09B9 E1          	pushf
0541   09BA             		
0542   09BA 3B D5 16    	mov d, s_divzero
0543   09BD 07 7B 02    	call puts
0544   09C0             	
0545   09C0 EE          	popf
0546   09C1 E7          	pop d
0547   09C2 E4          	pop a
0548   09C3             							; enable interrupts
0549   09C3 06          	sysret
0550   09C4             
0551   09C4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0552   09C4             ; UNDEFINED OPCODE EXCEPTION
0553   09C4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0554   09C4             undefined_opcode:
0555   09C4 06          	sysret
0556   09C5             
0557   09C5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0558   09C5             ; RTC SERVICES INTERRUPT
0559   09C5             ; RTC I/O bank = FFA0 to FFAF
0560   09C5             ; FFA0 to FFA7 is scratch RAM
0561   09C5             ; control register at $FFA8 [ W | R | S | Cal4..Cal0 ]
0562   09C5             ; al = 0..6 -> get
0563   09C5             ; al = 7..D -> set
0564   09C5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0565   09C5             rtc_services:
0566   09C5 DB          	push al
0567   09C6 DA          	push d
0568   09C7 B9 06       	cmp al, 6
0569   09C9 D1 DE 09    	jgu rtc_set
0570   09CC             rtc_get:
0571   09CC 6A A9       	add al, $A9			; generate RTC address to get to address A9 of clock
0572   09CE 22 FF       	mov ah, $FF		
0573   09D0 3C          	mov d, a				; get to FFA9 + offset
0574   09D1 F2 A8 FF 40 	mov byte[$FFA8], $40		; set R bit to 1
0575   09D5 1E          	mov al, [d]			; get data
0576   09D6 F2 A8 FF 00 	mov byte[$FFA8], 0		; reset R bit
0577   09DA 23          	mov ah, al
0578   09DB E7          	pop d
0579   09DC E8          	pop al
0580   09DD 06          	sysret
0581   09DE             rtc_set:
0582   09DE DD          	push bl
0583   09DF 99          	mov bl, ah		; set data asIDE
0584   09E0 6A A2       	add al, $A2		; generate RTC address to get to address A9 of clock
0585   09E2 22 FF       	mov ah, $FF		
0586   09E4 3C          	mov d, a		; get to FFA9 + offset
0587   09E5 1B          	mov al, bl		; get data back
0588   09E6 F2 A8 FF 80 	mov byte[$FFA8], $80	; set W bit to 1
0589   09EA 3E          	mov [d], al		; set data
0590   09EB F2 A8 FF 00 	mov byte[$FFA8], 0		; reset write bit
0591   09EF EA          	pop bl
0592   09F0 E7          	pop d
0593   09F1 E8          	pop al
0594   09F2 06          	sysret
0595   09F3             
0596   09F3             datetime_serv_tbl:
0597   09F3 FB 09       	.dw print_date
0598   09F5 6F 0A       	.dw set_date
0599   09F7             datetime_services:
0600   09F7 FD 0A F3 09 	jmp [datetime_serv_tbl + al]			
0601   09FB             print_date:
0602   09FB 10 00 0D    	mov a, $0D00				; print carriage return char
0603   09FE 19 03       	mov al, 3
0604   0A00 05 01       	syscall sys_rtc				; get week
0605   0A02 1A          	mov al, ah
0606   0A03 22 00       	mov ah, 0
0607   0A05 FD 9D 02    	shl a, 2					
0608   0A08 3B 5F 17    	mov d, s_week
0609   0A0B 59          	add d, a
0610   0A0C 07 7B 02    	call puts
0611   0A0F 10 00 20    	mov a, $2000
0612   0A12 05 03       	syscall sys_io					; display ' '
0613   0A14             	
0614   0A14 19 04       	mov al, 4
0615   0A16 05 01       	syscall sys_rtc					; get day
0616   0A18 99          	mov bl, ah
0617   0A19 07 1B 03    	call print_u8x
0618   0A1C 10 00 20    	mov a, $2000
0619   0A1F 05 03       	syscall sys_io					; display ' '
0620   0A21             ; there is a problem with the month displaying
0621   0A21             ; the month is stored as BCD. so when retrieving the month, the value will be in binary
0622   0A21             ; even though it is to be understood as BCD.
0623   0A21             ; when retrieving the value and adding the string table address offset the value will go overboard!	
0624   0A21 19 05       	mov al, 05
0625   0A23 05 01       	syscall sys_rtc				; get month
0626   0A25 1A          	mov al, ah
0627   0A26 22 00       	mov ah, 0
0628   0A28 FD 9D 02    	shl a, 2					
0629   0A2B 3B 2B 17    	mov d, s_months
0630   0A2E 59          	add d, a
0631   0A2F 07 7B 02    	call puts
0632   0A32             	
0633   0A32 10 00 20    	mov a, $2000
0634   0A35 05 03       	syscall sys_io			; display ' '
0635   0A37             	
0636   0A37 2E 20       	mov bl, $20
0637   0A39 07 1B 03    	call print_u8x			; print 20 for year prefix
0638   0A3C 19 06       	mov al, 06
0639   0A3E 05 01       	syscall sys_rtc					; get year
0640   0A40 99          	mov bl, ah
0641   0A41 07 1B 03    	call print_u8x
0642   0A44             	
0643   0A44 10 00 20    	mov a, $2000	
0644   0A47 05 03       	syscall sys_io			; display ' '
0645   0A49             
0646   0A49 19 02       	mov al, 2
0647   0A4B 05 01       	syscall sys_rtc					; get hours
0648   0A4D 99          	mov bl, ah
0649   0A4E 07 1B 03    	call print_u8x
0650   0A51 10 00 3A    	mov a, $3A00		
0651   0A54 05 03       	syscall sys_io				; display ':'
0652   0A56             
0653   0A56 19 01       	mov al, 01
0654   0A58 05 01       	syscall sys_rtc					; get minutes
0655   0A5A 99          	mov bl, ah
0656   0A5B 07 1B 03    	call print_u8x
0657   0A5E 10 00 3A    	mov a, $3A00	
0658   0A61 05 03       	syscall sys_io			; display ':'
0659   0A63             
0660   0A63 19 00       	mov al, 0
0661   0A65 05 01       	syscall sys_rtc					; get seconds
0662   0A67 99          	mov bl, ah
0663   0A68 07 1B 03    	call print_u8x
0664   0A6B             	
0665   0A6B 07 28 02    	call printnl
0666   0A6E 06          	sysret
0667   0A6F             	
0668   0A6F             set_date:
0669   0A6F 3B F0 16    	mov d, s_set_year
0670   0A72 07 7B 02    	call puts
0671   0A75 07 62 03    	call scan_u8x				; read integer into A
0672   0A78 FD 9D 08    	shl a, 8				; only AL used, move to AH
0673   0A7B 19 0D       	mov al, 0Dh				; set RTC year
0674   0A7D 05 01       	syscall sys_rtc					; set RTC
0675   0A7F             	
0676   0A7F 3B F7 16    	mov d, s_set_month
0677   0A82 07 7B 02    	call puts
0678   0A85 07 62 03    	call scan_u8x					; read integer into A
0679   0A88 FD 9D 08    	shl a, 8				; only AL used, move to AH
0680   0A8B 19 0C       	mov al, 0Ch				; set RTC month
0681   0A8D 05 01       	syscall sys_rtc					; set RTC
0682   0A8F             
0683   0A8F 3B FF 16    	mov d, s_set_day
0684   0A92 07 7B 02    	call puts
0685   0A95 07 62 03    	call scan_u8x					; read integer into A
0686   0A98 FD 9D 08    	shl a, 8				; only AL used, move to AH
0687   0A9B 19 0B       	mov al, 0Bh				; set RTC month
0688   0A9D 05 01       	syscall sys_rtc					; set RTC
0689   0A9F             
0690   0A9F 3B 05 17    	mov d, s_set_week
0691   0AA2 07 7B 02    	call puts
0692   0AA5 07 62 03    	call scan_u8x					; read integer into A
0693   0AA8 FD 9D 08    	shl a, 8				; only AL used, move to AH
0694   0AAB 19 0A       	mov al, 0Ah				; set RTC month
0695   0AAD 05 01       	syscall sys_rtc					; set RTC
0696   0AAF             
0697   0AAF 3B 0F 17    	mov d, s_set_hours
0698   0AB2 07 7B 02    	call puts
0699   0AB5 07 62 03    	call scan_u8x					; read integer into A
0700   0AB8 FD 9D 08    	shl a, 8				; only AL used, move to AH
0701   0ABB 19 09       	mov al, 09h				; set RTC month
0702   0ABD 05 01       	syscall sys_rtc					; set RTC
0703   0ABF             
0704   0ABF 3B 17 17    	mov d, s_set_minutes
0705   0AC2 07 7B 02    	call puts
0706   0AC5 07 62 03    	call scan_u8x					; read integer into A
0707   0AC8 FD 9D 08    	shl a, 8				; only AL used, move to AH
0708   0ACB 19 08       	mov al, 08h				; set RTC month
0709   0ACD 05 01       	syscall sys_rtc					; set RTC
0710   0ACF             
0711   0ACF 3B 21 17    	mov d, s_set_seconds
0712   0AD2 07 7B 02    	call puts
0713   0AD5 07 62 03    	call scan_u8x					; read integer into A
0714   0AD8 FD 9D 08    	shl a, 8					; only AL used, move to AH
0715   0ADB 19 07       	mov al, 07h				; set RTC month
0716   0ADD 05 01       	syscall sys_rtc					; set RTC
0717   0ADF 06          	sysret
0718   0AE0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0719   0AE0             ; IDE SERVICES INTERRUPT
0720   0AE0             ; al = option
0721   0AE0             ; 0 = IDE reset, 1 = IDE sleep, 2 = read sector, 3 = write sector
0722   0AE0             ; IDE read/write sector
0723   0AE0             ; 512 bytes
0724   0AE0             ; user buffer pointer in D
0725   0AE0             ; AH = number of sectors
0726   0AE0             ; CB = LBA bytes 3..0
0727   0AE0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0728   0AE0             IDE_serv_tbl:
0729   0AE0 EC 0A       	.dw IDE_reset
0730   0AE2 00 0B       	.dw IDE_sleep
0731   0AE4 0F 0B       	.dw IDE_read_sect_wrapper
0732   0AE6 13 0B       	.dw IDE_write_sect_wrapper
0733   0AE8             IDE_services_kernel:
0734   0AE8 FD 0A E0 0A 	jmp [IDE_serv_tbl + al]		
0735   0AEC             	
0736   0AEC             IDE_reset:			
0737   0AEC F2 D7 FF 04 	mov byte[_IDE_R7], 4		; RESET IDE
0738   0AF0 07 99 0B    	call IDE_wait				; wait for IDE ready			 			
0739   0AF3 F2 D6 FF E0 	mov byte[_IDE_R6], $E0		; LBA3= 0, MASTER, MODE= LBA				
0740   0AF7 F2 D1 FF 01 	mov byte[_IDE_R1], 1		; 8-BIT TRANSFERS			
0741   0AFB F2 D7 FF EF 	mov byte[_IDE_R7], $EF		; SET FEATURE COMMAND
0742   0AFF 06          	sysret
0743   0B00             IDE_sleep:
0744   0B00 07 99 0B    	call IDE_wait					; wait for IDE ready			 			
0745   0B03 F2 D6 FF 40 	mov byte [_IDE_R6], %01000000	; lba[3:0](reserved), bit 6=1
0746   0B07 F2 D7 FF E6 	mov byte [_IDE_R7], $E6		; sleep command
0747   0B0B 07 99 0B    	call IDE_wait					; wait for IDE ready
0748   0B0E 06          	sysret
0749   0B0F             IDE_read_sect_wrapper:
0750   0B0F 07 17 0B    	call IDE_read_sect
0751   0B12 06          	sysret
0752   0B13             IDE_write_sect_wrapper:
0753   0B13 07 3D 0B    	call IDE_write_sect
0754   0B16 06          	sysret
0755   0B17             IDE_read_sect:
0756   0B17 1A          	mov al, ah
0757   0B18 24          	mov ah, bl
0758   0B19 42 D2 FF    	mov [_IDE_R2], a			; number of sectors (0..255)
0759   0B1C 1C          	mov al, bh
0760   0B1D 3D D4 FF    	mov [_IDE_R4], al
0761   0B20 12          	mov a, c
0762   0B21 3D D5 FF    	mov [_IDE_R5], al
0763   0B24 1A          	mov al, ah
0764   0B25 87 0F       	and al, %00001111
0765   0B27 8B E0       	or al, %11100000			; mode lba, master
0766   0B29 3D D6 FF    	mov [_IDE_R6], al
0767   0B2C             IDE_read_sect_wait:
0768   0B2C 1D D7 FF    	mov al, [_IDE_R7]	
0769   0B2F 87 80       	and al, $80				; BUSY FLAG
0770   0B31 C7 2C 0B    	jnz IDE_read_sect_wait
0771   0B34 19 20       	mov al, $20
0772   0B36 3D D7 FF    	mov [_IDE_R7], al			; read sector cmd
0773   0B39 07 63 0B    	call IDE_read	
0774   0B3C 09          	ret
0775   0B3D             IDE_write_sect:
0776   0B3D 1A          	mov al, ah
0777   0B3E 24          	mov ah, bl
0778   0B3F 42 D2 FF    	mov [_IDE_R2], a			; number of sectors (0..255)
0779   0B42 1C          	mov al, bh
0780   0B43 3D D4 FF    	mov [_IDE_R4], al
0781   0B46 12          	mov a, c
0782   0B47 3D D5 FF    	mov [_IDE_R5], al
0783   0B4A 1A          	mov al, ah
0784   0B4B 87 0F       	and al, %00001111
0785   0B4D 8B E0       	or al, %11100000			; mode lba, master
0786   0B4F 3D D6 FF    	mov [_IDE_R6], al
0787   0B52             IDE_write_sect_wait:
0788   0B52 1D D7 FF    	mov al, [_IDE_R7]	
0789   0B55 87 80       	and al, $80				; BUSY FLAG
0790   0B57 C7 52 0B    	jnz IDE_write_sect_wait
0791   0B5A 19 30       	mov al, $30
0792   0B5C 3D D7 FF    	mov [_IDE_R7], al			; write sector cmd
0793   0B5F 07 7E 0B    	call IDE_write			
0794   0B62 09          	ret
0795   0B63             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0796   0B63             ; READ IDE DATA
0797   0B63             ; pointer in D
0798   0B63             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0799   0B63             IDE_read:
0800   0B63 DA          	push d
0801   0B64             IDE_read_loop:
0802   0B64 1D D7 FF    	mov al, [_IDE_R7]	
0803   0B67 87 80       	and al, 80h				; BUSY FLAG
0804   0B69 C7 64 0B    	jnz IDE_read_loop			; wait loop
0805   0B6C             	
0806   0B6C 1D D7 FF    	mov al, [_IDE_R7]
0807   0B6F 87 08       	and al, %00001000			; DRQ FLAG
0808   0B71 C6 7C 0B    	jz IDE_read_end
0809   0B74 1D D0 FF    	mov al, [_IDE_R0]
0810   0B77 3E          	mov [d], al
0811   0B78 79          	inc d
0812   0B79 0A 64 0B    	jmp IDE_read_loop
0813   0B7C             IDE_read_end:
0814   0B7C E7          	pop d
0815   0B7D 09          	ret
0816   0B7E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0817   0B7E             ; WRITE IDE DATA
0818   0B7E             ; data pointer in D
0819   0B7E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0820   0B7E             IDE_write:
0821   0B7E DA          	push d
0822   0B7F             IDE_write_loop:
0823   0B7F 1D D7 FF    	mov al, [_IDE_R7]	
0824   0B82 87 80       	and al, 80h				; BUSY FLAG
0825   0B84 C7 7F 0B    	jnz IDE_write_loop			; wait loop
0826   0B87             	
0827   0B87 1D D7 FF    	mov al, [_IDE_R7]
0828   0B8A 87 08       	and al, %00001000			; DRQ FLAG
0829   0B8C C6 97 0B    	jz IDE_write_end
0830   0B8F 1E          	mov al, [d]
0831   0B90 3D D0 FF    	mov [_IDE_R0], al
0832   0B93 79          	inc d 
0833   0B94 0A 7F 0B    	jmp IDE_write_loop
0834   0B97             IDE_write_end:
0835   0B97 E7          	pop d
0836   0B98 09          	ret
0837   0B99             
0838   0B99             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0839   0B99             ; wait for IDE to be ready
0840   0B99             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0841   0B99             IDE_wait:
0842   0B99 1D D7 FF    	mov al, [_IDE_R7]	
0843   0B9C 87 80       	and al, 80h				; BUSY FLAG
0844   0B9E C7 99 0B    	jnz IDE_wait
0845   0BA1 09          	ret
0846   0BA2             
0847   0BA2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0848   0BA2             ; i/o interrupt
0849   0BA2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0850   0BA2             io_services_jmp:
0851   0BA2 C5 0B       	.dw io_putchar
0852   0BA4 D2 0B       	.dw io_getchar
0853   0BA6 AC 0B       	.dw io_uart_init
0854   0BA8             
0855   0BA8             io_services:
0856   0BA8 FD 0A A2 0B 	jmp [io_services_jmp + al]
0857   0BAC             io_uart_init:
0858   0BAC F2 83 FF 83 	mov byte[_UART0_LCR], $83			; 8 data, 1 stop, no parity	, divisor latch = 1, UART address 3 = Line Control Register
0859   0BB0 F2 80 FF 03 	mov byte[_UART0_DLAB_0], 3			; baud = 38400, divisor latch low byte = 3
0860   0BB4 F2 81 FF 00 	mov byte[_UART0_DLAB_1], 0			; divisor latch high byte = 0			
0861   0BB8 F2 83 FF 03 	mov byte[_UART0_LCR], 3			; UART address 3 = Line Control Register
0862   0BBC F2 81 FF 01 	mov byte[_UART0_IER], 1			; enable interrupt: receive data available
0863   0BC0 F2 82 FF 00 	mov byte[_UART0_FCR], 0			; disable FIFO
0864   0BC4 06          	sysret
0865   0BC5             ; char in ah
0866   0BC5             io_putchar:
0867   0BC5             io_putchar_L0:
0868   0BC5 1D 85 FF    	mov al, [_UART0_LSR]			; read Line Status Register
0869   0BC8 93 20       	test al, $20					; isolate Transmitter Empty
0870   0BCA C6 C5 0B    	jz io_putchar_L0		
0871   0BCD 1A          	mov al, ah
0872   0BCE 3D 80 FF    	mov [_UART0_DATA], al			; write char to Transmitter Holding Register
0873   0BD1 06          	sysret
0874   0BD2             ; char in ah
0875   0BD2             ; al = sucess code
0876   0BD2             io_getchar:
0877   0BD2 D8          	push b
0878   0BD3 DA          	push d
0879   0BD4             io_getchar_L0:	
0880   0BD4 14 21 16    	mov a, [fifo_pr]
0881   0BD7 29 1F 16    	mov b, [fifo_pi]
0882   0BDA B0          	cmp a, b
0883   0BDB C6 03 0C    	je io_getchar_fail
0884   0BDE             	
0885   0BDE 3C          	mov d, a
0886   0BDF 1E          	mov al, [d]
0887   0BE0 DB          	push al
0888   0BE1             	
0889   0BE1 14 21 16    	mov a, [fifo_pr]
0890   0BE4 77          	inc a
0891   0BE5 AF CB 26    	cmp a, fifo + FIFO_SIZE				; check if pointer reached the end of the fifo
0892   0BE8 C7 EE 0B    	jne io_getchar_cont
0893   0BEB 10 CB 1E    	mov a, fifo	
0894   0BEE             io_getchar_cont:	
0895   0BEE 42 21 16    	mov [fifo_pr], a			; update fifo pointer
0896   0BF1             	
0897   0BF1 E9          	pop ah
0898   0BF2             ; here we just echo the char back to the console
0899   0BF2             io_getchar_echo_L0:
0900   0BF2 1D 85 FF    	mov al, [_UART0_LSR]			; read Line Status Register
0901   0BF5 93 20       	test al, $20					; isolate Transmitter Empty
0902   0BF7 C6 F2 0B    	jz io_getchar_echo_L0
0903   0BFA 1A          	mov al, ah
0904   0BFB 3D 80 FF    	mov [_UART0_DATA], al			; write char to Transmitter Holding Register
0905   0BFE             
0906   0BFE 19 01       	mov al, 1		; AL = 1 means a char successfully received
0907   0C00 E7          	pop d
0908   0C01 E5          	pop b
0909   0C02 06          	sysret
0910   0C03             io_getchar_fail:
0911   0C03 E7          	pop d
0912   0C04 E5          	pop b
0913   0C05 19 00       	mov al, 0			; AL = 0 means no char received
0914   0C07 06          	sysret
0915   0C08             
0916   0C08             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0917   0C08             ;; FILE SYSTEM DATA
0918   0C08             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0919   0C08             ; infor for : IDE SERVICES INTERRUPT
0920   0C08             ; IDE read/write 512-byte sector
0921   0C08             ; al = option
0922   0C08             ; user buffer pointer in D
0923   0C08             ; AH = number of sectors
0924   0C08             ; CB = LBA bytes 3..0	
0925   0C08             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0926   0C08             ;; FILE SYSTEM DATA STRUCTURE
0927   0C08             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0928   0C08             ; for a directory we have the header first, followed by metadata
0929   0C08             ; header 1 sector (512 bytes)
0930   0C08             ; metadata 1 sector (512 bytes)
0931   0C08             ; HEADER ENTRIES:
0932   0C08             ; filename (64)
0933   0C08             ; parent dir LBA (2) -  to be used for faster backwards navigation...
0934   0C08             ;
0935   0C08             ; metadata entries:
0936   0C08             ; filename (24)
0937   0C08             ; attributes (1)	|_|_|file_type(3bits)|x|w|r| types: file, directory, character device
0938   0C08             ; LBA (2)
0939   0C08             ; size (2)
0940   0C08             ; day (1)
0941   0C08             ; month (1)
0942   0C08             ; year (1)
0943   0C08             ; packet size = 32 bytes
0944   0C08             ;
0945   0C08             ; first directory on disk is the root directory '/'
0946   0C08             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0947   0C08             ;; FILE SYSTEM DISK FORMATTING
0948   0C08             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0949   0C08             ; writes FST_TOTAL_SECTORS + FS_NBR_FILES disk sectors  with 0's
0950   0C08             ; this is the file system table formating
0951   0C08             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0952   0C08             file_system_jmptbl:
0953   0C08 38 0C       	.dw file_system_mkfs
0954   0C0A E3 0C       	.dw cmd_fs_space
0955   0C0C E4 0C       	.dw cmd_mkdir
0956   0C0E 5D 10       	.dw cmd_cd
0957   0C10 62 10       	.dw cmd_ls
0958   0C12 4B 11       	.dw cmd_mktxt
0959   0C14 CC 11       	.dw cmd_mkbin
0960   0C16 89 12       	.dw cmd_pwd
0961   0C18 F7 12       	.dw cmd_cat
0962   0C1A 53 13       	.dw cmd_rmdir					; 9
0963   0C1C AF 13       	.dw cmd_rm
0964   0C1E 00 00       	.dw 0
0965   0C20 00 00       	.dw 0
0966   0C22 00 00       	.dw 0							; 13
0967   0C24 67 0C       	.dw fileio_chmod				; 14
0968   0C26 17 14       	.dw cmd_mv						; 15
0969   0C28 60 0C       	.dw cd_goto_root				; 16
0970   0C2A 59 10       	.dw get_current_dirID			; 17
0971   0C2C 35 0E       	.dw get_path_from_dirID			; 18
0972   0C2E 9B 0E       	.dw get_dirID_from_path_user	; 19
0973   0C30 B5 0F       	.dw loadfile_from_path_user		; 20	
0974   0C32 25 0F       	.dw file_exists_by_path_user	; 21
0975   0C34             file_system:
0976   0C34 FD 0A 08 0C 	jmp [file_system_jmptbl + al]
0977   0C38             
0978   0C38             file_system_mkfs:	
0979   0C38 FD 4F CB 28 	mov di, transient_area
0980   0C3C 19 00       	mov al, 0
0981   0C3E 38 00 02    	mov c, 512
0982   0C41 FD F7       	rep stosb
0983   0C43 26 20 00    	mov b, FST_LBA_START
0984   0C46 38 00 00    	mov c, 0				; reset LBA to 0
0985   0C49             file_system_mkfs_L1:	
0986   0C49 22 01       	mov ah, $01			; one sect
0987   0C4B 3B CB 28    	mov d, transient_area
0988   0C4E 07 3D 0B    	call IDE_write_sect
0989   0C51 FD 77       	inc b
0990   0C53 C0 00 08    	cmp b, CF_CARD_LBA_SIZE
0991   0C56 C7 49 0C    	jne file_system_mkfs_L1
0992   0C59             file_system_mkfs_create_root:
0993   0C59 10 20 00    	mov a, ROOT_dirID
0994   0C5C 42 23 16    	mov [current_dirID], a		; set current directory LBA to ROOT
0995   0C5F 06          	sysret	
0996   0C60             	
0997   0C60             cd_goto_root:
0998   0C60 10 20 00    	mov a, ROOT_dirID
0999   0C63 42 23 16    	mov [current_dirID], a		; set current directory LBA to ROOT
1000   0C66 06          	sysret	
1001   0C67             
1002   0C67             ; filename in D (userspace data)
1003   0C67             ; permission in BL
1004   0C67             fileio_chmod:
1005   0C67 DD          	push bl
1006   0C68 FD 4E       	mov si, d
1007   0C6A FD 4F CB 1C 	mov di, temp_data
1008   0C6E 38 80 00    	mov c, 128
1009   0C71 04          	load					; load filename from user-space
1010   0C72             		
1011   0C72 14 23 16    	mov a, [current_dirID]
1012   0C75 77          	inc a				; metadata sector
1013   0C76 27          	mov b, a
1014   0C77 38 00 00    	mov c, 0				; reset LBA to 0
1015   0C7A 22 01       	mov ah, $01			; disk read
1016   0C7C 3B CB 28    	mov d, transient_area
1017   0C7F 07 17 0B    	call IDE_read_sect		; read directory
1018   0C82 FD 10       	cla
1019   0C84 42 1B 16    	mov [index], a		; reset file counter
1020   0C87             fileio_chmod_L1:
1021   0C87 FD 4E       	mov si, d
1022   0C89 FD 4F CB 1C 	mov di, temp_data
1023   0C8D 07 93 00    	call strcmp
1024   0C90 C6 A7 0C    	je fileio_chmod_found_entry
1025   0C93             
1026   0C93 58 20 00    	add d, 32
1027   0C96 14 1B 16    	mov a, [index]
1028   0C99 77          	inc a
1029   0C9A 42 1B 16    	mov [index], a
1030   0C9D AF 10 00    	cmp a, FST_FILES_PER_DIR
1031   0CA0 C7 87 0C    	jne fileio_chmod_L1
1032   0CA3 EA          	pop bl
1033   0CA4 0A C0 0C    	jmp fileio_chmod_not_found
1034   0CA7             fileio_chmod_found_entry:	
1035   0CA7 FD 79       	mov g, b					; save LBA
1036   0CA9 EA          	pop bl						; retrieve saved permission value
1037   0CAA 1F 18 00    	mov al, [d + 24]			; read file permissions
1038   0CAD 87 F8       	and al, %11111000			; remove all permissions, keep other flags
1039   0CAF 8C          	or al, bl					; set new permissions
1040   0CB0 3F 18 00    	mov [d + 24], al			; write new permissions
1041   0CB3 38 00 00    	mov c, 0
1042   0CB6 3B CB 28    	mov d, transient_area
1043   0CB9 22 01       	mov ah, $01				; disk write 1 sect
1044   0CBB FD 27       	mov b, g					; retrieve LBA
1045   0CBD 07 3D 0B    	call IDE_write_sect		; write sector
1046   0CC0             fileio_chmod_not_found:
1047   0CC0 06          	sysret
1048   0CC1             
1049   0CC1             ;; bootloader installer
1050   0CC1             ;; kernel LBA address in A
1051   0CC1             cmd_boot_installer:
1052   0CC1 D7          	push a
1053   0CC2 26 00 00    	mov b, 0
1054   0CC5 38 00 00    	mov c, 0
1055   0CC8 22 01       	mov ah, $01				; 1 sector
1056   0CCA 3B CB 28    	mov d, transient_area
1057   0CCD 07 17 0B    	call IDE_read_sect			; read sector
1058   0CD0             	
1059   0CD0 E4          	pop a
1060   0CD1 44 FE 01    	mov [d + 510], a		; update LBA address
1061   0CD4 26 00 00    	mov b, 0
1062   0CD7 38 00 00    	mov c, 0
1063   0CDA 22 01       	mov ah, $01				; 1 sector
1064   0CDC 3B CB 28    	mov d, transient_area
1065   0CDF 07 3D 0B    	call IDE_write_sect		; write sector
1066   0CE2             	
1067   0CE2 06          	sysret
1068   0CE3             
1069   0CE3             cmd_fs_space:
1070   0CE3 06          	sysret
1071   0CE4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1072   0CE4             ;; CREATE NEW DIRECTORY
1073   0CE4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1074   0CE4             ; search list for NULL name entry. add new directory to list
1075   0CE4             cmd_mkdir:
1076   0CE4 FD 4E       	mov si, d
1077   0CE6 FD 4F CB 1C 	mov di, temp_data
1078   0CEA 38 00 02    	mov c, 512
1079   0CED 04          	load						; load data from user-space
1080   0CEE 26 22 00    	mov b, FST_LBA_START + 2 	; start at 2 because LBA  0 is ROOT (this would also cause issues 								
1081   0CF1             								; when checking for NULL name, since root has a NULL name)
1082   0CF1 38 00 00    	mov c, 0					; reset LBA to 0
1083   0CF4             cmd_mkdir_L1:	
1084   0CF4 22 01       	mov ah, $01			; disk read
1085   0CF6 3B CB 28    	mov d, transient_area
1086   0CF9 07 17 0B    	call IDE_read_sect		; read sector
1087   0CFC BD 00       	cmp byte[d], 0			; check for NULL
1088   0CFE C6 07 0D    	je cmd_mkdir_found_null
1089   0D01 55 02 00    	add b, FST_SECTORS_PER_DIR					; skip directory
1090   0D04 0A F4 0C    	jmp cmd_mkdir_L1
1091   0D07             cmd_mkdir_found_null:
1092   0D07             ;create header file by grabbing dir name from parameter
1093   0D07 D8          	push b				; save new directory's LBA
1094   0D08 38 40 00    	mov c, 64
1095   0D0B FD 4D CB 1C 	mov si, temp_data
1096   0D0F FD 4F CB 28 	mov di, transient_area
1097   0D13 FD F5       	rep movsb					; copy dirname from temp_data to transient_area
1098   0D15 14 23 16    	mov a, [current_dirID]
1099   0D18 42 0B 29    	mov [transient_area + 64], a		; store parent directory LBA
1100   0D1B 19 00       	mov al, 0
1101   0D1D FD 4F CB 2A 	mov di, transient_area + 512
1102   0D21 38 00 02    	mov c, 512
1103   0D24 FD F7       	rep stosb					; clean buffer
1104   0D26 38 00 00    	mov c, 0				; reset LBA(c) to 0
1105   0D29             ; write directory entry sectors
1106   0D29 3B CB 28    	mov d, transient_area
1107   0D2C 22 02       	mov ah, $02			; disk write, 2 sectors
1108   0D2E 07 3D 0B    	call IDE_write_sect		; write sector
1109   0D31             ; now we need to add the new directory to the list, insIDE the current directory
1110   0D31 14 23 16    	mov a, [current_dirID]
1111   0D34 53 01 00    	add a, 1
1112   0D37 27          	mov b, a					; metadata sector
1113   0D38 38 00 00    	mov c, 0
1114   0D3B FD 79       	mov g, b					; save LBA
1115   0D3D 3B CB 28    	mov d, transient_area
1116   0D40 22 01       	mov ah, $01			; disk read
1117   0D42 07 17 0B    	call IDE_read_sect		; read metadata sector
1118   0D45             cmd_mkdir_L2:
1119   0D45 BD 00       	cmp byte[d], 0
1120   0D47 C6 50 0D    	je cmd_mkdir_found_null2
1121   0D4A 58 20 00    	add d, FST_ENTRY_SIZE
1122   0D4D 0A 45 0D    	jmp cmd_mkdir_L2					; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1123   0D50             cmd_mkdir_found_null2:
1124   0D50 FD 4D CB 1C 	mov si, temp_data
1125   0D54 FD 50       	mov di, d
1126   0D56 07 A8 00    	call strcpy			; copy directory name
1127   0D59 58 18 00    	add d, 24			; goto ATTRIBUTES
1128   0D5C 19 0B       	mov al, %00001011		;directory, no execute, write, read
1129   0D5E 3E          	mov [d], al			
1130   0D5F 79          	inc d
1131   0D60 E5          	pop b
1132   0D61 D8          	push b				; push LBA back
1133   0D62 FD 43       	mov [d], b			; save LBA
1134   0D64             ; set file creation date	
1135   0D64 58 04 00    	add d, 4
1136   0D67 19 04       	mov al, 4
1137   0D69 05 01       	syscall sys_rtc
1138   0D6B 1A          	mov al, ah
1139   0D6C 3E          	mov [d], al			; set day
1140   0D6D 79          	inc d
1141   0D6E 19 05       	mov al, 5
1142   0D70 05 01       	syscall sys_rtc
1143   0D72 1A          	mov al, ah
1144   0D73 3E          	mov [d], al			; set month
1145   0D74 79          	inc d
1146   0D75 19 06       	mov al, 6
1147   0D77 05 01       	syscall sys_rtc
1148   0D79 1A          	mov al, ah
1149   0D7A 3E          	mov [d], al			; set year
1150   0D7B             ; write sector into disk for new directory entry
1151   0D7B FD 27       	mov b, g
1152   0D7D 38 00 00    	mov c, 0
1153   0D80 3B CB 28    	mov d, transient_area
1154   0D83 22 01       	mov ah, $01			; disk write, 1 sector
1155   0D85 07 3D 0B    	call IDE_write_sect		; write sector
1156   0D88             
1157   0D88             ; after adding the new directory's information to its parent directory's list
1158   0D88             ; we need to now enter the new directory, and to it add two new directories!
1159   0D88             ; which directories do we need to add ? '..' and '.' are the directories needed.
1160   0D88             ; importantly, note that these two new directories are only entries in the list
1161   0D88             ; and do not have actual physical entries in the disk as real directories.
1162   0D88             ; i.e. they only exist as list entries in the new directory created so that
1163   0D88             ; the new directory can reference its parent and itself
1164   0D88             ;
1165   0D88             ; we need to add both '..' and '.'
1166   0D88             ; this first section is for '..' and on the section below we do the same for '.'
1167   0D88 E4          	pop a						; retrieve the new directory's LBA	
1168   0D89 D7          	push a						; and save again
1169   0D8A 53 01 00    	add a, 1
1170   0D8D 27          	mov b, a					; metadata sector
1171   0D8E 38 00 00    	mov c, 0
1172   0D91 FD 79       	mov g, b					; save LBA
1173   0D93 3B CB 28    	mov d, transient_area
1174   0D96 22 01       	mov ah, $01			; disk read
1175   0D98 07 17 0B    	call IDE_read_sect		; read metadata sector
1176   0D9B             cmd_mkdir_L3:
1177   0D9B BD 00       	cmp byte[d], 0
1178   0D9D C6 A6 0D    	je cmd_mkdir_found_null3
1179   0DA0 58 20 00    	add d, FST_ENTRY_SIZE
1180   0DA3 0A 9B 0D    	jmp cmd_mkdir_L3	; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1181   0DA6             cmd_mkdir_found_null3:
1182   0DA6 FD 4D 30 16 	mov si, s_parent_dir
1183   0DAA FD 50       	mov di, d
1184   0DAC 07 A8 00    	call strcpy			; copy directory name
1185   0DAF 58 18 00    	add d, 24			; goto ATTRIBUTES
1186   0DB2 19 0B       	mov al, %00001011		;directory, no execute, write, read, 
1187   0DB4 3E          	mov [d], al			
1188   0DB5 79          	inc d
1189   0DB6 29 23 16    	mov b, [current_dirID]	; retrieve the parent directorys LBA
1190   0DB9 FD 43       	mov [d], b			; save LBA
1191   0DBB             ; set file creation date	
1192   0DBB 58 04 00    	add d, 4
1193   0DBE 19 04       	mov al, 4
1194   0DC0 05 01       	syscall sys_rtc
1195   0DC2 1A          	mov al, ah
1196   0DC3 3E          	mov [d], al			; set day
1197   0DC4 79          	inc d
1198   0DC5 19 05       	mov al, 5
1199   0DC7 05 01       	syscall sys_rtc
1200   0DC9 1A          	mov al, ah
1201   0DCA 3E          	mov [d], al			; set month
1202   0DCB 79          	inc d
1203   0DCC 19 06       	mov al, 6
1204   0DCE 05 01       	syscall sys_rtc
1205   0DD0 1A          	mov al, ah
1206   0DD1 3E          	mov [d], al			; set year
1207   0DD2             ; write sector into disk for new directory entry
1208   0DD2 FD 27       	mov b, g
1209   0DD4 38 00 00    	mov c, 0
1210   0DD7 3B CB 28    	mov d, transient_area
1211   0DDA 22 01       	mov ah, $01			; disk write, 1 sector
1212   0DDC 07 3D 0B    	call IDE_write_sect		; write sector
1213   0DDF             
1214   0DDF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1215   0DDF             ; like we did above for '..', we need to now add the '.' directory to the list.
1216   0DDF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1217   0DDF E4          	pop a						; retrieve the new directory's LBA	
1218   0DE0 D7          	push a
1219   0DE1 53 01 00    	add a, 1
1220   0DE4 27          	mov b, a					; metadata sector
1221   0DE5 38 00 00    	mov c, 0
1222   0DE8 FD 79       	mov g, b					; save LBA
1223   0DEA 3B CB 28    	mov d, transient_area
1224   0DED 22 01       	mov ah, $01				; disk read
1225   0DEF 07 17 0B    	call IDE_read_sect				; read metadata sector
1226   0DF2             cmd_mkdir_L4:
1227   0DF2 BD 00       	cmp byte[d], 0
1228   0DF4 C6 FD 0D    	je cmd_mkdir_found_null4
1229   0DF7 58 20 00    	add d, FST_ENTRY_SIZE
1230   0DFA 0A F2 0D    	jmp cmd_mkdir_L4	; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1231   0DFD             cmd_mkdir_found_null4:
1232   0DFD FD 4D 33 16 	mov si, s_current_dir
1233   0E01 FD 50       	mov di, d
1234   0E03 07 A8 00    	call strcpy			; copy directory name
1235   0E06 58 18 00    	add d, 24			; goto ATTRIBUTES
1236   0E09 19 0B       	mov al, %00001011		;directory, no execute, write, read, 
1237   0E0B 3E          	mov [d], al			
1238   0E0C 79          	inc d
1239   0E0D E5          	pop b				; new directory's LBA itself. for self-referential directory entry '.'
1240   0E0E FD 43       	mov [d], b			; save LBA
1241   0E10             ; set file creation date	
1242   0E10 58 04 00    	add d, 4
1243   0E13 19 04       	mov al, 4
1244   0E15 05 01       	syscall sys_rtc
1245   0E17 1A          	mov al, ah
1246   0E18 3E          	mov [d], al			; set day
1247   0E19 79          	inc d
1248   0E1A 19 05       	mov al, 5
1249   0E1C 05 01       	syscall sys_rtc
1250   0E1E 1A          	mov al, ah
1251   0E1F 3E          	mov [d], al			; set month
1252   0E20 79          	inc d
1253   0E21 19 06       	mov al, 6
1254   0E23 05 01       	syscall sys_rtc
1255   0E25 1A          	mov al, ah
1256   0E26 3E          	mov [d], al			; set year
1257   0E27             ; write sector into disk for new directory entry
1258   0E27 FD 27       	mov b, g
1259   0E29 38 00 00    	mov c, 0
1260   0E2C 3B CB 28    	mov d, transient_area
1261   0E2F 22 01       	mov ah, $01			; disk write, 1 sector
1262   0E31 07 3D 0B    	call IDE_write_sect		; write sector
1263   0E34             cmd_mkdir_end:
1264   0E34 06          	sysret
1265   0E35             
1266   0E35             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1267   0E35             ;; get path from a given directory dirID
1268   0E35             ;; pseudo code:
1269   0E35             ;	get_path_from_dirID(int dirID, char *D){
1270   0E35             ;		if(dirID == 0){
1271   0E35             ;			reverse path in D;
1272   0E35             ;			return;
1273   0E35             ;		}
1274   0E35             ;		else{
1275   0E35             ;			copy directory name to end of D;
1276   0E35             ;			add '/' to end of D;
1277   0E35             ;			parentID = get parent directory ID;
1278   0E35             ;			get_path_from_dirID(parentID, D);
1279   0E35             ;		}
1280   0E35             ;	}
1281   0E35             ;; A = dirID
1282   0E35             ;; D = generated path string pointer
1283   0E35             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1284   0E35             ;; sample path: /usr/bin
1285   0E35             get_path_from_dirID:
1286   0E35 3B CB 1A    	mov d, filename
1287   0E38 19 00       	mov al, 0
1288   0E3A 3E          	mov [d], al				; initialize path string 
1289   0E3B 14 23 16    	mov a, [current_dirID]
1290   0E3E 07 4B 0E    	call get_path_from_dirID_E0
1291   0E41 3B CB 1A    	mov d, filename
1292   0E44 07 3C 00    	call strrev
1293   0E47 07 7B 02    	call puts
1294   0E4A 06          	sysret
1295   0E4B             get_path_from_dirID_E0:
1296   0E4B 07 6A 0E    	call get_dirname_from_dirID
1297   0E4E FD 4D 35 16 	mov si, s_fslash
1298   0E52 FD 50       	mov di, d
1299   0E54 07 B6 00    	call strcat						; add '/' to end of path
1300   0E57 AF 20 00    	cmp a, ROOT_dirID				; check if we are at the root directory
1301   0E5A C6 69 0E    	je get_path_from_dirID_root
1302   0E5D 07 87 0E    	call get_parentID_from_dirID	; use current ID (A) to find parentID (into A)
1303   0E60 AF 20 00    	cmp a, ROOT_dirID				; check if we are at the root directory
1304   0E63 C6 69 0E    	je get_path_from_dirID_root
1305   0E66 07 4B 0E    	call get_path_from_dirID_E0		; recursively call itself
1306   0E69             get_path_from_dirID_root:
1307   0E69 09          	ret
1308   0E6A             
1309   0E6A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1310   0E6A             ;; inputs:
1311   0E6A             ;; A = directory ID
1312   0E6A             ;; outputs:
1313   0E6A             ;; D = pointer to directory name string
1314   0E6A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1315   0E6A             get_dirname_from_dirID:
1316   0E6A D7          	push a
1317   0E6B D8          	push b
1318   0E6C DA          	push d
1319   0E6D 27          	mov b, a
1320   0E6E 38 00 00    	mov c, 0				; reset LBA to 0
1321   0E71 22 01       	mov ah, $01			; disk read
1322   0E73 3B CB 26    	mov d, transient_area - 512
1323   0E76 07 17 0B    	call IDE_read_sect			; read directory
1324   0E79 07 3C 00    	call strrev				; reverse dir name before copying
1325   0E7C FD 4E       	mov si, d
1326   0E7E E7          	pop d					; destination address = D value pushed at beginning
1327   0E7F FD 50       	mov di, d
1328   0E81 07 B6 00    	call strcat				; copy filename to D
1329   0E84 E5          	pop b
1330   0E85 E4          	pop a
1331   0E86 09          	ret
1332   0E87             
1333   0E87             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1334   0E87             ;; inputs:
1335   0E87             ;; A = directory ID
1336   0E87             ;; outputs:
1337   0E87             ;; A = parent directory ID
1338   0E87             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1339   0E87             get_parentID_from_dirID:
1340   0E87 D8          	push b
1341   0E88 DA          	push d
1342   0E89 27          	mov b, a
1343   0E8A 38 00 00    	mov c, 0				; reset LBA to 0
1344   0E8D 22 01       	mov ah, $01			; disk read
1345   0E8F 3B CB 26    	mov d, transient_area - 512
1346   0E92 07 17 0B    	call IDE_read_sect			; read directory
1347   0E95 16 40 00    	mov a, [d + 64]			; copy parent ID value to A
1348   0E98 E7          	pop d
1349   0E99 E5          	pop b
1350   0E9A 09          	ret
1351   0E9B             
1352   0E9B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1353   0E9B             ;; get dirID from a given path string
1354   0E9B             ;; inputs:
1355   0E9B             ;; D = path pointer 
1356   0E9B             ;; outputs:
1357   0E9B             ;; A = dirID
1358   0E9B             ;; if dir non existent, A = FFFF (fail code)
1359   0E9B             ;; /usr/local/bin		- absolute
1360   0E9B             ;; local/bin/games		- relative
1361   0E9B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1362   0E9B             get_dirID_from_path_user:
1363   0E9B FD 4E       	mov si, d
1364   0E9D FD 4F CB 1C 	mov di, temp_data
1365   0EA1 38 00 02    	mov c, 512
1366   0EA4 04          	load
1367   0EA5 07 A9 0E    	call get_dirID_from_path
1368   0EA8 06          	sysret
1369   0EA9             
1370   0EA9             get_dirID_from_path:
1371   0EA9 26 CB 1C    	mov b, temp_data
1372   0EAC FD 42 7A 06 	mov [prog], b			; token pointer set to path string
1373   0EB0 07 DB 04    	call get_token
1374   0EB3 31 7D 06    	mov bl, [tok]
1375   0EB6 C1 01       	cmp bl, TOK_FSLASH
1376   0EB8 C6 C4 0E    	je get_dirID_from_path_abs 
1377   0EBB 14 23 16    	mov a, [current_dirID]
1378   0EBE 07 61 06    	call putback
1379   0EC1 0A C7 0E    	jmp get_dirID_from_path_E0
1380   0EC4             get_dirID_from_path_abs:
1381   0EC4 10 20 00    	mov a, ROOT_dirID
1382   0EC7             get_dirID_from_path_E0:
1383   0EC7 07 DB 04    	call get_token
1384   0ECA 31 7C 06    	mov bl, [toktyp]
1385   0ECD C1 00       	cmp bl, TOKTYP_IDENTIFIER
1386   0ECF C7 20 0F    	jne get_dirID_from_path_end	; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1387   0ED2             
1388   0ED2 FD 4D 7E 06 	mov si, tokstr
1389   0ED6 FD 4F CB 1A 	mov di, filename
1390   0EDA 07 A8 00    	call strcpy				
1391   0EDD 77          	inc a					; metadata sector
1392   0EDE 27          	mov b, a
1393   0EDF 38 00 00    	mov c, 0				; reset LBA to 0
1394   0EE2 22 01       	mov ah, $01			; disk read
1395   0EE4 3B CB 28    	mov d, transient_area
1396   0EE7 07 17 0B    	call IDE_read_sect		; read directory
1397   0EEA FD 10       	cla
1398   0EEC 42 1B 16    	mov [index], a
1399   0EEF             get_dirID_from_path_L1:
1400   0EEF FD 4E       	mov si, d
1401   0EF1 FD 4F CB 1A 	mov di, filename
1402   0EF5 07 93 00    	call strcmp
1403   0EF8 C6 0E 0F    	je get_dirID_from_path_name_equal	
1404   0EFB 58 20 00    	add d, 32
1405   0EFE 14 1B 16    	mov a, [index]
1406   0F01 77          	inc a
1407   0F02 42 1B 16    	mov [index], a
1408   0F05 AF 10 00    	cmp a, FST_FILES_PER_DIR
1409   0F08 C6 21 0F    	je get_dirID_from_path_fail
1410   0F0B 0A EF 0E    	jmp get_dirID_from_path_L1
1411   0F0E             get_dirID_from_path_name_equal:
1412   0F0E 58 19 00    	add d, 25					; 
1413   0F11 15          	mov a, [d]					; set result register A = dirID
1414   0F12 07 DB 04    	call get_token
1415   0F15 31 7D 06    	mov bl, [tok]
1416   0F18 C1 01       	cmp bl, TOK_FSLASH			; check if there are more elements in the path
1417   0F1A C6 C7 0E    	je get_dirID_from_path_E0
1418   0F1D 07 61 06    	call putback
1419   0F20             get_dirID_from_path_end:
1420   0F20 09          	ret
1421   0F21             get_dirID_from_path_fail:
1422   0F21 10 FF FF    	mov A, $FFFF
1423   0F24 09          	ret
1424   0F25             
1425   0F25             
1426   0F25             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1427   0F25             ;; check if file exists by a given path string
1428   0F25             ;; inputs:
1429   0F25             ;; D = path pointer 
1430   0F25             ;; OUTPUTS:
1431   0F25             ;; A = success code, if file exists gives LBA, else, give 0
1432   0F25             ;; /usr/local/bin/ed
1433   0F25             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1434   0F25             file_exists_by_path_user:
1435   0F25 FD 4E       	mov si, d
1436   0F27 FD 4F CB 1C 	mov di, temp_data
1437   0F2B 38 00 02    	mov c, 512
1438   0F2E 04          	load
1439   0F2F 07 33 0F    	call file_exists_by_path
1440   0F32 06          	sysret
1441   0F33             file_exists_by_path:
1442   0F33 26 CB 1C    	mov b, temp_data
1443   0F36 FD 42 7A 06 	mov [prog], b			; token pointer set to path string
1444   0F3A 07 DB 04    	call get_token
1445   0F3D 31 7D 06    	mov bl, [tok]
1446   0F40 C1 01       	cmp bl, TOK_FSLASH
1447   0F42 C6 4E 0F    	je  file_exists_by_path_abs
1448   0F45 14 23 16    	mov a, [current_dirID]
1449   0F48 07 61 06    	call putback
1450   0F4B 0A 51 0F    	jmp file_exists_by_path_E0
1451   0F4E             file_exists_by_path_abs:
1452   0F4E 10 20 00    	mov a, ROOT_dirID
1453   0F51             file_exists_by_path_E0:
1454   0F51 07 DB 04    	call get_token
1455   0F54 31 7C 06    	mov bl, [toktyp]
1456   0F57 C1 00       	cmp bl, TOKTYP_IDENTIFIER
1457   0F59 C7 B1 0F    	jne file_exists_by_path_end	; check if there are tokens after '/'
1458   0F5C FD 4D 7E 06 	mov si, tokstr
1459   0F60 FD 4F CB 1A 	mov di, filename
1460   0F64 07 A8 00    	call strcpy				
1461   0F67 77          	inc a					; metadata sector
1462   0F68 27          	mov b, a
1463   0F69 38 00 00    	mov c, 0				; reset LBA to 0
1464   0F6C 22 01       	mov ah, $01			; disk read
1465   0F6E 3B CB 28    	mov d, transient_area
1466   0F71 07 17 0B    	call IDE_read_sect		; read directory
1467   0F74 FD 10       	cla
1468   0F76 42 1B 16    	mov [index], a
1469   0F79             file_exists_by_path_L1:
1470   0F79 FD 4E       	mov si, d
1471   0F7B FD 4F CB 1A 	mov di, filename
1472   0F7F 07 93 00    	call strcmp
1473   0F82 C6 98 0F    	je 	file_exists_by_path_name_equal
1474   0F85 58 20 00    	add d, 32
1475   0F88 14 1B 16    	mov a, [index]
1476   0F8B 77          	inc a
1477   0F8C 42 1B 16    	mov [index], a
1478   0F8F AF 10 00    	cmp a, FST_FILES_PER_DIR
1479   0F92 C6 B1 0F    	je file_exists_by_path_end
1480   0F95 0A 79 0F    	jmp file_exists_by_path_L1
1481   0F98             file_exists_by_path_name_equal:
1482   0F98 33 18 00    	mov bl, [d + 24]
1483   0F9B FD 87 38    	and bl, %00111000			; directory flag
1484   0F9E C1 08       	cmp bl, %00001000			; is dir?
1485   0FA0 C6 A7 0F    	je file_exists_by_path_isdir;
1486   0FA3             ; entry is a file
1487   0FA3 16 19 00    	mov a, [d + 25]			; get and return LBA of file
1488   0FA6 09          	ret
1489   0FA7             file_exists_by_path_isdir:
1490   0FA7 58 19 00    	add d, 25					; 
1491   0FAA 15          	mov a, [d]					; set result register A = dirID
1492   0FAB 07 DB 04    	call get_token
1493   0FAE 0A 51 0F    	jmp file_exists_by_path_E0
1494   0FB1             file_exists_by_path_end:
1495   0FB1 10 00 00    	mov a, 0			; return 0 because file was not found
1496   0FB4 09          	ret
1497   0FB5             
1498   0FB5             
1499   0FB5             
1500   0FB5             
1501   0FB5             
1502   0FB5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1503   0FB5             ;; load file data from a given path string
1504   0FB5             ;; inputs:
1505   0FB5             ;; D = path pointer 
1506   0FB5             ;; DI = userspace program data destination
1507   0FB5             ;; /usr/local/bin/ed
1508   0FB5             ;; ./ed
1509   0FB5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1510   0FB5             loadfile_from_path_user:
1511   0FB5 E3          	push di
1512   0FB6 FD 4E       	mov si, d
1513   0FB8 FD 4F CB 1C 	mov di, temp_data
1514   0FBC 38 00 02    	mov c, 512
1515   0FBF 04          	load
1516   0FC0 07 CD 0F    	call loadfile_from_path
1517   0FC3 F0          	pop di
1518   0FC4 FD 4D CB 28 	mov si, transient_area
1519   0FC8 38 00 3E    	mov c, 512 * (FS_SECTORS_PER_FILE-1)
1520   0FCB 03          	store
1521   0FCC 06          	sysret
1522   0FCD             loadfile_from_path:
1523   0FCD 26 CB 1C    	mov b, temp_data
1524   0FD0 FD 42 7A 06 	mov [prog], b			; token pointer set to path string
1525   0FD4 07 DB 04    	call get_token
1526   0FD7 31 7D 06    	mov bl, [tok]
1527   0FDA C1 01       	cmp bl, TOK_FSLASH
1528   0FDC C6 E8 0F    	je loadfile_from_path_abs 
1529   0FDF 14 23 16    	mov a, [current_dirID]
1530   0FE2 07 61 06    	call putback
1531   0FE5 0A EB 0F    	jmp loadfile_from_path_E0
1532   0FE8             loadfile_from_path_abs:
1533   0FE8 10 20 00    	mov a, ROOT_dirID
1534   0FEB             loadfile_from_path_E0:
1535   0FEB 07 DB 04    	call get_token
1536   0FEE 31 7C 06    	mov bl, [toktyp]
1537   0FF1 C1 00       	cmp bl, TOKTYP_IDENTIFIER
1538   0FF3 C7 58 10    	jne loadfile_from_path_end	; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1539   0FF6 FD 4D 7E 06 	mov si, tokstr
1540   0FFA FD 4F CB 1A 	mov di, filename
1541   0FFE 07 A8 00    	call strcpy				
1542   1001 77          	inc a					; metadata sector
1543   1002 27          	mov b, a
1544   1003 38 00 00    	mov c, 0				; reset LBA to 0
1545   1006 22 01       	mov ah, $01			; disk read
1546   1008 3B CB 28    	mov d, transient_area
1547   100B 07 17 0B    	call IDE_read_sect		; read directory
1548   100E FD 10       	cla
1549   1010 42 1B 16    	mov [index], a
1550   1013             loadfile_from_path_L1:
1551   1013 FD 4E       	mov si, d
1552   1015 FD 4F CB 1A 	mov di, filename
1553   1019 07 93 00    	call strcmp
1554   101C C6 32 10    	je loadfile_from_path_name_equal	
1555   101F 58 20 00    	add d, 32
1556   1022 14 1B 16    	mov a, [index]
1557   1025 77          	inc a
1558   1026 42 1B 16    	mov [index], a
1559   1029 AF 10 00    	cmp a, FST_FILES_PER_DIR
1560   102C C6 58 10    	je loadfile_from_path_end
1561   102F 0A 13 10    	jmp loadfile_from_path_L1
1562   1032             loadfile_from_path_name_equal:
1563   1032 33 18 00    	mov bl, [d + 24]
1564   1035 FD 87 38    	and bl, %00111000			; directory flag
1565   1038 C1 08       	cmp bl, %00001000			; is dir?
1566   103A C6 4E 10    	je loadfile_isdirectory	;
1567   103D             ; entry is a file
1568   103D 2B 19 00    	mov b, [d + 25]			; get LBA
1569   1040 FD 77       	inc b				; add 1 to B because the LBA for data comes after the header sector
1570   1042 3B CB 28    	mov d, transient_area
1571   1045 38 00 00    	mov c, 0
1572   1048 22 1F       	mov ah, FS_SECTORS_PER_FILE-1		; number of sectors
1573   104A 07 17 0B    	call IDE_read_sect				; read sector
1574   104D 09          	ret
1575   104E             loadfile_isdirectory:
1576   104E 58 19 00    	add d, 25					; 
1577   1051 15          	mov a, [d]					; set result register A = dirID
1578   1052 07 DB 04    	call get_token
1579   1055 0A EB 0F    	jmp loadfile_from_path_E0
1580   1058             loadfile_from_path_end:
1581   1058 09          	ret
1582   1059             
1583   1059             
1584   1059             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1585   1059             ;; return the ID of the current directory
1586   1059             ;; ID returned in B
1587   1059             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1588   1059             get_current_dirID:
1589   1059 29 23 16    	mov b, [current_dirID]
1590   105C 06          	sysret
1591   105D             
1592   105D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1593   105D             ;; CD
1594   105D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1595   105D             ; new dirID in B
1596   105D             cmd_cd:
1597   105D FD 42 23 16 	mov [current_dirID], b
1598   1061 06          	sysret	
1599   1062             
1600   1062             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1601   1062             ;; LS
1602   1062             ;; dirID in B
1603   1062             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1604   1062             cmd_ls:
1605   1062 FD 77       	inc b				; metadata sector
1606   1064 38 00 00    	mov c, 0				; reset LBA to 0
1607   1067 22 01       	mov ah, $01			; disk read
1608   1069 3B CB 28    	mov d, transient_area
1609   106C 07 17 0B    	call IDE_read_sect		; read directory
1610   106F FD 10       	cla
1611   1071 42 1B 16    	mov [index], a		; reset entry index
1612   1074             cmd_ls_L1:
1613   1074 BD 00       	cmp byte [d], 0		; check for NULL
1614   1076 C6 06 11    	je cmd_ls_next
1615   1079             cmd_ls_non_null:
1616   1079 1F 18 00    	mov al, [d + 24]
1617   107C 87 38       	and al, %00111000
1618   107E FD A2 03    	shr al, 3
1619   1081 22 00       	mov ah, 0					; file type
1620   1083 B7 40 16    	mov a, [a + file_type]			
1621   1086 23          	mov ah, al
1622   1087 07 46 01    	call putchar
1623   108A 1F 18 00    	mov al, [d + 24]
1624   108D 87 01       	and al, %00000001
1625   108F 22 00       	mov ah, 0
1626   1091 B7 3B 16    	mov a, [a + file_attrib]		; read
1627   1094 23          	mov ah, al
1628   1095 07 46 01    	call putchar
1629   1098 1F 18 00    	mov al, [d + 24]
1630   109B 87 02       	and al, %00000010
1631   109D 22 00       	mov ah, 0
1632   109F B7 3B 16    	mov a, [a + file_attrib]		; write
1633   10A2 23          	mov ah, al
1634   10A3 07 46 01    	call putchar
1635   10A6 1F 18 00    	mov al, [d + 24]
1636   10A9 87 04       	and al, %00000100
1637   10AB 22 00       	mov ah, 0
1638   10AD B7 3B 16    	mov a, [a + file_attrib]		; execute
1639   10B0 23          	mov ah, al
1640   10B1 07 46 01    	call putchar
1641   10B4 22 20       	mov ah, $20
1642   10B6 07 46 01    	call putchar	
1643   10B9 16 1B 00    	mov a, [d + 27]
1644   10BC 07 A4 02    	call print_u16d				; filesize
1645   10BF 22 20       	mov ah, $20
1646   10C1 07 46 01    	call putchar	
1647   10C4 16 19 00    	mov a, [d + 25]
1648   10C7 07 A4 02    	call print_u16d			; dirID / LBA
1649   10CA 22 20       	mov ah, $20
1650   10CC 07 46 01    	call putchar
1651   10CF             ; print date
1652   10CF 33 1D 00    	mov bl, [d + 29]			; day
1653   10D2 07 1B 03    	call print_u8x
1654   10D5 22 20       	mov ah, $20
1655   10D7 07 46 01    	call putchar	
1656   10DA 1F 1E 00    	mov al, [d + 30]			; month
1657   10DD FD 9E 02    	shl al, 2
1658   10E0 DA          	push d
1659   10E1 3B 2B 17    	mov d, s_months
1660   10E4 22 00       	mov ah, 0
1661   10E6 59          	add d, a
1662   10E7 07 7B 02    	call puts
1663   10EA E7          	pop d
1664   10EB 22 20       	mov ah, $20
1665   10ED 07 46 01    	call putchar
1666   10F0 2E 20       	mov bl, $20
1667   10F2 07 1B 03    	call print_u8x
1668   10F5 33 1F 00    	mov bl, [d + 31]			; year
1669   10F8 07 1B 03    	call print_u8x	
1670   10FB 22 20       	mov ah, $20
1671   10FD 07 46 01    	call putchar	
1672   1100 07 7B 02    	call puts				; print filename	
1673   1103 07 28 02    	call printnl
1674   1106             cmd_ls_next:
1675   1106 14 1B 16    	mov a, [index]
1676   1109 77          	inc a
1677   110A 42 1B 16    	mov [index], a
1678   110D AF 10 00    	cmp a, FST_FILES_PER_DIR
1679   1110 C6 19 11    	je cmd_ls_end
1680   1113 58 20 00    	add d, 32			
1681   1116 0A 74 10    	jmp cmd_ls_L1	
1682   1119             cmd_ls_end:
1683   1119 06          	sysret
1684   111A             
1685   111A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1686   111A             ;; pad string to 32 chars
1687   111A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1688   111A             ; count in C
1689   111A             padding:
1690   111A D7          	push a
1691   111B D8          	push b
1692   111C 10 20 00    	mov a, 32
1693   111F 28          	mov b, c
1694   1120 60          	sub a, b
1695   1121 39          	mov c, a
1696   1122             padding_L1:
1697   1122 22 20       	mov ah, $20
1698   1124 07 46 01    	call putchar
1699   1127 7E          	dec c
1700   1128 C2 00 00    	cmp c, 0
1701   112B C7 22 11    	jne padding_L1
1702   112E E5          	pop b
1703   112F E4          	pop a
1704   1130 09          	ret
1705   1131             
1706   1131             
1707   1131             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1708   1131             ;; finds an empty data block
1709   1131             ;; block LBA returned in B
1710   1131             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1711   1131             fs_find_empty_block:
1712   1131 26 A0 00    	mov b, FS_LBA_START		; raw files starting block
1713   1134 38 00 00    	mov c, 0						; reset LBA to 0
1714   1137             fs_find_empty_block_L1:	
1715   1137 22 01       	mov ah, $01			; disk read
1716   1139 3B CB 26    	mov d, transient_area - 512
1717   113C 07 17 0B    	call IDE_read_sect		; read sector
1718   113F BD 00       	cmp byte [d], 0
1719   1141 C6 4A 11    	je fs_find_empty_block_found_null
1720   1144 55 20 00    	add b, FS_SECTORS_PER_FILE
1721   1147 0A 37 11    	jmp fs_find_empty_block_L1
1722   114A             fs_find_empty_block_found_null:
1723   114A 09          	ret
1724   114B             
1725   114B             ; file structure:
1726   114B             ; 512 bytes header
1727   114B             ; header used to tell whether the block is free
1728   114B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1729   114B             ;; CREATE NEW TEXTFILE
1730   114B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1731   114B             cmd_mktxt:
1732   114B FD 4E       	mov si, d
1733   114D FD 4F CB 28 	mov di, transient_area
1734   1151 38 00 40    	mov c, FS_SECTORS_PER_FILE * 512
1735   1154 04          	load					; load data from user-space
1736   1155 07 31 11    	call fs_find_empty_block	; look for empty data blocks
1737   1158 D8          	push b				; save empty block LBA
1738   1159             ;create header file by grabbing file name from parameter	
1739   1159 3B CB 2A    	mov d, transient_area + 512			; pointer to file contents
1740   115C             	;call gettxt
1741   115C 07 83 00    	call strlen						; get length of the text file
1742   115F D9          	push c							; save length
1743   1160 19 01       	mov al, 1
1744   1162 3D CB 28    	mov [transient_area], al					; mark sectors as USED (not NULL)
1745   1165 3B CB 28    	mov d, transient_area
1746   1168             cmd_mktxt_L2:
1747   1168 38 00 00    	mov c, 0
1748   116B 22 20       	mov ah, FS_SECTORS_PER_FILE		; number of sectors to write
1749   116D 07 3D 0B    	call IDE_write_sect			; write sectors
1750   1170             ; now we add the file to the current directory!
1751   1170             cmd_mktxt_add_to_dir:	
1752   1170 14 23 16    	mov a, [current_dirID]
1753   1173 77          	inc a
1754   1174 27          	mov b, a					; metadata sector
1755   1175 38 00 00    	mov c, 0
1756   1178 FD 79       	mov g, b					; save LBA
1757   117A 3B CB 26    	mov d, transient_area - 512
1758   117D 22 01       	mov ah, $01			; disk read
1759   117F 07 17 0B    	call IDE_read_sect		; read metadata sector
1760   1182             cmd_mktxt_add_to_dir_L2:
1761   1182 BD 00       	cmp byte[d], 0
1762   1184 C6 8D 11    	je cmd_mktxt_add_to_dir_null
1763   1187 58 20 00    	add d, FST_ENTRY_SIZE
1764   118A 0A 82 11    	jmp cmd_mktxt_add_to_dir_L2		; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1765   118D             cmd_mktxt_add_to_dir_null:
1766   118D FD 4D CC 28 	mov si, transient_area + 1		; filename located after the data block 'USED' marker byte
1767   1191 FD 50       	mov di, d
1768   1193 07 A8 00    	call strcpy			; copy file name
1769   1196 58 18 00    	add d, 24			; skip name
1770   1199 19 03       	mov al, %00000011	; type=file, no execute, write, read
1771   119B 3E          	mov [d], al			
1772   119C 58 03 00    	add d, 3
1773   119F E4          	pop a
1774   11A0 43          	mov [d], a
1775   11A1 63 02 00    	sub d, 2
1776   11A4 E5          	pop b				; get file LBA
1777   11A5 FD 43       	mov [d], b			; save LBA	
1778   11A7             	
1779   11A7             	; set file creation date	
1780   11A7 58 04 00    	add d, 4
1781   11AA 19 04       	mov al, 4
1782   11AC 05 01       	syscall sys_rtc
1783   11AE 1A          	mov al, ah
1784   11AF 3E          	mov [d], al			; set day
1785   11B0             	
1786   11B0 79          	inc d
1787   11B1 19 05       	mov al, 5
1788   11B3 05 01       	syscall sys_rtc
1789   11B5 1A          	mov al, ah
1790   11B6 3E          	mov [d], al			; set month
1791   11B7             	
1792   11B7 79          	inc d
1793   11B8 19 06       	mov al, 6
1794   11BA 05 01       	syscall sys_rtc
1795   11BC 1A          	mov al, ah
1796   11BD 3E          	mov [d], al			; set year
1797   11BE             	
1798   11BE             ; write sector into disk for new directory entry
1799   11BE FD 27       	mov b, g
1800   11C0 38 00 00    	mov c, 0
1801   11C3 3B CB 26    	mov d, transient_area - 512
1802   11C6 22 01       	mov ah, $01			; disk write, 1 sector
1803   11C8 07 3D 0B    	call IDE_write_sect		; write sector
1804   11CB 06          	sysret
1805   11CC             
1806   11CC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1807   11CC             ;; CREATE NEW BINARY FILE
1808   11CC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1809   11CC             ; search for first null block
1810   11CC             cmd_mkbin:
1811   11CC FD 4E       	mov si, d
1812   11CE FD 4F CB 1C 	mov di, temp_data
1813   11D2 38 00 02    	mov c, 512
1814   11D5 04          	load					; load data from user-space
1815   11D6             	
1816   11D6 26 A0 00    	mov b, FS_LBA_START		; files start when directories end
1817   11D9 38 00 00    	mov c, 0				; reset LBA to 0
1818   11DC             cmd_mkbin_L1:	
1819   11DC 22 01       	mov ah, $01			; disk read
1820   11DE 3B CB 28    	mov d, transient_area
1821   11E1 07 17 0B    	call IDE_read_sect		; read sector
1822   11E4 BD 00       	cmp byte[d], 0			; check for NULL
1823   11E6 C6 EF 11    	je cmd_mkbin_found_null
1824   11E9 55 20 00    	add b, FS_SECTORS_PER_FILE
1825   11EC 0A DC 11    	jmp cmd_mkbin_L1
1826   11EF             cmd_mkbin_found_null:
1827   11EF D8          	push b				; save LBA
1828   11F0             ;create header file by grabbing file name from parameter
1829   11F0 FD 4F CB 2A 	mov di, transient_area + 512	; pointer to file contents
1830   11F4 07 E8 15    	call _load_hex			; load binary hex
1831   11F7 D9          	push c					; save size (nbr of bytes)
1832   11F8 19 01       	mov al, 1
1833   11FA 3D CB 28    	mov [transient_area], al		; mark sectors as USED (not NULL)
1834   11FD FD 10       	cla
1835   11FF 42 1B 16    	mov [index], a
1836   1202 3B CB 28    	mov d, transient_area
1837   1205 13          	mov a, d
1838   1206 42 1D 16    	mov [buffer_addr], a
1839   1209             cmd_mkbin_L2:
1840   1209 38 00 00    	mov c, 0
1841   120C 22 01       	mov ah, $01				; disk write, 1 sector
1842   120E 07 3D 0B    	call IDE_write_sect			; write sector
1843   1211 14 1B 16    	mov a, [index]
1844   1214 77          	inc a
1845   1215 42 1B 16    	mov [index], a
1846   1218 AF 20 00    	cmp a, FS_SECTORS_PER_FILE		; remove 1 from this because we dont count the header sector
1847   121B C6 2D 12    	je cmd_mkbin_add_to_dir
1848   121E FD 77       	inc b
1849   1220 14 1D 16    	mov a, [buffer_addr]
1850   1223 53 00 02    	add a, 512
1851   1226 42 1D 16    	mov [buffer_addr], a
1852   1229 3C          	mov d, a
1853   122A 0A 09 12    	jmp cmd_mkbin_L2
1854   122D             ; now we add the file to the current directory!
1855   122D             cmd_mkbin_add_to_dir:	
1856   122D 14 23 16    	mov a, [current_dirID]
1857   1230 77          	inc a
1858   1231 27          	mov b, a					; metadata sector
1859   1232 38 00 00    	mov c, 0
1860   1235 FD 79       	mov g, b					; save LBA
1861   1237 3B CB 28    	mov d, transient_area
1862   123A 22 01       	mov ah, $01			; disk read
1863   123C 07 17 0B    	call IDE_read_sect		; read metadata sector
1864   123F             cmd_mkbin_add_to_dir_L2:
1865   123F BD 00       	cmp byte[d], 0
1866   1241 C6 4A 12    	je cmd_mkbin_add_to_dir_null
1867   1244 58 20 00    	add d, FST_ENTRY_SIZE
1868   1247 0A 3F 12    	jmp cmd_mkbin_add_to_dir_L2		; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1869   124A             cmd_mkbin_add_to_dir_null:
1870   124A FD 4D CB 1C 	mov si, temp_data
1871   124E FD 50       	mov di, d
1872   1250 07 A8 00    	call strcpy			; copy file name
1873   1253 58 18 00    	add d, 24			; skip name
1874   1256 19 07       	mov al, %00000111		;type=file, execute, write, read, 
1875   1258 3E          	mov [d], al
1876   1259 58 03 00    	add d, 3
1877   125C E4          	pop a
1878   125D 43          	mov [d], a
1879   125E 63 02 00    	sub d, 2
1880   1261 E5          	pop b				; get file LBA
1881   1262 FD 43       	mov [d], b			; save LBA
1882   1264             	
1883   1264             	; set file creation date	
1884   1264 58 04 00    	add d, 4
1885   1267 19 04       	mov al, 4
1886   1269 05 01       	syscall sys_rtc
1887   126B 1A          	mov al, ah
1888   126C 3E          	mov [d], al			; set day
1889   126D             	
1890   126D 79          	inc d
1891   126E 19 05       	mov al, 5
1892   1270 05 01       	syscall sys_rtc
1893   1272 1A          	mov al, ah
1894   1273 3E          	mov [d], al			; set month
1895   1274             	
1896   1274 79          	inc d
1897   1275 19 06       	mov al, 6
1898   1277 05 01       	syscall sys_rtc
1899   1279 1A          	mov al, ah
1900   127A 3E          	mov [d], al			; set year
1901   127B             	
1902   127B             ; write sector into disk for new directory entry
1903   127B FD 27       	mov b, g
1904   127D 38 00 00    	mov c, 0
1905   1280 3B CB 28    	mov d, transient_area
1906   1283 22 01       	mov ah, $01			; disk write, 1 sector
1907   1285 07 3D 0B    	call IDE_write_sect		; write sector
1908   1288 06          	sysret
1909   1289             
1910   1289             			
1911   1289             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1912   1289             ;; PWD - PRINT WORKING DIRECTORY
1913   1289             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		
1914   1289             cmd_pwd:
1915   1289 3B CB 1A    	mov d, filename
1916   128C 19 00       	mov al, 0
1917   128E 3E          	mov [d], al				; initialize path string 
1918   128F 14 23 16    	mov a, [current_dirID]
1919   1292 07 4B 0E    	call get_path_from_dirID_E0
1920   1295 3B CB 1A    	mov d, filename
1921   1298 07 3C 00    	call strrev
1922   129B 07 7B 02    	call puts
1923   129E 07 28 02    	call printnl
1924   12A1 06          	sysret
1925   12A2             
1926   12A2             
1927   12A2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1928   12A2             ;; get current directory LBA
1929   12A2             ;; A: returned LBA
1930   12A2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:
1931   12A2             cmd_get_curr_dir_LBA:
1932   12A2 14 23 16    	mov a, [current_dirID]
1933   12A5 06          	sysret
1934   12A6             
1935   12A6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1936   12A6             ;; LOAD FILE INTO MEM
1937   12A6             ;; file loaded to transient_area
1938   12A6             ;; D: filename pointer
1939   12A6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:
1940   12A6             cmd_loadfile_user:
1941   12A6 FD 4E       	mov si, d
1942   12A8 FD 4F CB 1A 	mov di, filename
1943   12AC 38 00 01    	mov c, 256
1944   12AF 04          	load
1945   12B0 07 B4 12    	call cmd_loadfile
1946   12B3 06          	sysret
1947   12B4             
1948   12B4             cmd_loadfile:
1949   12B4 14 23 16    	mov a, [current_dirID]
1950   12B7 77          	inc a				; metadata sector
1951   12B8 27          	mov b, a
1952   12B9 38 00 00    	mov c, 0				; reset LBA to 0
1953   12BC 22 01       	mov ah, $01			; disk read
1954   12BE 3B CB 26    	mov d, transient_area-512
1955   12C1 07 17 0B    	call IDE_read_sect		; read directory
1956   12C4 FD 10       	cla
1957   12C6 42 1B 16    	mov [index], a		; reset file counter
1958   12C9             cmd_loadfile_L1:
1959   12C9 FD 4E       	mov si, d
1960   12CB FD 4F CB 1A 	mov di, filename
1961   12CF 07 93 00    	call strcmp
1962   12D2 C6 E8 12    	je cmd_loadfile_found_entry
1963   12D5 58 20 00    	add d, 32
1964   12D8 14 1B 16    	mov a, [index]
1965   12DB 77          	inc a
1966   12DC 42 1B 16    	mov [index], a
1967   12DF AF 10 00    	cmp a, FST_FILES_PER_DIR
1968   12E2 C6 F6 12    	je cmd_loadfile_not_found
1969   12E5 0A C9 12    	jmp cmd_loadfile_L1
1970   12E8             cmd_loadfile_found_entry:
1971   12E8 58 19 00    	add d, 25			; get to dirID of file in disk
1972   12EB 2A          	mov b, [d]			; get LBA
1973   12EC FD 77       	inc b				; add 1 to B because the LBA for data comes after the header sector
1974   12EE 3B CB 28    	mov d, transient_area
1975   12F1 22 1F       	mov ah, FS_SECTORS_PER_FILE-1		; number of sectors
1976   12F3 07 17 0B    	call IDE_read_sect				; read sector
1977   12F6             cmd_loadfile_not_found:
1978   12F6 09          	ret
1979   12F7             
1980   12F7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1981   12F7             ;; CAT
1982   12F7             ;; userspace destination data pointer in D
1983   12F7             ;; filename starts at D, but is overwritten after the read is made
1984   12F7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:
1985   12F7             cmd_cat:
1986   12F7 DA          	push d					; save userspace file data destination
1987   12F8 FD 4E       	mov si, d
1988   12FA FD 4F CB 1C 	mov di, temp_data
1989   12FE 38 00 02    	mov c, 512
1990   1301 04          	load					; copy filename from user-space
1991   1302 29 23 16    	mov b, [current_dirID]
1992   1305 FD 77       	inc b				; metadata sector
1993   1307 38 00 00    	mov c, 0				; reset LBA to 0
1994   130A 22 01       	mov ah, $01			; disk read
1995   130C 3B CB 26    	mov d, transient_area-512
1996   130F 07 17 0B    	call IDE_read_sect		; read directory
1997   1312 FD 10       	cla
1998   1314 42 1B 16    	mov [index], a		; reset file counter
1999   1317             cmd_cat_L1:
2000   1317 FD 4E       	mov si, d
2001   1319 FD 4F CB 1C 	mov di, temp_data
2002   131D 07 93 00    	call strcmp
2003   1320 C6 36 13    	je cmd_cat_found_entry
2004   1323 58 20 00    	add d, 32
2005   1326 14 1B 16    	mov a, [index]
2006   1329 77          	inc a
2007   132A 42 1B 16    	mov [index], a
2008   132D AF 10 00    	cmp a, FST_FILES_PER_DIR
2009   1330 C6 51 13    	je cmd_cat_not_found
2010   1333 0A 17 13    	jmp cmd_cat_L1
2011   1336             cmd_cat_found_entry:
2012   1336 58 19 00    	add d, 25			; get to dirID of file in disk
2013   1339 2A          	mov b, [d]			; get LBA
2014   133A FD 77       	inc b				; add 1 to B because the LBA for data comes after the header sector 
2015   133C 3B CB 28    	mov d, transient_area	
2016   133F 38 00 00    	mov c, 0
2017   1342 22 1F       	mov ah, FS_SECTORS_PER_FILE-1	; nbr sectors
2018   1344 07 17 0B    	call IDE_read_sect		; read sectors
2019   1347 F0          	pop di						; write userspace file data destination to DI
2020   1348 FD 4D CB 28 	mov si, transient_area		; data origin
2021   134C 38 00 3E    	mov c, 512*(FS_SECTORS_PER_FILE-1)
2022   134F 03          	store
2023   1350 06          	sysret
2024   1351             cmd_cat_not_found:
2025   1351 E7          	pop d
2026   1352 06          	sysret
2027   1353             
2028   1353             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2029   1353             ;; RMDIR - remove DIR by dirID
2030   1353             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2031   1353             ; deletes a directory entry in the given directory's file list 
2032   1353             ; also deletes the actual directory entry in the FST
2033   1353             ; synopsis: rmdir /usr/local/testdir
2034   1353             ; B = dirID
2035   1353             cmd_rmdir:
2036   1353 FD 79       	mov g, b
2037   1355 11          	mov a, b
2038   1356 07 87 0E    	call get_parentID_from_dirID	; now get the directory's parent, in A
2039   1359 D7          	push a						; save dirID
2040   135A             ; search for directory's entry in the parent's directory then and delete it
2041   135A 77          	inc a						; metadata sector
2042   135B 27          	mov b, a
2043   135C 38 00 00    	mov c, 0					; reset LBA to 0
2044   135F 22 01       	mov ah, $01					;
2045   1361 3B CB 28    	mov d, transient_area
2046   1364 07 17 0B    	call IDE_read_sect			; read directory
2047   1367 FD 10       	cla
2048   1369 42 1B 16    	mov [index], a				; reset file counter
2049   136C FD 27       	mov b, g					; retrieve directory's dirID
2050   136E             cmd_rmdir_L1:
2051   136E 16 19 00    	mov a, [d + 25]				; get entry's dirID/LBA value
2052   1371 B0          	cmp a, b					; compare dirID's to find the directory
2053   1372 C6 88 13    	je cmd_rmdir_found_entry
2054   1375 58 20 00    	add d, 32
2055   1378 14 1B 16    	mov a, [index]
2056   137B 77          	inc a
2057   137C 42 1B 16    	mov [index], a
2058   137F AF 10 00    	cmp a, FST_FILES_PER_DIR
2059   1382 C6 AD 13    	je cmd_rmdir_not_found
2060   1385 0A 6E 13    	jmp cmd_rmdir_L1
2061   1388             cmd_rmdir_found_entry:
2062   1388 FD 10       	cla
2063   138A 3E          	mov [d], al					; make filename NULL
2064   138B 44 19 00    	mov [d + 25], a				; clear dirID/LBA as well not to generate problems with previously deleted directories
2065   138E E5          	pop b
2066   138F FD 77       	inc b						; metadata sector
2067   1391 38 00 00    	mov c, 0					; reset LBA to 0
2068   1394 22 01       	mov ah, $01					; 
2069   1396 3B CB 28    	mov d, transient_area
2070   1399 07 3D 0B    	call IDE_write_sect			; write sector and erase file's entry in the current DIR
2071   139C             
2072   139C FD 27       	mov b, g
2073   139E 3B CB 28    	mov d, transient_area	
2074   13A1 FD 10       	cla
2075   13A3 3E          	mov [d], al					; make directory's name header NULL for re-use
2076   13A4 38 00 00    	mov c, 0
2077   13A7 22 01       	mov ah, $01					; disk write 1 sect
2078   13A9 07 3D 0B    	call IDE_write_sect			; delete directory given by dirID in B
2079   13AC 06          	sysret
2080   13AD             cmd_rmdir_not_found:
2081   13AD E5          	pop b
2082   13AE 06          	sysret
2083   13AF             
2084   13AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2085   13AF             ;; RM - remove file
2086   13AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2087   13AF             ; frees up the data sectors for the file further down the disk
2088   13AF             ; deletes file entry in the directory's file list 
2089   13AF             cmd_rm:
2090   13AF FD 4E       	mov si, d
2091   13B1 FD 4F CB 1C 	mov di, temp_data
2092   13B5 38 00 02    	mov c, 512
2093   13B8 04          	load					; load data from user-space
2094   13B9 14 23 16    	mov a, [current_dirID]
2095   13BC 77          	inc a				; metadata sector
2096   13BD 27          	mov b, a
2097   13BE 38 00 00    	mov c, 0				; reset LBA to 0
2098   13C1 22 01       	mov ah, $01			; disk read
2099   13C3 3B CB 28    	mov d, transient_area
2100   13C6 07 17 0B    	call IDE_read_sect		; read directory
2101   13C9 10 00 00    	mov a, 0
2102   13CC 42 1B 16    	mov [index], a		; reset file counter
2103   13CF             cmd_rm_L1:
2104   13CF FD 4E       	mov si, d
2105   13D1 FD 4F CB 1C 	mov di, temp_data
2106   13D5 07 93 00    	call strcmp
2107   13D8 C6 EE 13    	je cmd_rm_found_entry
2108   13DB 58 20 00    	add d, 32
2109   13DE 14 1B 16    	mov a, [index]
2110   13E1 77          	inc a
2111   13E2 42 1B 16    	mov [index], a
2112   13E5 AF 10 00    	cmp a, FST_FILES_PER_DIR
2113   13E8 C6 16 14    	je cmd_rm_not_found
2114   13EB 0A CF 13    	jmp cmd_rm_L1
2115   13EE             cmd_rm_found_entry:
2116   13EE 2B 19 00    	mov b, [d + 25]			; get LBA
2117   13F1 FD 79       	mov g, b				; save LBA
2118   13F3 19 00       	mov al, 0
2119   13F5 3E          	mov [d], al			; make file entry NULL
2120   13F6 14 23 16    	mov a, [current_dirID]
2121   13F9 77          	inc a				; metadata sector
2122   13FA 27          	mov b, a
2123   13FB 38 00 00    	mov c, 0				; reset LBA to 0
2124   13FE 22 01       	mov ah, $01			; disk write
2125   1400 3B CB 28    	mov d, transient_area
2126   1403 07 3D 0B    	call IDE_write_sect		; write sector and erase file's entry in the current DIR
2127   1406 3B CB 28    	mov d, transient_area	
2128   1409 19 00       	mov al, 0
2129   140B 3E          	mov [d], al			; make file's data header NULL for re-use
2130   140C 38 00 00    	mov c, 0
2131   140F FD 27       	mov b, g				; get data header LBA
2132   1411 22 01       	mov ah, $01					; disk write 1 sect
2133   1413 07 3D 0B    	call IDE_write_sect				; write sector
2134   1416             cmd_rm_not_found:	
2135   1416 06          	sysret	
2136   1417             
2137   1417             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2138   1417             ;; mv - move / change file name
2139   1417             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2140   1417             cmd_mv:
2141   1417 FD 4E       	mov si, d
2142   1419 FD 4F CB 1C 	mov di, temp_data
2143   141D 38 00 02    	mov c, 512
2144   1420 04          	load						; load data from user-space
2145   1421 14 23 16    	mov a, [current_dirID]
2146   1424 77          	inc a						; metadata sector
2147   1425 27          	mov b, a	
2148   1426 38 00 00    	mov c, 0					; reset LBA to 0
2149   1429 22 01       	mov ah, $01				; disk read
2150   142B 3B CB 28    	mov d, transient_area
2151   142E 07 17 0B    	call IDE_read_sect		;read directory
2152   1431 FD 10       	cla
2153   1433 42 1B 16    	mov [index], a				;reset file counter
2154   1436             cmd_mv_L1:
2155   1436 FD 4E       	mov si, d
2156   1438 FD 4F CB 1C 	mov di, temp_data
2157   143C 07 93 00    	call strcmp
2158   143F C6 55 14    	je cmd_mv_found_entry
2159   1442 58 20 00    	add d, 32
2160   1445 14 1B 16    	mov a, [index]
2161   1448 77          	inc a
2162   1449 42 1B 16    	mov [index], a
2163   144C AF 10 00    	cmp a, FST_FILES_PER_DIR
2164   144F C6 87 14    	je cmd_mv_not_found
2165   1452 0A 36 14    	jmp cmd_mv_L1
2166   1455             cmd_mv_found_entry:	
2167   1455 DA          	push d
2168   1456 FD 4D 4B 1D 	mov si, temp_data + 128	; (0...127) = original filename , (128...255) = new name
2169   145A FD 50       	mov di, d
2170   145C 07 A8 00    	call strcpy	
2171   145F 38 00 00    	mov c, 0
2172   1462 3B CB 28    	mov d, transient_area
2173   1465 22 01       	mov ah, $01					;disk write 1 sect
2174   1467 07 3D 0B    	call IDE_write_sect			;write sector
2175   146A E7          	pop d
2176   146B             ;;;;;;;; need to check whether its a dir or a file here ;;;;;;;;;;;;;;
2177   146B 2B 19 00    	mov b, [d + 25]				; get the dirID of the directory so we can locate its own entry in the list
2178   146E 22 01       	mov ah, $01
2179   1470 3B CB 28    	mov d, transient_area
2180   1473 38 00 00    	mov c, 0
2181   1476 07 17 0B    	call IDE_read_sect			; read directory entry
2182   1479 FD 4D 4B 1D 	mov si, temp_data + 128
2183   147D FD 50       	mov di, d
2184   147F 07 A8 00    	call strcpy					; change directory's name
2185   1482 22 01       	mov ah, $01
2186   1484 07 3D 0B    	call IDE_write_sect			; rewrite directory back to disk
2187   1487             cmd_mv_not_found:
2188   1487 06          	sysret
2189   1488             
2190   1488             KERNEL_RESET_VECTOR:	
2191   1488 FD 49 FF F7 	mov bp, STACK_BEGIN
2192   148C FD 47 FF F7 	mov sp, STACK_BEGIN
2193   1490             	
2194   1490 19 80       	mov al, %10000000
2195   1492 FD 0F       	stomsk					; mask out timer interrupt for now (only allow UART to interrupt)
2196   1494 FD 0C       	sti	
2197   1496             	
2198   1496             ; reset fifo pointers
2199   1496 10 CB 1E    	mov a, fifo
2200   1499 3B 1F 16    	mov d, fifo_pi
2201   149C 43          	mov [d], a
2202   149D 3B 21 16    	mov d, fifo_pr
2203   14A0 43          	mov [d], a	
2204   14A1 19 02       	mov al, 2
2205   14A3 05 03       	syscall sys_io			; enable uart in interrupt mode
2206   14A5             	
2207   14A5 3B 79 16    	mov d, s_kernel_started
2208   14A8 07 7B 02    	call puts
2209   14AB             	
2210   14AB 3B 9E 16    	mov d, s_prompt_init
2211   14AE 07 7B 02    	call puts
2212   14B1             
2213   14B1 19 10       	mov al, 16
2214   14B3 05 04       	syscall sys_fileio		; set root dirID
2215   14B5             
2216   14B5 3B 25 16    	mov d, s_init_path
2217   14B8 05 05       	syscall sys_fork		; launch init as a new process
2218   14BA             
2219   14BA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2220   14BA             ;;; Process Index in A
2221   14BA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2222   14BA             find_free_proc:
2223   14BA FD 4D BC 18 	mov si, proc_availab_table + 1			; skip process 0 (kernel)
2224   14BE             find_free_proc_L0:
2225   14BE F6          	lodsb						; get process state
2226   14BF B9 00       	cmp al, 0
2227   14C1 C6 C7 14    	je find_free_proc_free			; if free, jump
2228   14C4 0A BE 14    	jmp find_free_proc_L0			; else, goto next
2229   14C7             find_free_proc_free:
2230   14C7 4E          	mov a, si
2231   14C8 5F BC 18    	sub a, 1 + proc_availab_table				; get process index
2232   14CB 09          	ret
2233   14CC             	
2234   14CC             
2235   14CC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2236   14CC             ;;; Process Index in AL
2237   14CC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2238   14CC             proc_memory_map:
2239   14CC 22 00       	mov ah, 0
2240   14CE 27          	mov b, a			; page in BL, 0 in BH
2241   14CF FD 9D 05    	shl a, 5			; multiply by 32
2242   14D2 39          	mov c, a			; save in C
2243   14D3 57 20 00    	add c, 32
2244   14D6             proc_memory_map_L0:
2245   14D6 02          	pagemap
2246   14D7 55 00 08    	add b, $0800					; increase page number (msb 5 bits of BH only)
2247   14DA 53 01 00    	add a, 1						; increase both 
2248   14DD B1          	cmp a, c						; check to see if we reached the end of memory
2249   14DE C7 D6 14    	jne proc_memory_map_L0
2250   14E1 09          	ret
2251   14E2             	
2252   14E2             
2253   14E2             cmd_terminate_proc:
2254   14E2 51 05 00    	add sp, 5		; clear stack of the values that were pushed by the interrupt (SP, Status, PC)
2255   14E5             					; since they will not be used for anything here.
2256   14E5 1D 1A 16    	mov al, [active_proc_index]
2257   14E8 22 00       	mov ah, 0	
2258   14EA FD 9D 05    	shl a, 5						; x32
2259   14ED 53 CB 18    	add a, proc_names
2260   14F0 3C          	mov d, a
2261   14F1 19 00       	mov al, 0
2262   14F3 3E          	mov [d], al			; nullify process name
2263   14F4             
2264   14F4 1D 1A 16    	mov al, [active_proc_index]
2265   14F7 22 00       	mov ah, 0	
2266   14F9 3C          	mov d, a
2267   14FA 19 00       	mov al, 0
2268   14FC 3F BB 18    	mov [d + proc_availab_table], al					; make process empty again
2269   14FF             	
2270   14FF 1D 19 16    	mov al, [nbr_active_procs]			; decrease nbr of active processes
2271   1502 80          	dec al
2272   1503 3D 19 16    	mov [nbr_active_procs], al
2273   1506             
2274   1506             ; now load the shell process again
2275   1506 19 02       	mov al, 2				; next process = process 2 = shell
2276   1508 3D 1A 16    	mov [active_proc_index], al		; set next active proc
2277   150B             
2278   150B             ; calculate LUT entry for next process
2279   150B 22 00       	mov ah, 0
2280   150D FD 99       	shl a							; x2
2281   150F B7 D8 15    	mov a, [proc_table_convert + a]		; get process state start index	
2282   1512             	
2283   1512 4D          	mov si, a						; source is proc state block
2284   1513 48          	mov a, sp
2285   1514 5F 13 00    	sub a, 19
2286   1517 4F          	mov di, a						; destination is kernel stack
2287   1518             ; restore SP
2288   1518 7D          	dec a
2289   1519 47          	mov sp, a
2290   151A 38 14 00    	mov c, 20
2291   151D FD F5       	rep movsb
2292   151F             ; set VM process
2293   151F 1D 1A 16    	mov al, [active_proc_index]
2294   1522 01          	setptb
2295   1523             		
2296   1523 4C          	popa
2297   1524 06          	sysret
2298   1525             
2299   1525             cmd_pause_proc:
2300   1525             ; save all registers into kernel stack
2301   1525 4B          	pusha
2302   1526 22 00       	mov ah, 0
2303   1528 1D 1A 16    	mov al, [active_proc_index]
2304   152B FD 99       	shl a							; x2
2305   152D B7 D8 15    	mov a, [proc_table_convert + a]	; get process state start index
2306   1530             		
2307   1530 4F          	mov di, a
2308   1531 48          	mov a, sp
2309   1532 77          	inc a
2310   1533 4D          	mov si, a
2311   1534 38 14 00    	mov c, 20
2312   1537 FD F5       	rep movsb					; save process state!
2313   1539             ; restore kernel stack position to point before interrupt arrived
2314   1539 51 14 00    	add sp, 20
2315   153C             ; now load the shell process again
2316   153C 19 02       	mov al, 2				; next process = process 2 = shell
2317   153E 3D 1A 16    	mov [active_proc_index], al		; set next active proc
2318   1541             
2319   1541             ; calculate LUT entry for next process
2320   1541 22 00       	mov ah, 0
2321   1543 FD 99       	shl a							; x2
2322   1545 B7 D8 15    	mov a, [proc_table_convert + a]		; get process state start index	
2323   1548             	
2324   1548 4D          	mov si, a						; source is proc state block
2325   1549 48          	mov a, sp
2326   154A 5F 13 00    	sub a, 19
2327   154D 4F          	mov di, a						; destination is kernel stack
2328   154E             ; restore SP
2329   154E 7D          	dec a
2330   154F 47          	mov sp, a
2331   1550 38 14 00    	mov c, 20
2332   1553 FD F5       	rep movsb
2333   1555             ; set VM process
2334   1555 1D 1A 16    	mov al, [active_proc_index]
2335   1558 01          	setptb
2336   1559             		
2337   1559 4C          	popa
2338   155A 06          	sysret
2339   155B             
2340   155B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2341   155B             ;; fork a new process
2342   155B             ;; D = path of the process file to be forked
2343   155B             ;; B = arguments ptr
2344   155B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2345   155B             cmd_fork:
2346   155B             ; we save the active process first	
2347   155B 4B          	pusha
2348   155C 22 00       	mov ah, 0
2349   155E 1D 1A 16    	mov al, [active_proc_index]
2350   1561 FD 99       	shl a							; x2
2351   1563 B7 D8 15    	mov a, [proc_table_convert + a]		; get process state table's start index
2352   1566             	
2353   1566 4F          	mov di, a
2354   1567 48          	mov a, sp
2355   1568 77          	inc a
2356   1569 4D          	mov si, a
2357   156A 38 14 00    	mov c, 20
2358   156D FD F5       	rep movsb					; save process state!
2359   156F             ; restore kernel stack position to point before interrupt arrived
2360   156F 51 14 00    	add sp, 20
2361   1572             	
2362   1572 FD 4E       	mov si, d				; copy the file path
2363   1574 FD 4F CB 1C 	mov di, temp_data
2364   1578 38 00 02    	mov c, 512
2365   157B 04          	load
2366   157C 11          	mov a, b
2367   157D 4D          	mov si, a				; copy the arguments
2368   157E FD 4F CB 26 	mov di, scrap_sector
2369   1582 38 00 02    	mov c, 512
2370   1585 04          	load
2371   1586 07 CD 0F    	call loadfile_from_path		; load the process file from disk by path (path is in temp_data)
2372   1589             								; the file data is loaded into transient_area
2373   1589             ; now we allocate a new process	
2374   1589 07 BA 14    	call find_free_proc			; index in A
2375   158C 01          	setptb
2376   158D 07 CC 14    	call proc_memory_map			; map process memory pages
2377   1590             ; copy arguments into process's memory
2378   1590 FD 4D CB 26 	mov si, scrap_sector
2379   1594 FD 4F 00 00 	mov di, 0
2380   1598 38 00 02    	mov c, 512
2381   159B 03          	store
2382   159C             ; now copy process binary data into process's memory
2383   159C FD 4D CB 28 	mov si, transient_area
2384   15A0 FD 4F 00 04 	mov di, PROC_TEXT_ORG		; code origin address for all user processes
2385   15A4 38 00 40    	mov c, FS_FILE_SIZE			; size of memory space to copy, which is equal to the max file size in disk (for now)
2386   15A7 03          	store						; copy process data
2387   15A8             		
2388   15A8 07 BA 14    	call find_free_proc			; index in A
2389   15AB 3D 1A 16    	mov [active_proc_index], al		; set new active process
2390   15AE FD 9D 05    	shl a, 5						; x32
2391   15B1 53 CB 18    	add a, proc_names
2392   15B4 4F          	mov di, a
2393   15B5 FD 4D CB 1C 	mov si, temp_data			; copy and store process filename
2394   15B9 07 A8 00    	call strcpy
2395   15BC             	
2396   15BC 07 BA 14    	call find_free_proc			; index in A
2397   15BF 3C          	mov d, a
2398   15C0 19 01       	mov al, 1
2399   15C2 3F BB 18    	mov [d + proc_availab_table], al					; make process busy
2400   15C5             	
2401   15C5 1D 19 16    	mov al, [nbr_active_procs]			; increase nbr of active processes
2402   15C8 7A          	inc al
2403   15C9 3D 19 16    	mov [nbr_active_procs], al
2404   15CC             ; launch process
2405   15CC FD D7 FF FF 	push word $FFFF 
2406   15D0 FD DB 0E    	push byte %00001110		; dma_ack = 0, interrupts enabled = 1, mode = user, paging = on, halt=0, display_reg_load=0, dir=0
2407   15D3 FD D7 00 04 	push word PROC_TEXT_ORG
2408   15D7 06          	sysret
2409   15D8             
2410   15D8             proc_table_convert:
2411   15D8 7B 17       	.dw proc_state_table + 0
2412   15DA 8F 17       	.dw proc_state_table + 20
2413   15DC A3 17       	.dw proc_state_table + 40
2414   15DE B7 17       	.dw proc_state_table + 60
2415   15E0 CB 17       	.dw proc_state_table + 80
2416   15E2 DF 17       	.dw proc_state_table + 100
2417   15E4 F3 17       	.dw proc_state_table + 120
2418   15E6 07 18       	.dw proc_state_table + 140
2419   15E8             	
2420   15E8             ; ************************************************************
2421   15E8             ; GET HEX FILE
2422   15E8             ; di = destination address
2423   15E8             ; return length in bytes in C
2424   15E8             ; ************************************************************
2425   15E8             _load_hex:
2426   15E8 D2          	push bp
2427   15E9 9B          	mov bp, sp
2428   15EA D7          	push a
2429   15EB D8          	push b
2430   15EC DA          	push d
2431   15ED E2          	push si
2432   15EE E3          	push di
2433   15EF 52 00 60    	sub sp, $6000				; string data block
2434   15F2 38 00 00    	mov c, 0
2435   15F5 48          	mov a, sp
2436   15F6 77          	inc a
2437   15F7 3C          	mov d, a				; start of string data block
2438   15F8 07 4D 01    	call gets				; get program string
2439   15FB 4D          	mov si, a
2440   15FC             __load_hex_loop:
2441   15FC F6          	lodsb					; load from [SI] to AL
2442   15FD B9 00       	cmp al, 0				; check if ASCII 0
2443   15FF C6 0D 16    	jz __load_hex_ret
2444   1602 36          	mov bh, al
2445   1603 F6          	lodsb
2446   1604 2F          	mov bl, al
2447   1605 07 FB 00    	call atoi				; convert ASCII byte in B to int (to AL)
2448   1608 F7          	stosb					; store AL to [DI]
2449   1609 78          	inc c
2450   160A 0A FC 15    	jmp __load_hex_loop
2451   160D             __load_hex_ret:
2452   160D 51 00 60    	add sp, $6000
2453   1610 F0          	pop di
2454   1611 EF          	pop si
2455   1612 E7          	pop d
2456   1613 E5          	pop b
2457   1614 E4          	pop a
2458   1615 9C          	mov sp, bp
2459   1616 F1          	pop bp
2460   1617 09          	ret
2461   1618             
2462   1618             ; synopsis: look insIDE a certain DIRECTORY for files/directories
2463   1618             ; BEFORE CALLING THIS FUNCTION, CD INTO REQUIRED DIRECTORY
2464   1618             ; for each entry insIDE DIRECTORY:
2465   1618             ;	if entry is a file:
2466   1618             ;		compare filename to searched filename
2467   1618             ;		if filenames are the same, print filename
2468   1618             ;	else if entry is a directory:
2469   1618             ;		cd to the given directory
2470   1618             ;		recursively call cmd_find
2471   1618             ;		cd outsIDE previous directory
2472   1618             ;	if current entry == last entry, return
2473   1618             ; endfor
2474   1618             ;		
2475   1618             ;	
2476   1618             f_find:
2477   1618             	
2478   1618 09          	ret
2479   1619             
2480   1619             
2481   1619             
2482   1619 00          nbr_active_procs:	.db 0
2483   161A 01          active_proc_index:	.db 1
2484   161B             
2485   161B 00 00       index:				.dw 0
2486   161D 00 00       buffer_addr:		.dw 0
2487   161F             
2488   161F CB 1E       fifo_pi:			.dw fifo
2489   1621 CB 1E       fifo_pr:			.dw fifo
2490   1623             
2491   1623             ; file system variables
2492   1623 00 00       current_dirID:		.dw 0				; keep dirID of current directory
2493   1625 2F 73 62 69 s_init_path:		.db "/sbin/init", 0
2493   1629 6E 2F 69 6E 
2493   162D 69 74 00 
2494   1630             
2495   1630 2E 2E 00    s_parent_dir:		.db "..", 0
2496   1633 2E 00       s_current_dir:		.db ".", 0
2497   1635 2F 00       s_fslash: 			.db "/", 0
2498   1637 20 23 20 00 s_hash:				.db " # ", 0
2499   163B 2D 72 77 20 file_attrib:		.db "-rw x"			; chars at multiples of 2
2499   163F 78 
2500   1640 2D 64 63    file_type:			.db "-dc"
2501   1643 50 49 44 20 s_ps_header:		.db "PID COMMAND\n", 0
2501   1647 43 4F 4D 4D 
2501   164B 41 4E 44 0A 
2501   164F 00 
2502   1650 53 6F 6C 2D s_host: 			.db "Sol-1:", 0
2502   1654 31 3A 00 
2503   1657 53 6F 6C 2D s_uname:			.db "Sol-OS\n", 0
2503   165B 4F 53 0A 00 
2504   165F             
2505   165F 72 6F 6F 74 s_root:				.db "root\n", 0
2505   1663 0A 00 
2506   1665             
2507   1665 69 6E 74 65 s_int_en:			.db "interrupts enabled\n", 0
2507   1669 72 72 75 70 
2507   166D 74 73 20 65 
2507   1671 6E 61 62 6C 
2507   1675 65 64 0A 00 
2508   1679 6B 65 72 6E s_kernel_started:	.db "kernel started\n", 0
2508   167D 65 6C 20 73 
2508   1681 74 61 72 74 
2508   1685 65 64 0A 00 
2509   1689 65 6E 74 65 s_procname:			.db "enter process name: ", 0
2509   168D 72 20 70 72 
2509   1691 6F 63 65 73 
2509   1695 73 20 6E 61 
2509   1699 6D 65 3A 20 
2509   169D 00 
2510   169E 73 74 61 72 s_prompt_init:		.db "starting init\n", 0
2510   16A2 74 69 6E 67 
2510   16A6 20 69 6E 69 
2510   16AA 74 0A 00 
2511   16AD 0A 73 6F 66 s_priviledge:		.db "\nsoftware failure: privilege exception\n", 0
2511   16B1 74 77 61 72 
2511   16B5 65 20 66 61 
2511   16B9 69 6C 75 72 
2511   16BD 65 3A 20 70 
2511   16C1 72 69 76 69 
2511   16C5 6C 65 67 65 
2511   16C9 20 65 78 63 
2511   16CD 65 70 74 69 
2511   16D1 6F 6E 0A 00 
2512   16D5 0A 65 78 63 s_divzero:			.db "\nexception: zero division\n", 0
2512   16D9 65 70 74 69 
2512   16DD 6F 6E 3A 20 
2512   16E1 7A 65 72 6F 
2512   16E5 20 64 69 76 
2512   16E9 69 73 69 6F 
2512   16ED 6E 0A 00 
2513   16F0             
2514   16F0 59 65 61 72 s_set_year:			.db "Year: ", 0
2514   16F4 3A 20 00 
2515   16F7 4D 6F 6E 74 s_set_month:		.db "Month: ", 0
2515   16FB 68 3A 20 00 
2516   16FF 44 61 79 3A s_set_day:			.db "Day: ", 0
2516   1703 20 00 
2517   1705 57 65 65 6B s_set_week:			.db "Weekday: ", 0
2517   1709 64 61 79 3A 
2517   170D 20 00 
2518   170F 48 6F 75 72 s_set_hours:		.db "Hours: ", 0
2518   1713 73 3A 20 00 
2519   1717 4D 69 6E 75 s_set_minutes:		.db "Minutes: ", 0
2519   171B 74 65 73 3A 
2519   171F 20 00 
2520   1721 53 65 63 6F s_set_seconds:		.db "Seconds: ", 0
2520   1725 6E 64 73 3A 
2520   1729 20 00 
2521   172B 20 20 20 00 s_months:			.db "   ", 0
2522   172F 4A 61 6E 00 					.db "Jan", 0
2523   1733 46 65 62 00 					.db "Feb", 0
2524   1737 4D 61 72 00 					.db "Mar", 0
2525   173B 41 70 72 00 					.db "Apr", 0
2526   173F 4D 61 79 00 					.db "May", 0
2527   1743 4A 75 6E 00 					.db "Jun", 0
2528   1747 4A 75 6C 00 					.db "Jul", 0
2529   174B 41 75 67 00 					.db "Aug", 0
2530   174F 53 65 70 00 					.db "Sep", 0
2531   1753 4F 63 74 00 					.db "Oct", 0
2532   1757 4E 6F 76 00 					.db "Nov", 0
2533   175B 44 65 63 00 					.db "Dec", 0
2534   175F 53 75 6E 00 s_week:				.db "Sun", 0 
2535   1763 4D 6F 6E 00 					.db "Mon", 0 
2536   1767 54 75 65 00 					.db "Tue", 0 
2537   176B 57 65 64 00 					.db "Wed", 0 
2538   176F 54 68 75 00 					.db "Thu", 0 
2539   1773 46 72 69 00 					.db "Fri", 0 
2540   1777 53 61 74 00 					.db "Sat", 0
2541   177B             
2542   177B 00 00 00 00 proc_state_table:	.fill 16 * 20, 0	; for 15 processes max
2542   177F 00 00 00 00 
2542   1783 00 00 00 00 
2542   1787 00 00 00 00 
2542   178B 00 00 00 00 
2542   178F 00 00 00 00 
2542   1793 00 00 00 00 
2542   1797 00 00 00 00 
2542   179B 00 00 00 00 
2542   179F 00 00 00 00 
2542   17A3 00 00 00 00 
2542   17A7 00 00 00 00 
2542   17AB 00 00 00 00 
2542   17AF 00 00 00 00 
2542   17B3 00 00 00 00 
2542   17B7 00 00 00 00 
2542   17BB 00 00 00 00 
2542   17BF 00 00 00 00 
2542   17C3 00 00 00 00 
2542   17C7 00 00 00 00 
2542   17CB 00 00 00 00 
2542   17CF 00 00 00 00 
2542   17D3 00 00 00 00 
2542   17D7 00 00 00 00 
2542   17DB 00 00 00 00 
2542   17DF 00 00 00 00 
2542   17E3 00 00 00 00 
2542   17E7 00 00 00 00 
2542   17EB 00 00 00 00 
2542   17EF 00 00 00 00 
2542   17F3 00 00 00 00 
2542   17F7 00 00 00 00 
2542   17FB 00 00 00 00 
2542   17FF 00 00 00 00 
2542   1803 00 00 00 00 
2542   1807 00 00 00 00 
2542   180B 00 00 00 00 
2542   180F 00 00 00 00 
2542   1813 00 00 00 00 
2542   1817 00 00 00 00 
2542   181B 00 00 00 00 
2542   181F 00 00 00 00 
2542   1823 00 00 00 00 
2542   1827 00 00 00 00 
2542   182B 00 00 00 00 
2542   182F 00 00 00 00 
2542   1833 00 00 00 00 
2542   1837 00 00 00 00 
2542   183B 00 00 00 00 
2542   183F 00 00 00 00 
2542   1843 00 00 00 00 
2542   1847 00 00 00 00 
2542   184B 00 00 00 00 
2542   184F 00 00 00 00 
2542   1853 00 00 00 00 
2542   1857 00 00 00 00 
2542   185B 00 00 00 00 
2542   185F 00 00 00 00 
2542   1863 00 00 00 00 
2542   1867 00 00 00 00 
2542   186B 00 00 00 00 
2542   186F 00 00 00 00 
2542   1873 00 00 00 00 
2542   1877 00 00 00 00 
2542   187B 00 00 00 00 
2542   187F 00 00 00 00 
2542   1883 00 00 00 00 
2542   1887 00 00 00 00 
2542   188B 00 00 00 00 
2542   188F 00 00 00 00 
2542   1893 00 00 00 00 
2542   1897 00 00 00 00 
2542   189B 00 00 00 00 
2542   189F 00 00 00 00 
2542   18A3 00 00 00 00 
2542   18A7 00 00 00 00 
2542   18AB 00 00 00 00 
2542   18AF 00 00 00 00 
2542   18B3 00 00 00 00 
2542   18B7 00 00 00 00 
2543   18BB 00 00 00 00 proc_availab_table:	.fill 16, 0			; space for 15 processes. 0 = process empty, 1 = process taken
2543   18BF 00 00 00 00 
2543   18C3 00 00 00 00 
2543   18C7 00 00 00 00 
2544   18CB 00 00 00 00 proc_names:			.fill 16 * 32, 0	; process names
2544   18CF 00 00 00 00 
2544   18D3 00 00 00 00 
2544   18D7 00 00 00 00 
2544   18DB 00 00 00 00 
2544   18DF 00 00 00 00 
2544   18E3 00 00 00 00 
2544   18E7 00 00 00 00 
2544   18EB 00 00 00 00 
2544   18EF 00 00 00 00 
2544   18F3 00 00 00 00 
2544   18F7 00 00 00 00 
2544   18FB 00 00 00 00 
2544   18FF 00 00 00 00 
2544   1903 00 00 00 00 
2544   1907 00 00 00 00 
2544   190B 00 00 00 00 
2544   190F 00 00 00 00 
2544   1913 00 00 00 00 
2544   1917 00 00 00 00 
2544   191B 00 00 00 00 
2544   191F 00 00 00 00 
2544   1923 00 00 00 00 
2544   1927 00 00 00 00 
2544   192B 00 00 00 00 
2544   192F 00 00 00 00 
2544   1933 00 00 00 00 
2544   1937 00 00 00 00 
2544   193B 00 00 00 00 
2544   193F 00 00 00 00 
2544   1943 00 00 00 00 
2544   1947 00 00 00 00 
2544   194B 00 00 00 00 
2544   194F 00 00 00 00 
2544   1953 00 00 00 00 
2544   1957 00 00 00 00 
2544   195B 00 00 00 00 
2544   195F 00 00 00 00 
2544   1963 00 00 00 00 
2544   1967 00 00 00 00 
2544   196B 00 00 00 00 
2544   196F 00 00 00 00 
2544   1973 00 00 00 00 
2544   1977 00 00 00 00 
2544   197B 00 00 00 00 
2544   197F 00 00 00 00 
2544   1983 00 00 00 00 
2544   1987 00 00 00 00 
2544   198B 00 00 00 00 
2544   198F 00 00 00 00 
2544   1993 00 00 00 00 
2544   1997 00 00 00 00 
2544   199B 00 00 00 00 
2544   199F 00 00 00 00 
2544   19A3 00 00 00 00 
2544   19A7 00 00 00 00 
2544   19AB 00 00 00 00 
2544   19AF 00 00 00 00 
2544   19B3 00 00 00 00 
2544   19B7 00 00 00 00 
2544   19BB 00 00 00 00 
2544   19BF 00 00 00 00 
2544   19C3 00 00 00 00 
2544   19C7 00 00 00 00 
2544   19CB 00 00 00 00 
2544   19CF 00 00 00 00 
2544   19D3 00 00 00 00 
2544   19D7 00 00 00 00 
2544   19DB 00 00 00 00 
2544   19DF 00 00 00 00 
2544   19E3 00 00 00 00 
2544   19E7 00 00 00 00 
2544   19EB 00 00 00 00 
2544   19EF 00 00 00 00 
2544   19F3 00 00 00 00 
2544   19F7 00 00 00 00 
2544   19FB 00 00 00 00 
2544   19FF 00 00 00 00 
2544   1A03 00 00 00 00 
2544   1A07 00 00 00 00 
2544   1A0B 00 00 00 00 
2544   1A0F 00 00 00 00 
2544   1A13 00 00 00 00 
2544   1A17 00 00 00 00 
2544   1A1B 00 00 00 00 
2544   1A1F 00 00 00 00 
2544   1A23 00 00 00 00 
2544   1A27 00 00 00 00 
2544   1A2B 00 00 00 00 
2544   1A2F 00 00 00 00 
2544   1A33 00 00 00 00 
2544   1A37 00 00 00 00 
2544   1A3B 00 00 00 00 
2544   1A3F 00 00 00 00 
2544   1A43 00 00 00 00 
2544   1A47 00 00 00 00 
2544   1A4B 00 00 00 00 
2544   1A4F 00 00 00 00 
2544   1A53 00 00 00 00 
2544   1A57 00 00 00 00 
2544   1A5B 00 00 00 00 
2544   1A5F 00 00 00 00 
2544   1A63 00 00 00 00 
2544   1A67 00 00 00 00 
2544   1A6B 00 00 00 00 
2544   1A6F 00 00 00 00 
2544   1A73 00 00 00 00 
2544   1A77 00 00 00 00 
2544   1A7B 00 00 00 00 
2544   1A7F 00 00 00 00 
2544   1A83 00 00 00 00 
2544   1A87 00 00 00 00 
2544   1A8B 00 00 00 00 
2544   1A8F 00 00 00 00 
2544   1A93 00 00 00 00 
2544   1A97 00 00 00 00 
2544   1A9B 00 00 00 00 
2544   1A9F 00 00 00 00 
2544   1AA3 00 00 00 00 
2544   1AA7 00 00 00 00 
2544   1AAB 00 00 00 00 
2544   1AAF 00 00 00 00 
2544   1AB3 00 00 00 00 
2544   1AB7 00 00 00 00 
2544   1ABB 00 00 00 00 
2544   1ABF 00 00 00 00 
2544   1AC3 00 00 00 00 
2544   1AC7 00 00 00 00 
2545   1ACB 00 00 00 00 filename:			.fill 512, 0		; holds a path for file search
2545   1ACF 00 00 00 00 
2545   1AD3 00 00 00 00 
2545   1AD7 00 00 00 00 
2545   1ADB 00 00 00 00 
2545   1ADF 00 00 00 00 
2545   1AE3 00 00 00 00 
2545   1AE7 00 00 00 00 
2545   1AEB 00 00 00 00 
2545   1AEF 00 00 00 00 
2545   1AF3 00 00 00 00 
2545   1AF7 00 00 00 00 
2545   1AFB 00 00 00 00 
2545   1AFF 00 00 00 00 
2545   1B03 00 00 00 00 
2545   1B07 00 00 00 00 
2545   1B0B 00 00 00 00 
2545   1B0F 00 00 00 00 
2545   1B13 00 00 00 00 
2545   1B17 00 00 00 00 
2545   1B1B 00 00 00 00 
2545   1B1F 00 00 00 00 
2545   1B23 00 00 00 00 
2545   1B27 00 00 00 00 
2545   1B2B 00 00 00 00 
2545   1B2F 00 00 00 00 
2545   1B33 00 00 00 00 
2545   1B37 00 00 00 00 
2545   1B3B 00 00 00 00 
2545   1B3F 00 00 00 00 
2545   1B43 00 00 00 00 
2545   1B47 00 00 00 00 
2545   1B4B 00 00 00 00 
2545   1B4F 00 00 00 00 
2545   1B53 00 00 00 00 
2545   1B57 00 00 00 00 
2545   1B5B 00 00 00 00 
2545   1B5F 00 00 00 00 
2545   1B63 00 00 00 00 
2545   1B67 00 00 00 00 
2545   1B6B 00 00 00 00 
2545   1B6F 00 00 00 00 
2545   1B73 00 00 00 00 
2545   1B77 00 00 00 00 
2545   1B7B 00 00 00 00 
2545   1B7F 00 00 00 00 
2545   1B83 00 00 00 00 
2545   1B87 00 00 00 00 
2545   1B8B 00 00 00 00 
2545   1B8F 00 00 00 00 
2545   1B93 00 00 00 00 
2545   1B97 00 00 00 00 
2545   1B9B 00 00 00 00 
2545   1B9F 00 00 00 00 
2545   1BA3 00 00 00 00 
2545   1BA7 00 00 00 00 
2545   1BAB 00 00 00 00 
2545   1BAF 00 00 00 00 
2545   1BB3 00 00 00 00 
2545   1BB7 00 00 00 00 
2545   1BBB 00 00 00 00 
2545   1BBF 00 00 00 00 
2545   1BC3 00 00 00 00 
2545   1BC7 00 00 00 00 
2545   1BCB 00 00 00 00 
2545   1BCF 00 00 00 00 
2545   1BD3 00 00 00 00 
2545   1BD7 00 00 00 00 
2545   1BDB 00 00 00 00 
2545   1BDF 00 00 00 00 
2545   1BE3 00 00 00 00 
2545   1BE7 00 00 00 00 
2545   1BEB 00 00 00 00 
2545   1BEF 00 00 00 00 
2545   1BF3 00 00 00 00 
2545   1BF7 00 00 00 00 
2545   1BFB 00 00 00 00 
2545   1BFF 00 00 00 00 
2545   1C03 00 00 00 00 
2545   1C07 00 00 00 00 
2545   1C0B 00 00 00 00 
2545   1C0F 00 00 00 00 
2545   1C13 00 00 00 00 
2545   1C17 00 00 00 00 
2545   1C1B 00 00 00 00 
2545   1C1F 00 00 00 00 
2545   1C23 00 00 00 00 
2545   1C27 00 00 00 00 
2545   1C2B 00 00 00 00 
2545   1C2F 00 00 00 00 
2545   1C33 00 00 00 00 
2545   1C37 00 00 00 00 
2545   1C3B 00 00 00 00 
2545   1C3F 00 00 00 00 
2545   1C43 00 00 00 00 
2545   1C47 00 00 00 00 
2545   1C4B 00 00 00 00 
2545   1C4F 00 00 00 00 
2545   1C53 00 00 00 00 
2545   1C57 00 00 00 00 
2545   1C5B 00 00 00 00 
2545   1C5F 00 00 00 00 
2545   1C63 00 00 00 00 
2545   1C67 00 00 00 00 
2545   1C6B 00 00 00 00 
2545   1C6F 00 00 00 00 
2545   1C73 00 00 00 00 
2545   1C77 00 00 00 00 
2545   1C7B 00 00 00 00 
2545   1C7F 00 00 00 00 
2545   1C83 00 00 00 00 
2545   1C87 00 00 00 00 
2545   1C8B 00 00 00 00 
2545   1C8F 00 00 00 00 
2545   1C93 00 00 00 00 
2545   1C97 00 00 00 00 
2545   1C9B 00 00 00 00 
2545   1C9F 00 00 00 00 
2545   1CA3 00 00 00 00 
2545   1CA7 00 00 00 00 
2545   1CAB 00 00 00 00 
2545   1CAF 00 00 00 00 
2545   1CB3 00 00 00 00 
2545   1CB7 00 00 00 00 
2545   1CBB 00 00 00 00 
2545   1CBF 00 00 00 00 
2545   1CC3 00 00 00 00 
2545   1CC7 00 00 00 00 
2546   1CCB 00 00 00 00 temp_data:			.fill 512, 0   		;  user space data
2546   1CCF 00 00 00 00 
2546   1CD3 00 00 00 00 
2546   1CD7 00 00 00 00 
2546   1CDB 00 00 00 00 
2546   1CDF 00 00 00 00 
2546   1CE3 00 00 00 00 
2546   1CE7 00 00 00 00 
2546   1CEB 00 00 00 00 
2546   1CEF 00 00 00 00 
2546   1CF3 00 00 00 00 
2546   1CF7 00 00 00 00 
2546   1CFB 00 00 00 00 
2546   1CFF 00 00 00 00 
2546   1D03 00 00 00 00 
2546   1D07 00 00 00 00 
2546   1D0B 00 00 00 00 
2546   1D0F 00 00 00 00 
2546   1D13 00 00 00 00 
2546   1D17 00 00 00 00 
2546   1D1B 00 00 00 00 
2546   1D1F 00 00 00 00 
2546   1D23 00 00 00 00 
2546   1D27 00 00 00 00 
2546   1D2B 00 00 00 00 
2546   1D2F 00 00 00 00 
2546   1D33 00 00 00 00 
2546   1D37 00 00 00 00 
2546   1D3B 00 00 00 00 
2546   1D3F 00 00 00 00 
2546   1D43 00 00 00 00 
2546   1D47 00 00 00 00 
2546   1D4B 00 00 00 00 
2546   1D4F 00 00 00 00 
2546   1D53 00 00 00 00 
2546   1D57 00 00 00 00 
2546   1D5B 00 00 00 00 
2546   1D5F 00 00 00 00 
2546   1D63 00 00 00 00 
2546   1D67 00 00 00 00 
2546   1D6B 00 00 00 00 
2546   1D6F 00 00 00 00 
2546   1D73 00 00 00 00 
2546   1D77 00 00 00 00 
2546   1D7B 00 00 00 00 
2546   1D7F 00 00 00 00 
2546   1D83 00 00 00 00 
2546   1D87 00 00 00 00 
2546   1D8B 00 00 00 00 
2546   1D8F 00 00 00 00 
2546   1D93 00 00 00 00 
2546   1D97 00 00 00 00 
2546   1D9B 00 00 00 00 
2546   1D9F 00 00 00 00 
2546   1DA3 00 00 00 00 
2546   1DA7 00 00 00 00 
2546   1DAB 00 00 00 00 
2546   1DAF 00 00 00 00 
2546   1DB3 00 00 00 00 
2546   1DB7 00 00 00 00 
2546   1DBB 00 00 00 00 
2546   1DBF 00 00 00 00 
2546   1DC3 00 00 00 00 
2546   1DC7 00 00 00 00 
2546   1DCB 00 00 00 00 
2546   1DCF 00 00 00 00 
2546   1DD3 00 00 00 00 
2546   1DD7 00 00 00 00 
2546   1DDB 00 00 00 00 
2546   1DDF 00 00 00 00 
2546   1DE3 00 00 00 00 
2546   1DE7 00 00 00 00 
2546   1DEB 00 00 00 00 
2546   1DEF 00 00 00 00 
2546   1DF3 00 00 00 00 
2546   1DF7 00 00 00 00 
2546   1DFB 00 00 00 00 
2546   1DFF 00 00 00 00 
2546   1E03 00 00 00 00 
2546   1E07 00 00 00 00 
2546   1E0B 00 00 00 00 
2546   1E0F 00 00 00 00 
2546   1E13 00 00 00 00 
2546   1E17 00 00 00 00 
2546   1E1B 00 00 00 00 
2546   1E1F 00 00 00 00 
2546   1E23 00 00 00 00 
2546   1E27 00 00 00 00 
2546   1E2B 00 00 00 00 
2546   1E2F 00 00 00 00 
2546   1E33 00 00 00 00 
2546   1E37 00 00 00 00 
2546   1E3B 00 00 00 00 
2546   1E3F 00 00 00 00 
2546   1E43 00 00 00 00 
2546   1E47 00 00 00 00 
2546   1E4B 00 00 00 00 
2546   1E4F 00 00 00 00 
2546   1E53 00 00 00 00 
2546   1E57 00 00 00 00 
2546   1E5B 00 00 00 00 
2546   1E5F 00 00 00 00 
2546   1E63 00 00 00 00 
2546   1E67 00 00 00 00 
2546   1E6B 00 00 00 00 
2546   1E6F 00 00 00 00 
2546   1E73 00 00 00 00 
2546   1E77 00 00 00 00 
2546   1E7B 00 00 00 00 
2546   1E7F 00 00 00 00 
2546   1E83 00 00 00 00 
2546   1E87 00 00 00 00 
2546   1E8B 00 00 00 00 
2546   1E8F 00 00 00 00 
2546   1E93 00 00 00 00 
2546   1E97 00 00 00 00 
2546   1E9B 00 00 00 00 
2546   1E9F 00 00 00 00 
2546   1EA3 00 00 00 00 
2546   1EA7 00 00 00 00 
2546   1EAB 00 00 00 00 
2546   1EAF 00 00 00 00 
2546   1EB3 00 00 00 00 
2546   1EB7 00 00 00 00 
2546   1EBB 00 00 00 00 
2546   1EBF 00 00 00 00 
2546   1EC3 00 00 00 00 
2546   1EC7 00 00 00 00 
2547   1ECB FF FF FF FF fifo:				.fill FIFO_SIZE
2547   1ECF FF FF FF FF 
2547   1ED3 FF FF FF FF 
2547   1ED7 FF FF FF FF 
2547   1EDB FF FF FF FF 
2547   1EDF FF FF FF FF 
2547   1EE3 FF FF FF FF 
2547   1EE7 FF FF FF FF 
2547   1EEB FF FF FF FF 
2547   1EEF FF FF FF FF 
2547   1EF3 FF FF FF FF 
2547   1EF7 FF FF FF FF 
2547   1EFB FF FF FF FF 
2547   1EFF FF FF FF FF 
2547   1F03 FF FF FF FF 
2547   1F07 FF FF FF FF 
2547   1F0B FF FF FF FF 
2547   1F0F FF FF FF FF 
2547   1F13 FF FF FF FF 
2547   1F17 FF FF FF FF 
2547   1F1B FF FF FF FF 
2547   1F1F FF FF FF FF 
2547   1F23 FF FF FF FF 
2547   1F27 FF FF FF FF 
2547   1F2B FF FF FF FF 
2547   1F2F FF FF FF FF 
2547   1F33 FF FF FF FF 
2547   1F37 FF FF FF FF 
2547   1F3B FF FF FF FF 
2547   1F3F FF FF FF FF 
2547   1F43 FF FF FF FF 
2547   1F47 FF FF FF FF 
2547   1F4B FF FF FF FF 
2547   1F4F FF FF FF FF 
2547   1F53 FF FF FF FF 
2547   1F57 FF FF FF FF 
2547   1F5B FF FF FF FF 
2547   1F5F FF FF FF FF 
2547   1F63 FF FF FF FF 
2547   1F67 FF FF FF FF 
2547   1F6B FF FF FF FF 
2547   1F6F FF FF FF FF 
2547   1F73 FF FF FF FF 
2547   1F77 FF FF FF FF 
2547   1F7B FF FF FF FF 
2547   1F7F FF FF FF FF 
2547   1F83 FF FF FF FF 
2547   1F87 FF FF FF FF 
2547   1F8B FF FF FF FF 
2547   1F8F FF FF FF FF 
2547   1F93 FF FF FF FF 
2547   1F97 FF FF FF FF 
2547   1F9B FF FF FF FF 
2547   1F9F FF FF FF FF 
2547   1FA3 FF FF FF FF 
2547   1FA7 FF FF FF FF 
2547   1FAB FF FF FF FF 
2547   1FAF FF FF FF FF 
2547   1FB3 FF FF FF FF 
2547   1FB7 FF FF FF FF 
2547   1FBB FF FF FF FF 
2547   1FBF FF FF FF FF 
2547   1FC3 FF FF FF FF 
2547   1FC7 FF FF FF FF 
2547   1FCB FF FF FF FF 
2547   1FCF FF FF FF FF 
2547   1FD3 FF FF FF FF 
2547   1FD7 FF FF FF FF 
2547   1FDB FF FF FF FF 
2547   1FDF FF FF FF FF 
2547   1FE3 FF FF FF FF 
2547   1FE7 FF FF FF FF 
2547   1FEB FF FF FF FF 
2547   1FEF FF FF FF FF 
2547   1FF3 FF FF FF FF 
2547   1FF7 FF FF FF FF 
2547   1FFB FF FF FF FF 
2547   1FFF FF FF FF FF 
2547   2003 FF FF FF FF 
2547   2007 FF FF FF FF 
2547   200B FF FF FF FF 
2547   200F FF FF FF FF 
2547   2013 FF FF FF FF 
2547   2017 FF FF FF FF 
2547   201B FF FF FF FF 
2547   201F FF FF FF FF 
2547   2023 FF FF FF FF 
2547   2027 FF FF FF FF 
2547   202B FF FF FF FF 
2547   202F FF FF FF FF 
2547   2033 FF FF FF FF 
2547   2037 FF FF FF FF 
2547   203B FF FF FF FF 
2547   203F FF FF FF FF 
2547   2043 FF FF FF FF 
2547   2047 FF FF FF FF 
2547   204B FF FF FF FF 
2547   204F FF FF FF FF 
2547   2053 FF FF FF FF 
2547   2057 FF FF FF FF 
2547   205B FF FF FF FF 
2547   205F FF FF FF FF 
2547   2063 FF FF FF FF 
2547   2067 FF FF FF FF 
2547   206B FF FF FF FF 
2547   206F FF FF FF FF 
2547   2073 FF FF FF FF 
2547   2077 FF FF FF FF 
2547   207B FF FF FF FF 
2547   207F FF FF FF FF 
2547   2083 FF FF FF FF 
2547   2087 FF FF FF FF 
2547   208B FF FF FF FF 
2547   208F FF FF FF FF 
2547   2093 FF FF FF FF 
2547   2097 FF FF FF FF 
2547   209B FF FF FF FF 
2547   209F FF FF FF FF 
2547   20A3 FF FF FF FF 
2547   20A7 FF FF FF FF 
2547   20AB FF FF FF FF 
2547   20AF FF FF FF FF 
2547   20B3 FF FF FF FF 
2547   20B7 FF FF FF FF 
2547   20BB FF FF FF FF 
2547   20BF FF FF FF FF 
2547   20C3 FF FF FF FF 
2547   20C7 FF FF FF FF 
2547   20CB FF FF FF FF 
2547   20CF FF FF FF FF 
2547   20D3 FF FF FF FF 
2547   20D7 FF FF FF FF 
2547   20DB FF FF FF FF 
2547   20DF FF FF FF FF 
2547   20E3 FF FF FF FF 
2547   20E7 FF FF FF FF 
2547   20EB FF FF FF FF 
2547   20EF FF FF FF FF 
2547   20F3 FF FF FF FF 
2547   20F7 FF FF FF FF 
2547   20FB FF FF FF FF 
2547   20FF FF FF FF FF 
2547   2103 FF FF FF FF 
2547   2107 FF FF FF FF 
2547   210B FF FF FF FF 
2547   210F FF FF FF FF 
2547   2113 FF FF FF FF 
2547   2117 FF FF FF FF 
2547   211B FF FF FF FF 
2547   211F FF FF FF FF 
2547   2123 FF FF FF FF 
2547   2127 FF FF FF FF 
2547   212B FF FF FF FF 
2547   212F FF FF FF FF 
2547   2133 FF FF FF FF 
2547   2137 FF FF FF FF 
2547   213B FF FF FF FF 
2547   213F FF FF FF FF 
2547   2143 FF FF FF FF 
2547   2147 FF FF FF FF 
2547   214B FF FF FF FF 
2547   214F FF FF FF FF 
2547   2153 FF FF FF FF 
2547   2157 FF FF FF FF 
2547   215B FF FF FF FF 
2547   215F FF FF FF FF 
2547   2163 FF FF FF FF 
2547   2167 FF FF FF FF 
2547   216B FF FF FF FF 
2547   216F FF FF FF FF 
2547   2173 FF FF FF FF 
2547   2177 FF FF FF FF 
2547   217B FF FF FF FF 
2547   217F FF FF FF FF 
2547   2183 FF FF FF FF 
2547   2187 FF FF FF FF 
2547   218B FF FF FF FF 
2547   218F FF FF FF FF 
2547   2193 FF FF FF FF 
2547   2197 FF FF FF FF 
2547   219B FF FF FF FF 
2547   219F FF FF FF FF 
2547   21A3 FF FF FF FF 
2547   21A7 FF FF FF FF 
2547   21AB FF FF FF FF 
2547   21AF FF FF FF FF 
2547   21B3 FF FF FF FF 
2547   21B7 FF FF FF FF 
2547   21BB FF FF FF FF 
2547   21BF FF FF FF FF 
2547   21C3 FF FF FF FF 
2547   21C7 FF FF FF FF 
2547   21CB FF FF FF FF 
2547   21CF FF FF FF FF 
2547   21D3 FF FF FF FF 
2547   21D7 FF FF FF FF 
2547   21DB FF FF FF FF 
2547   21DF FF FF FF FF 
2547   21E3 FF FF FF FF 
2547   21E7 FF FF FF FF 
2547   21EB FF FF FF FF 
2547   21EF FF FF FF FF 
2547   21F3 FF FF FF FF 
2547   21F7 FF FF FF FF 
2547   21FB FF FF FF FF 
2547   21FF FF FF FF FF 
2547   2203 FF FF FF FF 
2547   2207 FF FF FF FF 
2547   220B FF FF FF FF 
2547   220F FF FF FF FF 
2547   2213 FF FF FF FF 
2547   2217 FF FF FF FF 
2547   221B FF FF FF FF 
2547   221F FF FF FF FF 
2547   2223 FF FF FF FF 
2547   2227 FF FF FF FF 
2547   222B FF FF FF FF 
2547   222F FF FF FF FF 
2547   2233 FF FF FF FF 
2547   2237 FF FF FF FF 
2547   223B FF FF FF FF 
2547   223F FF FF FF FF 
2547   2243 FF FF FF FF 
2547   2247 FF FF FF FF 
2547   224B FF FF FF FF 
2547   224F FF FF FF FF 
2547   2253 FF FF FF FF 
2547   2257 FF FF FF FF 
2547   225B FF FF FF FF 
2547   225F FF FF FF FF 
2547   2263 FF FF FF FF 
2547   2267 FF FF FF FF 
2547   226B FF FF FF FF 
2547   226F FF FF FF FF 
2547   2273 FF FF FF FF 
2547   2277 FF FF FF FF 
2547   227B FF FF FF FF 
2547   227F FF FF FF FF 
2547   2283 FF FF FF FF 
2547   2287 FF FF FF FF 
2547   228B FF FF FF FF 
2547   228F FF FF FF FF 
2547   2293 FF FF FF FF 
2547   2297 FF FF FF FF 
2547   229B FF FF FF FF 
2547   229F FF FF FF FF 
2547   22A3 FF FF FF FF 
2547   22A7 FF FF FF FF 
2547   22AB FF FF FF FF 
2547   22AF FF FF FF FF 
2547   22B3 FF FF FF FF 
2547   22B7 FF FF FF FF 
2547   22BB FF FF FF FF 
2547   22BF FF FF FF FF 
2547   22C3 FF FF FF FF 
2547   22C7 FF FF FF FF 
2547   22CB FF FF FF FF 
2547   22CF FF FF FF FF 
2547   22D3 FF FF FF FF 
2547   22D7 FF FF FF FF 
2547   22DB FF FF FF FF 
2547   22DF FF FF FF FF 
2547   22E3 FF FF FF FF 
2547   22E7 FF FF FF FF 
2547   22EB FF FF FF FF 
2547   22EF FF FF FF FF 
2547   22F3 FF FF FF FF 
2547   22F7 FF FF FF FF 
2547   22FB FF FF FF FF 
2547   22FF FF FF FF FF 
2547   2303 FF FF FF FF 
2547   2307 FF FF FF FF 
2547   230B FF FF FF FF 
2547   230F FF FF FF FF 
2547   2313 FF FF FF FF 
2547   2317 FF FF FF FF 
2547   231B FF FF FF FF 
2547   231F FF FF FF FF 
2547   2323 FF FF FF FF 
2547   2327 FF FF FF FF 
2547   232B FF FF FF FF 
2547   232F FF FF FF FF 
2547   2333 FF FF FF FF 
2547   2337 FF FF FF FF 
2547   233B FF FF FF FF 
2547   233F FF FF FF FF 
2547   2343 FF FF FF FF 
2547   2347 FF FF FF FF 
2547   234B FF FF FF FF 
2547   234F FF FF FF FF 
2547   2353 FF FF FF FF 
2547   2357 FF FF FF FF 
2547   235B FF FF FF FF 
2547   235F FF FF FF FF 
2547   2363 FF FF FF FF 
2547   2367 FF FF FF FF 
2547   236B FF FF FF FF 
2547   236F FF FF FF FF 
2547   2373 FF FF FF FF 
2547   2377 FF FF FF FF 
2547   237B FF FF FF FF 
2547   237F FF FF FF FF 
2547   2383 FF FF FF FF 
2547   2387 FF FF FF FF 
2547   238B FF FF FF FF 
2547   238F FF FF FF FF 
2547   2393 FF FF FF FF 
2547   2397 FF FF FF FF 
2547   239B FF FF FF FF 
2547   239F FF FF FF FF 
2547   23A3 FF FF FF FF 
2547   23A7 FF FF FF FF 
2547   23AB FF FF FF FF 
2547   23AF FF FF FF FF 
2547   23B3 FF FF FF FF 
2547   23B7 FF FF FF FF 
2547   23BB FF FF FF FF 
2547   23BF FF FF FF FF 
2547   23C3 FF FF FF FF 
2547   23C7 FF FF FF FF 
2547   23CB FF FF FF FF 
2547   23CF FF FF FF FF 
2547   23D3 FF FF FF FF 
2547   23D7 FF FF FF FF 
2547   23DB FF FF FF FF 
2547   23DF FF FF FF FF 
2547   23E3 FF FF FF FF 
2547   23E7 FF FF FF FF 
2547   23EB FF FF FF FF 
2547   23EF FF FF FF FF 
2547   23F3 FF FF FF FF 
2547   23F7 FF FF FF FF 
2547   23FB FF FF FF FF 
2547   23FF FF FF FF FF 
2547   2403 FF FF FF FF 
2547   2407 FF FF FF FF 
2547   240B FF FF FF FF 
2547   240F FF FF FF FF 
2547   2413 FF FF FF FF 
2547   2417 FF FF FF FF 
2547   241B FF FF FF FF 
2547   241F FF FF FF FF 
2547   2423 FF FF FF FF 
2547   2427 FF FF FF FF 
2547   242B FF FF FF FF 
2547   242F FF FF FF FF 
2547   2433 FF FF FF FF 
2547   2437 FF FF FF FF 
2547   243B FF FF FF FF 
2547   243F FF FF FF FF 
2547   2443 FF FF FF FF 
2547   2447 FF FF FF FF 
2547   244B FF FF FF FF 
2547   244F FF FF FF FF 
2547   2453 FF FF FF FF 
2547   2457 FF FF FF FF 
2547   245B FF FF FF FF 
2547   245F FF FF FF FF 
2547   2463 FF FF FF FF 
2547   2467 FF FF FF FF 
2547   246B FF FF FF FF 
2547   246F FF FF FF FF 
2547   2473 FF FF FF FF 
2547   2477 FF FF FF FF 
2547   247B FF FF FF FF 
2547   247F FF FF FF FF 
2547   2483 FF FF FF FF 
2547   2487 FF FF FF FF 
2547   248B FF FF FF FF 
2547   248F FF FF FF FF 
2547   2493 FF FF FF FF 
2547   2497 FF FF FF FF 
2547   249B FF FF FF FF 
2547   249F FF FF FF FF 
2547   24A3 FF FF FF FF 
2547   24A7 FF FF FF FF 
2547   24AB FF FF FF FF 
2547   24AF FF FF FF FF 
2547   24B3 FF FF FF FF 
2547   24B7 FF FF FF FF 
2547   24BB FF FF FF FF 
2547   24BF FF FF FF FF 
2547   24C3 FF FF FF FF 
2547   24C7 FF FF FF FF 
2547   24CB FF FF FF FF 
2547   24CF FF FF FF FF 
2547   24D3 FF FF FF FF 
2547   24D7 FF FF FF FF 
2547   24DB FF FF FF FF 
2547   24DF FF FF FF FF 
2547   24E3 FF FF FF FF 
2547   24E7 FF FF FF FF 
2547   24EB FF FF FF FF 
2547   24EF FF FF FF FF 
2547   24F3 FF FF FF FF 
2547   24F7 FF FF FF FF 
2547   24FB FF FF FF FF 
2547   24FF FF FF FF FF 
2547   2503 FF FF FF FF 
2547   2507 FF FF FF FF 
2547   250B FF FF FF FF 
2547   250F FF FF FF FF 
2547   2513 FF FF FF FF 
2547   2517 FF FF FF FF 
2547   251B FF FF FF FF 
2547   251F FF FF FF FF 
2547   2523 FF FF FF FF 
2547   2527 FF FF FF FF 
2547   252B FF FF FF FF 
2547   252F FF FF FF FF 
2547   2533 FF FF FF FF 
2547   2537 FF FF FF FF 
2547   253B FF FF FF FF 
2547   253F FF FF FF FF 
2547   2543 FF FF FF FF 
2547   2547 FF FF FF FF 
2547   254B FF FF FF FF 
2547   254F FF FF FF FF 
2547   2553 FF FF FF FF 
2547   2557 FF FF FF FF 
2547   255B FF FF FF FF 
2547   255F FF FF FF FF 
2547   2563 FF FF FF FF 
2547   2567 FF FF FF FF 
2547   256B FF FF FF FF 
2547   256F FF FF FF FF 
2547   2573 FF FF FF FF 
2547   2577 FF FF FF FF 
2547   257B FF FF FF FF 
2547   257F FF FF FF FF 
2547   2583 FF FF FF FF 
2547   2587 FF FF FF FF 
2547   258B FF FF FF FF 
2547   258F FF FF FF FF 
2547   2593 FF FF FF FF 
2547   2597 FF FF FF FF 
2547   259B FF FF FF FF 
2547   259F FF FF FF FF 
2547   25A3 FF FF FF FF 
2547   25A7 FF FF FF FF 
2547   25AB FF FF FF FF 
2547   25AF FF FF FF FF 
2547   25B3 FF FF FF FF 
2547   25B7 FF FF FF FF 
2547   25BB FF FF FF FF 
2547   25BF FF FF FF FF 
2547   25C3 FF FF FF FF 
2547   25C7 FF FF FF FF 
2547   25CB FF FF FF FF 
2547   25CF FF FF FF FF 
2547   25D3 FF FF FF FF 
2547   25D7 FF FF FF FF 
2547   25DB FF FF FF FF 
2547   25DF FF FF FF FF 
2547   25E3 FF FF FF FF 
2547   25E7 FF FF FF FF 
2547   25EB FF FF FF FF 
2547   25EF FF FF FF FF 
2547   25F3 FF FF FF FF 
2547   25F7 FF FF FF FF 
2547   25FB FF FF FF FF 
2547   25FF FF FF FF FF 
2547   2603 FF FF FF FF 
2547   2607 FF FF FF FF 
2547   260B FF FF FF FF 
2547   260F FF FF FF FF 
2547   2613 FF FF FF FF 
2547   2617 FF FF FF FF 
2547   261B FF FF FF FF 
2547   261F FF FF FF FF 
2547   2623 FF FF FF FF 
2547   2627 FF FF FF FF 
2547   262B FF FF FF FF 
2547   262F FF FF FF FF 
2547   2633 FF FF FF FF 
2547   2637 FF FF FF FF 
2547   263B FF FF FF FF 
2547   263F FF FF FF FF 
2547   2643 FF FF FF FF 
2547   2647 FF FF FF FF 
2547   264B FF FF FF FF 
2547   264F FF FF FF FF 
2547   2653 FF FF FF FF 
2547   2657 FF FF FF FF 
2547   265B FF FF FF FF 
2547   265F FF FF FF FF 
2547   2663 FF FF FF FF 
2547   2667 FF FF FF FF 
2547   266B FF FF FF FF 
2547   266F FF FF FF FF 
2547   2673 FF FF FF FF 
2547   2677 FF FF FF FF 
2547   267B FF FF FF FF 
2547   267F FF FF FF FF 
2547   2683 FF FF FF FF 
2547   2687 FF FF FF FF 
2547   268B FF FF FF FF 
2547   268F FF FF FF FF 
2547   2693 FF FF FF FF 
2547   2697 FF FF FF FF 
2547   269B FF FF FF FF 
2547   269F FF FF FF FF 
2547   26A3 FF FF FF FF 
2547   26A7 FF FF FF FF 
2547   26AB FF FF FF FF 
2547   26AF FF FF FF FF 
2547   26B3 FF FF FF FF 
2547   26B7 FF FF FF FF 
2547   26BB FF FF FF FF 
2547   26BF FF FF FF FF 
2547   26C3 FF FF FF FF 
2547   26C7 FF FF FF FF 
2548   26CB             
2549   26CB FF FF FF FF scrap_sector:		.fill 512		; scrap sector
2549   26CF FF FF FF FF 
2549   26D3 FF FF FF FF 
2549   26D7 FF FF FF FF 
2549   26DB FF FF FF FF 
2549   26DF FF FF FF FF 
2549   26E3 FF FF FF FF 
2549   26E7 FF FF FF FF 
2549   26EB FF FF FF FF 
2549   26EF FF FF FF FF 
2549   26F3 FF FF FF FF 
2549   26F7 FF FF FF FF 
2549   26FB FF FF FF FF 
2549   26FF FF FF FF FF 
2549   2703 FF FF FF FF 
2549   2707 FF FF FF FF 
2549   270B FF FF FF FF 
2549   270F FF FF FF FF 
2549   2713 FF FF FF FF 
2549   2717 FF FF FF FF 
2549   271B FF FF FF FF 
2549   271F FF FF FF FF 
2549   2723 FF FF FF FF 
2549   2727 FF FF FF FF 
2549   272B FF FF FF FF 
2549   272F FF FF FF FF 
2549   2733 FF FF FF FF 
2549   2737 FF FF FF FF 
2549   273B FF FF FF FF 
2549   273F FF FF FF FF 
2549   2743 FF FF FF FF 
2549   2747 FF FF FF FF 
2549   274B FF FF FF FF 
2549   274F FF FF FF FF 
2549   2753 FF FF FF FF 
2549   2757 FF FF FF FF 
2549   275B FF FF FF FF 
2549   275F FF FF FF FF 
2549   2763 FF FF FF FF 
2549   2767 FF FF FF FF 
2549   276B FF FF FF FF 
2549   276F FF FF FF FF 
2549   2773 FF FF FF FF 
2549   2777 FF FF FF FF 
2549   277B FF FF FF FF 
2549   277F FF FF FF FF 
2549   2783 FF FF FF FF 
2549   2787 FF FF FF FF 
2549   278B FF FF FF FF 
2549   278F FF FF FF FF 
2549   2793 FF FF FF FF 
2549   2797 FF FF FF FF 
2549   279B FF FF FF FF 
2549   279F FF FF FF FF 
2549   27A3 FF FF FF FF 
2549   27A7 FF FF FF FF 
2549   27AB FF FF FF FF 
2549   27AF FF FF FF FF 
2549   27B3 FF FF FF FF 
2549   27B7 FF FF FF FF 
2549   27BB FF FF FF FF 
2549   27BF FF FF FF FF 
2549   27C3 FF FF FF FF 
2549   27C7 FF FF FF FF 
2549   27CB FF FF FF FF 
2549   27CF FF FF FF FF 
2549   27D3 FF FF FF FF 
2549   27D7 FF FF FF FF 
2549   27DB FF FF FF FF 
2549   27DF FF FF FF FF 
2549   27E3 FF FF FF FF 
2549   27E7 FF FF FF FF 
2549   27EB FF FF FF FF 
2549   27EF FF FF FF FF 
2549   27F3 FF FF FF FF 
2549   27F7 FF FF FF FF 
2549   27FB FF FF FF FF 
2549   27FF FF FF FF FF 
2549   2803 FF FF FF FF 
2549   2807 FF FF FF FF 
2549   280B FF FF FF FF 
2549   280F FF FF FF FF 
2549   2813 FF FF FF FF 
2549   2817 FF FF FF FF 
2549   281B FF FF FF FF 
2549   281F FF FF FF FF 
2549   2823 FF FF FF FF 
2549   2827 FF FF FF FF 
2549   282B FF FF FF FF 
2549   282F FF FF FF FF 
2549   2833 FF FF FF FF 
2549   2837 FF FF FF FF 
2549   283B FF FF FF FF 
2549   283F FF FF FF FF 
2549   2843 FF FF FF FF 
2549   2847 FF FF FF FF 
2549   284B FF FF FF FF 
2549   284F FF FF FF FF 
2549   2853 FF FF FF FF 
2549   2857 FF FF FF FF 
2549   285B FF FF FF FF 
2549   285F FF FF FF FF 
2549   2863 FF FF FF FF 
2549   2867 FF FF FF FF 
2549   286B FF FF FF FF 
2549   286F FF FF FF FF 
2549   2873 FF FF FF FF 
2549   2877 FF FF FF FF 
2549   287B FF FF FF FF 
2549   287F FF FF FF FF 
2549   2883 FF FF FF FF 
2549   2887 FF FF FF FF 
2549   288B FF FF FF FF 
2549   288F FF FF FF FF 
2549   2893 FF FF FF FF 
2549   2897 FF FF FF FF 
2549   289B FF FF FF FF 
2549   289F FF FF FF FF 
2549   28A3 FF FF FF FF 
2549   28A7 FF FF FF FF 
2549   28AB FF FF FF FF 
2549   28AF FF FF FF FF 
2549   28B3 FF FF FF FF 
2549   28B7 FF FF FF FF 
2549   28BB FF FF FF FF 
2549   28BF FF FF FF FF 
2549   28C3 FF FF FF FF 
2549   28C7 FF FF FF FF 
2550   28CB 00          transient_area:		.db 0			; beginning of the transient memory area. used for disk reads and other purposes		
2551   28CC             
2552   28CC             
2553   28CC             .end
tasm: Number of errors = 0
