0001   0000             .include "kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0002   0000             
0003   0400             .org PROC_TEXT_ORG
0004   0400             
0005   0400             primes:
0006   0400 FD 47 FF FF 	mov sp, $FFFF
0007   0404 FD 49 FF FF 	mov bp, $FFFF
0008   0408             
0009   0408 10 00 00    	mov a, 0
0010   040B 42 22 0A    	mov [prog], a
0011   040E 07 83 08    	call get_token
0012   0411 1D 25 0A    	mov al, [tok]
0013   0414 B9 14       	cmp al, TOK_END
0014   0416 C6 78 04    	je bad_args
0015   0419 3B 26 0A    	mov d, tokstr
0016   041C 07 90 06    	call strtoint
0017   041F 42 E2 0B    	mov [min], a
0018   0422 07 83 08    	call get_token
0019   0425 1D 25 0A    	mov al, [tok]
0020   0428 B9 14       	cmp al, TOK_END
0021   042A C6 78 04    	je bad_args
0022   042D 3B 26 0A    	mov d, tokstr
0023   0430 07 90 06    	call strtoint
0024   0433 42 E0 0B    	mov [max], a
0025   0436             	
0026   0436 14 E2 0B    	mov a, [min]
0027   0439             primes_L1:
0028   0439 38 02 00    	mov c, 2	
0029   043C             primes_L2:
0030   043C D7          	push a
0031   043D 28          	mov b, c
0032   043E AE          	div a, b
0033   043F C0 00 00    	cmp b, 0
0034   0442 C6 4A 04    	jz divisible
0035   0445 78          	inc c
0036   0446 E4          	pop a
0037   0447 0A 3C 04    	jmp primes_L2		
0038   044A             divisible:
0039   044A E4          	pop a
0040   044B B1          	cmp a, c
0041   044C C7 72 04    	jnz notprime			
0042   044F             isprime:
0043   044F 07 E9 06    	call print_u16d
0044   0452             	
0045   0452 D7          	push a
0046   0453 14 DE 0B    	mov a, [total]
0047   0456 77          	inc a
0048   0457 42 DE 0B    	mov [total], a
0049   045A 3B F3 0B    	mov d, s_total
0050   045D 07 C0 06    	call puts
0051   0460 07 E9 06    	call print_u16d
0052   0463             	
0053   0463 E4          	pop a
0054   0464             
0055   0464 07 6D 06    	call printnl
0056   0467 77          	inc a
0057   0468 29 E0 0B    	mov b, [max]
0058   046B B0          	cmp a, b
0059   046C C9 76 04    	jgeu primes_ret
0060   046F 0A 39 04    	jmp primes_L1
0061   0472             notprime:
0062   0472 77          	inc a
0063   0473 0A 39 04    	jmp primes_L1		
0064   0476             primes_ret:
0065   0476 05 0B       	syscall sys_terminate_proc
0066   0478             
0067   0478             bad_args:
0068   0478 3B C3 0B    	mov d, s_usage
0069   047B 07 C0 06    	call puts
0070   047E 0A 76 04    	jmp primes_ret
0071   0481             
0072   0481             .include "stdio.asm"
0001+  0481             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0481             ; stdio.s
0003+  0481             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0481             .include "string.asm"
0001++ 0481             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0481             ; string.s
0003++ 0481             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0481             
0005++ 0481             
0006++ 0481             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0481             ; strrev
0008++ 0481             ; reverse a string
0009++ 0481             ; D = string address
0010++ 0481             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0481             ; 01234
0012++ 0481             strrev:
0013++ 0481 4B          	pusha
0014++ 0482 07 C8 04    	call strlen	; length in C
0015++ 0485 12          	mov a, c
0016++ 0486 AF 01 00    	cmp a, 1
0017++ 0489 D0 A3 04    	jleu strrev_end	; check string length. string len must be > 1
0018++ 048C 7D          	dec a
0019++ 048D FD 4E       	mov si, d	; beginning of string
0020++ 048F FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0491 59          	add d, a	; end of string
0022++ 0492 12          	mov a, c
0023++ 0493 FD 9B       	shr a		; divide by 2
0024++ 0495 39          	mov c, a	; C now counts the steps
0025++ 0496             strrev_L0:
0026++ 0496 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0497 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0498 3E          	mov [d], al	; store left char into right side
0029++ 0499 1B          	mov al, bl
0030++ 049A F7          	stosb		; store right-side char into left-side; increase DI
0031++ 049B 7E          	dec c
0032++ 049C 7F          	dec d
0033++ 049D C2 00 00    	cmp c, 0
0034++ 04A0 C7 96 04    	jne strrev_L0
0035++ 04A3             strrev_end:
0036++ 04A3 4C          	popa
0037++ 04A4 09          	ret
0038++ 04A5             	
0039++ 04A5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 04A5             ; strchr
0041++ 04A5             ; search string in D for char in AL
0042++ 04A5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 04A5             strchr:
0044++ 04A5             strchr_L0:
0045++ 04A5 32          	mov bl, [d]
0046++ 04A6 C1 00       	cmp bl, 0
0047++ 04A8 C6 B3 04    	je strchr_end
0048++ 04AB BA          	cmp al, bl
0049++ 04AC C6 B3 04    	je strchr_end
0050++ 04AF 79          	inc d
0051++ 04B0 0A A5 04    	jmp strchr_L0
0052++ 04B3             strchr_end:
0053++ 04B3 1B          	mov al, bl
0054++ 04B4 09          	ret
0055++ 04B5             
0056++ 04B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 04B5             ; strstr
0058++ 04B5             ; find sub-string
0059++ 04B5             ; str1 in SI
0060++ 04B5             ; str2 in DI
0061++ 04B5             ; SI points to end of source string
0062++ 04B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 04B5             strstr:
0064++ 04B5 DB          	push al
0065++ 04B6 DA          	push d
0066++ 04B7 E3          	push di
0067++ 04B8             strstr_loop:
0068++ 04B8 F3          	cmpsb					; compare a byte of the strings
0069++ 04B9 C7 C4 04    	jne strstr_ret
0070++ 04BC FC 00 00    	lea d, [di + 0]
0071++ 04BF BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 04C1 C7 B8 04    	jne strstr_loop				; equal chars but not at end
0073++ 04C4             strstr_ret:
0074++ 04C4 F0          	pop di
0075++ 04C5 E7          	pop d
0076++ 04C6 E8          	pop al
0077++ 04C7 09          	ret
0078++ 04C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 04C8             ; length of null terminated string
0080++ 04C8             ; result in C
0081++ 04C8             ; pointer in D
0082++ 04C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 04C8             strlen:
0084++ 04C8 DA          	push d
0085++ 04C9 38 00 00    	mov c, 0
0086++ 04CC             strlen_L1:
0087++ 04CC BD 00       	cmp byte [d], 0
0088++ 04CE C6 D6 04    	je strlen_ret
0089++ 04D1 79          	inc d
0090++ 04D2 78          	inc c
0091++ 04D3 0A CC 04    	jmp strlen_L1
0092++ 04D6             strlen_ret:
0093++ 04D6 E7          	pop d
0094++ 04D7 09          	ret
0095++ 04D8             
0096++ 04D8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 04D8             ; STRCMP
0098++ 04D8             ; compare two strings
0099++ 04D8             ; str1 in SI
0100++ 04D8             ; str2 in DI
0101++ 04D8             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 04D8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 04D8             strcmp:
0104++ 04D8 DB          	push al
0105++ 04D9 DA          	push d
0106++ 04DA E3          	push di
0107++ 04DB E2          	push si
0108++ 04DC             strcmp_loop:
0109++ 04DC F3          	cmpsb					; compare a byte of the strings
0110++ 04DD C7 E8 04    	jne strcmp_ret
0111++ 04E0 FB FF FF    	lea d, [si +- 1]
0112++ 04E3 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 04E5 C7 DC 04    	jne strcmp_loop				; equal chars but not at end
0114++ 04E8             strcmp_ret:
0115++ 04E8 EF          	pop si
0116++ 04E9 F0          	pop di
0117++ 04EA E7          	pop d
0118++ 04EB E8          	pop al
0119++ 04EC 09          	ret
0120++ 04ED             
0121++ 04ED             
0122++ 04ED             ; STRCPY
0123++ 04ED             ; copy null terminated string from SI to DI
0124++ 04ED             ; source in SI
0125++ 04ED             ; destination in DI
0126++ 04ED             strcpy:
0127++ 04ED E2          	push si
0128++ 04EE E3          	push di
0129++ 04EF DB          	push al
0130++ 04F0             strcpy_L1:
0131++ 04F0 F6          	lodsb
0132++ 04F1 F7          	stosb
0133++ 04F2 B9 00       	cmp al, 0
0134++ 04F4 C7 F0 04    	jne strcpy_L1
0135++ 04F7             strcpy_end:
0136++ 04F7 E8          	pop al
0137++ 04F8 F0          	pop di
0138++ 04F9 EF          	pop si
0139++ 04FA 09          	ret
0140++ 04FB             
0141++ 04FB             ; STRCAT
0142++ 04FB             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 04FB             ; source in SI
0144++ 04FB             ; destination in DI
0145++ 04FB             strcat:
0146++ 04FB E2          	push si
0147++ 04FC E3          	push di
0148++ 04FD D7          	push a
0149++ 04FE DA          	push d
0150++ 04FF 50          	mov a, di
0151++ 0500 3C          	mov d, a
0152++ 0501             strcat_goto_end_L1:
0153++ 0501 BD 00       	cmp byte[d], 0
0154++ 0503 C6 0A 05    	je strcat_start
0155++ 0506 79          	inc d
0156++ 0507 0A 01 05    	jmp strcat_goto_end_L1
0157++ 050A             strcat_start:
0158++ 050A FD 50       	mov di, d
0159++ 050C             strcat_L1:
0160++ 050C F6          	lodsb
0161++ 050D F7          	stosb
0162++ 050E B9 00       	cmp al, 0
0163++ 0510 C7 0C 05    	jne strcat_L1
0164++ 0513             strcat_end:
0165++ 0513 E7          	pop d
0166++ 0514 E4          	pop a
0167++ 0515 F0          	pop di
0168++ 0516 EF          	pop si
0169++ 0517 09          	ret
0005+  0518             
0006+  0518 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  051C 34 35 36 37 
0006+  0520 38 39 41 42 
0006+  0524 43 44 45 46 
0007+  0528             
0008+  0528 01 00       table_power:.dw 1
0009+  052A 0A 00       			.dw 10
0010+  052C 64 00       			.dw 100
0011+  052E E8 03       			.dw 1000
0012+  0530 10 27       			.dw 10000
0013+  0532             
0014+  0532             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0015+  0532             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0016+  0532             ; ASCII in BL
0017+  0532             ; result in AL
0018+  0532             ; ascii for F = 0100 0110
0019+  0532             ; ascii for 9 = 0011 1001
0020+  0532             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0021+  0532             hex_ascii_encode:
0022+  0532 1B          	mov al, bl
0023+  0533 93 40       	test al, $40				; test if letter or number
0024+  0535 C7 3B 05    	jnz hex_letter
0025+  0538 87 0F       	and al, $0F				; get number
0026+  053A 09          	ret
0027+  053B             hex_letter:
0028+  053B 87 0F       	and al, $0F				; get letter
0029+  053D 6A 09       	add al, 9
0030+  053F 09          	ret
0031+  0540             
0032+  0540             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0033+  0540             ; ATOI
0034+  0540             ; 2 letter hex string in B
0035+  0540             ; 8bit integer returned in AL
0036+  0540             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0037+  0540             atoi:
0038+  0540 D8          	push b
0039+  0541 07 32 05    	call hex_ascii_encode			; convert BL to 4bit code in AL
0040+  0544 30          	mov bl, bh
0041+  0545 DB          	push al					; save a
0042+  0546 07 32 05    	call hex_ascii_encode
0043+  0549 EA          	pop bl	
0044+  054A FD 9E 04    	shl al, 4
0045+  054D 8C          	or al, bl
0046+  054E E5          	pop b
0047+  054F 09          	ret	
0048+  0550             
0049+  0550             
0050+  0550             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  0550             ; printf
0052+  0550             ; no need for explanations!
0053+  0550             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0054+  0550             printf:
0055+  0550 09          	ret
0056+  0551             
0057+  0551             
0058+  0551             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  0551             ; scanf
0060+  0551             ; no need for explanations!
0061+  0551             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  0551             scanf:
0063+  0551 09          	ret
0064+  0552             
0065+  0552             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  0552             ; ITOA
0067+  0552             ; 8bit value in BL
0068+  0552             ; 2 byte ASCII result in A
0069+  0552             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0070+  0552             itoa:
0071+  0552 DA          	push d
0072+  0553 D8          	push b
0073+  0554 A7 00       	mov bh, 0
0074+  0556 FD A4 04    	shr bl, 4	
0075+  0559 74          	mov d, b
0076+  055A 1F 18 05    	mov al, [d + s_hex_digits]
0077+  055D 23          	mov ah, al
0078+  055E             	
0079+  055E E5          	pop b
0080+  055F D8          	push b
0081+  0560 A7 00       	mov bh, 0
0082+  0562 FD 87 0F    	and bl, $0F
0083+  0565 74          	mov d, b
0084+  0566 1F 18 05    	mov al, [d + s_hex_digits]
0085+  0569 E5          	pop b
0086+  056A E7          	pop d
0087+  056B 09          	ret
0088+  056C             
0089+  056C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0090+  056C             ; HEX STRING TO BINARY
0091+  056C             ; di = destination address
0092+  056C             ; si = source
0093+  056C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0094+  056C             hex_to_int:
0095+  056C             hex_to_int_L1:
0096+  056C F6          	lodsb					; load from [SI] to AL
0097+  056D B9 00       	cmp al, 0				; check if ASCII 0
0098+  056F C6 7C 05    	jz hex_to_int_ret
0099+  0572 36          	mov bh, al
0100+  0573 F6          	lodsb
0101+  0574 2F          	mov bl, al
0102+  0575 07 40 05    	call atoi				; convert ASCII byte in B to int (to AL)
0103+  0578 F7          	stosb					; store AL to [DI]
0104+  0579 0A 6C 05    	jmp hex_to_int_L1
0105+  057C             hex_to_int_ret:
0106+  057C 09          	ret		
0107+  057D             
0108+  057D             
0109+  057D             
0110+  057D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  057D             ; GETCHAR
0112+  057D             ; char in ah
0113+  057D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0114+  057D             getchar:
0115+  057D DB          	push al
0116+  057E             getchar_retry:
0117+  057E FD 0C       	sti
0118+  0580 19 01       	mov al, 1
0119+  0582 05 03       	syscall sys_io			; receive in AH
0120+  0584 B9 00       	cmp al, 0			; check if any char was receive
0121+  0586 C6 7E 05    	je getchar_retry
0122+  0589 E8          	pop al
0123+  058A 09          	ret
0124+  058B             
0125+  058B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0126+  058B             ; PUTCHAR
0127+  058B             ; char in ah
0128+  058B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  058B             putchar:
0130+  058B D7          	push a
0131+  058C 19 00       	mov al, 0
0132+  058E 05 03       	syscall sys_io			; char in AH
0133+  0590 E4          	pop a
0134+  0591 09          	ret
0135+  0592             
0136+  0592             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0137+  0592             ;; INPUT A STRING
0138+  0592             ;; terminates with null
0139+  0592             ;; pointer in D
0140+  0592             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  0592             gets:
0142+  0592 D7          	push a
0143+  0593 DA          	push d
0144+  0594             gets_loop:
0145+  0594 FD 0C       	sti
0146+  0596 19 01       	mov al, 1
0147+  0598 05 03       	syscall sys_io			; receive in AH
0148+  059A B9 00       	cmp al, 0				; check error code (AL)
0149+  059C C6 94 05    	je gets_loop			; if no char received, retry
0150+  059F             
0151+  059F 76 1B       	cmp ah, 27
0152+  05A1 C6 BD 05    	je gets_telnet_escape
0153+  05A4 76 0A       	cmp ah, $0A				; LF
0154+  05A6 C6 16 06    	je gets_end
0155+  05A9 76 5C       	cmp ah, $5C				; '\\'
0156+  05AB C6 ED 05    	je gets_escape
0157+  05AE             	
0158+  05AE 76 08       	cmp ah, $08			; check for backspace
0159+  05B0 C6 B9 05    	je gets_backspace
0160+  05B3             
0161+  05B3 1A          	mov al, ah
0162+  05B4 3E          	mov [d], al
0163+  05B5 79          	inc d
0164+  05B6 0A 94 05    	jmp gets_loop
0165+  05B9             gets_backspace:
0166+  05B9 7F          	dec d
0167+  05BA 0A 94 05    	jmp gets_loop
0168+  05BD             gets_telnet_escape:
0169+  05BD FD 0C       	sti
0170+  05BF 19 01       	mov al, 1
0171+  05C1 05 03       	syscall sys_io				; receive in AH without echo
0172+  05C3 B9 00       	cmp al, 0					; check error code (AL)
0173+  05C5 C6 BD 05    	je gets_telnet_escape		; if no char received, retry
0174+  05C8 76 5B       	cmp ah, '['
0175+  05CA C7 94 05    	jne gets_loop
0176+  05CD             gets_telnet_escape_phase2:
0177+  05CD FD 0C       	sti
0178+  05CF 19 01       	mov al, 1
0179+  05D1 05 03       	syscall sys_io					; receive in AH without echo
0180+  05D3 B9 00       	cmp al, 0						; check error code (AL)
0181+  05D5 C6 CD 05    	je gets_telnet_escape_phase2	; if no char received, retry
0182+  05D8 76 44       	cmp ah, 'D'
0183+  05DA C6 E5 05    	je gets_left_arrow
0184+  05DD 76 43       	cmp ah, 'C'
0185+  05DF C6 E9 05    	je gets_right_arrow
0186+  05E2 0A 94 05    	jmp gets_loop
0187+  05E5             gets_left_arrow:
0188+  05E5 7F          	dec d
0189+  05E6 0A 94 05    	jmp gets_loop
0190+  05E9             gets_right_arrow:
0191+  05E9 79          	inc d
0192+  05EA 0A 94 05    	jmp gets_loop
0193+  05ED             gets_escape:
0194+  05ED FD 0C       	sti
0195+  05EF 19 01       	mov al, 1
0196+  05F1 05 03       	syscall sys_io			; receive in AH
0197+  05F3 B9 00       	cmp al, 0				; check error code (AL)
0198+  05F5 C6 ED 05    	je gets_escape			; if no char received, retry
0199+  05F8 76 6E       	cmp ah, 'n'
0200+  05FA C6 08 06    	je gets_LF
0201+  05FD 76 72       	cmp ah, 'r'
0202+  05FF C6 0F 06    	je gets_CR
0203+  0602 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0204+  0603 3E          	mov [d], al
0205+  0604 79          	inc d
0206+  0605 0A 94 05    	jmp gets_loop
0207+  0608             gets_LF:
0208+  0608 19 0A       	mov al, $0A
0209+  060A 3E          	mov [d], al
0210+  060B 79          	inc d
0211+  060C 0A 94 05    	jmp gets_loop
0212+  060F             gets_CR:
0213+  060F 19 0D       	mov al, $0D
0214+  0611 3E          	mov [d], al
0215+  0612 79          	inc d
0216+  0613 0A 94 05    	jmp gets_loop
0217+  0616             gets_end:
0218+  0616 19 00       	mov al, 0
0219+  0618 3E          	mov [d], al				; terminate string
0220+  0619 E7          	pop d
0221+  061A E4          	pop a
0222+  061B 09          	ret
0223+  061C             
0224+  061C             
0225+  061C             
0226+  061C             
0227+  061C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0228+  061C             ;; INPUT TEXT
0229+  061C             ;; terminated with CTRL+D
0230+  061C             ;; pointer in D
0231+  061C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0232+  061C             gettxt:
0233+  061C D7          	push a
0234+  061D DA          	push d
0235+  061E             gettxt_loop:
0236+  061E 19 01       	mov al, 1
0237+  0620 05 03       	syscall sys_io			; receive in AH
0238+  0622 B9 00       	cmp al, 0				; check error code (AL)
0239+  0624 C6 1E 06    	je gettxt_loop		; if no char received, retry
0240+  0627 76 04       	cmp ah, 4			; EOT
0241+  0629 C6 67 06    	je gettxt_end
0242+  062C 76 08       	cmp ah, $08			; check for backspace
0243+  062E C6 63 06    	je gettxt_backspace
0244+  0631 76 5C       	cmp ah, $5C				; '\\'
0245+  0633 C6 3C 06    	je gettxt_escape
0246+  0636 1A          	mov al, ah
0247+  0637 3E          	mov [d], al
0248+  0638 79          	inc d
0249+  0639 0A 1E 06    	jmp gettxt_loop
0250+  063C             gettxt_escape:
0251+  063C 19 01       	mov al, 1
0252+  063E 05 03       	syscall sys_io			; receive in AH
0253+  0640 B9 00       	cmp al, 0				; check error code (AL)
0254+  0642 C6 3C 06    	je gettxt_escape		; if no char received, retry
0255+  0645 76 6E       	cmp ah, 'n'
0256+  0647 C6 55 06    	je gettxt_LF
0257+  064A 76 72       	cmp ah, 'r'
0258+  064C C6 5C 06    	je gettxt_CR
0259+  064F 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0260+  0650 3E          	mov [d], al
0261+  0651 79          	inc d
0262+  0652 0A 1E 06    	jmp gettxt_loop
0263+  0655             gettxt_LF:
0264+  0655 19 0A       	mov al, $0A
0265+  0657 3E          	mov [d], al
0266+  0658 79          	inc d
0267+  0659 0A 1E 06    	jmp gettxt_loop
0268+  065C             gettxt_CR:
0269+  065C 19 0D       	mov al, $0D
0270+  065E 3E          	mov [d], al
0271+  065F 79          	inc d
0272+  0660 0A 1E 06    	jmp gettxt_loop
0273+  0663             gettxt_backspace:
0274+  0663 7F          	dec d
0275+  0664 0A 1E 06    	jmp gettxt_loop
0276+  0667             gettxt_end:
0277+  0667 19 00       	mov al, 0
0278+  0669 3E          	mov [d], al				; terminate string
0279+  066A E7          	pop d
0280+  066B E4          	pop a
0281+  066C 09          	ret
0282+  066D             
0283+  066D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0284+  066D             ; PRINT NEW LINE
0285+  066D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0286+  066D             printnl:
0287+  066D D7          	push a
0288+  066E 10 00 0A    	mov a, $0A00
0289+  0671 05 03       	syscall sys_io
0290+  0673 10 00 0D    	mov a, $0D00
0291+  0676 05 03       	syscall sys_io
0292+  0678 E4          	pop a
0293+  0679 09          	ret
0294+  067A             
0295+  067A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0296+  067A             ; strtoint
0297+  067A             ; 4 digit hex string number in d
0298+  067A             ; integer returned in A
0299+  067A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0300+  067A             strtointx:
0301+  067A D8          	push b
0302+  067B 32          	mov bl, [d]
0303+  067C 37          	mov bh, bl
0304+  067D 33 01 00    	mov bl, [d + 1]
0305+  0680 07 40 05    	call atoi				; convert to int in AL
0306+  0683 23          	mov ah, al				; move to AH
0307+  0684 33 02 00    	mov bl, [d + 2]
0308+  0687 37          	mov bh, bl
0309+  0688 33 03 00    	mov bl, [d + 3]
0310+  068B 07 40 05    	call atoi				; convert to int in AL
0311+  068E E5          	pop b
0312+  068F 09          	ret
0313+  0690             
0314+  0690             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0315+  0690             ; strtoint
0316+  0690             ; 5 digit base10 string number in d
0317+  0690             ; integer returned in A
0318+  0690             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0319+  0690             strtoint:
0320+  0690 E2          	push si
0321+  0691 D8          	push b
0322+  0692 D9          	push c
0323+  0693 DA          	push d
0324+  0694 07 C8 04    	call strlen			; get string length in C
0325+  0697 7E          	dec c
0326+  0698 FD 4E       	mov si, d
0327+  069A 12          	mov a, c
0328+  069B FD 99       	shl a
0329+  069D 3B 28 05    	mov d, table_power
0330+  06A0 59          	add d, a
0331+  06A1 38 00 00    	mov c, 0
0332+  06A4             strtoint_L0:
0333+  06A4 F6          	lodsb			; load ASCII to al
0334+  06A5 B9 00       	cmp al, 0
0335+  06A7 C6 BA 06    	je strtoint_end
0336+  06AA 6F 30       	sub al, $30		; make into integer
0337+  06AC 22 00       	mov ah, 0
0338+  06AE 2A          	mov b, [d]
0339+  06AF AC          	mul a, b			; result in B since it fits in 16bits
0340+  06B0 11          	mov a, b
0341+  06B1 28          	mov b, c
0342+  06B2 54          	add a, b
0343+  06B3 39          	mov c, a
0344+  06B4 63 02 00    	sub d, 2
0345+  06B7 0A A4 06    	jmp strtoint_L0
0346+  06BA             strtoint_end:
0347+  06BA 12          	mov a, c
0348+  06BB E7          	pop d
0349+  06BC E6          	pop c
0350+  06BD E5          	pop b
0351+  06BE EF          	pop si
0352+  06BF 09          	ret
0353+  06C0             
0354+  06C0             
0355+  06C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  06C0             ; PRINT NULL TERMINATED STRING
0357+  06C0             ; pointer in D
0358+  06C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  06C0             puts:
0360+  06C0 D7          	push a
0361+  06C1 DA          	push d
0362+  06C2             puts_L1:
0363+  06C2 1E          	mov al, [d]
0364+  06C3 B9 00       	cmp al, 0
0365+  06C5 C6 D1 06    	jz puts_END
0366+  06C8 23          	mov ah, al
0367+  06C9 19 00       	mov al, 0
0368+  06CB 05 03       	syscall sys_io
0369+  06CD 79          	inc d
0370+  06CE 0A C2 06    	jmp puts_L1
0371+  06D1             puts_END:
0372+  06D1 E7          	pop d
0373+  06D2 E4          	pop a
0374+  06D3 09          	ret
0375+  06D4             
0376+  06D4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0377+  06D4             ; PRINT N SIZE STRING
0378+  06D4             ; pointer in D
0379+  06D4             ; size in C
0380+  06D4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0381+  06D4             putsn:
0382+  06D4 DB          	push al
0383+  06D5 DA          	push d
0384+  06D6 D9          	push c
0385+  06D7             putsn_L0:
0386+  06D7 1E          	mov al, [d]
0387+  06D8 23          	mov ah, al
0388+  06D9 19 00       	mov al, 0
0389+  06DB 05 03       	syscall sys_io
0390+  06DD 79          	inc d
0391+  06DE 7E          	dec c	
0392+  06DF C2 00 00    	cmp c, 0
0393+  06E2 C7 D7 06    	jne putsn_L0
0394+  06E5             putsn_end:
0395+  06E5 E6          	pop c
0396+  06E6 E7          	pop d
0397+  06E7 E8          	pop al
0398+  06E8 09          	ret
0399+  06E9             
0400+  06E9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0401+  06E9             ; print 16bit decimal number
0402+  06E9             ; input number in A
0403+  06E9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  06E9             print_u16d:
0405+  06E9 D7          	push a
0406+  06EA D8          	push b
0407+  06EB 26 10 27    	mov b, 10000
0408+  06EE AE          	div a, b			; get 10000 coeff.
0409+  06EF 07 15 07    	call print_zero_or_space
0410+  06F2 11          	mov a, b
0411+  06F3 26 E8 03    	mov b, 1000
0412+  06F6 AE          	div a, b			; get 10000 coeff.
0413+  06F7 07 15 07    	call print_zero_or_space
0414+  06FA 11          	mov a, b
0415+  06FB 26 64 00    	mov b, 100
0416+  06FE AE          	div a, b
0417+  06FF 07 15 07    	call print_zero_or_space
0418+  0702 11          	mov a, b
0419+  0703 26 0A 00    	mov b, 10
0420+  0706 AE          	div a, b
0421+  0707 07 15 07    	call print_zero_or_space
0422+  070A 11          	mov a, b
0423+  070B 6A 30       	add al, $30
0424+  070D 23          	mov ah, al
0425+  070E 19 00       	mov al, 0
0426+  0710 05 03       	syscall sys_io	; print coeff
0427+  0712 E5          	pop b
0428+  0713 E4          	pop a
0429+  0714 09          	ret
0430+  0715             
0431+  0715             
0432+  0715             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0433+  0715             ; if A == 0, print space
0434+  0715             ; else print A
0435+  0715             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  0715             print_zero_or_space:
0437+  0715             	; cmp a, 0
0438+  0715             	; jne print_number
0439+  0715             	; mov ah, $20
0440+  0715             	; call putchar
0441+  0715             	; ret
0442+  0715             print_number:
0443+  0715 6A 30       	add al, $30
0444+  0717 23          	mov ah, al
0445+  0718 07 8B 05    	call putchar
0446+  071B 09          	ret
0447+  071C             
0448+  071C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  071C             ; PRINT 16BIT HEX INTEGER
0450+  071C             ; integer value in reg B
0451+  071C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0452+  071C             print_u16x:
0453+  071C D7          	push a
0454+  071D D8          	push b
0455+  071E DD          	push bl
0456+  071F 30          	mov bl, bh
0457+  0720 07 52 05    	call itoa				; convert bh to char in A
0458+  0723 2F          	mov bl, al				; save al
0459+  0724 19 00       	mov al, 0
0460+  0726 05 03       	syscall sys_io				; display AH
0461+  0728 24          	mov ah, bl				; retrieve al
0462+  0729 19 00       	mov al, 0
0463+  072B 05 03       	syscall sys_io				; display AL
0464+  072D             
0465+  072D EA          	pop bl
0466+  072E 07 52 05    	call itoa				; convert bh to char in A
0467+  0731 2F          	mov bl, al				; save al
0468+  0732 19 00       	mov al, 0
0469+  0734 05 03       	syscall sys_io				; display AH
0470+  0736 24          	mov ah, bl				; retrieve al
0471+  0737 19 00       	mov al, 0
0472+  0739 05 03       	syscall sys_io				; display AL
0473+  073B             
0474+  073B E5          	pop b
0475+  073C E4          	pop a
0476+  073D 09          	ret
0477+  073E             
0478+  073E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  073E             ; INPUT 16BIT HEX INTEGER
0480+  073E             ; read 16bit integer into A
0481+  073E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0482+  073E             scan_u16x:
0483+  073E F8 10 00    	enter 16
0484+  0741 D8          	push b
0485+  0742 DA          	push d
0486+  0743             
0487+  0743 FA F1 FF    	lea d, [bp + -15]
0488+  0746 07 92 05    	call gets				; get number
0489+  0749             
0490+  0749 32          	mov bl, [d]
0491+  074A 37          	mov bh, bl
0492+  074B 33 01 00    	mov bl, [d + 1]
0493+  074E 07 40 05    	call atoi				; convert to int in AL
0494+  0751 23          	mov ah, al				; move to AH
0495+  0752             
0496+  0752 33 02 00    	mov bl, [d + 2]
0497+  0755 37          	mov bh, bl
0498+  0756 33 03 00    	mov bl, [d + 3]
0499+  0759 07 40 05    	call atoi				; convert to int in AL
0500+  075C             
0501+  075C E7          	pop d
0502+  075D E5          	pop b
0503+  075E F9          	leave
0504+  075F 09          	ret
0505+  0760             
0506+  0760             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  0760             ; PRINT 8bit HEX INTEGER
0508+  0760             ; integer value in reg bl
0509+  0760             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0510+  0760             print_u8x:
0511+  0760 D7          	push a
0512+  0761 DD          	push bl
0513+  0762             
0514+  0762 07 52 05    	call itoa				; convert bl to char in A
0515+  0765 2F          	mov bl, al				; save al
0516+  0766 19 00       	mov al, 0
0517+  0768 05 03       	syscall sys_io				; display AH
0518+  076A 24          	mov ah, bl				; retrieve al
0519+  076B 19 00       	mov al, 0
0520+  076D 05 03       	syscall sys_io				; display AL
0521+  076F             
0522+  076F EA          	pop bl
0523+  0770 E4          	pop a
0524+  0771 09          	ret
0525+  0772             
0526+  0772             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  0772             ; print 8bit decimal unsigned number
0528+  0772             ; input number in AL
0529+  0772             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0530+  0772             print_u8d:
0531+  0772 D7          	push a
0532+  0773 D8          	push b
0533+  0774             
0534+  0774 22 00       	mov ah, 0
0535+  0776 26 64 00    	mov b, 100
0536+  0779 AE          	div a, b
0537+  077A D8          	push b			; save remainder
0538+  077B B9 00       	cmp al, 0
0539+  077D C6 87 07    	je skip100
0540+  0780 6A 30       	add al, $30
0541+  0782 23          	mov ah, al
0542+  0783 19 00       	mov al, 0
0543+  0785 05 03       	syscall sys_io	; print coeff
0544+  0787             skip100:
0545+  0787 E4          	pop a
0546+  0788 22 00       	mov ah, 0
0547+  078A 26 0A 00    	mov b, 10
0548+  078D AE          	div a, b
0549+  078E D8          	push b			; save remainder
0550+  078F B9 00       	cmp al, 0
0551+  0791 C6 9B 07    	je skip10
0552+  0794 6A 30       	add al, $30
0553+  0796 23          	mov ah, al
0554+  0797 19 00       	mov al, 0
0555+  0799 05 03       	syscall sys_io	; print coeff
0556+  079B             skip10:
0557+  079B E4          	pop a
0558+  079C 1B          	mov al, bl
0559+  079D 6A 30       	add al, $30
0560+  079F 23          	mov ah, al
0561+  07A0 19 00       	mov al, 0
0562+  07A2 05 03       	syscall sys_io	; print coeff
0563+  07A4 E5          	pop b
0564+  07A5 E4          	pop a
0565+  07A6 09          	ret
0566+  07A7             
0567+  07A7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  07A7             ; INPUT 8BIT HEX INTEGER
0569+  07A7             ; read 8bit integer into AL
0570+  07A7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0571+  07A7             scan_u8x:
0572+  07A7 F8 04 00    	enter 4
0573+  07AA D8          	push b
0574+  07AB DA          	push d
0575+  07AC             
0576+  07AC FA FD FF    	lea d, [bp + -3]
0577+  07AF 07 92 05    	call gets				; get number
0578+  07B2             
0579+  07B2 32          	mov bl, [d]
0580+  07B3 37          	mov bh, bl
0581+  07B4 33 01 00    	mov bl, [d + 1]
0582+  07B7 07 40 05    	call atoi				; convert to int in AL
0583+  07BA             
0584+  07BA E7          	pop d
0585+  07BB E5          	pop b
0586+  07BC F9          	leave
0587+  07BD 09          	ret
0588+  07BE             
0589+  07BE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0590+  07BE             ; input decimal number
0591+  07BE             ; result in A
0592+  07BE             ; 655'\0'
0593+  07BE             ; low--------high
0594+  07BE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0595+  07BE             scan_u16d:
0596+  07BE F8 08 00    	enter 8
0597+  07C1 E2          	push si
0598+  07C2 D8          	push b
0599+  07C3 D9          	push c
0600+  07C4 DA          	push d
0601+  07C5 FA F9 FF    	lea d, [bp +- 7]
0602+  07C8 07 92 05    	call gets
0603+  07CB 07 C8 04    	call strlen			; get string length in C
0604+  07CE 7E          	dec c
0605+  07CF FD 4E       	mov si, d
0606+  07D1 12          	mov a, c
0607+  07D2 FD 99       	shl a
0608+  07D4 3B 28 05    	mov d, table_power
0609+  07D7 59          	add d, a
0610+  07D8 38 00 00    	mov c, 0
0611+  07DB             mul_loop:
0612+  07DB F6          	lodsb			; load ASCII to al
0613+  07DC B9 00       	cmp al, 0
0614+  07DE C6 F1 07    	je mul_exit
0615+  07E1 6F 30       	sub al, $30		; make into integer
0616+  07E3 22 00       	mov ah, 0
0617+  07E5 2A          	mov b, [d]
0618+  07E6 AC          	mul a, b			; result in B since it fits in 16bits
0619+  07E7 11          	mov a, b
0620+  07E8 28          	mov b, c
0621+  07E9 54          	add a, b
0622+  07EA 39          	mov c, a
0623+  07EB 63 02 00    	sub d, 2
0624+  07EE 0A DB 07    	jmp mul_loop
0625+  07F1             mul_exit:
0626+  07F1 12          	mov a, c
0627+  07F2 E7          	pop d
0628+  07F3 E6          	pop c
0629+  07F4 E5          	pop b
0630+  07F5 EF          	pop si
0631+  07F6 F9          	leave
0632+  07F7 09          	ret
0073   07F8             .include "token.asm"
0001+  07F8             TOKTYP_IDENTIFIER	.equ 0
0002+  07F8             TOKTYP_KEYWORD		.equ 1
0003+  07F8             TOKTYP_DELIMITER	.equ 2
0004+  07F8             TOKTYP_STRING		.equ 3
0005+  07F8             TOKTYP_CHAR			.equ 4
0006+  07F8             TOKTYP_NUMERIC		.equ 5
0007+  07F8             TOKTYP_END			.equ 6
0008+  07F8             
0009+  07F8             TOK_NULL			.equ 0
0010+  07F8             TOK_FSLASH			.equ 1
0011+  07F8             TOK_TIMES 			.equ 2
0012+  07F8             TOK_PLUS 			.equ 3
0013+  07F8             TOK_MINUS 			.equ 4
0014+  07F8             TOK_DOT				.equ 5
0015+  07F8             TOK_SEMI			.equ 6
0016+  07F8             TOK_ANGLE			.equ 7
0017+  07F8             TOK_TILDE			.equ 8
0018+  07F8             TOK_EQUAL			.equ 9
0019+  07F8             TOK_COLON			.equ 10
0020+  07F8             TOK_COMMA			.equ 11
0021+  07F8             
0022+  07F8             TOK_END				.equ 20
0023+  07F8             
0024+  07F8             
0025+  07F8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  07F8             ;; read a full command argment from shell input buffer
0027+  07F8             ;; argument is written into tokstr
0028+  07F8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  07F8             get_arg:
0030+  07F8 D7          	push a
0031+  07F9 E2          	push si
0032+  07FA E3          	push di
0033+  07FB 19 00       	mov al, 0
0034+  07FD 3D 26 0A    	mov [tokstr], al			; nullify tokstr string
0035+  0800 14 22 0A    	mov a, [prog]
0036+  0803 4D          	mov si, a
0037+  0804 FD 4F 26 0A 	mov di, tokstr
0038+  0808             get_arg_skip_spaces:
0039+  0808 F6          	lodsb
0040+  0809 07 9C 0B    	call isspace
0041+  080C C6 08 08    	je get_arg_skip_spaces
0042+  080F             get_arg_L0:
0043+  080F B9 3B       	cmp al, $3B				; check if is ';'
0044+  0811 C6 1E 08    	je get_arg_end
0045+  0814 B9 00       	cmp al, 0
0046+  0816 C6 1E 08    	je get_arg_end			; check if end of input
0047+  0819 F7          	stosb
0048+  081A F6          	lodsb
0049+  081B 0A 0F 08    	jmp get_arg_L0
0050+  081E             get_arg_end:
0051+  081E 19 00       	mov al, 0
0052+  0820 F7          	stosb
0053+  0821 D5 01 00    	sub si, 1
0054+  0824 4E          	mov a, si
0055+  0825 42 22 0A    	mov [prog], a		; update pointer
0056+  0828 F0          	pop di
0057+  0829 EF          	pop si
0058+  082A E4          	pop a
0059+  082B 09          	ret
0060+  082C             
0061+  082C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  082C             ;; read a path formation from shell input buffer
0063+  082C             ;; path is written into tokstr
0064+  082C             ;; /usr/bin
0065+  082C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  082C             get_path:
0067+  082C D7          	push a
0068+  082D E2          	push si
0069+  082E E3          	push di
0070+  082F 19 00       	mov al, 0
0071+  0831 3D 26 0A    	mov [tokstr], al			; nullify tokstr string
0072+  0834 14 22 0A    	mov a, [prog]
0073+  0837 4D          	mov si, a
0074+  0838 FD 4F 26 0A 	mov di, tokstr
0075+  083C             get_path_skip_spaces:
0076+  083C F6          	lodsb
0077+  083D 07 9C 0B    	call isspace
0078+  0840 C6 3C 08    	je get_path_skip_spaces
0079+  0843             get_path_is_pathchar:
0080+  0843 F7          	stosb
0081+  0844 F6          	lodsb
0082+  0845 07 26 0B    	call isalnum			;check if is alphanumeric
0083+  0848 C6 43 08    	je get_path_is_pathchar
0084+  084B B9 2F       	cmp al, '/'				; check if is '/'
0085+  084D C6 43 08    	je get_path_is_pathchar
0086+  0850 19 00       	mov al, 0
0087+  0852 F7          	stosb
0088+  0853 D5 01 00    	sub si, 1
0089+  0856 4E          	mov a, si
0090+  0857 42 22 0A    	mov [prog], a		; update pointer
0091+  085A             get_path_end:
0092+  085A F0          	pop di
0093+  085B EF          	pop si
0094+  085C E4          	pop a
0095+  085D 09          	ret
0096+  085E             
0097+  085E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  085E             ;; read a line
0099+  085E             ;; line is written into tokstr
0100+  085E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  085E             get_line:
0102+  085E D7          	push a
0103+  085F E2          	push si
0104+  0860 E3          	push di
0105+  0861 19 00       	mov al, 0
0106+  0863 3D 26 0A    	mov [tokstr], al			; nullify tokstr string
0107+  0866 14 22 0A    	mov a, [prog]
0108+  0869 4D          	mov si, a
0109+  086A FD 4F 26 0A 	mov di, tokstr
0110+  086E             get_line_L0:
0111+  086E F6          	lodsb
0112+  086F B9 0A       	cmp al, $0A		; check for new line
0113+  0871 C6 78 08    	je get_line_exit
0114+  0874 F7          	stosb
0115+  0875 0A 6E 08    	jmp get_line_L0
0116+  0878             get_line_exit:
0117+  0878 19 00       	mov al, 0
0118+  087A F7          	stosb
0119+  087B 4E          	mov a, si
0120+  087C 42 22 0A    	mov [prog], a		; update pointer
0121+  087F F0          	pop di
0122+  0880 EF          	pop si
0123+  0881 E4          	pop a
0124+  0882 09          	ret
0125+  0883             
0126+  0883             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  0883             ;; token parser
0128+  0883             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  0883             get_token:
0130+  0883 D7          	push a
0131+  0884 DA          	push d
0132+  0885 E2          	push si
0133+  0886 E3          	push di
0134+  0887 19 00       	mov al, 0
0135+  0889 3D 26 0A    	mov [tokstr], al			; nullify tokstr string
0136+  088C 19 00       	mov al, TOK_NULL
0137+  088E 3D 25 0A    	mov [tok], al				; nullify token
0138+  0891 14 22 0A    	mov a, [prog]
0139+  0894 4D          	mov si, a
0140+  0895 FD 4F 26 0A 	mov di, tokstr
0141+  0899             get_tok_skip_spaces:
0142+  0899 F6          	lodsb
0143+  089A 07 9C 0B    	call isspace
0144+  089D C6 99 08    	je get_tok_skip_spaces
0145+  08A0 B9 00       	cmp al, 0			; check for end of input (NULL)
0146+  08A2 C6 87 09    	je get_token_end
0147+  08A5 B9 23       	cmp al, '#'			; comments!
0148+  08A7 C6 B5 09    	je get_tok_comment
0149+  08AA 07 26 0B    	call isalnum
0150+  08AD C6 94 09    	jz is_alphanumeric
0151+  08B0             ; other token types
0152+  08B0             get_token_slash:
0153+  08B0 B9 2F       	cmp al, '/'				; check if '/'
0154+  08B2 C7 CA 08    	jne get_token_minus
0155+  08B5 F7          	stosb					; store '/' into token string
0156+  08B6 19 00       	mov al, 0
0157+  08B8 F7          	stosb					; terminate token string
0158+  08B9 19 01       	mov al, TOK_FSLASH
0159+  08BB 3D 25 0A    	mov [tok], al			
0160+  08BE 19 02       	mov al, TOKTYP_DELIMITER
0161+  08C0 3D 24 0A    	mov [toktyp], al
0162+  08C3 4E          	mov a, si
0163+  08C4 42 22 0A    	mov [prog], a		; update pointer
0164+  08C7 0A B0 09    	jmp get_token_return
0165+  08CA             get_token_minus:
0166+  08CA B9 2D       	cmp al, '-'				; check if '-'
0167+  08CC C7 E4 08    	jne get_token_comma
0168+  08CF F7          	stosb					; store '-' into token string
0169+  08D0 19 00       	mov al, 0
0170+  08D2 F7          	stosb					; terminate token string
0171+  08D3 19 04       	mov al, TOK_MINUS
0172+  08D5 3D 25 0A    	mov [tok], al			
0173+  08D8 19 02       	mov al, TOKTYP_DELIMITER
0174+  08DA 3D 24 0A    	mov [toktyp], al
0175+  08DD 4E          	mov a, si
0176+  08DE 42 22 0A    	mov [prog], a		; update pointer
0177+  08E1 0A B0 09    	jmp get_token_return
0178+  08E4             get_token_comma:
0179+  08E4 B9 2C       	cmp al, ','				; check if ','
0180+  08E6 C7 FE 08    	jne get_token_semi
0181+  08E9 F7          	stosb					; store ',' into token string
0182+  08EA 19 00       	mov al, 0
0183+  08EC F7          	stosb					; terminate token string
0184+  08ED 19 0B       	mov al, TOK_COMMA
0185+  08EF 3D 25 0A    	mov [tok], al			
0186+  08F2 19 02       	mov al, TOKTYP_DELIMITER
0187+  08F4 3D 24 0A    	mov [toktyp], al
0188+  08F7 4E          	mov a, si
0189+  08F8 42 22 0A    	mov [prog], a		; update pointer
0190+  08FB 0A B0 09    	jmp get_token_return
0191+  08FE             get_token_semi:
0192+  08FE B9 3B       	cmp al, $3B				; check if ';'
0193+  0900 C7 18 09    	jne get_token_colon
0194+  0903 F7          	stosb					; store ';' into token string
0195+  0904 19 00       	mov al, 0
0196+  0906 F7          	stosb					; terminate token string
0197+  0907 19 06       	mov al, TOK_SEMI
0198+  0909 3D 25 0A    	mov [tok], al			
0199+  090C 19 02       	mov al, TOKTYP_DELIMITER
0200+  090E 3D 24 0A    	mov [toktyp], al
0201+  0911 4E          	mov a, si
0202+  0912 42 22 0A    	mov [prog], a		; update pointer
0203+  0915 0A B0 09    	jmp get_token_return
0204+  0918             get_token_colon:
0205+  0918 B9 3A       	cmp al, $3A				; check if ':'
0206+  091A C7 32 09    	jne get_token_angle
0207+  091D F7          	stosb					; store ':' into token string
0208+  091E 19 00       	mov al, 0
0209+  0920 F7          	stosb					; terminate token string
0210+  0921 19 0A       	mov al, TOK_COLON
0211+  0923 3D 25 0A    	mov [tok], al			
0212+  0926 19 02       	mov al, TOKTYP_DELIMITER
0213+  0928 3D 24 0A    	mov [toktyp], al
0214+  092B 4E          	mov a, si
0215+  092C 42 22 0A    	mov [prog], a		; update pointer
0216+  092F 0A B0 09    	jmp get_token_return
0217+  0932             get_token_angle:
0218+  0932 B9 3E       	cmp al, $3E				; check if '>'
0219+  0934 C7 4C 09    	jne get_token_tilde
0220+  0937 F7          	stosb					; store '>' into token string
0221+  0938 19 00       	mov al, 0
0222+  093A F7          	stosb					; terminate token string
0223+  093B 19 07       	mov al, TOK_ANGLE
0224+  093D 3D 25 0A    	mov [tok], al			
0225+  0940 19 02       	mov al, TOKTYP_DELIMITER
0226+  0942 3D 24 0A    	mov [toktyp], al
0227+  0945 4E          	mov a, si
0228+  0946 42 22 0A    	mov [prog], a		; update pointer
0229+  0949 0A B0 09    	jmp get_token_return
0230+  094C             get_token_tilde:
0231+  094C B9 7E       	cmp al, '~'				; check if '~'
0232+  094E C7 66 09    	jne get_token_equal
0233+  0951 F7          	stosb					; store '~' into token string
0234+  0952 19 00       	mov al, 0
0235+  0954 F7          	stosb					; terminate token string
0236+  0955 19 08       	mov al, TOK_TILDE
0237+  0957 3D 25 0A    	mov [tok], al			
0238+  095A 19 02       	mov al, TOKTYP_DELIMITER
0239+  095C 3D 24 0A    	mov [toktyp], al
0240+  095F 4E          	mov a, si
0241+  0960 42 22 0A    	mov [prog], a		; update pointer
0242+  0963 0A B0 09    	jmp get_token_return
0243+  0966             get_token_equal:
0244+  0966 B9 3D       	cmp al, '='				; check if '='
0245+  0968 C7 80 09    	jne get_token_skip
0246+  096B F7          	stosb					; store '=' into token string
0247+  096C 19 00       	mov al, 0
0248+  096E F7          	stosb					; terminate token string
0249+  096F 19 09       	mov al, TOK_EQUAL
0250+  0971 3D 25 0A    	mov [tok], al			
0251+  0974 19 02       	mov al, TOKTYP_DELIMITER
0252+  0976 3D 24 0A    	mov [toktyp], al
0253+  0979 4E          	mov a, si
0254+  097A 42 22 0A    	mov [prog], a		; update pointer
0255+  097D 0A B0 09    	jmp get_token_return
0256+  0980             get_token_skip:
0257+  0980 4E          	mov a, si
0258+  0981 42 22 0A    	mov [prog], a		; update pointer
0259+  0984 0A B0 09    	jmp get_token_return
0260+  0987             get_token_end:				; end of file token
0261+  0987 19 14       	mov al, TOK_END
0262+  0989 3D 25 0A    	mov [tok], al
0263+  098C 19 06       	mov al, TOKTYP_END
0264+  098E 3D 24 0A    	mov [toktyp], al
0265+  0991 0A B0 09    	jmp get_token_return
0266+  0994             is_alphanumeric:
0267+  0994 F7          	stosb
0268+  0995 F6          	lodsb
0269+  0996 07 26 0B    	call isalnum			;check if is alphanumeric
0270+  0999 C6 94 09    	jz is_alphanumeric
0271+  099C B9 2E       	cmp al, $2E				; check if is '.'
0272+  099E C6 94 09    	je is_alphanumeric
0273+  09A1 19 00       	mov al, 0
0274+  09A3 F7          	stosb
0275+  09A4 19 00       	mov al, TOKTYP_IDENTIFIER
0276+  09A6 3D 24 0A    	mov [toktyp], al
0277+  09A9 D5 01 00    	sub si, 1
0278+  09AC 4E          	mov a, si
0279+  09AD 42 22 0A    	mov [prog], a		; update pointer
0280+  09B0             get_token_return:
0281+  09B0 F0          	pop di
0282+  09B1 EF          	pop si
0283+  09B2 E7          	pop d
0284+  09B3 E4          	pop a
0285+  09B4 09          	ret
0286+  09B5             get_tok_comment:
0287+  09B5 F6          	lodsb
0288+  09B6 B9 0A       	cmp al, $0A			; new line
0289+  09B8 C7 B5 09    	jne get_tok_comment
0290+  09BB 0A 99 08    	jmp get_tok_skip_spaces
0291+  09BE             
0292+  09BE             
0293+  09BE             get_number:
0294+  09BE D7          	push a
0295+  09BF DA          	push d
0296+  09C0 E2          	push si
0297+  09C1 E3          	push di
0298+  09C2 19 00       	mov al, 0
0299+  09C4 3D 26 0A    	mov [tokstr], al			; nullify tokstr string
0300+  09C7 19 00       	mov al, TOK_NULL
0301+  09C9 3D 25 0A    	mov [tok], al				; nullify token
0302+  09CC 14 22 0A    	mov a, [prog]
0303+  09CF 4D          	mov si, a
0304+  09D0 FD 4F 26 0A 	mov di, tokstr
0305+  09D4             get_number_skip_spaces:
0306+  09D4 F6          	lodsb
0307+  09D5 07 9C 0B    	call isspace
0308+  09D8 C6 D4 09    	je get_number_skip_spaces
0309+  09DB B9 00       	cmp al, 0			; check for end of input (NULL)
0310+  09DD C7 ED 09    	jne get_number_L0
0311+  09E0 19 14       	mov al, TOK_END
0312+  09E2 3D 25 0A    	mov [tok], al
0313+  09E5 19 06       	mov al, TOKTYP_END
0314+  09E7 3D 24 0A    	mov [toktyp], al
0315+  09EA 0A 04 0A    	jmp get_number_return
0316+  09ED             get_number_L0:
0317+  09ED F7          	stosb
0318+  09EE F6          	lodsb
0319+  09EF 07 30 0B    	call isdigit			;check if is numeric
0320+  09F2 C6 ED 09    	jz get_number_L0
0321+  09F5 19 00       	mov al, 0
0322+  09F7 F7          	stosb
0323+  09F8 19 05       	mov al, TOKTYP_NUMERIC
0324+  09FA 3D 24 0A    	mov [toktyp], al
0325+  09FD D5 01 00    	sub si, 1
0326+  0A00 4E          	mov a, si
0327+  0A01 42 22 0A    	mov [prog], a		; update pointer
0328+  0A04             get_number_return:
0329+  0A04 F0          	pop di
0330+  0A05 EF          	pop si
0331+  0A06 E7          	pop d
0332+  0A07 E4          	pop a
0333+  0A08 09          	ret
0334+  0A09             
0335+  0A09             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  0A09             ;; PUT BACK TOKEN
0337+  0A09             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
0338+  0A09             putback:
0339+  0A09 D7          	push a
0340+  0A0A E2          	push si
0341+  0A0B FD 4D 26 0A 	mov si, tokstr	
0342+  0A0F             putback_loop:
0343+  0A0F F6          	lodsb
0344+  0A10 B9 00       	cmp al, 0
0345+  0A12 C6 1F 0A    	je putback_end
0346+  0A15 14 22 0A    	mov a, [prog]
0347+  0A18 7D          	dec a
0348+  0A19 42 22 0A    	mov [prog], a			; update pointer
0349+  0A1C 0A 0F 0A    	jmp putback_loop
0350+  0A1F             putback_end:
0351+  0A1F EF          	pop si
0352+  0A20 E4          	pop a
0353+  0A21 09          	ret
0354+  0A22             
0355+  0A22             
0356+  0A22             
0357+  0A22             
0358+  0A22 00 00       prog:		.dw 0			; pointer to current position in buffer
0359+  0A24             
0360+  0A24 00          toktyp: 	.db 0			; token type symbol
0361+  0A25 00          tok:		.db 0			; current token symbol
0362+  0A26 00 00 00 00 tokstr:		.fill 256, 0	; token as a string
0362+  0A2A 00 00 00 00 
0362+  0A2E 00 00 00 00 
0362+  0A32 00 00 00 00 
0362+  0A36 00 00 00 00 
0362+  0A3A 00 00 00 00 
0362+  0A3E 00 00 00 00 
0362+  0A42 00 00 00 00 
0362+  0A46 00 00 00 00 
0362+  0A4A 00 00 00 00 
0362+  0A4E 00 00 00 00 
0362+  0A52 00 00 00 00 
0362+  0A56 00 00 00 00 
0362+  0A5A 00 00 00 00 
0362+  0A5E 00 00 00 00 
0362+  0A62 00 00 00 00 
0362+  0A66 00 00 00 00 
0362+  0A6A 00 00 00 00 
0362+  0A6E 00 00 00 00 
0362+  0A72 00 00 00 00 
0362+  0A76 00 00 00 00 
0362+  0A7A 00 00 00 00 
0362+  0A7E 00 00 00 00 
0362+  0A82 00 00 00 00 
0362+  0A86 00 00 00 00 
0362+  0A8A 00 00 00 00 
0362+  0A8E 00 00 00 00 
0362+  0A92 00 00 00 00 
0362+  0A96 00 00 00 00 
0362+  0A9A 00 00 00 00 
0362+  0A9E 00 00 00 00 
0362+  0AA2 00 00 00 00 
0362+  0AA6 00 00 00 00 
0362+  0AAA 00 00 00 00 
0362+  0AAE 00 00 00 00 
0362+  0AB2 00 00 00 00 
0362+  0AB6 00 00 00 00 
0362+  0ABA 00 00 00 00 
0362+  0ABE 00 00 00 00 
0362+  0AC2 00 00 00 00 
0362+  0AC6 00 00 00 00 
0362+  0ACA 00 00 00 00 
0362+  0ACE 00 00 00 00 
0362+  0AD2 00 00 00 00 
0362+  0AD6 00 00 00 00 
0362+  0ADA 00 00 00 00 
0362+  0ADE 00 00 00 00 
0362+  0AE2 00 00 00 00 
0362+  0AE6 00 00 00 00 
0362+  0AEA 00 00 00 00 
0362+  0AEE 00 00 00 00 
0362+  0AF2 00 00 00 00 
0362+  0AF6 00 00 00 00 
0362+  0AFA 00 00 00 00 
0362+  0AFE 00 00 00 00 
0362+  0B02 00 00 00 00 
0362+  0B06 00 00 00 00 
0362+  0B0A 00 00 00 00 
0362+  0B0E 00 00 00 00 
0362+  0B12 00 00 00 00 
0362+  0B16 00 00 00 00 
0362+  0B1A 00 00 00 00 
0362+  0B1E 00 00 00 00 
0362+  0B22 00 00 00 00 
0074   0B26             .include "ctype.asm"
0001+  0B26             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0B26             ; ctype.s
0003+  0B26             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0B26             
0005+  0B26             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  0B26             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  0B26             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  0B26             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  0B26             ;; characters are supported.
0010+  0B26             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  0B26             ;; isalnum 
0012+  0B26             ;; isalpha 
0013+  0B26             ;; islower 
0014+  0B26             ;; isupper 
0015+  0B26             ;; isdigit 
0016+  0B26             ;; isxdigit
0017+  0B26             ;; iscntrl 
0018+  0B26             ;; isgraph 
0019+  0B26             ;; isspace 
0020+  0B26             ;; isblank 
0021+  0B26             ;; isprint 
0022+  0B26             ;; ispunct 
0023+  0B26             ;; tolower 
0024+  0B26             ;; toupper
0025+  0B26             
0026+  0B26             
0027+  0B26             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  0B26             ;; IS ALPHANUMERIC
0029+  0B26             ;; sets ZF according with result
0030+  0B26             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  0B26             isalnum:
0032+  0B26 07 43 0B    	call isalpha
0033+  0B29 C6 2F 0B    	je isalnum_exit
0034+  0B2C 07 30 0B    	call isdigit
0035+  0B2F             isalnum_exit:
0036+  0B2F 09          	ret	
0037+  0B30             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0B30             ;; IS DIGIT
0039+  0B30             ;; sets ZF according with result
0040+  0B30             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  0B30             isdigit:
0042+  0B30 DB          	push al
0043+  0B31 B9 30       	cmp al, '0'
0044+  0B33 C8 3F 0B    	jlu isdigit_false
0045+  0B36 B9 39       	cmp al, '9'
0046+  0B38 D1 3F 0B    	jgu isdigit_false
0047+  0B3B 87 00       	and al, 0	; set ZF
0048+  0B3D E8          	pop al
0049+  0B3E 09          	ret
0050+  0B3F             isdigit_false:
0051+  0B3F 8B 01       	or al, 1	; clear ZF
0052+  0B41 E8          	pop al
0053+  0B42 09          	ret	
0054+  0B43             	
0055+  0B43             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  0B43             ;; IS ALPHA
0057+  0B43             ;; sets ZF according with result
0058+  0B43             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  0B43             isalpha:
0060+  0B43 DB          	push al
0061+  0B44 B9 5F       	cmp al, '_'
0062+  0B46 C6 66 0B    	je isalpha_true
0063+  0B49 B9 2E       	cmp al, '.'
0064+  0B4B C6 66 0B    	je isalpha_true
0065+  0B4E B9 41       	cmp al, 'A'
0066+  0B50 C8 62 0B    	jlu isalpha_false
0067+  0B53 B9 7A       	cmp al, 'z'
0068+  0B55 D1 62 0B    	jgu isalpha_false
0069+  0B58 B9 5A       	cmp al, 'Z'
0070+  0B5A D0 66 0B    	jleu isalpha_true
0071+  0B5D B9 61       	cmp al, 'a'
0072+  0B5F C9 66 0B    	jgeu isalpha_true
0073+  0B62             isalpha_false:
0074+  0B62 8B 01       	or al, 1	; clear ZF
0075+  0B64 E8          	pop al
0076+  0B65 09          	ret
0077+  0B66             isalpha_true:
0078+  0B66 87 00       	and al, 0	; set ZF
0079+  0B68 E8          	pop al
0080+  0B69 09          	ret
0081+  0B6A             
0082+  0B6A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  0B6A             ;; IS PATH-ALPHA
0084+  0B6A             ;; sets ZF according with result
0085+  0B6A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  0B6A             ispath:
0087+  0B6A DB          	push al
0088+  0B6B 07 30 0B    	call isdigit
0089+  0B6E C6 98 0B    	je ispath_true
0090+  0B71 B9 5F       	cmp al, '_'
0091+  0B73 C6 98 0B    	je ispath_true
0092+  0B76 B9 2F       	cmp al, '/'
0093+  0B78 C6 98 0B    	je ispath_true
0094+  0B7B B9 2E       	cmp al, '.'
0095+  0B7D C6 98 0B    	je ispath_true
0096+  0B80 B9 41       	cmp al, 'A'
0097+  0B82 C8 94 0B    	jlu ispath_false
0098+  0B85 B9 7A       	cmp al, 'z'
0099+  0B87 D1 94 0B    	jgu ispath_false
0100+  0B8A B9 5A       	cmp al, 'Z'
0101+  0B8C D0 98 0B    	jleu ispath_true
0102+  0B8F B9 61       	cmp al, 'a'
0103+  0B91 C9 98 0B    	jgeu ispath_true
0104+  0B94             ispath_false:
0105+  0B94 8B 01       	or al, 1	; clear ZF
0106+  0B96 E8          	pop al
0107+  0B97 09          	ret
0108+  0B98             ispath_true:
0109+  0B98 87 00       	and al, 0	; set ZF
0110+  0B9A E8          	pop al
0111+  0B9B 09          	ret
0112+  0B9C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  0B9C             ;; IS SPACE
0114+  0B9C             ;; sets ZF according with result
0115+  0B9C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  0B9C             isspace:
0117+  0B9C B9 20       	cmp al, $20		; ' '
0118+  0B9E C6 B2 0B    	je isspace_exit
0119+  0BA1 B9 09       	cmp al, $09		; '\t'
0120+  0BA3 C6 B2 0B    	je isspace_exit
0121+  0BA6 B9 0A       	cmp al, $0A		; '\n'
0122+  0BA8 C6 B2 0B    	je isspace_exit
0123+  0BAB B9 0D       	cmp al, $0D		; '\r'
0124+  0BAD C6 B2 0B    	je isspace_exit
0125+  0BB0 B9 0B       	cmp al, $0B		; '\v'
0126+  0BB2             isspace_exit:
0127+  0BB2 09          	ret	
0128+  0BB3             
0129+  0BB3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0BB3             ; TO LOWER
0131+  0BB3             ; input in AL
0132+  0BB3             ; output in AL
0133+  0BB3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  0BB3             to_lower:
0135+  0BB3 B9 5A       	cmp al, 'Z'
0136+  0BB5 D1 BA 0B    	jgu to_lower_ret
0137+  0BB8 6A 20       	add al, $20				; convert to lower case
0138+  0BBA             to_lower_ret:
0139+  0BBA 09          	ret
0140+  0BBB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  0BBB             ; TO UPPER
0142+  0BBB             ; input in AL
0143+  0BBB             ; output in AL
0144+  0BBB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  0BBB             to_upper:
0146+  0BBB B9 61       	cmp al, 'a'
0147+  0BBD C8 C2 0B    	jlu to_upper_ret
0148+  0BC0 6F 20       	sub al, $20			; convert to upper case
0149+  0BC2             to_upper_ret:
0150+  0BC2 09          	ret
0151+  0BC3             
0075   0BC3             
0076   0BC3 55 73 61 67 s_usage:	.db "Usage: primes [min] [max]\n", 0
0076   0BC7 65 3A 20 70 
0076   0BCB 72 69 6D 65 
0076   0BCF 73 20 5B 6D 
0076   0BD3 69 6E 5D 20 
0076   0BD7 5B 6D 61 78 
0076   0BDB 5D 0A 00 
0077   0BDE 00 00       total:		.dw 0
0078   0BE0 E8 03       max:		.dw 1000
0079   0BE2 05 00       min:		.dw 5
0080   0BE4             
0081   0BE4 0D 55 70 70 s_max:		.db "\rUpper bound: ", 0
0081   0BE8 65 72 20 62 
0081   0BEC 6F 75 6E 64 
0081   0BF0 3A 20 00 
0082   0BF3 2C 20 54 6F s_total:	.db ", Total primes: ", 0
0082   0BF7 74 61 6C 20 
0082   0BFB 70 72 69 6D 
0082   0BFF 65 73 3A 20 
0082   0C03 00 
0083   0C04             			
0084   0C04             .end
tasm: Number of errors = 0
