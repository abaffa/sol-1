0001   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002   0000             ; ADVENTURE
0003   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004   0000             
0005   0000             .include "kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0006   0000             
0007   0400             .org PROC_TEXT_ORG			; origin at 1024
0008   0400             
0009   0400             adventure:
0010   0400 3B 54 06    	mov d, s_telnet_clear
0011   0403 07 BB 0D    	call puts
0012   0406 3B 5C 06    	mov d, s_adv_instr
0013   0409 07 BB 0D    	call puts
0014   040C             
0015   040C             adv_start:
0016   040C 07 68 0D    	call printnl
0017   040F 19 00       	mov al, 0
0018   0411 3D AB 04    	mov [player_location], al		; reset position
0019   0414 3B C1 06    	mov d, s_adv_0
0020   0417 07 68 0D    	call printnl
0021   041A 07 BB 0D    	call puts
0022   041D 07 68 0D    	call printnl
0023   0420             
0024   0420             adv_loop:
0025   0420 3B AC 04    	mov d, player_command
0026   0423 07 8D 0C    	call gets			; get command
0027   0426             
0028   0426 1E          	mov al, [d]
0029   0427 23          	mov ah, al
0030   0428 07 88 0F    	call to_upper
0031   042B B9 51       	cmp al, 'Q'
0032   042D C6 A9 04    	je adv_ret			; quit game
0033   0430 B9 58       	cmp al, 'X'
0034   0432 C6 74 04    	je examine_command
0035   0435 07 24 06    	call adv_map_dir		; convert NESW to 0123 in AL
0036   0438 B9 04       	cmp al, 4
0037   043A C6 6B 04    	je unknown_command		; other keywords
0038   043D             move_command:
0039   043D 2F          	mov bl, al			; save converted movement value
0040   043E 1D AB 04    	mov al, [player_location]		; get current pos
0041   0441 3A 02       	mov cl, 2
0042   0443 9E          	shl al, cl			; multiply pos by 4, for table conversion
0043   0444 6B          	add al, bl			; get new position table index
0044   0445 22 00       	mov ah, 0
0045   0447 53 FC 05    	add a, adv_pos_table
0046   044A 3C          	mov d, a
0047   044B 1E          	mov al, [d]
0048   044C 3D AB 04    	mov [player_location], al		; save new position
0049   044F 07 55 04    	call print_location_description
0050   0452 0A 20 04    	jmp adv_loop			; back to main loop
0051   0455             
0052   0455             print_location_description:
0053   0455 1D AB 04    	mov al, [player_location]		; get position
0054   0458 22 00       	mov ah, 0
0055   045A 3A 01       	mov cl, 1
0056   045C 9D          	shl a, cl			; times 2
0057   045D B7 40 06    	mov a, [a + adv_text_table]	; get text description for new position
0058   0460 3C          	mov d, a
0059   0461 07 68 0D    	call printnl
0060   0464 07 BB 0D    	call puts
0061   0467 07 68 0D    	call printnl
0062   046A 09          	ret
0063   046B             
0064   046B             unknown_command:
0065   046B 3B 23 0B    	mov d, s_unknown_command
0066   046E 07 BB 0D    	call puts
0067   0471 0A 20 04    	jmp adv_loop
0068   0474             
0069   0474             examine_command:
0070   0474 3B 5B 0B    	mov d, s_items_here
0071   0477 07 BB 0D    	call puts
0072   047A 3B AC 05    	mov d, item_list
0073   047D             examine_command_L0:
0074   047D 16 01 00    	mov a, [d + 1]
0075   0480 AF 00 00    	cmp a, 0
0076   0483 C6 A6 04    	je examine_command_end
0077   0486 1E          	mov al, [d]
0078   0487 31 AB 04    	mov bl, [player_location]
0079   048A BA          	cmp al, bl
0080   048B C6 94 04    	je examine_command_item_here
0081   048E 58 04 00    	add d, 4
0082   0491 0A 7D 04    	jmp examine_command_L0
0083   0494             examine_command_item_here:
0084   0494 DA          	push d
0085   0495 16 01 00    	mov a, [d+1]	; get pointer
0086   0498 3C          	mov d, a
0087   0499 07 BB 0D    	call puts
0088   049C E7          	pop d
0089   049D 58 04 00    	add d, 4
0090   04A0 07 68 0D    	call printnl
0091   04A3 0A 7D 04    	jmp examine_command_L0
0092   04A6             examine_command_end:
0093   04A6 0A 20 04    	jmp adv_loop
0094   04A9             
0095   04A9             adv_ret:
0096   04A9 05 0B       	syscall sys_terminate_proc			; return to shell
0097   04AB             
0098   04AB 00          player_location:	.db 0
0099   04AC 00 00 00 00 player_command:		.fill 256, 0
0099   04B0 00 00 00 00 
0099   04B4 00 00 00 00 
0099   04B8 00 00 00 00 
0099   04BC 00 00 00 00 
0099   04C0 00 00 00 00 
0099   04C4 00 00 00 00 
0099   04C8 00 00 00 00 
0099   04CC 00 00 00 00 
0099   04D0 00 00 00 00 
0099   04D4 00 00 00 00 
0099   04D8 00 00 00 00 
0099   04DC 00 00 00 00 
0099   04E0 00 00 00 00 
0099   04E4 00 00 00 00 
0099   04E8 00 00 00 00 
0099   04EC 00 00 00 00 
0099   04F0 00 00 00 00 
0099   04F4 00 00 00 00 
0099   04F8 00 00 00 00 
0099   04FC 00 00 00 00 
0099   0500 00 00 00 00 
0099   0504 00 00 00 00 
0099   0508 00 00 00 00 
0099   050C 00 00 00 00 
0099   0510 00 00 00 00 
0099   0514 00 00 00 00 
0099   0518 00 00 00 00 
0099   051C 00 00 00 00 
0099   0520 00 00 00 00 
0099   0524 00 00 00 00 
0099   0528 00 00 00 00 
0099   052C 00 00 00 00 
0099   0530 00 00 00 00 
0099   0534 00 00 00 00 
0099   0538 00 00 00 00 
0099   053C 00 00 00 00 
0099   0540 00 00 00 00 
0099   0544 00 00 00 00 
0099   0548 00 00 00 00 
0099   054C 00 00 00 00 
0099   0550 00 00 00 00 
0099   0554 00 00 00 00 
0099   0558 00 00 00 00 
0099   055C 00 00 00 00 
0099   0560 00 00 00 00 
0099   0564 00 00 00 00 
0099   0568 00 00 00 00 
0099   056C 00 00 00 00 
0099   0570 00 00 00 00 
0099   0574 00 00 00 00 
0099   0578 00 00 00 00 
0099   057C 00 00 00 00 
0099   0580 00 00 00 00 
0099   0584 00 00 00 00 
0099   0588 00 00 00 00 
0099   058C 00 00 00 00 
0099   0590 00 00 00 00 
0099   0594 00 00 00 00 
0099   0598 00 00 00 00 
0099   059C 00 00 00 00 
0099   05A0 00 00 00 00 
0099   05A4 00 00 00 00 
0099   05A8 00 00 00 00 
0100   05AC             
0101   05AC             
0102   05AC             ; location(1), 255 = with player
0103   05AC             ; pointer to item name (2)
0104   05AC             ; flags(1)
0105   05AC             ;
0106   05AC             item_list:
0107   05AC 00          	.db 0
0108   05AD C0 05       	.dw item0
0109   05AF 00          	.db 0
0110   05B0 00          	.db 0
0111   05B1 D5 05       	.dw item1
0112   05B3 00          	.db 0
0113   05B4 01          	.db 1
0114   05B5 E1 05       	.dw item2
0115   05B7 00          	.db 0
0116   05B8 01          	.db 1
0117   05B9 F1 05       	.dw item3
0118   05BB 00          	.db 0
0119   05BC             ; end of list
0120   05BC 00          	.db 0
0121   05BD 00 00       	.dw 0
0122   05BF 00          	.db 0
0123   05C0             	
0124   05C0             item_names:	
0125   05C0 61 6E 20 6F item0:	.db "an old brass lantern", 0
0125   05C4 6C 64 20 62 
0125   05C8 72 61 73 73 
0125   05CC 20 6C 61 6E 
0125   05D0 74 65 72 6E 
0125   05D4 00 
0126   05D5 61 20 73 6D item1:	.db "a small key", 0
0126   05D9 61 6C 6C 20 
0126   05DD 6B 65 79 00 
0127   05E1 61 6E 20 65 item2:	.db "an empty bottle", 0
0127   05E5 6D 70 74 79 
0127   05E9 20 62 6F 74 
0127   05ED 74 6C 65 00 
0128   05F1 61 6E 20 6F item3:	.db "an old axe", 0
0128   05F5 6C 64 20 61 
0128   05F9 78 65 00 
0129   05FC             
0130   05FC             adv_pos_table:
0131   05FC             	; pos 0, beginning
0132   05FC 01          	.db 1			; N
0133   05FD 02          	.db 2			; E
0134   05FE 03          	.db 3			; S
0135   05FF 04          	.db 4			; W
0136   0600             	; pos 1
0137   0600 06          	.db 6			
0138   0601 01          	.db 1			
0139   0602 00          	.db 0			
0140   0603 01          	.db 1	
0141   0604             	; pos 2
0142   0604 02          	.db 2
0143   0605 02          	.db 2
0144   0606 03          	.db 3
0145   0607 00          	.db 0	
0146   0608             	; pos 3
0147   0608 00          	.db 0
0148   0609 02          	.db 2
0149   060A 03          	.db 3
0150   060B 04          	.db 4
0151   060C             	; pos 4
0152   060C 05          	.db 5
0153   060D 00          	.db 0
0154   060E 03          	.db 3
0155   060F 04          	.db 4
0156   0610             	; pos 5
0157   0610 05          	.db 5
0158   0611 05          	.db 5
0159   0612 04          	.db 4
0160   0613 05          	.db 5
0161   0614             	; pos 6
0162   0614 07          	.db 7
0163   0615 06          	.db 6
0164   0616 01          	.db 1
0165   0617 06          	.db 6
0166   0618             	; pos 7
0167   0618 08          	.db 8
0168   0619 07          	.db 7
0169   061A 06          	.db 6
0170   061B 07          	.db 7
0171   061C             	; pos 8
0172   061C 09          	.db 9
0173   061D 08          	.db 8
0174   061E 07          	.db 7
0175   061F 08          	.db 8
0176   0620             	; pos 9
0177   0620 09          	.db 9
0178   0621 09          	.db 9
0179   0622 08          	.db 8
0180   0623 09          	.db 9
0181   0624             
0182   0624             
0183   0624             ; dir char in AL
0184   0624             ; output in AL
0185   0624             adv_map_dir:
0186   0624 23          	mov ah, al
0187   0625 19 00       	mov al, 0
0188   0627 76 4E       	cmp ah, 'N'
0189   0629 C6 3F 06    	je dir_ret
0190   062C 7A          	inc al
0191   062D 76 45       	cmp ah, 'E'
0192   062F C6 3F 06    	je dir_ret
0193   0632 7A          	inc al
0194   0633 76 53       	cmp ah, 'S'
0195   0635 C6 3F 06    	je dir_ret
0196   0638 7A          	inc al
0197   0639 76 57       	cmp ah, 'W'
0198   063B C6 3F 06    	je dir_ret
0199   063E 7A          	inc al			
0200   063F             dir_ret:
0201   063F 09          	ret
0202   0640             	
0203   0640             	
0204   0640             adv_text_table:
0205   0640 C1 06       	.dw s_adv_0
0206   0642 D1 07       	.dw s_adv_1
0207   0644 11 08       	.dw s_adv_2
0208   0646 C4 08       	.dw s_adv_3
0209   0648 FD 08       	.dw s_adv_4
0210   064A 19 09       	.dw s_adv_5
0211   064C 6A 09       	.dw s_adv_6
0212   064E B7 09       	.dw s_adv_7
0213   0650 F7 09       	.dw s_adv_8
0214   0652 9E 0A       	.dw s_adv_9	
0215   0654             	
0216   0654             
0217   0654 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0217   0658 1B 5B 48 00 
0218   065C             
0219   065C 49 4E 53 54 s_adv_instr:	.db "INSTRUCTIONS:\n"
0219   0660 52 55 43 54 
0219   0664 49 4F 4E 53 
0219   0668 3A 0A 
0220   066A 6E 3A 20 67 				.db "n: go north\n"
0220   066E 6F 20 6E 6F 
0220   0672 72 74 68 0A 
0221   0676 73 3A 20 67 				.db "s: go south\n"
0221   067A 6F 20 73 6F 
0221   067E 75 74 68 0A 
0222   0682 77 3A 20 67 				.db "w: go west\n"
0222   0686 6F 20 77 65 
0222   068A 73 74 0A 
0223   068D 65 3A 20 67 				.db "e: go east\n"
0223   0691 6F 20 65 61 
0223   0695 73 74 0A 
0224   0698 78 3A 20 65 				.db "x: examine location\n"
0224   069C 78 61 6D 69 
0224   06A0 6E 65 20 6C 
0224   06A4 6F 63 61 74 
0224   06A8 69 6F 6E 0A 
0225   06AC 74 3A 20 74 				.db "t: take item\n"
0225   06B0 61 6B 65 20 
0225   06B4 69 74 65 6D 
0225   06B8 0A 
0226   06B9 71 3A 20 71 				.db "q: quit", 0
0226   06BD 75 69 74 00 
0227   06C1             
0228   06C1             s_adv_0:
0229   06C1 49 74 20 69 	.db "It is around 9am, and you find yourself in a forest.\n"
0229   06C5 73 20 61 72 
0229   06C9 6F 75 6E 64 
0229   06CD 20 39 61 6D 
0229   06D1 2C 20 61 6E 
0229   06D5 64 20 79 6F 
0229   06D9 75 20 66 69 
0229   06DD 6E 64 20 79 
0229   06E1 6F 75 72 73 
0229   06E5 65 6C 66 20 
0229   06E9 69 6E 20 61 
0229   06ED 20 66 6F 72 
0229   06F1 65 73 74 2E 
0229   06F5 0A 
0230   06F6 54 68 65 72 	.db "There is an old wooden cabin north of you.\n"
0230   06FA 65 20 69 73 
0230   06FE 20 61 6E 20 
0230   0702 6F 6C 64 20 
0230   0706 77 6F 6F 64 
0230   070A 65 6E 20 63 
0230   070E 61 62 69 6E 
0230   0712 20 6E 6F 72 
0230   0716 74 68 20 6F 
0230   071A 66 20 79 6F 
0230   071E 75 2E 0A 
0231   0721 54 68 65 20 	.db "The cabin looks very old and seems abandoned. It has two windows and a door at the front.\n"
0231   0725 63 61 62 69 
0231   0729 6E 20 6C 6F 
0231   072D 6F 6B 73 20 
0231   0731 76 65 72 79 
0231   0735 20 6F 6C 64 
0231   0739 20 61 6E 64 
0231   073D 20 73 65 65 
0231   0741 6D 73 20 61 
0231   0745 62 61 6E 64 
0231   0749 6F 6E 65 64 
0231   074D 2E 20 49 74 
0231   0751 20 68 61 73 
0231   0755 20 74 77 6F 
0231   0759 20 77 69 6E 
0231   075D 64 6F 77 73 
0231   0761 20 61 6E 64 
0231   0765 20 61 20 64 
0231   0769 6F 6F 72 20 
0231   076D 61 74 20 74 
0231   0771 68 65 20 66 
0231   0775 72 6F 6E 74 
0231   0779 2E 0A 
0232   077B 59 6F 75 20 	.db "You can see through the windows and the sunlight illuminates the inside of the cabin.", 0
0232   077F 63 61 6E 20 
0232   0783 73 65 65 20 
0232   0787 74 68 72 6F 
0232   078B 75 67 68 20 
0232   078F 74 68 65 20 
0232   0793 77 69 6E 64 
0232   0797 6F 77 73 20 
0232   079B 61 6E 64 20 
0232   079F 74 68 65 20 
0232   07A3 73 75 6E 6C 
0232   07A7 69 67 68 74 
0232   07AB 20 69 6C 6C 
0232   07AF 75 6D 69 6E 
0232   07B3 61 74 65 73 
0232   07B7 20 74 68 65 
0232   07BB 20 69 6E 73 
0232   07BF 69 64 65 20 
0232   07C3 6F 66 20 74 
0232   07C7 68 65 20 63 
0232   07CB 61 62 69 6E 
0232   07CF 2E 00 
0233   07D1             
0234   07D1             s_adv_1:
0235   07D1 59 6F 75 20 	.db "You are at the entrance door to the cabin. The door is locked.\n", 0
0235   07D5 61 72 65 20 
0235   07D9 61 74 20 74 
0235   07DD 68 65 20 65 
0235   07E1 6E 74 72 61 
0235   07E5 6E 63 65 20 
0235   07E9 64 6F 6F 72 
0235   07ED 20 74 6F 20 
0235   07F1 74 68 65 20 
0235   07F5 63 61 62 69 
0235   07F9 6E 2E 20 54 
0235   07FD 68 65 20 64 
0235   0801 6F 6F 72 20 
0235   0805 69 73 20 6C 
0235   0809 6F 63 6B 65 
0235   080D 64 2E 0A 00 
0236   0811             
0237   0811             s_adv_2:
0238   0811 59 6F 75 20 	.db "You are in a clearing. Small trees encircle you. The grass is short and there are a few big rocks on the ground.\n"
0238   0815 61 72 65 20 
0238   0819 69 6E 20 61 
0238   081D 20 63 6C 65 
0238   0821 61 72 69 6E 
0238   0825 67 2E 20 53 
0238   0829 6D 61 6C 6C 
0238   082D 20 74 72 65 
0238   0831 65 73 20 65 
0238   0835 6E 63 69 72 
0238   0839 63 6C 65 20 
0238   083D 79 6F 75 2E 
0238   0841 20 54 68 65 
0238   0845 20 67 72 61 
0238   0849 73 73 20 69 
0238   084D 73 20 73 68 
0238   0851 6F 72 74 20 
0238   0855 61 6E 64 20 
0238   0859 74 68 65 72 
0238   085D 65 20 61 72 
0238   0861 65 20 61 20 
0238   0865 66 65 77 20 
0238   0869 62 69 67 20 
0238   086D 72 6F 63 6B 
0238   0871 73 20 6F 6E 
0238   0875 20 74 68 65 
0238   0879 20 67 72 6F 
0238   087D 75 6E 64 2E 
0238   0881 0A 
0239   0882 54 68 65 20 	.db "The sky is a deep blue with big white puffy clouds flying calmly.", 0
0239   0886 73 6B 79 20 
0239   088A 69 73 20 61 
0239   088E 20 64 65 65 
0239   0892 70 20 62 6C 
0239   0896 75 65 20 77 
0239   089A 69 74 68 20 
0239   089E 62 69 67 20 
0239   08A2 77 68 69 74 
0239   08A6 65 20 70 75 
0239   08AA 66 66 79 20 
0239   08AE 63 6C 6F 75 
0239   08B2 64 73 20 66 
0239   08B6 6C 79 69 6E 
0239   08BA 67 20 63 61 
0239   08BE 6C 6D 6C 79 
0239   08C2 2E 00 
0240   08C4             
0241   08C4             s_adv_3:
0242   08C4 59 6F 75 20 	.db "You are in a deep forest. Big trees block the way south.", 0
0242   08C8 61 72 65 20 
0242   08CC 69 6E 20 61 
0242   08D0 20 64 65 65 
0242   08D4 70 20 66 6F 
0242   08D8 72 65 73 74 
0242   08DC 2E 20 42 69 
0242   08E0 67 20 74 72 
0242   08E4 65 65 73 20 
0242   08E8 62 6C 6F 63 
0242   08EC 6B 20 74 68 
0242   08F0 65 20 77 61 
0242   08F4 79 20 73 6F 
0242   08F8 75 74 68 2E 
0242   08FC 00 
0243   08FD             
0244   08FD             s_adv_4:
0245   08FD 59 6F 75 20 	.db "You are on a rocky plateau.", 0
0245   0901 61 72 65 20 
0245   0905 6F 6E 20 61 
0245   0909 20 72 6F 63 
0245   090D 6B 79 20 70 
0245   0911 6C 61 74 65 
0245   0915 61 75 2E 00 
0246   0919             
0247   0919             s_adv_5:
0248   0919 59 6F 75 20 	.db "You are at the top of the plateau. Looking down the mountain you see a big lake.", 0
0248   091D 61 72 65 20 
0248   0921 61 74 20 74 
0248   0925 68 65 20 74 
0248   0929 6F 70 20 6F 
0248   092D 66 20 74 68 
0248   0931 65 20 70 6C 
0248   0935 61 74 65 61 
0248   0939 75 2E 20 4C 
0248   093D 6F 6F 6B 69 
0248   0941 6E 67 20 64 
0248   0945 6F 77 6E 20 
0248   0949 74 68 65 20 
0248   094D 6D 6F 75 6E 
0248   0951 74 61 69 6E 
0248   0955 20 79 6F 75 
0248   0959 20 73 65 65 
0248   095D 20 61 20 62 
0248   0961 69 67 20 6C 
0248   0965 61 6B 65 2E 
0248   0969 00 
0249   096A             
0250   096A             s_adv_6:
0251   096A 59 6F 75 20 	.db "You are north of the cabin. There is a path through the trees leading north.", 0
0251   096E 61 72 65 20 
0251   0972 6E 6F 72 74 
0251   0976 68 20 6F 66 
0251   097A 20 74 68 65 
0251   097E 20 63 61 62 
0251   0982 69 6E 2E 20 
0251   0986 54 68 65 72 
0251   098A 65 20 69 73 
0251   098E 20 61 20 70 
0251   0992 61 74 68 20 
0251   0996 74 68 72 6F 
0251   099A 75 67 68 20 
0251   099E 74 68 65 20 
0251   09A2 74 72 65 65 
0251   09A6 73 20 6C 65 
0251   09AA 61 64 69 6E 
0251   09AE 67 20 6E 6F 
0251   09B2 72 74 68 2E 
0251   09B6 00 
0252   09B7             
0253   09B7             s_adv_7:
0254   09B7 59 6F 75 20 	.db "You are in a forest path. There is a small stream north of you.", 0
0254   09BB 61 72 65 20 
0254   09BF 69 6E 20 61 
0254   09C3 20 66 6F 72 
0254   09C7 65 73 74 20 
0254   09CB 70 61 74 68 
0254   09CF 2E 20 54 68 
0254   09D3 65 72 65 20 
0254   09D7 69 73 20 61 
0254   09DB 20 73 6D 61 
0254   09DF 6C 6C 20 73 
0254   09E3 74 72 65 61 
0254   09E7 6D 20 6E 6F 
0254   09EB 72 74 68 20 
0254   09EF 6F 66 20 79 
0254   09F3 6F 75 2E 00 
0255   09F7             
0256   09F7             s_adv_8:
0257   09F7 59 6F 75 20 	.db "You are in a rocky floored water spring. "
0257   09FB 61 72 65 20 
0257   09FF 69 6E 20 61 
0257   0A03 20 72 6F 63 
0257   0A07 6B 79 20 66 
0257   0A0B 6C 6F 6F 72 
0257   0A0F 65 64 20 77 
0257   0A13 61 74 65 72 
0257   0A17 20 73 70 72 
0257   0A1B 69 6E 67 2E 
0257   0A1F 20 
0258   0A20 43 6C 65 61 	.db "Clear water flows out of a small spring amidst the rocks. "
0258   0A24 72 20 77 61 
0258   0A28 74 65 72 20 
0258   0A2C 66 6C 6F 77 
0258   0A30 73 20 6F 75 
0258   0A34 74 20 6F 66 
0258   0A38 20 61 20 73 
0258   0A3C 6D 61 6C 6C 
0258   0A40 20 73 70 72 
0258   0A44 69 6E 67 20 
0258   0A48 61 6D 69 64 
0258   0A4C 73 74 20 74 
0258   0A50 68 65 20 72 
0258   0A54 6F 63 6B 73 
0258   0A58 2E 20 
0259   0A5A 57 65 74 20 	.db "Wet and muddy grass encircles the spring. A bird is singing nearby.", 0
0259   0A5E 61 6E 64 20 
0259   0A62 6D 75 64 64 
0259   0A66 79 20 67 72 
0259   0A6A 61 73 73 20 
0259   0A6E 65 6E 63 69 
0259   0A72 72 63 6C 65 
0259   0A76 73 20 74 68 
0259   0A7A 65 20 73 70 
0259   0A7E 72 69 6E 67 
0259   0A82 2E 20 41 20 
0259   0A86 62 69 72 64 
0259   0A8A 20 69 73 20 
0259   0A8E 73 69 6E 67 
0259   0A92 69 6E 67 20 
0259   0A96 6E 65 61 72 
0259   0A9A 62 79 2E 00 
0260   0A9E             
0261   0A9E             s_adv_9:
0262   0A9E 59 6F 75 20 	.db "You are in a bog. The water reaches up to your knees.\n"
0262   0AA2 61 72 65 20 
0262   0AA6 69 6E 20 61 
0262   0AAA 20 62 6F 67 
0262   0AAE 2E 20 54 68 
0262   0AB2 65 20 77 61 
0262   0AB6 74 65 72 20 
0262   0ABA 72 65 61 63 
0262   0ABE 68 65 73 20 
0262   0AC2 75 70 20 74 
0262   0AC6 6F 20 79 6F 
0262   0ACA 75 72 20 6B 
0262   0ACE 6E 65 65 73 
0262   0AD2 2E 0A 
0263   0AD4 54 68 65 20 	.db "The ground feels like quick sand and it is difficult to move around.", 0
0263   0AD8 67 72 6F 75 
0263   0ADC 6E 64 20 66 
0263   0AE0 65 65 6C 73 
0263   0AE4 20 6C 69 6B 
0263   0AE8 65 20 71 75 
0263   0AEC 69 63 6B 20 
0263   0AF0 73 61 6E 64 
0263   0AF4 20 61 6E 64 
0263   0AF8 20 69 74 20 
0263   0AFC 69 73 20 64 
0263   0B00 69 66 66 69 
0263   0B04 63 75 6C 74 
0263   0B08 20 74 6F 20 
0263   0B0C 6D 6F 76 65 
0263   0B10 20 61 72 6F 
0263   0B14 75 6E 64 2E 
0263   0B18 00 
0264   0B19             
0265   0B19             s_adv_restart:
0266   0B19 52 65 73 74 	.db "Restart? ", 0
0266   0B1D 61 72 74 3F 
0266   0B21 20 00 
0267   0B23             	
0268   0B23             s_unknown_command:
0269   0B23 49 20 64 6F 	.db "I do not understand that word.\n", 0
0269   0B27 20 6E 6F 74 
0269   0B2B 20 75 6E 64 
0269   0B2F 65 72 73 74 
0269   0B33 61 6E 64 20 
0269   0B37 74 68 61 74 
0269   0B3B 20 77 6F 72 
0269   0B3F 64 2E 0A 00 
0270   0B43             	
0271   0B43             s_adv_exam:
0272   0B43 54 68 65 72 	.db "There is nothing here.\n", 0
0272   0B47 65 20 69 73 
0272   0B4B 20 6E 6F 74 
0272   0B4F 68 69 6E 67 
0272   0B53 20 68 65 72 
0272   0B57 65 2E 0A 00 
0273   0B5B             	
0274   0B5B             s_items_here:
0275   0B5B 49 74 65 6D 	.db "Items found at this location...\n", 0
0275   0B5F 73 20 66 6F 
0275   0B63 75 6E 64 20 
0275   0B67 61 74 20 74 
0275   0B6B 68 69 73 20 
0275   0B6F 6C 6F 63 61 
0275   0B73 74 69 6F 6E 
0275   0B77 2E 2E 2E 0A 
0275   0B7B 00 
0276   0B7C             
0277   0B7C             p_itemlist:
0278   0B7C             
0279   0B7C             
0280   0B7C             .include "stdio.asm"
0001+  0B7C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0B7C             ; stdio.s
0003+  0B7C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0B7C             .include "string.asm"
0001++ 0B7C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0B7C             ; string.s
0003++ 0B7C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0B7C             
0005++ 0B7C             
0006++ 0B7C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0B7C             ; strrev
0008++ 0B7C             ; reverse a string
0009++ 0B7C             ; D = string address
0010++ 0B7C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0B7C             ; 01234
0012++ 0B7C             strrev:
0013++ 0B7C 4B          	pusha
0014++ 0B7D 07 C3 0B    	call strlen	; length in C
0015++ 0B80 12          	mov a, c
0016++ 0B81 AF 01 00    	cmp a, 1
0017++ 0B84 D0 9E 0B    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0B87 7D          	dec a
0019++ 0B88 FD 4E       	mov si, d	; beginning of string
0020++ 0B8A FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0B8C 59          	add d, a	; end of string
0022++ 0B8D 12          	mov a, c
0023++ 0B8E FD 9B       	shr a		; divide by 2
0024++ 0B90 39          	mov c, a	; C now counts the steps
0025++ 0B91             strrev_L0:
0026++ 0B91 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0B92 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0B93 3E          	mov [d], al	; store left char into right side
0029++ 0B94 1B          	mov al, bl
0030++ 0B95 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0B96 7E          	dec c
0032++ 0B97 7F          	dec d
0033++ 0B98 C2 00 00    	cmp c, 0
0034++ 0B9B C7 91 0B    	jne strrev_L0
0035++ 0B9E             strrev_end:
0036++ 0B9E 4C          	popa
0037++ 0B9F 09          	ret
0038++ 0BA0             	
0039++ 0BA0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0BA0             ; strchr
0041++ 0BA0             ; search string in D for char in AL
0042++ 0BA0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0BA0             strchr:
0044++ 0BA0             strchr_L0:
0045++ 0BA0 32          	mov bl, [d]
0046++ 0BA1 C1 00       	cmp bl, 0
0047++ 0BA3 C6 AE 0B    	je strchr_end
0048++ 0BA6 BA          	cmp al, bl
0049++ 0BA7 C6 AE 0B    	je strchr_end
0050++ 0BAA 79          	inc d
0051++ 0BAB 0A A0 0B    	jmp strchr_L0
0052++ 0BAE             strchr_end:
0053++ 0BAE 1B          	mov al, bl
0054++ 0BAF 09          	ret
0055++ 0BB0             
0056++ 0BB0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0BB0             ; strstr
0058++ 0BB0             ; find sub-string
0059++ 0BB0             ; str1 in SI
0060++ 0BB0             ; str2 in DI
0061++ 0BB0             ; SI points to end of source string
0062++ 0BB0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0BB0             strstr:
0064++ 0BB0 DB          	push al
0065++ 0BB1 DA          	push d
0066++ 0BB2 E3          	push di
0067++ 0BB3             strstr_loop:
0068++ 0BB3 F3          	cmpsb					; compare a byte of the strings
0069++ 0BB4 C7 BF 0B    	jne strstr_ret
0070++ 0BB7 FC 00 00    	lea d, [di + 0]
0071++ 0BBA BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0BBC C7 B3 0B    	jne strstr_loop				; equal chars but not at end
0073++ 0BBF             strstr_ret:
0074++ 0BBF F0          	pop di
0075++ 0BC0 E7          	pop d
0076++ 0BC1 E8          	pop al
0077++ 0BC2 09          	ret
0078++ 0BC3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0BC3             ; length of null terminated string
0080++ 0BC3             ; result in C
0081++ 0BC3             ; pointer in D
0082++ 0BC3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0BC3             strlen:
0084++ 0BC3 DA          	push d
0085++ 0BC4 38 00 00    	mov c, 0
0086++ 0BC7             strlen_L1:
0087++ 0BC7 BD 00       	cmp byte [d], 0
0088++ 0BC9 C6 D1 0B    	je strlen_ret
0089++ 0BCC 79          	inc d
0090++ 0BCD 78          	inc c
0091++ 0BCE 0A C7 0B    	jmp strlen_L1
0092++ 0BD1             strlen_ret:
0093++ 0BD1 E7          	pop d
0094++ 0BD2 09          	ret
0095++ 0BD3             
0096++ 0BD3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0BD3             ; STRCMP
0098++ 0BD3             ; compare two strings
0099++ 0BD3             ; str1 in SI
0100++ 0BD3             ; str2 in DI
0101++ 0BD3             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0BD3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0BD3             strcmp:
0104++ 0BD3 DB          	push al
0105++ 0BD4 DA          	push d
0106++ 0BD5 E3          	push di
0107++ 0BD6 E2          	push si
0108++ 0BD7             strcmp_loop:
0109++ 0BD7 F3          	cmpsb					; compare a byte of the strings
0110++ 0BD8 C7 E3 0B    	jne strcmp_ret
0111++ 0BDB FB FF FF    	lea d, [si +- 1]
0112++ 0BDE BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0BE0 C7 D7 0B    	jne strcmp_loop				; equal chars but not at end
0114++ 0BE3             strcmp_ret:
0115++ 0BE3 EF          	pop si
0116++ 0BE4 F0          	pop di
0117++ 0BE5 E7          	pop d
0118++ 0BE6 E8          	pop al
0119++ 0BE7 09          	ret
0120++ 0BE8             
0121++ 0BE8             
0122++ 0BE8             ; STRCPY
0123++ 0BE8             ; copy null terminated string from SI to DI
0124++ 0BE8             ; source in SI
0125++ 0BE8             ; destination in DI
0126++ 0BE8             strcpy:
0127++ 0BE8 E2          	push si
0128++ 0BE9 E3          	push di
0129++ 0BEA DB          	push al
0130++ 0BEB             strcpy_L1:
0131++ 0BEB F6          	lodsb
0132++ 0BEC F7          	stosb
0133++ 0BED B9 00       	cmp al, 0
0134++ 0BEF C7 EB 0B    	jne strcpy_L1
0135++ 0BF2             strcpy_end:
0136++ 0BF2 E8          	pop al
0137++ 0BF3 F0          	pop di
0138++ 0BF4 EF          	pop si
0139++ 0BF5 09          	ret
0140++ 0BF6             
0141++ 0BF6             ; STRCAT
0142++ 0BF6             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0BF6             ; source in SI
0144++ 0BF6             ; destination in DI
0145++ 0BF6             strcat:
0146++ 0BF6 E2          	push si
0147++ 0BF7 E3          	push di
0148++ 0BF8 D7          	push a
0149++ 0BF9 DA          	push d
0150++ 0BFA 50          	mov a, di
0151++ 0BFB 3C          	mov d, a
0152++ 0BFC             strcat_goto_end_L1:
0153++ 0BFC BD 00       	cmp byte[d], 0
0154++ 0BFE C6 05 0C    	je strcat_start
0155++ 0C01 79          	inc d
0156++ 0C02 0A FC 0B    	jmp strcat_goto_end_L1
0157++ 0C05             strcat_start:
0158++ 0C05 FD 50       	mov di, d
0159++ 0C07             strcat_L1:
0160++ 0C07 F6          	lodsb
0161++ 0C08 F7          	stosb
0162++ 0C09 B9 00       	cmp al, 0
0163++ 0C0B C7 07 0C    	jne strcat_L1
0164++ 0C0E             strcat_end:
0165++ 0C0E E7          	pop d
0166++ 0C0F E4          	pop a
0167++ 0C10 F0          	pop di
0168++ 0C11 EF          	pop si
0169++ 0C12 09          	ret
0005+  0C13             
0006+  0C13 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  0C17 34 35 36 37 
0006+  0C1B 38 39 41 42 
0006+  0C1F 43 44 45 46 
0007+  0C23             
0008+  0C23 01 00       table_power:.dw 1
0009+  0C25 0A 00       			.dw 10
0010+  0C27 64 00       			.dw 100
0011+  0C29 E8 03       			.dw 1000
0012+  0C2B 10 27       			.dw 10000
0013+  0C2D             
0014+  0C2D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0015+  0C2D             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0016+  0C2D             ; ASCII in BL
0017+  0C2D             ; result in AL
0018+  0C2D             ; ascii for F = 0100 0110
0019+  0C2D             ; ascii for 9 = 0011 1001
0020+  0C2D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0021+  0C2D             hex_ascii_encode:
0022+  0C2D 1B          	mov al, bl
0023+  0C2E 93 40       	test al, $40				; test if letter or number
0024+  0C30 C7 36 0C    	jnz hex_letter
0025+  0C33 87 0F       	and al, $0F				; get number
0026+  0C35 09          	ret
0027+  0C36             hex_letter:
0028+  0C36 87 0F       	and al, $0F				; get letter
0029+  0C38 6A 09       	add al, 9
0030+  0C3A 09          	ret
0031+  0C3B             
0032+  0C3B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0033+  0C3B             ; ATOI
0034+  0C3B             ; 2 letter hex string in B
0035+  0C3B             ; 8bit integer returned in AL
0036+  0C3B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0037+  0C3B             atoi:
0038+  0C3B D8          	push b
0039+  0C3C 07 2D 0C    	call hex_ascii_encode			; convert BL to 4bit code in AL
0040+  0C3F 30          	mov bl, bh
0041+  0C40 DB          	push al					; save a
0042+  0C41 07 2D 0C    	call hex_ascii_encode
0043+  0C44 EA          	pop bl	
0044+  0C45 FD 9E 04    	shl al, 4
0045+  0C48 8C          	or al, bl
0046+  0C49 E5          	pop b
0047+  0C4A 09          	ret	
0048+  0C4B             
0049+  0C4B             
0050+  0C4B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  0C4B             ; printf
0052+  0C4B             ; no need for explanations!
0053+  0C4B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0054+  0C4B             printf:
0055+  0C4B 09          	ret
0056+  0C4C             
0057+  0C4C             
0058+  0C4C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  0C4C             ; scanf
0060+  0C4C             ; no need for explanations!
0061+  0C4C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  0C4C             scanf:
0063+  0C4C 09          	ret
0064+  0C4D             
0065+  0C4D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  0C4D             ; ITOA
0067+  0C4D             ; 8bit value in BL
0068+  0C4D             ; 2 byte ASCII result in A
0069+  0C4D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0070+  0C4D             itoa:
0071+  0C4D DA          	push d
0072+  0C4E D8          	push b
0073+  0C4F A7 00       	mov bh, 0
0074+  0C51 FD A4 04    	shr bl, 4	
0075+  0C54 74          	mov d, b
0076+  0C55 1F 13 0C    	mov al, [d + s_hex_digits]
0077+  0C58 23          	mov ah, al
0078+  0C59             	
0079+  0C59 E5          	pop b
0080+  0C5A D8          	push b
0081+  0C5B A7 00       	mov bh, 0
0082+  0C5D FD 87 0F    	and bl, $0F
0083+  0C60 74          	mov d, b
0084+  0C61 1F 13 0C    	mov al, [d + s_hex_digits]
0085+  0C64 E5          	pop b
0086+  0C65 E7          	pop d
0087+  0C66 09          	ret
0088+  0C67             
0089+  0C67             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0090+  0C67             ; HEX STRING TO BINARY
0091+  0C67             ; di = destination address
0092+  0C67             ; si = source
0093+  0C67             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0094+  0C67             hex_to_int:
0095+  0C67             hex_to_int_L1:
0096+  0C67 F6          	lodsb					; load from [SI] to AL
0097+  0C68 B9 00       	cmp al, 0				; check if ASCII 0
0098+  0C6A C6 77 0C    	jz hex_to_int_ret
0099+  0C6D 36          	mov bh, al
0100+  0C6E F6          	lodsb
0101+  0C6F 2F          	mov bl, al
0102+  0C70 07 3B 0C    	call atoi				; convert ASCII byte in B to int (to AL)
0103+  0C73 F7          	stosb					; store AL to [DI]
0104+  0C74 0A 67 0C    	jmp hex_to_int_L1
0105+  0C77             hex_to_int_ret:
0106+  0C77 09          	ret		
0107+  0C78             
0108+  0C78             
0109+  0C78             
0110+  0C78             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  0C78             ; GETCHAR
0112+  0C78             ; char in ah
0113+  0C78             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0114+  0C78             getchar:
0115+  0C78 DB          	push al
0116+  0C79             getchar_retry:
0117+  0C79 FD 0C       	sti
0118+  0C7B 19 01       	mov al, 1
0119+  0C7D 05 03       	syscall sys_io			; receive in AH
0120+  0C7F B9 00       	cmp al, 0			; check if any char was receive
0121+  0C81 C6 79 0C    	je getchar_retry
0122+  0C84 E8          	pop al
0123+  0C85 09          	ret
0124+  0C86             
0125+  0C86             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0126+  0C86             ; PUTCHAR
0127+  0C86             ; char in ah
0128+  0C86             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  0C86             putchar:
0130+  0C86 D7          	push a
0131+  0C87 19 00       	mov al, 0
0132+  0C89 05 03       	syscall sys_io			; char in AH
0133+  0C8B E4          	pop a
0134+  0C8C 09          	ret
0135+  0C8D             
0136+  0C8D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0137+  0C8D             ;; INPUT A STRING
0138+  0C8D             ;; terminates with null
0139+  0C8D             ;; pointer in D
0140+  0C8D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  0C8D             gets:
0142+  0C8D D7          	push a
0143+  0C8E DA          	push d
0144+  0C8F             gets_loop:
0145+  0C8F FD 0C       	sti
0146+  0C91 19 01       	mov al, 1
0147+  0C93 05 03       	syscall sys_io			; receive in AH
0148+  0C95 B9 00       	cmp al, 0				; check error code (AL)
0149+  0C97 C6 8F 0C    	je gets_loop			; if no char received, retry
0150+  0C9A             
0151+  0C9A 76 1B       	cmp ah, 27
0152+  0C9C C6 B8 0C    	je gets_telnet_escape
0153+  0C9F 76 0A       	cmp ah, $0A				; LF
0154+  0CA1 C6 11 0D    	je gets_end
0155+  0CA4 76 5C       	cmp ah, $5C				; '\\'
0156+  0CA6 C6 E8 0C    	je gets_escape
0157+  0CA9             	
0158+  0CA9 76 08       	cmp ah, $08			; check for backspace
0159+  0CAB C6 B4 0C    	je gets_backspace
0160+  0CAE             
0161+  0CAE 1A          	mov al, ah
0162+  0CAF 3E          	mov [d], al
0163+  0CB0 79          	inc d
0164+  0CB1 0A 8F 0C    	jmp gets_loop
0165+  0CB4             gets_backspace:
0166+  0CB4 7F          	dec d
0167+  0CB5 0A 8F 0C    	jmp gets_loop
0168+  0CB8             gets_telnet_escape:
0169+  0CB8 FD 0C       	sti
0170+  0CBA 19 01       	mov al, 1
0171+  0CBC 05 03       	syscall sys_io				; receive in AH without echo
0172+  0CBE B9 00       	cmp al, 0					; check error code (AL)
0173+  0CC0 C6 B8 0C    	je gets_telnet_escape		; if no char received, retry
0174+  0CC3 76 5B       	cmp ah, '['
0175+  0CC5 C7 8F 0C    	jne gets_loop
0176+  0CC8             gets_telnet_escape_phase2:
0177+  0CC8 FD 0C       	sti
0178+  0CCA 19 01       	mov al, 1
0179+  0CCC 05 03       	syscall sys_io					; receive in AH without echo
0180+  0CCE B9 00       	cmp al, 0						; check error code (AL)
0181+  0CD0 C6 C8 0C    	je gets_telnet_escape_phase2	; if no char received, retry
0182+  0CD3 76 44       	cmp ah, 'D'
0183+  0CD5 C6 E0 0C    	je gets_left_arrow
0184+  0CD8 76 43       	cmp ah, 'C'
0185+  0CDA C6 E4 0C    	je gets_right_arrow
0186+  0CDD 0A 8F 0C    	jmp gets_loop
0187+  0CE0             gets_left_arrow:
0188+  0CE0 7F          	dec d
0189+  0CE1 0A 8F 0C    	jmp gets_loop
0190+  0CE4             gets_right_arrow:
0191+  0CE4 79          	inc d
0192+  0CE5 0A 8F 0C    	jmp gets_loop
0193+  0CE8             gets_escape:
0194+  0CE8 FD 0C       	sti
0195+  0CEA 19 01       	mov al, 1
0196+  0CEC 05 03       	syscall sys_io			; receive in AH
0197+  0CEE B9 00       	cmp al, 0				; check error code (AL)
0198+  0CF0 C6 E8 0C    	je gets_escape			; if no char received, retry
0199+  0CF3 76 6E       	cmp ah, 'n'
0200+  0CF5 C6 03 0D    	je gets_LF
0201+  0CF8 76 72       	cmp ah, 'r'
0202+  0CFA C6 0A 0D    	je gets_CR
0203+  0CFD 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0204+  0CFE 3E          	mov [d], al
0205+  0CFF 79          	inc d
0206+  0D00 0A 8F 0C    	jmp gets_loop
0207+  0D03             gets_LF:
0208+  0D03 19 0A       	mov al, $0A
0209+  0D05 3E          	mov [d], al
0210+  0D06 79          	inc d
0211+  0D07 0A 8F 0C    	jmp gets_loop
0212+  0D0A             gets_CR:
0213+  0D0A 19 0D       	mov al, $0D
0214+  0D0C 3E          	mov [d], al
0215+  0D0D 79          	inc d
0216+  0D0E 0A 8F 0C    	jmp gets_loop
0217+  0D11             gets_end:
0218+  0D11 19 00       	mov al, 0
0219+  0D13 3E          	mov [d], al				; terminate string
0220+  0D14 E7          	pop d
0221+  0D15 E4          	pop a
0222+  0D16 09          	ret
0223+  0D17             
0224+  0D17             
0225+  0D17             
0226+  0D17             
0227+  0D17             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0228+  0D17             ;; INPUT TEXT
0229+  0D17             ;; terminated with CTRL+D
0230+  0D17             ;; pointer in D
0231+  0D17             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0232+  0D17             gettxt:
0233+  0D17 D7          	push a
0234+  0D18 DA          	push d
0235+  0D19             gettxt_loop:
0236+  0D19 19 01       	mov al, 1
0237+  0D1B 05 03       	syscall sys_io			; receive in AH
0238+  0D1D B9 00       	cmp al, 0				; check error code (AL)
0239+  0D1F C6 19 0D    	je gettxt_loop		; if no char received, retry
0240+  0D22 76 04       	cmp ah, 4			; EOT
0241+  0D24 C6 62 0D    	je gettxt_end
0242+  0D27 76 08       	cmp ah, $08			; check for backspace
0243+  0D29 C6 5E 0D    	je gettxt_backspace
0244+  0D2C 76 5C       	cmp ah, $5C				; '\\'
0245+  0D2E C6 37 0D    	je gettxt_escape
0246+  0D31 1A          	mov al, ah
0247+  0D32 3E          	mov [d], al
0248+  0D33 79          	inc d
0249+  0D34 0A 19 0D    	jmp gettxt_loop
0250+  0D37             gettxt_escape:
0251+  0D37 19 01       	mov al, 1
0252+  0D39 05 03       	syscall sys_io			; receive in AH
0253+  0D3B B9 00       	cmp al, 0				; check error code (AL)
0254+  0D3D C6 37 0D    	je gettxt_escape		; if no char received, retry
0255+  0D40 76 6E       	cmp ah, 'n'
0256+  0D42 C6 50 0D    	je gettxt_LF
0257+  0D45 76 72       	cmp ah, 'r'
0258+  0D47 C6 57 0D    	je gettxt_CR
0259+  0D4A 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0260+  0D4B 3E          	mov [d], al
0261+  0D4C 79          	inc d
0262+  0D4D 0A 19 0D    	jmp gettxt_loop
0263+  0D50             gettxt_LF:
0264+  0D50 19 0A       	mov al, $0A
0265+  0D52 3E          	mov [d], al
0266+  0D53 79          	inc d
0267+  0D54 0A 19 0D    	jmp gettxt_loop
0268+  0D57             gettxt_CR:
0269+  0D57 19 0D       	mov al, $0D
0270+  0D59 3E          	mov [d], al
0271+  0D5A 79          	inc d
0272+  0D5B 0A 19 0D    	jmp gettxt_loop
0273+  0D5E             gettxt_backspace:
0274+  0D5E 7F          	dec d
0275+  0D5F 0A 19 0D    	jmp gettxt_loop
0276+  0D62             gettxt_end:
0277+  0D62 19 00       	mov al, 0
0278+  0D64 3E          	mov [d], al				; terminate string
0279+  0D65 E7          	pop d
0280+  0D66 E4          	pop a
0281+  0D67 09          	ret
0282+  0D68             
0283+  0D68             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0284+  0D68             ; PRINT NEW LINE
0285+  0D68             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0286+  0D68             printnl:
0287+  0D68 D7          	push a
0288+  0D69 10 00 0A    	mov a, $0A00
0289+  0D6C 05 03       	syscall sys_io
0290+  0D6E 10 00 0D    	mov a, $0D00
0291+  0D71 05 03       	syscall sys_io
0292+  0D73 E4          	pop a
0293+  0D74 09          	ret
0294+  0D75             
0295+  0D75             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0296+  0D75             ; strtoint
0297+  0D75             ; 4 digit hex string number in d
0298+  0D75             ; integer returned in A
0299+  0D75             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0300+  0D75             strtointx:
0301+  0D75 D8          	push b
0302+  0D76 32          	mov bl, [d]
0303+  0D77 37          	mov bh, bl
0304+  0D78 33 01 00    	mov bl, [d + 1]
0305+  0D7B 07 3B 0C    	call atoi				; convert to int in AL
0306+  0D7E 23          	mov ah, al				; move to AH
0307+  0D7F 33 02 00    	mov bl, [d + 2]
0308+  0D82 37          	mov bh, bl
0309+  0D83 33 03 00    	mov bl, [d + 3]
0310+  0D86 07 3B 0C    	call atoi				; convert to int in AL
0311+  0D89 E5          	pop b
0312+  0D8A 09          	ret
0313+  0D8B             
0314+  0D8B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0315+  0D8B             ; strtoint
0316+  0D8B             ; 5 digit base10 string number in d
0317+  0D8B             ; integer returned in A
0318+  0D8B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0319+  0D8B             strtoint:
0320+  0D8B E2          	push si
0321+  0D8C D8          	push b
0322+  0D8D D9          	push c
0323+  0D8E DA          	push d
0324+  0D8F 07 C3 0B    	call strlen			; get string length in C
0325+  0D92 7E          	dec c
0326+  0D93 FD 4E       	mov si, d
0327+  0D95 12          	mov a, c
0328+  0D96 FD 99       	shl a
0329+  0D98 3B 23 0C    	mov d, table_power
0330+  0D9B 59          	add d, a
0331+  0D9C 38 00 00    	mov c, 0
0332+  0D9F             strtoint_L0:
0333+  0D9F F6          	lodsb			; load ASCII to al
0334+  0DA0 B9 00       	cmp al, 0
0335+  0DA2 C6 B5 0D    	je strtoint_end
0336+  0DA5 6F 30       	sub al, $30		; make into integer
0337+  0DA7 22 00       	mov ah, 0
0338+  0DA9 2A          	mov b, [d]
0339+  0DAA AC          	mul a, b			; result in B since it fits in 16bits
0340+  0DAB 11          	mov a, b
0341+  0DAC 28          	mov b, c
0342+  0DAD 54          	add a, b
0343+  0DAE 39          	mov c, a
0344+  0DAF 63 02 00    	sub d, 2
0345+  0DB2 0A 9F 0D    	jmp strtoint_L0
0346+  0DB5             strtoint_end:
0347+  0DB5 12          	mov a, c
0348+  0DB6 E7          	pop d
0349+  0DB7 E6          	pop c
0350+  0DB8 E5          	pop b
0351+  0DB9 EF          	pop si
0352+  0DBA 09          	ret
0353+  0DBB             
0354+  0DBB             
0355+  0DBB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  0DBB             ; PRINT NULL TERMINATED STRING
0357+  0DBB             ; pointer in D
0358+  0DBB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  0DBB             puts:
0360+  0DBB D7          	push a
0361+  0DBC DA          	push d
0362+  0DBD             puts_L1:
0363+  0DBD 1E          	mov al, [d]
0364+  0DBE B9 00       	cmp al, 0
0365+  0DC0 C6 CC 0D    	jz puts_END
0366+  0DC3 23          	mov ah, al
0367+  0DC4 19 00       	mov al, 0
0368+  0DC6 05 03       	syscall sys_io
0369+  0DC8 79          	inc d
0370+  0DC9 0A BD 0D    	jmp puts_L1
0371+  0DCC             puts_END:
0372+  0DCC E7          	pop d
0373+  0DCD E4          	pop a
0374+  0DCE 09          	ret
0375+  0DCF             
0376+  0DCF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0377+  0DCF             ; PRINT N SIZE STRING
0378+  0DCF             ; pointer in D
0379+  0DCF             ; size in C
0380+  0DCF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0381+  0DCF             putsn:
0382+  0DCF DB          	push al
0383+  0DD0 DA          	push d
0384+  0DD1 D9          	push c
0385+  0DD2             putsn_L0:
0386+  0DD2 1E          	mov al, [d]
0387+  0DD3 23          	mov ah, al
0388+  0DD4 19 00       	mov al, 0
0389+  0DD6 05 03       	syscall sys_io
0390+  0DD8 79          	inc d
0391+  0DD9 7E          	dec c	
0392+  0DDA C2 00 00    	cmp c, 0
0393+  0DDD C7 D2 0D    	jne putsn_L0
0394+  0DE0             putsn_end:
0395+  0DE0 E6          	pop c
0396+  0DE1 E7          	pop d
0397+  0DE2 E8          	pop al
0398+  0DE3 09          	ret
0399+  0DE4             
0400+  0DE4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0401+  0DE4             ; print 16bit decimal number
0402+  0DE4             ; input number in A
0403+  0DE4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  0DE4             print_u16d:
0405+  0DE4 D7          	push a
0406+  0DE5 D8          	push b
0407+  0DE6 26 10 27    	mov b, 10000
0408+  0DE9 AE          	div a, b			; get 10000 coeff.
0409+  0DEA 07 10 0E    	call print_zero_or_space
0410+  0DED 11          	mov a, b
0411+  0DEE 26 E8 03    	mov b, 1000
0412+  0DF1 AE          	div a, b			; get 10000 coeff.
0413+  0DF2 07 10 0E    	call print_zero_or_space
0414+  0DF5 11          	mov a, b
0415+  0DF6 26 64 00    	mov b, 100
0416+  0DF9 AE          	div a, b
0417+  0DFA 07 10 0E    	call print_zero_or_space
0418+  0DFD 11          	mov a, b
0419+  0DFE 26 0A 00    	mov b, 10
0420+  0E01 AE          	div a, b
0421+  0E02 07 10 0E    	call print_zero_or_space
0422+  0E05 11          	mov a, b
0423+  0E06 6A 30       	add al, $30
0424+  0E08 23          	mov ah, al
0425+  0E09 19 00       	mov al, 0
0426+  0E0B 05 03       	syscall sys_io	; print coeff
0427+  0E0D E5          	pop b
0428+  0E0E E4          	pop a
0429+  0E0F 09          	ret
0430+  0E10             
0431+  0E10             
0432+  0E10             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0433+  0E10             ; if A == 0, print space
0434+  0E10             ; else print A
0435+  0E10             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  0E10             print_zero_or_space:
0437+  0E10             	; cmp a, 0
0438+  0E10             	; jne print_number
0439+  0E10             	; mov ah, $20
0440+  0E10             	; call putchar
0441+  0E10             	; ret
0442+  0E10             print_number:
0443+  0E10 6A 30       	add al, $30
0444+  0E12 23          	mov ah, al
0445+  0E13 07 86 0C    	call putchar
0446+  0E16 09          	ret
0447+  0E17             
0448+  0E17             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  0E17             ; PRINT 16BIT HEX INTEGER
0450+  0E17             ; integer value in reg B
0451+  0E17             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0452+  0E17             print_u16x:
0453+  0E17 D7          	push a
0454+  0E18 D8          	push b
0455+  0E19 DD          	push bl
0456+  0E1A 30          	mov bl, bh
0457+  0E1B 07 4D 0C    	call itoa				; convert bh to char in A
0458+  0E1E 2F          	mov bl, al				; save al
0459+  0E1F 19 00       	mov al, 0
0460+  0E21 05 03       	syscall sys_io				; display AH
0461+  0E23 24          	mov ah, bl				; retrieve al
0462+  0E24 19 00       	mov al, 0
0463+  0E26 05 03       	syscall sys_io				; display AL
0464+  0E28             
0465+  0E28 EA          	pop bl
0466+  0E29 07 4D 0C    	call itoa				; convert bh to char in A
0467+  0E2C 2F          	mov bl, al				; save al
0468+  0E2D 19 00       	mov al, 0
0469+  0E2F 05 03       	syscall sys_io				; display AH
0470+  0E31 24          	mov ah, bl				; retrieve al
0471+  0E32 19 00       	mov al, 0
0472+  0E34 05 03       	syscall sys_io				; display AL
0473+  0E36             
0474+  0E36 E5          	pop b
0475+  0E37 E4          	pop a
0476+  0E38 09          	ret
0477+  0E39             
0478+  0E39             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  0E39             ; INPUT 16BIT HEX INTEGER
0480+  0E39             ; read 16bit integer into A
0481+  0E39             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0482+  0E39             scan_u16x:
0483+  0E39 F8 10 00    	enter 16
0484+  0E3C D8          	push b
0485+  0E3D DA          	push d
0486+  0E3E             
0487+  0E3E FA F1 FF    	lea d, [bp + -15]
0488+  0E41 07 8D 0C    	call gets				; get number
0489+  0E44             
0490+  0E44 32          	mov bl, [d]
0491+  0E45 37          	mov bh, bl
0492+  0E46 33 01 00    	mov bl, [d + 1]
0493+  0E49 07 3B 0C    	call atoi				; convert to int in AL
0494+  0E4C 23          	mov ah, al				; move to AH
0495+  0E4D             
0496+  0E4D 33 02 00    	mov bl, [d + 2]
0497+  0E50 37          	mov bh, bl
0498+  0E51 33 03 00    	mov bl, [d + 3]
0499+  0E54 07 3B 0C    	call atoi				; convert to int in AL
0500+  0E57             
0501+  0E57 E7          	pop d
0502+  0E58 E5          	pop b
0503+  0E59 F9          	leave
0504+  0E5A 09          	ret
0505+  0E5B             
0506+  0E5B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  0E5B             ; PRINT 8bit HEX INTEGER
0508+  0E5B             ; integer value in reg bl
0509+  0E5B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0510+  0E5B             print_u8x:
0511+  0E5B D7          	push a
0512+  0E5C DD          	push bl
0513+  0E5D             
0514+  0E5D 07 4D 0C    	call itoa				; convert bl to char in A
0515+  0E60 2F          	mov bl, al				; save al
0516+  0E61 19 00       	mov al, 0
0517+  0E63 05 03       	syscall sys_io				; display AH
0518+  0E65 24          	mov ah, bl				; retrieve al
0519+  0E66 19 00       	mov al, 0
0520+  0E68 05 03       	syscall sys_io				; display AL
0521+  0E6A             
0522+  0E6A EA          	pop bl
0523+  0E6B E4          	pop a
0524+  0E6C 09          	ret
0525+  0E6D             
0526+  0E6D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  0E6D             ; print 8bit decimal unsigned number
0528+  0E6D             ; input number in AL
0529+  0E6D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0530+  0E6D             print_u8d:
0531+  0E6D D7          	push a
0532+  0E6E D8          	push b
0533+  0E6F             
0534+  0E6F 22 00       	mov ah, 0
0535+  0E71 26 64 00    	mov b, 100
0536+  0E74 AE          	div a, b
0537+  0E75 D8          	push b			; save remainder
0538+  0E76 B9 00       	cmp al, 0
0539+  0E78 C6 82 0E    	je skip100
0540+  0E7B 6A 30       	add al, $30
0541+  0E7D 23          	mov ah, al
0542+  0E7E 19 00       	mov al, 0
0543+  0E80 05 03       	syscall sys_io	; print coeff
0544+  0E82             skip100:
0545+  0E82 E4          	pop a
0546+  0E83 22 00       	mov ah, 0
0547+  0E85 26 0A 00    	mov b, 10
0548+  0E88 AE          	div a, b
0549+  0E89 D8          	push b			; save remainder
0550+  0E8A B9 00       	cmp al, 0
0551+  0E8C C6 96 0E    	je skip10
0552+  0E8F 6A 30       	add al, $30
0553+  0E91 23          	mov ah, al
0554+  0E92 19 00       	mov al, 0
0555+  0E94 05 03       	syscall sys_io	; print coeff
0556+  0E96             skip10:
0557+  0E96 E4          	pop a
0558+  0E97 1B          	mov al, bl
0559+  0E98 6A 30       	add al, $30
0560+  0E9A 23          	mov ah, al
0561+  0E9B 19 00       	mov al, 0
0562+  0E9D 05 03       	syscall sys_io	; print coeff
0563+  0E9F E5          	pop b
0564+  0EA0 E4          	pop a
0565+  0EA1 09          	ret
0566+  0EA2             
0567+  0EA2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  0EA2             ; INPUT 8BIT HEX INTEGER
0569+  0EA2             ; read 8bit integer into AL
0570+  0EA2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0571+  0EA2             scan_u8x:
0572+  0EA2 F8 04 00    	enter 4
0573+  0EA5 D8          	push b
0574+  0EA6 DA          	push d
0575+  0EA7             
0576+  0EA7 FA FD FF    	lea d, [bp + -3]
0577+  0EAA 07 8D 0C    	call gets				; get number
0578+  0EAD             
0579+  0EAD 32          	mov bl, [d]
0580+  0EAE 37          	mov bh, bl
0581+  0EAF 33 01 00    	mov bl, [d + 1]
0582+  0EB2 07 3B 0C    	call atoi				; convert to int in AL
0583+  0EB5             
0584+  0EB5 E7          	pop d
0585+  0EB6 E5          	pop b
0586+  0EB7 F9          	leave
0587+  0EB8 09          	ret
0588+  0EB9             
0589+  0EB9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0590+  0EB9             ; input decimal number
0591+  0EB9             ; result in A
0592+  0EB9             ; 655'\0'
0593+  0EB9             ; low--------high
0594+  0EB9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0595+  0EB9             scan_u16d:
0596+  0EB9 F8 08 00    	enter 8
0597+  0EBC E2          	push si
0598+  0EBD D8          	push b
0599+  0EBE D9          	push c
0600+  0EBF DA          	push d
0601+  0EC0 FA F9 FF    	lea d, [bp +- 7]
0602+  0EC3 07 8D 0C    	call gets
0603+  0EC6 07 C3 0B    	call strlen			; get string length in C
0604+  0EC9 7E          	dec c
0605+  0ECA FD 4E       	mov si, d
0606+  0ECC 12          	mov a, c
0607+  0ECD FD 99       	shl a
0608+  0ECF 3B 23 0C    	mov d, table_power
0609+  0ED2 59          	add d, a
0610+  0ED3 38 00 00    	mov c, 0
0611+  0ED6             mul_loop:
0612+  0ED6 F6          	lodsb			; load ASCII to al
0613+  0ED7 B9 00       	cmp al, 0
0614+  0ED9 C6 EC 0E    	je mul_exit
0615+  0EDC 6F 30       	sub al, $30		; make into integer
0616+  0EDE 22 00       	mov ah, 0
0617+  0EE0 2A          	mov b, [d]
0618+  0EE1 AC          	mul a, b			; result in B since it fits in 16bits
0619+  0EE2 11          	mov a, b
0620+  0EE3 28          	mov b, c
0621+  0EE4 54          	add a, b
0622+  0EE5 39          	mov c, a
0623+  0EE6 63 02 00    	sub d, 2
0624+  0EE9 0A D6 0E    	jmp mul_loop
0625+  0EEC             mul_exit:
0626+  0EEC 12          	mov a, c
0627+  0EED E7          	pop d
0628+  0EEE E6          	pop c
0629+  0EEF E5          	pop b
0630+  0EF0 EF          	pop si
0631+  0EF1 F9          	leave
0632+  0EF2 09          	ret
0281   0EF3             .include "ctype.asm"
0001+  0EF3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0EF3             ; ctype.s
0003+  0EF3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0EF3             
0005+  0EF3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  0EF3             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  0EF3             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  0EF3             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  0EF3             ;; characters are supported.
0010+  0EF3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  0EF3             ;; isalnum 
0012+  0EF3             ;; isalpha 
0013+  0EF3             ;; islower 
0014+  0EF3             ;; isupper 
0015+  0EF3             ;; isdigit 
0016+  0EF3             ;; isxdigit
0017+  0EF3             ;; iscntrl 
0018+  0EF3             ;; isgraph 
0019+  0EF3             ;; isspace 
0020+  0EF3             ;; isblank 
0021+  0EF3             ;; isprint 
0022+  0EF3             ;; ispunct 
0023+  0EF3             ;; tolower 
0024+  0EF3             ;; toupper
0025+  0EF3             
0026+  0EF3             
0027+  0EF3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  0EF3             ;; IS ALPHANUMERIC
0029+  0EF3             ;; sets ZF according with result
0030+  0EF3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  0EF3             isalnum:
0032+  0EF3 07 10 0F    	call isalpha
0033+  0EF6 C6 FC 0E    	je isalnum_exit
0034+  0EF9 07 FD 0E    	call isdigit
0035+  0EFC             isalnum_exit:
0036+  0EFC 09          	ret	
0037+  0EFD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0EFD             ;; IS DIGIT
0039+  0EFD             ;; sets ZF according with result
0040+  0EFD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  0EFD             isdigit:
0042+  0EFD DB          	push al
0043+  0EFE B9 30       	cmp al, '0'
0044+  0F00 C8 0C 0F    	jlu isdigit_false
0045+  0F03 B9 39       	cmp al, '9'
0046+  0F05 D1 0C 0F    	jgu isdigit_false
0047+  0F08 87 00       	and al, 0	; set ZF
0048+  0F0A E8          	pop al
0049+  0F0B 09          	ret
0050+  0F0C             isdigit_false:
0051+  0F0C 8B 01       	or al, 1	; clear ZF
0052+  0F0E E8          	pop al
0053+  0F0F 09          	ret	
0054+  0F10             	
0055+  0F10             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  0F10             ;; IS ALPHA
0057+  0F10             ;; sets ZF according with result
0058+  0F10             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  0F10             isalpha:
0060+  0F10 DB          	push al
0061+  0F11 B9 5F       	cmp al, '_'
0062+  0F13 C6 33 0F    	je isalpha_true
0063+  0F16 B9 2E       	cmp al, '.'
0064+  0F18 C6 33 0F    	je isalpha_true
0065+  0F1B B9 41       	cmp al, 'A'
0066+  0F1D C8 2F 0F    	jlu isalpha_false
0067+  0F20 B9 7A       	cmp al, 'z'
0068+  0F22 D1 2F 0F    	jgu isalpha_false
0069+  0F25 B9 5A       	cmp al, 'Z'
0070+  0F27 D0 33 0F    	jleu isalpha_true
0071+  0F2A B9 61       	cmp al, 'a'
0072+  0F2C C9 33 0F    	jgeu isalpha_true
0073+  0F2F             isalpha_false:
0074+  0F2F 8B 01       	or al, 1	; clear ZF
0075+  0F31 E8          	pop al
0076+  0F32 09          	ret
0077+  0F33             isalpha_true:
0078+  0F33 87 00       	and al, 0	; set ZF
0079+  0F35 E8          	pop al
0080+  0F36 09          	ret
0081+  0F37             
0082+  0F37             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  0F37             ;; IS PATH-ALPHA
0084+  0F37             ;; sets ZF according with result
0085+  0F37             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  0F37             ispath:
0087+  0F37 DB          	push al
0088+  0F38 07 FD 0E    	call isdigit
0089+  0F3B C6 65 0F    	je ispath_true
0090+  0F3E B9 5F       	cmp al, '_'
0091+  0F40 C6 65 0F    	je ispath_true
0092+  0F43 B9 2F       	cmp al, '/'
0093+  0F45 C6 65 0F    	je ispath_true
0094+  0F48 B9 2E       	cmp al, '.'
0095+  0F4A C6 65 0F    	je ispath_true
0096+  0F4D B9 41       	cmp al, 'A'
0097+  0F4F C8 61 0F    	jlu ispath_false
0098+  0F52 B9 7A       	cmp al, 'z'
0099+  0F54 D1 61 0F    	jgu ispath_false
0100+  0F57 B9 5A       	cmp al, 'Z'
0101+  0F59 D0 65 0F    	jleu ispath_true
0102+  0F5C B9 61       	cmp al, 'a'
0103+  0F5E C9 65 0F    	jgeu ispath_true
0104+  0F61             ispath_false:
0105+  0F61 8B 01       	or al, 1	; clear ZF
0106+  0F63 E8          	pop al
0107+  0F64 09          	ret
0108+  0F65             ispath_true:
0109+  0F65 87 00       	and al, 0	; set ZF
0110+  0F67 E8          	pop al
0111+  0F68 09          	ret
0112+  0F69             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  0F69             ;; IS SPACE
0114+  0F69             ;; sets ZF according with result
0115+  0F69             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  0F69             isspace:
0117+  0F69 B9 20       	cmp al, $20		; ' '
0118+  0F6B C6 7F 0F    	je isspace_exit
0119+  0F6E B9 09       	cmp al, $09		; '\t'
0120+  0F70 C6 7F 0F    	je isspace_exit
0121+  0F73 B9 0A       	cmp al, $0A		; '\n'
0122+  0F75 C6 7F 0F    	je isspace_exit
0123+  0F78 B9 0D       	cmp al, $0D		; '\r'
0124+  0F7A C6 7F 0F    	je isspace_exit
0125+  0F7D B9 0B       	cmp al, $0B		; '\v'
0126+  0F7F             isspace_exit:
0127+  0F7F 09          	ret	
0128+  0F80             
0129+  0F80             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0F80             ; TO LOWER
0131+  0F80             ; input in AL
0132+  0F80             ; output in AL
0133+  0F80             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  0F80             to_lower:
0135+  0F80 B9 5A       	cmp al, 'Z'
0136+  0F82 D1 87 0F    	jgu to_lower_ret
0137+  0F85 6A 20       	add al, $20				; convert to lower case
0138+  0F87             to_lower_ret:
0139+  0F87 09          	ret
0140+  0F88             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  0F88             ; TO UPPER
0142+  0F88             ; input in AL
0143+  0F88             ; output in AL
0144+  0F88             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  0F88             to_upper:
0146+  0F88 B9 61       	cmp al, 'a'
0147+  0F8A C8 8F 0F    	jlu to_upper_ret
0148+  0F8D 6F 20       	sub al, $20			; convert to upper case
0149+  0F8F             to_upper_ret:
0150+  0F8F 09          	ret
0151+  0F90             
0282   0F90             .include "token.asm"
0001+  0F90             TOKTYP_IDENTIFIER	.equ 0
0002+  0F90             TOKTYP_KEYWORD		.equ 1
0003+  0F90             TOKTYP_DELIMITER	.equ 2
0004+  0F90             TOKTYP_STRING		.equ 3
0005+  0F90             TOKTYP_CHAR			.equ 4
0006+  0F90             TOKTYP_NUMERIC		.equ 5
0007+  0F90             TOKTYP_END			.equ 6
0008+  0F90             
0009+  0F90             TOK_NULL			.equ 0
0010+  0F90             TOK_FSLASH			.equ 1
0011+  0F90             TOK_TIMES 			.equ 2
0012+  0F90             TOK_PLUS 			.equ 3
0013+  0F90             TOK_MINUS 			.equ 4
0014+  0F90             TOK_DOT				.equ 5
0015+  0F90             TOK_SEMI			.equ 6
0016+  0F90             TOK_ANGLE			.equ 7
0017+  0F90             TOK_TILDE			.equ 8
0018+  0F90             TOK_EQUAL			.equ 9
0019+  0F90             TOK_COLON			.equ 10
0020+  0F90             TOK_COMMA			.equ 11
0021+  0F90             
0022+  0F90             TOK_END				.equ 20
0023+  0F90             
0024+  0F90             
0025+  0F90             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  0F90             ;; read a full command argment from shell input buffer
0027+  0F90             ;; argument is written into tokstr
0028+  0F90             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  0F90             get_arg:
0030+  0F90 D7          	push a
0031+  0F91 E2          	push si
0032+  0F92 E3          	push di
0033+  0F93 19 00       	mov al, 0
0034+  0F95 3D BE 11    	mov [tokstr], al			; nullify tokstr string
0035+  0F98 14 BA 11    	mov a, [prog]
0036+  0F9B 4D          	mov si, a
0037+  0F9C FD 4F BE 11 	mov di, tokstr
0038+  0FA0             get_arg_skip_spaces:
0039+  0FA0 F6          	lodsb
0040+  0FA1 07 69 0F    	call isspace
0041+  0FA4 C6 A0 0F    	je get_arg_skip_spaces
0042+  0FA7             get_arg_L0:
0043+  0FA7 B9 3B       	cmp al, $3B				; check if is ';'
0044+  0FA9 C6 B6 0F    	je get_arg_end
0045+  0FAC B9 00       	cmp al, 0
0046+  0FAE C6 B6 0F    	je get_arg_end			; check if end of input
0047+  0FB1 F7          	stosb
0048+  0FB2 F6          	lodsb
0049+  0FB3 0A A7 0F    	jmp get_arg_L0
0050+  0FB6             get_arg_end:
0051+  0FB6 19 00       	mov al, 0
0052+  0FB8 F7          	stosb
0053+  0FB9 D5 01 00    	sub si, 1
0054+  0FBC 4E          	mov a, si
0055+  0FBD 42 BA 11    	mov [prog], a		; update pointer
0056+  0FC0 F0          	pop di
0057+  0FC1 EF          	pop si
0058+  0FC2 E4          	pop a
0059+  0FC3 09          	ret
0060+  0FC4             
0061+  0FC4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  0FC4             ;; read a path formation from shell input buffer
0063+  0FC4             ;; path is written into tokstr
0064+  0FC4             ;; /usr/bin
0065+  0FC4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  0FC4             get_path:
0067+  0FC4 D7          	push a
0068+  0FC5 E2          	push si
0069+  0FC6 E3          	push di
0070+  0FC7 19 00       	mov al, 0
0071+  0FC9 3D BE 11    	mov [tokstr], al			; nullify tokstr string
0072+  0FCC 14 BA 11    	mov a, [prog]
0073+  0FCF 4D          	mov si, a
0074+  0FD0 FD 4F BE 11 	mov di, tokstr
0075+  0FD4             get_path_skip_spaces:
0076+  0FD4 F6          	lodsb
0077+  0FD5 07 69 0F    	call isspace
0078+  0FD8 C6 D4 0F    	je get_path_skip_spaces
0079+  0FDB             get_path_is_pathchar:
0080+  0FDB F7          	stosb
0081+  0FDC F6          	lodsb
0082+  0FDD 07 F3 0E    	call isalnum			;check if is alphanumeric
0083+  0FE0 C6 DB 0F    	je get_path_is_pathchar
0084+  0FE3 B9 2F       	cmp al, '/'				; check if is '/'
0085+  0FE5 C6 DB 0F    	je get_path_is_pathchar
0086+  0FE8 19 00       	mov al, 0
0087+  0FEA F7          	stosb
0088+  0FEB D5 01 00    	sub si, 1
0089+  0FEE 4E          	mov a, si
0090+  0FEF 42 BA 11    	mov [prog], a		; update pointer
0091+  0FF2             get_path_end:
0092+  0FF2 F0          	pop di
0093+  0FF3 EF          	pop si
0094+  0FF4 E4          	pop a
0095+  0FF5 09          	ret
0096+  0FF6             
0097+  0FF6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  0FF6             ;; read a line
0099+  0FF6             ;; line is written into tokstr
0100+  0FF6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  0FF6             get_line:
0102+  0FF6 D7          	push a
0103+  0FF7 E2          	push si
0104+  0FF8 E3          	push di
0105+  0FF9 19 00       	mov al, 0
0106+  0FFB 3D BE 11    	mov [tokstr], al			; nullify tokstr string
0107+  0FFE 14 BA 11    	mov a, [prog]
0108+  1001 4D          	mov si, a
0109+  1002 FD 4F BE 11 	mov di, tokstr
0110+  1006             get_line_L0:
0111+  1006 F6          	lodsb
0112+  1007 B9 0A       	cmp al, $0A		; check for new line
0113+  1009 C6 10 10    	je get_line_exit
0114+  100C F7          	stosb
0115+  100D 0A 06 10    	jmp get_line_L0
0116+  1010             get_line_exit:
0117+  1010 19 00       	mov al, 0
0118+  1012 F7          	stosb
0119+  1013 4E          	mov a, si
0120+  1014 42 BA 11    	mov [prog], a		; update pointer
0121+  1017 F0          	pop di
0122+  1018 EF          	pop si
0123+  1019 E4          	pop a
0124+  101A 09          	ret
0125+  101B             
0126+  101B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  101B             ;; token parser
0128+  101B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  101B             get_token:
0130+  101B D7          	push a
0131+  101C DA          	push d
0132+  101D E2          	push si
0133+  101E E3          	push di
0134+  101F 19 00       	mov al, 0
0135+  1021 3D BE 11    	mov [tokstr], al			; nullify tokstr string
0136+  1024 19 00       	mov al, TOK_NULL
0137+  1026 3D BD 11    	mov [tok], al				; nullify token
0138+  1029 14 BA 11    	mov a, [prog]
0139+  102C 4D          	mov si, a
0140+  102D FD 4F BE 11 	mov di, tokstr
0141+  1031             get_tok_skip_spaces:
0142+  1031 F6          	lodsb
0143+  1032 07 69 0F    	call isspace
0144+  1035 C6 31 10    	je get_tok_skip_spaces
0145+  1038 B9 00       	cmp al, 0			; check for end of input (NULL)
0146+  103A C6 1F 11    	je get_token_end
0147+  103D B9 23       	cmp al, '#'			; comments!
0148+  103F C6 4D 11    	je get_tok_comment
0149+  1042 07 F3 0E    	call isalnum
0150+  1045 C6 2C 11    	jz is_alphanumeric
0151+  1048             ; other token types
0152+  1048             get_token_slash:
0153+  1048 B9 2F       	cmp al, '/'				; check if '/'
0154+  104A C7 62 10    	jne get_token_minus
0155+  104D F7          	stosb					; store '/' into token string
0156+  104E 19 00       	mov al, 0
0157+  1050 F7          	stosb					; terminate token string
0158+  1051 19 01       	mov al, TOK_FSLASH
0159+  1053 3D BD 11    	mov [tok], al			
0160+  1056 19 02       	mov al, TOKTYP_DELIMITER
0161+  1058 3D BC 11    	mov [toktyp], al
0162+  105B 4E          	mov a, si
0163+  105C 42 BA 11    	mov [prog], a		; update pointer
0164+  105F 0A 48 11    	jmp get_token_return
0165+  1062             get_token_minus:
0166+  1062 B9 2D       	cmp al, '-'				; check if '-'
0167+  1064 C7 7C 10    	jne get_token_comma
0168+  1067 F7          	stosb					; store '-' into token string
0169+  1068 19 00       	mov al, 0
0170+  106A F7          	stosb					; terminate token string
0171+  106B 19 04       	mov al, TOK_MINUS
0172+  106D 3D BD 11    	mov [tok], al			
0173+  1070 19 02       	mov al, TOKTYP_DELIMITER
0174+  1072 3D BC 11    	mov [toktyp], al
0175+  1075 4E          	mov a, si
0176+  1076 42 BA 11    	mov [prog], a		; update pointer
0177+  1079 0A 48 11    	jmp get_token_return
0178+  107C             get_token_comma:
0179+  107C B9 2C       	cmp al, ','				; check if ','
0180+  107E C7 96 10    	jne get_token_semi
0181+  1081 F7          	stosb					; store ',' into token string
0182+  1082 19 00       	mov al, 0
0183+  1084 F7          	stosb					; terminate token string
0184+  1085 19 0B       	mov al, TOK_COMMA
0185+  1087 3D BD 11    	mov [tok], al			
0186+  108A 19 02       	mov al, TOKTYP_DELIMITER
0187+  108C 3D BC 11    	mov [toktyp], al
0188+  108F 4E          	mov a, si
0189+  1090 42 BA 11    	mov [prog], a		; update pointer
0190+  1093 0A 48 11    	jmp get_token_return
0191+  1096             get_token_semi:
0192+  1096 B9 3B       	cmp al, $3B				; check if ';'
0193+  1098 C7 B0 10    	jne get_token_colon
0194+  109B F7          	stosb					; store ';' into token string
0195+  109C 19 00       	mov al, 0
0196+  109E F7          	stosb					; terminate token string
0197+  109F 19 06       	mov al, TOK_SEMI
0198+  10A1 3D BD 11    	mov [tok], al			
0199+  10A4 19 02       	mov al, TOKTYP_DELIMITER
0200+  10A6 3D BC 11    	mov [toktyp], al
0201+  10A9 4E          	mov a, si
0202+  10AA 42 BA 11    	mov [prog], a		; update pointer
0203+  10AD 0A 48 11    	jmp get_token_return
0204+  10B0             get_token_colon:
0205+  10B0 B9 3A       	cmp al, $3A				; check if ':'
0206+  10B2 C7 CA 10    	jne get_token_angle
0207+  10B5 F7          	stosb					; store ':' into token string
0208+  10B6 19 00       	mov al, 0
0209+  10B8 F7          	stosb					; terminate token string
0210+  10B9 19 0A       	mov al, TOK_COLON
0211+  10BB 3D BD 11    	mov [tok], al			
0212+  10BE 19 02       	mov al, TOKTYP_DELIMITER
0213+  10C0 3D BC 11    	mov [toktyp], al
0214+  10C3 4E          	mov a, si
0215+  10C4 42 BA 11    	mov [prog], a		; update pointer
0216+  10C7 0A 48 11    	jmp get_token_return
0217+  10CA             get_token_angle:
0218+  10CA B9 3E       	cmp al, $3E				; check if '>'
0219+  10CC C7 E4 10    	jne get_token_tilde
0220+  10CF F7          	stosb					; store '>' into token string
0221+  10D0 19 00       	mov al, 0
0222+  10D2 F7          	stosb					; terminate token string
0223+  10D3 19 07       	mov al, TOK_ANGLE
0224+  10D5 3D BD 11    	mov [tok], al			
0225+  10D8 19 02       	mov al, TOKTYP_DELIMITER
0226+  10DA 3D BC 11    	mov [toktyp], al
0227+  10DD 4E          	mov a, si
0228+  10DE 42 BA 11    	mov [prog], a		; update pointer
0229+  10E1 0A 48 11    	jmp get_token_return
0230+  10E4             get_token_tilde:
0231+  10E4 B9 7E       	cmp al, '~'				; check if '~'
0232+  10E6 C7 FE 10    	jne get_token_equal
0233+  10E9 F7          	stosb					; store '~' into token string
0234+  10EA 19 00       	mov al, 0
0235+  10EC F7          	stosb					; terminate token string
0236+  10ED 19 08       	mov al, TOK_TILDE
0237+  10EF 3D BD 11    	mov [tok], al			
0238+  10F2 19 02       	mov al, TOKTYP_DELIMITER
0239+  10F4 3D BC 11    	mov [toktyp], al
0240+  10F7 4E          	mov a, si
0241+  10F8 42 BA 11    	mov [prog], a		; update pointer
0242+  10FB 0A 48 11    	jmp get_token_return
0243+  10FE             get_token_equal:
0244+  10FE B9 3D       	cmp al, '='				; check if '='
0245+  1100 C7 18 11    	jne get_token_skip
0246+  1103 F7          	stosb					; store '=' into token string
0247+  1104 19 00       	mov al, 0
0248+  1106 F7          	stosb					; terminate token string
0249+  1107 19 09       	mov al, TOK_EQUAL
0250+  1109 3D BD 11    	mov [tok], al			
0251+  110C 19 02       	mov al, TOKTYP_DELIMITER
0252+  110E 3D BC 11    	mov [toktyp], al
0253+  1111 4E          	mov a, si
0254+  1112 42 BA 11    	mov [prog], a		; update pointer
0255+  1115 0A 48 11    	jmp get_token_return
0256+  1118             get_token_skip:
0257+  1118 4E          	mov a, si
0258+  1119 42 BA 11    	mov [prog], a		; update pointer
0259+  111C 0A 48 11    	jmp get_token_return
0260+  111F             get_token_end:				; end of file token
0261+  111F 19 14       	mov al, TOK_END
0262+  1121 3D BD 11    	mov [tok], al
0263+  1124 19 06       	mov al, TOKTYP_END
0264+  1126 3D BC 11    	mov [toktyp], al
0265+  1129 0A 48 11    	jmp get_token_return
0266+  112C             is_alphanumeric:
0267+  112C F7          	stosb
0268+  112D F6          	lodsb
0269+  112E 07 F3 0E    	call isalnum			;check if is alphanumeric
0270+  1131 C6 2C 11    	jz is_alphanumeric
0271+  1134 B9 2E       	cmp al, $2E				; check if is '.'
0272+  1136 C6 2C 11    	je is_alphanumeric
0273+  1139 19 00       	mov al, 0
0274+  113B F7          	stosb
0275+  113C 19 00       	mov al, TOKTYP_IDENTIFIER
0276+  113E 3D BC 11    	mov [toktyp], al
0277+  1141 D5 01 00    	sub si, 1
0278+  1144 4E          	mov a, si
0279+  1145 42 BA 11    	mov [prog], a		; update pointer
0280+  1148             get_token_return:
0281+  1148 F0          	pop di
0282+  1149 EF          	pop si
0283+  114A E7          	pop d
0284+  114B E4          	pop a
0285+  114C 09          	ret
0286+  114D             get_tok_comment:
0287+  114D F6          	lodsb
0288+  114E B9 0A       	cmp al, $0A			; new line
0289+  1150 C7 4D 11    	jne get_tok_comment
0290+  1153 0A 31 10    	jmp get_tok_skip_spaces
0291+  1156             
0292+  1156             
0293+  1156             get_number:
0294+  1156 D7          	push a
0295+  1157 DA          	push d
0296+  1158 E2          	push si
0297+  1159 E3          	push di
0298+  115A 19 00       	mov al, 0
0299+  115C 3D BE 11    	mov [tokstr], al			; nullify tokstr string
0300+  115F 19 00       	mov al, TOK_NULL
0301+  1161 3D BD 11    	mov [tok], al				; nullify token
0302+  1164 14 BA 11    	mov a, [prog]
0303+  1167 4D          	mov si, a
0304+  1168 FD 4F BE 11 	mov di, tokstr
0305+  116C             get_number_skip_spaces:
0306+  116C F6          	lodsb
0307+  116D 07 69 0F    	call isspace
0308+  1170 C6 6C 11    	je get_number_skip_spaces
0309+  1173 B9 00       	cmp al, 0			; check for end of input (NULL)
0310+  1175 C7 85 11    	jne get_number_L0
0311+  1178 19 14       	mov al, TOK_END
0312+  117A 3D BD 11    	mov [tok], al
0313+  117D 19 06       	mov al, TOKTYP_END
0314+  117F 3D BC 11    	mov [toktyp], al
0315+  1182 0A 9C 11    	jmp get_number_return
0316+  1185             get_number_L0:
0317+  1185 F7          	stosb
0318+  1186 F6          	lodsb
0319+  1187 07 FD 0E    	call isdigit			;check if is numeric
0320+  118A C6 85 11    	jz get_number_L0
0321+  118D 19 00       	mov al, 0
0322+  118F F7          	stosb
0323+  1190 19 05       	mov al, TOKTYP_NUMERIC
0324+  1192 3D BC 11    	mov [toktyp], al
0325+  1195 D5 01 00    	sub si, 1
0326+  1198 4E          	mov a, si
0327+  1199 42 BA 11    	mov [prog], a		; update pointer
0328+  119C             get_number_return:
0329+  119C F0          	pop di
0330+  119D EF          	pop si
0331+  119E E7          	pop d
0332+  119F E4          	pop a
0333+  11A0 09          	ret
0334+  11A1             
0335+  11A1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  11A1             ;; PUT BACK TOKEN
0337+  11A1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
0338+  11A1             putback:
0339+  11A1 D7          	push a
0340+  11A2 E2          	push si
0341+  11A3 FD 4D BE 11 	mov si, tokstr	
0342+  11A7             putback_loop:
0343+  11A7 F6          	lodsb
0344+  11A8 B9 00       	cmp al, 0
0345+  11AA C6 B7 11    	je putback_end
0346+  11AD 14 BA 11    	mov a, [prog]
0347+  11B0 7D          	dec a
0348+  11B1 42 BA 11    	mov [prog], a			; update pointer
0349+  11B4 0A A7 11    	jmp putback_loop
0350+  11B7             putback_end:
0351+  11B7 EF          	pop si
0352+  11B8 E4          	pop a
0353+  11B9 09          	ret
0354+  11BA             
0355+  11BA             
0356+  11BA             
0357+  11BA             
0358+  11BA 00 00       prog:		.dw 0			; pointer to current position in buffer
0359+  11BC             
0360+  11BC 00          toktyp: 	.db 0			; token type symbol
0361+  11BD 00          tok:		.db 0			; current token symbol
0362+  11BE 00 00 00 00 tokstr:		.fill 256, 0	; token as a string
0362+  11C2 00 00 00 00 
0362+  11C6 00 00 00 00 
0362+  11CA 00 00 00 00 
0362+  11CE 00 00 00 00 
0362+  11D2 00 00 00 00 
0362+  11D6 00 00 00 00 
0362+  11DA 00 00 00 00 
0362+  11DE 00 00 00 00 
0362+  11E2 00 00 00 00 
0362+  11E6 00 00 00 00 
0362+  11EA 00 00 00 00 
0362+  11EE 00 00 00 00 
0362+  11F2 00 00 00 00 
0362+  11F6 00 00 00 00 
0362+  11FA 00 00 00 00 
0362+  11FE 00 00 00 00 
0362+  1202 00 00 00 00 
0362+  1206 00 00 00 00 
0362+  120A 00 00 00 00 
0362+  120E 00 00 00 00 
0362+  1212 00 00 00 00 
0362+  1216 00 00 00 00 
0362+  121A 00 00 00 00 
0362+  121E 00 00 00 00 
0362+  1222 00 00 00 00 
0362+  1226 00 00 00 00 
0362+  122A 00 00 00 00 
0362+  122E 00 00 00 00 
0362+  1232 00 00 00 00 
0362+  1236 00 00 00 00 
0362+  123A 00 00 00 00 
0362+  123E 00 00 00 00 
0362+  1242 00 00 00 00 
0362+  1246 00 00 00 00 
0362+  124A 00 00 00 00 
0362+  124E 00 00 00 00 
0362+  1252 00 00 00 00 
0362+  1256 00 00 00 00 
0362+  125A 00 00 00 00 
0362+  125E 00 00 00 00 
0362+  1262 00 00 00 00 
0362+  1266 00 00 00 00 
0362+  126A 00 00 00 00 
0362+  126E 00 00 00 00 
0362+  1272 00 00 00 00 
0362+  1276 00 00 00 00 
0362+  127A 00 00 00 00 
0362+  127E 00 00 00 00 
0362+  1282 00 00 00 00 
0362+  1286 00 00 00 00 
0362+  128A 00 00 00 00 
0362+  128E 00 00 00 00 
0362+  1292 00 00 00 00 
0362+  1296 00 00 00 00 
0362+  129A 00 00 00 00 
0362+  129E 00 00 00 00 
0362+  12A2 00 00 00 00 
0362+  12A6 00 00 00 00 
0362+  12AA 00 00 00 00 
0362+  12AE 00 00 00 00 
0362+  12B2 00 00 00 00 
0362+  12B6 00 00 00 00 
0362+  12BA 00 00 00 00 
0283   12BE             
0284   12BE             .end
tasm: Number of errors = 0
