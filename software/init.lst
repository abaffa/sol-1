0001   0000             .include "kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0002   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0003   0000             ; SHELL
0004   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0005   0000             
0006   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007   0000             ; SYSTEM CONSTANTS / EQUATIONS
0008   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0009   0000             STACK_BEGIN:	.equ $F7FF	; beginning of stack
0010   0000             
0011   0400             .org PROC_TEXT_ORG			; origin at 1024
0012   0400             
0013   0400             shell_main:	
0014   0400 FD 49 FF F7 	mov bp, STACK_BEGIN
0015   0404 FD 47 FF F7 	mov sp, STACK_BEGIN
0016   0408             
0017   0408 3B 40 04    	mov d, s_prompt_init
0018   040B 07 8D 06    	call puts
0019   040E             
0020   040E 3B 25 04    	mov d, s_prompt_shell
0021   0411 07 8D 06    	call puts
0022   0414 3B 19 04    	mov d, s_shell_path
0023   0417 05 05       	syscall sys_fork
0024   0419             
0025   0419 2F 75 73 72 s_shell_path:	.db "/usr/bin/sh", 0
0025   041D 2F 62 69 6E 
0025   0421 2F 73 68 00 
0026   0425             
0027   0425 6C 61 75 6E s_prompt_shell:	.db "launching a shell session\n", 0
0027   0429 63 68 69 6E 
0027   042D 67 20 61 20 
0027   0431 73 68 65 6C 
0027   0435 6C 20 73 65 
0027   0439 73 73 69 6F 
0027   043D 6E 0A 00 
0028   0440             
0029   0440 69 6E 69 74 s_prompt_init:	.db "init started\n", 0
0029   0444 20 73 74 61 
0029   0448 72 74 65 64 
0029   044C 0A 00 
0030   044E             
0031   044E             .include "stdio.asm"
0001+  044E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  044E             ; stdio.s
0003+  044E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  044E             .include "string.asm"
0001++ 044E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 044E             ; string.s
0003++ 044E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 044E             
0005++ 044E             
0006++ 044E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 044E             ; strrev
0008++ 044E             ; reverse a string
0009++ 044E             ; D = string address
0010++ 044E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 044E             ; 01234
0012++ 044E             strrev:
0013++ 044E 4B          	pusha
0014++ 044F 07 95 04    	call strlen	; length in C
0015++ 0452 12          	mov a, c
0016++ 0453 AF 01 00    	cmp a, 1
0017++ 0456 D0 70 04    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0459 7D          	dec a
0019++ 045A FD 4E       	mov si, d	; beginning of string
0020++ 045C FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 045E 59          	add d, a	; end of string
0022++ 045F 12          	mov a, c
0023++ 0460 FD 9B       	shr a		; divide by 2
0024++ 0462 39          	mov c, a	; C now counts the steps
0025++ 0463             strrev_L0:
0026++ 0463 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0464 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0465 3E          	mov [d], al	; store left char into right side
0029++ 0466 1B          	mov al, bl
0030++ 0467 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0468 7E          	dec c
0032++ 0469 7F          	dec d
0033++ 046A C2 00 00    	cmp c, 0
0034++ 046D C7 63 04    	jne strrev_L0
0035++ 0470             strrev_end:
0036++ 0470 4C          	popa
0037++ 0471 09          	ret
0038++ 0472             	
0039++ 0472             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0472             ; strchr
0041++ 0472             ; search string in D for char in AL
0042++ 0472             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0472             strchr:
0044++ 0472             strchr_L0:
0045++ 0472 32          	mov bl, [d]
0046++ 0473 C1 00       	cmp bl, 0
0047++ 0475 C6 80 04    	je strchr_end
0048++ 0478 BA          	cmp al, bl
0049++ 0479 C6 80 04    	je strchr_end
0050++ 047C 79          	inc d
0051++ 047D 0A 72 04    	jmp strchr_L0
0052++ 0480             strchr_end:
0053++ 0480 1B          	mov al, bl
0054++ 0481 09          	ret
0055++ 0482             
0056++ 0482             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0482             ; strstr
0058++ 0482             ; find sub-string
0059++ 0482             ; str1 in SI
0060++ 0482             ; str2 in DI
0061++ 0482             ; SI points to end of source string
0062++ 0482             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0482             strstr:
0064++ 0482 DB          	push al
0065++ 0483 DA          	push d
0066++ 0484 E3          	push di
0067++ 0485             strstr_loop:
0068++ 0485 F3          	cmpsb					; compare a byte of the strings
0069++ 0486 C7 91 04    	jne strstr_ret
0070++ 0489 FC 00 00    	lea d, [di + 0]
0071++ 048C BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 048E C7 85 04    	jne strstr_loop				; equal chars but not at end
0073++ 0491             strstr_ret:
0074++ 0491 F0          	pop di
0075++ 0492 E7          	pop d
0076++ 0493 E8          	pop al
0077++ 0494 09          	ret
0078++ 0495             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0495             ; length of null terminated string
0080++ 0495             ; result in C
0081++ 0495             ; pointer in D
0082++ 0495             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0495             strlen:
0084++ 0495 DA          	push d
0085++ 0496 38 00 00    	mov c, 0
0086++ 0499             strlen_L1:
0087++ 0499 BD 00       	cmp byte [d], 0
0088++ 049B C6 A3 04    	je strlen_ret
0089++ 049E 79          	inc d
0090++ 049F 78          	inc c
0091++ 04A0 0A 99 04    	jmp strlen_L1
0092++ 04A3             strlen_ret:
0093++ 04A3 E7          	pop d
0094++ 04A4 09          	ret
0095++ 04A5             
0096++ 04A5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 04A5             ; STRCMP
0098++ 04A5             ; compare two strings
0099++ 04A5             ; str1 in SI
0100++ 04A5             ; str2 in DI
0101++ 04A5             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 04A5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 04A5             strcmp:
0104++ 04A5 DB          	push al
0105++ 04A6 DA          	push d
0106++ 04A7 E3          	push di
0107++ 04A8 E2          	push si
0108++ 04A9             strcmp_loop:
0109++ 04A9 F3          	cmpsb					; compare a byte of the strings
0110++ 04AA C7 B5 04    	jne strcmp_ret
0111++ 04AD FB FF FF    	lea d, [si +- 1]
0112++ 04B0 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 04B2 C7 A9 04    	jne strcmp_loop				; equal chars but not at end
0114++ 04B5             strcmp_ret:
0115++ 04B5 EF          	pop si
0116++ 04B6 F0          	pop di
0117++ 04B7 E7          	pop d
0118++ 04B8 E8          	pop al
0119++ 04B9 09          	ret
0120++ 04BA             
0121++ 04BA             
0122++ 04BA             ; STRCPY
0123++ 04BA             ; copy null terminated string from SI to DI
0124++ 04BA             ; source in SI
0125++ 04BA             ; destination in DI
0126++ 04BA             strcpy:
0127++ 04BA E2          	push si
0128++ 04BB E3          	push di
0129++ 04BC DB          	push al
0130++ 04BD             strcpy_L1:
0131++ 04BD F6          	lodsb
0132++ 04BE F7          	stosb
0133++ 04BF B9 00       	cmp al, 0
0134++ 04C1 C7 BD 04    	jne strcpy_L1
0135++ 04C4             strcpy_end:
0136++ 04C4 E8          	pop al
0137++ 04C5 F0          	pop di
0138++ 04C6 EF          	pop si
0139++ 04C7 09          	ret
0140++ 04C8             
0141++ 04C8             ; STRCAT
0142++ 04C8             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 04C8             ; source in SI
0144++ 04C8             ; destination in DI
0145++ 04C8             strcat:
0146++ 04C8 E2          	push si
0147++ 04C9 E3          	push di
0148++ 04CA D7          	push a
0149++ 04CB DA          	push d
0150++ 04CC 50          	mov a, di
0151++ 04CD 3C          	mov d, a
0152++ 04CE             strcat_goto_end_L1:
0153++ 04CE BD 00       	cmp byte[d], 0
0154++ 04D0 C6 D7 04    	je strcat_start
0155++ 04D3 79          	inc d
0156++ 04D4 0A CE 04    	jmp strcat_goto_end_L1
0157++ 04D7             strcat_start:
0158++ 04D7 FD 50       	mov di, d
0159++ 04D9             strcat_L1:
0160++ 04D9 F6          	lodsb
0161++ 04DA F7          	stosb
0162++ 04DB B9 00       	cmp al, 0
0163++ 04DD C7 D9 04    	jne strcat_L1
0164++ 04E0             strcat_end:
0165++ 04E0 E7          	pop d
0166++ 04E1 E4          	pop a
0167++ 04E2 F0          	pop di
0168++ 04E3 EF          	pop si
0169++ 04E4 09          	ret
0005+  04E5             
0006+  04E5 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  04E9 34 35 36 37 
0006+  04ED 38 39 41 42 
0006+  04F1 43 44 45 46 
0007+  04F5             
0008+  04F5 01 00       table_power:.dw 1
0009+  04F7 0A 00       			.dw 10
0010+  04F9 64 00       			.dw 100
0011+  04FB E8 03       			.dw 1000
0012+  04FD 10 27       			.dw 10000
0013+  04FF             
0014+  04FF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0015+  04FF             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0016+  04FF             ; ASCII in BL
0017+  04FF             ; result in AL
0018+  04FF             ; ascii for F = 0100 0110
0019+  04FF             ; ascii for 9 = 0011 1001
0020+  04FF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0021+  04FF             hex_ascii_encode:
0022+  04FF 1B          	mov al, bl
0023+  0500 93 40       	test al, $40				; test if letter or number
0024+  0502 C7 08 05    	jnz hex_letter
0025+  0505 87 0F       	and al, $0F				; get number
0026+  0507 09          	ret
0027+  0508             hex_letter:
0028+  0508 87 0F       	and al, $0F				; get letter
0029+  050A 6A 09       	add al, 9
0030+  050C 09          	ret
0031+  050D             
0032+  050D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0033+  050D             ; ATOI
0034+  050D             ; 2 letter hex string in B
0035+  050D             ; 8bit integer returned in AL
0036+  050D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0037+  050D             atoi:
0038+  050D D8          	push b
0039+  050E 07 FF 04    	call hex_ascii_encode			; convert BL to 4bit code in AL
0040+  0511 30          	mov bl, bh
0041+  0512 DB          	push al					; save a
0042+  0513 07 FF 04    	call hex_ascii_encode
0043+  0516 EA          	pop bl	
0044+  0517 FD 9E 04    	shl al, 4
0045+  051A 8C          	or al, bl
0046+  051B E5          	pop b
0047+  051C 09          	ret	
0048+  051D             
0049+  051D             
0050+  051D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  051D             ; printf
0052+  051D             ; no need for explanations!
0053+  051D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0054+  051D             printf:
0055+  051D 09          	ret
0056+  051E             
0057+  051E             
0058+  051E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  051E             ; scanf
0060+  051E             ; no need for explanations!
0061+  051E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  051E             scanf:
0063+  051E 09          	ret
0064+  051F             
0065+  051F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  051F             ; ITOA
0067+  051F             ; 8bit value in BL
0068+  051F             ; 2 byte ASCII result in A
0069+  051F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0070+  051F             itoa:
0071+  051F DA          	push d
0072+  0520 D8          	push b
0073+  0521 A7 00       	mov bh, 0
0074+  0523 FD A4 04    	shr bl, 4	
0075+  0526 74          	mov d, b
0076+  0527 1F E5 04    	mov al, [d + s_hex_digits]
0077+  052A 23          	mov ah, al
0078+  052B             	
0079+  052B E5          	pop b
0080+  052C D8          	push b
0081+  052D A7 00       	mov bh, 0
0082+  052F FD 87 0F    	and bl, $0F
0083+  0532 74          	mov d, b
0084+  0533 1F E5 04    	mov al, [d + s_hex_digits]
0085+  0536 E5          	pop b
0086+  0537 E7          	pop d
0087+  0538 09          	ret
0088+  0539             
0089+  0539             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0090+  0539             ; HEX STRING TO BINARY
0091+  0539             ; di = destination address
0092+  0539             ; si = source
0093+  0539             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0094+  0539             hex_to_int:
0095+  0539             hex_to_int_L1:
0096+  0539 F6          	lodsb					; load from [SI] to AL
0097+  053A B9 00       	cmp al, 0				; check if ASCII 0
0098+  053C C6 49 05    	jz hex_to_int_ret
0099+  053F 36          	mov bh, al
0100+  0540 F6          	lodsb
0101+  0541 2F          	mov bl, al
0102+  0542 07 0D 05    	call atoi				; convert ASCII byte in B to int (to AL)
0103+  0545 F7          	stosb					; store AL to [DI]
0104+  0546 0A 39 05    	jmp hex_to_int_L1
0105+  0549             hex_to_int_ret:
0106+  0549 09          	ret		
0107+  054A             
0108+  054A             
0109+  054A             
0110+  054A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  054A             ; GETCHAR
0112+  054A             ; char in ah
0113+  054A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0114+  054A             getchar:
0115+  054A DB          	push al
0116+  054B             getchar_retry:
0117+  054B FD 0C       	sti
0118+  054D 19 01       	mov al, 1
0119+  054F 05 03       	syscall sys_io			; receive in AH
0120+  0551 B9 00       	cmp al, 0			; check if any char was receive
0121+  0553 C6 4B 05    	je getchar_retry
0122+  0556 E8          	pop al
0123+  0557 09          	ret
0124+  0558             
0125+  0558             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0126+  0558             ; PUTCHAR
0127+  0558             ; char in ah
0128+  0558             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  0558             putchar:
0130+  0558 D7          	push a
0131+  0559 19 00       	mov al, 0
0132+  055B 05 03       	syscall sys_io			; char in AH
0133+  055D E4          	pop a
0134+  055E 09          	ret
0135+  055F             
0136+  055F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0137+  055F             ;; INPUT A STRING
0138+  055F             ;; terminates with null
0139+  055F             ;; pointer in D
0140+  055F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  055F             gets:
0142+  055F D7          	push a
0143+  0560 DA          	push d
0144+  0561             gets_loop:
0145+  0561 FD 0C       	sti
0146+  0563 19 01       	mov al, 1
0147+  0565 05 03       	syscall sys_io			; receive in AH
0148+  0567 B9 00       	cmp al, 0				; check error code (AL)
0149+  0569 C6 61 05    	je gets_loop			; if no char received, retry
0150+  056C             
0151+  056C 76 1B       	cmp ah, 27
0152+  056E C6 8A 05    	je gets_telnet_escape
0153+  0571 76 0A       	cmp ah, $0A				; LF
0154+  0573 C6 E3 05    	je gets_end
0155+  0576 76 5C       	cmp ah, $5C				; '\\'
0156+  0578 C6 BA 05    	je gets_escape
0157+  057B             	
0158+  057B 76 08       	cmp ah, $08			; check for backspace
0159+  057D C6 86 05    	je gets_backspace
0160+  0580             
0161+  0580 1A          	mov al, ah
0162+  0581 3E          	mov [d], al
0163+  0582 79          	inc d
0164+  0583 0A 61 05    	jmp gets_loop
0165+  0586             gets_backspace:
0166+  0586 7F          	dec d
0167+  0587 0A 61 05    	jmp gets_loop
0168+  058A             gets_telnet_escape:
0169+  058A FD 0C       	sti
0170+  058C 19 01       	mov al, 1
0171+  058E 05 03       	syscall sys_io				; receive in AH without echo
0172+  0590 B9 00       	cmp al, 0					; check error code (AL)
0173+  0592 C6 8A 05    	je gets_telnet_escape		; if no char received, retry
0174+  0595 76 5B       	cmp ah, '['
0175+  0597 C7 61 05    	jne gets_loop
0176+  059A             gets_telnet_escape_phase2:
0177+  059A FD 0C       	sti
0178+  059C 19 01       	mov al, 1
0179+  059E 05 03       	syscall sys_io					; receive in AH without echo
0180+  05A0 B9 00       	cmp al, 0						; check error code (AL)
0181+  05A2 C6 9A 05    	je gets_telnet_escape_phase2	; if no char received, retry
0182+  05A5 76 44       	cmp ah, 'D'
0183+  05A7 C6 B2 05    	je gets_left_arrow
0184+  05AA 76 43       	cmp ah, 'C'
0185+  05AC C6 B6 05    	je gets_right_arrow
0186+  05AF 0A 61 05    	jmp gets_loop
0187+  05B2             gets_left_arrow:
0188+  05B2 7F          	dec d
0189+  05B3 0A 61 05    	jmp gets_loop
0190+  05B6             gets_right_arrow:
0191+  05B6 79          	inc d
0192+  05B7 0A 61 05    	jmp gets_loop
0193+  05BA             gets_escape:
0194+  05BA FD 0C       	sti
0195+  05BC 19 01       	mov al, 1
0196+  05BE 05 03       	syscall sys_io			; receive in AH
0197+  05C0 B9 00       	cmp al, 0				; check error code (AL)
0198+  05C2 C6 BA 05    	je gets_escape			; if no char received, retry
0199+  05C5 76 6E       	cmp ah, 'n'
0200+  05C7 C6 D5 05    	je gets_LF
0201+  05CA 76 72       	cmp ah, 'r'
0202+  05CC C6 DC 05    	je gets_CR
0203+  05CF 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0204+  05D0 3E          	mov [d], al
0205+  05D1 79          	inc d
0206+  05D2 0A 61 05    	jmp gets_loop
0207+  05D5             gets_LF:
0208+  05D5 19 0A       	mov al, $0A
0209+  05D7 3E          	mov [d], al
0210+  05D8 79          	inc d
0211+  05D9 0A 61 05    	jmp gets_loop
0212+  05DC             gets_CR:
0213+  05DC 19 0D       	mov al, $0D
0214+  05DE 3E          	mov [d], al
0215+  05DF 79          	inc d
0216+  05E0 0A 61 05    	jmp gets_loop
0217+  05E3             gets_end:
0218+  05E3 19 00       	mov al, 0
0219+  05E5 3E          	mov [d], al				; terminate string
0220+  05E6 E7          	pop d
0221+  05E7 E4          	pop a
0222+  05E8 09          	ret
0223+  05E9             
0224+  05E9             
0225+  05E9             
0226+  05E9             
0227+  05E9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0228+  05E9             ;; INPUT TEXT
0229+  05E9             ;; terminated with CTRL+D
0230+  05E9             ;; pointer in D
0231+  05E9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0232+  05E9             gettxt:
0233+  05E9 D7          	push a
0234+  05EA DA          	push d
0235+  05EB             gettxt_loop:
0236+  05EB 19 01       	mov al, 1
0237+  05ED 05 03       	syscall sys_io			; receive in AH
0238+  05EF B9 00       	cmp al, 0				; check error code (AL)
0239+  05F1 C6 EB 05    	je gettxt_loop		; if no char received, retry
0240+  05F4 76 04       	cmp ah, 4			; EOT
0241+  05F6 C6 34 06    	je gettxt_end
0242+  05F9 76 08       	cmp ah, $08			; check for backspace
0243+  05FB C6 30 06    	je gettxt_backspace
0244+  05FE 76 5C       	cmp ah, $5C				; '\\'
0245+  0600 C6 09 06    	je gettxt_escape
0246+  0603 1A          	mov al, ah
0247+  0604 3E          	mov [d], al
0248+  0605 79          	inc d
0249+  0606 0A EB 05    	jmp gettxt_loop
0250+  0609             gettxt_escape:
0251+  0609 19 01       	mov al, 1
0252+  060B 05 03       	syscall sys_io			; receive in AH
0253+  060D B9 00       	cmp al, 0				; check error code (AL)
0254+  060F C6 09 06    	je gettxt_escape		; if no char received, retry
0255+  0612 76 6E       	cmp ah, 'n'
0256+  0614 C6 22 06    	je gettxt_LF
0257+  0617 76 72       	cmp ah, 'r'
0258+  0619 C6 29 06    	je gettxt_CR
0259+  061C 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0260+  061D 3E          	mov [d], al
0261+  061E 79          	inc d
0262+  061F 0A EB 05    	jmp gettxt_loop
0263+  0622             gettxt_LF:
0264+  0622 19 0A       	mov al, $0A
0265+  0624 3E          	mov [d], al
0266+  0625 79          	inc d
0267+  0626 0A EB 05    	jmp gettxt_loop
0268+  0629             gettxt_CR:
0269+  0629 19 0D       	mov al, $0D
0270+  062B 3E          	mov [d], al
0271+  062C 79          	inc d
0272+  062D 0A EB 05    	jmp gettxt_loop
0273+  0630             gettxt_backspace:
0274+  0630 7F          	dec d
0275+  0631 0A EB 05    	jmp gettxt_loop
0276+  0634             gettxt_end:
0277+  0634 19 00       	mov al, 0
0278+  0636 3E          	mov [d], al				; terminate string
0279+  0637 E7          	pop d
0280+  0638 E4          	pop a
0281+  0639 09          	ret
0282+  063A             
0283+  063A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0284+  063A             ; PRINT NEW LINE
0285+  063A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0286+  063A             printnl:
0287+  063A D7          	push a
0288+  063B 10 00 0A    	mov a, $0A00
0289+  063E 05 03       	syscall sys_io
0290+  0640 10 00 0D    	mov a, $0D00
0291+  0643 05 03       	syscall sys_io
0292+  0645 E4          	pop a
0293+  0646 09          	ret
0294+  0647             
0295+  0647             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0296+  0647             ; strtoint
0297+  0647             ; 4 digit hex string number in d
0298+  0647             ; integer returned in A
0299+  0647             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0300+  0647             strtointx:
0301+  0647 D8          	push b
0302+  0648 32          	mov bl, [d]
0303+  0649 37          	mov bh, bl
0304+  064A 33 01 00    	mov bl, [d + 1]
0305+  064D 07 0D 05    	call atoi				; convert to int in AL
0306+  0650 23          	mov ah, al				; move to AH
0307+  0651 33 02 00    	mov bl, [d + 2]
0308+  0654 37          	mov bh, bl
0309+  0655 33 03 00    	mov bl, [d + 3]
0310+  0658 07 0D 05    	call atoi				; convert to int in AL
0311+  065B E5          	pop b
0312+  065C 09          	ret
0313+  065D             
0314+  065D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0315+  065D             ; strtoint
0316+  065D             ; 5 digit base10 string number in d
0317+  065D             ; integer returned in A
0318+  065D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0319+  065D             strtoint:
0320+  065D E2          	push si
0321+  065E D8          	push b
0322+  065F D9          	push c
0323+  0660 DA          	push d
0324+  0661 07 95 04    	call strlen			; get string length in C
0325+  0664 7E          	dec c
0326+  0665 FD 4E       	mov si, d
0327+  0667 12          	mov a, c
0328+  0668 FD 99       	shl a
0329+  066A 3B F5 04    	mov d, table_power
0330+  066D 59          	add d, a
0331+  066E 38 00 00    	mov c, 0
0332+  0671             strtoint_L0:
0333+  0671 F6          	lodsb			; load ASCII to al
0334+  0672 B9 00       	cmp al, 0
0335+  0674 C6 87 06    	je strtoint_end
0336+  0677 6F 30       	sub al, $30		; make into integer
0337+  0679 22 00       	mov ah, 0
0338+  067B 2A          	mov b, [d]
0339+  067C AC          	mul a, b			; result in B since it fits in 16bits
0340+  067D 11          	mov a, b
0341+  067E 28          	mov b, c
0342+  067F 54          	add a, b
0343+  0680 39          	mov c, a
0344+  0681 63 02 00    	sub d, 2
0345+  0684 0A 71 06    	jmp strtoint_L0
0346+  0687             strtoint_end:
0347+  0687 12          	mov a, c
0348+  0688 E7          	pop d
0349+  0689 E6          	pop c
0350+  068A E5          	pop b
0351+  068B EF          	pop si
0352+  068C 09          	ret
0353+  068D             
0354+  068D             
0355+  068D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  068D             ; PRINT NULL TERMINATED STRING
0357+  068D             ; pointer in D
0358+  068D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  068D             puts:
0360+  068D D7          	push a
0361+  068E DA          	push d
0362+  068F             puts_L1:
0363+  068F 1E          	mov al, [d]
0364+  0690 B9 00       	cmp al, 0
0365+  0692 C6 9E 06    	jz puts_END
0366+  0695 23          	mov ah, al
0367+  0696 19 00       	mov al, 0
0368+  0698 05 03       	syscall sys_io
0369+  069A 79          	inc d
0370+  069B 0A 8F 06    	jmp puts_L1
0371+  069E             puts_END:
0372+  069E E7          	pop d
0373+  069F E4          	pop a
0374+  06A0 09          	ret
0375+  06A1             
0376+  06A1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0377+  06A1             ; PRINT N SIZE STRING
0378+  06A1             ; pointer in D
0379+  06A1             ; size in C
0380+  06A1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0381+  06A1             putsn:
0382+  06A1 DB          	push al
0383+  06A2 DA          	push d
0384+  06A3 D9          	push c
0385+  06A4             putsn_L0:
0386+  06A4 1E          	mov al, [d]
0387+  06A5 23          	mov ah, al
0388+  06A6 19 00       	mov al, 0
0389+  06A8 05 03       	syscall sys_io
0390+  06AA 79          	inc d
0391+  06AB 7E          	dec c	
0392+  06AC C2 00 00    	cmp c, 0
0393+  06AF C7 A4 06    	jne putsn_L0
0394+  06B2             putsn_end:
0395+  06B2 E6          	pop c
0396+  06B3 E7          	pop d
0397+  06B4 E8          	pop al
0398+  06B5 09          	ret
0399+  06B6             
0400+  06B6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0401+  06B6             ; print 16bit decimal number
0402+  06B6             ; input number in A
0403+  06B6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  06B6             print_u16d:
0405+  06B6 D7          	push a
0406+  06B7 D8          	push b
0407+  06B8 26 10 27    	mov b, 10000
0408+  06BB AE          	div a, b			; get 10000 coeff.
0409+  06BC 07 E2 06    	call print_zero_or_space
0410+  06BF 11          	mov a, b
0411+  06C0 26 E8 03    	mov b, 1000
0412+  06C3 AE          	div a, b			; get 10000 coeff.
0413+  06C4 07 E2 06    	call print_zero_or_space
0414+  06C7 11          	mov a, b
0415+  06C8 26 64 00    	mov b, 100
0416+  06CB AE          	div a, b
0417+  06CC 07 E2 06    	call print_zero_or_space
0418+  06CF 11          	mov a, b
0419+  06D0 26 0A 00    	mov b, 10
0420+  06D3 AE          	div a, b
0421+  06D4 07 E2 06    	call print_zero_or_space
0422+  06D7 11          	mov a, b
0423+  06D8 6A 30       	add al, $30
0424+  06DA 23          	mov ah, al
0425+  06DB 19 00       	mov al, 0
0426+  06DD 05 03       	syscall sys_io	; print coeff
0427+  06DF E5          	pop b
0428+  06E0 E4          	pop a
0429+  06E1 09          	ret
0430+  06E2             
0431+  06E2             
0432+  06E2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0433+  06E2             ; if A == 0, print space
0434+  06E2             ; else print A
0435+  06E2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  06E2             print_zero_or_space:
0437+  06E2             	; cmp a, 0
0438+  06E2             	; jne print_number
0439+  06E2             	; mov ah, $20
0440+  06E2             	; call putchar
0441+  06E2             	; ret
0442+  06E2             print_number:
0443+  06E2 6A 30       	add al, $30
0444+  06E4 23          	mov ah, al
0445+  06E5 07 58 05    	call putchar
0446+  06E8 09          	ret
0447+  06E9             
0448+  06E9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  06E9             ; PRINT 16BIT HEX INTEGER
0450+  06E9             ; integer value in reg B
0451+  06E9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0452+  06E9             print_u16x:
0453+  06E9 D7          	push a
0454+  06EA D8          	push b
0455+  06EB DD          	push bl
0456+  06EC 30          	mov bl, bh
0457+  06ED 07 1F 05    	call itoa				; convert bh to char in A
0458+  06F0 2F          	mov bl, al				; save al
0459+  06F1 19 00       	mov al, 0
0460+  06F3 05 03       	syscall sys_io				; display AH
0461+  06F5 24          	mov ah, bl				; retrieve al
0462+  06F6 19 00       	mov al, 0
0463+  06F8 05 03       	syscall sys_io				; display AL
0464+  06FA             
0465+  06FA EA          	pop bl
0466+  06FB 07 1F 05    	call itoa				; convert bh to char in A
0467+  06FE 2F          	mov bl, al				; save al
0468+  06FF 19 00       	mov al, 0
0469+  0701 05 03       	syscall sys_io				; display AH
0470+  0703 24          	mov ah, bl				; retrieve al
0471+  0704 19 00       	mov al, 0
0472+  0706 05 03       	syscall sys_io				; display AL
0473+  0708             
0474+  0708 E5          	pop b
0475+  0709 E4          	pop a
0476+  070A 09          	ret
0477+  070B             
0478+  070B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  070B             ; INPUT 16BIT HEX INTEGER
0480+  070B             ; read 16bit integer into A
0481+  070B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0482+  070B             scan_u16x:
0483+  070B F8 10 00    	enter 16
0484+  070E D8          	push b
0485+  070F DA          	push d
0486+  0710             
0487+  0710 FA F1 FF    	lea d, [bp + -15]
0488+  0713 07 5F 05    	call gets				; get number
0489+  0716             
0490+  0716 32          	mov bl, [d]
0491+  0717 37          	mov bh, bl
0492+  0718 33 01 00    	mov bl, [d + 1]
0493+  071B 07 0D 05    	call atoi				; convert to int in AL
0494+  071E 23          	mov ah, al				; move to AH
0495+  071F             
0496+  071F 33 02 00    	mov bl, [d + 2]
0497+  0722 37          	mov bh, bl
0498+  0723 33 03 00    	mov bl, [d + 3]
0499+  0726 07 0D 05    	call atoi				; convert to int in AL
0500+  0729             
0501+  0729 E7          	pop d
0502+  072A E5          	pop b
0503+  072B F9          	leave
0504+  072C 09          	ret
0505+  072D             
0506+  072D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  072D             ; PRINT 8bit HEX INTEGER
0508+  072D             ; integer value in reg bl
0509+  072D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0510+  072D             print_u8x:
0511+  072D D7          	push a
0512+  072E DD          	push bl
0513+  072F             
0514+  072F 07 1F 05    	call itoa				; convert bl to char in A
0515+  0732 2F          	mov bl, al				; save al
0516+  0733 19 00       	mov al, 0
0517+  0735 05 03       	syscall sys_io				; display AH
0518+  0737 24          	mov ah, bl				; retrieve al
0519+  0738 19 00       	mov al, 0
0520+  073A 05 03       	syscall sys_io				; display AL
0521+  073C             
0522+  073C EA          	pop bl
0523+  073D E4          	pop a
0524+  073E 09          	ret
0525+  073F             
0526+  073F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  073F             ; print 8bit decimal unsigned number
0528+  073F             ; input number in AL
0529+  073F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0530+  073F             print_u8d:
0531+  073F D7          	push a
0532+  0740 D8          	push b
0533+  0741             
0534+  0741 22 00       	mov ah, 0
0535+  0743 26 64 00    	mov b, 100
0536+  0746 AE          	div a, b
0537+  0747 D8          	push b			; save remainder
0538+  0748 B9 00       	cmp al, 0
0539+  074A C6 54 07    	je skip100
0540+  074D 6A 30       	add al, $30
0541+  074F 23          	mov ah, al
0542+  0750 19 00       	mov al, 0
0543+  0752 05 03       	syscall sys_io	; print coeff
0544+  0754             skip100:
0545+  0754 E4          	pop a
0546+  0755 22 00       	mov ah, 0
0547+  0757 26 0A 00    	mov b, 10
0548+  075A AE          	div a, b
0549+  075B D8          	push b			; save remainder
0550+  075C B9 00       	cmp al, 0
0551+  075E C6 68 07    	je skip10
0552+  0761 6A 30       	add al, $30
0553+  0763 23          	mov ah, al
0554+  0764 19 00       	mov al, 0
0555+  0766 05 03       	syscall sys_io	; print coeff
0556+  0768             skip10:
0557+  0768 E4          	pop a
0558+  0769 1B          	mov al, bl
0559+  076A 6A 30       	add al, $30
0560+  076C 23          	mov ah, al
0561+  076D 19 00       	mov al, 0
0562+  076F 05 03       	syscall sys_io	; print coeff
0563+  0771 E5          	pop b
0564+  0772 E4          	pop a
0565+  0773 09          	ret
0566+  0774             
0567+  0774             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  0774             ; INPUT 8BIT HEX INTEGER
0569+  0774             ; read 8bit integer into AL
0570+  0774             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0571+  0774             scan_u8x:
0572+  0774 F8 04 00    	enter 4
0573+  0777 D8          	push b
0574+  0778 DA          	push d
0575+  0779             
0576+  0779 FA FD FF    	lea d, [bp + -3]
0577+  077C 07 5F 05    	call gets				; get number
0578+  077F             
0579+  077F 32          	mov bl, [d]
0580+  0780 37          	mov bh, bl
0581+  0781 33 01 00    	mov bl, [d + 1]
0582+  0784 07 0D 05    	call atoi				; convert to int in AL
0583+  0787             
0584+  0787 E7          	pop d
0585+  0788 E5          	pop b
0586+  0789 F9          	leave
0587+  078A 09          	ret
0588+  078B             
0589+  078B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0590+  078B             ; input decimal number
0591+  078B             ; result in A
0592+  078B             ; 655'\0'
0593+  078B             ; low--------high
0594+  078B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0595+  078B             scan_u16d:
0596+  078B F8 08 00    	enter 8
0597+  078E E2          	push si
0598+  078F D8          	push b
0599+  0790 D9          	push c
0600+  0791 DA          	push d
0601+  0792 FA F9 FF    	lea d, [bp +- 7]
0602+  0795 07 5F 05    	call gets
0603+  0798 07 95 04    	call strlen			; get string length in C
0604+  079B 7E          	dec c
0605+  079C FD 4E       	mov si, d
0606+  079E 12          	mov a, c
0607+  079F FD 99       	shl a
0608+  07A1 3B F5 04    	mov d, table_power
0609+  07A4 59          	add d, a
0610+  07A5 38 00 00    	mov c, 0
0611+  07A8             mul_loop:
0612+  07A8 F6          	lodsb			; load ASCII to al
0613+  07A9 B9 00       	cmp al, 0
0614+  07AB C6 BE 07    	je mul_exit
0615+  07AE 6F 30       	sub al, $30		; make into integer
0616+  07B0 22 00       	mov ah, 0
0617+  07B2 2A          	mov b, [d]
0618+  07B3 AC          	mul a, b			; result in B since it fits in 16bits
0619+  07B4 11          	mov a, b
0620+  07B5 28          	mov b, c
0621+  07B6 54          	add a, b
0622+  07B7 39          	mov c, a
0623+  07B8 63 02 00    	sub d, 2
0624+  07BB 0A A8 07    	jmp mul_loop
0625+  07BE             mul_exit:
0626+  07BE 12          	mov a, c
0627+  07BF E7          	pop d
0628+  07C0 E6          	pop c
0629+  07C1 E5          	pop b
0630+  07C2 EF          	pop si
0631+  07C3 F9          	leave
0632+  07C4 09          	ret
0032   07C5             
0033   07C5             .end
tasm: Number of errors = 0
