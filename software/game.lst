0001   0000             .include "kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0002   0000             
0003   0000             main:
0004   0000 3B A0 00    	mov d, s_clear
0005   0003 07 97 07    	call puts
0006   0006             
0007   0006             main_L0:
0008   0006 07 54 06    	call getchar
0009   0009 76 71       	cmp ah, 'q'
0010   000B C6 81 00    	je quit
0011   000E 07 54 06    	call getchar
0012   0011 07 54 06    	call getchar
0013   0014             	
0014   0014 76 41       	cmp ah, $41
0015   0016 C6 55 00    	je go_up
0016   0019             
0017   0019 76 42       	cmp ah, $42
0018   001B C6 61 00    	je go_down
0019   001E             
0020   001E 76 43       	cmp ah, $43
0021   0020 C6 6D 00    	je go_right
0022   0023             	
0023   0023 76 44       	cmp ah, $44
0024   0025 C6 77 00    	je go_left
0025   0028             
0026   0028             back:
0027   0028             ; calculate	array position for Y coordinate
0028   0028 14 86 00    	mov a, [pos]
0029   002B 3B A8 00    	mov d, buffer
0030   002E 59          	add d, a
0031   002F 19 40       	mov al, '@'
0032   0031 3E          	mov [d], al
0033   0032             
0034   0032 3B A0 00    	mov d, s_clear
0035   0035 07 97 07    	call puts
0036   0038             
0037   0038 3B A8 00    	mov d, buffer
0038   003B 26 00 00    	mov b, 0
0039   003E             loop:
0040   003E 38 3C 00    	mov c, width
0041   0041 07 AB 07    	call putsn
0042   0044 07 44 07    	call printnl
0043   0047 58 3C 00    	add d, width
0044   004A FD 77       	inc b
0045   004C C0 14 00    	cmp b, height
0046   004F C7 3E 00    	jne loop
0047   0052             
0048   0052 0A 06 00    	jmp main_L0
0049   0055             
0050   0055             go_up:
0051   0055 14 86 00    	mov a, [pos]
0052   0058 5F 3C 00    	sub a, width
0053   005B 42 86 00    	mov [pos], a
0054   005E 0A 28 00    	jmp back
0055   0061             go_down:
0056   0061 14 86 00    	mov a, [pos]
0057   0064 53 3C 00    	add a, width
0058   0067 42 86 00    	mov [pos], a
0059   006A 0A 28 00    	jmp back
0060   006D             
0061   006D             go_right:
0062   006D 14 86 00    	mov a, [pos]
0063   0070 77          	inc a
0064   0071 42 86 00    	mov [pos], a
0065   0074 0A 28 00    	jmp back
0066   0077             
0067   0077             go_left:
0068   0077 14 86 00    	mov a, [pos]
0069   007A 7D          	dec a
0070   007B 42 86 00    	mov [pos], a
0071   007E 0A 28 00    	jmp back
0072   0081             
0073   0081             quit:
0074   0081 09          	ret
0075   0082             
0076   0082             width: 			.equ 60
0077   0082             height:			.equ 20
0078   0082             
0079   0082 00 00       x:				.dw 0
0080   0084 00 00       y:				.dw 0
0081   0086             
0082   0086 00 00       pos:			.dw 0
0083   0088             
0084   0088             
0085   0088 FF FF FF FF choice:			.fill 20
0085   008C FF FF FF FF 
0085   0090 FF FF FF FF 
0085   0094 FF FF FF FF 
0085   0098 FF FF FF FF 
0086   009C             
0087   009C             
0088   009C 41          s_up:			.db $41
0089   009D 42          s_down:			.db $42
0090   009E 43          s_right:		.db $43
0091   009F 44          s_left:			.db $44
0092   00A0             
0093   00A0 1B 5B 32 4A s_clear:		.db 27, "[2J", 27, "[H", 0
0093   00A4 1B 5B 48 00 
0094   00A8             
0095   00A8 20 20 20 20 buffer:			.fill 1200, ' '
0095   00AC 20 20 20 20 
0095   00B0 20 20 20 20 
0095   00B4 20 20 20 20 
0095   00B8 20 20 20 20 
0095   00BC 20 20 20 20 
0095   00C0 20 20 20 20 
0095   00C4 20 20 20 20 
0095   00C8 20 20 20 20 
0095   00CC 20 20 20 20 
0095   00D0 20 20 20 20 
0095   00D4 20 20 20 20 
0095   00D8 20 20 20 20 
0095   00DC 20 20 20 20 
0095   00E0 20 20 20 20 
0095   00E4 20 20 20 20 
0095   00E8 20 20 20 20 
0095   00EC 20 20 20 20 
0095   00F0 20 20 20 20 
0095   00F4 20 20 20 20 
0095   00F8 20 20 20 20 
0095   00FC 20 20 20 20 
0095   0100 20 20 20 20 
0095   0104 20 20 20 20 
0095   0108 20 20 20 20 
0095   010C 20 20 20 20 
0095   0110 20 20 20 20 
0095   0114 20 20 20 20 
0095   0118 20 20 20 20 
0095   011C 20 20 20 20 
0095   0120 20 20 20 20 
0095   0124 20 20 20 20 
0095   0128 20 20 20 20 
0095   012C 20 20 20 20 
0095   0130 20 20 20 20 
0095   0134 20 20 20 20 
0095   0138 20 20 20 20 
0095   013C 20 20 20 20 
0095   0140 20 20 20 20 
0095   0144 20 20 20 20 
0095   0148 20 20 20 20 
0095   014C 20 20 20 20 
0095   0150 20 20 20 20 
0095   0154 20 20 20 20 
0095   0158 20 20 20 20 
0095   015C 20 20 20 20 
0095   0160 20 20 20 20 
0095   0164 20 20 20 20 
0095   0168 20 20 20 20 
0095   016C 20 20 20 20 
0095   0170 20 20 20 20 
0095   0174 20 20 20 20 
0095   0178 20 20 20 20 
0095   017C 20 20 20 20 
0095   0180 20 20 20 20 
0095   0184 20 20 20 20 
0095   0188 20 20 20 20 
0095   018C 20 20 20 20 
0095   0190 20 20 20 20 
0095   0194 20 20 20 20 
0095   0198 20 20 20 20 
0095   019C 20 20 20 20 
0095   01A0 20 20 20 20 
0095   01A4 20 20 20 20 
0095   01A8 20 20 20 20 
0095   01AC 20 20 20 20 
0095   01B0 20 20 20 20 
0095   01B4 20 20 20 20 
0095   01B8 20 20 20 20 
0095   01BC 20 20 20 20 
0095   01C0 20 20 20 20 
0095   01C4 20 20 20 20 
0095   01C8 20 20 20 20 
0095   01CC 20 20 20 20 
0095   01D0 20 20 20 20 
0095   01D4 20 20 20 20 
0095   01D8 20 20 20 20 
0095   01DC 20 20 20 20 
0095   01E0 20 20 20 20 
0095   01E4 20 20 20 20 
0095   01E8 20 20 20 20 
0095   01EC 20 20 20 20 
0095   01F0 20 20 20 20 
0095   01F4 20 20 20 20 
0095   01F8 20 20 20 20 
0095   01FC 20 20 20 20 
0095   0200 20 20 20 20 
0095   0204 20 20 20 20 
0095   0208 20 20 20 20 
0095   020C 20 20 20 20 
0095   0210 20 20 20 20 
0095   0214 20 20 20 20 
0095   0218 20 20 20 20 
0095   021C 20 20 20 20 
0095   0220 20 20 20 20 
0095   0224 20 20 20 20 
0095   0228 20 20 20 20 
0095   022C 20 20 20 20 
0095   0230 20 20 20 20 
0095   0234 20 20 20 20 
0095   0238 20 20 20 20 
0095   023C 20 20 20 20 
0095   0240 20 20 20 20 
0095   0244 20 20 20 20 
0095   0248 20 20 20 20 
0095   024C 20 20 20 20 
0095   0250 20 20 20 20 
0095   0254 20 20 20 20 
0095   0258 20 20 20 20 
0095   025C 20 20 20 20 
0095   0260 20 20 20 20 
0095   0264 20 20 20 20 
0095   0268 20 20 20 20 
0095   026C 20 20 20 20 
0095   0270 20 20 20 20 
0095   0274 20 20 20 20 
0095   0278 20 20 20 20 
0095   027C 20 20 20 20 
0095   0280 20 20 20 20 
0095   0284 20 20 20 20 
0095   0288 20 20 20 20 
0095   028C 20 20 20 20 
0095   0290 20 20 20 20 
0095   0294 20 20 20 20 
0095   0298 20 20 20 20 
0095   029C 20 20 20 20 
0095   02A0 20 20 20 20 
0095   02A4 20 20 20 20 
0095   02A8 20 20 20 20 
0095   02AC 20 20 20 20 
0095   02B0 20 20 20 20 
0095   02B4 20 20 20 20 
0095   02B8 20 20 20 20 
0095   02BC 20 20 20 20 
0095   02C0 20 20 20 20 
0095   02C4 20 20 20 20 
0095   02C8 20 20 20 20 
0095   02CC 20 20 20 20 
0095   02D0 20 20 20 20 
0095   02D4 20 20 20 20 
0095   02D8 20 20 20 20 
0095   02DC 20 20 20 20 
0095   02E0 20 20 20 20 
0095   02E4 20 20 20 20 
0095   02E8 20 20 20 20 
0095   02EC 20 20 20 20 
0095   02F0 20 20 20 20 
0095   02F4 20 20 20 20 
0095   02F8 20 20 20 20 
0095   02FC 20 20 20 20 
0095   0300 20 20 20 20 
0095   0304 20 20 20 20 
0095   0308 20 20 20 20 
0095   030C 20 20 20 20 
0095   0310 20 20 20 20 
0095   0314 20 20 20 20 
0095   0318 20 20 20 20 
0095   031C 20 20 20 20 
0095   0320 20 20 20 20 
0095   0324 20 20 20 20 
0095   0328 20 20 20 20 
0095   032C 20 20 20 20 
0095   0330 20 20 20 20 
0095   0334 20 20 20 20 
0095   0338 20 20 20 20 
0095   033C 20 20 20 20 
0095   0340 20 20 20 20 
0095   0344 20 20 20 20 
0095   0348 20 20 20 20 
0095   034C 20 20 20 20 
0095   0350 20 20 20 20 
0095   0354 20 20 20 20 
0095   0358 20 20 20 20 
0095   035C 20 20 20 20 
0095   0360 20 20 20 20 
0095   0364 20 20 20 20 
0095   0368 20 20 20 20 
0095   036C 20 20 20 20 
0095   0370 20 20 20 20 
0095   0374 20 20 20 20 
0095   0378 20 20 20 20 
0095   037C 20 20 20 20 
0095   0380 20 20 20 20 
0095   0384 20 20 20 20 
0095   0388 20 20 20 20 
0095   038C 20 20 20 20 
0095   0390 20 20 20 20 
0095   0394 20 20 20 20 
0095   0398 20 20 20 20 
0095   039C 20 20 20 20 
0095   03A0 20 20 20 20 
0095   03A4 20 20 20 20 
0095   03A8 20 20 20 20 
0095   03AC 20 20 20 20 
0095   03B0 20 20 20 20 
0095   03B4 20 20 20 20 
0095   03B8 20 20 20 20 
0095   03BC 20 20 20 20 
0095   03C0 20 20 20 20 
0095   03C4 20 20 20 20 
0095   03C8 20 20 20 20 
0095   03CC 20 20 20 20 
0095   03D0 20 20 20 20 
0095   03D4 20 20 20 20 
0095   03D8 20 20 20 20 
0095   03DC 20 20 20 20 
0095   03E0 20 20 20 20 
0095   03E4 20 20 20 20 
0095   03E8 20 20 20 20 
0095   03EC 20 20 20 20 
0095   03F0 20 20 20 20 
0095   03F4 20 20 20 20 
0095   03F8 20 20 20 20 
0095   03FC 20 20 20 20 
0095   0400 20 20 20 20 
0095   0404 20 20 20 20 
0095   0408 20 20 20 20 
0095   040C 20 20 20 20 
0095   0410 20 20 20 20 
0095   0414 20 20 20 20 
0095   0418 20 20 20 20 
0095   041C 20 20 20 20 
0095   0420 20 20 20 20 
0095   0424 20 20 20 20 
0095   0428 20 20 20 20 
0095   042C 20 20 20 20 
0095   0430 20 20 20 20 
0095   0434 20 20 20 20 
0095   0438 20 20 20 20 
0095   043C 20 20 20 20 
0095   0440 20 20 20 20 
0095   0444 20 20 20 20 
0095   0448 20 20 20 20 
0095   044C 20 20 20 20 
0095   0450 20 20 20 20 
0095   0454 20 20 20 20 
0095   0458 20 20 20 20 
0095   045C 20 20 20 20 
0095   0460 20 20 20 20 
0095   0464 20 20 20 20 
0095   0468 20 20 20 20 
0095   046C 20 20 20 20 
0095   0470 20 20 20 20 
0095   0474 20 20 20 20 
0095   0478 20 20 20 20 
0095   047C 20 20 20 20 
0095   0480 20 20 20 20 
0095   0484 20 20 20 20 
0095   0488 20 20 20 20 
0095   048C 20 20 20 20 
0095   0490 20 20 20 20 
0095   0494 20 20 20 20 
0095   0498 20 20 20 20 
0095   049C 20 20 20 20 
0095   04A0 20 20 20 20 
0095   04A4 20 20 20 20 
0095   04A8 20 20 20 20 
0095   04AC 20 20 20 20 
0095   04B0 20 20 20 20 
0095   04B4 20 20 20 20 
0095   04B8 20 20 20 20 
0095   04BC 20 20 20 20 
0095   04C0 20 20 20 20 
0095   04C4 20 20 20 20 
0095   04C8 20 20 20 20 
0095   04CC 20 20 20 20 
0095   04D0 20 20 20 20 
0095   04D4 20 20 20 20 
0095   04D8 20 20 20 20 
0095   04DC 20 20 20 20 
0095   04E0 20 20 20 20 
0095   04E4 20 20 20 20 
0095   04E8 20 20 20 20 
0095   04EC 20 20 20 20 
0095   04F0 20 20 20 20 
0095   04F4 20 20 20 20 
0095   04F8 20 20 20 20 
0095   04FC 20 20 20 20 
0095   0500 20 20 20 20 
0095   0504 20 20 20 20 
0095   0508 20 20 20 20 
0095   050C 20 20 20 20 
0095   0510 20 20 20 20 
0095   0514 20 20 20 20 
0095   0518 20 20 20 20 
0095   051C 20 20 20 20 
0095   0520 20 20 20 20 
0095   0524 20 20 20 20 
0095   0528 20 20 20 20 
0095   052C 20 20 20 20 
0095   0530 20 20 20 20 
0095   0534 20 20 20 20 
0095   0538 20 20 20 20 
0095   053C 20 20 20 20 
0095   0540 20 20 20 20 
0095   0544 20 20 20 20 
0095   0548 20 20 20 20 
0095   054C 20 20 20 20 
0095   0550 20 20 20 20 
0095   0554 20 20 20 20 
0096   0558             
0097   0558             .include "stdio.asm"
0001+  0558             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0558             ; stdio.s
0003+  0558             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0558             .include "string.asm"
0001++ 0558             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0558             ; string.s
0003++ 0558             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0558             
0005++ 0558             
0006++ 0558             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0558             ; strrev
0008++ 0558             ; reverse a string
0009++ 0558             ; D = string address
0010++ 0558             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0558             ; 01234
0012++ 0558             strrev:
0013++ 0558 4B          	pusha
0014++ 0559 07 9F 05    	call strlen	; length in C
0015++ 055C 12          	mov a, c
0016++ 055D AF 01 00    	cmp a, 1
0017++ 0560 D0 7A 05    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0563 7D          	dec a
0019++ 0564 FD 4E       	mov si, d	; beginning of string
0020++ 0566 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0568 59          	add d, a	; end of string
0022++ 0569 12          	mov a, c
0023++ 056A FD 9B       	shr a		; divide by 2
0024++ 056C 39          	mov c, a	; C now counts the steps
0025++ 056D             strrev_L0:
0026++ 056D 32          	mov bl, [d]	; save load right-side char into BL
0027++ 056E F6          	lodsb		; load left-side char into AL; increase SI
0028++ 056F 3E          	mov [d], al	; store left char into right side
0029++ 0570 1B          	mov al, bl
0030++ 0571 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0572 7E          	dec c
0032++ 0573 7F          	dec d
0033++ 0574 C2 00 00    	cmp c, 0
0034++ 0577 C7 6D 05    	jne strrev_L0
0035++ 057A             strrev_end:
0036++ 057A 4C          	popa
0037++ 057B 09          	ret
0038++ 057C             	
0039++ 057C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 057C             ; strchr
0041++ 057C             ; search string in D for char in AL
0042++ 057C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 057C             strchr:
0044++ 057C             strchr_L0:
0045++ 057C 32          	mov bl, [d]
0046++ 057D C1 00       	cmp bl, 0
0047++ 057F C6 8A 05    	je strchr_end
0048++ 0582 BA          	cmp al, bl
0049++ 0583 C6 8A 05    	je strchr_end
0050++ 0586 79          	inc d
0051++ 0587 0A 7C 05    	jmp strchr_L0
0052++ 058A             strchr_end:
0053++ 058A 1B          	mov al, bl
0054++ 058B 09          	ret
0055++ 058C             
0056++ 058C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 058C             ; strstr
0058++ 058C             ; find sub-string
0059++ 058C             ; str1 in SI
0060++ 058C             ; str2 in DI
0061++ 058C             ; SI points to end of source string
0062++ 058C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 058C             strstr:
0064++ 058C DB          	push al
0065++ 058D DA          	push d
0066++ 058E E3          	push di
0067++ 058F             strstr_loop:
0068++ 058F F3          	cmpsb					; compare a byte of the strings
0069++ 0590 C7 9B 05    	jne strstr_ret
0070++ 0593 FC 00 00    	lea d, [di + 0]
0071++ 0596 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0598 C7 8F 05    	jne strstr_loop				; equal chars but not at end
0073++ 059B             strstr_ret:
0074++ 059B F0          	pop di
0075++ 059C E7          	pop d
0076++ 059D E8          	pop al
0077++ 059E 09          	ret
0078++ 059F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 059F             ; length of null terminated string
0080++ 059F             ; result in C
0081++ 059F             ; pointer in D
0082++ 059F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 059F             strlen:
0084++ 059F DA          	push d
0085++ 05A0 38 00 00    	mov c, 0
0086++ 05A3             strlen_L1:
0087++ 05A3 BD 00       	cmp byte [d], 0
0088++ 05A5 C6 AD 05    	je strlen_ret
0089++ 05A8 79          	inc d
0090++ 05A9 78          	inc c
0091++ 05AA 0A A3 05    	jmp strlen_L1
0092++ 05AD             strlen_ret:
0093++ 05AD E7          	pop d
0094++ 05AE 09          	ret
0095++ 05AF             
0096++ 05AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 05AF             ; STRCMP
0098++ 05AF             ; compare two strings
0099++ 05AF             ; str1 in SI
0100++ 05AF             ; str2 in DI
0101++ 05AF             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 05AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 05AF             strcmp:
0104++ 05AF DB          	push al
0105++ 05B0 DA          	push d
0106++ 05B1 E3          	push di
0107++ 05B2 E2          	push si
0108++ 05B3             strcmp_loop:
0109++ 05B3 F3          	cmpsb					; compare a byte of the strings
0110++ 05B4 C7 BF 05    	jne strcmp_ret
0111++ 05B7 FB FF FF    	lea d, [si +- 1]
0112++ 05BA BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 05BC C7 B3 05    	jne strcmp_loop				; equal chars but not at end
0114++ 05BF             strcmp_ret:
0115++ 05BF EF          	pop si
0116++ 05C0 F0          	pop di
0117++ 05C1 E7          	pop d
0118++ 05C2 E8          	pop al
0119++ 05C3 09          	ret
0120++ 05C4             
0121++ 05C4             
0122++ 05C4             ; STRCPY
0123++ 05C4             ; copy null terminated string from SI to DI
0124++ 05C4             ; source in SI
0125++ 05C4             ; destination in DI
0126++ 05C4             strcpy:
0127++ 05C4 E2          	push si
0128++ 05C5 E3          	push di
0129++ 05C6 DB          	push al
0130++ 05C7             strcpy_L1:
0131++ 05C7 F6          	lodsb
0132++ 05C8 F7          	stosb
0133++ 05C9 B9 00       	cmp al, 0
0134++ 05CB C7 C7 05    	jne strcpy_L1
0135++ 05CE             strcpy_end:
0136++ 05CE E8          	pop al
0137++ 05CF F0          	pop di
0138++ 05D0 EF          	pop si
0139++ 05D1 09          	ret
0140++ 05D2             
0141++ 05D2             ; STRCAT
0142++ 05D2             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 05D2             ; source in SI
0144++ 05D2             ; destination in DI
0145++ 05D2             strcat:
0146++ 05D2 E2          	push si
0147++ 05D3 E3          	push di
0148++ 05D4 D7          	push a
0149++ 05D5 DA          	push d
0150++ 05D6 50          	mov a, di
0151++ 05D7 3C          	mov d, a
0152++ 05D8             strcat_goto_end_L1:
0153++ 05D8 BD 00       	cmp byte[d], 0
0154++ 05DA C6 E1 05    	je strcat_start
0155++ 05DD 79          	inc d
0156++ 05DE 0A D8 05    	jmp strcat_goto_end_L1
0157++ 05E1             strcat_start:
0158++ 05E1 FD 50       	mov di, d
0159++ 05E3             strcat_L1:
0160++ 05E3 F6          	lodsb
0161++ 05E4 F7          	stosb
0162++ 05E5 B9 00       	cmp al, 0
0163++ 05E7 C7 E3 05    	jne strcat_L1
0164++ 05EA             strcat_end:
0165++ 05EA E7          	pop d
0166++ 05EB E4          	pop a
0167++ 05EC F0          	pop di
0168++ 05ED EF          	pop si
0169++ 05EE 09          	ret
0005+  05EF             
0006+  05EF 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  05F3 34 35 36 37 
0006+  05F7 38 39 41 42 
0006+  05FB 43 44 45 46 
0007+  05FF             
0008+  05FF 01 00       table_power:.dw 1
0009+  0601 0A 00       			.dw 10
0010+  0603 64 00       			.dw 100
0011+  0605 E8 03       			.dw 1000
0012+  0607 10 27       			.dw 10000
0013+  0609             
0014+  0609             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0015+  0609             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0016+  0609             ; ASCII in BL
0017+  0609             ; result in AL
0018+  0609             ; ascii for F = 0100 0110
0019+  0609             ; ascii for 9 = 0011 1001
0020+  0609             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0021+  0609             hex_ascii_encode:
0022+  0609 1B          	mov al, bl
0023+  060A 93 40       	test al, $40				; test if letter or number
0024+  060C C7 12 06    	jnz hex_letter
0025+  060F 87 0F       	and al, $0F				; get number
0026+  0611 09          	ret
0027+  0612             hex_letter:
0028+  0612 87 0F       	and al, $0F				; get letter
0029+  0614 6A 09       	add al, 9
0030+  0616 09          	ret
0031+  0617             
0032+  0617             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0033+  0617             ; ATOI
0034+  0617             ; 2 letter hex string in B
0035+  0617             ; 8bit integer returned in AL
0036+  0617             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0037+  0617             atoi:
0038+  0617 D8          	push b
0039+  0618 07 09 06    	call hex_ascii_encode			; convert BL to 4bit code in AL
0040+  061B 30          	mov bl, bh
0041+  061C DB          	push al					; save a
0042+  061D 07 09 06    	call hex_ascii_encode
0043+  0620 EA          	pop bl	
0044+  0621 FD 9E 04    	shl al, 4
0045+  0624 8C          	or al, bl
0046+  0625 E5          	pop b
0047+  0626 09          	ret	
0048+  0627             
0049+  0627             
0050+  0627             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  0627             ; printf
0052+  0627             ; no need for explanations!
0053+  0627             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0054+  0627             printf:
0055+  0627 09          	ret
0056+  0628             
0057+  0628             
0058+  0628             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  0628             ; scanf
0060+  0628             ; no need for explanations!
0061+  0628             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  0628             scanf:
0063+  0628 09          	ret
0064+  0629             
0065+  0629             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  0629             ; ITOA
0067+  0629             ; 8bit value in BL
0068+  0629             ; 2 byte ASCII result in A
0069+  0629             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0070+  0629             itoa:
0071+  0629 DA          	push d
0072+  062A D8          	push b
0073+  062B A7 00       	mov bh, 0
0074+  062D FD A4 04    	shr bl, 4	
0075+  0630 74          	mov d, b
0076+  0631 1F EF 05    	mov al, [d + s_hex_digits]
0077+  0634 23          	mov ah, al
0078+  0635             	
0079+  0635 E5          	pop b
0080+  0636 D8          	push b
0081+  0637 A7 00       	mov bh, 0
0082+  0639 FD 87 0F    	and bl, $0F
0083+  063C 74          	mov d, b
0084+  063D 1F EF 05    	mov al, [d + s_hex_digits]
0085+  0640 E5          	pop b
0086+  0641 E7          	pop d
0087+  0642 09          	ret
0088+  0643             
0089+  0643             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0090+  0643             ; HEX STRING TO BINARY
0091+  0643             ; di = destination address
0092+  0643             ; si = source
0093+  0643             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0094+  0643             hex_to_int:
0095+  0643             hex_to_int_L1:
0096+  0643 F6          	lodsb					; load from [SI] to AL
0097+  0644 B9 00       	cmp al, 0				; check if ASCII 0
0098+  0646 C6 53 06    	jz hex_to_int_ret
0099+  0649 36          	mov bh, al
0100+  064A F6          	lodsb
0101+  064B 2F          	mov bl, al
0102+  064C 07 17 06    	call atoi				; convert ASCII byte in B to int (to AL)
0103+  064F F7          	stosb					; store AL to [DI]
0104+  0650 0A 43 06    	jmp hex_to_int_L1
0105+  0653             hex_to_int_ret:
0106+  0653 09          	ret		
0107+  0654             
0108+  0654             
0109+  0654             
0110+  0654             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  0654             ; GETCHAR
0112+  0654             ; char in ah
0113+  0654             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0114+  0654             getchar:
0115+  0654 DB          	push al
0116+  0655             getchar_retry:
0117+  0655 FD 0C       	sti
0118+  0657 19 01       	mov al, 1
0119+  0659 05 03       	syscall sys_io			; receive in AH
0120+  065B B9 00       	cmp al, 0			; check if any char was receive
0121+  065D C6 55 06    	je getchar_retry
0122+  0660 E8          	pop al
0123+  0661 09          	ret
0124+  0662             
0125+  0662             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0126+  0662             ; PUTCHAR
0127+  0662             ; char in ah
0128+  0662             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  0662             putchar:
0130+  0662 D7          	push a
0131+  0663 19 00       	mov al, 0
0132+  0665 05 03       	syscall sys_io			; char in AH
0133+  0667 E4          	pop a
0134+  0668 09          	ret
0135+  0669             
0136+  0669             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0137+  0669             ;; INPUT A STRING
0138+  0669             ;; terminates with null
0139+  0669             ;; pointer in D
0140+  0669             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  0669             gets:
0142+  0669 D7          	push a
0143+  066A DA          	push d
0144+  066B             gets_loop:
0145+  066B FD 0C       	sti
0146+  066D 19 01       	mov al, 1
0147+  066F 05 03       	syscall sys_io			; receive in AH
0148+  0671 B9 00       	cmp al, 0				; check error code (AL)
0149+  0673 C6 6B 06    	je gets_loop			; if no char received, retry
0150+  0676             
0151+  0676 76 1B       	cmp ah, 27
0152+  0678 C6 94 06    	je gets_telnet_escape
0153+  067B 76 0A       	cmp ah, $0A				; LF
0154+  067D C6 ED 06    	je gets_end
0155+  0680 76 5C       	cmp ah, $5C				; '\\'
0156+  0682 C6 C4 06    	je gets_escape
0157+  0685             	
0158+  0685 76 08       	cmp ah, $08			; check for backspace
0159+  0687 C6 90 06    	je gets_backspace
0160+  068A             
0161+  068A 1A          	mov al, ah
0162+  068B 3E          	mov [d], al
0163+  068C 79          	inc d
0164+  068D 0A 6B 06    	jmp gets_loop
0165+  0690             gets_backspace:
0166+  0690 7F          	dec d
0167+  0691 0A 6B 06    	jmp gets_loop
0168+  0694             gets_telnet_escape:
0169+  0694 FD 0C       	sti
0170+  0696 19 01       	mov al, 1
0171+  0698 05 03       	syscall sys_io				; receive in AH without echo
0172+  069A B9 00       	cmp al, 0					; check error code (AL)
0173+  069C C6 94 06    	je gets_telnet_escape		; if no char received, retry
0174+  069F 76 5B       	cmp ah, '['
0175+  06A1 C7 6B 06    	jne gets_loop
0176+  06A4             gets_telnet_escape_phase2:
0177+  06A4 FD 0C       	sti
0178+  06A6 19 01       	mov al, 1
0179+  06A8 05 03       	syscall sys_io					; receive in AH without echo
0180+  06AA B9 00       	cmp al, 0						; check error code (AL)
0181+  06AC C6 A4 06    	je gets_telnet_escape_phase2	; if no char received, retry
0182+  06AF 76 44       	cmp ah, 'D'
0183+  06B1 C6 BC 06    	je gets_left_arrow
0184+  06B4 76 43       	cmp ah, 'C'
0185+  06B6 C6 C0 06    	je gets_right_arrow
0186+  06B9 0A 6B 06    	jmp gets_loop
0187+  06BC             gets_left_arrow:
0188+  06BC 7F          	dec d
0189+  06BD 0A 6B 06    	jmp gets_loop
0190+  06C0             gets_right_arrow:
0191+  06C0 79          	inc d
0192+  06C1 0A 6B 06    	jmp gets_loop
0193+  06C4             gets_escape:
0194+  06C4 FD 0C       	sti
0195+  06C6 19 01       	mov al, 1
0196+  06C8 05 03       	syscall sys_io			; receive in AH
0197+  06CA B9 00       	cmp al, 0				; check error code (AL)
0198+  06CC C6 C4 06    	je gets_escape			; if no char received, retry
0199+  06CF 76 6E       	cmp ah, 'n'
0200+  06D1 C6 DF 06    	je gets_LF
0201+  06D4 76 72       	cmp ah, 'r'
0202+  06D6 C6 E6 06    	je gets_CR
0203+  06D9 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0204+  06DA 3E          	mov [d], al
0205+  06DB 79          	inc d
0206+  06DC 0A 6B 06    	jmp gets_loop
0207+  06DF             gets_LF:
0208+  06DF 19 0A       	mov al, $0A
0209+  06E1 3E          	mov [d], al
0210+  06E2 79          	inc d
0211+  06E3 0A 6B 06    	jmp gets_loop
0212+  06E6             gets_CR:
0213+  06E6 19 0D       	mov al, $0D
0214+  06E8 3E          	mov [d], al
0215+  06E9 79          	inc d
0216+  06EA 0A 6B 06    	jmp gets_loop
0217+  06ED             gets_end:
0218+  06ED 19 00       	mov al, 0
0219+  06EF 3E          	mov [d], al				; terminate string
0220+  06F0 E7          	pop d
0221+  06F1 E4          	pop a
0222+  06F2 09          	ret
0223+  06F3             
0224+  06F3             
0225+  06F3             
0226+  06F3             
0227+  06F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0228+  06F3             ;; INPUT TEXT
0229+  06F3             ;; terminated with CTRL+D
0230+  06F3             ;; pointer in D
0231+  06F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0232+  06F3             gettxt:
0233+  06F3 D7          	push a
0234+  06F4 DA          	push d
0235+  06F5             gettxt_loop:
0236+  06F5 19 01       	mov al, 1
0237+  06F7 05 03       	syscall sys_io			; receive in AH
0238+  06F9 B9 00       	cmp al, 0				; check error code (AL)
0239+  06FB C6 F5 06    	je gettxt_loop		; if no char received, retry
0240+  06FE 76 04       	cmp ah, 4			; EOT
0241+  0700 C6 3E 07    	je gettxt_end
0242+  0703 76 08       	cmp ah, $08			; check for backspace
0243+  0705 C6 3A 07    	je gettxt_backspace
0244+  0708 76 5C       	cmp ah, $5C				; '\\'
0245+  070A C6 13 07    	je gettxt_escape
0246+  070D 1A          	mov al, ah
0247+  070E 3E          	mov [d], al
0248+  070F 79          	inc d
0249+  0710 0A F5 06    	jmp gettxt_loop
0250+  0713             gettxt_escape:
0251+  0713 19 01       	mov al, 1
0252+  0715 05 03       	syscall sys_io			; receive in AH
0253+  0717 B9 00       	cmp al, 0				; check error code (AL)
0254+  0719 C6 13 07    	je gettxt_escape		; if no char received, retry
0255+  071C 76 6E       	cmp ah, 'n'
0256+  071E C6 2C 07    	je gettxt_LF
0257+  0721 76 72       	cmp ah, 'r'
0258+  0723 C6 33 07    	je gettxt_CR
0259+  0726 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0260+  0727 3E          	mov [d], al
0261+  0728 79          	inc d
0262+  0729 0A F5 06    	jmp gettxt_loop
0263+  072C             gettxt_LF:
0264+  072C 19 0A       	mov al, $0A
0265+  072E 3E          	mov [d], al
0266+  072F 79          	inc d
0267+  0730 0A F5 06    	jmp gettxt_loop
0268+  0733             gettxt_CR:
0269+  0733 19 0D       	mov al, $0D
0270+  0735 3E          	mov [d], al
0271+  0736 79          	inc d
0272+  0737 0A F5 06    	jmp gettxt_loop
0273+  073A             gettxt_backspace:
0274+  073A 7F          	dec d
0275+  073B 0A F5 06    	jmp gettxt_loop
0276+  073E             gettxt_end:
0277+  073E 19 00       	mov al, 0
0278+  0740 3E          	mov [d], al				; terminate string
0279+  0741 E7          	pop d
0280+  0742 E4          	pop a
0281+  0743 09          	ret
0282+  0744             
0283+  0744             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0284+  0744             ; PRINT NEW LINE
0285+  0744             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0286+  0744             printnl:
0287+  0744 D7          	push a
0288+  0745 10 00 0A    	mov a, $0A00
0289+  0748 05 03       	syscall sys_io
0290+  074A 10 00 0D    	mov a, $0D00
0291+  074D 05 03       	syscall sys_io
0292+  074F E4          	pop a
0293+  0750 09          	ret
0294+  0751             
0295+  0751             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0296+  0751             ; strtoint
0297+  0751             ; 4 digit hex string number in d
0298+  0751             ; integer returned in A
0299+  0751             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0300+  0751             strtointx:
0301+  0751 D8          	push b
0302+  0752 32          	mov bl, [d]
0303+  0753 37          	mov bh, bl
0304+  0754 33 01 00    	mov bl, [d + 1]
0305+  0757 07 17 06    	call atoi				; convert to int in AL
0306+  075A 23          	mov ah, al				; move to AH
0307+  075B 33 02 00    	mov bl, [d + 2]
0308+  075E 37          	mov bh, bl
0309+  075F 33 03 00    	mov bl, [d + 3]
0310+  0762 07 17 06    	call atoi				; convert to int in AL
0311+  0765 E5          	pop b
0312+  0766 09          	ret
0313+  0767             
0314+  0767             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0315+  0767             ; strtoint
0316+  0767             ; 5 digit base10 string number in d
0317+  0767             ; integer returned in A
0318+  0767             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0319+  0767             strtoint:
0320+  0767 E2          	push si
0321+  0768 D8          	push b
0322+  0769 D9          	push c
0323+  076A DA          	push d
0324+  076B 07 9F 05    	call strlen			; get string length in C
0325+  076E 7E          	dec c
0326+  076F FD 4E       	mov si, d
0327+  0771 12          	mov a, c
0328+  0772 FD 99       	shl a
0329+  0774 3B FF 05    	mov d, table_power
0330+  0777 59          	add d, a
0331+  0778 38 00 00    	mov c, 0
0332+  077B             strtoint_L0:
0333+  077B F6          	lodsb			; load ASCII to al
0334+  077C B9 00       	cmp al, 0
0335+  077E C6 91 07    	je strtoint_end
0336+  0781 6F 30       	sub al, $30		; make into integer
0337+  0783 22 00       	mov ah, 0
0338+  0785 2A          	mov b, [d]
0339+  0786 AC          	mul a, b			; result in B since it fits in 16bits
0340+  0787 11          	mov a, b
0341+  0788 28          	mov b, c
0342+  0789 54          	add a, b
0343+  078A 39          	mov c, a
0344+  078B 63 02 00    	sub d, 2
0345+  078E 0A 7B 07    	jmp strtoint_L0
0346+  0791             strtoint_end:
0347+  0791 12          	mov a, c
0348+  0792 E7          	pop d
0349+  0793 E6          	pop c
0350+  0794 E5          	pop b
0351+  0795 EF          	pop si
0352+  0796 09          	ret
0353+  0797             
0354+  0797             
0355+  0797             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  0797             ; PRINT NULL TERMINATED STRING
0357+  0797             ; pointer in D
0358+  0797             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  0797             puts:
0360+  0797 D7          	push a
0361+  0798 DA          	push d
0362+  0799             puts_L1:
0363+  0799 1E          	mov al, [d]
0364+  079A B9 00       	cmp al, 0
0365+  079C C6 A8 07    	jz puts_END
0366+  079F 23          	mov ah, al
0367+  07A0 19 00       	mov al, 0
0368+  07A2 05 03       	syscall sys_io
0369+  07A4 79          	inc d
0370+  07A5 0A 99 07    	jmp puts_L1
0371+  07A8             puts_END:
0372+  07A8 E7          	pop d
0373+  07A9 E4          	pop a
0374+  07AA 09          	ret
0375+  07AB             
0376+  07AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0377+  07AB             ; PRINT N SIZE STRING
0378+  07AB             ; pointer in D
0379+  07AB             ; size in C
0380+  07AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0381+  07AB             putsn:
0382+  07AB DB          	push al
0383+  07AC DA          	push d
0384+  07AD D9          	push c
0385+  07AE             putsn_L0:
0386+  07AE 1E          	mov al, [d]
0387+  07AF 23          	mov ah, al
0388+  07B0 19 00       	mov al, 0
0389+  07B2 05 03       	syscall sys_io
0390+  07B4 79          	inc d
0391+  07B5 7E          	dec c	
0392+  07B6 C2 00 00    	cmp c, 0
0393+  07B9 C7 AE 07    	jne putsn_L0
0394+  07BC             putsn_end:
0395+  07BC E6          	pop c
0396+  07BD E7          	pop d
0397+  07BE E8          	pop al
0398+  07BF 09          	ret
0399+  07C0             
0400+  07C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0401+  07C0             ; print 16bit decimal number
0402+  07C0             ; input number in A
0403+  07C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  07C0             print_u16d:
0405+  07C0 D7          	push a
0406+  07C1 D8          	push b
0407+  07C2 26 10 27    	mov b, 10000
0408+  07C5 AE          	div a, b			; get 10000 coeff.
0409+  07C6 07 EC 07    	call print_zero_or_space
0410+  07C9 11          	mov a, b
0411+  07CA 26 E8 03    	mov b, 1000
0412+  07CD AE          	div a, b			; get 10000 coeff.
0413+  07CE 07 EC 07    	call print_zero_or_space
0414+  07D1 11          	mov a, b
0415+  07D2 26 64 00    	mov b, 100
0416+  07D5 AE          	div a, b
0417+  07D6 07 EC 07    	call print_zero_or_space
0418+  07D9 11          	mov a, b
0419+  07DA 26 0A 00    	mov b, 10
0420+  07DD AE          	div a, b
0421+  07DE 07 EC 07    	call print_zero_or_space
0422+  07E1 11          	mov a, b
0423+  07E2 6A 30       	add al, $30
0424+  07E4 23          	mov ah, al
0425+  07E5 19 00       	mov al, 0
0426+  07E7 05 03       	syscall sys_io	; print coeff
0427+  07E9 E5          	pop b
0428+  07EA E4          	pop a
0429+  07EB 09          	ret
0430+  07EC             
0431+  07EC             
0432+  07EC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0433+  07EC             ; if A == 0, print space
0434+  07EC             ; else print A
0435+  07EC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  07EC             print_zero_or_space:
0437+  07EC             	; cmp a, 0
0438+  07EC             	; jne print_number
0439+  07EC             	; mov ah, $20
0440+  07EC             	; call putchar
0441+  07EC             	; ret
0442+  07EC             print_number:
0443+  07EC 6A 30       	add al, $30
0444+  07EE 23          	mov ah, al
0445+  07EF 07 62 06    	call putchar
0446+  07F2 09          	ret
0447+  07F3             
0448+  07F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  07F3             ; PRINT 16BIT HEX INTEGER
0450+  07F3             ; integer value in reg B
0451+  07F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0452+  07F3             print_u16x:
0453+  07F3 D7          	push a
0454+  07F4 D8          	push b
0455+  07F5 DD          	push bl
0456+  07F6 30          	mov bl, bh
0457+  07F7 07 29 06    	call itoa				; convert bh to char in A
0458+  07FA 2F          	mov bl, al				; save al
0459+  07FB 19 00       	mov al, 0
0460+  07FD 05 03       	syscall sys_io				; display AH
0461+  07FF 24          	mov ah, bl				; retrieve al
0462+  0800 19 00       	mov al, 0
0463+  0802 05 03       	syscall sys_io				; display AL
0464+  0804             
0465+  0804 EA          	pop bl
0466+  0805 07 29 06    	call itoa				; convert bh to char in A
0467+  0808 2F          	mov bl, al				; save al
0468+  0809 19 00       	mov al, 0
0469+  080B 05 03       	syscall sys_io				; display AH
0470+  080D 24          	mov ah, bl				; retrieve al
0471+  080E 19 00       	mov al, 0
0472+  0810 05 03       	syscall sys_io				; display AL
0473+  0812             
0474+  0812 E5          	pop b
0475+  0813 E4          	pop a
0476+  0814 09          	ret
0477+  0815             
0478+  0815             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  0815             ; INPUT 16BIT HEX INTEGER
0480+  0815             ; read 16bit integer into A
0481+  0815             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0482+  0815             scan_u16x:
0483+  0815 F8 10 00    	enter 16
0484+  0818 D8          	push b
0485+  0819 DA          	push d
0486+  081A             
0487+  081A FA F1 FF    	lea d, [bp + -15]
0488+  081D 07 69 06    	call gets				; get number
0489+  0820             
0490+  0820 32          	mov bl, [d]
0491+  0821 37          	mov bh, bl
0492+  0822 33 01 00    	mov bl, [d + 1]
0493+  0825 07 17 06    	call atoi				; convert to int in AL
0494+  0828 23          	mov ah, al				; move to AH
0495+  0829             
0496+  0829 33 02 00    	mov bl, [d + 2]
0497+  082C 37          	mov bh, bl
0498+  082D 33 03 00    	mov bl, [d + 3]
0499+  0830 07 17 06    	call atoi				; convert to int in AL
0500+  0833             
0501+  0833 E7          	pop d
0502+  0834 E5          	pop b
0503+  0835 F9          	leave
0504+  0836 09          	ret
0505+  0837             
0506+  0837             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  0837             ; PRINT 8bit HEX INTEGER
0508+  0837             ; integer value in reg bl
0509+  0837             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0510+  0837             print_u8x:
0511+  0837 D7          	push a
0512+  0838 DD          	push bl
0513+  0839             
0514+  0839 07 29 06    	call itoa				; convert bl to char in A
0515+  083C 2F          	mov bl, al				; save al
0516+  083D 19 00       	mov al, 0
0517+  083F 05 03       	syscall sys_io				; display AH
0518+  0841 24          	mov ah, bl				; retrieve al
0519+  0842 19 00       	mov al, 0
0520+  0844 05 03       	syscall sys_io				; display AL
0521+  0846             
0522+  0846 EA          	pop bl
0523+  0847 E4          	pop a
0524+  0848 09          	ret
0525+  0849             
0526+  0849             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  0849             ; print 8bit decimal unsigned number
0528+  0849             ; input number in AL
0529+  0849             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0530+  0849             print_u8d:
0531+  0849 D7          	push a
0532+  084A D8          	push b
0533+  084B             
0534+  084B 22 00       	mov ah, 0
0535+  084D 26 64 00    	mov b, 100
0536+  0850 AE          	div a, b
0537+  0851 D8          	push b			; save remainder
0538+  0852 B9 00       	cmp al, 0
0539+  0854 C6 5E 08    	je skip100
0540+  0857 6A 30       	add al, $30
0541+  0859 23          	mov ah, al
0542+  085A 19 00       	mov al, 0
0543+  085C 05 03       	syscall sys_io	; print coeff
0544+  085E             skip100:
0545+  085E E4          	pop a
0546+  085F 22 00       	mov ah, 0
0547+  0861 26 0A 00    	mov b, 10
0548+  0864 AE          	div a, b
0549+  0865 D8          	push b			; save remainder
0550+  0866 B9 00       	cmp al, 0
0551+  0868 C6 72 08    	je skip10
0552+  086B 6A 30       	add al, $30
0553+  086D 23          	mov ah, al
0554+  086E 19 00       	mov al, 0
0555+  0870 05 03       	syscall sys_io	; print coeff
0556+  0872             skip10:
0557+  0872 E4          	pop a
0558+  0873 1B          	mov al, bl
0559+  0874 6A 30       	add al, $30
0560+  0876 23          	mov ah, al
0561+  0877 19 00       	mov al, 0
0562+  0879 05 03       	syscall sys_io	; print coeff
0563+  087B E5          	pop b
0564+  087C E4          	pop a
0565+  087D 09          	ret
0566+  087E             
0567+  087E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  087E             ; INPUT 8BIT HEX INTEGER
0569+  087E             ; read 8bit integer into AL
0570+  087E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0571+  087E             scan_u8x:
0572+  087E F8 04 00    	enter 4
0573+  0881 D8          	push b
0574+  0882 DA          	push d
0575+  0883             
0576+  0883 FA FD FF    	lea d, [bp + -3]
0577+  0886 07 69 06    	call gets				; get number
0578+  0889             
0579+  0889 32          	mov bl, [d]
0580+  088A 37          	mov bh, bl
0581+  088B 33 01 00    	mov bl, [d + 1]
0582+  088E 07 17 06    	call atoi				; convert to int in AL
0583+  0891             
0584+  0891 E7          	pop d
0585+  0892 E5          	pop b
0586+  0893 F9          	leave
0587+  0894 09          	ret
0588+  0895             
0589+  0895             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0590+  0895             ; input decimal number
0591+  0895             ; result in A
0592+  0895             ; 655'\0'
0593+  0895             ; low--------high
0594+  0895             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0595+  0895             scan_u16d:
0596+  0895 F8 08 00    	enter 8
0597+  0898 E2          	push si
0598+  0899 D8          	push b
0599+  089A D9          	push c
0600+  089B DA          	push d
0601+  089C FA F9 FF    	lea d, [bp +- 7]
0602+  089F 07 69 06    	call gets
0603+  08A2 07 9F 05    	call strlen			; get string length in C
0604+  08A5 7E          	dec c
0605+  08A6 FD 4E       	mov si, d
0606+  08A8 12          	mov a, c
0607+  08A9 FD 99       	shl a
0608+  08AB 3B FF 05    	mov d, table_power
0609+  08AE 59          	add d, a
0610+  08AF 38 00 00    	mov c, 0
0611+  08B2             mul_loop:
0612+  08B2 F6          	lodsb			; load ASCII to al
0613+  08B3 B9 00       	cmp al, 0
0614+  08B5 C6 C8 08    	je mul_exit
0615+  08B8 6F 30       	sub al, $30		; make into integer
0616+  08BA 22 00       	mov ah, 0
0617+  08BC 2A          	mov b, [d]
0618+  08BD AC          	mul a, b			; result in B since it fits in 16bits
0619+  08BE 11          	mov a, b
0620+  08BF 28          	mov b, c
0621+  08C0 54          	add a, b
0622+  08C1 39          	mov c, a
0623+  08C2 63 02 00    	sub d, 2
0624+  08C5 0A B2 08    	jmp mul_loop
0625+  08C8             mul_exit:
0626+  08C8 12          	mov a, c
0627+  08C9 E7          	pop d
0628+  08CA E6          	pop c
0629+  08CB E5          	pop b
0630+  08CC EF          	pop si
0631+  08CD F9          	leave
0632+  08CE 09          	ret
0098   08CF             .end
0099   08CF             
tasm: Number of errors = 0
