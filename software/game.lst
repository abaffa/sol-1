0001   0000             .include "kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0002   0000             
0003   0000             main:
0004   0000 3B A0 00    	mov d, s_clear
0005   0003 07 9C 07    	call puts
0006   0006             
0007   0006             main_L0:
0008   0006 07 54 06    	call getchar
0009   0009 76 71       	cmp ah, 'q'
0010   000B C6 81 00    	je quit
0011   000E 07 54 06    	call getchar
0012   0011 07 54 06    	call getchar
0013   0014             	
0014   0014 76 41       	cmp ah, $41
0015   0016 C6 55 00    	je go_up
0016   0019             
0017   0019 76 42       	cmp ah, $42
0018   001B C6 61 00    	je go_down
0019   001E             
0020   001E 76 43       	cmp ah, $43
0021   0020 C6 6D 00    	je go_right
0022   0023             	
0023   0023 76 44       	cmp ah, $44
0024   0025 C6 77 00    	je go_left
0025   0028             
0026   0028             back:
0027   0028             ; calculate	array position for Y coordinate
0028   0028 14 86 00    	mov a, [pos]
0029   002B 3B A8 00    	mov d, buffer
0030   002E 59          	add d, a
0031   002F 19 40       	mov al, '@'
0032   0031 3E          	mov [d], al
0033   0032             
0034   0032 3B A0 00    	mov d, s_clear
0035   0035 07 9C 07    	call puts
0036   0038             
0037   0038 3B A8 00    	mov d, buffer
0038   003B 26 00 00    	mov b, 0
0039   003E             loop:
0040   003E 38 3C 00    	mov c, width
0041   0041 07 B0 07    	call putsn
0042   0044 07 49 07    	call printnl
0043   0047 58 3C 00    	add d, width
0044   004A FD 77       	inc b
0045   004C C0 14 00    	cmp b, height
0046   004F C7 3E 00    	jne loop
0047   0052             
0048   0052 0A 06 00    	jmp main_L0
0049   0055             
0050   0055             go_up:
0051   0055 14 86 00    	mov a, [pos]
0052   0058 5F 3C 00    	sub a, width
0053   005B 42 86 00    	mov [pos], a
0054   005E 0A 28 00    	jmp back
0055   0061             go_down:
0056   0061 14 86 00    	mov a, [pos]
0057   0064 53 3C 00    	add a, width
0058   0067 42 86 00    	mov [pos], a
0059   006A 0A 28 00    	jmp back
0060   006D             
0061   006D             go_right:
0062   006D 14 86 00    	mov a, [pos]
0063   0070 77          	inc a
0064   0071 42 86 00    	mov [pos], a
0065   0074 0A 28 00    	jmp back
0066   0077             
0067   0077             go_left:
0068   0077 14 86 00    	mov a, [pos]
0069   007A 7D          	dec a
0070   007B 42 86 00    	mov [pos], a
0071   007E 0A 28 00    	jmp back
0072   0081             
0073   0081             quit:
0074   0081 09          	ret
0075   0082             
0076   0082             width: 			.equ 60
0077   0082             height:			.equ 20
0078   0082             
0079   0082 00 00       x:				.dw 0
0080   0084 00 00       y:				.dw 0
0081   0086             
0082   0086 00 00       pos:			.dw 0
0083   0088             
0084   0088             
0085   0088 FF FF FF FF choice:			.fill 20
0085   008C FF FF FF FF 
0085   0090 FF FF FF FF 
0085   0094 FF FF FF FF 
0085   0098 FF FF FF FF 
0086   009C             
0087   009C             
0088   009C 41          s_up:			.db $41
0089   009D 42          s_down:			.db $42
0090   009E 43          s_right:		.db $43
0091   009F 44          s_left:			.db $44
0092   00A0             
0093   00A0 1B 5B 32 4A s_clear:		.db 27, "[2J", 27, "[H", 0
0093   00A4 1B 5B 48 00 
0094   00A8             
0095   00A8 20 20 20 20 buffer:			.fill 1200, ' '
0095   00AC 20 20 20 20 
0095   00B0 20 20 20 20 
0095   00B4 20 20 20 20 
0095   00B8 20 20 20 20 
0095   00BC 20 20 20 20 
0095   00C0 20 20 20 20 
0095   00C4 20 20 20 20 
0095   00C8 20 20 20 20 
0095   00CC 20 20 20 20 
0095   00D0 20 20 20 20 
0095   00D4 20 20 20 20 
0095   00D8 20 20 20 20 
0095   00DC 20 20 20 20 
0095   00E0 20 20 20 20 
0095   00E4 20 20 20 20 
0095   00E8 20 20 20 20 
0095   00EC 20 20 20 20 
0095   00F0 20 20 20 20 
0095   00F4 20 20 20 20 
0095   00F8 20 20 20 20 
0095   00FC 20 20 20 20 
0095   0100 20 20 20 20 
0095   0104 20 20 20 20 
0095   0108 20 20 20 20 
0095   010C 20 20 20 20 
0095   0110 20 20 20 20 
0095   0114 20 20 20 20 
0095   0118 20 20 20 20 
0095   011C 20 20 20 20 
0095   0120 20 20 20 20 
0095   0124 20 20 20 20 
0095   0128 20 20 20 20 
0095   012C 20 20 20 20 
0095   0130 20 20 20 20 
0095   0134 20 20 20 20 
0095   0138 20 20 20 20 
0095   013C 20 20 20 20 
0095   0140 20 20 20 20 
0095   0144 20 20 20 20 
0095   0148 20 20 20 20 
0095   014C 20 20 20 20 
0095   0150 20 20 20 20 
0095   0154 20 20 20 20 
0095   0158 20 20 20 20 
0095   015C 20 20 20 20 
0095   0160 20 20 20 20 
0095   0164 20 20 20 20 
0095   0168 20 20 20 20 
0095   016C 20 20 20 20 
0095   0170 20 20 20 20 
0095   0174 20 20 20 20 
0095   0178 20 20 20 20 
0095   017C 20 20 20 20 
0095   0180 20 20 20 20 
0095   0184 20 20 20 20 
0095   0188 20 20 20 20 
0095   018C 20 20 20 20 
0095   0190 20 20 20 20 
0095   0194 20 20 20 20 
0095   0198 20 20 20 20 
0095   019C 20 20 20 20 
0095   01A0 20 20 20 20 
0095   01A4 20 20 20 20 
0095   01A8 20 20 20 20 
0095   01AC 20 20 20 20 
0095   01B0 20 20 20 20 
0095   01B4 20 20 20 20 
0095   01B8 20 20 20 20 
0095   01BC 20 20 20 20 
0095   01C0 20 20 20 20 
0095   01C4 20 20 20 20 
0095   01C8 20 20 20 20 
0095   01CC 20 20 20 20 
0095   01D0 20 20 20 20 
0095   01D4 20 20 20 20 
0095   01D8 20 20 20 20 
0095   01DC 20 20 20 20 
0095   01E0 20 20 20 20 
0095   01E4 20 20 20 20 
0095   01E8 20 20 20 20 
0095   01EC 20 20 20 20 
0095   01F0 20 20 20 20 
0095   01F4 20 20 20 20 
0095   01F8 20 20 20 20 
0095   01FC 20 20 20 20 
0095   0200 20 20 20 20 
0095   0204 20 20 20 20 
0095   0208 20 20 20 20 
0095   020C 20 20 20 20 
0095   0210 20 20 20 20 
0095   0214 20 20 20 20 
0095   0218 20 20 20 20 
0095   021C 20 20 20 20 
0095   0220 20 20 20 20 
0095   0224 20 20 20 20 
0095   0228 20 20 20 20 
0095   022C 20 20 20 20 
0095   0230 20 20 20 20 
0095   0234 20 20 20 20 
0095   0238 20 20 20 20 
0095   023C 20 20 20 20 
0095   0240 20 20 20 20 
0095   0244 20 20 20 20 
0095   0248 20 20 20 20 
0095   024C 20 20 20 20 
0095   0250 20 20 20 20 
0095   0254 20 20 20 20 
0095   0258 20 20 20 20 
0095   025C 20 20 20 20 
0095   0260 20 20 20 20 
0095   0264 20 20 20 20 
0095   0268 20 20 20 20 
0095   026C 20 20 20 20 
0095   0270 20 20 20 20 
0095   0274 20 20 20 20 
0095   0278 20 20 20 20 
0095   027C 20 20 20 20 
0095   0280 20 20 20 20 
0095   0284 20 20 20 20 
0095   0288 20 20 20 20 
0095   028C 20 20 20 20 
0095   0290 20 20 20 20 
0095   0294 20 20 20 20 
0095   0298 20 20 20 20 
0095   029C 20 20 20 20 
0095   02A0 20 20 20 20 
0095   02A4 20 20 20 20 
0095   02A8 20 20 20 20 
0095   02AC 20 20 20 20 
0095   02B0 20 20 20 20 
0095   02B4 20 20 20 20 
0095   02B8 20 20 20 20 
0095   02BC 20 20 20 20 
0095   02C0 20 20 20 20 
0095   02C4 20 20 20 20 
0095   02C8 20 20 20 20 
0095   02CC 20 20 20 20 
0095   02D0 20 20 20 20 
0095   02D4 20 20 20 20 
0095   02D8 20 20 20 20 
0095   02DC 20 20 20 20 
0095   02E0 20 20 20 20 
0095   02E4 20 20 20 20 
0095   02E8 20 20 20 20 
0095   02EC 20 20 20 20 
0095   02F0 20 20 20 20 
0095   02F4 20 20 20 20 
0095   02F8 20 20 20 20 
0095   02FC 20 20 20 20 
0095   0300 20 20 20 20 
0095   0304 20 20 20 20 
0095   0308 20 20 20 20 
0095   030C 20 20 20 20 
0095   0310 20 20 20 20 
0095   0314 20 20 20 20 
0095   0318 20 20 20 20 
0095   031C 20 20 20 20 
0095   0320 20 20 20 20 
0095   0324 20 20 20 20 
0095   0328 20 20 20 20 
0095   032C 20 20 20 20 
0095   0330 20 20 20 20 
0095   0334 20 20 20 20 
0095   0338 20 20 20 20 
0095   033C 20 20 20 20 
0095   0340 20 20 20 20 
0095   0344 20 20 20 20 
0095   0348 20 20 20 20 
0095   034C 20 20 20 20 
0095   0350 20 20 20 20 
0095   0354 20 20 20 20 
0095   0358 20 20 20 20 
0095   035C 20 20 20 20 
0095   0360 20 20 20 20 
0095   0364 20 20 20 20 
0095   0368 20 20 20 20 
0095   036C 20 20 20 20 
0095   0370 20 20 20 20 
0095   0374 20 20 20 20 
0095   0378 20 20 20 20 
0095   037C 20 20 20 20 
0095   0380 20 20 20 20 
0095   0384 20 20 20 20 
0095   0388 20 20 20 20 
0095   038C 20 20 20 20 
0095   0390 20 20 20 20 
0095   0394 20 20 20 20 
0095   0398 20 20 20 20 
0095   039C 20 20 20 20 
0095   03A0 20 20 20 20 
0095   03A4 20 20 20 20 
0095   03A8 20 20 20 20 
0095   03AC 20 20 20 20 
0095   03B0 20 20 20 20 
0095   03B4 20 20 20 20 
0095   03B8 20 20 20 20 
0095   03BC 20 20 20 20 
0095   03C0 20 20 20 20 
0095   03C4 20 20 20 20 
0095   03C8 20 20 20 20 
0095   03CC 20 20 20 20 
0095   03D0 20 20 20 20 
0095   03D4 20 20 20 20 
0095   03D8 20 20 20 20 
0095   03DC 20 20 20 20 
0095   03E0 20 20 20 20 
0095   03E4 20 20 20 20 
0095   03E8 20 20 20 20 
0095   03EC 20 20 20 20 
0095   03F0 20 20 20 20 
0095   03F4 20 20 20 20 
0095   03F8 20 20 20 20 
0095   03FC 20 20 20 20 
0095   0400 20 20 20 20 
0095   0404 20 20 20 20 
0095   0408 20 20 20 20 
0095   040C 20 20 20 20 
0095   0410 20 20 20 20 
0095   0414 20 20 20 20 
0095   0418 20 20 20 20 
0095   041C 20 20 20 20 
0095   0420 20 20 20 20 
0095   0424 20 20 20 20 
0095   0428 20 20 20 20 
0095   042C 20 20 20 20 
0095   0430 20 20 20 20 
0095   0434 20 20 20 20 
0095   0438 20 20 20 20 
0095   043C 20 20 20 20 
0095   0440 20 20 20 20 
0095   0444 20 20 20 20 
0095   0448 20 20 20 20 
0095   044C 20 20 20 20 
0095   0450 20 20 20 20 
0095   0454 20 20 20 20 
0095   0458 20 20 20 20 
0095   045C 20 20 20 20 
0095   0460 20 20 20 20 
0095   0464 20 20 20 20 
0095   0468 20 20 20 20 
0095   046C 20 20 20 20 
0095   0470 20 20 20 20 
0095   0474 20 20 20 20 
0095   0478 20 20 20 20 
0095   047C 20 20 20 20 
0095   0480 20 20 20 20 
0095   0484 20 20 20 20 
0095   0488 20 20 20 20 
0095   048C 20 20 20 20 
0095   0490 20 20 20 20 
0095   0494 20 20 20 20 
0095   0498 20 20 20 20 
0095   049C 20 20 20 20 
0095   04A0 20 20 20 20 
0095   04A4 20 20 20 20 
0095   04A8 20 20 20 20 
0095   04AC 20 20 20 20 
0095   04B0 20 20 20 20 
0095   04B4 20 20 20 20 
0095   04B8 20 20 20 20 
0095   04BC 20 20 20 20 
0095   04C0 20 20 20 20 
0095   04C4 20 20 20 20 
0095   04C8 20 20 20 20 
0095   04CC 20 20 20 20 
0095   04D0 20 20 20 20 
0095   04D4 20 20 20 20 
0095   04D8 20 20 20 20 
0095   04DC 20 20 20 20 
0095   04E0 20 20 20 20 
0095   04E4 20 20 20 20 
0095   04E8 20 20 20 20 
0095   04EC 20 20 20 20 
0095   04F0 20 20 20 20 
0095   04F4 20 20 20 20 
0095   04F8 20 20 20 20 
0095   04FC 20 20 20 20 
0095   0500 20 20 20 20 
0095   0504 20 20 20 20 
0095   0508 20 20 20 20 
0095   050C 20 20 20 20 
0095   0510 20 20 20 20 
0095   0514 20 20 20 20 
0095   0518 20 20 20 20 
0095   051C 20 20 20 20 
0095   0520 20 20 20 20 
0095   0524 20 20 20 20 
0095   0528 20 20 20 20 
0095   052C 20 20 20 20 
0095   0530 20 20 20 20 
0095   0534 20 20 20 20 
0095   0538 20 20 20 20 
0095   053C 20 20 20 20 
0095   0540 20 20 20 20 
0095   0544 20 20 20 20 
0095   0548 20 20 20 20 
0095   054C 20 20 20 20 
0095   0550 20 20 20 20 
0095   0554 20 20 20 20 
0096   0558             
0097   0558             .include "stdio.asm"
0001+  0558             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0558             ; stdio.s
0003+  0558             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0558             .include "string.asm"
0001++ 0558             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0558             ; string.s
0003++ 0558             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0558             
0005++ 0558             
0006++ 0558             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0558             ; strrev
0008++ 0558             ; reverse a string
0009++ 0558             ; D = string address
0010++ 0558             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0558             ; 01234
0012++ 0558             strrev:
0013++ 0558 4B          	pusha
0014++ 0559 07 9F 05    	call strlen	; length in C
0015++ 055C 12          	mov a, c
0016++ 055D AF 01 00    	cmp a, 1
0017++ 0560 D0 7A 05    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0563 7D          	dec a
0019++ 0564 FD 4E       	mov si, d	; beginning of string
0020++ 0566 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0568 59          	add d, a	; end of string
0022++ 0569 12          	mov a, c
0023++ 056A FD 9B       	shr a		; divide by 2
0024++ 056C 39          	mov c, a	; C now counts the steps
0025++ 056D             strrev_L0:
0026++ 056D 32          	mov bl, [d]	; save load right-side char into BL
0027++ 056E F6          	lodsb		; load left-side char into AL; increase SI
0028++ 056F 3E          	mov [d], al	; store left char into right side
0029++ 0570 1B          	mov al, bl
0030++ 0571 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0572 7E          	dec c
0032++ 0573 7F          	dec d
0033++ 0574 C2 00 00    	cmp c, 0
0034++ 0577 C7 6D 05    	jne strrev_L0
0035++ 057A             strrev_end:
0036++ 057A 4C          	popa
0037++ 057B 09          	ret
0038++ 057C             	
0039++ 057C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 057C             ; strchr
0041++ 057C             ; search string in D for char in AL
0042++ 057C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 057C             strchr:
0044++ 057C             strchr_L0:
0045++ 057C 32          	mov bl, [d]
0046++ 057D C1 00       	cmp bl, 0
0047++ 057F C6 8A 05    	je strchr_end
0048++ 0582 BA          	cmp al, bl
0049++ 0583 C6 8A 05    	je strchr_end
0050++ 0586 79          	inc d
0051++ 0587 0A 7C 05    	jmp strchr_L0
0052++ 058A             strchr_end:
0053++ 058A 1B          	mov al, bl
0054++ 058B 09          	ret
0055++ 058C             
0056++ 058C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 058C             ; strstr
0058++ 058C             ; find sub-string
0059++ 058C             ; str1 in SI
0060++ 058C             ; str2 in DI
0061++ 058C             ; SI points to end of source string
0062++ 058C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 058C             strstr:
0064++ 058C DB          	push al
0065++ 058D DA          	push d
0066++ 058E E3          	push di
0067++ 058F             strstr_loop:
0068++ 058F F3          	cmpsb					; compare a byte of the strings
0069++ 0590 C7 9B 05    	jne strstr_ret
0070++ 0593 FC 00 00    	lea d, [di + 0]
0071++ 0596 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0598 C7 8F 05    	jne strstr_loop				; equal chars but not at end
0073++ 059B             strstr_ret:
0074++ 059B F0          	pop di
0075++ 059C E7          	pop d
0076++ 059D E8          	pop al
0077++ 059E 09          	ret
0078++ 059F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 059F             ; length of null terminated string
0080++ 059F             ; result in C
0081++ 059F             ; pointer in D
0082++ 059F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 059F             strlen:
0084++ 059F DA          	push d
0085++ 05A0 38 00 00    	mov c, 0
0086++ 05A3             strlen_L1:
0087++ 05A3 BD 00       	cmp byte [d], 0
0088++ 05A5 C6 AD 05    	je strlen_ret
0089++ 05A8 79          	inc d
0090++ 05A9 78          	inc c
0091++ 05AA 0A A3 05    	jmp strlen_L1
0092++ 05AD             strlen_ret:
0093++ 05AD E7          	pop d
0094++ 05AE 09          	ret
0095++ 05AF             
0096++ 05AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 05AF             ; STRCMP
0098++ 05AF             ; compare two strings
0099++ 05AF             ; str1 in SI
0100++ 05AF             ; str2 in DI
0101++ 05AF             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 05AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 05AF             strcmp:
0104++ 05AF DB          	push al
0105++ 05B0 DA          	push d
0106++ 05B1 E3          	push di
0107++ 05B2 E2          	push si
0108++ 05B3             strcmp_loop:
0109++ 05B3 F3          	cmpsb					; compare a byte of the strings
0110++ 05B4 C7 BF 05    	jne strcmp_ret
0111++ 05B7 FB FF FF    	lea d, [si +- 1]
0112++ 05BA BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 05BC C7 B3 05    	jne strcmp_loop				; equal chars but not at end
0114++ 05BF             strcmp_ret:
0115++ 05BF EF          	pop si
0116++ 05C0 F0          	pop di
0117++ 05C1 E7          	pop d
0118++ 05C2 E8          	pop al
0119++ 05C3 09          	ret
0120++ 05C4             
0121++ 05C4             
0122++ 05C4             ; STRCPY
0123++ 05C4             ; copy null terminated string from SI to DI
0124++ 05C4             ; source in SI
0125++ 05C4             ; destination in DI
0126++ 05C4             strcpy:
0127++ 05C4 E2          	push si
0128++ 05C5 E3          	push di
0129++ 05C6 DB          	push al
0130++ 05C7             strcpy_L1:
0131++ 05C7 F6          	lodsb
0132++ 05C8 F7          	stosb
0133++ 05C9 B9 00       	cmp al, 0
0134++ 05CB C7 C7 05    	jne strcpy_L1
0135++ 05CE             strcpy_end:
0136++ 05CE E8          	pop al
0137++ 05CF F0          	pop di
0138++ 05D0 EF          	pop si
0139++ 05D1 09          	ret
0140++ 05D2             
0141++ 05D2             ; STRCAT
0142++ 05D2             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 05D2             ; source in SI
0144++ 05D2             ; destination in DI
0145++ 05D2             strcat:
0146++ 05D2 E2          	push si
0147++ 05D3 E3          	push di
0148++ 05D4 D7          	push a
0149++ 05D5 DA          	push d
0150++ 05D6 50          	mov a, di
0151++ 05D7 3C          	mov d, a
0152++ 05D8             strcat_goto_end_L1:
0153++ 05D8 BD 00       	cmp byte[d], 0
0154++ 05DA C6 E1 05    	je strcat_start
0155++ 05DD 79          	inc d
0156++ 05DE 0A D8 05    	jmp strcat_goto_end_L1
0157++ 05E1             strcat_start:
0158++ 05E1 FD 50       	mov di, d
0159++ 05E3             strcat_L1:
0160++ 05E3 F6          	lodsb
0161++ 05E4 F7          	stosb
0162++ 05E5 B9 00       	cmp al, 0
0163++ 05E7 C7 E3 05    	jne strcat_L1
0164++ 05EA             strcat_end:
0165++ 05EA E7          	pop d
0166++ 05EB E4          	pop a
0167++ 05EC F0          	pop di
0168++ 05ED EF          	pop si
0169++ 05EE 09          	ret
0005+  05EF             
0006+  05EF 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  05F3 34 35 36 37 
0006+  05F7 38 39 41 42 
0006+  05FB 43 44 45 46 
0007+  05FF             
0008+  05FF 01 00       table_power:.dw 1
0009+  0601 0A 00       			.dw 10
0010+  0603 64 00       			.dw 100
0011+  0605 E8 03       			.dw 1000
0012+  0607 10 27       			.dw 10000
0013+  0609             
0014+  0609             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0015+  0609             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0016+  0609             ; ASCII in BL
0017+  0609             ; result in AL
0018+  0609             ; ascii for F = 0100 0110
0019+  0609             ; ascii for 9 = 0011 1001
0020+  0609             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0021+  0609             hex_ascii_encode:
0022+  0609 1B          	mov al, bl
0023+  060A 93 40       	test al, $40				; test if letter or number
0024+  060C C7 12 06    	jnz hex_letter
0025+  060F 87 0F       	and al, $0F				; get number
0026+  0611 09          	ret
0027+  0612             hex_letter:
0028+  0612 87 0F       	and al, $0F				; get letter
0029+  0614 6A 09       	add al, 9
0030+  0616 09          	ret
0031+  0617             
0032+  0617             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0033+  0617             ; ATOI
0034+  0617             ; 2 letter hex string in B
0035+  0617             ; 8bit integer returned in AL
0036+  0617             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0037+  0617             atoi:
0038+  0617 D8          	push b
0039+  0618 07 09 06    	call hex_ascii_encode			; convert BL to 4bit code in AL
0040+  061B 30          	mov bl, bh
0041+  061C DB          	push al					; save a
0042+  061D 07 09 06    	call hex_ascii_encode
0043+  0620 EA          	pop bl	
0044+  0621 FD 9E 04    	shl al, 4
0045+  0624 8C          	or al, bl
0046+  0625 E5          	pop b
0047+  0626 09          	ret	
0048+  0627             
0049+  0627             
0050+  0627             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  0627             ; printf
0052+  0627             ; no need for explanations!
0053+  0627             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0054+  0627             printf:
0055+  0627 09          	ret
0056+  0628             
0057+  0628             
0058+  0628             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  0628             ; scanf
0060+  0628             ; no need for explanations!
0061+  0628             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  0628             scanf:
0063+  0628 09          	ret
0064+  0629             
0065+  0629             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  0629             ; ITOA
0067+  0629             ; 8bit value in BL
0068+  0629             ; 2 byte ASCII result in A
0069+  0629             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0070+  0629             itoa:
0071+  0629 DA          	push d
0072+  062A D8          	push b
0073+  062B A7 00       	mov bh, 0
0074+  062D FD A4 04    	shr bl, 4	
0075+  0630 74          	mov d, b
0076+  0631 1F EF 05    	mov al, [d + s_hex_digits]
0077+  0634 23          	mov ah, al
0078+  0635             	
0079+  0635 E5          	pop b
0080+  0636 D8          	push b
0081+  0637 A7 00       	mov bh, 0
0082+  0639 FD 87 0F    	and bl, $0F
0083+  063C 74          	mov d, b
0084+  063D 1F EF 05    	mov al, [d + s_hex_digits]
0085+  0640 E5          	pop b
0086+  0641 E7          	pop d
0087+  0642 09          	ret
0088+  0643             
0089+  0643             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0090+  0643             ; HEX STRING TO BINARY
0091+  0643             ; di = destination address
0092+  0643             ; si = source
0093+  0643             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0094+  0643             hex_to_int:
0095+  0643             hex_to_int_L1:
0096+  0643 F6          	lodsb					; load from [SI] to AL
0097+  0644 B9 00       	cmp al, 0				; check if ASCII 0
0098+  0646 C6 53 06    	jz hex_to_int_ret
0099+  0649 36          	mov bh, al
0100+  064A F6          	lodsb
0101+  064B 2F          	mov bl, al
0102+  064C 07 17 06    	call atoi				; convert ASCII byte in B to int (to AL)
0103+  064F F7          	stosb					; store AL to [DI]
0104+  0650 0A 43 06    	jmp hex_to_int_L1
0105+  0653             hex_to_int_ret:
0106+  0653 09          	ret		
0107+  0654             
0108+  0654             
0109+  0654             
0110+  0654             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  0654             ; GETCHAR
0112+  0654             ; char in ah
0113+  0654             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0114+  0654             getchar:
0115+  0654 DB          	push al
0116+  0655             getchar_retry:
0117+  0655 FD 0C       	sti
0118+  0657 19 01       	mov al, 1
0119+  0659 05 03       	syscall sys_io			; receive in AH
0120+  065B B9 00       	cmp al, 0			; check if any char was receive
0121+  065D C6 55 06    	je getchar_retry
0122+  0660 E8          	pop al
0123+  0661 09          	ret
0124+  0662             
0125+  0662             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0126+  0662             ; PUTCHAR
0127+  0662             ; char in ah
0128+  0662             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  0662             putchar:
0130+  0662 D7          	push a
0131+  0663 19 00       	mov al, 0
0132+  0665 05 03       	syscall sys_io			; char in AH
0133+  0667 E4          	pop a
0134+  0668 09          	ret
0135+  0669             
0136+  0669             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0137+  0669             ;; INPUT A STRING
0138+  0669             ;; terminates with null
0139+  0669             ;; pointer in D
0140+  0669             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  0669             gets:
0142+  0669 D7          	push a
0143+  066A DA          	push d
0144+  066B             gets_loop:
0145+  066B FD 0C       	sti
0146+  066D 19 01       	mov al, 1
0147+  066F 05 03       	syscall sys_io			; receive in AH
0148+  0671 B9 00       	cmp al, 0				; check error code (AL)
0149+  0673 C6 6B 06    	je gets_loop			; if no char received, retry
0150+  0676             
0151+  0676 76 1B       	cmp ah, 27
0152+  0678 C6 99 06    	je gets_telnet_escape
0153+  067B 76 0A       	cmp ah, $0A				; LF
0154+  067D C6 F2 06    	je gets_end
0155+  0680 76 0D       	cmp ah, $0D				; CR
0156+  0682 C6 F2 06    	je gets_end
0157+  0685 76 5C       	cmp ah, $5C				; '\\'
0158+  0687 C6 C9 06    	je gets_escape
0159+  068A             	
0160+  068A 76 08       	cmp ah, $08			; check for backspace
0161+  068C C6 95 06    	je gets_backspace
0162+  068F             
0163+  068F 1A          	mov al, ah
0164+  0690 3E          	mov [d], al
0165+  0691 79          	inc d
0166+  0692 0A 6B 06    	jmp gets_loop
0167+  0695             gets_backspace:
0168+  0695 7F          	dec d
0169+  0696 0A 6B 06    	jmp gets_loop
0170+  0699             gets_telnet_escape:
0171+  0699 FD 0C       	sti
0172+  069B 19 01       	mov al, 1
0173+  069D 05 03       	syscall sys_io				; receive in AH without echo
0174+  069F B9 00       	cmp al, 0					; check error code (AL)
0175+  06A1 C6 99 06    	je gets_telnet_escape		; if no char received, retry
0176+  06A4 76 5B       	cmp ah, '['
0177+  06A6 C7 6B 06    	jne gets_loop
0178+  06A9             gets_telnet_escape_phase2:
0179+  06A9 FD 0C       	sti
0180+  06AB 19 01       	mov al, 1
0181+  06AD 05 03       	syscall sys_io					; receive in AH without echo
0182+  06AF B9 00       	cmp al, 0						; check error code (AL)
0183+  06B1 C6 A9 06    	je gets_telnet_escape_phase2	; if no char received, retry
0184+  06B4 76 44       	cmp ah, 'D'
0185+  06B6 C6 C1 06    	je gets_left_arrow
0186+  06B9 76 43       	cmp ah, 'C'
0187+  06BB C6 C5 06    	je gets_right_arrow
0188+  06BE 0A 6B 06    	jmp gets_loop
0189+  06C1             gets_left_arrow:
0190+  06C1 7F          	dec d
0191+  06C2 0A 6B 06    	jmp gets_loop
0192+  06C5             gets_right_arrow:
0193+  06C5 79          	inc d
0194+  06C6 0A 6B 06    	jmp gets_loop
0195+  06C9             gets_escape:
0196+  06C9 FD 0C       	sti
0197+  06CB 19 01       	mov al, 1
0198+  06CD 05 03       	syscall sys_io			; receive in AH
0199+  06CF B9 00       	cmp al, 0				; check error code (AL)
0200+  06D1 C6 C9 06    	je gets_escape			; if no char received, retry
0201+  06D4 76 6E       	cmp ah, 'n'
0202+  06D6 C6 E4 06    	je gets_LF
0203+  06D9 76 72       	cmp ah, 'r'
0204+  06DB C6 EB 06    	je gets_CR
0205+  06DE 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0206+  06DF 3E          	mov [d], al
0207+  06E0 79          	inc d
0208+  06E1 0A 6B 06    	jmp gets_loop
0209+  06E4             gets_LF:
0210+  06E4 19 0A       	mov al, $0A
0211+  06E6 3E          	mov [d], al
0212+  06E7 79          	inc d
0213+  06E8 0A 6B 06    	jmp gets_loop
0214+  06EB             gets_CR:
0215+  06EB 19 0D       	mov al, $0D
0216+  06ED 3E          	mov [d], al
0217+  06EE 79          	inc d
0218+  06EF 0A 6B 06    	jmp gets_loop
0219+  06F2             gets_end:
0220+  06F2 19 00       	mov al, 0
0221+  06F4 3E          	mov [d], al				; terminate string
0222+  06F5 E7          	pop d
0223+  06F6 E4          	pop a
0224+  06F7 09          	ret
0225+  06F8             
0226+  06F8             
0227+  06F8             
0228+  06F8             
0229+  06F8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0230+  06F8             ;; INPUT TEXT
0231+  06F8             ;; terminated with CTRL+D
0232+  06F8             ;; pointer in D
0233+  06F8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0234+  06F8             gettxt:
0235+  06F8 D7          	push a
0236+  06F9 DA          	push d
0237+  06FA             gettxt_loop:
0238+  06FA 19 01       	mov al, 1
0239+  06FC 05 03       	syscall sys_io			; receive in AH
0240+  06FE B9 00       	cmp al, 0				; check error code (AL)
0241+  0700 C6 FA 06    	je gettxt_loop		; if no char received, retry
0242+  0703 76 04       	cmp ah, 4			; EOT
0243+  0705 C6 43 07    	je gettxt_end
0244+  0708 76 08       	cmp ah, $08			; check for backspace
0245+  070A C6 3F 07    	je gettxt_backspace
0246+  070D 76 5C       	cmp ah, $5C				; '\\'
0247+  070F C6 18 07    	je gettxt_escape
0248+  0712 1A          	mov al, ah
0249+  0713 3E          	mov [d], al
0250+  0714 79          	inc d
0251+  0715 0A FA 06    	jmp gettxt_loop
0252+  0718             gettxt_escape:
0253+  0718 19 01       	mov al, 1
0254+  071A 05 03       	syscall sys_io			; receive in AH
0255+  071C B9 00       	cmp al, 0				; check error code (AL)
0256+  071E C6 18 07    	je gettxt_escape		; if no char received, retry
0257+  0721 76 6E       	cmp ah, 'n'
0258+  0723 C6 31 07    	je gettxt_LF
0259+  0726 76 72       	cmp ah, 'r'
0260+  0728 C6 38 07    	je gettxt_CR
0261+  072B 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0262+  072C 3E          	mov [d], al
0263+  072D 79          	inc d
0264+  072E 0A FA 06    	jmp gettxt_loop
0265+  0731             gettxt_LF:
0266+  0731 19 0A       	mov al, $0A
0267+  0733 3E          	mov [d], al
0268+  0734 79          	inc d
0269+  0735 0A FA 06    	jmp gettxt_loop
0270+  0738             gettxt_CR:
0271+  0738 19 0D       	mov al, $0D
0272+  073A 3E          	mov [d], al
0273+  073B 79          	inc d
0274+  073C 0A FA 06    	jmp gettxt_loop
0275+  073F             gettxt_backspace:
0276+  073F 7F          	dec d
0277+  0740 0A FA 06    	jmp gettxt_loop
0278+  0743             gettxt_end:
0279+  0743 19 00       	mov al, 0
0280+  0745 3E          	mov [d], al				; terminate string
0281+  0746 E7          	pop d
0282+  0747 E4          	pop a
0283+  0748 09          	ret
0284+  0749             
0285+  0749             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0286+  0749             ; PRINT NEW LINE
0287+  0749             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  0749             printnl:
0289+  0749 D7          	push a
0290+  074A 10 00 0A    	mov a, $0A00
0291+  074D 05 03       	syscall sys_io
0292+  074F 10 00 0D    	mov a, $0D00
0293+  0752 05 03       	syscall sys_io
0294+  0754 E4          	pop a
0295+  0755 09          	ret
0296+  0756             
0297+  0756             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0298+  0756             ; strtoint
0299+  0756             ; 4 digit hex string number in d
0300+  0756             ; integer returned in A
0301+  0756             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0302+  0756             strtointx:
0303+  0756 D8          	push b
0304+  0757 32          	mov bl, [d]
0305+  0758 37          	mov bh, bl
0306+  0759 33 01 00    	mov bl, [d + 1]
0307+  075C 07 17 06    	call atoi				; convert to int in AL
0308+  075F 23          	mov ah, al				; move to AH
0309+  0760 33 02 00    	mov bl, [d + 2]
0310+  0763 37          	mov bh, bl
0311+  0764 33 03 00    	mov bl, [d + 3]
0312+  0767 07 17 06    	call atoi				; convert to int in AL
0313+  076A E5          	pop b
0314+  076B 09          	ret
0315+  076C             
0316+  076C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0317+  076C             ; strtoint
0318+  076C             ; 5 digit base10 string number in d
0319+  076C             ; integer returned in A
0320+  076C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0321+  076C             strtoint:
0322+  076C E2          	push si
0323+  076D D8          	push b
0324+  076E D9          	push c
0325+  076F DA          	push d
0326+  0770 07 9F 05    	call strlen			; get string length in C
0327+  0773 7E          	dec c
0328+  0774 FD 4E       	mov si, d
0329+  0776 12          	mov a, c
0330+  0777 FD 99       	shl a
0331+  0779 3B FF 05    	mov d, table_power
0332+  077C 59          	add d, a
0333+  077D 38 00 00    	mov c, 0
0334+  0780             strtoint_L0:
0335+  0780 F6          	lodsb			; load ASCII to al
0336+  0781 B9 00       	cmp al, 0
0337+  0783 C6 96 07    	je strtoint_end
0338+  0786 6F 30       	sub al, $30		; make into integer
0339+  0788 22 00       	mov ah, 0
0340+  078A 2A          	mov b, [d]
0341+  078B AC          	mul a, b			; result in B since it fits in 16bits
0342+  078C 11          	mov a, b
0343+  078D 28          	mov b, c
0344+  078E 54          	add a, b
0345+  078F 39          	mov c, a
0346+  0790 63 02 00    	sub d, 2
0347+  0793 0A 80 07    	jmp strtoint_L0
0348+  0796             strtoint_end:
0349+  0796 12          	mov a, c
0350+  0797 E7          	pop d
0351+  0798 E6          	pop c
0352+  0799 E5          	pop b
0353+  079A EF          	pop si
0354+  079B 09          	ret
0355+  079C             
0356+  079C             
0357+  079C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0358+  079C             ; PRINT NULL TERMINATED STRING
0359+  079C             ; pointer in D
0360+  079C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0361+  079C             puts:
0362+  079C D7          	push a
0363+  079D DA          	push d
0364+  079E             puts_L1:
0365+  079E 1E          	mov al, [d]
0366+  079F B9 00       	cmp al, 0
0367+  07A1 C6 AD 07    	jz puts_END
0368+  07A4 23          	mov ah, al
0369+  07A5 19 00       	mov al, 0
0370+  07A7 05 03       	syscall sys_io
0371+  07A9 79          	inc d
0372+  07AA 0A 9E 07    	jmp puts_L1
0373+  07AD             puts_END:
0374+  07AD E7          	pop d
0375+  07AE E4          	pop a
0376+  07AF 09          	ret
0377+  07B0             
0378+  07B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  07B0             ; PRINT N SIZE STRING
0380+  07B0             ; pointer in D
0381+  07B0             ; size in C
0382+  07B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0383+  07B0             putsn:
0384+  07B0 DB          	push al
0385+  07B1 DA          	push d
0386+  07B2 D9          	push c
0387+  07B3             putsn_L0:
0388+  07B3 1E          	mov al, [d]
0389+  07B4 23          	mov ah, al
0390+  07B5 19 00       	mov al, 0
0391+  07B7 05 03       	syscall sys_io
0392+  07B9 79          	inc d
0393+  07BA 7E          	dec c	
0394+  07BB C2 00 00    	cmp c, 0
0395+  07BE C7 B3 07    	jne putsn_L0
0396+  07C1             putsn_end:
0397+  07C1 E6          	pop c
0398+  07C2 E7          	pop d
0399+  07C3 E8          	pop al
0400+  07C4 09          	ret
0401+  07C5             
0402+  07C5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0403+  07C5             ; print 16bit decimal number
0404+  07C5             ; input number in A
0405+  07C5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  07C5             print_u16d:
0407+  07C5 D7          	push a
0408+  07C6 D8          	push b
0409+  07C7 26 10 27    	mov b, 10000
0410+  07CA AE          	div a, b			; get 10000 coeff.
0411+  07CB 07 F1 07    	call print_number
0412+  07CE 11          	mov a, b
0413+  07CF 26 E8 03    	mov b, 1000
0414+  07D2 AE          	div a, b			; get 10000 coeff.
0415+  07D3 07 F1 07    	call print_number
0416+  07D6 11          	mov a, b
0417+  07D7 26 64 00    	mov b, 100
0418+  07DA AE          	div a, b
0419+  07DB 07 F1 07    	call print_number
0420+  07DE 11          	mov a, b
0421+  07DF 26 0A 00    	mov b, 10
0422+  07E2 AE          	div a, b
0423+  07E3 07 F1 07    	call print_number
0424+  07E6 11          	mov a, b
0425+  07E7 6A 30       	add al, $30
0426+  07E9 23          	mov ah, al
0427+  07EA 19 00       	mov al, 0
0428+  07EC 05 03       	syscall sys_io	; print coeff
0429+  07EE E5          	pop b
0430+  07EF E4          	pop a
0431+  07F0 09          	ret
0432+  07F1             
0433+  07F1             
0434+  07F1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0435+  07F1             ; if A == 0, print space
0436+  07F1             ; else print A
0437+  07F1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0438+  07F1             print_number:
0439+  07F1 6A 30       	add al, $30
0440+  07F3 23          	mov ah, al
0441+  07F4 07 62 06    	call putchar
0442+  07F7 09          	ret
0443+  07F8             
0444+  07F8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  07F8             ; PRINT 16BIT HEX INTEGER
0446+  07F8             ; integer value in reg B
0447+  07F8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  07F8             print_u16x:
0449+  07F8 D7          	push a
0450+  07F9 D8          	push b
0451+  07FA DD          	push bl
0452+  07FB 30          	mov bl, bh
0453+  07FC 07 29 06    	call itoa				; convert bh to char in A
0454+  07FF 2F          	mov bl, al				; save al
0455+  0800 19 00       	mov al, 0
0456+  0802 05 03       	syscall sys_io				; display AH
0457+  0804 24          	mov ah, bl				; retrieve al
0458+  0805 19 00       	mov al, 0
0459+  0807 05 03       	syscall sys_io				; display AL
0460+  0809             
0461+  0809 EA          	pop bl
0462+  080A 07 29 06    	call itoa				; convert bh to char in A
0463+  080D 2F          	mov bl, al				; save al
0464+  080E 19 00       	mov al, 0
0465+  0810 05 03       	syscall sys_io				; display AH
0466+  0812 24          	mov ah, bl				; retrieve al
0467+  0813 19 00       	mov al, 0
0468+  0815 05 03       	syscall sys_io				; display AL
0469+  0817             
0470+  0817 E5          	pop b
0471+  0818 E4          	pop a
0472+  0819 09          	ret
0473+  081A             
0474+  081A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0475+  081A             ; INPUT 16BIT HEX INTEGER
0476+  081A             ; read 16bit integer into A
0477+  081A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0478+  081A             scan_u16x:
0479+  081A F8 10 00    	enter 16
0480+  081D D8          	push b
0481+  081E DA          	push d
0482+  081F             
0483+  081F FA F1 FF    	lea d, [bp + -15]
0484+  0822 07 69 06    	call gets				; get number
0485+  0825             
0486+  0825 32          	mov bl, [d]
0487+  0826 37          	mov bh, bl
0488+  0827 33 01 00    	mov bl, [d + 1]
0489+  082A 07 17 06    	call atoi				; convert to int in AL
0490+  082D 23          	mov ah, al				; move to AH
0491+  082E             
0492+  082E 33 02 00    	mov bl, [d + 2]
0493+  0831 37          	mov bh, bl
0494+  0832 33 03 00    	mov bl, [d + 3]
0495+  0835 07 17 06    	call atoi				; convert to int in AL
0496+  0838             
0497+  0838 E7          	pop d
0498+  0839 E5          	pop b
0499+  083A F9          	leave
0500+  083B 09          	ret
0501+  083C             
0502+  083C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0503+  083C             ; PRINT 8bit HEX INTEGER
0504+  083C             ; integer value in reg bl
0505+  083C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0506+  083C             print_u8x:
0507+  083C D7          	push a
0508+  083D DD          	push bl
0509+  083E             
0510+  083E 07 29 06    	call itoa				; convert bl to char in A
0511+  0841 2F          	mov bl, al				; save al
0512+  0842 19 00       	mov al, 0
0513+  0844 05 03       	syscall sys_io				; display AH
0514+  0846 24          	mov ah, bl				; retrieve al
0515+  0847 19 00       	mov al, 0
0516+  0849 05 03       	syscall sys_io				; display AL
0517+  084B             
0518+  084B EA          	pop bl
0519+  084C E4          	pop a
0520+  084D 09          	ret
0521+  084E             
0522+  084E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0523+  084E             ; print 8bit decimal unsigned number
0524+  084E             ; input number in AL
0525+  084E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0526+  084E             print_u8d:
0527+  084E D7          	push a
0528+  084F D8          	push b
0529+  0850             
0530+  0850 22 00       	mov ah, 0
0531+  0852 26 64 00    	mov b, 100
0532+  0855 AE          	div a, b
0533+  0856 D8          	push b			; save remainder
0534+  0857 B9 00       	cmp al, 0
0535+  0859 C6 63 08    	je skip100
0536+  085C 6A 30       	add al, $30
0537+  085E 23          	mov ah, al
0538+  085F 19 00       	mov al, 0
0539+  0861 05 03       	syscall sys_io	; print coeff
0540+  0863             skip100:
0541+  0863 E4          	pop a
0542+  0864 22 00       	mov ah, 0
0543+  0866 26 0A 00    	mov b, 10
0544+  0869 AE          	div a, b
0545+  086A D8          	push b			; save remainder
0546+  086B B9 00       	cmp al, 0
0547+  086D C6 77 08    	je skip10
0548+  0870 6A 30       	add al, $30
0549+  0872 23          	mov ah, al
0550+  0873 19 00       	mov al, 0
0551+  0875 05 03       	syscall sys_io	; print coeff
0552+  0877             skip10:
0553+  0877 E4          	pop a
0554+  0878 1B          	mov al, bl
0555+  0879 6A 30       	add al, $30
0556+  087B 23          	mov ah, al
0557+  087C 19 00       	mov al, 0
0558+  087E 05 03       	syscall sys_io	; print coeff
0559+  0880 E5          	pop b
0560+  0881 E4          	pop a
0561+  0882 09          	ret
0562+  0883             
0563+  0883             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0564+  0883             ; INPUT 8BIT HEX INTEGER
0565+  0883             ; read 8bit integer into AL
0566+  0883             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0567+  0883             scan_u8x:
0568+  0883 F8 04 00    	enter 4
0569+  0886 D8          	push b
0570+  0887 DA          	push d
0571+  0888             
0572+  0888 FA FD FF    	lea d, [bp + -3]
0573+  088B 07 69 06    	call gets				; get number
0574+  088E             
0575+  088E 32          	mov bl, [d]
0576+  088F 37          	mov bh, bl
0577+  0890 33 01 00    	mov bl, [d + 1]
0578+  0893 07 17 06    	call atoi				; convert to int in AL
0579+  0896             
0580+  0896 E7          	pop d
0581+  0897 E5          	pop b
0582+  0898 F9          	leave
0583+  0899 09          	ret
0584+  089A             
0585+  089A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0586+  089A             ; input decimal number
0587+  089A             ; result in A
0588+  089A             ; 655'\0'
0589+  089A             ; low--------high
0590+  089A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0591+  089A             scan_u16d:
0592+  089A F8 08 00    	enter 8
0593+  089D E2          	push si
0594+  089E D8          	push b
0595+  089F D9          	push c
0596+  08A0 DA          	push d
0597+  08A1 FA F9 FF    	lea d, [bp +- 7]
0598+  08A4 07 69 06    	call gets
0599+  08A7 07 9F 05    	call strlen			; get string length in C
0600+  08AA 7E          	dec c
0601+  08AB FD 4E       	mov si, d
0602+  08AD 12          	mov a, c
0603+  08AE FD 99       	shl a
0604+  08B0 3B FF 05    	mov d, table_power
0605+  08B3 59          	add d, a
0606+  08B4 38 00 00    	mov c, 0
0607+  08B7             mul_loop:
0608+  08B7 F6          	lodsb			; load ASCII to al
0609+  08B8 B9 00       	cmp al, 0
0610+  08BA C6 CD 08    	je mul_exit
0611+  08BD 6F 30       	sub al, $30		; make into integer
0612+  08BF 22 00       	mov ah, 0
0613+  08C1 2A          	mov b, [d]
0614+  08C2 AC          	mul a, b			; result in B since it fits in 16bits
0615+  08C3 11          	mov a, b
0616+  08C4 28          	mov b, c
0617+  08C5 54          	add a, b
0618+  08C6 39          	mov c, a
0619+  08C7 63 02 00    	sub d, 2
0620+  08CA 0A B7 08    	jmp mul_loop
0621+  08CD             mul_exit:
0622+  08CD 12          	mov a, c
0623+  08CE E7          	pop d
0624+  08CF E6          	pop c
0625+  08D0 E5          	pop b
0626+  08D1 EF          	pop si
0627+  08D2 F9          	leave
0628+  08D3 09          	ret
0098   08D4             .end
0099   08D4             
tasm: Number of errors = 0
