0001   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002   0000             ; ctype.s
0003   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004   0000             
0005   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006   0000             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007   0000             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008   0000             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009   0000             ;; characters are supported.
0010   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011   0000             ;; isalnum 
0012   0000             ;; isalpha 
0013   0000             ;; islower 
0014   0000             ;; isupper 
0015   0000             ;; isdigit 
0016   0000             ;; isxdigit
0017   0000             ;; iscntrl 
0018   0000             ;; isgraph 
0019   0000             ;; isspace 
0020   0000             ;; isblank 
0021   0000             ;; isprint 
0022   0000             ;; ispunct 
0023   0000             ;; tolower 
0024   0000             ;; toupper
0025   0000             
0026   0000             
0027   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028   0000             ;; IS ALPHANUMERIC
0029   0000             ;; sets ZF according with result
0030   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031   0000             isalnum:
0032   0000 07 1D 00    	call isalpha
0033   0003 C6 09 00    	je isalnum_exit
0034   0006 07 0A 00    	call isdigit
0035   0009             isalnum_exit:
0036   0009 09          	ret	
0037   000A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038   000A             ;; IS DIGIT
0039   000A             ;; sets ZF according with result
0040   000A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041   000A             isdigit:
0042   000A DB          	push al
0043   000B B9 30       	cmp al, '0'
0044   000D C8 19 00    	jlu isdigit_false
0045   0010 B9 39       	cmp al, '9'
0046   0012 D1 19 00    	jgu isdigit_false
0047   0015 87 00       	and al, 0	; set ZF
0048   0017 E8          	pop al
0049   0018 09          	ret
0050   0019             isdigit_false:
0051   0019 8B 01       	or al, 1	; clear ZF
0052   001B E8          	pop al
0053   001C 09          	ret	
0054   001D             	
0055   001D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056   001D             ;; IS ALPHA
0057   001D             ;; sets ZF according with result
0058   001D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059   001D             isalpha:
0060   001D DB          	push al
0061   001E B9 5F       	cmp al, '_'
0062   0020 C6 40 00    	je isalpha_true
0063   0023 B9 2E       	cmp al, '.'
0064   0025 C6 40 00    	je isalpha_true
0065   0028 B9 41       	cmp al, 'A'
0066   002A C8 3C 00    	jlu isalpha_false
0067   002D B9 7A       	cmp al, 'z'
0068   002F D1 3C 00    	jgu isalpha_false
0069   0032 B9 5A       	cmp al, 'Z'
0070   0034 D0 40 00    	jleu isalpha_true
0071   0037 B9 61       	cmp al, 'a'
0072   0039 C9 40 00    	jgeu isalpha_true
0073   003C             isalpha_false:
0074   003C 8B 01       	or al, 1	; clear ZF
0075   003E E8          	pop al
0076   003F 09          	ret
0077   0040             isalpha_true:
0078   0040 87 00       	and al, 0	; set ZF
0079   0042 E8          	pop al
0080   0043 09          	ret
0081   0044             
0082   0044             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083   0044             ;; IS PATH-ALPHA
0084   0044             ;; sets ZF according with result
0085   0044             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086   0044             ispath:
0087   0044 DB          	push al
0088   0045 07 0A 00    	call isdigit
0089   0048 C6 72 00    	je ispath_true
0090   004B B9 5F       	cmp al, '_'
0091   004D C6 72 00    	je ispath_true
0092   0050 B9 2F       	cmp al, '/'
0093   0052 C6 72 00    	je ispath_true
0094   0055 B9 2E       	cmp al, '.'
0095   0057 C6 72 00    	je ispath_true
0096   005A B9 41       	cmp al, 'A'
0097   005C C8 6E 00    	jlu ispath_false
0098   005F B9 7A       	cmp al, 'z'
0099   0061 D1 6E 00    	jgu ispath_false
0100   0064 B9 5A       	cmp al, 'Z'
0101   0066 D0 72 00    	jleu ispath_true
0102   0069 B9 61       	cmp al, 'a'
0103   006B C9 72 00    	jgeu ispath_true
0104   006E             ispath_false:
0105   006E 8B 01       	or al, 1	; clear ZF
0106   0070 E8          	pop al
0107   0071 09          	ret
0108   0072             ispath_true:
0109   0072 87 00       	and al, 0	; set ZF
0110   0074 E8          	pop al
0111   0075 09          	ret
0112   0076             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113   0076             ;; IS SPACE
0114   0076             ;; sets ZF according with result
0115   0076             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116   0076             isspace:
0117   0076 B9 20       	cmp al, $20		; ' '
0118   0078 C6 8C 00    	je isspace_exit
0119   007B B9 09       	cmp al, $09		; '\t'
0120   007D C6 8C 00    	je isspace_exit
0121   0080 B9 0A       	cmp al, $0A		; '\n'
0122   0082 C6 8C 00    	je isspace_exit
0123   0085 B9 0D       	cmp al, $0D		; '\r'
0124   0087 C6 8C 00    	je isspace_exit
0125   008A B9 0B       	cmp al, $0B		; '\v'
0126   008C             isspace_exit:
0127   008C 09          	ret	
0128   008D             
0129   008D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130   008D             ; TO LOWER
0131   008D             ; input in AL
0132   008D             ; output in AL
0133   008D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134   008D             to_lower:
0135   008D B9 5A       	cmp al, 'Z'
0136   008F D1 94 00    	jgu to_lower_ret
0137   0092 6A 20       	add al, $20				; convert to lower case
0138   0094             to_lower_ret:
0139   0094 09          	ret
0140   0095             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141   0095             ; TO UPPER
0142   0095             ; input in AL
0143   0095             ; output in AL
0144   0095             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145   0095             to_upper:
0146   0095 B9 61       	cmp al, 'a'
0147   0097 C8 9C 00    	jlu to_upper_ret
0148   009A 6F 20       	sub al, $20			; convert to upper case
0149   009C             to_upper_ret:
0150   009C 09          	ret
0151   009D             
 line 0151: No END directive before EOF.       
tasm: Number of errors = 1
