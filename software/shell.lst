0001   0000             .include "kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0002   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0003   0000             ; SHELL
0004   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0005   0000             
0006   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007   0000             ; SYSTEM CONSTANTS / EQUATIONS
0008   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0009   0000             STACK_BEGIN:	.equ $F7FF	; beginning of stack
0010   0000             
0011   0400             .org PROC_TEXT_ORG			; origin at 1024
0012   0400             
0013   0400             shell_main:	
0014   0400 FD 49 FF F7 	mov bp, STACK_BEGIN
0015   0404 FD 47 FF F7 	mov sp, STACK_BEGIN
0016   0408             
0017   0408 3B E9 08    	mov d, s_prompt_config
0018   040B 07 99 0D    	call puts
0019   040E             ; open config file
0020   040E             ; PATH=/usr/bin;
0021   040E             ; read PATH config entry
0022   040E 3B E3 08    	mov d, s_prompt_PATH
0023   0411 07 99 0D    	call puts
0024   0414 3B 9A 08    	mov d, s_etc_config				; '/etc/sh.conf'
0025   0417 FD 4D B8 08 	mov si, s_PATH					; config entry name is "PATH"
0026   041B FD 4F 0D 08 	mov di, PATH					; config value destination is the var that holds the PATH variable
0027   041F 07 E9 04    	call read_config	
0028   0422 3B 0D 08    	mov d, PATH
0029   0425 07 99 0D    	call puts
0030   0428             ; open config file
0031   0428             ; home = /usr/home/guest;
0032   0428             ; read home directory config entry
0033   0428 3B D2 08    	mov d, s_prompt_homedir
0034   042B 07 99 0D    	call puts
0035   042E 3B 9A 08    	mov d, s_etc_config				; '/etc/sh.conf'
0036   0431 FD 4D A7 08 	mov si, s_home					; config entry name is "home"
0037   0435 FD 4F 0D 07 	mov di, homedir					; config value destination is the var that holds the home directory path
0038   0439 07 E9 04    	call read_config	
0039   043C 3B 0D 07    	mov d, homedir
0040   043F 07 99 0D    	call puts
0041   0442             ; open config file
0042   0442             ; read manpage directory path
0043   0442 3B BD 08    	mov d, s_prompt_manpages
0044   0445 07 99 0D    	call puts
0045   0448 3B 9A 08    	mov d, s_etc_config				; '/etc/sh.conf'
0046   044B FD 4D B4 08 	mov si, s_man					; config entry name is "man"
0047   044F FD 4F 8D 07 	mov di, manpath				; config value destination is the var that holds the man pages directory path
0048   0453 07 E9 04    	call read_config
0049   0456 3B 8D 07    	mov d, manpath
0050   0459 07 99 0D    	call puts
0051   045C             
0052   045C 10 8D 08    	mov a, s_etc_profile
0053   045F 42 98 11    	mov [prog], a
0054   0462 07 32 05    	call cmd_ssh
0055   0465             
0056   0465             shell_L0:
0057   0465 3B 46 09    	mov d, s_sol1
0058   0468 07 99 0D    	call puts
0059   046B 19 12       	mov al, 18
0060   046D 05 04       	syscall sys_fileio				; print current path
0061   046F 3B 40 09    	mov d, s_hash
0062   0472 07 99 0D    	call puts
0063   0475 3B 51 09    	mov d, shell_input_buff
0064   0478 13          	mov a, d
0065   0479 42 98 11    	mov [prog], a			; reset tokenizer buffer pointer
0066   047C 07 66 0C    	call gets						; get command
0067   047F 07 85 04    	call cmd_parser
0068   0482 0A 65 04    	jmp shell_L0
0069   0485             
0070   0485             cmd_parser:
0071   0485 07 F9 0F    	call get_token					; get command into tokstr
0072   0488 FD 4F C8 06 	mov di, commands
0073   048C FD 10       	cla
0074   048E 42 53 0B    	mov [parser_index], a		; reset commands index
0075   0491             parser_L0:
0076   0491 FD 4D 9C 11 	mov si, tokstr
0077   0495 07 AC 0B    	call strcmp
0078   0498 C6 C0 04    	je parser_cmd_equal
0079   049B             parser_L0_L0:
0080   049B FC 00 00    	lea d, [di + 0]
0081   049E BD 00       	cmp byte[d], 0
0082   04A0 C6 A9 04    	je parser_L0_L0_exit			; run through the keyword until finding NULL
0083   04A3 D4 01 00    	add di, 1
0084   04A6 0A 9B 04    	jmp parser_L0_L0
0085   04A9             parser_L0_L0_exit:
0086   04A9 D4 01 00    	add di, 1				; then skip NULL byte at the end 
0087   04AC 14 53 0B    	mov a, [parser_index]
0088   04AF 53 02 00    	add a, 2
0089   04B2 42 53 0B    	mov [parser_index], a			; increase commands table index
0090   04B5 FC 00 00    	lea d, [di + 0]
0091   04B8 BD 00       	cmp byte[d], 0
0092   04BA C6 DF 04    	je parser_cmd_not_found
0093   04BD 0A 91 04    	jmp parser_L0
0094   04C0             parser_cmd_equal:
0095   04C0 10 00 0D    	mov a, $0D00
0096   04C3 05 03       	syscall sys_io				; print carriage return
0097   04C5 14 53 0B    	mov a, [parser_index]			; get the keyword pointer
0098   04C8 FD 07 FB 06 	call [a + keyword_ptrs]		; execute command
0099   04CC 10 00 0D    	mov a, $0D00
0100   04CF 05 03       	syscall sys_io				; print carriage return
0101   04D1             parser_retry:
0102   04D1 07 F9 0F    	call get_token
0103   04D4 BC 9B 11 06 	cmp byte[tok], TOK_SEMI
0104   04D8 C6 85 04    	je cmd_parser
0105   04DB 07 7F 11    	call putback
0106   04DE 09          	ret
0107   04DF             parser_cmd_not_found:
0108   04DF 07 7F 11    	call putback
0109   04E2 07 D9 05    	call cmd_exec			; execute as file/program
0110   04E5 0A D1 04    	jmp parser_retry		; check for more commands
0111   04E8 09          	ret
0112   04E9             
0113   04E9             ; inputs:
0114   04E9             ; D = filename ptr
0115   04E9             ; SI = entry name ptr
0116   04E9             ; DI = output value string ptr
0117   04E9             read_config:
0118   04E9 E3          	push di
0119   04EA E2          	push si
0120   04EB FD 4F 9C 15 	mov di, shell_transient_area
0121   04EF 19 14       	mov al, 20
0122   04F1 05 04       	syscall sys_fileio				; read entire config file
0123   04F3 10 9C 15    	mov a, shell_transient_area
0124   04F6 42 98 11    	mov [prog], a
0125   04F9 EF          	pop si
0126   04FA             read_config_L0:
0127   04FA 07 F9 0F    	call get_token
0128   04FD BC 9B 11 14 	cmp byte[tok], TOK_END
0129   0501 C6 2D 05    	je read_config_EOF
0130   0504 FD 4F 9C 11 	mov di, tokstr
0131   0508 07 AC 0B    	call strcmp
0132   050B C6 1B 05    	je read_config_found_entry
0133   050E             read_config_L0_L0:
0134   050E 07 F9 0F    	call get_token
0135   0511 BC 9B 11 06 	cmp byte[tok], TOK_SEMI
0136   0515 C6 FA 04    	je read_config_L0
0137   0518 0A 0E 05    	jmp read_config_L0_L0
0138   051B             read_config_found_entry:
0139   051B 07 F9 0F    	call get_token			; bypass '=' sign
0140   051E F0          	pop di
0141   051F 14 98 11    	mov a, [prog]
0142   0522 4D          	mov si, a
0143   0523             read_conf_L1:
0144   0523 F6          	lodsb
0145   0524 B9 3B       	cmp al, $3B				; ';'
0146   0526 C6 2E 05    	je read_config_EOF_2
0147   0529 F7          	stosb
0148   052A 0A 23 05    	jmp read_conf_L1
0149   052D             read_config_EOF:
0150   052D F0          	pop di
0151   052E             read_config_EOF_2:
0152   052E 19 00       	mov al, 0
0153   0530 F7          	stosb					; terminate value with NULL
0154   0531 09          	ret
0155   0532             
0156   0532             
0157   0532             cmd_ssh:
0158   0532 07 A2 0F    	call get_path
0159   0535 3B 9C 11    	mov d, tokstr
0160   0538 FD 4F 9C 15 	mov di, shell_transient_area
0161   053C 19 14       	mov al, 20
0162   053E 05 04       	syscall sys_fileio				; read textfile 
0163   0540             	
0164   0540 3B 9C 15    	mov d, shell_transient_area
0165   0543 13          	mov a, d
0166   0544 42 98 11    	mov [prog], a			; reset tokenizer buffer pointer
0167   0547 07 85 04    	call cmd_parser
0168   054A             
0169   054A 07 46 0D    	call printnl
0170   054D 09          	ret
0171   054E             	
0172   054E             ; ************************************************************
0173   054E             ; GET HEX FILE
0174   054E             ; di = destination address
0175   054E             ; return length in bytes in C
0176   054E             ; ************************************************************
0177   054E             load_hex:
0178   054E D2          	push bp
0179   054F 9B          	mov bp, sp
0180   0550 D7          	push a
0181   0551 D8          	push b
0182   0552 DA          	push d
0183   0553 E2          	push si
0184   0554 E3          	push di
0185   0555 52 00 60    	sub sp, $6000				; string data block
0186   0558 38 00 00    	mov c, 0
0187   055B             	
0188   055B 48          	mov a, sp
0189   055C 77          	inc a
0190   055D 3C          	mov d, a				; start of string data block
0191   055E 07 66 0C    	call gets				; get program string
0192   0561 4D          	mov si, a
0193   0562             load_hex_loop:
0194   0562 F6          	lodsb					; load from [SI] to AL
0195   0563 B9 00       	cmp al, 0				; check if ASCII 0
0196   0565 C6 73 05    	jz load_hex_ret
0197   0568 36          	mov bh, al
0198   0569 F6          	lodsb
0199   056A 2F          	mov bl, al
0200   056B 07 14 0C    	call atoi				; convert ASCII byte in B to int (to AL)
0201   056E F7          	stosb					; store AL to [DI]
0202   056F 78          	inc c
0203   0570 0A 62 05    	jmp load_hex_loop
0204   0573             load_hex_ret:
0205   0573 51 00 60    	add sp, $6000
0206   0576 F0          	pop di
0207   0577 EF          	pop si
0208   0578 E7          	pop d
0209   0579 E5          	pop b
0210   057A E4          	pop a
0211   057B 9C          	mov sp, bp
0212   057C F1          	pop bp
0213   057D 09          	ret
0214   057E             
0215   057E             cmd_setdate:
0216   057E 19 01       	mov al, 1			; set datetime
0217   0580 05 07       	syscall sys_datetime	
0218   0582 09          	ret	
0219   0583             	
0220   0583             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0221   0583             ;; FILE SYSTEM DATA
0222   0583             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0223   0583             ; infor for : IDE SERVICES INTERRUPT
0224   0583             ; al = option
0225   0583             ; IDE read/write sector
0226   0583             ; 512 bytes
0227   0583             ; user buffer pointer in D
0228   0583             ; AH = number of sectors
0229   0583             ; CB = LBA bytes 3..0	
0230   0583             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231   0583             ;; FILE SYSTEM DATA STRUCTURE
0232   0583             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0233   0583             ; for a directory we have the header first, followed by metadata
0234   0583             ; header 1 sector (512 bytes)
0235   0583             ; metadata 1 sector (512 bytes)
0236   0583             ; HEADER ENTRIES:
0237   0583             ; filename (64)
0238   0583             ; parent dir LBA (2) -  to be used for faster backwards navigation...
0239   0583             ;
0240   0583             ; metadata entries:
0241   0583             ; filename (24)
0242   0583             ; attributes (1)
0243   0583             ; LBA (2)
0244   0583             ; size (2)
0245   0583             ; day (1)
0246   0583             ; month (1)
0247   0583             ; year (1)
0248   0583             ; packet size = 32 bytes
0249   0583             ;
0250   0583             ; first directory on disk is the root directory '/'
0251   0583             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0252   0583             ;; FILE SYSTEM DISK FORMATTING
0253   0583             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0254   0583             ; writes FST_TOTAL_SECTORS + FS_NBR_FILES disk sectors  with 0's
0255   0583             ; this is the file system table formating
0256   0583             cmd_mkfs:
0257   0583 19 00       	mov al, 0
0258   0585 05 04       	syscall sys_fileio
0259   0587 09          	ret
0260   0588             
0261   0588             
0262   0588             
0263   0588             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0264   0588             ;; parse path
0265   0588             ;; 
0266   0588             ;;
0267   0588             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0268   0588             
0269   0588             
0270   0588             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0271   0588             ;; CD
0272   0588             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0273   0588             ; search for given directory inside current dir
0274   0588             ; if found, read its LBA, and switch directories
0275   0588             ; example:	cd /usr/bin; ls
0276   0588             ; 			cd /usr/bin;
0277   0588             ;			cd /usr/bin
0278   0588             cmd_cd:
0279   0588 07 F9 0F    	call get_token
0280   058B 1D 9B 11    	mov al, [tok]
0281   058E B9 14       	cmp al, TOK_END
0282   0590 C6 B6 05    	je cmd_cd_gotohome
0283   0593 B9 06       	cmp al, TOK_SEMI
0284   0595 C6 B6 05    	je cmd_cd_gotohome
0285   0598 B9 08       	cmp al, TOK_TILDE
0286   059A C6 B6 05    	je cmd_cd_gotohome
0287   059D 07 7F 11    	call putback
0288   05A0 07 A2 0F    	call get_path		; get the path for the cd command
0289   05A3             cmd_cd_syscall:
0290   05A3 3B 9C 11    	mov d, tokstr
0291   05A6 19 13       	mov al, 19
0292   05A8 05 04       	syscall sys_fileio	; get dirID in A
0293   05AA AF FF FF    	cmp a, $FFFF
0294   05AD C6 C7 05    	je cmd_cd_fail
0295   05B0 27          	mov b, a
0296   05B1 19 03       	mov al, 3
0297   05B3 05 04       	syscall sys_fileio	; set dir to B
0298   05B5 09          	ret
0299   05B6             cmd_cd_gotohome:
0300   05B6 07 7F 11    	call putback
0301   05B9 FD 4D 0D 07 	mov si, homedir
0302   05BD FD 4F 9C 11 	mov di, tokstr
0303   05C1 07 C1 0B    	call strcpy
0304   05C4 0A A3 05    	jmp cmd_cd_syscall
0305   05C7             cmd_cd_fail:
0306   05C7 09          	ret
0307   05C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0308   05C8             ;; pad string to 32 chars
0309   05C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0310   05C8             ; count in C
0311   05C8             padding:
0312   05C8 D7          	push a
0313   05C9 10 20 00    	mov a, 32
0314   05CC 28          	mov b, c
0315   05CD 60          	sub a, b
0316   05CE 39          	mov c, a
0317   05CF             padding_L1:
0318   05CF 22 20       	mov ah, $20
0319   05D1 07 5F 0C    	call putchar
0320   05D4 A9 CF 05    	loopc padding_L1
0321   05D7 E4          	pop a
0322   05D8 09          	ret
0323   05D9             ; file structure:
0324   05D9             ; 512 bytes header
0325   05D9             ; header used to tell whether the block is free
0326   05D9             
0327   05D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0328   05D9             ;; EXEC/OPEN PROGRAM/FILE
0329   05D9             ;; 'filename' maps to '/usr/bin/filename'
0330   05D9             ;; './file' or '/a/directory/file' loads a file directly
0331   05D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0332   05D9             cmd_exec:
0333   05D9 BC 9B 11 14 	cmp byte[tok], TOK_END
0334   05DD C6 63 06    	je cmd_exec_ret		; check for NULL input
0335   05E0 07 A2 0F    	call get_path		; get file path 
0336   05E3 14 98 11    	mov a, [prog]
0337   05E6 D7          	push a				; save argument pointer
0338   05E7 FD 4D 9C 11 	mov si, tokstr
0339   05EB FD 4F 9C 12 	mov di, temp_data1
0340   05EF 07 C1 0B    	call strcpy			; copy filename for later
0341   05F2 BC 9C 11 2F 	cmp byte[tokstr], '/'	; check first character of path
0342   05F6 C6 54 06    	je cmd_exec_abs
0343   05F9 BC 9C 11 2E 	cmp byte[tokstr], '.'	; check first character of path
0344   05FD C6 54 06    	je cmd_exec_abs
0345   0600 10 0D 08    	mov a, PATH
0346   0603 42 98 11    	mov [prog], a		; set token pointer to $PATH beginning
0347   0606             cmd_exec_L0:
0348   0606 07 A2 0F    	call get_path		; get a path option
0349   0609 FD 4D 9C 11 	mov si, tokstr
0350   060D FD 4F 9C 13 	mov di, temp_data
0351   0611 07 C1 0B    	call strcpy			; firstly, form address from one of the '$PATH' addresses
0352   0614 FD 4D 44 09 	mov si, s_fslash
0353   0618 FD 4F 9C 13 	mov di, temp_data
0354   061C 07 CF 0B    	call strcat			; add '/' in between $PATH component and filename
0355   061F FD 4D 9C 12 	mov si, temp_data1
0356   0623 FD 4F 9C 13 	mov di, temp_data
0357   0627 07 CF 0B    	call strcat			; now glue the given filename to the total path
0358   062A 3B 9C 13    	mov d, temp_data
0359   062D 19 15       	mov al, 21
0360   062F 05 04       	syscall sys_fileio	; now we check whether such a file exists. success code is given in A. if 0, file does not exist
0361   0631 AF 00 00    	cmp a, 0
0362   0634 C7 44 06    	jne cmd_exec_PATH_exists
0363   0637 07 F9 0F    	call get_token
0364   063A BC 9B 11 06 	cmp byte[tok], TOK_SEMI
0365   063E C6 54 06    	je cmd_exec_abs		; if file not found as $PATH/filename, then try to load it without using $PATH
0366   0641 0A 06 06    	jmp cmd_exec_L0		; if not ';' at the end, then token must be a separator. so try another path
0367   0644             cmd_exec_PATH_exists:
0368   0644 E4          	pop a				; retrieve token pointer which points to the arguments given
0369   0645 42 98 11    	mov [prog], a
0370   0648 07 6E 0F    	call get_arg		; if however, $PATH/filename was found, then we execute it
0371   064B 26 9C 11    	mov b, tokstr
0372   064E 3B 9C 13    	mov d, temp_data
0373   0651 05 05       	syscall sys_fork
0374   0653 09          	ret
0375   0654             cmd_exec_abs:	; execute as absolute path
0376   0654 E4          	pop a
0377   0655 42 98 11    	mov [prog], a
0378   0658 07 6E 0F    	call get_arg
0379   065B 26 9C 11    	mov b, tokstr
0380   065E 3B 9C 12    	mov d, temp_data1	;original filename
0381   0661 05 05       	syscall sys_fork
0382   0663             cmd_exec_ret:
0383   0663 09          	ret
0384   0664             
0385   0664             
0386   0664             cmd_shutdown:
0387   0664 19 01       	mov al, 1
0388   0666 05 02       	syscall sys_IDE
0389   0668 FF          	halt
0390   0669 09          	ret
0391   066A             
0392   066A             cmd_reboot:
0393   066A 3B 15 09    	mov d, s_rebooting
0394   066D 07 99 0D    	call puts
0395   0670 05 08       	syscall sys_reboot
0396   0672             
0397   0672             cmd_drtoggle:
0398   0672 0C          	lodstat
0399   0673 2F          	mov bl, al
0400   0674 FD 87 DF    	and bl, %11011111
0401   0677 87 20       	and al, %00100000
0402   0679 8F 20       	xor al, %00100000
0403   067B 8C          	or al, bl
0404   067C 0D          	stostat
0405   067D             	
0406   067D 09          	ret
0407   067E             
0408   067E             cmd_man:
0409   067E 3B 26 09    	mov d, s_telnet_clear
0410   0681 07 99 0D    	call puts
0411   0684 FD 4D 8D 07 	mov si, manpath
0412   0688 FD 4F 9C 13 	mov di, temp_data
0413   068C 07 C1 0B    	call strcpy				; complete path with command name
0414   068F FD 4D 44 09 	mov si, s_fslash
0415   0693 FD 4F 9C 13 	mov di, temp_data
0416   0697 07 CF 0B    	call strcat				; add '/' to the end
0417   069A 07 F9 0F    	call get_token
0418   069D FD 4D 9C 11 	mov si, tokstr
0419   06A1 FD 4F 9C 13 	mov di, temp_data
0420   06A5 07 CF 0B    	call strcat				; complete path with command name
0421   06A8 3B 9C 13    	mov d, temp_data
0422   06AB FD 4F 9C 15 	mov di, shell_transient_area
0423   06AF 19 14       	mov al, 20
0424   06B1 05 04       	syscall sys_fileio
0425   06B3 3B 9C 15    	mov d, shell_transient_area
0426   06B6 07 99 0D    	call puts
0427   06B9 07 46 0D    	call printnl
0428   06BC             cmd_man_fail:
0429   06BC 09          	ret
0430   06BD             
0431   06BD             cmd_fg:
0432   06BD 07 F9 0F    	call get_token
0433   06C0 1D 9C 11    	mov al, [tokstr]
0434   06C3 6F 30       	sub al, $30
0435   06C5 05 0A       	syscall sys_resumeproc
0436   06C7 09          	ret
0437   06C8             
0438   06C8 6D 6B 66 73 commands:		.db "mkfs", 0
0438   06CC 00 
0439   06CD 63 64 00    				.db "cd", 0
0440   06D0 73 64 61 74 				.db "sdate", 0
0440   06D4 65 00 
0441   06D6 72 65 62 6F 				.db "reboot", 0
0441   06DA 6F 74 00 
0442   06DD 73 68 75 74 				.db "shutdown", 0
0442   06E1 64 6F 77 6E 
0442   06E5 00 
0443   06E6 64 72 74 6F 				.db "drtoggle", 0
0443   06EA 67 67 6C 65 
0443   06EE 00 
0444   06EF 6D 61 6E 00 				.db "man", 0
0445   06F3 66 67 00    				.db "fg", 0
0446   06F6 73 73 68 00 				.db "ssh", 0
0447   06FA 00          				.db 0
0448   06FB             
0449   06FB 83 05       keyword_ptrs:	.dw cmd_mkfs
0450   06FD 88 05       				.dw cmd_cd
0451   06FF 7E 05       				.dw cmd_setdate
0452   0701 6A 06       				.dw cmd_reboot
0453   0703 64 06       				.dw cmd_shutdown
0454   0705 72 06       				.dw cmd_drtoggle
0455   0707 7E 06       				.dw cmd_man
0456   0709 BD 06       				.dw cmd_fg
0457   070B 32 05       				.dw cmd_ssh
0458   070D             
0459   070D 00 00 00 00 homedir:		.fill 128, 0
0459   0711 00 00 00 00 
0459   0715 00 00 00 00 
0459   0719 00 00 00 00 
0459   071D 00 00 00 00 
0459   0721 00 00 00 00 
0459   0725 00 00 00 00 
0459   0729 00 00 00 00 
0459   072D 00 00 00 00 
0459   0731 00 00 00 00 
0459   0735 00 00 00 00 
0459   0739 00 00 00 00 
0459   073D 00 00 00 00 
0459   0741 00 00 00 00 
0459   0745 00 00 00 00 
0459   0749 00 00 00 00 
0459   074D 00 00 00 00 
0459   0751 00 00 00 00 
0459   0755 00 00 00 00 
0459   0759 00 00 00 00 
0459   075D 00 00 00 00 
0459   0761 00 00 00 00 
0459   0765 00 00 00 00 
0459   0769 00 00 00 00 
0459   076D 00 00 00 00 
0459   0771 00 00 00 00 
0459   0775 00 00 00 00 
0459   0779 00 00 00 00 
0459   077D 00 00 00 00 
0459   0781 00 00 00 00 
0459   0785 00 00 00 00 
0459   0789 00 00 00 00 
0460   078D 00 00 00 00 manpath:		.fill 128, 0		; man path
0460   0791 00 00 00 00 
0460   0795 00 00 00 00 
0460   0799 00 00 00 00 
0460   079D 00 00 00 00 
0460   07A1 00 00 00 00 
0460   07A5 00 00 00 00 
0460   07A9 00 00 00 00 
0460   07AD 00 00 00 00 
0460   07B1 00 00 00 00 
0460   07B5 00 00 00 00 
0460   07B9 00 00 00 00 
0460   07BD 00 00 00 00 
0460   07C1 00 00 00 00 
0460   07C5 00 00 00 00 
0460   07C9 00 00 00 00 
0460   07CD 00 00 00 00 
0460   07D1 00 00 00 00 
0460   07D5 00 00 00 00 
0460   07D9 00 00 00 00 
0460   07DD 00 00 00 00 
0460   07E1 00 00 00 00 
0460   07E5 00 00 00 00 
0460   07E9 00 00 00 00 
0460   07ED 00 00 00 00 
0460   07F1 00 00 00 00 
0460   07F5 00 00 00 00 
0460   07F9 00 00 00 00 
0460   07FD 00 00 00 00 
0460   0801 00 00 00 00 
0460   0805 00 00 00 00 
0460   0809 00 00 00 00 
0461   080D 00 00 00 00 PATH:			.fill 128, 0		; $PATH environment variable (for now just one path)
0461   0811 00 00 00 00 
0461   0815 00 00 00 00 
0461   0819 00 00 00 00 
0461   081D 00 00 00 00 
0461   0821 00 00 00 00 
0461   0825 00 00 00 00 
0461   0829 00 00 00 00 
0461   082D 00 00 00 00 
0461   0831 00 00 00 00 
0461   0835 00 00 00 00 
0461   0839 00 00 00 00 
0461   083D 00 00 00 00 
0461   0841 00 00 00 00 
0461   0845 00 00 00 00 
0461   0849 00 00 00 00 
0461   084D 00 00 00 00 
0461   0851 00 00 00 00 
0461   0855 00 00 00 00 
0461   0859 00 00 00 00 
0461   085D 00 00 00 00 
0461   0861 00 00 00 00 
0461   0865 00 00 00 00 
0461   0869 00 00 00 00 
0461   086D 00 00 00 00 
0461   0871 00 00 00 00 
0461   0875 00 00 00 00 
0461   0879 00 00 00 00 
0461   087D 00 00 00 00 
0461   0881 00 00 00 00 
0461   0885 00 00 00 00 
0461   0889 00 00 00 00 
0462   088D             
0463   088D 2F 65 74 63 s_etc_profile:	.db "/etc/profile", 0
0463   0891 2F 70 72 6F 
0463   0895 66 69 6C 65 
0463   0899 00 
0464   089A 2F 65 74 63 s_etc_config:	.db "/etc/sh.conf", 0
0464   089E 2F 73 68 2E 
0464   08A2 63 6F 6E 66 
0464   08A6 00 
0465   08A7 68 6F 6D 65 s_home:			.db "home", 0
0465   08AB 00 
0466   08AC 77 65 6C 63 s_welcome:		.db "welcome", 0
0466   08B0 6F 6D 65 00 
0467   08B4 6D 61 6E 00 s_man:			.db "man", 0
0468   08B8 50 41 54 48 s_PATH:			.db "PATH", 0
0468   08BC 00 
0469   08BD             
0470   08BD 0A 6D 61 6E s_prompt_manpages:	.db "\nmanpages directory=", 0
0470   08C1 70 61 67 65 
0470   08C5 73 20 64 69 
0470   08C9 72 65 63 74 
0470   08CD 6F 72 79 3D 
0470   08D1 00 
0471   08D2 0A 68 6F 6D s_prompt_homedir:	.db "\nhome directory=", 0
0471   08D6 65 20 64 69 
0471   08DA 72 65 63 74 
0471   08DE 6F 72 79 3D 
0471   08E2 00 
0472   08E3 50 41 54 48 s_prompt_PATH:		.db "PATH=", 0
0472   08E7 3D 00 
0473   08E9 0A 72 65 61 s_prompt_config:	.db "\nreading \'/etc/sh.conf\' configuration file\n", 0
0473   08ED 64 69 6E 67 
0473   08F1 20 27 2F 65 
0473   08F5 74 63 2F 73 
0473   08F9 68 2E 63 6F 
0473   08FD 6E 66 27 20 
0473   0901 63 6F 6E 66 
0473   0905 69 67 75 72 
0473   0909 61 74 69 6F 
0473   090D 6E 20 66 69 
0473   0911 6C 65 0A 00 
0474   0915             
0475   0915 1B 5B 32 4A s_rebooting: 	.db 27, "[2J", 27, "[H", "rebooting", 0
0475   0919 1B 5B 48 72 
0475   091D 65 62 6F 6F 
0475   0921 74 69 6E 67 
0475   0925 00 
0476   0926 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0476   092A 1B 5B 48 00 
0477   092E 25 20 00    s_dataentry:	.db "% ", 0
0478   0931 0A 73 79 6E s_syntax_err:	.db "\nsyntax error\n", 0
0478   0935 74 61 78 20 
0478   0939 65 72 72 6F 
0478   093D 72 0A 00 
0479   0940 20 23 20 00 s_hash:			.db " # ", 0
0480   0944 2F 00       s_fslash:		.db "/", 0
0481   0946 53 6F 6C 61 s_sol1:			.db "Solarium: ", 0
0481   094A 72 69 75 6D 
0481   094E 3A 20 00 
0482   0951             ; shell variables
0483   0951 00 00 00 00 shell_input_buff:	.fill 512, 0
0483   0955 00 00 00 00 
0483   0959 00 00 00 00 
0483   095D 00 00 00 00 
0483   0961 00 00 00 00 
0483   0965 00 00 00 00 
0483   0969 00 00 00 00 
0483   096D 00 00 00 00 
0483   0971 00 00 00 00 
0483   0975 00 00 00 00 
0483   0979 00 00 00 00 
0483   097D 00 00 00 00 
0483   0981 00 00 00 00 
0483   0985 00 00 00 00 
0483   0989 00 00 00 00 
0483   098D 00 00 00 00 
0483   0991 00 00 00 00 
0483   0995 00 00 00 00 
0483   0999 00 00 00 00 
0483   099D 00 00 00 00 
0483   09A1 00 00 00 00 
0483   09A5 00 00 00 00 
0483   09A9 00 00 00 00 
0483   09AD 00 00 00 00 
0483   09B1 00 00 00 00 
0483   09B5 00 00 00 00 
0483   09B9 00 00 00 00 
0483   09BD 00 00 00 00 
0483   09C1 00 00 00 00 
0483   09C5 00 00 00 00 
0483   09C9 00 00 00 00 
0483   09CD 00 00 00 00 
0483   09D1 00 00 00 00 
0483   09D5 00 00 00 00 
0483   09D9 00 00 00 00 
0483   09DD 00 00 00 00 
0483   09E1 00 00 00 00 
0483   09E5 00 00 00 00 
0483   09E9 00 00 00 00 
0483   09ED 00 00 00 00 
0483   09F1 00 00 00 00 
0483   09F5 00 00 00 00 
0483   09F9 00 00 00 00 
0483   09FD 00 00 00 00 
0483   0A01 00 00 00 00 
0483   0A05 00 00 00 00 
0483   0A09 00 00 00 00 
0483   0A0D 00 00 00 00 
0483   0A11 00 00 00 00 
0483   0A15 00 00 00 00 
0483   0A19 00 00 00 00 
0483   0A1D 00 00 00 00 
0483   0A21 00 00 00 00 
0483   0A25 00 00 00 00 
0483   0A29 00 00 00 00 
0483   0A2D 00 00 00 00 
0483   0A31 00 00 00 00 
0483   0A35 00 00 00 00 
0483   0A39 00 00 00 00 
0483   0A3D 00 00 00 00 
0483   0A41 00 00 00 00 
0483   0A45 00 00 00 00 
0483   0A49 00 00 00 00 
0483   0A4D 00 00 00 00 
0483   0A51 00 00 00 00 
0483   0A55 00 00 00 00 
0483   0A59 00 00 00 00 
0483   0A5D 00 00 00 00 
0483   0A61 00 00 00 00 
0483   0A65 00 00 00 00 
0483   0A69 00 00 00 00 
0483   0A6D 00 00 00 00 
0483   0A71 00 00 00 00 
0483   0A75 00 00 00 00 
0483   0A79 00 00 00 00 
0483   0A7D 00 00 00 00 
0483   0A81 00 00 00 00 
0483   0A85 00 00 00 00 
0483   0A89 00 00 00 00 
0483   0A8D 00 00 00 00 
0483   0A91 00 00 00 00 
0483   0A95 00 00 00 00 
0483   0A99 00 00 00 00 
0483   0A9D 00 00 00 00 
0483   0AA1 00 00 00 00 
0483   0AA5 00 00 00 00 
0483   0AA9 00 00 00 00 
0483   0AAD 00 00 00 00 
0483   0AB1 00 00 00 00 
0483   0AB5 00 00 00 00 
0483   0AB9 00 00 00 00 
0483   0ABD 00 00 00 00 
0483   0AC1 00 00 00 00 
0483   0AC5 00 00 00 00 
0483   0AC9 00 00 00 00 
0483   0ACD 00 00 00 00 
0483   0AD1 00 00 00 00 
0483   0AD5 00 00 00 00 
0483   0AD9 00 00 00 00 
0483   0ADD 00 00 00 00 
0483   0AE1 00 00 00 00 
0483   0AE5 00 00 00 00 
0483   0AE9 00 00 00 00 
0483   0AED 00 00 00 00 
0483   0AF1 00 00 00 00 
0483   0AF5 00 00 00 00 
0483   0AF9 00 00 00 00 
0483   0AFD 00 00 00 00 
0483   0B01 00 00 00 00 
0483   0B05 00 00 00 00 
0483   0B09 00 00 00 00 
0483   0B0D 00 00 00 00 
0483   0B11 00 00 00 00 
0483   0B15 00 00 00 00 
0483   0B19 00 00 00 00 
0483   0B1D 00 00 00 00 
0483   0B21 00 00 00 00 
0483   0B25 00 00 00 00 
0483   0B29 00 00 00 00 
0483   0B2D 00 00 00 00 
0483   0B31 00 00 00 00 
0483   0B35 00 00 00 00 
0483   0B39 00 00 00 00 
0483   0B3D 00 00 00 00 
0483   0B41 00 00 00 00 
0483   0B45 00 00 00 00 
0483   0B49 00 00 00 00 
0483   0B4D 00 00 00 00 
0484   0B51 00 00       shell_buff_ptr:		.dw 0
0485   0B53 00 00       parser_index: 		.dw 0
0486   0B55             
0487   0B55             .include "stdio.asm"
0001+  0B55             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0B55             ; stdio.s
0003+  0B55             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0B55             .include "string.asm"
0001++ 0B55             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0B55             ; string.s
0003++ 0B55             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0B55             
0005++ 0B55             
0006++ 0B55             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0B55             ; strrev
0008++ 0B55             ; reverse a string
0009++ 0B55             ; D = string address
0010++ 0B55             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0B55             ; 01234
0012++ 0B55             strrev:
0013++ 0B55 4B          	pusha
0014++ 0B56 07 9C 0B    	call strlen	; length in C
0015++ 0B59 12          	mov a, c
0016++ 0B5A AF 01 00    	cmp a, 1
0017++ 0B5D D0 77 0B    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0B60 7D          	dec a
0019++ 0B61 FD 4E       	mov si, d	; beginning of string
0020++ 0B63 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0B65 59          	add d, a	; end of string
0022++ 0B66 12          	mov a, c
0023++ 0B67 FD 9B       	shr a		; divide by 2
0024++ 0B69 39          	mov c, a	; C now counts the steps
0025++ 0B6A             strrev_L0:
0026++ 0B6A 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0B6B F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0B6C 3E          	mov [d], al	; store left char into right side
0029++ 0B6D 1B          	mov al, bl
0030++ 0B6E F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0B6F 7E          	dec c
0032++ 0B70 7F          	dec d
0033++ 0B71 C2 00 00    	cmp c, 0
0034++ 0B74 C7 6A 0B    	jne strrev_L0
0035++ 0B77             strrev_end:
0036++ 0B77 4C          	popa
0037++ 0B78 09          	ret
0038++ 0B79             	
0039++ 0B79             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0B79             ; strchr
0041++ 0B79             ; search string in D for char in AL
0042++ 0B79             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0B79             strchr:
0044++ 0B79             strchr_L0:
0045++ 0B79 32          	mov bl, [d]
0046++ 0B7A C1 00       	cmp bl, 0
0047++ 0B7C C6 87 0B    	je strchr_end
0048++ 0B7F BA          	cmp al, bl
0049++ 0B80 C6 87 0B    	je strchr_end
0050++ 0B83 79          	inc d
0051++ 0B84 0A 79 0B    	jmp strchr_L0
0052++ 0B87             strchr_end:
0053++ 0B87 1B          	mov al, bl
0054++ 0B88 09          	ret
0055++ 0B89             
0056++ 0B89             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0B89             ; strstr
0058++ 0B89             ; find sub-string
0059++ 0B89             ; str1 in SI
0060++ 0B89             ; str2 in DI
0061++ 0B89             ; SI points to end of source string
0062++ 0B89             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0B89             strstr:
0064++ 0B89 DB          	push al
0065++ 0B8A DA          	push d
0066++ 0B8B E3          	push di
0067++ 0B8C             strstr_loop:
0068++ 0B8C F3          	cmpsb					; compare a byte of the strings
0069++ 0B8D C7 98 0B    	jne strstr_ret
0070++ 0B90 FC 00 00    	lea d, [di + 0]
0071++ 0B93 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0B95 C7 8C 0B    	jne strstr_loop				; equal chars but not at end
0073++ 0B98             strstr_ret:
0074++ 0B98 F0          	pop di
0075++ 0B99 E7          	pop d
0076++ 0B9A E8          	pop al
0077++ 0B9B 09          	ret
0078++ 0B9C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0B9C             ; length of null terminated string
0080++ 0B9C             ; result in C
0081++ 0B9C             ; pointer in D
0082++ 0B9C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0B9C             strlen:
0084++ 0B9C DA          	push d
0085++ 0B9D 38 00 00    	mov c, 0
0086++ 0BA0             strlen_L1:
0087++ 0BA0 BD 00       	cmp byte [d], 0
0088++ 0BA2 C6 AA 0B    	je strlen_ret
0089++ 0BA5 79          	inc d
0090++ 0BA6 78          	inc c
0091++ 0BA7 0A A0 0B    	jmp strlen_L1
0092++ 0BAA             strlen_ret:
0093++ 0BAA E7          	pop d
0094++ 0BAB 09          	ret
0095++ 0BAC             
0096++ 0BAC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0BAC             ; STRCMP
0098++ 0BAC             ; compare two strings
0099++ 0BAC             ; str1 in SI
0100++ 0BAC             ; str2 in DI
0101++ 0BAC             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0BAC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0BAC             strcmp:
0104++ 0BAC DB          	push al
0105++ 0BAD DA          	push d
0106++ 0BAE E3          	push di
0107++ 0BAF E2          	push si
0108++ 0BB0             strcmp_loop:
0109++ 0BB0 F3          	cmpsb					; compare a byte of the strings
0110++ 0BB1 C7 BC 0B    	jne strcmp_ret
0111++ 0BB4 FB FF FF    	lea d, [si +- 1]
0112++ 0BB7 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0BB9 C7 B0 0B    	jne strcmp_loop				; equal chars but not at end
0114++ 0BBC             strcmp_ret:
0115++ 0BBC EF          	pop si
0116++ 0BBD F0          	pop di
0117++ 0BBE E7          	pop d
0118++ 0BBF E8          	pop al
0119++ 0BC0 09          	ret
0120++ 0BC1             
0121++ 0BC1             
0122++ 0BC1             ; STRCPY
0123++ 0BC1             ; copy null terminated string from SI to DI
0124++ 0BC1             ; source in SI
0125++ 0BC1             ; destination in DI
0126++ 0BC1             strcpy:
0127++ 0BC1 E2          	push si
0128++ 0BC2 E3          	push di
0129++ 0BC3 DB          	push al
0130++ 0BC4             strcpy_L1:
0131++ 0BC4 F6          	lodsb
0132++ 0BC5 F7          	stosb
0133++ 0BC6 B9 00       	cmp al, 0
0134++ 0BC8 C7 C4 0B    	jne strcpy_L1
0135++ 0BCB             strcpy_end:
0136++ 0BCB E8          	pop al
0137++ 0BCC F0          	pop di
0138++ 0BCD EF          	pop si
0139++ 0BCE 09          	ret
0140++ 0BCF             
0141++ 0BCF             ; STRCAT
0142++ 0BCF             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0BCF             ; source in SI
0144++ 0BCF             ; destination in DI
0145++ 0BCF             strcat:
0146++ 0BCF E2          	push si
0147++ 0BD0 E3          	push di
0148++ 0BD1 D7          	push a
0149++ 0BD2 DA          	push d
0150++ 0BD3 50          	mov a, di
0151++ 0BD4 3C          	mov d, a
0152++ 0BD5             strcat_goto_end_L1:
0153++ 0BD5 BD 00       	cmp byte[d], 0
0154++ 0BD7 C6 DE 0B    	je strcat_start
0155++ 0BDA 79          	inc d
0156++ 0BDB 0A D5 0B    	jmp strcat_goto_end_L1
0157++ 0BDE             strcat_start:
0158++ 0BDE FD 50       	mov di, d
0159++ 0BE0             strcat_L1:
0160++ 0BE0 F6          	lodsb
0161++ 0BE1 F7          	stosb
0162++ 0BE2 B9 00       	cmp al, 0
0163++ 0BE4 C7 E0 0B    	jne strcat_L1
0164++ 0BE7             strcat_end:
0165++ 0BE7 E7          	pop d
0166++ 0BE8 E4          	pop a
0167++ 0BE9 F0          	pop di
0168++ 0BEA EF          	pop si
0169++ 0BEB 09          	ret
0005+  0BEC             
0006+  0BEC 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  0BF0 34 35 36 37 
0006+  0BF4 38 39 41 42 
0006+  0BF8 43 44 45 46 
0007+  0BFC             
0008+  0BFC 01 00       table_power:.dw 1
0009+  0BFE 0A 00       			.dw 10
0010+  0C00 64 00       			.dw 100
0011+  0C02 E8 03       			.dw 1000
0012+  0C04 10 27       			.dw 10000
0013+  0C06             
0014+  0C06             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0015+  0C06             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0016+  0C06             ; ASCII in BL
0017+  0C06             ; result in AL
0018+  0C06             ; ascii for F = 0100 0110
0019+  0C06             ; ascii for 9 = 0011 1001
0020+  0C06             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0021+  0C06             hex_ascii_encode:
0022+  0C06 1B          	mov al, bl
0023+  0C07 93 40       	test al, $40				; test if letter or number
0024+  0C09 C7 0F 0C    	jnz hex_letter
0025+  0C0C 87 0F       	and al, $0F				; get number
0026+  0C0E 09          	ret
0027+  0C0F             hex_letter:
0028+  0C0F 87 0F       	and al, $0F				; get letter
0029+  0C11 6A 09       	add al, 9
0030+  0C13 09          	ret
0031+  0C14             
0032+  0C14             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0033+  0C14             ; ATOI
0034+  0C14             ; 2 letter hex string in B
0035+  0C14             ; 8bit integer returned in AL
0036+  0C14             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0037+  0C14             atoi:
0038+  0C14 D8          	push b
0039+  0C15 07 06 0C    	call hex_ascii_encode			; convert BL to 4bit code in AL
0040+  0C18 30          	mov bl, bh
0041+  0C19 DB          	push al					; save a
0042+  0C1A 07 06 0C    	call hex_ascii_encode
0043+  0C1D EA          	pop bl	
0044+  0C1E FD 9E 04    	shl al, 4
0045+  0C21 8C          	or al, bl
0046+  0C22 E5          	pop b
0047+  0C23 09          	ret	
0048+  0C24             
0049+  0C24             
0050+  0C24             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  0C24             ; printf
0052+  0C24             ; no need for explanations!
0053+  0C24             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0054+  0C24             printf:
0055+  0C24 09          	ret
0056+  0C25             
0057+  0C25             
0058+  0C25             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  0C25             ; scanf
0060+  0C25             ; no need for explanations!
0061+  0C25             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  0C25             scanf:
0063+  0C25 09          	ret
0064+  0C26             
0065+  0C26             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  0C26             ; ITOA
0067+  0C26             ; 8bit value in BL
0068+  0C26             ; 2 byte ASCII result in A
0069+  0C26             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0070+  0C26             itoa:
0071+  0C26 DA          	push d
0072+  0C27 D8          	push b
0073+  0C28 A7 00       	mov bh, 0
0074+  0C2A FD A4 04    	shr bl, 4	
0075+  0C2D 74          	mov d, b
0076+  0C2E 1F EC 0B    	mov al, [d + s_hex_digits]
0077+  0C31 23          	mov ah, al
0078+  0C32             	
0079+  0C32 E5          	pop b
0080+  0C33 D8          	push b
0081+  0C34 A7 00       	mov bh, 0
0082+  0C36 FD 87 0F    	and bl, $0F
0083+  0C39 74          	mov d, b
0084+  0C3A 1F EC 0B    	mov al, [d + s_hex_digits]
0085+  0C3D E5          	pop b
0086+  0C3E E7          	pop d
0087+  0C3F 09          	ret
0088+  0C40             
0089+  0C40             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0090+  0C40             ; HEX STRING TO BINARY
0091+  0C40             ; di = destination address
0092+  0C40             ; si = source
0093+  0C40             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0094+  0C40             hex_to_int:
0095+  0C40             hex_to_int_L1:
0096+  0C40 F6          	lodsb					; load from [SI] to AL
0097+  0C41 B9 00       	cmp al, 0				; check if ASCII 0
0098+  0C43 C6 50 0C    	jz hex_to_int_ret
0099+  0C46 36          	mov bh, al
0100+  0C47 F6          	lodsb
0101+  0C48 2F          	mov bl, al
0102+  0C49 07 14 0C    	call atoi				; convert ASCII byte in B to int (to AL)
0103+  0C4C F7          	stosb					; store AL to [DI]
0104+  0C4D 0A 40 0C    	jmp hex_to_int_L1
0105+  0C50             hex_to_int_ret:
0106+  0C50 09          	ret		
0107+  0C51             
0108+  0C51             
0109+  0C51             
0110+  0C51             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  0C51             ; GETCHAR
0112+  0C51             ; char in ah
0113+  0C51             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0114+  0C51             getchar:
0115+  0C51 DB          	push al
0116+  0C52             getchar_retry:
0117+  0C52 FD 0C       	sti
0118+  0C54 19 01       	mov al, 1
0119+  0C56 05 03       	syscall sys_io			; receive in AH
0120+  0C58 B9 00       	cmp al, 0			; check if any char was receive
0121+  0C5A C6 52 0C    	je getchar_retry
0122+  0C5D E8          	pop al
0123+  0C5E 09          	ret
0124+  0C5F             
0125+  0C5F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0126+  0C5F             ; PUTCHAR
0127+  0C5F             ; char in ah
0128+  0C5F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  0C5F             putchar:
0130+  0C5F D7          	push a
0131+  0C60 19 00       	mov al, 0
0132+  0C62 05 03       	syscall sys_io			; char in AH
0133+  0C64 E4          	pop a
0134+  0C65 09          	ret
0135+  0C66             
0136+  0C66             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0137+  0C66             ;; INPUT A STRING
0138+  0C66             ;; terminates with null
0139+  0C66             ;; pointer in D
0140+  0C66             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  0C66             gets:
0142+  0C66 D7          	push a
0143+  0C67 DA          	push d
0144+  0C68             gets_loop:
0145+  0C68 FD 0C       	sti
0146+  0C6A 19 01       	mov al, 1
0147+  0C6C 05 03       	syscall sys_io			; receive in AH
0148+  0C6E B9 00       	cmp al, 0				; check error code (AL)
0149+  0C70 C6 68 0C    	je gets_loop			; if no char received, retry
0150+  0C73             
0151+  0C73 76 1B       	cmp ah, 27
0152+  0C75 C6 96 0C    	je gets_telnet_escape
0153+  0C78 76 0A       	cmp ah, $0A				; LF
0154+  0C7A C6 EF 0C    	je gets_end
0155+  0C7D 76 0D       	cmp ah, $0D				; CR
0156+  0C7F C6 EF 0C    	je gets_end
0157+  0C82 76 5C       	cmp ah, $5C				; '\\'
0158+  0C84 C6 C6 0C    	je gets_escape
0159+  0C87             	
0160+  0C87 76 08       	cmp ah, $08			; check for backspace
0161+  0C89 C6 92 0C    	je gets_backspace
0162+  0C8C             
0163+  0C8C 1A          	mov al, ah
0164+  0C8D 3E          	mov [d], al
0165+  0C8E 79          	inc d
0166+  0C8F 0A 68 0C    	jmp gets_loop
0167+  0C92             gets_backspace:
0168+  0C92 7F          	dec d
0169+  0C93 0A 68 0C    	jmp gets_loop
0170+  0C96             gets_telnet_escape:
0171+  0C96 FD 0C       	sti
0172+  0C98 19 01       	mov al, 1
0173+  0C9A 05 03       	syscall sys_io				; receive in AH without echo
0174+  0C9C B9 00       	cmp al, 0					; check error code (AL)
0175+  0C9E C6 96 0C    	je gets_telnet_escape		; if no char received, retry
0176+  0CA1 76 5B       	cmp ah, '['
0177+  0CA3 C7 68 0C    	jne gets_loop
0178+  0CA6             gets_telnet_escape_phase2:
0179+  0CA6 FD 0C       	sti
0180+  0CA8 19 01       	mov al, 1
0181+  0CAA 05 03       	syscall sys_io					; receive in AH without echo
0182+  0CAC B9 00       	cmp al, 0						; check error code (AL)
0183+  0CAE C6 A6 0C    	je gets_telnet_escape_phase2	; if no char received, retry
0184+  0CB1 76 44       	cmp ah, 'D'
0185+  0CB3 C6 BE 0C    	je gets_left_arrow
0186+  0CB6 76 43       	cmp ah, 'C'
0187+  0CB8 C6 C2 0C    	je gets_right_arrow
0188+  0CBB 0A 68 0C    	jmp gets_loop
0189+  0CBE             gets_left_arrow:
0190+  0CBE 7F          	dec d
0191+  0CBF 0A 68 0C    	jmp gets_loop
0192+  0CC2             gets_right_arrow:
0193+  0CC2 79          	inc d
0194+  0CC3 0A 68 0C    	jmp gets_loop
0195+  0CC6             gets_escape:
0196+  0CC6 FD 0C       	sti
0197+  0CC8 19 01       	mov al, 1
0198+  0CCA 05 03       	syscall sys_io			; receive in AH
0199+  0CCC B9 00       	cmp al, 0				; check error code (AL)
0200+  0CCE C6 C6 0C    	je gets_escape			; if no char received, retry
0201+  0CD1 76 6E       	cmp ah, 'n'
0202+  0CD3 C6 E1 0C    	je gets_LF
0203+  0CD6 76 72       	cmp ah, 'r'
0204+  0CD8 C6 E8 0C    	je gets_CR
0205+  0CDB 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0206+  0CDC 3E          	mov [d], al
0207+  0CDD 79          	inc d
0208+  0CDE 0A 68 0C    	jmp gets_loop
0209+  0CE1             gets_LF:
0210+  0CE1 19 0A       	mov al, $0A
0211+  0CE3 3E          	mov [d], al
0212+  0CE4 79          	inc d
0213+  0CE5 0A 68 0C    	jmp gets_loop
0214+  0CE8             gets_CR:
0215+  0CE8 19 0D       	mov al, $0D
0216+  0CEA 3E          	mov [d], al
0217+  0CEB 79          	inc d
0218+  0CEC 0A 68 0C    	jmp gets_loop
0219+  0CEF             gets_end:
0220+  0CEF 19 00       	mov al, 0
0221+  0CF1 3E          	mov [d], al				; terminate string
0222+  0CF2 E7          	pop d
0223+  0CF3 E4          	pop a
0224+  0CF4 09          	ret
0225+  0CF5             
0226+  0CF5             
0227+  0CF5             
0228+  0CF5             
0229+  0CF5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0230+  0CF5             ;; INPUT TEXT
0231+  0CF5             ;; terminated with CTRL+D
0232+  0CF5             ;; pointer in D
0233+  0CF5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0234+  0CF5             gettxt:
0235+  0CF5 D7          	push a
0236+  0CF6 DA          	push d
0237+  0CF7             gettxt_loop:
0238+  0CF7 19 01       	mov al, 1
0239+  0CF9 05 03       	syscall sys_io			; receive in AH
0240+  0CFB B9 00       	cmp al, 0				; check error code (AL)
0241+  0CFD C6 F7 0C    	je gettxt_loop		; if no char received, retry
0242+  0D00 76 04       	cmp ah, 4			; EOT
0243+  0D02 C6 40 0D    	je gettxt_end
0244+  0D05 76 08       	cmp ah, $08			; check for backspace
0245+  0D07 C6 3C 0D    	je gettxt_backspace
0246+  0D0A 76 5C       	cmp ah, $5C				; '\\'
0247+  0D0C C6 15 0D    	je gettxt_escape
0248+  0D0F 1A          	mov al, ah
0249+  0D10 3E          	mov [d], al
0250+  0D11 79          	inc d
0251+  0D12 0A F7 0C    	jmp gettxt_loop
0252+  0D15             gettxt_escape:
0253+  0D15 19 01       	mov al, 1
0254+  0D17 05 03       	syscall sys_io			; receive in AH
0255+  0D19 B9 00       	cmp al, 0				; check error code (AL)
0256+  0D1B C6 15 0D    	je gettxt_escape		; if no char received, retry
0257+  0D1E 76 6E       	cmp ah, 'n'
0258+  0D20 C6 2E 0D    	je gettxt_LF
0259+  0D23 76 72       	cmp ah, 'r'
0260+  0D25 C6 35 0D    	je gettxt_CR
0261+  0D28 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0262+  0D29 3E          	mov [d], al
0263+  0D2A 79          	inc d
0264+  0D2B 0A F7 0C    	jmp gettxt_loop
0265+  0D2E             gettxt_LF:
0266+  0D2E 19 0A       	mov al, $0A
0267+  0D30 3E          	mov [d], al
0268+  0D31 79          	inc d
0269+  0D32 0A F7 0C    	jmp gettxt_loop
0270+  0D35             gettxt_CR:
0271+  0D35 19 0D       	mov al, $0D
0272+  0D37 3E          	mov [d], al
0273+  0D38 79          	inc d
0274+  0D39 0A F7 0C    	jmp gettxt_loop
0275+  0D3C             gettxt_backspace:
0276+  0D3C 7F          	dec d
0277+  0D3D 0A F7 0C    	jmp gettxt_loop
0278+  0D40             gettxt_end:
0279+  0D40 19 00       	mov al, 0
0280+  0D42 3E          	mov [d], al				; terminate string
0281+  0D43 E7          	pop d
0282+  0D44 E4          	pop a
0283+  0D45 09          	ret
0284+  0D46             
0285+  0D46             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0286+  0D46             ; PRINT NEW LINE
0287+  0D46             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  0D46             printnl:
0289+  0D46 D7          	push a
0290+  0D47 10 00 0A    	mov a, $0A00
0291+  0D4A 05 03       	syscall sys_io
0292+  0D4C 10 00 0D    	mov a, $0D00
0293+  0D4F 05 03       	syscall sys_io
0294+  0D51 E4          	pop a
0295+  0D52 09          	ret
0296+  0D53             
0297+  0D53             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0298+  0D53             ; strtoint
0299+  0D53             ; 4 digit hex string number in d
0300+  0D53             ; integer returned in A
0301+  0D53             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0302+  0D53             strtointx:
0303+  0D53 D8          	push b
0304+  0D54 32          	mov bl, [d]
0305+  0D55 37          	mov bh, bl
0306+  0D56 33 01 00    	mov bl, [d + 1]
0307+  0D59 07 14 0C    	call atoi				; convert to int in AL
0308+  0D5C 23          	mov ah, al				; move to AH
0309+  0D5D 33 02 00    	mov bl, [d + 2]
0310+  0D60 37          	mov bh, bl
0311+  0D61 33 03 00    	mov bl, [d + 3]
0312+  0D64 07 14 0C    	call atoi				; convert to int in AL
0313+  0D67 E5          	pop b
0314+  0D68 09          	ret
0315+  0D69             
0316+  0D69             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0317+  0D69             ; strtoint
0318+  0D69             ; 5 digit base10 string number in d
0319+  0D69             ; integer returned in A
0320+  0D69             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0321+  0D69             strtoint:
0322+  0D69 E2          	push si
0323+  0D6A D8          	push b
0324+  0D6B D9          	push c
0325+  0D6C DA          	push d
0326+  0D6D 07 9C 0B    	call strlen			; get string length in C
0327+  0D70 7E          	dec c
0328+  0D71 FD 4E       	mov si, d
0329+  0D73 12          	mov a, c
0330+  0D74 FD 99       	shl a
0331+  0D76 3B FC 0B    	mov d, table_power
0332+  0D79 59          	add d, a
0333+  0D7A 38 00 00    	mov c, 0
0334+  0D7D             strtoint_L0:
0335+  0D7D F6          	lodsb			; load ASCII to al
0336+  0D7E B9 00       	cmp al, 0
0337+  0D80 C6 93 0D    	je strtoint_end
0338+  0D83 6F 30       	sub al, $30		; make into integer
0339+  0D85 22 00       	mov ah, 0
0340+  0D87 2A          	mov b, [d]
0341+  0D88 AC          	mul a, b			; result in B since it fits in 16bits
0342+  0D89 11          	mov a, b
0343+  0D8A 28          	mov b, c
0344+  0D8B 54          	add a, b
0345+  0D8C 39          	mov c, a
0346+  0D8D 63 02 00    	sub d, 2
0347+  0D90 0A 7D 0D    	jmp strtoint_L0
0348+  0D93             strtoint_end:
0349+  0D93 12          	mov a, c
0350+  0D94 E7          	pop d
0351+  0D95 E6          	pop c
0352+  0D96 E5          	pop b
0353+  0D97 EF          	pop si
0354+  0D98 09          	ret
0355+  0D99             
0356+  0D99             
0357+  0D99             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0358+  0D99             ; PRINT NULL TERMINATED STRING
0359+  0D99             ; pointer in D
0360+  0D99             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0361+  0D99             puts:
0362+  0D99 D7          	push a
0363+  0D9A DA          	push d
0364+  0D9B             puts_L1:
0365+  0D9B 1E          	mov al, [d]
0366+  0D9C B9 00       	cmp al, 0
0367+  0D9E C6 AA 0D    	jz puts_END
0368+  0DA1 23          	mov ah, al
0369+  0DA2 19 00       	mov al, 0
0370+  0DA4 05 03       	syscall sys_io
0371+  0DA6 79          	inc d
0372+  0DA7 0A 9B 0D    	jmp puts_L1
0373+  0DAA             puts_END:
0374+  0DAA E7          	pop d
0375+  0DAB E4          	pop a
0376+  0DAC 09          	ret
0377+  0DAD             
0378+  0DAD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  0DAD             ; PRINT N SIZE STRING
0380+  0DAD             ; pointer in D
0381+  0DAD             ; size in C
0382+  0DAD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0383+  0DAD             putsn:
0384+  0DAD DB          	push al
0385+  0DAE DA          	push d
0386+  0DAF D9          	push c
0387+  0DB0             putsn_L0:
0388+  0DB0 1E          	mov al, [d]
0389+  0DB1 23          	mov ah, al
0390+  0DB2 19 00       	mov al, 0
0391+  0DB4 05 03       	syscall sys_io
0392+  0DB6 79          	inc d
0393+  0DB7 7E          	dec c	
0394+  0DB8 C2 00 00    	cmp c, 0
0395+  0DBB C7 B0 0D    	jne putsn_L0
0396+  0DBE             putsn_end:
0397+  0DBE E6          	pop c
0398+  0DBF E7          	pop d
0399+  0DC0 E8          	pop al
0400+  0DC1 09          	ret
0401+  0DC2             
0402+  0DC2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0403+  0DC2             ; print 16bit decimal number
0404+  0DC2             ; input number in A
0405+  0DC2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  0DC2             print_u16d:
0407+  0DC2 D7          	push a
0408+  0DC3 D8          	push b
0409+  0DC4 26 10 27    	mov b, 10000
0410+  0DC7 AE          	div a, b			; get 10000 coeff.
0411+  0DC8 07 EE 0D    	call print_number
0412+  0DCB 11          	mov a, b
0413+  0DCC 26 E8 03    	mov b, 1000
0414+  0DCF AE          	div a, b			; get 10000 coeff.
0415+  0DD0 07 EE 0D    	call print_number
0416+  0DD3 11          	mov a, b
0417+  0DD4 26 64 00    	mov b, 100
0418+  0DD7 AE          	div a, b
0419+  0DD8 07 EE 0D    	call print_number
0420+  0DDB 11          	mov a, b
0421+  0DDC 26 0A 00    	mov b, 10
0422+  0DDF AE          	div a, b
0423+  0DE0 07 EE 0D    	call print_number
0424+  0DE3 11          	mov a, b
0425+  0DE4 6A 30       	add al, $30
0426+  0DE6 23          	mov ah, al
0427+  0DE7 19 00       	mov al, 0
0428+  0DE9 05 03       	syscall sys_io	; print coeff
0429+  0DEB E5          	pop b
0430+  0DEC E4          	pop a
0431+  0DED 09          	ret
0432+  0DEE             
0433+  0DEE             
0434+  0DEE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0435+  0DEE             ; if A == 0, print space
0436+  0DEE             ; else print A
0437+  0DEE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0438+  0DEE             print_number:
0439+  0DEE 6A 30       	add al, $30
0440+  0DF0 23          	mov ah, al
0441+  0DF1 07 5F 0C    	call putchar
0442+  0DF4 09          	ret
0443+  0DF5             
0444+  0DF5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  0DF5             ; PRINT 16BIT HEX INTEGER
0446+  0DF5             ; integer value in reg B
0447+  0DF5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  0DF5             print_u16x:
0449+  0DF5 D7          	push a
0450+  0DF6 D8          	push b
0451+  0DF7 DD          	push bl
0452+  0DF8 30          	mov bl, bh
0453+  0DF9 07 26 0C    	call itoa				; convert bh to char in A
0454+  0DFC 2F          	mov bl, al				; save al
0455+  0DFD 19 00       	mov al, 0
0456+  0DFF 05 03       	syscall sys_io				; display AH
0457+  0E01 24          	mov ah, bl				; retrieve al
0458+  0E02 19 00       	mov al, 0
0459+  0E04 05 03       	syscall sys_io				; display AL
0460+  0E06             
0461+  0E06 EA          	pop bl
0462+  0E07 07 26 0C    	call itoa				; convert bh to char in A
0463+  0E0A 2F          	mov bl, al				; save al
0464+  0E0B 19 00       	mov al, 0
0465+  0E0D 05 03       	syscall sys_io				; display AH
0466+  0E0F 24          	mov ah, bl				; retrieve al
0467+  0E10 19 00       	mov al, 0
0468+  0E12 05 03       	syscall sys_io				; display AL
0469+  0E14             
0470+  0E14 E5          	pop b
0471+  0E15 E4          	pop a
0472+  0E16 09          	ret
0473+  0E17             
0474+  0E17             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0475+  0E17             ; INPUT 16BIT HEX INTEGER
0476+  0E17             ; read 16bit integer into A
0477+  0E17             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0478+  0E17             scan_u16x:
0479+  0E17 F8 10 00    	enter 16
0480+  0E1A D8          	push b
0481+  0E1B DA          	push d
0482+  0E1C             
0483+  0E1C FA F1 FF    	lea d, [bp + -15]
0484+  0E1F 07 66 0C    	call gets				; get number
0485+  0E22             
0486+  0E22 32          	mov bl, [d]
0487+  0E23 37          	mov bh, bl
0488+  0E24 33 01 00    	mov bl, [d + 1]
0489+  0E27 07 14 0C    	call atoi				; convert to int in AL
0490+  0E2A 23          	mov ah, al				; move to AH
0491+  0E2B             
0492+  0E2B 33 02 00    	mov bl, [d + 2]
0493+  0E2E 37          	mov bh, bl
0494+  0E2F 33 03 00    	mov bl, [d + 3]
0495+  0E32 07 14 0C    	call atoi				; convert to int in AL
0496+  0E35             
0497+  0E35 E7          	pop d
0498+  0E36 E5          	pop b
0499+  0E37 F9          	leave
0500+  0E38 09          	ret
0501+  0E39             
0502+  0E39             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0503+  0E39             ; PRINT 8bit HEX INTEGER
0504+  0E39             ; integer value in reg bl
0505+  0E39             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0506+  0E39             print_u8x:
0507+  0E39 D7          	push a
0508+  0E3A DD          	push bl
0509+  0E3B             
0510+  0E3B 07 26 0C    	call itoa				; convert bl to char in A
0511+  0E3E 2F          	mov bl, al				; save al
0512+  0E3F 19 00       	mov al, 0
0513+  0E41 05 03       	syscall sys_io				; display AH
0514+  0E43 24          	mov ah, bl				; retrieve al
0515+  0E44 19 00       	mov al, 0
0516+  0E46 05 03       	syscall sys_io				; display AL
0517+  0E48             
0518+  0E48 EA          	pop bl
0519+  0E49 E4          	pop a
0520+  0E4A 09          	ret
0521+  0E4B             
0522+  0E4B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0523+  0E4B             ; print 8bit decimal unsigned number
0524+  0E4B             ; input number in AL
0525+  0E4B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0526+  0E4B             print_u8d:
0527+  0E4B D7          	push a
0528+  0E4C D8          	push b
0529+  0E4D             
0530+  0E4D 22 00       	mov ah, 0
0531+  0E4F 26 64 00    	mov b, 100
0532+  0E52 AE          	div a, b
0533+  0E53 D8          	push b			; save remainder
0534+  0E54 B9 00       	cmp al, 0
0535+  0E56 C6 60 0E    	je skip100
0536+  0E59 6A 30       	add al, $30
0537+  0E5B 23          	mov ah, al
0538+  0E5C 19 00       	mov al, 0
0539+  0E5E 05 03       	syscall sys_io	; print coeff
0540+  0E60             skip100:
0541+  0E60 E4          	pop a
0542+  0E61 22 00       	mov ah, 0
0543+  0E63 26 0A 00    	mov b, 10
0544+  0E66 AE          	div a, b
0545+  0E67 D8          	push b			; save remainder
0546+  0E68 B9 00       	cmp al, 0
0547+  0E6A C6 74 0E    	je skip10
0548+  0E6D 6A 30       	add al, $30
0549+  0E6F 23          	mov ah, al
0550+  0E70 19 00       	mov al, 0
0551+  0E72 05 03       	syscall sys_io	; print coeff
0552+  0E74             skip10:
0553+  0E74 E4          	pop a
0554+  0E75 1B          	mov al, bl
0555+  0E76 6A 30       	add al, $30
0556+  0E78 23          	mov ah, al
0557+  0E79 19 00       	mov al, 0
0558+  0E7B 05 03       	syscall sys_io	; print coeff
0559+  0E7D E5          	pop b
0560+  0E7E E4          	pop a
0561+  0E7F 09          	ret
0562+  0E80             
0563+  0E80             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0564+  0E80             ; INPUT 8BIT HEX INTEGER
0565+  0E80             ; read 8bit integer into AL
0566+  0E80             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0567+  0E80             scan_u8x:
0568+  0E80 F8 04 00    	enter 4
0569+  0E83 D8          	push b
0570+  0E84 DA          	push d
0571+  0E85             
0572+  0E85 FA FD FF    	lea d, [bp + -3]
0573+  0E88 07 66 0C    	call gets				; get number
0574+  0E8B             
0575+  0E8B 32          	mov bl, [d]
0576+  0E8C 37          	mov bh, bl
0577+  0E8D 33 01 00    	mov bl, [d + 1]
0578+  0E90 07 14 0C    	call atoi				; convert to int in AL
0579+  0E93             
0580+  0E93 E7          	pop d
0581+  0E94 E5          	pop b
0582+  0E95 F9          	leave
0583+  0E96 09          	ret
0584+  0E97             
0585+  0E97             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0586+  0E97             ; input decimal number
0587+  0E97             ; result in A
0588+  0E97             ; 655'\0'
0589+  0E97             ; low--------high
0590+  0E97             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0591+  0E97             scan_u16d:
0592+  0E97 F8 08 00    	enter 8
0593+  0E9A E2          	push si
0594+  0E9B D8          	push b
0595+  0E9C D9          	push c
0596+  0E9D DA          	push d
0597+  0E9E FA F9 FF    	lea d, [bp +- 7]
0598+  0EA1 07 66 0C    	call gets
0599+  0EA4 07 9C 0B    	call strlen			; get string length in C
0600+  0EA7 7E          	dec c
0601+  0EA8 FD 4E       	mov si, d
0602+  0EAA 12          	mov a, c
0603+  0EAB FD 99       	shl a
0604+  0EAD 3B FC 0B    	mov d, table_power
0605+  0EB0 59          	add d, a
0606+  0EB1 38 00 00    	mov c, 0
0607+  0EB4             mul_loop:
0608+  0EB4 F6          	lodsb			; load ASCII to al
0609+  0EB5 B9 00       	cmp al, 0
0610+  0EB7 C6 CA 0E    	je mul_exit
0611+  0EBA 6F 30       	sub al, $30		; make into integer
0612+  0EBC 22 00       	mov ah, 0
0613+  0EBE 2A          	mov b, [d]
0614+  0EBF AC          	mul a, b			; result in B since it fits in 16bits
0615+  0EC0 11          	mov a, b
0616+  0EC1 28          	mov b, c
0617+  0EC2 54          	add a, b
0618+  0EC3 39          	mov c, a
0619+  0EC4 63 02 00    	sub d, 2
0620+  0EC7 0A B4 0E    	jmp mul_loop
0621+  0ECA             mul_exit:
0622+  0ECA 12          	mov a, c
0623+  0ECB E7          	pop d
0624+  0ECC E6          	pop c
0625+  0ECD E5          	pop b
0626+  0ECE EF          	pop si
0627+  0ECF F9          	leave
0628+  0ED0 09          	ret
0488   0ED1             .include "ctype.asm"
0001+  0ED1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0ED1             ; ctype.s
0003+  0ED1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0ED1             
0005+  0ED1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  0ED1             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  0ED1             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  0ED1             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  0ED1             ;; characters are supported.
0010+  0ED1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  0ED1             ;; isalnum 
0012+  0ED1             ;; isalpha 
0013+  0ED1             ;; islower 
0014+  0ED1             ;; isupper 
0015+  0ED1             ;; isdigit 
0016+  0ED1             ;; isxdigit
0017+  0ED1             ;; iscntrl 
0018+  0ED1             ;; isgraph 
0019+  0ED1             ;; isspace 
0020+  0ED1             ;; isblank 
0021+  0ED1             ;; isprint 
0022+  0ED1             ;; ispunct 
0023+  0ED1             ;; tolower 
0024+  0ED1             ;; toupper
0025+  0ED1             
0026+  0ED1             
0027+  0ED1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  0ED1             ;; IS ALPHANUMERIC
0029+  0ED1             ;; sets ZF according with result
0030+  0ED1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  0ED1             isalnum:
0032+  0ED1 07 EE 0E    	call isalpha
0033+  0ED4 C6 DA 0E    	je isalnum_exit
0034+  0ED7 07 DB 0E    	call isdigit
0035+  0EDA             isalnum_exit:
0036+  0EDA 09          	ret	
0037+  0EDB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0EDB             ;; IS DIGIT
0039+  0EDB             ;; sets ZF according with result
0040+  0EDB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  0EDB             isdigit:
0042+  0EDB DB          	push al
0043+  0EDC B9 30       	cmp al, '0'
0044+  0EDE C8 EA 0E    	jlu isdigit_false
0045+  0EE1 B9 39       	cmp al, '9'
0046+  0EE3 D1 EA 0E    	jgu isdigit_false
0047+  0EE6 87 00       	and al, 0	; set ZF
0048+  0EE8 E8          	pop al
0049+  0EE9 09          	ret
0050+  0EEA             isdigit_false:
0051+  0EEA 8B 01       	or al, 1	; clear ZF
0052+  0EEC E8          	pop al
0053+  0EED 09          	ret	
0054+  0EEE             	
0055+  0EEE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  0EEE             ;; IS ALPHA
0057+  0EEE             ;; sets ZF according with result
0058+  0EEE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  0EEE             isalpha:
0060+  0EEE DB          	push al
0061+  0EEF B9 5F       	cmp al, '_'
0062+  0EF1 C6 11 0F    	je isalpha_true
0063+  0EF4 B9 2E       	cmp al, '.'
0064+  0EF6 C6 11 0F    	je isalpha_true
0065+  0EF9 B9 41       	cmp al, 'A'
0066+  0EFB C8 0D 0F    	jlu isalpha_false
0067+  0EFE B9 7A       	cmp al, 'z'
0068+  0F00 D1 0D 0F    	jgu isalpha_false
0069+  0F03 B9 5A       	cmp al, 'Z'
0070+  0F05 D0 11 0F    	jleu isalpha_true
0071+  0F08 B9 61       	cmp al, 'a'
0072+  0F0A C9 11 0F    	jgeu isalpha_true
0073+  0F0D             isalpha_false:
0074+  0F0D 8B 01       	or al, 1	; clear ZF
0075+  0F0F E8          	pop al
0076+  0F10 09          	ret
0077+  0F11             isalpha_true:
0078+  0F11 87 00       	and al, 0	; set ZF
0079+  0F13 E8          	pop al
0080+  0F14 09          	ret
0081+  0F15             
0082+  0F15             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  0F15             ;; IS PATH-ALPHA
0084+  0F15             ;; sets ZF according with result
0085+  0F15             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  0F15             ispath:
0087+  0F15 DB          	push al
0088+  0F16 07 DB 0E    	call isdigit
0089+  0F19 C6 43 0F    	je ispath_true
0090+  0F1C B9 5F       	cmp al, '_'
0091+  0F1E C6 43 0F    	je ispath_true
0092+  0F21 B9 2F       	cmp al, '/'
0093+  0F23 C6 43 0F    	je ispath_true
0094+  0F26 B9 2E       	cmp al, '.'
0095+  0F28 C6 43 0F    	je ispath_true
0096+  0F2B B9 41       	cmp al, 'A'
0097+  0F2D C8 3F 0F    	jlu ispath_false
0098+  0F30 B9 7A       	cmp al, 'z'
0099+  0F32 D1 3F 0F    	jgu ispath_false
0100+  0F35 B9 5A       	cmp al, 'Z'
0101+  0F37 D0 43 0F    	jleu ispath_true
0102+  0F3A B9 61       	cmp al, 'a'
0103+  0F3C C9 43 0F    	jgeu ispath_true
0104+  0F3F             ispath_false:
0105+  0F3F 8B 01       	or al, 1	; clear ZF
0106+  0F41 E8          	pop al
0107+  0F42 09          	ret
0108+  0F43             ispath_true:
0109+  0F43 87 00       	and al, 0	; set ZF
0110+  0F45 E8          	pop al
0111+  0F46 09          	ret
0112+  0F47             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  0F47             ;; IS SPACE
0114+  0F47             ;; sets ZF according with result
0115+  0F47             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  0F47             isspace:
0117+  0F47 B9 20       	cmp al, $20		; ' '
0118+  0F49 C6 5D 0F    	je isspace_exit
0119+  0F4C B9 09       	cmp al, $09		; '\t'
0120+  0F4E C6 5D 0F    	je isspace_exit
0121+  0F51 B9 0A       	cmp al, $0A		; '\n'
0122+  0F53 C6 5D 0F    	je isspace_exit
0123+  0F56 B9 0D       	cmp al, $0D		; '\r'
0124+  0F58 C6 5D 0F    	je isspace_exit
0125+  0F5B B9 0B       	cmp al, $0B		; '\v'
0126+  0F5D             isspace_exit:
0127+  0F5D 09          	ret	
0128+  0F5E             
0129+  0F5E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0F5E             ; TO LOWER
0131+  0F5E             ; input in AL
0132+  0F5E             ; output in AL
0133+  0F5E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  0F5E             to_lower:
0135+  0F5E B9 5A       	cmp al, 'Z'
0136+  0F60 D1 65 0F    	jgu to_lower_ret
0137+  0F63 6A 20       	add al, $20				; convert to lower case
0138+  0F65             to_lower_ret:
0139+  0F65 09          	ret
0140+  0F66             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  0F66             ; TO UPPER
0142+  0F66             ; input in AL
0143+  0F66             ; output in AL
0144+  0F66             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  0F66             to_upper:
0146+  0F66 B9 61       	cmp al, 'a'
0147+  0F68 C8 6D 0F    	jlu to_upper_ret
0148+  0F6B 6F 20       	sub al, $20			; convert to upper case
0149+  0F6D             to_upper_ret:
0150+  0F6D 09          	ret
0151+  0F6E             
0489   0F6E             .include "token.asm"
0001+  0F6E             TOKTYP_IDENTIFIER	.equ 0
0002+  0F6E             TOKTYP_KEYWORD		.equ 1
0003+  0F6E             TOKTYP_DELIMITER	.equ 2
0004+  0F6E             TOKTYP_STRING		.equ 3
0005+  0F6E             TOKTYP_CHAR			.equ 4
0006+  0F6E             TOKTYP_NUMERIC		.equ 5
0007+  0F6E             TOKTYP_END			.equ 6
0008+  0F6E             
0009+  0F6E             TOK_NULL			.equ 0
0010+  0F6E             TOK_FSLASH			.equ 1
0011+  0F6E             TOK_TIMES 			.equ 2
0012+  0F6E             TOK_PLUS 			.equ 3
0013+  0F6E             TOK_MINUS 			.equ 4
0014+  0F6E             TOK_DOT				.equ 5
0015+  0F6E             TOK_SEMI			.equ 6
0016+  0F6E             TOK_ANGLE			.equ 7
0017+  0F6E             TOK_TILDE			.equ 8
0018+  0F6E             TOK_EQUAL			.equ 9
0019+  0F6E             TOK_COLON			.equ 10
0020+  0F6E             TOK_COMMA			.equ 11
0021+  0F6E             
0022+  0F6E             TOK_END				.equ 20
0023+  0F6E             
0024+  0F6E             
0025+  0F6E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  0F6E             ;; read a full command argment from shell input buffer
0027+  0F6E             ;; argument is written into tokstr
0028+  0F6E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  0F6E             get_arg:
0030+  0F6E D7          	push a
0031+  0F6F E2          	push si
0032+  0F70 E3          	push di
0033+  0F71 19 00       	mov al, 0
0034+  0F73 3D 9C 11    	mov [tokstr], al			; nullify tokstr string
0035+  0F76 14 98 11    	mov a, [prog]
0036+  0F79 4D          	mov si, a
0037+  0F7A FD 4F 9C 11 	mov di, tokstr
0038+  0F7E             get_arg_skip_spaces:
0039+  0F7E F6          	lodsb
0040+  0F7F 07 47 0F    	call isspace
0041+  0F82 C6 7E 0F    	je get_arg_skip_spaces
0042+  0F85             get_arg_L0:
0043+  0F85 B9 3B       	cmp al, $3B				; check if is ';'
0044+  0F87 C6 94 0F    	je get_arg_end
0045+  0F8A B9 00       	cmp al, 0
0046+  0F8C C6 94 0F    	je get_arg_end			; check if end of input
0047+  0F8F F7          	stosb
0048+  0F90 F6          	lodsb
0049+  0F91 0A 85 0F    	jmp get_arg_L0
0050+  0F94             get_arg_end:
0051+  0F94 19 00       	mov al, 0
0052+  0F96 F7          	stosb
0053+  0F97 D5 01 00    	sub si, 1
0054+  0F9A 4E          	mov a, si
0055+  0F9B 42 98 11    	mov [prog], a		; update pointer
0056+  0F9E F0          	pop di
0057+  0F9F EF          	pop si
0058+  0FA0 E4          	pop a
0059+  0FA1 09          	ret
0060+  0FA2             
0061+  0FA2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  0FA2             ;; read a path formation from shell input buffer
0063+  0FA2             ;; path is written into tokstr
0064+  0FA2             ;; /usr/bin
0065+  0FA2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  0FA2             get_path:
0067+  0FA2 D7          	push a
0068+  0FA3 E2          	push si
0069+  0FA4 E3          	push di
0070+  0FA5 19 00       	mov al, 0
0071+  0FA7 3D 9C 11    	mov [tokstr], al			; nullify tokstr string
0072+  0FAA 14 98 11    	mov a, [prog]
0073+  0FAD 4D          	mov si, a
0074+  0FAE FD 4F 9C 11 	mov di, tokstr
0075+  0FB2             get_path_skip_spaces:
0076+  0FB2 F6          	lodsb
0077+  0FB3 07 47 0F    	call isspace
0078+  0FB6 C6 B2 0F    	je get_path_skip_spaces
0079+  0FB9             get_path_is_pathchar:
0080+  0FB9 F7          	stosb
0081+  0FBA F6          	lodsb
0082+  0FBB 07 D1 0E    	call isalnum			;check if is alphanumeric
0083+  0FBE C6 B9 0F    	je get_path_is_pathchar
0084+  0FC1 B9 2F       	cmp al, '/'				; check if is '/'
0085+  0FC3 C6 B9 0F    	je get_path_is_pathchar
0086+  0FC6 19 00       	mov al, 0
0087+  0FC8 F7          	stosb
0088+  0FC9 D5 01 00    	sub si, 1
0089+  0FCC 4E          	mov a, si
0090+  0FCD 42 98 11    	mov [prog], a		; update pointer
0091+  0FD0             get_path_end:
0092+  0FD0 F0          	pop di
0093+  0FD1 EF          	pop si
0094+  0FD2 E4          	pop a
0095+  0FD3 09          	ret
0096+  0FD4             
0097+  0FD4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  0FD4             ;; read a line
0099+  0FD4             ;; line is written into tokstr
0100+  0FD4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  0FD4             get_line:
0102+  0FD4 D7          	push a
0103+  0FD5 E2          	push si
0104+  0FD6 E3          	push di
0105+  0FD7 19 00       	mov al, 0
0106+  0FD9 3D 9C 11    	mov [tokstr], al			; nullify tokstr string
0107+  0FDC 14 98 11    	mov a, [prog]
0108+  0FDF 4D          	mov si, a
0109+  0FE0 FD 4F 9C 11 	mov di, tokstr
0110+  0FE4             get_line_L0:
0111+  0FE4 F6          	lodsb
0112+  0FE5 B9 0A       	cmp al, $0A		; check for new line
0113+  0FE7 C6 EE 0F    	je get_line_exit
0114+  0FEA F7          	stosb
0115+  0FEB 0A E4 0F    	jmp get_line_L0
0116+  0FEE             get_line_exit:
0117+  0FEE 19 00       	mov al, 0
0118+  0FF0 F7          	stosb
0119+  0FF1 4E          	mov a, si
0120+  0FF2 42 98 11    	mov [prog], a		; update pointer
0121+  0FF5 F0          	pop di
0122+  0FF6 EF          	pop si
0123+  0FF7 E4          	pop a
0124+  0FF8 09          	ret
0125+  0FF9             
0126+  0FF9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  0FF9             ;; token parser
0128+  0FF9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  0FF9             get_token:
0130+  0FF9 D7          	push a
0131+  0FFA DA          	push d
0132+  0FFB E2          	push si
0133+  0FFC E3          	push di
0134+  0FFD 19 00       	mov al, 0
0135+  0FFF 3D 9C 11    	mov [tokstr], al			; nullify tokstr string
0136+  1002 19 00       	mov al, TOK_NULL
0137+  1004 3D 9B 11    	mov [tok], al				; nullify token
0138+  1007 14 98 11    	mov a, [prog]
0139+  100A 4D          	mov si, a
0140+  100B FD 4F 9C 11 	mov di, tokstr
0141+  100F             get_tok_skip_spaces:
0142+  100F F6          	lodsb
0143+  1010 07 47 0F    	call isspace
0144+  1013 C6 0F 10    	je get_tok_skip_spaces
0145+  1016 B9 00       	cmp al, 0			; check for end of input (NULL)
0146+  1018 C6 FD 10    	je get_token_end
0147+  101B B9 23       	cmp al, '#'			; comments!
0148+  101D C6 2B 11    	je get_tok_comment
0149+  1020 07 D1 0E    	call isalnum
0150+  1023 C6 0A 11    	jz is_alphanumeric
0151+  1026             ; other token types
0152+  1026             get_token_slash:
0153+  1026 B9 2F       	cmp al, '/'				; check if '/'
0154+  1028 C7 40 10    	jne get_token_minus
0155+  102B F7          	stosb					; store '/' into token string
0156+  102C 19 00       	mov al, 0
0157+  102E F7          	stosb					; terminate token string
0158+  102F 19 01       	mov al, TOK_FSLASH
0159+  1031 3D 9B 11    	mov [tok], al			
0160+  1034 19 02       	mov al, TOKTYP_DELIMITER
0161+  1036 3D 9A 11    	mov [toktyp], al
0162+  1039 4E          	mov a, si
0163+  103A 42 98 11    	mov [prog], a		; update pointer
0164+  103D 0A 26 11    	jmp get_token_return
0165+  1040             get_token_minus:
0166+  1040 B9 2D       	cmp al, '-'				; check if '-'
0167+  1042 C7 5A 10    	jne get_token_comma
0168+  1045 F7          	stosb					; store '-' into token string
0169+  1046 19 00       	mov al, 0
0170+  1048 F7          	stosb					; terminate token string
0171+  1049 19 04       	mov al, TOK_MINUS
0172+  104B 3D 9B 11    	mov [tok], al			
0173+  104E 19 02       	mov al, TOKTYP_DELIMITER
0174+  1050 3D 9A 11    	mov [toktyp], al
0175+  1053 4E          	mov a, si
0176+  1054 42 98 11    	mov [prog], a		; update pointer
0177+  1057 0A 26 11    	jmp get_token_return
0178+  105A             get_token_comma:
0179+  105A B9 2C       	cmp al, ','				; check if ','
0180+  105C C7 74 10    	jne get_token_semi
0181+  105F F7          	stosb					; store ',' into token string
0182+  1060 19 00       	mov al, 0
0183+  1062 F7          	stosb					; terminate token string
0184+  1063 19 0B       	mov al, TOK_COMMA
0185+  1065 3D 9B 11    	mov [tok], al			
0186+  1068 19 02       	mov al, TOKTYP_DELIMITER
0187+  106A 3D 9A 11    	mov [toktyp], al
0188+  106D 4E          	mov a, si
0189+  106E 42 98 11    	mov [prog], a		; update pointer
0190+  1071 0A 26 11    	jmp get_token_return
0191+  1074             get_token_semi:
0192+  1074 B9 3B       	cmp al, $3B				; check if ';'
0193+  1076 C7 8E 10    	jne get_token_colon
0194+  1079 F7          	stosb					; store ';' into token string
0195+  107A 19 00       	mov al, 0
0196+  107C F7          	stosb					; terminate token string
0197+  107D 19 06       	mov al, TOK_SEMI
0198+  107F 3D 9B 11    	mov [tok], al			
0199+  1082 19 02       	mov al, TOKTYP_DELIMITER
0200+  1084 3D 9A 11    	mov [toktyp], al
0201+  1087 4E          	mov a, si
0202+  1088 42 98 11    	mov [prog], a		; update pointer
0203+  108B 0A 26 11    	jmp get_token_return
0204+  108E             get_token_colon:
0205+  108E B9 3A       	cmp al, $3A				; check if ':'
0206+  1090 C7 A8 10    	jne get_token_angle
0207+  1093 F7          	stosb					; store ':' into token string
0208+  1094 19 00       	mov al, 0
0209+  1096 F7          	stosb					; terminate token string
0210+  1097 19 0A       	mov al, TOK_COLON
0211+  1099 3D 9B 11    	mov [tok], al			
0212+  109C 19 02       	mov al, TOKTYP_DELIMITER
0213+  109E 3D 9A 11    	mov [toktyp], al
0214+  10A1 4E          	mov a, si
0215+  10A2 42 98 11    	mov [prog], a		; update pointer
0216+  10A5 0A 26 11    	jmp get_token_return
0217+  10A8             get_token_angle:
0218+  10A8 B9 3E       	cmp al, $3E				; check if '>'
0219+  10AA C7 C2 10    	jne get_token_tilde
0220+  10AD F7          	stosb					; store '>' into token string
0221+  10AE 19 00       	mov al, 0
0222+  10B0 F7          	stosb					; terminate token string
0223+  10B1 19 07       	mov al, TOK_ANGLE
0224+  10B3 3D 9B 11    	mov [tok], al			
0225+  10B6 19 02       	mov al, TOKTYP_DELIMITER
0226+  10B8 3D 9A 11    	mov [toktyp], al
0227+  10BB 4E          	mov a, si
0228+  10BC 42 98 11    	mov [prog], a		; update pointer
0229+  10BF 0A 26 11    	jmp get_token_return
0230+  10C2             get_token_tilde:
0231+  10C2 B9 7E       	cmp al, '~'				; check if '~'
0232+  10C4 C7 DC 10    	jne get_token_equal
0233+  10C7 F7          	stosb					; store '~' into token string
0234+  10C8 19 00       	mov al, 0
0235+  10CA F7          	stosb					; terminate token string
0236+  10CB 19 08       	mov al, TOK_TILDE
0237+  10CD 3D 9B 11    	mov [tok], al			
0238+  10D0 19 02       	mov al, TOKTYP_DELIMITER
0239+  10D2 3D 9A 11    	mov [toktyp], al
0240+  10D5 4E          	mov a, si
0241+  10D6 42 98 11    	mov [prog], a		; update pointer
0242+  10D9 0A 26 11    	jmp get_token_return
0243+  10DC             get_token_equal:
0244+  10DC B9 3D       	cmp al, '='				; check if '='
0245+  10DE C7 F6 10    	jne get_token_skip
0246+  10E1 F7          	stosb					; store '=' into token string
0247+  10E2 19 00       	mov al, 0
0248+  10E4 F7          	stosb					; terminate token string
0249+  10E5 19 09       	mov al, TOK_EQUAL
0250+  10E7 3D 9B 11    	mov [tok], al			
0251+  10EA 19 02       	mov al, TOKTYP_DELIMITER
0252+  10EC 3D 9A 11    	mov [toktyp], al
0253+  10EF 4E          	mov a, si
0254+  10F0 42 98 11    	mov [prog], a		; update pointer
0255+  10F3 0A 26 11    	jmp get_token_return
0256+  10F6             get_token_skip:
0257+  10F6 4E          	mov a, si
0258+  10F7 42 98 11    	mov [prog], a		; update pointer
0259+  10FA 0A 26 11    	jmp get_token_return
0260+  10FD             get_token_end:				; end of file token
0261+  10FD 19 14       	mov al, TOK_END
0262+  10FF 3D 9B 11    	mov [tok], al
0263+  1102 19 06       	mov al, TOKTYP_END
0264+  1104 3D 9A 11    	mov [toktyp], al
0265+  1107 0A 26 11    	jmp get_token_return
0266+  110A             is_alphanumeric:
0267+  110A F7          	stosb
0268+  110B F6          	lodsb
0269+  110C 07 D1 0E    	call isalnum			;check if is alphanumeric
0270+  110F C6 0A 11    	jz is_alphanumeric
0271+  1112 B9 2E       	cmp al, $2E				; check if is '.'
0272+  1114 C6 0A 11    	je is_alphanumeric
0273+  1117 19 00       	mov al, 0
0274+  1119 F7          	stosb
0275+  111A 19 00       	mov al, TOKTYP_IDENTIFIER
0276+  111C 3D 9A 11    	mov [toktyp], al
0277+  111F D5 01 00    	sub si, 1
0278+  1122 4E          	mov a, si
0279+  1123 42 98 11    	mov [prog], a		; update pointer
0280+  1126             get_token_return:
0281+  1126 F0          	pop di
0282+  1127 EF          	pop si
0283+  1128 E7          	pop d
0284+  1129 E4          	pop a
0285+  112A 09          	ret
0286+  112B             get_tok_comment:
0287+  112B F6          	lodsb
0288+  112C B9 0A       	cmp al, $0A			; new line
0289+  112E C7 2B 11    	jne get_tok_comment
0290+  1131 0A 0F 10    	jmp get_tok_skip_spaces
0291+  1134             
0292+  1134             
0293+  1134             get_number:
0294+  1134 D7          	push a
0295+  1135 DA          	push d
0296+  1136 E2          	push si
0297+  1137 E3          	push di
0298+  1138 19 00       	mov al, 0
0299+  113A 3D 9C 11    	mov [tokstr], al			; nullify tokstr string
0300+  113D 19 00       	mov al, TOK_NULL
0301+  113F 3D 9B 11    	mov [tok], al				; nullify token
0302+  1142 14 98 11    	mov a, [prog]
0303+  1145 4D          	mov si, a
0304+  1146 FD 4F 9C 11 	mov di, tokstr
0305+  114A             get_number_skip_spaces:
0306+  114A F6          	lodsb
0307+  114B 07 47 0F    	call isspace
0308+  114E C6 4A 11    	je get_number_skip_spaces
0309+  1151 B9 00       	cmp al, 0			; check for end of input (NULL)
0310+  1153 C7 63 11    	jne get_number_L0
0311+  1156 19 14       	mov al, TOK_END
0312+  1158 3D 9B 11    	mov [tok], al
0313+  115B 19 06       	mov al, TOKTYP_END
0314+  115D 3D 9A 11    	mov [toktyp], al
0315+  1160 0A 7A 11    	jmp get_number_return
0316+  1163             get_number_L0:
0317+  1163 F7          	stosb
0318+  1164 F6          	lodsb
0319+  1165 07 DB 0E    	call isdigit			;check if is numeric
0320+  1168 C6 63 11    	jz get_number_L0
0321+  116B 19 00       	mov al, 0
0322+  116D F7          	stosb
0323+  116E 19 05       	mov al, TOKTYP_NUMERIC
0324+  1170 3D 9A 11    	mov [toktyp], al
0325+  1173 D5 01 00    	sub si, 1
0326+  1176 4E          	mov a, si
0327+  1177 42 98 11    	mov [prog], a		; update pointer
0328+  117A             get_number_return:
0329+  117A F0          	pop di
0330+  117B EF          	pop si
0331+  117C E7          	pop d
0332+  117D E4          	pop a
0333+  117E 09          	ret
0334+  117F             
0335+  117F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  117F             ;; PUT BACK TOKEN
0337+  117F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
0338+  117F             putback:
0339+  117F D7          	push a
0340+  1180 E2          	push si
0341+  1181 FD 4D 9C 11 	mov si, tokstr	
0342+  1185             putback_loop:
0343+  1185 F6          	lodsb
0344+  1186 B9 00       	cmp al, 0
0345+  1188 C6 95 11    	je putback_end
0346+  118B 14 98 11    	mov a, [prog]
0347+  118E 7D          	dec a
0348+  118F 42 98 11    	mov [prog], a			; update pointer
0349+  1192 0A 85 11    	jmp putback_loop
0350+  1195             putback_end:
0351+  1195 EF          	pop si
0352+  1196 E4          	pop a
0353+  1197 09          	ret
0354+  1198             
0355+  1198             
0356+  1198             
0357+  1198             
0358+  1198 00 00       prog:		.dw 0			; pointer to current position in buffer
0359+  119A             
0360+  119A 00          toktyp: 	.db 0			; token type symbol
0361+  119B 00          tok:		.db 0			; current token symbol
0362+  119C 00 00 00 00 tokstr:		.fill 256, 0	; token as a string
0362+  11A0 00 00 00 00 
0362+  11A4 00 00 00 00 
0362+  11A8 00 00 00 00 
0362+  11AC 00 00 00 00 
0362+  11B0 00 00 00 00 
0362+  11B4 00 00 00 00 
0362+  11B8 00 00 00 00 
0362+  11BC 00 00 00 00 
0362+  11C0 00 00 00 00 
0362+  11C4 00 00 00 00 
0362+  11C8 00 00 00 00 
0362+  11CC 00 00 00 00 
0362+  11D0 00 00 00 00 
0362+  11D4 00 00 00 00 
0362+  11D8 00 00 00 00 
0362+  11DC 00 00 00 00 
0362+  11E0 00 00 00 00 
0362+  11E4 00 00 00 00 
0362+  11E8 00 00 00 00 
0362+  11EC 00 00 00 00 
0362+  11F0 00 00 00 00 
0362+  11F4 00 00 00 00 
0362+  11F8 00 00 00 00 
0362+  11FC 00 00 00 00 
0362+  1200 00 00 00 00 
0362+  1204 00 00 00 00 
0362+  1208 00 00 00 00 
0362+  120C 00 00 00 00 
0362+  1210 00 00 00 00 
0362+  1214 00 00 00 00 
0362+  1218 00 00 00 00 
0362+  121C 00 00 00 00 
0362+  1220 00 00 00 00 
0362+  1224 00 00 00 00 
0362+  1228 00 00 00 00 
0362+  122C 00 00 00 00 
0362+  1230 00 00 00 00 
0362+  1234 00 00 00 00 
0362+  1238 00 00 00 00 
0362+  123C 00 00 00 00 
0362+  1240 00 00 00 00 
0362+  1244 00 00 00 00 
0362+  1248 00 00 00 00 
0362+  124C 00 00 00 00 
0362+  1250 00 00 00 00 
0362+  1254 00 00 00 00 
0362+  1258 00 00 00 00 
0362+  125C 00 00 00 00 
0362+  1260 00 00 00 00 
0362+  1264 00 00 00 00 
0362+  1268 00 00 00 00 
0362+  126C 00 00 00 00 
0362+  1270 00 00 00 00 
0362+  1274 00 00 00 00 
0362+  1278 00 00 00 00 
0362+  127C 00 00 00 00 
0362+  1280 00 00 00 00 
0362+  1284 00 00 00 00 
0362+  1288 00 00 00 00 
0362+  128C 00 00 00 00 
0362+  1290 00 00 00 00 
0362+  1294 00 00 00 00 
0362+  1298 00 00 00 00 
0490   129C             
0491   129C 00 00 00 00 temp_data1:				.fill 256, 0
0491   12A0 00 00 00 00 
0491   12A4 00 00 00 00 
0491   12A8 00 00 00 00 
0491   12AC 00 00 00 00 
0491   12B0 00 00 00 00 
0491   12B4 00 00 00 00 
0491   12B8 00 00 00 00 
0491   12BC 00 00 00 00 
0491   12C0 00 00 00 00 
0491   12C4 00 00 00 00 
0491   12C8 00 00 00 00 
0491   12CC 00 00 00 00 
0491   12D0 00 00 00 00 
0491   12D4 00 00 00 00 
0491   12D8 00 00 00 00 
0491   12DC 00 00 00 00 
0491   12E0 00 00 00 00 
0491   12E4 00 00 00 00 
0491   12E8 00 00 00 00 
0491   12EC 00 00 00 00 
0491   12F0 00 00 00 00 
0491   12F4 00 00 00 00 
0491   12F8 00 00 00 00 
0491   12FC 00 00 00 00 
0491   1300 00 00 00 00 
0491   1304 00 00 00 00 
0491   1308 00 00 00 00 
0491   130C 00 00 00 00 
0491   1310 00 00 00 00 
0491   1314 00 00 00 00 
0491   1318 00 00 00 00 
0491   131C 00 00 00 00 
0491   1320 00 00 00 00 
0491   1324 00 00 00 00 
0491   1328 00 00 00 00 
0491   132C 00 00 00 00 
0491   1330 00 00 00 00 
0491   1334 00 00 00 00 
0491   1338 00 00 00 00 
0491   133C 00 00 00 00 
0491   1340 00 00 00 00 
0491   1344 00 00 00 00 
0491   1348 00 00 00 00 
0491   134C 00 00 00 00 
0491   1350 00 00 00 00 
0491   1354 00 00 00 00 
0491   1358 00 00 00 00 
0491   135C 00 00 00 00 
0491   1360 00 00 00 00 
0491   1364 00 00 00 00 
0491   1368 00 00 00 00 
0491   136C 00 00 00 00 
0491   1370 00 00 00 00 
0491   1374 00 00 00 00 
0491   1378 00 00 00 00 
0491   137C 00 00 00 00 
0491   1380 00 00 00 00 
0491   1384 00 00 00 00 
0491   1388 00 00 00 00 
0491   138C 00 00 00 00 
0491   1390 00 00 00 00 
0491   1394 00 00 00 00 
0491   1398 00 00 00 00 
0492   139C 00 00 00 00 temp_data:				.fill 512, 0
0492   13A0 00 00 00 00 
0492   13A4 00 00 00 00 
0492   13A8 00 00 00 00 
0492   13AC 00 00 00 00 
0492   13B0 00 00 00 00 
0492   13B4 00 00 00 00 
0492   13B8 00 00 00 00 
0492   13BC 00 00 00 00 
0492   13C0 00 00 00 00 
0492   13C4 00 00 00 00 
0492   13C8 00 00 00 00 
0492   13CC 00 00 00 00 
0492   13D0 00 00 00 00 
0492   13D4 00 00 00 00 
0492   13D8 00 00 00 00 
0492   13DC 00 00 00 00 
0492   13E0 00 00 00 00 
0492   13E4 00 00 00 00 
0492   13E8 00 00 00 00 
0492   13EC 00 00 00 00 
0492   13F0 00 00 00 00 
0492   13F4 00 00 00 00 
0492   13F8 00 00 00 00 
0492   13FC 00 00 00 00 
0492   1400 00 00 00 00 
0492   1404 00 00 00 00 
0492   1408 00 00 00 00 
0492   140C 00 00 00 00 
0492   1410 00 00 00 00 
0492   1414 00 00 00 00 
0492   1418 00 00 00 00 
0492   141C 00 00 00 00 
0492   1420 00 00 00 00 
0492   1424 00 00 00 00 
0492   1428 00 00 00 00 
0492   142C 00 00 00 00 
0492   1430 00 00 00 00 
0492   1434 00 00 00 00 
0492   1438 00 00 00 00 
0492   143C 00 00 00 00 
0492   1440 00 00 00 00 
0492   1444 00 00 00 00 
0492   1448 00 00 00 00 
0492   144C 00 00 00 00 
0492   1450 00 00 00 00 
0492   1454 00 00 00 00 
0492   1458 00 00 00 00 
0492   145C 00 00 00 00 
0492   1460 00 00 00 00 
0492   1464 00 00 00 00 
0492   1468 00 00 00 00 
0492   146C 00 00 00 00 
0492   1470 00 00 00 00 
0492   1474 00 00 00 00 
0492   1478 00 00 00 00 
0492   147C 00 00 00 00 
0492   1480 00 00 00 00 
0492   1484 00 00 00 00 
0492   1488 00 00 00 00 
0492   148C 00 00 00 00 
0492   1490 00 00 00 00 
0492   1494 00 00 00 00 
0492   1498 00 00 00 00 
0492   149C 00 00 00 00 
0492   14A0 00 00 00 00 
0492   14A4 00 00 00 00 
0492   14A8 00 00 00 00 
0492   14AC 00 00 00 00 
0492   14B0 00 00 00 00 
0492   14B4 00 00 00 00 
0492   14B8 00 00 00 00 
0492   14BC 00 00 00 00 
0492   14C0 00 00 00 00 
0492   14C4 00 00 00 00 
0492   14C8 00 00 00 00 
0492   14CC 00 00 00 00 
0492   14D0 00 00 00 00 
0492   14D4 00 00 00 00 
0492   14D8 00 00 00 00 
0492   14DC 00 00 00 00 
0492   14E0 00 00 00 00 
0492   14E4 00 00 00 00 
0492   14E8 00 00 00 00 
0492   14EC 00 00 00 00 
0492   14F0 00 00 00 00 
0492   14F4 00 00 00 00 
0492   14F8 00 00 00 00 
0492   14FC 00 00 00 00 
0492   1500 00 00 00 00 
0492   1504 00 00 00 00 
0492   1508 00 00 00 00 
0492   150C 00 00 00 00 
0492   1510 00 00 00 00 
0492   1514 00 00 00 00 
0492   1518 00 00 00 00 
0492   151C 00 00 00 00 
0492   1520 00 00 00 00 
0492   1524 00 00 00 00 
0492   1528 00 00 00 00 
0492   152C 00 00 00 00 
0492   1530 00 00 00 00 
0492   1534 00 00 00 00 
0492   1538 00 00 00 00 
0492   153C 00 00 00 00 
0492   1540 00 00 00 00 
0492   1544 00 00 00 00 
0492   1548 00 00 00 00 
0492   154C 00 00 00 00 
0492   1550 00 00 00 00 
0492   1554 00 00 00 00 
0492   1558 00 00 00 00 
0492   155C 00 00 00 00 
0492   1560 00 00 00 00 
0492   1564 00 00 00 00 
0492   1568 00 00 00 00 
0492   156C 00 00 00 00 
0492   1570 00 00 00 00 
0492   1574 00 00 00 00 
0492   1578 00 00 00 00 
0492   157C 00 00 00 00 
0492   1580 00 00 00 00 
0492   1584 00 00 00 00 
0492   1588 00 00 00 00 
0492   158C 00 00 00 00 
0492   1590 00 00 00 00 
0492   1594 00 00 00 00 
0492   1598 00 00 00 00 
0493   159C             shell_transient_area:	; shell transient data area
0494   159C             
0495   159C             .end
tasm: Number of errors = 0
