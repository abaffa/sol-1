0001   0000             .include "kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0002   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0003   0000             ; SHELL
0004   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0005   0000             
0006   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007   0000             ; SYSTEM CONSTANTS / EQUATIONS
0008   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0009   0000             STACK_BEGIN:  .equ $F7FF  ; beginning of stack
0010   0000             
0011   0400             .org PROC_TEXT_ORG      ; origin at 1024
0012   0400             
0013   0400             shell_main:  
0014   0400 FD 49 FF F7   mov bp, STACK_BEGIN
0015   0404 FD 47 FF F7   mov sp, STACK_BEGIN
0016   0408             
0017   0408 3B B1 08      mov d, s_prompt_config
0018   040B 07 61 0D      call puts
0019   040E             
0020   040E             ; open config file
0021   040E             ; example: PATH=/usr/bin;
0022   040E             ; read PATH config entry
0023   040E 3B AB 08      mov d, s_prompt_PATH
0024   0411 07 61 0D      call puts
0025   0414 3B 6A 08      mov d, s_etc_config        ; '/etc/sh.conf'
0026   0417 FD 4D 80 08   mov si, s_PATH          ; config entry name is "PATH"
0027   041B FD 4F DD 07   mov di, PATH          ; config value destination is the var that holds the PATH variable
0028   041F 07 E9 04      call read_config  
0029   0422 3B DD 07      mov d, PATH
0030   0425 07 61 0D      call puts
0031   0428             ; open config file
0032   0428             ; home = /usr/home/guest;
0033   0428             ; read home directory config entry
0034   0428 3B 9A 08      mov d, s_prompt_homedir
0035   042B 07 61 0D      call puts
0036   042E 3B 6A 08      mov d, s_etc_config        ; '/etc/sh.conf'
0037   0431 FD 4D 77 08   mov si, s_home          ; config entry name is "home"
0038   0435 FD 4F DD 06   mov di, homedir          ; config value destination is the var that holds the home directory path
0039   0439 07 E9 04      call read_config  
0040   043C 3B DD 06      mov d, homedir
0041   043F 07 61 0D      call puts
0042   0442             ; open config file
0043   0442             ; read manpage directory path
0044   0442 3B 85 08      mov d, s_prompt_manpages
0045   0445 07 61 0D      call puts
0046   0448 3B 6A 08      mov d, s_etc_config        ; '/etc/sh.conf'
0047   044B FD 4D 7C 08   mov si, s_man          ; config entry name is "man"
0048   044F FD 4F 5D 07   mov di, manpath        ; config value destination is the var that holds the man pages directory path
0049   0453 07 E9 04      call read_config
0050   0456 3B 5D 07      mov d, manpath
0051   0459 07 61 0D      call puts
0052   045C             
0053   045C 10 5D 08      mov a, s_etc_profile
0054   045F 42 5C 11      mov [prog], a
0055   0462 07 32 05      call cmd_ssh
0056   0465             
0057   0465             shell_L0:
0058   0465 3B 06 09      mov d, s_sol1
0059   0468 07 61 0D      call puts
0060   046B 19 12         mov al, 18
0061   046D 05 04         syscall sys_fileio        ; print current path
0062   046F 3B 00 09      mov d, s_hash
0063   0472 07 61 0D      call puts
0064   0475 3B 11 09      mov d, shell_input_buff
0065   0478 13            mov a, d
0066   0479 42 5C 11      mov [prog], a      ; reset tokenizer buffer pointer
0067   047C 07 2E 0C      call gets            ; get command
0068   047F 07 85 04      call cmd_parser
0069   0482 0A 65 04      jmp shell_L0
0070   0485             
0071   0485             cmd_parser:
0072   0485 07 BD 0F      call get_token          ; get command into tokstr
0073   0488 FD 4F 98 06   mov di, commands
0074   048C FD 10         cla
0075   048E 42 13 0B      mov [parser_index], a    ; reset commands index
0076   0491             parser_L0:
0077   0491 FD 4D 60 11   mov si, tokstr
0078   0495 07 6C 0B      call strcmp
0079   0498 C6 C0 04      je parser_cmd_equal
0080   049B             parser_L0_L0:
0081   049B FC 00 00      lea d, [di + 0]
0082   049E BD 00         cmp byte[d], 0
0083   04A0 C6 A9 04      je parser_L0_L0_exit      ; run through the keyword until finding NULL
0084   04A3 D4 01 00      add di, 1
0085   04A6 0A 9B 04      jmp parser_L0_L0
0086   04A9             parser_L0_L0_exit:
0087   04A9 D4 01 00      add di, 1        ; then skip NULL byte at the end 
0088   04AC 14 13 0B      mov a, [parser_index]
0089   04AF 53 02 00      add a, 2
0090   04B2 42 13 0B      mov [parser_index], a      ; increase commands table index
0091   04B5 FC 00 00      lea d, [di + 0]
0092   04B8 BD 00         cmp byte[d], 0
0093   04BA C6 DF 04      je parser_cmd_not_found
0094   04BD 0A 91 04      jmp parser_L0
0095   04C0             parser_cmd_equal:
0096   04C0 10 00 0D      mov a, $0D00
0097   04C3 05 03         syscall sys_io        ; print carriage return
0098   04C5 14 13 0B      mov a, [parser_index]      ; get the keyword pointer
0099   04C8 FD 07 CB 06   call [a + keyword_ptrs]    ; execute command
0100   04CC 10 00 0D      mov a, $0D00
0101   04CF 05 03         syscall sys_io        ; print carriage return
0102   04D1             parser_retry:
0103   04D1 07 BD 0F      call get_token
0104   04D4 BC 5F 11 06   cmp byte[tok], TOK_SEMI
0105   04D8 C6 85 04      je cmd_parser
0106   04DB 07 43 11      call putback
0107   04DE 09            ret
0108   04DF             parser_cmd_not_found:
0109   04DF 07 43 11      call putback
0110   04E2 07 A9 05      call cmd_exec      ; execute as file/program
0111   04E5 0A D1 04      jmp parser_retry    ; check for more commands
0112   04E8 09            ret
0113   04E9             
0114   04E9             ; inputs:
0115   04E9             ; D = filename ptr
0116   04E9             ; SI = entry name ptr
0117   04E9             ; DI = output value string ptr
0118   04E9             read_config:
0119   04E9 E3            push di
0120   04EA E2            push si
0121   04EB FD 4F 60 15   mov di, shell_transient_area
0122   04EF 19 14         mov al, 20
0123   04F1 05 04         syscall sys_fileio        ; read entire config file
0124   04F3 10 60 15      mov a, shell_transient_area
0125   04F6 42 5C 11      mov [prog], a
0126   04F9 EF            pop si
0127   04FA             read_config_L0:
0128   04FA 07 BD 0F      call get_token
0129   04FD BC 5F 11 14   cmp byte[tok], TOK_END
0130   0501 C6 2D 05      je read_config_EOF
0131   0504 FD 4F 60 11   mov di, tokstr
0132   0508 07 6C 0B      call strcmp
0133   050B C6 1B 05      je read_config_found_entry
0134   050E             read_config_L0_L0:
0135   050E 07 BD 0F      call get_token
0136   0511 BC 5F 11 06   cmp byte[tok], TOK_SEMI
0137   0515 C6 FA 04      je read_config_L0
0138   0518 0A 0E 05      jmp read_config_L0_L0
0139   051B             read_config_found_entry:
0140   051B 07 BD 0F      call get_token      ; bypass '=' sign
0141   051E F0            pop di
0142   051F 14 5C 11      mov a, [prog]
0143   0522 4D            mov si, a
0144   0523             read_conf_L1:
0145   0523 F6            lodsb
0146   0524 B9 3B         cmp al, $3B        ; ';'
0147   0526 C6 2E 05      je read_config_EOF_2
0148   0529 F7            stosb
0149   052A 0A 23 05      jmp read_conf_L1
0150   052D             read_config_EOF:
0151   052D F0            pop di
0152   052E             read_config_EOF_2:
0153   052E 19 00         mov al, 0
0154   0530 F7            stosb          ; terminate value with NULL
0155   0531 09            ret
0156   0532             
0157   0532             ; ssh = sol shell
0158   0532             cmd_ssh:
0159   0532 07 66 0F      call get_path
0160   0535 3B 60 11      mov d, tokstr
0161   0538 FD 4F 60 15   mov di, shell_transient_area
0162   053C 19 14         mov al, 20
0163   053E 05 04         syscall sys_fileio        ; read textfile 
0164   0540               
0165   0540 3B 60 15      mov d, shell_transient_area
0166   0543 13            mov a, d
0167   0544 42 5C 11      mov [prog], a      ; reset tokenizer buffer pointer
0168   0547 07 85 04      call cmd_parser
0169   054A             
0170   054A 07 0E 0D      call printnl
0171   054D 09            ret
0172   054E               
0173   054E             ; ************************************************************
0174   054E             ; GET HEX FILE
0175   054E             ; di = destination address
0176   054E             ; return length in bytes in C
0177   054E             ; ************************************************************
0178   054E             ;load_hex:
0179   054E             ;  push bp
0180   054E             ;  mov bp, sp
0181   054E             ;  push a
0182   054E             ;  push b
0183   054E             ;  push d
0184   054E             ;  push si
0185   054E             ;  push di
0186   054E             ;  sub sp, $6000        ; string data block
0187   054E             ;  mov c, 0
0188   054E             ;  
0189   054E             ;  mov a, sp
0190   054E             ;  inc a
0191   054E             ;  mov d, a        ; start of string data block
0192   054E             ;  call gets        ; get program string
0193   054E             ;  mov si, a
0194   054E             ;load_hex_loop:
0195   054E             ;  lodsb          ; load from [SI] to AL
0196   054E             ;  cmp al, 0        ; check if ASCII 0
0197   054E             ;  jz load_hex_ret
0198   054E             ;  mov bh, al
0199   054E             ;  lodsb
0200   054E             ;  mov bl, al
0201   054E             ;  call atoi        ; convert ASCII byte in B to int (to AL)
0202   054E             ;  stosb          ; store AL to [DI]
0203   054E             ;  inc c
0204   054E             ;  jmp load_hex_loop
0205   054E             ;load_hex_ret:
0206   054E             ;  add sp, $6000
0207   054E             ;  pop di
0208   054E             ;  pop si
0209   054E             ;  pop d
0210   054E             ;  pop b
0211   054E             ;  pop a
0212   054E             ;  mov sp, bp
0213   054E             ;  pop bp
0214   054E             ;  ret
0215   054E             
0216   054E             cmd_setdate:
0217   054E 19 01         mov al, 1      ; set datetime
0218   0550 05 07         syscall sys_datetime  
0219   0552 09            ret  
0220   0553               
0221   0553             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0222   0553             ;; FILE SYSTEM DATA
0223   0553             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0224   0553             ; infor for : IDE SERVICES INTERRUPT
0225   0553             ; al = option
0226   0553             ; IDE read/write sector
0227   0553             ; 512 bytes
0228   0553             ; user buffer pointer in D
0229   0553             ; AH = number of sectors
0230   0553             ; CB = LBA bytes 3..0  
0231   0553             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0232   0553             ;; FILE SYSTEM DATA STRUCTURE
0233   0553             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0234   0553             ; for a directory we have the header first, followed by metadata
0235   0553             ; header 1 sector (512 bytes)
0236   0553             ; metadata 1 sector (512 bytes)
0237   0553             ; HEADER ENTRIES:
0238   0553             ; filename (64)
0239   0553             ; parent dir LBA (2) -  to be used for faster backwards navigation...
0240   0553             ;
0241   0553             ; metadata entries:
0242   0553             ; filename (24)
0243   0553             ; attributes (1)
0244   0553             ; LBA (2)
0245   0553             ; size (2)
0246   0553             ; day (1)
0247   0553             ; month (1)
0248   0553             ; year (1)
0249   0553             ; packet size = 32 bytes
0250   0553             ;
0251   0553             ; first directory on disk is the root directory '/'
0252   0553             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0253   0553             ;; FILE SYSTEM DISK FORMATTING
0254   0553             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0255   0553             ; writes FST_TOTAL_SECTORS + FS_NBR_FILES disk sectors  with 0's
0256   0553             ; this is the file system table formating
0257   0553             cmd_mkfs:
0258   0553 19 00         mov al, 0
0259   0555 05 04         syscall sys_fileio
0260   0557 09            ret
0261   0558             
0262   0558             
0263   0558             
0264   0558             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0265   0558             ;; parse path
0266   0558             ;; 
0267   0558             ;;
0268   0558             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0269   0558             
0270   0558             
0271   0558             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272   0558             ;; CD
0273   0558             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0274   0558             ; search for given directory inside current dir
0275   0558             ; if found, read its LBA, and switch directories
0276   0558             ; example:  cd /usr/bin; ls
0277   0558             ;       cd /usr/bin;
0278   0558             ;      cd /usr/bin
0279   0558             cmd_cd:
0280   0558 07 BD 0F      call get_token
0281   055B 1D 5F 11      mov al, [tok]
0282   055E B9 14         cmp al, TOK_END
0283   0560 C6 86 05      je cmd_cd_gotohome
0284   0563 B9 06         cmp al, TOK_SEMI
0285   0565 C6 86 05      je cmd_cd_gotohome
0286   0568 B9 08         cmp al, TOK_TILDE
0287   056A C6 86 05      je cmd_cd_gotohome
0288   056D 07 43 11      call putback
0289   0570 07 66 0F      call get_path    ; get the path for the cd command
0290   0573             cmd_cd_syscall:
0291   0573 3B 60 11      mov d, tokstr
0292   0576 19 13         mov al, 19
0293   0578 05 04         syscall sys_fileio  ; get dirID in A
0294   057A AF FF FF      cmp a, $FFFF
0295   057D C6 97 05      je cmd_cd_fail
0296   0580 27            mov b, a
0297   0581 19 03         mov al, 3
0298   0583 05 04         syscall sys_fileio  ; set dir to B
0299   0585 09            ret
0300   0586             cmd_cd_gotohome:
0301   0586 07 43 11      call putback
0302   0589 FD 4D DD 06   mov si, homedir
0303   058D FD 4F 60 11   mov di, tokstr
0304   0591 07 81 0B      call strcpy
0305   0594 0A 73 05      jmp cmd_cd_syscall
0306   0597             cmd_cd_fail:
0307   0597 09            ret
0308   0598             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0309   0598             ;; pad string to 32 chars
0310   0598             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0311   0598             ; count in C
0312   0598             padding:
0313   0598 D7            push a
0314   0599 10 20 00      mov a, 32
0315   059C 28            mov b, c
0316   059D 60            sub a, b
0317   059E 39            mov c, a
0318   059F             padding_L1:
0319   059F 22 20         mov ah, $20
0320   05A1 07 27 0C      call putchar
0321   05A4 A9 9F 05      loopc padding_L1
0322   05A7 E4            pop a
0323   05A8 09            ret
0324   05A9             ; file structure:
0325   05A9             ; 512 bytes header
0326   05A9             ; header used to tell whether the block is free
0327   05A9             
0328   05A9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0329   05A9             ;; EXEC/OPEN PROGRAM/FILE
0330   05A9             ;; 'filename' maps to '/usr/bin/filename'
0331   05A9             ;; './file' or '/a/directory/file' loads a file directly
0332   05A9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0333   05A9             cmd_exec:
0334   05A9 BC 5F 11 14   cmp byte[tok], TOK_END
0335   05AD C6 33 06      je cmd_exec_ret    ; check for NULL input
0336   05B0 07 66 0F      call get_path    ; get file path 
0337   05B3 14 5C 11      mov a, [prog]
0338   05B6 D7            push a        ; save argument pointer
0339   05B7 FD 4D 60 11   mov si, tokstr
0340   05BB FD 4F 60 12   mov di, temp_data1
0341   05BF 07 81 0B      call strcpy      ; copy filename for later
0342   05C2 BC 60 11 2F   cmp byte[tokstr], '/'  ; check first character of path
0343   05C6 C6 24 06      je cmd_exec_abs
0344   05C9 BC 60 11 2E   cmp byte[tokstr], '.'  ; check first character of path
0345   05CD C6 24 06      je cmd_exec_abs
0346   05D0 10 DD 07      mov a, PATH
0347   05D3 42 5C 11      mov [prog], a    ; set token pointer to $PATH beginning
0348   05D6             cmd_exec_L0:
0349   05D6 07 66 0F      call get_path    ; get a path option
0350   05D9 FD 4D 60 11   mov si, tokstr
0351   05DD FD 4F 60 13   mov di, temp_data
0352   05E1 07 81 0B      call strcpy      ; firstly, form address from one of the '$PATH' addresses
0353   05E4 FD 4D 04 09   mov si, s_fslash
0354   05E8 FD 4F 60 13   mov di, temp_data
0355   05EC 07 8F 0B      call strcat      ; add '/' in between $PATH component and filename
0356   05EF FD 4D 60 12   mov si, temp_data1
0357   05F3 FD 4F 60 13   mov di, temp_data
0358   05F7 07 8F 0B      call strcat      ; now glue the given filename to the total path
0359   05FA 3B 60 13      mov d, temp_data
0360   05FD 19 15         mov al, 21
0361   05FF 05 04         syscall sys_fileio  ; now we check whether such a file exists. success code is given in A. if 0, file does not exist
0362   0601 AF 00 00      cmp a, 0
0363   0604 C7 14 06      jne cmd_exec_PATH_exists
0364   0607 07 BD 0F      call get_token
0365   060A BC 5F 11 06   cmp byte[tok], TOK_SEMI
0366   060E C6 24 06      je cmd_exec_abs    ; if file not found as $PATH/filename, then try to load it without using $PATH
0367   0611 0A D6 05      jmp cmd_exec_L0    ; if not ';' at the end, then token must be a separator. so try another path
0368   0614             cmd_exec_PATH_exists:
0369   0614 E4            pop a        ; retrieve token pointer which points to the arguments given
0370   0615 42 5C 11      mov [prog], a
0371   0618 07 32 0F      call get_arg    ; if however, $PATH/filename was found, then we execute it
0372   061B 26 60 11      mov b, tokstr
0373   061E 3B 60 13      mov d, temp_data
0374   0621 05 05         syscall sys_fork
0375   0623 09            ret
0376   0624             cmd_exec_abs:  ; execute as absolute path
0377   0624 E4            pop a
0378   0625 42 5C 11      mov [prog], a
0379   0628 07 32 0F      call get_arg
0380   062B 26 60 11      mov b, tokstr
0381   062E 3B 60 12      mov d, temp_data1  ;original filename
0382   0631 05 05         syscall sys_fork
0383   0633             cmd_exec_ret:
0384   0633 09            ret
0385   0634             
0386   0634             
0387   0634             cmd_shutdown:
0388   0634 19 01         mov al, 1
0389   0636 05 02         syscall sys_IDE
0390   0638 FF            halt
0391   0639 09            ret
0392   063A             
0393   063A             cmd_reboot:
0394   063A 3B DD 08      mov d, s_rebooting
0395   063D 07 61 0D      call puts
0396   0640 05 08         syscall sys_reboot
0397   0642             
0398   0642             cmd_drtoggle:
0399   0642 0C            lodstat
0400   0643 2F            mov bl, al
0401   0644 FD 87 DF      and bl, %11011111
0402   0647 87 20         and al, %00100000
0403   0649 8F 20         xor al, %00100000
0404   064B 8C            or al, bl
0405   064C 0D            stostat
0406   064D               
0407   064D 09            ret
0408   064E             
0409   064E             cmd_man:
0410   064E 3B BC 0B      mov d, s_telnet_clear
0411   0651 07 61 0D      call puts
0412   0654 FD 4D 5D 07   mov si, manpath
0413   0658 FD 4F 60 13   mov di, temp_data
0414   065C 07 81 0B      call strcpy        ; complete path with command name
0415   065F FD 4D 04 09   mov si, s_fslash
0416   0663 FD 4F 60 13   mov di, temp_data
0417   0667 07 8F 0B      call strcat        ; add '/' to the end
0418   066A 07 BD 0F      call get_token
0419   066D FD 4D 60 11   mov si, tokstr
0420   0671 FD 4F 60 13   mov di, temp_data
0421   0675 07 8F 0B      call strcat        ; complete path with command name
0422   0678 3B 60 13      mov d, temp_data
0423   067B FD 4F 60 15   mov di, shell_transient_area
0424   067F 19 14         mov al, 20
0425   0681 05 04         syscall sys_fileio
0426   0683 3B 60 15      mov d, shell_transient_area
0427   0686 07 61 0D      call puts
0428   0689 07 0E 0D      call printnl
0429   068C             cmd_man_fail:
0430   068C 09            ret
0431   068D             
0432   068D             cmd_fg:
0433   068D 07 BD 0F      call get_token
0434   0690 1D 60 11      mov al, [tokstr]
0435   0693 6F 30         sub al, $30
0436   0695 05 0A         syscall sys_resumeproc
0437   0697 09            ret
0438   0698             
0439   0698 6D 6B 66 73 commands:    .db "mkfs", 0
0439   069C 00 
0440   069D 63 64 00            .db "cd", 0
0441   06A0 73 64 61 74         .db "sdate", 0
0441   06A4 65 00 
0442   06A6 72 65 62 6F         .db "reboot", 0
0442   06AA 6F 74 00 
0443   06AD 73 68 75 74         .db "shutdown", 0
0443   06B1 64 6F 77 6E 
0443   06B5 00 
0444   06B6 64 72 74 6F         .db "drtoggle", 0
0444   06BA 67 67 6C 65 
0444   06BE 00 
0445   06BF 6D 61 6E 00         .db "man", 0
0446   06C3 66 67 00            .db "fg", 0
0447   06C6 73 73 68 00         .db "ssh", 0
0448   06CA 00                  .db 0
0449   06CB             
0450   06CB 53 05       keyword_ptrs:  .dw cmd_mkfs
0451   06CD 58 05               .dw cmd_cd
0452   06CF 4E 05               .dw cmd_setdate
0453   06D1 3A 06               .dw cmd_reboot
0454   06D3 34 06               .dw cmd_shutdown
0455   06D5 42 06               .dw cmd_drtoggle
0456   06D7 4E 06               .dw cmd_man
0457   06D9 8D 06               .dw cmd_fg
0458   06DB 32 05               .dw cmd_ssh
0459   06DD             
0460   06DD 00 00 00 00 homedir:    .fill 128, 0
0460   06E1 00 00 00 00 
0460   06E5 00 00 00 00 
0460   06E9 00 00 00 00 
0460   06ED 00 00 00 00 
0460   06F1 00 00 00 00 
0460   06F5 00 00 00 00 
0460   06F9 00 00 00 00 
0460   06FD 00 00 00 00 
0460   0701 00 00 00 00 
0460   0705 00 00 00 00 
0460   0709 00 00 00 00 
0460   070D 00 00 00 00 
0460   0711 00 00 00 00 
0460   0715 00 00 00 00 
0460   0719 00 00 00 00 
0460   071D 00 00 00 00 
0460   0721 00 00 00 00 
0460   0725 00 00 00 00 
0460   0729 00 00 00 00 
0460   072D 00 00 00 00 
0460   0731 00 00 00 00 
0460   0735 00 00 00 00 
0460   0739 00 00 00 00 
0460   073D 00 00 00 00 
0460   0741 00 00 00 00 
0460   0745 00 00 00 00 
0460   0749 00 00 00 00 
0460   074D 00 00 00 00 
0460   0751 00 00 00 00 
0460   0755 00 00 00 00 
0460   0759 00 00 00 00 
0461   075D 00 00 00 00 manpath:    .fill 128, 0    ; man path
0461   0761 00 00 00 00 
0461   0765 00 00 00 00 
0461   0769 00 00 00 00 
0461   076D 00 00 00 00 
0461   0771 00 00 00 00 
0461   0775 00 00 00 00 
0461   0779 00 00 00 00 
0461   077D 00 00 00 00 
0461   0781 00 00 00 00 
0461   0785 00 00 00 00 
0461   0789 00 00 00 00 
0461   078D 00 00 00 00 
0461   0791 00 00 00 00 
0461   0795 00 00 00 00 
0461   0799 00 00 00 00 
0461   079D 00 00 00 00 
0461   07A1 00 00 00 00 
0461   07A5 00 00 00 00 
0461   07A9 00 00 00 00 
0461   07AD 00 00 00 00 
0461   07B1 00 00 00 00 
0461   07B5 00 00 00 00 
0461   07B9 00 00 00 00 
0461   07BD 00 00 00 00 
0461   07C1 00 00 00 00 
0461   07C5 00 00 00 00 
0461   07C9 00 00 00 00 
0461   07CD 00 00 00 00 
0461   07D1 00 00 00 00 
0461   07D5 00 00 00 00 
0461   07D9 00 00 00 00 
0462   07DD 00 00 00 00 PATH:      .fill 128, 0    ; $PATH environment variable (for now just one path)
0462   07E1 00 00 00 00 
0462   07E5 00 00 00 00 
0462   07E9 00 00 00 00 
0462   07ED 00 00 00 00 
0462   07F1 00 00 00 00 
0462   07F5 00 00 00 00 
0462   07F9 00 00 00 00 
0462   07FD 00 00 00 00 
0462   0801 00 00 00 00 
0462   0805 00 00 00 00 
0462   0809 00 00 00 00 
0462   080D 00 00 00 00 
0462   0811 00 00 00 00 
0462   0815 00 00 00 00 
0462   0819 00 00 00 00 
0462   081D 00 00 00 00 
0462   0821 00 00 00 00 
0462   0825 00 00 00 00 
0462   0829 00 00 00 00 
0462   082D 00 00 00 00 
0462   0831 00 00 00 00 
0462   0835 00 00 00 00 
0462   0839 00 00 00 00 
0462   083D 00 00 00 00 
0462   0841 00 00 00 00 
0462   0845 00 00 00 00 
0462   0849 00 00 00 00 
0462   084D 00 00 00 00 
0462   0851 00 00 00 00 
0462   0855 00 00 00 00 
0462   0859 00 00 00 00 
0463   085D             
0464   085D 2F 65 74 63 s_etc_profile:  .db "/etc/profile", 0
0464   0861 2F 70 72 6F 
0464   0865 66 69 6C 65 
0464   0869 00 
0465   086A 2F 65 74 63 s_etc_config:  .db "/etc/sh.conf", 0
0465   086E 2F 73 68 2E 
0465   0872 63 6F 6E 66 
0465   0876 00 
0466   0877 68 6F 6D 65 s_home:      .db "home", 0
0466   087B 00 
0467   087C 6D 61 6E 00 s_man:      .db "man", 0
0468   0880 50 41 54 48 s_PATH:      .db "PATH", 0
0468   0884 00 
0469   0885             
0470   0885 0A 6D 61 6E s_prompt_manpages:  .db "\nmanpages directory=", 0
0470   0889 70 61 67 65 
0470   088D 73 20 64 69 
0470   0891 72 65 63 74 
0470   0895 6F 72 79 3D 
0470   0899 00 
0471   089A 0A 68 6F 6D s_prompt_homedir:  .db "\nhome directory=", 0
0471   089E 65 20 64 69 
0471   08A2 72 65 63 74 
0471   08A6 6F 72 79 3D 
0471   08AA 00 
0472   08AB 50 41 54 48 s_prompt_PATH:    .db "PATH=", 0
0472   08AF 3D 00 
0473   08B1 0A 72 65 61 s_prompt_config:  .db "\nreading \'/etc/sh.conf\' configuration file\n", 0
0473   08B5 64 69 6E 67 
0473   08B9 20 27 2F 65 
0473   08BD 74 63 2F 73 
0473   08C1 68 2E 63 6F 
0473   08C5 6E 66 27 20 
0473   08C9 63 6F 6E 66 
0473   08CD 69 67 75 72 
0473   08D1 61 74 69 6F 
0473   08D5 6E 20 66 69 
0473   08D9 6C 65 0A 00 
0474   08DD             
0475   08DD 1B 5B 32 4A s_rebooting:   .db 27, "[2J", 27, "[H", "rebooting", 0
0475   08E1 1B 5B 48 72 
0475   08E5 65 62 6F 6F 
0475   08E9 74 69 6E 67 
0475   08ED 00 
0476   08EE 25 20 00    s_dataentry:  .db "% ", 0
0477   08F1 0A 73 79 6E s_syntax_err:  .db "\nsyntax error\n", 0
0477   08F5 74 61 78 20 
0477   08F9 65 72 72 6F 
0477   08FD 72 0A 00 
0478   0900 20 23 20 00 s_hash:      .db " # ", 0
0479   0904 2F 00       s_fslash:    .db "/", 0
0480   0906 53 6F 6C 61 s_sol1:      .db "Solarium:", 0, 0
0480   090A 72 69 75 6D 
0480   090E 3A 00 00 
0481   0911             ; shell variables
0482   0911 00 00 00 00 shell_input_buff:  .fill 512, 0
0482   0915 00 00 00 00 
0482   0919 00 00 00 00 
0482   091D 00 00 00 00 
0482   0921 00 00 00 00 
0482   0925 00 00 00 00 
0482   0929 00 00 00 00 
0482   092D 00 00 00 00 
0482   0931 00 00 00 00 
0482   0935 00 00 00 00 
0482   0939 00 00 00 00 
0482   093D 00 00 00 00 
0482   0941 00 00 00 00 
0482   0945 00 00 00 00 
0482   0949 00 00 00 00 
0482   094D 00 00 00 00 
0482   0951 00 00 00 00 
0482   0955 00 00 00 00 
0482   0959 00 00 00 00 
0482   095D 00 00 00 00 
0482   0961 00 00 00 00 
0482   0965 00 00 00 00 
0482   0969 00 00 00 00 
0482   096D 00 00 00 00 
0482   0971 00 00 00 00 
0482   0975 00 00 00 00 
0482   0979 00 00 00 00 
0482   097D 00 00 00 00 
0482   0981 00 00 00 00 
0482   0985 00 00 00 00 
0482   0989 00 00 00 00 
0482   098D 00 00 00 00 
0482   0991 00 00 00 00 
0482   0995 00 00 00 00 
0482   0999 00 00 00 00 
0482   099D 00 00 00 00 
0482   09A1 00 00 00 00 
0482   09A5 00 00 00 00 
0482   09A9 00 00 00 00 
0482   09AD 00 00 00 00 
0482   09B1 00 00 00 00 
0482   09B5 00 00 00 00 
0482   09B9 00 00 00 00 
0482   09BD 00 00 00 00 
0482   09C1 00 00 00 00 
0482   09C5 00 00 00 00 
0482   09C9 00 00 00 00 
0482   09CD 00 00 00 00 
0482   09D1 00 00 00 00 
0482   09D5 00 00 00 00 
0482   09D9 00 00 00 00 
0482   09DD 00 00 00 00 
0482   09E1 00 00 00 00 
0482   09E5 00 00 00 00 
0482   09E9 00 00 00 00 
0482   09ED 00 00 00 00 
0482   09F1 00 00 00 00 
0482   09F5 00 00 00 00 
0482   09F9 00 00 00 00 
0482   09FD 00 00 00 00 
0482   0A01 00 00 00 00 
0482   0A05 00 00 00 00 
0482   0A09 00 00 00 00 
0482   0A0D 00 00 00 00 
0482   0A11 00 00 00 00 
0482   0A15 00 00 00 00 
0482   0A19 00 00 00 00 
0482   0A1D 00 00 00 00 
0482   0A21 00 00 00 00 
0482   0A25 00 00 00 00 
0482   0A29 00 00 00 00 
0482   0A2D 00 00 00 00 
0482   0A31 00 00 00 00 
0482   0A35 00 00 00 00 
0482   0A39 00 00 00 00 
0482   0A3D 00 00 00 00 
0482   0A41 00 00 00 00 
0482   0A45 00 00 00 00 
0482   0A49 00 00 00 00 
0482   0A4D 00 00 00 00 
0482   0A51 00 00 00 00 
0482   0A55 00 00 00 00 
0482   0A59 00 00 00 00 
0482   0A5D 00 00 00 00 
0482   0A61 00 00 00 00 
0482   0A65 00 00 00 00 
0482   0A69 00 00 00 00 
0482   0A6D 00 00 00 00 
0482   0A71 00 00 00 00 
0482   0A75 00 00 00 00 
0482   0A79 00 00 00 00 
0482   0A7D 00 00 00 00 
0482   0A81 00 00 00 00 
0482   0A85 00 00 00 00 
0482   0A89 00 00 00 00 
0482   0A8D 00 00 00 00 
0482   0A91 00 00 00 00 
0482   0A95 00 00 00 00 
0482   0A99 00 00 00 00 
0482   0A9D 00 00 00 00 
0482   0AA1 00 00 00 00 
0482   0AA5 00 00 00 00 
0482   0AA9 00 00 00 00 
0482   0AAD 00 00 00 00 
0482   0AB1 00 00 00 00 
0482   0AB5 00 00 00 00 
0482   0AB9 00 00 00 00 
0482   0ABD 00 00 00 00 
0482   0AC1 00 00 00 00 
0482   0AC5 00 00 00 00 
0482   0AC9 00 00 00 00 
0482   0ACD 00 00 00 00 
0482   0AD1 00 00 00 00 
0482   0AD5 00 00 00 00 
0482   0AD9 00 00 00 00 
0482   0ADD 00 00 00 00 
0482   0AE1 00 00 00 00 
0482   0AE5 00 00 00 00 
0482   0AE9 00 00 00 00 
0482   0AED 00 00 00 00 
0482   0AF1 00 00 00 00 
0482   0AF5 00 00 00 00 
0482   0AF9 00 00 00 00 
0482   0AFD 00 00 00 00 
0482   0B01 00 00 00 00 
0482   0B05 00 00 00 00 
0482   0B09 00 00 00 00 
0482   0B0D 00 00 00 00 
0483   0B11 00 00       shell_buff_ptr:    .dw 0
0484   0B13 00 00       parser_index:     .dw 0
0485   0B15             
0486   0B15             .include "stdio.asm"
0001+  0B15             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0B15             ; stdio.s
0003+  0B15             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0B15             .include "string.asm"
0001++ 0B15             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0B15             ; string.s
0003++ 0B15             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0B15             
0005++ 0B15             
0006++ 0B15             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0B15             ; strrev
0008++ 0B15             ; reverse a string
0009++ 0B15             ; D = string address
0010++ 0B15             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0B15             ; 01234
0012++ 0B15             strrev:
0013++ 0B15 4B          	pusha
0014++ 0B16 07 5C 0B    	call strlen	; length in C
0015++ 0B19 12          	mov a, c
0016++ 0B1A AF 01 00    	cmp a, 1
0017++ 0B1D D0 37 0B    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0B20 7D          	dec a
0019++ 0B21 FD 4E       	mov si, d	; beginning of string
0020++ 0B23 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0B25 59          	add d, a	; end of string
0022++ 0B26 12          	mov a, c
0023++ 0B27 FD 9B       	shr a		; divide by 2
0024++ 0B29 39          	mov c, a	; C now counts the steps
0025++ 0B2A             strrev_L0:
0026++ 0B2A 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0B2B F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0B2C 3E          	mov [d], al	; store left char into right side
0029++ 0B2D 1B          	mov al, bl
0030++ 0B2E F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0B2F 7E          	dec c
0032++ 0B30 7F          	dec d
0033++ 0B31 C2 00 00    	cmp c, 0
0034++ 0B34 C7 2A 0B    	jne strrev_L0
0035++ 0B37             strrev_end:
0036++ 0B37 4C          	popa
0037++ 0B38 09          	ret
0038++ 0B39             	
0039++ 0B39             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0B39             ; strchr
0041++ 0B39             ; search string in D for char in AL
0042++ 0B39             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0B39             strchr:
0044++ 0B39             strchr_L0:
0045++ 0B39 32          	mov bl, [d]
0046++ 0B3A C1 00       	cmp bl, 0
0047++ 0B3C C6 47 0B    	je strchr_end
0048++ 0B3F BA          	cmp al, bl
0049++ 0B40 C6 47 0B    	je strchr_end
0050++ 0B43 79          	inc d
0051++ 0B44 0A 39 0B    	jmp strchr_L0
0052++ 0B47             strchr_end:
0053++ 0B47 1B          	mov al, bl
0054++ 0B48 09          	ret
0055++ 0B49             
0056++ 0B49             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0B49             ; strstr
0058++ 0B49             ; find sub-string
0059++ 0B49             ; str1 in SI
0060++ 0B49             ; str2 in DI
0061++ 0B49             ; SI points to end of source string
0062++ 0B49             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0B49             strstr:
0064++ 0B49 DB          	push al
0065++ 0B4A DA          	push d
0066++ 0B4B E3          	push di
0067++ 0B4C             strstr_loop:
0068++ 0B4C F3          	cmpsb					; compare a byte of the strings
0069++ 0B4D C7 58 0B    	jne strstr_ret
0070++ 0B50 FC 00 00    	lea d, [di + 0]
0071++ 0B53 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0B55 C7 4C 0B    	jne strstr_loop				; equal chars but not at end
0073++ 0B58             strstr_ret:
0074++ 0B58 F0          	pop di
0075++ 0B59 E7          	pop d
0076++ 0B5A E8          	pop al
0077++ 0B5B 09          	ret
0078++ 0B5C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0B5C             ; length of null terminated string
0080++ 0B5C             ; result in C
0081++ 0B5C             ; pointer in D
0082++ 0B5C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0B5C             strlen:
0084++ 0B5C DA          	push d
0085++ 0B5D 38 00 00    	mov c, 0
0086++ 0B60             strlen_L1:
0087++ 0B60 BD 00       	cmp byte [d], 0
0088++ 0B62 C6 6A 0B    	je strlen_ret
0089++ 0B65 79          	inc d
0090++ 0B66 78          	inc c
0091++ 0B67 0A 60 0B    	jmp strlen_L1
0092++ 0B6A             strlen_ret:
0093++ 0B6A E7          	pop d
0094++ 0B6B 09          	ret
0095++ 0B6C             
0096++ 0B6C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0B6C             ; STRCMP
0098++ 0B6C             ; compare two strings
0099++ 0B6C             ; str1 in SI
0100++ 0B6C             ; str2 in DI
0101++ 0B6C             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0B6C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0B6C             strcmp:
0104++ 0B6C DB          	push al
0105++ 0B6D DA          	push d
0106++ 0B6E E3          	push di
0107++ 0B6F E2          	push si
0108++ 0B70             strcmp_loop:
0109++ 0B70 F3          	cmpsb					; compare a byte of the strings
0110++ 0B71 C7 7C 0B    	jne strcmp_ret
0111++ 0B74 FB FF FF    	lea d, [si +- 1]
0112++ 0B77 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0B79 C7 70 0B    	jne strcmp_loop				; equal chars but not at end
0114++ 0B7C             strcmp_ret:
0115++ 0B7C EF          	pop si
0116++ 0B7D F0          	pop di
0117++ 0B7E E7          	pop d
0118++ 0B7F E8          	pop al
0119++ 0B80 09          	ret
0120++ 0B81             
0121++ 0B81             
0122++ 0B81             ; STRCPY
0123++ 0B81             ; copy null terminated string from SI to DI
0124++ 0B81             ; source in SI
0125++ 0B81             ; destination in DI
0126++ 0B81             strcpy:
0127++ 0B81 E2          	push si
0128++ 0B82 E3          	push di
0129++ 0B83 DB          	push al
0130++ 0B84             strcpy_L1:
0131++ 0B84 F6          	lodsb
0132++ 0B85 F7          	stosb
0133++ 0B86 B9 00       	cmp al, 0
0134++ 0B88 C7 84 0B    	jne strcpy_L1
0135++ 0B8B             strcpy_end:
0136++ 0B8B E8          	pop al
0137++ 0B8C F0          	pop di
0138++ 0B8D EF          	pop si
0139++ 0B8E 09          	ret
0140++ 0B8F             
0141++ 0B8F             ; STRCAT
0142++ 0B8F             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0B8F             ; source in SI
0144++ 0B8F             ; destination in DI
0145++ 0B8F             strcat:
0146++ 0B8F E2          	push si
0147++ 0B90 E3          	push di
0148++ 0B91 D7          	push a
0149++ 0B92 DA          	push d
0150++ 0B93 50          	mov a, di
0151++ 0B94 3C          	mov d, a
0152++ 0B95             strcat_goto_end_L1:
0153++ 0B95 BD 00       	cmp byte[d], 0
0154++ 0B97 C6 9E 0B    	je strcat_start
0155++ 0B9A 79          	inc d
0156++ 0B9B 0A 95 0B    	jmp strcat_goto_end_L1
0157++ 0B9E             strcat_start:
0158++ 0B9E FD 50       	mov di, d
0159++ 0BA0             strcat_L1:
0160++ 0BA0 F6          	lodsb
0161++ 0BA1 F7          	stosb
0162++ 0BA2 B9 00       	cmp al, 0
0163++ 0BA4 C7 A0 0B    	jne strcat_L1
0164++ 0BA7             strcat_end:
0165++ 0BA7 E7          	pop d
0166++ 0BA8 E4          	pop a
0167++ 0BA9 F0          	pop di
0168++ 0BAA EF          	pop si
0169++ 0BAB 09          	ret
0005+  0BAC             
0006+  0BAC 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  0BB0 34 35 36 37 
0006+  0BB4 38 39 41 42 
0006+  0BB8 43 44 45 46 
0007+  0BBC 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  0BC0 1B 5B 48 00 
0008+  0BC4             
0009+  0BC4 01 00       table_power:.dw 1
0010+  0BC6 0A 00       			.dw 10
0011+  0BC8 64 00       			.dw 100
0012+  0BCA E8 03       			.dw 1000
0013+  0BCC 10 27       			.dw 10000
0014+  0BCE             
0015+  0BCE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  0BCE             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  0BCE             ; ASCII in BL
0018+  0BCE             ; result in AL
0019+  0BCE             ; ascii for F = 0100 0110
0020+  0BCE             ; ascii for 9 = 0011 1001
0021+  0BCE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  0BCE             hex_ascii_encode:
0023+  0BCE 1B          	mov al, bl
0024+  0BCF 93 40       	test al, $40				; test if letter or number
0025+  0BD1 C7 D7 0B    	jnz hex_letter
0026+  0BD4 87 0F       	and al, $0F				; get number
0027+  0BD6 09          	ret
0028+  0BD7             hex_letter:
0029+  0BD7 87 0F       	and al, $0F				; get letter
0030+  0BD9 6A 09       	add al, 9
0031+  0BDB 09          	ret
0032+  0BDC             
0033+  0BDC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  0BDC             ; ATOI
0035+  0BDC             ; 2 letter hex string in B
0036+  0BDC             ; 8bit integer returned in AL
0037+  0BDC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0BDC             atoi:
0039+  0BDC D8          	push b
0040+  0BDD 07 CE 0B    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  0BE0 30          	mov bl, bh
0042+  0BE1 DB          	push al					; save a
0043+  0BE2 07 CE 0B    	call hex_ascii_encode
0044+  0BE5 EA          	pop bl	
0045+  0BE6 FD 9E 04    	shl al, 4
0046+  0BE9 8C          	or al, bl
0047+  0BEA E5          	pop b
0048+  0BEB 09          	ret	
0049+  0BEC             
0050+  0BEC             
0051+  0BEC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  0BEC             ; printf
0053+  0BEC             ; no need for explanations!
0054+  0BEC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0BEC             printf:
0056+  0BEC 09          	ret
0057+  0BED             
0058+  0BED             
0059+  0BED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  0BED             ; scanf
0061+  0BED             ; no need for explanations!
0062+  0BED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  0BED             scanf:
0064+  0BED 09          	ret
0065+  0BEE             
0066+  0BEE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  0BEE             ; ITOA
0068+  0BEE             ; 8bit value in BL
0069+  0BEE             ; 2 byte ASCII result in A
0070+  0BEE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  0BEE             itoa:
0072+  0BEE DA          	push d
0073+  0BEF D8          	push b
0074+  0BF0 A7 00       	mov bh, 0
0075+  0BF2 FD A4 04    	shr bl, 4	
0076+  0BF5 74          	mov d, b
0077+  0BF6 1F AC 0B    	mov al, [d + s_hex_digits]
0078+  0BF9 23          	mov ah, al
0079+  0BFA             	
0080+  0BFA E5          	pop b
0081+  0BFB D8          	push b
0082+  0BFC A7 00       	mov bh, 0
0083+  0BFE FD 87 0F    	and bl, $0F
0084+  0C01 74          	mov d, b
0085+  0C02 1F AC 0B    	mov al, [d + s_hex_digits]
0086+  0C05 E5          	pop b
0087+  0C06 E7          	pop d
0088+  0C07 09          	ret
0089+  0C08             
0090+  0C08             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  0C08             ; HEX STRING TO BINARY
0092+  0C08             ; di = destination address
0093+  0C08             ; si = source
0094+  0C08             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  0C08             hex_to_int:
0096+  0C08             hex_to_int_L1:
0097+  0C08 F6          	lodsb					; load from [SI] to AL
0098+  0C09 B9 00       	cmp al, 0				; check if ASCII 0
0099+  0C0B C6 18 0C    	jz hex_to_int_ret
0100+  0C0E 36          	mov bh, al
0101+  0C0F F6          	lodsb
0102+  0C10 2F          	mov bl, al
0103+  0C11 07 DC 0B    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  0C14 F7          	stosb					; store AL to [DI]
0105+  0C15 0A 08 0C    	jmp hex_to_int_L1
0106+  0C18             hex_to_int_ret:
0107+  0C18 09          	ret		
0108+  0C19             
0109+  0C19             
0110+  0C19             
0111+  0C19             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  0C19             ; GETCHAR
0113+  0C19             ; char in ah
0114+  0C19             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  0C19             getchar:
0116+  0C19 DB          	push al
0117+  0C1A             getchar_retry:
0118+  0C1A FD 0C       	sti
0119+  0C1C 19 01       	mov al, 1
0120+  0C1E 05 03       	syscall sys_io			; receive in AH
0121+  0C20 B9 00       	cmp al, 0			; check if any char was receive
0122+  0C22 C6 1A 0C    	je getchar_retry
0123+  0C25 E8          	pop al
0124+  0C26 09          	ret
0125+  0C27             
0126+  0C27             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  0C27             ; PUTCHAR
0128+  0C27             ; char in ah
0129+  0C27             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0C27             putchar:
0131+  0C27 D7          	push a
0132+  0C28 19 00       	mov al, 0
0133+  0C2A 05 03       	syscall sys_io			; char in AH
0134+  0C2C E4          	pop a
0135+  0C2D 09          	ret
0136+  0C2E             
0137+  0C2E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  0C2E             ;; INPUT A STRING
0139+  0C2E             ;; terminates with null
0140+  0C2E             ;; pointer in D
0141+  0C2E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  0C2E             gets:
0143+  0C2E D7          	push a
0144+  0C2F DA          	push d
0145+  0C30             gets_loop:
0146+  0C30 FD 0C       	sti
0147+  0C32 19 01       	mov al, 1
0148+  0C34 05 03       	syscall sys_io			; receive in AH
0149+  0C36 B9 00       	cmp al, 0				; check error code (AL)
0150+  0C38 C6 30 0C    	je gets_loop			; if no char received, retry
0151+  0C3B             
0152+  0C3B 76 1B       	cmp ah, 27
0153+  0C3D C6 5E 0C    	je gets_telnet_escape
0154+  0C40 76 0A       	cmp ah, $0A				; LF
0155+  0C42 C6 B7 0C    	je gets_end
0156+  0C45 76 0D       	cmp ah, $0D				; CR
0157+  0C47 C6 B7 0C    	je gets_end
0158+  0C4A 76 5C       	cmp ah, $5C				; '\\'
0159+  0C4C C6 8E 0C    	je gets_escape
0160+  0C4F             	
0161+  0C4F 76 08       	cmp ah, $08			; check for backspace
0162+  0C51 C6 5A 0C    	je gets_backspace
0163+  0C54             
0164+  0C54 1A          	mov al, ah
0165+  0C55 3E          	mov [d], al
0166+  0C56 79          	inc d
0167+  0C57 0A 30 0C    	jmp gets_loop
0168+  0C5A             gets_backspace:
0169+  0C5A 7F          	dec d
0170+  0C5B 0A 30 0C    	jmp gets_loop
0171+  0C5E             gets_telnet_escape:
0172+  0C5E FD 0C       	sti
0173+  0C60 19 01       	mov al, 1
0174+  0C62 05 03       	syscall sys_io				; receive in AH without echo
0175+  0C64 B9 00       	cmp al, 0					; check error code (AL)
0176+  0C66 C6 5E 0C    	je gets_telnet_escape		; if no char received, retry
0177+  0C69 76 5B       	cmp ah, '['
0178+  0C6B C7 30 0C    	jne gets_loop
0179+  0C6E             gets_telnet_escape_phase2:
0180+  0C6E FD 0C       	sti
0181+  0C70 19 01       	mov al, 1
0182+  0C72 05 03       	syscall sys_io					; receive in AH without echo
0183+  0C74 B9 00       	cmp al, 0						; check error code (AL)
0184+  0C76 C6 6E 0C    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  0C79 76 44       	cmp ah, 'D'
0186+  0C7B C6 86 0C    	je gets_left_arrow
0187+  0C7E 76 43       	cmp ah, 'C'
0188+  0C80 C6 8A 0C    	je gets_right_arrow
0189+  0C83 0A 30 0C    	jmp gets_loop
0190+  0C86             gets_left_arrow:
0191+  0C86 7F          	dec d
0192+  0C87 0A 30 0C    	jmp gets_loop
0193+  0C8A             gets_right_arrow:
0194+  0C8A 79          	inc d
0195+  0C8B 0A 30 0C    	jmp gets_loop
0196+  0C8E             gets_escape:
0197+  0C8E FD 0C       	sti
0198+  0C90 19 01       	mov al, 1
0199+  0C92 05 03       	syscall sys_io			; receive in AH
0200+  0C94 B9 00       	cmp al, 0				; check error code (AL)
0201+  0C96 C6 8E 0C    	je gets_escape			; if no char received, retry
0202+  0C99 76 6E       	cmp ah, 'n'
0203+  0C9B C6 A9 0C    	je gets_LF
0204+  0C9E 76 72       	cmp ah, 'r'
0205+  0CA0 C6 B0 0C    	je gets_CR
0206+  0CA3 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  0CA4 3E          	mov [d], al
0208+  0CA5 79          	inc d
0209+  0CA6 0A 30 0C    	jmp gets_loop
0210+  0CA9             gets_LF:
0211+  0CA9 19 0A       	mov al, $0A
0212+  0CAB 3E          	mov [d], al
0213+  0CAC 79          	inc d
0214+  0CAD 0A 30 0C    	jmp gets_loop
0215+  0CB0             gets_CR:
0216+  0CB0 19 0D       	mov al, $0D
0217+  0CB2 3E          	mov [d], al
0218+  0CB3 79          	inc d
0219+  0CB4 0A 30 0C    	jmp gets_loop
0220+  0CB7             gets_end:
0221+  0CB7 19 00       	mov al, 0
0222+  0CB9 3E          	mov [d], al				; terminate string
0223+  0CBA E7          	pop d
0224+  0CBB E4          	pop a
0225+  0CBC 09          	ret
0226+  0CBD             
0227+  0CBD             
0228+  0CBD             
0229+  0CBD             
0230+  0CBD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  0CBD             ;; INPUT TEXT
0232+  0CBD             ;; terminated with CTRL+D
0233+  0CBD             ;; pointer in D
0234+  0CBD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  0CBD             gettxt:
0236+  0CBD D7          	push a
0237+  0CBE DA          	push d
0238+  0CBF             gettxt_loop:
0239+  0CBF 19 01       	mov al, 1
0240+  0CC1 05 03       	syscall sys_io			; receive in AH
0241+  0CC3 B9 00       	cmp al, 0				; check error code (AL)
0242+  0CC5 C6 BF 0C    	je gettxt_loop		; if no char received, retry
0243+  0CC8 76 04       	cmp ah, 4			; EOT
0244+  0CCA C6 08 0D    	je gettxt_end
0245+  0CCD 76 08       	cmp ah, $08			; check for backspace
0246+  0CCF C6 04 0D    	je gettxt_backspace
0247+  0CD2 76 5C       	cmp ah, $5C				; '\\'
0248+  0CD4 C6 DD 0C    	je gettxt_escape
0249+  0CD7 1A          	mov al, ah
0250+  0CD8 3E          	mov [d], al
0251+  0CD9 79          	inc d
0252+  0CDA 0A BF 0C    	jmp gettxt_loop
0253+  0CDD             gettxt_escape:
0254+  0CDD 19 01       	mov al, 1
0255+  0CDF 05 03       	syscall sys_io			; receive in AH
0256+  0CE1 B9 00       	cmp al, 0				; check error code (AL)
0257+  0CE3 C6 DD 0C    	je gettxt_escape		; if no char received, retry
0258+  0CE6 76 6E       	cmp ah, 'n'
0259+  0CE8 C6 F6 0C    	je gettxt_LF
0260+  0CEB 76 72       	cmp ah, 'r'
0261+  0CED C6 FD 0C    	je gettxt_CR
0262+  0CF0 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  0CF1 3E          	mov [d], al
0264+  0CF2 79          	inc d
0265+  0CF3 0A BF 0C    	jmp gettxt_loop
0266+  0CF6             gettxt_LF:
0267+  0CF6 19 0A       	mov al, $0A
0268+  0CF8 3E          	mov [d], al
0269+  0CF9 79          	inc d
0270+  0CFA 0A BF 0C    	jmp gettxt_loop
0271+  0CFD             gettxt_CR:
0272+  0CFD 19 0D       	mov al, $0D
0273+  0CFF 3E          	mov [d], al
0274+  0D00 79          	inc d
0275+  0D01 0A BF 0C    	jmp gettxt_loop
0276+  0D04             gettxt_backspace:
0277+  0D04 7F          	dec d
0278+  0D05 0A BF 0C    	jmp gettxt_loop
0279+  0D08             gettxt_end:
0280+  0D08 19 00       	mov al, 0
0281+  0D0A 3E          	mov [d], al				; terminate string
0282+  0D0B E7          	pop d
0283+  0D0C E4          	pop a
0284+  0D0D 09          	ret
0285+  0D0E             
0286+  0D0E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  0D0E             ; PRINT NEW LINE
0288+  0D0E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  0D0E             printnl:
0290+  0D0E D7          	push a
0291+  0D0F 10 00 0A    	mov a, $0A00
0292+  0D12 05 03       	syscall sys_io
0293+  0D14 10 00 0D    	mov a, $0D00
0294+  0D17 05 03       	syscall sys_io
0295+  0D19 E4          	pop a
0296+  0D1A 09          	ret
0297+  0D1B             
0298+  0D1B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  0D1B             ; strtoint
0300+  0D1B             ; 4 digit hex string number in d
0301+  0D1B             ; integer returned in A
0302+  0D1B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  0D1B             strtointx:
0304+  0D1B D8          	push b
0305+  0D1C 32          	mov bl, [d]
0306+  0D1D 37          	mov bh, bl
0307+  0D1E 33 01 00    	mov bl, [d + 1]
0308+  0D21 07 DC 0B    	call atoi				; convert to int in AL
0309+  0D24 23          	mov ah, al				; move to AH
0310+  0D25 33 02 00    	mov bl, [d + 2]
0311+  0D28 37          	mov bh, bl
0312+  0D29 33 03 00    	mov bl, [d + 3]
0313+  0D2C 07 DC 0B    	call atoi				; convert to int in AL
0314+  0D2F E5          	pop b
0315+  0D30 09          	ret
0316+  0D31             
0317+  0D31             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  0D31             ; strtoint
0319+  0D31             ; 5 digit base10 string number in d
0320+  0D31             ; integer returned in A
0321+  0D31             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  0D31             strtoint:
0323+  0D31 E2          	push si
0324+  0D32 D8          	push b
0325+  0D33 D9          	push c
0326+  0D34 DA          	push d
0327+  0D35 07 5C 0B    	call strlen			; get string length in C
0328+  0D38 7E          	dec c
0329+  0D39 FD 4E       	mov si, d
0330+  0D3B 12          	mov a, c
0331+  0D3C FD 99       	shl a
0332+  0D3E 3B C4 0B    	mov d, table_power
0333+  0D41 59          	add d, a
0334+  0D42 38 00 00    	mov c, 0
0335+  0D45             strtoint_L0:
0336+  0D45 F6          	lodsb			; load ASCII to al
0337+  0D46 B9 00       	cmp al, 0
0338+  0D48 C6 5B 0D    	je strtoint_end
0339+  0D4B 6F 30       	sub al, $30		; make into integer
0340+  0D4D 22 00       	mov ah, 0
0341+  0D4F 2A          	mov b, [d]
0342+  0D50 AC          	mul a, b			; result in B since it fits in 16bits
0343+  0D51 11          	mov a, b
0344+  0D52 28          	mov b, c
0345+  0D53 54          	add a, b
0346+  0D54 39          	mov c, a
0347+  0D55 63 02 00    	sub d, 2
0348+  0D58 0A 45 0D    	jmp strtoint_L0
0349+  0D5B             strtoint_end:
0350+  0D5B 12          	mov a, c
0351+  0D5C E7          	pop d
0352+  0D5D E6          	pop c
0353+  0D5E E5          	pop b
0354+  0D5F EF          	pop si
0355+  0D60 09          	ret
0356+  0D61             
0357+  0D61             
0358+  0D61             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  0D61             ; PRINT NULL TERMINATED STRING
0360+  0D61             ; pointer in D
0361+  0D61             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  0D61             puts:
0363+  0D61 D7          	push a
0364+  0D62 DA          	push d
0365+  0D63             puts_L1:
0366+  0D63 1E          	mov al, [d]
0367+  0D64 B9 00       	cmp al, 0
0368+  0D66 C6 72 0D    	jz puts_END
0369+  0D69 23          	mov ah, al
0370+  0D6A 19 00       	mov al, 0
0371+  0D6C 05 03       	syscall sys_io
0372+  0D6E 79          	inc d
0373+  0D6F 0A 63 0D    	jmp puts_L1
0374+  0D72             puts_END:
0375+  0D72 E7          	pop d
0376+  0D73 E4          	pop a
0377+  0D74 09          	ret
0378+  0D75             
0379+  0D75             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  0D75             ; PRINT N SIZE STRING
0381+  0D75             ; pointer in D
0382+  0D75             ; size in C
0383+  0D75             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  0D75             putsn:
0385+  0D75 DB          	push al
0386+  0D76 DA          	push d
0387+  0D77 D9          	push c
0388+  0D78             putsn_L0:
0389+  0D78 1E          	mov al, [d]
0390+  0D79 23          	mov ah, al
0391+  0D7A 19 00       	mov al, 0
0392+  0D7C 05 03       	syscall sys_io
0393+  0D7E 79          	inc d
0394+  0D7F 7E          	dec c	
0395+  0D80 C2 00 00    	cmp c, 0
0396+  0D83 C7 78 0D    	jne putsn_L0
0397+  0D86             putsn_end:
0398+  0D86 E6          	pop c
0399+  0D87 E7          	pop d
0400+  0D88 E8          	pop al
0401+  0D89 09          	ret
0402+  0D8A             
0403+  0D8A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  0D8A             ; print 16bit decimal number
0405+  0D8A             ; input number in A
0406+  0D8A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  0D8A             print_u16d:
0408+  0D8A D7          	push a
0409+  0D8B D8          	push b
0410+  0D8C 26 10 27    	mov b, 10000
0411+  0D8F AE          	div a, b			; get 10000's coeff.
0412+  0D90 07 B2 0D    	call print_number
0413+  0D93 11          	mov a, b
0414+  0D94 26 E8 03    	mov b, 1000
0415+  0D97 AE          	div a, b			; get 1000's coeff.
0416+  0D98 07 B2 0D    	call print_number
0417+  0D9B 11          	mov a, b
0418+  0D9C 26 64 00    	mov b, 100
0419+  0D9F AE          	div a, b
0420+  0DA0 07 B2 0D    	call print_number
0421+  0DA3 11          	mov a, b
0422+  0DA4 26 0A 00    	mov b, 10
0423+  0DA7 AE          	div a, b
0424+  0DA8 07 B2 0D    	call print_number
0425+  0DAB 1B          	mov al, bl			; 1's coeff in bl
0426+  0DAC 07 B2 0D    	call print_number
0427+  0DAF E5          	pop b
0428+  0DB0 E4          	pop a
0429+  0DB1 09          	ret
0430+  0DB2             
0431+  0DB2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0432+  0DB2             ; print AL
0433+  0DB2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0434+  0DB2             print_number:
0435+  0DB2 6A 30       	add al, $30
0436+  0DB4 23          	mov ah, al
0437+  0DB5 07 27 0C    	call putchar
0438+  0DB8 09          	ret
0439+  0DB9             
0440+  0DB9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0441+  0DB9             ; PRINT 16BIT HEX INTEGER
0442+  0DB9             ; integer value in reg B
0443+  0DB9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0444+  0DB9             print_u16x:
0445+  0DB9 D7          	push a
0446+  0DBA D8          	push b
0447+  0DBB DD          	push bl
0448+  0DBC 30          	mov bl, bh
0449+  0DBD 07 EE 0B    	call itoa				; convert bh to char in A
0450+  0DC0 2F          	mov bl, al				; save al
0451+  0DC1 19 00       	mov al, 0
0452+  0DC3 05 03       	syscall sys_io				; display AH
0453+  0DC5 24          	mov ah, bl				; retrieve al
0454+  0DC6 19 00       	mov al, 0
0455+  0DC8 05 03       	syscall sys_io				; display AL
0456+  0DCA             
0457+  0DCA EA          	pop bl
0458+  0DCB 07 EE 0B    	call itoa				; convert bh to char in A
0459+  0DCE 2F          	mov bl, al				; save al
0460+  0DCF 19 00       	mov al, 0
0461+  0DD1 05 03       	syscall sys_io				; display AH
0462+  0DD3 24          	mov ah, bl				; retrieve al
0463+  0DD4 19 00       	mov al, 0
0464+  0DD6 05 03       	syscall sys_io				; display AL
0465+  0DD8             
0466+  0DD8 E5          	pop b
0467+  0DD9 E4          	pop a
0468+  0DDA 09          	ret
0469+  0DDB             
0470+  0DDB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0471+  0DDB             ; INPUT 16BIT HEX INTEGER
0472+  0DDB             ; read 16bit integer into A
0473+  0DDB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0474+  0DDB             scan_u16x:
0475+  0DDB F8 10 00    	enter 16
0476+  0DDE D8          	push b
0477+  0DDF DA          	push d
0478+  0DE0             
0479+  0DE0 FA F1 FF    	lea d, [bp + -15]
0480+  0DE3 07 2E 0C    	call gets				; get number
0481+  0DE6             
0482+  0DE6 32          	mov bl, [d]
0483+  0DE7 37          	mov bh, bl
0484+  0DE8 33 01 00    	mov bl, [d + 1]
0485+  0DEB 07 DC 0B    	call atoi				; convert to int in AL
0486+  0DEE 23          	mov ah, al				; move to AH
0487+  0DEF             
0488+  0DEF 33 02 00    	mov bl, [d + 2]
0489+  0DF2 37          	mov bh, bl
0490+  0DF3 33 03 00    	mov bl, [d + 3]
0491+  0DF6 07 DC 0B    	call atoi				; convert to int in AL
0492+  0DF9             
0493+  0DF9 E7          	pop d
0494+  0DFA E5          	pop b
0495+  0DFB F9          	leave
0496+  0DFC 09          	ret
0497+  0DFD             
0498+  0DFD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0499+  0DFD             ; PRINT 8bit HEX INTEGER
0500+  0DFD             ; integer value in reg bl
0501+  0DFD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0502+  0DFD             print_u8x:
0503+  0DFD D7          	push a
0504+  0DFE DD          	push bl
0505+  0DFF             
0506+  0DFF 07 EE 0B    	call itoa				; convert bl to char in A
0507+  0E02 2F          	mov bl, al				; save al
0508+  0E03 19 00       	mov al, 0
0509+  0E05 05 03       	syscall sys_io				; display AH
0510+  0E07 24          	mov ah, bl				; retrieve al
0511+  0E08 19 00       	mov al, 0
0512+  0E0A 05 03       	syscall sys_io				; display AL
0513+  0E0C             
0514+  0E0C EA          	pop bl
0515+  0E0D E4          	pop a
0516+  0E0E 09          	ret
0517+  0E0F             
0518+  0E0F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0519+  0E0F             ; print 8bit decimal unsigned number
0520+  0E0F             ; input number in AL
0521+  0E0F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0522+  0E0F             print_u8d:
0523+  0E0F D7          	push a
0524+  0E10 D8          	push b
0525+  0E11             
0526+  0E11 22 00       	mov ah, 0
0527+  0E13 26 64 00    	mov b, 100
0528+  0E16 AE          	div a, b
0529+  0E17 D8          	push b			; save remainder
0530+  0E18 B9 00       	cmp al, 0
0531+  0E1A C6 24 0E    	je skip100
0532+  0E1D 6A 30       	add al, $30
0533+  0E1F 23          	mov ah, al
0534+  0E20 19 00       	mov al, 0
0535+  0E22 05 03       	syscall sys_io	; print coeff
0536+  0E24             skip100:
0537+  0E24 E4          	pop a
0538+  0E25 22 00       	mov ah, 0
0539+  0E27 26 0A 00    	mov b, 10
0540+  0E2A AE          	div a, b
0541+  0E2B D8          	push b			; save remainder
0542+  0E2C B9 00       	cmp al, 0
0543+  0E2E C6 38 0E    	je skip10
0544+  0E31 6A 30       	add al, $30
0545+  0E33 23          	mov ah, al
0546+  0E34 19 00       	mov al, 0
0547+  0E36 05 03       	syscall sys_io	; print coeff
0548+  0E38             skip10:
0549+  0E38 E4          	pop a
0550+  0E39 1B          	mov al, bl
0551+  0E3A 6A 30       	add al, $30
0552+  0E3C 23          	mov ah, al
0553+  0E3D 19 00       	mov al, 0
0554+  0E3F 05 03       	syscall sys_io	; print coeff
0555+  0E41 E5          	pop b
0556+  0E42 E4          	pop a
0557+  0E43 09          	ret
0558+  0E44             
0559+  0E44             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0560+  0E44             ; INPUT 8BIT HEX INTEGER
0561+  0E44             ; read 8bit integer into AL
0562+  0E44             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0563+  0E44             scan_u8x:
0564+  0E44 F8 04 00    	enter 4
0565+  0E47 D8          	push b
0566+  0E48 DA          	push d
0567+  0E49             
0568+  0E49 FA FD FF    	lea d, [bp + -3]
0569+  0E4C 07 2E 0C    	call gets				; get number
0570+  0E4F             
0571+  0E4F 32          	mov bl, [d]
0572+  0E50 37          	mov bh, bl
0573+  0E51 33 01 00    	mov bl, [d + 1]
0574+  0E54 07 DC 0B    	call atoi				; convert to int in AL
0575+  0E57             
0576+  0E57 E7          	pop d
0577+  0E58 E5          	pop b
0578+  0E59 F9          	leave
0579+  0E5A 09          	ret
0580+  0E5B             
0581+  0E5B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0582+  0E5B             ; input decimal number
0583+  0E5B             ; result in A
0584+  0E5B             ; 655'\0'
0585+  0E5B             ; low--------high
0586+  0E5B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  0E5B             scan_u16d:
0588+  0E5B F8 08 00    	enter 8
0589+  0E5E E2          	push si
0590+  0E5F D8          	push b
0591+  0E60 D9          	push c
0592+  0E61 DA          	push d
0593+  0E62 FA F9 FF    	lea d, [bp +- 7]
0594+  0E65 07 2E 0C    	call gets
0595+  0E68 07 5C 0B    	call strlen			; get string length in C
0596+  0E6B 7E          	dec c
0597+  0E6C FD 4E       	mov si, d
0598+  0E6E 12          	mov a, c
0599+  0E6F FD 99       	shl a
0600+  0E71 3B C4 0B    	mov d, table_power
0601+  0E74 59          	add d, a
0602+  0E75 38 00 00    	mov c, 0
0603+  0E78             mul_loop:
0604+  0E78 F6          	lodsb			; load ASCII to al
0605+  0E79 B9 00       	cmp al, 0
0606+  0E7B C6 8E 0E    	je mul_exit
0607+  0E7E 6F 30       	sub al, $30		; make into integer
0608+  0E80 22 00       	mov ah, 0
0609+  0E82 2A          	mov b, [d]
0610+  0E83 AC          	mul a, b			; result in B since it fits in 16bits
0611+  0E84 11          	mov a, b
0612+  0E85 28          	mov b, c
0613+  0E86 54          	add a, b
0614+  0E87 39          	mov c, a
0615+  0E88 63 02 00    	sub d, 2
0616+  0E8B 0A 78 0E    	jmp mul_loop
0617+  0E8E             mul_exit:
0618+  0E8E 12          	mov a, c
0619+  0E8F E7          	pop d
0620+  0E90 E6          	pop c
0621+  0E91 E5          	pop b
0622+  0E92 EF          	pop si
0623+  0E93 F9          	leave
0624+  0E94 09          	ret
0487   0E95             .include "ctype.asm"
0001+  0E95             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0E95             ; ctype.s
0003+  0E95             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0E95             
0005+  0E95             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  0E95             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  0E95             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  0E95             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  0E95             ;; characters are supported.
0010+  0E95             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  0E95             ;; isalnum 
0012+  0E95             ;; isalpha 
0013+  0E95             ;; islower 
0014+  0E95             ;; isupper 
0015+  0E95             ;; isdigit 
0016+  0E95             ;; isxdigit
0017+  0E95             ;; iscntrl 
0018+  0E95             ;; isgraph 
0019+  0E95             ;; isspace 
0020+  0E95             ;; isblank 
0021+  0E95             ;; isprint 
0022+  0E95             ;; ispunct 
0023+  0E95             ;; tolower 
0024+  0E95             ;; toupper
0025+  0E95             
0026+  0E95             
0027+  0E95             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  0E95             ;; IS ALPHANUMERIC
0029+  0E95             ;; sets ZF according with result
0030+  0E95             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  0E95             isalnum:
0032+  0E95 07 B2 0E    	call isalpha
0033+  0E98 C6 9E 0E    	je isalnum_exit
0034+  0E9B 07 9F 0E    	call isdigit
0035+  0E9E             isalnum_exit:
0036+  0E9E 09          	ret	
0037+  0E9F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0E9F             ;; IS DIGIT
0039+  0E9F             ;; sets ZF according with result
0040+  0E9F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  0E9F             isdigit:
0042+  0E9F DB          	push al
0043+  0EA0 B9 30       	cmp al, '0'
0044+  0EA2 C8 AE 0E    	jlu isdigit_false
0045+  0EA5 B9 39       	cmp al, '9'
0046+  0EA7 D1 AE 0E    	jgu isdigit_false
0047+  0EAA 87 00       	and al, 0	; set ZF
0048+  0EAC E8          	pop al
0049+  0EAD 09          	ret
0050+  0EAE             isdigit_false:
0051+  0EAE 8B 01       	or al, 1	; clear ZF
0052+  0EB0 E8          	pop al
0053+  0EB1 09          	ret	
0054+  0EB2             	
0055+  0EB2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  0EB2             ;; IS ALPHA
0057+  0EB2             ;; sets ZF according with result
0058+  0EB2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  0EB2             isalpha:
0060+  0EB2 DB          	push al
0061+  0EB3 B9 5F       	cmp al, '_'
0062+  0EB5 C6 D5 0E    	je isalpha_true
0063+  0EB8 B9 2E       	cmp al, '.'
0064+  0EBA C6 D5 0E    	je isalpha_true
0065+  0EBD B9 41       	cmp al, 'A'
0066+  0EBF C8 D1 0E    	jlu isalpha_false
0067+  0EC2 B9 7A       	cmp al, 'z'
0068+  0EC4 D1 D1 0E    	jgu isalpha_false
0069+  0EC7 B9 5A       	cmp al, 'Z'
0070+  0EC9 D0 D5 0E    	jleu isalpha_true
0071+  0ECC B9 61       	cmp al, 'a'
0072+  0ECE C9 D5 0E    	jgeu isalpha_true
0073+  0ED1             isalpha_false:
0074+  0ED1 8B 01       	or al, 1	; clear ZF
0075+  0ED3 E8          	pop al
0076+  0ED4 09          	ret
0077+  0ED5             isalpha_true:
0078+  0ED5 87 00       	and al, 0	; set ZF
0079+  0ED7 E8          	pop al
0080+  0ED8 09          	ret
0081+  0ED9             
0082+  0ED9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  0ED9             ;; IS PATH-ALPHA
0084+  0ED9             ;; sets ZF according with result
0085+  0ED9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  0ED9             ispath:
0087+  0ED9 DB          	push al
0088+  0EDA 07 9F 0E    	call isdigit
0089+  0EDD C6 07 0F    	je ispath_true
0090+  0EE0 B9 5F       	cmp al, '_'
0091+  0EE2 C6 07 0F    	je ispath_true
0092+  0EE5 B9 2F       	cmp al, '/'
0093+  0EE7 C6 07 0F    	je ispath_true
0094+  0EEA B9 2E       	cmp al, '.'
0095+  0EEC C6 07 0F    	je ispath_true
0096+  0EEF B9 41       	cmp al, 'A'
0097+  0EF1 C8 03 0F    	jlu ispath_false
0098+  0EF4 B9 7A       	cmp al, 'z'
0099+  0EF6 D1 03 0F    	jgu ispath_false
0100+  0EF9 B9 5A       	cmp al, 'Z'
0101+  0EFB D0 07 0F    	jleu ispath_true
0102+  0EFE B9 61       	cmp al, 'a'
0103+  0F00 C9 07 0F    	jgeu ispath_true
0104+  0F03             ispath_false:
0105+  0F03 8B 01       	or al, 1	; clear ZF
0106+  0F05 E8          	pop al
0107+  0F06 09          	ret
0108+  0F07             ispath_true:
0109+  0F07 87 00       	and al, 0	; set ZF
0110+  0F09 E8          	pop al
0111+  0F0A 09          	ret
0112+  0F0B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  0F0B             ;; IS SPACE
0114+  0F0B             ;; sets ZF according with result
0115+  0F0B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  0F0B             isspace:
0117+  0F0B B9 20       	cmp al, $20		; ' '
0118+  0F0D C6 21 0F    	je isspace_exit
0119+  0F10 B9 09       	cmp al, $09		; '\t'
0120+  0F12 C6 21 0F    	je isspace_exit
0121+  0F15 B9 0A       	cmp al, $0A		; '\n'
0122+  0F17 C6 21 0F    	je isspace_exit
0123+  0F1A B9 0D       	cmp al, $0D		; '\r'
0124+  0F1C C6 21 0F    	je isspace_exit
0125+  0F1F B9 0B       	cmp al, $0B		; '\v'
0126+  0F21             isspace_exit:
0127+  0F21 09          	ret	
0128+  0F22             
0129+  0F22             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0F22             ; TO LOWER
0131+  0F22             ; input in AL
0132+  0F22             ; output in AL
0133+  0F22             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  0F22             to_lower:
0135+  0F22 B9 5A       	cmp al, 'Z'
0136+  0F24 D1 29 0F    	jgu to_lower_ret
0137+  0F27 6A 20       	add al, $20				; convert to lower case
0138+  0F29             to_lower_ret:
0139+  0F29 09          	ret
0140+  0F2A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  0F2A             ; TO UPPER
0142+  0F2A             ; input in AL
0143+  0F2A             ; output in AL
0144+  0F2A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  0F2A             to_upper:
0146+  0F2A B9 61       	cmp al, 'a'
0147+  0F2C C8 31 0F    	jlu to_upper_ret
0148+  0F2F 6F 20       	sub al, $20			; convert to upper case
0149+  0F31             to_upper_ret:
0150+  0F31 09          	ret
0151+  0F32             
0488   0F32             .include "token.asm"
0001+  0F32             TOKTYP_IDENTIFIER	.equ 0
0002+  0F32             TOKTYP_KEYWORD		.equ 1
0003+  0F32             TOKTYP_DELIMITER	.equ 2
0004+  0F32             TOKTYP_STRING		.equ 3
0005+  0F32             TOKTYP_CHAR			.equ 4
0006+  0F32             TOKTYP_NUMERIC		.equ 5
0007+  0F32             TOKTYP_END			.equ 6
0008+  0F32             
0009+  0F32             TOK_NULL			.equ 0
0010+  0F32             TOK_FSLASH			.equ 1
0011+  0F32             TOK_TIMES 			.equ 2
0012+  0F32             TOK_PLUS 			.equ 3
0013+  0F32             TOK_MINUS 			.equ 4
0014+  0F32             TOK_DOT				.equ 5
0015+  0F32             TOK_SEMI			.equ 6
0016+  0F32             TOK_ANGLE			.equ 7
0017+  0F32             TOK_TILDE			.equ 8
0018+  0F32             TOK_EQUAL			.equ 9
0019+  0F32             TOK_COLON			.equ 10
0020+  0F32             TOK_COMMA			.equ 11
0021+  0F32             
0022+  0F32             TOK_END				.equ 20
0023+  0F32             
0024+  0F32             
0025+  0F32             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  0F32             ;; read a full command argment from shell input buffer
0027+  0F32             ;; argument is written into tokstr
0028+  0F32             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  0F32             get_arg:
0030+  0F32 D7          	push a
0031+  0F33 E2          	push si
0032+  0F34 E3          	push di
0033+  0F35 19 00       	mov al, 0
0034+  0F37 3D 60 11    	mov [tokstr], al			; nullify tokstr string
0035+  0F3A 14 5C 11    	mov a, [prog]
0036+  0F3D 4D          	mov si, a
0037+  0F3E FD 4F 60 11 	mov di, tokstr
0038+  0F42             get_arg_skip_spaces:
0039+  0F42 F6          	lodsb
0040+  0F43 07 0B 0F    	call isspace
0041+  0F46 C6 42 0F    	je get_arg_skip_spaces
0042+  0F49             get_arg_L0:
0043+  0F49 B9 3B       	cmp al, $3B				; check if is ';'
0044+  0F4B C6 58 0F    	je get_arg_end
0045+  0F4E B9 00       	cmp al, 0
0046+  0F50 C6 58 0F    	je get_arg_end			; check if end of input
0047+  0F53 F7          	stosb
0048+  0F54 F6          	lodsb
0049+  0F55 0A 49 0F    	jmp get_arg_L0
0050+  0F58             get_arg_end:
0051+  0F58 19 00       	mov al, 0
0052+  0F5A F7          	stosb
0053+  0F5B D5 01 00    	sub si, 1
0054+  0F5E 4E          	mov a, si
0055+  0F5F 42 5C 11    	mov [prog], a		; update pointer
0056+  0F62 F0          	pop di
0057+  0F63 EF          	pop si
0058+  0F64 E4          	pop a
0059+  0F65 09          	ret
0060+  0F66             
0061+  0F66             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  0F66             ;; read a path formation from shell input buffer
0063+  0F66             ;; path is written into tokstr
0064+  0F66             ;; /usr/bin
0065+  0F66             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  0F66             get_path:
0067+  0F66 D7          	push a
0068+  0F67 E2          	push si
0069+  0F68 E3          	push di
0070+  0F69 19 00       	mov al, 0
0071+  0F6B 3D 60 11    	mov [tokstr], al			; nullify tokstr string
0072+  0F6E 14 5C 11    	mov a, [prog]
0073+  0F71 4D          	mov si, a
0074+  0F72 FD 4F 60 11 	mov di, tokstr
0075+  0F76             get_path_skip_spaces:
0076+  0F76 F6          	lodsb
0077+  0F77 07 0B 0F    	call isspace
0078+  0F7A C6 76 0F    	je get_path_skip_spaces
0079+  0F7D             get_path_is_pathchar:
0080+  0F7D F7          	stosb
0081+  0F7E F6          	lodsb
0082+  0F7F 07 95 0E    	call isalnum			;check if is alphanumeric
0083+  0F82 C6 7D 0F    	je get_path_is_pathchar
0084+  0F85 B9 2F       	cmp al, '/'				; check if is '/'
0085+  0F87 C6 7D 0F    	je get_path_is_pathchar
0086+  0F8A 19 00       	mov al, 0
0087+  0F8C F7          	stosb
0088+  0F8D D5 01 00    	sub si, 1
0089+  0F90 4E          	mov a, si
0090+  0F91 42 5C 11    	mov [prog], a		; update pointer
0091+  0F94             get_path_end:
0092+  0F94 F0          	pop di
0093+  0F95 EF          	pop si
0094+  0F96 E4          	pop a
0095+  0F97 09          	ret
0096+  0F98             
0097+  0F98             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  0F98             ;; read a line
0099+  0F98             ;; line is written into tokstr
0100+  0F98             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  0F98             get_line:
0102+  0F98 D7          	push a
0103+  0F99 E2          	push si
0104+  0F9A E3          	push di
0105+  0F9B 19 00       	mov al, 0
0106+  0F9D 3D 60 11    	mov [tokstr], al			; nullify tokstr string
0107+  0FA0 14 5C 11    	mov a, [prog]
0108+  0FA3 4D          	mov si, a
0109+  0FA4 FD 4F 60 11 	mov di, tokstr
0110+  0FA8             get_line_L0:
0111+  0FA8 F6          	lodsb
0112+  0FA9 B9 0A       	cmp al, $0A		; check for new line
0113+  0FAB C6 B2 0F    	je get_line_exit
0114+  0FAE F7          	stosb
0115+  0FAF 0A A8 0F    	jmp get_line_L0
0116+  0FB2             get_line_exit:
0117+  0FB2 19 00       	mov al, 0
0118+  0FB4 F7          	stosb
0119+  0FB5 4E          	mov a, si
0120+  0FB6 42 5C 11    	mov [prog], a		; update pointer
0121+  0FB9 F0          	pop di
0122+  0FBA EF          	pop si
0123+  0FBB E4          	pop a
0124+  0FBC 09          	ret
0125+  0FBD             
0126+  0FBD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  0FBD             ;; token parser
0128+  0FBD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  0FBD             get_token:
0130+  0FBD D7          	push a
0131+  0FBE DA          	push d
0132+  0FBF E2          	push si
0133+  0FC0 E3          	push di
0134+  0FC1 19 00       	mov al, 0
0135+  0FC3 3D 60 11    	mov [tokstr], al			; nullify tokstr string
0136+  0FC6 19 00       	mov al, TOK_NULL
0137+  0FC8 3D 5F 11    	mov [tok], al				; nullify token
0138+  0FCB 14 5C 11    	mov a, [prog]
0139+  0FCE 4D          	mov si, a
0140+  0FCF FD 4F 60 11 	mov di, tokstr
0141+  0FD3             get_tok_skip_spaces:
0142+  0FD3 F6          	lodsb
0143+  0FD4 07 0B 0F    	call isspace
0144+  0FD7 C6 D3 0F    	je get_tok_skip_spaces
0145+  0FDA B9 00       	cmp al, 0			; check for end of input (NULL)
0146+  0FDC C6 C1 10    	je get_token_end
0147+  0FDF B9 23       	cmp al, '#'			; comments!
0148+  0FE1 C6 EF 10    	je get_tok_comment
0149+  0FE4 07 95 0E    	call isalnum
0150+  0FE7 C6 CE 10    	jz is_alphanumeric
0151+  0FEA             ; other token types
0152+  0FEA             get_token_slash:
0153+  0FEA B9 2F       	cmp al, '/'				; check if '/'
0154+  0FEC C7 04 10    	jne get_token_minus
0155+  0FEF F7          	stosb					; store '/' into token string
0156+  0FF0 19 00       	mov al, 0
0157+  0FF2 F7          	stosb					; terminate token string
0158+  0FF3 19 01       	mov al, TOK_FSLASH
0159+  0FF5 3D 5F 11    	mov [tok], al			
0160+  0FF8 19 02       	mov al, TOKTYP_DELIMITER
0161+  0FFA 3D 5E 11    	mov [toktyp], al
0162+  0FFD 4E          	mov a, si
0163+  0FFE 42 5C 11    	mov [prog], a		; update pointer
0164+  1001 0A EA 10    	jmp get_token_return
0165+  1004             get_token_minus:
0166+  1004 B9 2D       	cmp al, '-'				; check if '-'
0167+  1006 C7 1E 10    	jne get_token_comma
0168+  1009 F7          	stosb					; store '-' into token string
0169+  100A 19 00       	mov al, 0
0170+  100C F7          	stosb					; terminate token string
0171+  100D 19 04       	mov al, TOK_MINUS
0172+  100F 3D 5F 11    	mov [tok], al			
0173+  1012 19 02       	mov al, TOKTYP_DELIMITER
0174+  1014 3D 5E 11    	mov [toktyp], al
0175+  1017 4E          	mov a, si
0176+  1018 42 5C 11    	mov [prog], a		; update pointer
0177+  101B 0A EA 10    	jmp get_token_return
0178+  101E             get_token_comma:
0179+  101E B9 2C       	cmp al, ','				; check if ','
0180+  1020 C7 38 10    	jne get_token_semi
0181+  1023 F7          	stosb					; store ',' into token string
0182+  1024 19 00       	mov al, 0
0183+  1026 F7          	stosb					; terminate token string
0184+  1027 19 0B       	mov al, TOK_COMMA
0185+  1029 3D 5F 11    	mov [tok], al			
0186+  102C 19 02       	mov al, TOKTYP_DELIMITER
0187+  102E 3D 5E 11    	mov [toktyp], al
0188+  1031 4E          	mov a, si
0189+  1032 42 5C 11    	mov [prog], a		; update pointer
0190+  1035 0A EA 10    	jmp get_token_return
0191+  1038             get_token_semi:
0192+  1038 B9 3B       	cmp al, $3B				; check if ';'
0193+  103A C7 52 10    	jne get_token_colon
0194+  103D F7          	stosb					; store ';' into token string
0195+  103E 19 00       	mov al, 0
0196+  1040 F7          	stosb					; terminate token string
0197+  1041 19 06       	mov al, TOK_SEMI
0198+  1043 3D 5F 11    	mov [tok], al			
0199+  1046 19 02       	mov al, TOKTYP_DELIMITER
0200+  1048 3D 5E 11    	mov [toktyp], al
0201+  104B 4E          	mov a, si
0202+  104C 42 5C 11    	mov [prog], a		; update pointer
0203+  104F 0A EA 10    	jmp get_token_return
0204+  1052             get_token_colon:
0205+  1052 B9 3A       	cmp al, $3A				; check if ':'
0206+  1054 C7 6C 10    	jne get_token_angle
0207+  1057 F7          	stosb					; store ':' into token string
0208+  1058 19 00       	mov al, 0
0209+  105A F7          	stosb					; terminate token string
0210+  105B 19 0A       	mov al, TOK_COLON
0211+  105D 3D 5F 11    	mov [tok], al			
0212+  1060 19 02       	mov al, TOKTYP_DELIMITER
0213+  1062 3D 5E 11    	mov [toktyp], al
0214+  1065 4E          	mov a, si
0215+  1066 42 5C 11    	mov [prog], a		; update pointer
0216+  1069 0A EA 10    	jmp get_token_return
0217+  106C             get_token_angle:
0218+  106C B9 3E       	cmp al, $3E				; check if '>'
0219+  106E C7 86 10    	jne get_token_tilde
0220+  1071 F7          	stosb					; store '>' into token string
0221+  1072 19 00       	mov al, 0
0222+  1074 F7          	stosb					; terminate token string
0223+  1075 19 07       	mov al, TOK_ANGLE
0224+  1077 3D 5F 11    	mov [tok], al			
0225+  107A 19 02       	mov al, TOKTYP_DELIMITER
0226+  107C 3D 5E 11    	mov [toktyp], al
0227+  107F 4E          	mov a, si
0228+  1080 42 5C 11    	mov [prog], a		; update pointer
0229+  1083 0A EA 10    	jmp get_token_return
0230+  1086             get_token_tilde:
0231+  1086 B9 7E       	cmp al, '~'				; check if '~'
0232+  1088 C7 A0 10    	jne get_token_equal
0233+  108B F7          	stosb					; store '~' into token string
0234+  108C 19 00       	mov al, 0
0235+  108E F7          	stosb					; terminate token string
0236+  108F 19 08       	mov al, TOK_TILDE
0237+  1091 3D 5F 11    	mov [tok], al			
0238+  1094 19 02       	mov al, TOKTYP_DELIMITER
0239+  1096 3D 5E 11    	mov [toktyp], al
0240+  1099 4E          	mov a, si
0241+  109A 42 5C 11    	mov [prog], a		; update pointer
0242+  109D 0A EA 10    	jmp get_token_return
0243+  10A0             get_token_equal:
0244+  10A0 B9 3D       	cmp al, '='				; check if '='
0245+  10A2 C7 BA 10    	jne get_token_skip
0246+  10A5 F7          	stosb					; store '=' into token string
0247+  10A6 19 00       	mov al, 0
0248+  10A8 F7          	stosb					; terminate token string
0249+  10A9 19 09       	mov al, TOK_EQUAL
0250+  10AB 3D 5F 11    	mov [tok], al			
0251+  10AE 19 02       	mov al, TOKTYP_DELIMITER
0252+  10B0 3D 5E 11    	mov [toktyp], al
0253+  10B3 4E          	mov a, si
0254+  10B4 42 5C 11    	mov [prog], a		; update pointer
0255+  10B7 0A EA 10    	jmp get_token_return
0256+  10BA             get_token_skip:
0257+  10BA 4E          	mov a, si
0258+  10BB 42 5C 11    	mov [prog], a		; update pointer
0259+  10BE 0A EA 10    	jmp get_token_return
0260+  10C1             get_token_end:				; end of file token
0261+  10C1 19 14       	mov al, TOK_END
0262+  10C3 3D 5F 11    	mov [tok], al
0263+  10C6 19 06       	mov al, TOKTYP_END
0264+  10C8 3D 5E 11    	mov [toktyp], al
0265+  10CB 0A EA 10    	jmp get_token_return
0266+  10CE             is_alphanumeric:
0267+  10CE F7          	stosb
0268+  10CF F6          	lodsb
0269+  10D0 07 95 0E    	call isalnum			;check if is alphanumeric
0270+  10D3 C6 CE 10    	jz is_alphanumeric
0271+  10D6 B9 2E       	cmp al, $2E				; check if is '.'
0272+  10D8 C6 CE 10    	je is_alphanumeric
0273+  10DB 19 00       	mov al, 0
0274+  10DD F7          	stosb
0275+  10DE 19 00       	mov al, TOKTYP_IDENTIFIER
0276+  10E0 3D 5E 11    	mov [toktyp], al
0277+  10E3 D5 01 00    	sub si, 1
0278+  10E6 4E          	mov a, si
0279+  10E7 42 5C 11    	mov [prog], a		; update pointer
0280+  10EA             get_token_return:
0281+  10EA F0          	pop di
0282+  10EB EF          	pop si
0283+  10EC E7          	pop d
0284+  10ED E4          	pop a
0285+  10EE 09          	ret
0286+  10EF             get_tok_comment:
0287+  10EF F6          	lodsb
0288+  10F0 B9 0A       	cmp al, $0A			; new line
0289+  10F2 C7 EF 10    	jne get_tok_comment
0290+  10F5 0A D3 0F    	jmp get_tok_skip_spaces
0291+  10F8             
0292+  10F8             
0293+  10F8             get_number:
0294+  10F8 D7          	push a
0295+  10F9 DA          	push d
0296+  10FA E2          	push si
0297+  10FB E3          	push di
0298+  10FC 19 00       	mov al, 0
0299+  10FE 3D 60 11    	mov [tokstr], al			; nullify tokstr string
0300+  1101 19 00       	mov al, TOK_NULL
0301+  1103 3D 5F 11    	mov [tok], al				; nullify token
0302+  1106 14 5C 11    	mov a, [prog]
0303+  1109 4D          	mov si, a
0304+  110A FD 4F 60 11 	mov di, tokstr
0305+  110E             get_number_skip_spaces:
0306+  110E F6          	lodsb
0307+  110F 07 0B 0F    	call isspace
0308+  1112 C6 0E 11    	je get_number_skip_spaces
0309+  1115 B9 00       	cmp al, 0			; check for end of input (NULL)
0310+  1117 C7 27 11    	jne get_number_L0
0311+  111A 19 14       	mov al, TOK_END
0312+  111C 3D 5F 11    	mov [tok], al
0313+  111F 19 06       	mov al, TOKTYP_END
0314+  1121 3D 5E 11    	mov [toktyp], al
0315+  1124 0A 3E 11    	jmp get_number_return
0316+  1127             get_number_L0:
0317+  1127 F7          	stosb
0318+  1128 F6          	lodsb
0319+  1129 07 9F 0E    	call isdigit			;check if is numeric
0320+  112C C6 27 11    	jz get_number_L0
0321+  112F 19 00       	mov al, 0
0322+  1131 F7          	stosb
0323+  1132 19 05       	mov al, TOKTYP_NUMERIC
0324+  1134 3D 5E 11    	mov [toktyp], al
0325+  1137 D5 01 00    	sub si, 1
0326+  113A 4E          	mov a, si
0327+  113B 42 5C 11    	mov [prog], a		; update pointer
0328+  113E             get_number_return:
0329+  113E F0          	pop di
0330+  113F EF          	pop si
0331+  1140 E7          	pop d
0332+  1141 E4          	pop a
0333+  1142 09          	ret
0334+  1143             
0335+  1143             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  1143             ;; PUT BACK TOKEN
0337+  1143             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
0338+  1143             putback:
0339+  1143 D7          	push a
0340+  1144 E2          	push si
0341+  1145 FD 4D 60 11 	mov si, tokstr	
0342+  1149             putback_loop:
0343+  1149 F6          	lodsb
0344+  114A B9 00       	cmp al, 0
0345+  114C C6 59 11    	je putback_end
0346+  114F 14 5C 11    	mov a, [prog]
0347+  1152 7D          	dec a
0348+  1153 42 5C 11    	mov [prog], a			; update pointer
0349+  1156 0A 49 11    	jmp putback_loop
0350+  1159             putback_end:
0351+  1159 EF          	pop si
0352+  115A E4          	pop a
0353+  115B 09          	ret
0354+  115C             
0355+  115C             
0356+  115C             
0357+  115C             
0358+  115C 00 00       prog:		.dw 0			; pointer to current position in buffer
0359+  115E             
0360+  115E 00          toktyp: 	.db 0			; token type symbol
0361+  115F 00          tok:		.db 0			; current token symbol
0362+  1160 00 00 00 00 tokstr:		.fill 256, 0	; token as a string
0362+  1164 00 00 00 00 
0362+  1168 00 00 00 00 
0362+  116C 00 00 00 00 
0362+  1170 00 00 00 00 
0362+  1174 00 00 00 00 
0362+  1178 00 00 00 00 
0362+  117C 00 00 00 00 
0362+  1180 00 00 00 00 
0362+  1184 00 00 00 00 
0362+  1188 00 00 00 00 
0362+  118C 00 00 00 00 
0362+  1190 00 00 00 00 
0362+  1194 00 00 00 00 
0362+  1198 00 00 00 00 
0362+  119C 00 00 00 00 
0362+  11A0 00 00 00 00 
0362+  11A4 00 00 00 00 
0362+  11A8 00 00 00 00 
0362+  11AC 00 00 00 00 
0362+  11B0 00 00 00 00 
0362+  11B4 00 00 00 00 
0362+  11B8 00 00 00 00 
0362+  11BC 00 00 00 00 
0362+  11C0 00 00 00 00 
0362+  11C4 00 00 00 00 
0362+  11C8 00 00 00 00 
0362+  11CC 00 00 00 00 
0362+  11D0 00 00 00 00 
0362+  11D4 00 00 00 00 
0362+  11D8 00 00 00 00 
0362+  11DC 00 00 00 00 
0362+  11E0 00 00 00 00 
0362+  11E4 00 00 00 00 
0362+  11E8 00 00 00 00 
0362+  11EC 00 00 00 00 
0362+  11F0 00 00 00 00 
0362+  11F4 00 00 00 00 
0362+  11F8 00 00 00 00 
0362+  11FC 00 00 00 00 
0362+  1200 00 00 00 00 
0362+  1204 00 00 00 00 
0362+  1208 00 00 00 00 
0362+  120C 00 00 00 00 
0362+  1210 00 00 00 00 
0362+  1214 00 00 00 00 
0362+  1218 00 00 00 00 
0362+  121C 00 00 00 00 
0362+  1220 00 00 00 00 
0362+  1224 00 00 00 00 
0362+  1228 00 00 00 00 
0362+  122C 00 00 00 00 
0362+  1230 00 00 00 00 
0362+  1234 00 00 00 00 
0362+  1238 00 00 00 00 
0362+  123C 00 00 00 00 
0362+  1240 00 00 00 00 
0362+  1244 00 00 00 00 
0362+  1248 00 00 00 00 
0362+  124C 00 00 00 00 
0362+  1250 00 00 00 00 
0362+  1254 00 00 00 00 
0362+  1258 00 00 00 00 
0362+  125C 00 00 00 00 
0489   1260             
0490   1260 00 00 00 00 temp_data1:        .fill 256, 0
0490   1264 00 00 00 00 
0490   1268 00 00 00 00 
0490   126C 00 00 00 00 
0490   1270 00 00 00 00 
0490   1274 00 00 00 00 
0490   1278 00 00 00 00 
0490   127C 00 00 00 00 
0490   1280 00 00 00 00 
0490   1284 00 00 00 00 
0490   1288 00 00 00 00 
0490   128C 00 00 00 00 
0490   1290 00 00 00 00 
0490   1294 00 00 00 00 
0490   1298 00 00 00 00 
0490   129C 00 00 00 00 
0490   12A0 00 00 00 00 
0490   12A4 00 00 00 00 
0490   12A8 00 00 00 00 
0490   12AC 00 00 00 00 
0490   12B0 00 00 00 00 
0490   12B4 00 00 00 00 
0490   12B8 00 00 00 00 
0490   12BC 00 00 00 00 
0490   12C0 00 00 00 00 
0490   12C4 00 00 00 00 
0490   12C8 00 00 00 00 
0490   12CC 00 00 00 00 
0490   12D0 00 00 00 00 
0490   12D4 00 00 00 00 
0490   12D8 00 00 00 00 
0490   12DC 00 00 00 00 
0490   12E0 00 00 00 00 
0490   12E4 00 00 00 00 
0490   12E8 00 00 00 00 
0490   12EC 00 00 00 00 
0490   12F0 00 00 00 00 
0490   12F4 00 00 00 00 
0490   12F8 00 00 00 00 
0490   12FC 00 00 00 00 
0490   1300 00 00 00 00 
0490   1304 00 00 00 00 
0490   1308 00 00 00 00 
0490   130C 00 00 00 00 
0490   1310 00 00 00 00 
0490   1314 00 00 00 00 
0490   1318 00 00 00 00 
0490   131C 00 00 00 00 
0490   1320 00 00 00 00 
0490   1324 00 00 00 00 
0490   1328 00 00 00 00 
0490   132C 00 00 00 00 
0490   1330 00 00 00 00 
0490   1334 00 00 00 00 
0490   1338 00 00 00 00 
0490   133C 00 00 00 00 
0490   1340 00 00 00 00 
0490   1344 00 00 00 00 
0490   1348 00 00 00 00 
0490   134C 00 00 00 00 
0490   1350 00 00 00 00 
0490   1354 00 00 00 00 
0490   1358 00 00 00 00 
0490   135C 00 00 00 00 
0491   1360 00 00 00 00 temp_data:        .fill 512, 0
0491   1364 00 00 00 00 
0491   1368 00 00 00 00 
0491   136C 00 00 00 00 
0491   1370 00 00 00 00 
0491   1374 00 00 00 00 
0491   1378 00 00 00 00 
0491   137C 00 00 00 00 
0491   1380 00 00 00 00 
0491   1384 00 00 00 00 
0491   1388 00 00 00 00 
0491   138C 00 00 00 00 
0491   1390 00 00 00 00 
0491   1394 00 00 00 00 
0491   1398 00 00 00 00 
0491   139C 00 00 00 00 
0491   13A0 00 00 00 00 
0491   13A4 00 00 00 00 
0491   13A8 00 00 00 00 
0491   13AC 00 00 00 00 
0491   13B0 00 00 00 00 
0491   13B4 00 00 00 00 
0491   13B8 00 00 00 00 
0491   13BC 00 00 00 00 
0491   13C0 00 00 00 00 
0491   13C4 00 00 00 00 
0491   13C8 00 00 00 00 
0491   13CC 00 00 00 00 
0491   13D0 00 00 00 00 
0491   13D4 00 00 00 00 
0491   13D8 00 00 00 00 
0491   13DC 00 00 00 00 
0491   13E0 00 00 00 00 
0491   13E4 00 00 00 00 
0491   13E8 00 00 00 00 
0491   13EC 00 00 00 00 
0491   13F0 00 00 00 00 
0491   13F4 00 00 00 00 
0491   13F8 00 00 00 00 
0491   13FC 00 00 00 00 
0491   1400 00 00 00 00 
0491   1404 00 00 00 00 
0491   1408 00 00 00 00 
0491   140C 00 00 00 00 
0491   1410 00 00 00 00 
0491   1414 00 00 00 00 
0491   1418 00 00 00 00 
0491   141C 00 00 00 00 
0491   1420 00 00 00 00 
0491   1424 00 00 00 00 
0491   1428 00 00 00 00 
0491   142C 00 00 00 00 
0491   1430 00 00 00 00 
0491   1434 00 00 00 00 
0491   1438 00 00 00 00 
0491   143C 00 00 00 00 
0491   1440 00 00 00 00 
0491   1444 00 00 00 00 
0491   1448 00 00 00 00 
0491   144C 00 00 00 00 
0491   1450 00 00 00 00 
0491   1454 00 00 00 00 
0491   1458 00 00 00 00 
0491   145C 00 00 00 00 
0491   1460 00 00 00 00 
0491   1464 00 00 00 00 
0491   1468 00 00 00 00 
0491   146C 00 00 00 00 
0491   1470 00 00 00 00 
0491   1474 00 00 00 00 
0491   1478 00 00 00 00 
0491   147C 00 00 00 00 
0491   1480 00 00 00 00 
0491   1484 00 00 00 00 
0491   1488 00 00 00 00 
0491   148C 00 00 00 00 
0491   1490 00 00 00 00 
0491   1494 00 00 00 00 
0491   1498 00 00 00 00 
0491   149C 00 00 00 00 
0491   14A0 00 00 00 00 
0491   14A4 00 00 00 00 
0491   14A8 00 00 00 00 
0491   14AC 00 00 00 00 
0491   14B0 00 00 00 00 
0491   14B4 00 00 00 00 
0491   14B8 00 00 00 00 
0491   14BC 00 00 00 00 
0491   14C0 00 00 00 00 
0491   14C4 00 00 00 00 
0491   14C8 00 00 00 00 
0491   14CC 00 00 00 00 
0491   14D0 00 00 00 00 
0491   14D4 00 00 00 00 
0491   14D8 00 00 00 00 
0491   14DC 00 00 00 00 
0491   14E0 00 00 00 00 
0491   14E4 00 00 00 00 
0491   14E8 00 00 00 00 
0491   14EC 00 00 00 00 
0491   14F0 00 00 00 00 
0491   14F4 00 00 00 00 
0491   14F8 00 00 00 00 
0491   14FC 00 00 00 00 
0491   1500 00 00 00 00 
0491   1504 00 00 00 00 
0491   1508 00 00 00 00 
0491   150C 00 00 00 00 
0491   1510 00 00 00 00 
0491   1514 00 00 00 00 
0491   1518 00 00 00 00 
0491   151C 00 00 00 00 
0491   1520 00 00 00 00 
0491   1524 00 00 00 00 
0491   1528 00 00 00 00 
0491   152C 00 00 00 00 
0491   1530 00 00 00 00 
0491   1534 00 00 00 00 
0491   1538 00 00 00 00 
0491   153C 00 00 00 00 
0491   1540 00 00 00 00 
0491   1544 00 00 00 00 
0491   1548 00 00 00 00 
0491   154C 00 00 00 00 
0491   1550 00 00 00 00 
0491   1554 00 00 00 00 
0491   1558 00 00 00 00 
0491   155C 00 00 00 00 
0492   1560             shell_transient_area:  ; shell transient data area
0493   1560             
0494   1560             .end
tasm: Number of errors = 0
