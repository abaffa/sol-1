0001   0000             .include "kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0002   0000             
0003   0400             .org PROC_TEXT_ORG			; origin at 1024
0004   0400             
0005   0400             cmd_echo:
0006   0400 10 00 00    	mov a, 0
0007   0403 42 3E 06    	mov [prog], a			; move tokennizer pointer to the beginning of the arguments area (address 0)
0008   0406 07 14 04    	call get_arg			; read argument line
0009   0409 3B 42 06    	mov d, tokstr
0010   040C 07 86 09    	call puts
0011   040F 07 33 09    	call printnl
0012   0412 05 0B       	syscall sys_terminate_proc
0013   0414             
0014   0414             
0015   0414             .include "token.asm"
0001+  0414             TOKTYP_IDENTIFIER	.equ 0
0002+  0414             TOKTYP_KEYWORD		.equ 1
0003+  0414             TOKTYP_DELIMITER	.equ 2
0004+  0414             TOKTYP_STRING		.equ 3
0005+  0414             TOKTYP_CHAR			.equ 4
0006+  0414             TOKTYP_NUMERIC		.equ 5
0007+  0414             TOKTYP_END			.equ 6
0008+  0414             
0009+  0414             TOK_NULL			.equ 0
0010+  0414             TOK_FSLASH			.equ 1
0011+  0414             TOK_TIMES 			.equ 2
0012+  0414             TOK_PLUS 			.equ 3
0013+  0414             TOK_MINUS 			.equ 4
0014+  0414             TOK_DOT				.equ 5
0015+  0414             TOK_SEMI			.equ 6
0016+  0414             TOK_ANGLE			.equ 7
0017+  0414             TOK_TILDE			.equ 8
0018+  0414             TOK_EQUAL			.equ 9
0019+  0414             TOK_COLON			.equ 10
0020+  0414             TOK_COMMA			.equ 11
0021+  0414             
0022+  0414             TOK_END				.equ 20
0023+  0414             
0024+  0414             
0025+  0414             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  0414             ;; read a full command argment from shell input buffer
0027+  0414             ;; argument is written into tokstr
0028+  0414             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  0414             get_arg:
0030+  0414 D7          	push a
0031+  0415 E2          	push si
0032+  0416 E3          	push di
0033+  0417 19 00       	mov al, 0
0034+  0419 3D 42 06    	mov [tokstr], al			; nullify tokstr string
0035+  041C 14 3E 06    	mov a, [prog]
0036+  041F 4D          	mov si, a
0037+  0420 FD 4F 42 06 	mov di, tokstr
0038+  0424             get_arg_skip_spaces:
0039+  0424 F6          	lodsb
0040+  0425 07 34 0B    	call isspace
0041+  0428 C6 24 04    	je get_arg_skip_spaces
0042+  042B             get_arg_L0:
0043+  042B B9 3B       	cmp al, $3B				; check if is ';'
0044+  042D C6 3A 04    	je get_arg_end
0045+  0430 B9 00       	cmp al, 0
0046+  0432 C6 3A 04    	je get_arg_end			; check if end of input
0047+  0435 F7          	stosb
0048+  0436 F6          	lodsb
0049+  0437 0A 2B 04    	jmp get_arg_L0
0050+  043A             get_arg_end:
0051+  043A 19 00       	mov al, 0
0052+  043C F7          	stosb
0053+  043D D5 01 00    	sub si, 1
0054+  0440 4E          	mov a, si
0055+  0441 42 3E 06    	mov [prog], a		; update pointer
0056+  0444 F0          	pop di
0057+  0445 EF          	pop si
0058+  0446 E4          	pop a
0059+  0447 09          	ret
0060+  0448             
0061+  0448             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  0448             ;; read a path formation from shell input buffer
0063+  0448             ;; path is written into tokstr
0064+  0448             ;; /usr/bin
0065+  0448             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  0448             get_path:
0067+  0448 D7          	push a
0068+  0449 E2          	push si
0069+  044A E3          	push di
0070+  044B 19 00       	mov al, 0
0071+  044D 3D 42 06    	mov [tokstr], al			; nullify tokstr string
0072+  0450 14 3E 06    	mov a, [prog]
0073+  0453 4D          	mov si, a
0074+  0454 FD 4F 42 06 	mov di, tokstr
0075+  0458             get_path_skip_spaces:
0076+  0458 F6          	lodsb
0077+  0459 07 34 0B    	call isspace
0078+  045C C6 58 04    	je get_path_skip_spaces
0079+  045F             get_path_is_pathchar:
0080+  045F F7          	stosb
0081+  0460 F6          	lodsb
0082+  0461 07 BE 0A    	call isalnum			;check if is alphanumeric
0083+  0464 C6 5F 04    	je get_path_is_pathchar
0084+  0467 B9 2F       	cmp al, '/'				; check if is '/'
0085+  0469 C6 5F 04    	je get_path_is_pathchar
0086+  046C 19 00       	mov al, 0
0087+  046E F7          	stosb
0088+  046F D5 01 00    	sub si, 1
0089+  0472 4E          	mov a, si
0090+  0473 42 3E 06    	mov [prog], a		; update pointer
0091+  0476             get_path_end:
0092+  0476 F0          	pop di
0093+  0477 EF          	pop si
0094+  0478 E4          	pop a
0095+  0479 09          	ret
0096+  047A             
0097+  047A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  047A             ;; read a line
0099+  047A             ;; line is written into tokstr
0100+  047A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  047A             get_line:
0102+  047A D7          	push a
0103+  047B E2          	push si
0104+  047C E3          	push di
0105+  047D 19 00       	mov al, 0
0106+  047F 3D 42 06    	mov [tokstr], al			; nullify tokstr string
0107+  0482 14 3E 06    	mov a, [prog]
0108+  0485 4D          	mov si, a
0109+  0486 FD 4F 42 06 	mov di, tokstr
0110+  048A             get_line_L0:
0111+  048A F6          	lodsb
0112+  048B B9 0A       	cmp al, $0A		; check for new line
0113+  048D C6 94 04    	je get_line_exit
0114+  0490 F7          	stosb
0115+  0491 0A 8A 04    	jmp get_line_L0
0116+  0494             get_line_exit:
0117+  0494 19 00       	mov al, 0
0118+  0496 F7          	stosb
0119+  0497 4E          	mov a, si
0120+  0498 42 3E 06    	mov [prog], a		; update pointer
0121+  049B F0          	pop di
0122+  049C EF          	pop si
0123+  049D E4          	pop a
0124+  049E 09          	ret
0125+  049F             
0126+  049F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  049F             ;; token parser
0128+  049F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  049F             get_token:
0130+  049F D7          	push a
0131+  04A0 DA          	push d
0132+  04A1 E2          	push si
0133+  04A2 E3          	push di
0134+  04A3 19 00       	mov al, 0
0135+  04A5 3D 42 06    	mov [tokstr], al			; nullify tokstr string
0136+  04A8 19 00       	mov al, TOK_NULL
0137+  04AA 3D 41 06    	mov [tok], al				; nullify token
0138+  04AD 14 3E 06    	mov a, [prog]
0139+  04B0 4D          	mov si, a
0140+  04B1 FD 4F 42 06 	mov di, tokstr
0141+  04B5             get_tok_skip_spaces:
0142+  04B5 F6          	lodsb
0143+  04B6 07 34 0B    	call isspace
0144+  04B9 C6 B5 04    	je get_tok_skip_spaces
0145+  04BC B9 00       	cmp al, 0			; check for end of input (NULL)
0146+  04BE C6 A3 05    	je get_token_end
0147+  04C1 B9 23       	cmp al, '#'			; comments!
0148+  04C3 C6 D1 05    	je get_tok_comment
0149+  04C6 07 BE 0A    	call isalnum
0150+  04C9 C6 B0 05    	jz is_alphanumeric
0151+  04CC             ; other token types
0152+  04CC             get_token_slash:
0153+  04CC B9 2F       	cmp al, '/'				; check if '/'
0154+  04CE C7 E6 04    	jne get_token_minus
0155+  04D1 F7          	stosb					; store '/' into token string
0156+  04D2 19 00       	mov al, 0
0157+  04D4 F7          	stosb					; terminate token string
0158+  04D5 19 01       	mov al, TOK_FSLASH
0159+  04D7 3D 41 06    	mov [tok], al			
0160+  04DA 19 02       	mov al, TOKTYP_DELIMITER
0161+  04DC 3D 40 06    	mov [toktyp], al
0162+  04DF 4E          	mov a, si
0163+  04E0 42 3E 06    	mov [prog], a		; update pointer
0164+  04E3 0A CC 05    	jmp get_token_return
0165+  04E6             get_token_minus:
0166+  04E6 B9 2D       	cmp al, '-'				; check if '-'
0167+  04E8 C7 00 05    	jne get_token_comma
0168+  04EB F7          	stosb					; store '-' into token string
0169+  04EC 19 00       	mov al, 0
0170+  04EE F7          	stosb					; terminate token string
0171+  04EF 19 04       	mov al, TOK_MINUS
0172+  04F1 3D 41 06    	mov [tok], al			
0173+  04F4 19 02       	mov al, TOKTYP_DELIMITER
0174+  04F6 3D 40 06    	mov [toktyp], al
0175+  04F9 4E          	mov a, si
0176+  04FA 42 3E 06    	mov [prog], a		; update pointer
0177+  04FD 0A CC 05    	jmp get_token_return
0178+  0500             get_token_comma:
0179+  0500 B9 2C       	cmp al, ','				; check if ','
0180+  0502 C7 1A 05    	jne get_token_semi
0181+  0505 F7          	stosb					; store ',' into token string
0182+  0506 19 00       	mov al, 0
0183+  0508 F7          	stosb					; terminate token string
0184+  0509 19 0B       	mov al, TOK_COMMA
0185+  050B 3D 41 06    	mov [tok], al			
0186+  050E 19 02       	mov al, TOKTYP_DELIMITER
0187+  0510 3D 40 06    	mov [toktyp], al
0188+  0513 4E          	mov a, si
0189+  0514 42 3E 06    	mov [prog], a		; update pointer
0190+  0517 0A CC 05    	jmp get_token_return
0191+  051A             get_token_semi:
0192+  051A B9 3B       	cmp al, $3B				; check if ';'
0193+  051C C7 34 05    	jne get_token_colon
0194+  051F F7          	stosb					; store ';' into token string
0195+  0520 19 00       	mov al, 0
0196+  0522 F7          	stosb					; terminate token string
0197+  0523 19 06       	mov al, TOK_SEMI
0198+  0525 3D 41 06    	mov [tok], al			
0199+  0528 19 02       	mov al, TOKTYP_DELIMITER
0200+  052A 3D 40 06    	mov [toktyp], al
0201+  052D 4E          	mov a, si
0202+  052E 42 3E 06    	mov [prog], a		; update pointer
0203+  0531 0A CC 05    	jmp get_token_return
0204+  0534             get_token_colon:
0205+  0534 B9 3A       	cmp al, $3A				; check if ':'
0206+  0536 C7 4E 05    	jne get_token_angle
0207+  0539 F7          	stosb					; store ':' into token string
0208+  053A 19 00       	mov al, 0
0209+  053C F7          	stosb					; terminate token string
0210+  053D 19 0A       	mov al, TOK_COLON
0211+  053F 3D 41 06    	mov [tok], al			
0212+  0542 19 02       	mov al, TOKTYP_DELIMITER
0213+  0544 3D 40 06    	mov [toktyp], al
0214+  0547 4E          	mov a, si
0215+  0548 42 3E 06    	mov [prog], a		; update pointer
0216+  054B 0A CC 05    	jmp get_token_return
0217+  054E             get_token_angle:
0218+  054E B9 3E       	cmp al, $3E				; check if '>'
0219+  0550 C7 68 05    	jne get_token_tilde
0220+  0553 F7          	stosb					; store '>' into token string
0221+  0554 19 00       	mov al, 0
0222+  0556 F7          	stosb					; terminate token string
0223+  0557 19 07       	mov al, TOK_ANGLE
0224+  0559 3D 41 06    	mov [tok], al			
0225+  055C 19 02       	mov al, TOKTYP_DELIMITER
0226+  055E 3D 40 06    	mov [toktyp], al
0227+  0561 4E          	mov a, si
0228+  0562 42 3E 06    	mov [prog], a		; update pointer
0229+  0565 0A CC 05    	jmp get_token_return
0230+  0568             get_token_tilde:
0231+  0568 B9 7E       	cmp al, '~'				; check if '~'
0232+  056A C7 82 05    	jne get_token_equal
0233+  056D F7          	stosb					; store '~' into token string
0234+  056E 19 00       	mov al, 0
0235+  0570 F7          	stosb					; terminate token string
0236+  0571 19 08       	mov al, TOK_TILDE
0237+  0573 3D 41 06    	mov [tok], al			
0238+  0576 19 02       	mov al, TOKTYP_DELIMITER
0239+  0578 3D 40 06    	mov [toktyp], al
0240+  057B 4E          	mov a, si
0241+  057C 42 3E 06    	mov [prog], a		; update pointer
0242+  057F 0A CC 05    	jmp get_token_return
0243+  0582             get_token_equal:
0244+  0582 B9 3D       	cmp al, '='				; check if '='
0245+  0584 C7 9C 05    	jne get_token_skip
0246+  0587 F7          	stosb					; store '=' into token string
0247+  0588 19 00       	mov al, 0
0248+  058A F7          	stosb					; terminate token string
0249+  058B 19 09       	mov al, TOK_EQUAL
0250+  058D 3D 41 06    	mov [tok], al			
0251+  0590 19 02       	mov al, TOKTYP_DELIMITER
0252+  0592 3D 40 06    	mov [toktyp], al
0253+  0595 4E          	mov a, si
0254+  0596 42 3E 06    	mov [prog], a		; update pointer
0255+  0599 0A CC 05    	jmp get_token_return
0256+  059C             get_token_skip:
0257+  059C 4E          	mov a, si
0258+  059D 42 3E 06    	mov [prog], a		; update pointer
0259+  05A0 0A CC 05    	jmp get_token_return
0260+  05A3             get_token_end:				; end of file token
0261+  05A3 19 14       	mov al, TOK_END
0262+  05A5 3D 41 06    	mov [tok], al
0263+  05A8 19 06       	mov al, TOKTYP_END
0264+  05AA 3D 40 06    	mov [toktyp], al
0265+  05AD 0A CC 05    	jmp get_token_return
0266+  05B0             is_alphanumeric:
0267+  05B0 F7          	stosb
0268+  05B1 F6          	lodsb
0269+  05B2 07 BE 0A    	call isalnum			;check if is alphanumeric
0270+  05B5 C6 B0 05    	jz is_alphanumeric
0271+  05B8 B9 2E       	cmp al, $2E				; check if is '.'
0272+  05BA C6 B0 05    	je is_alphanumeric
0273+  05BD 19 00       	mov al, 0
0274+  05BF F7          	stosb
0275+  05C0 19 00       	mov al, TOKTYP_IDENTIFIER
0276+  05C2 3D 40 06    	mov [toktyp], al
0277+  05C5 D5 01 00    	sub si, 1
0278+  05C8 4E          	mov a, si
0279+  05C9 42 3E 06    	mov [prog], a		; update pointer
0280+  05CC             get_token_return:
0281+  05CC F0          	pop di
0282+  05CD EF          	pop si
0283+  05CE E7          	pop d
0284+  05CF E4          	pop a
0285+  05D0 09          	ret
0286+  05D1             get_tok_comment:
0287+  05D1 F6          	lodsb
0288+  05D2 B9 0A       	cmp al, $0A			; new line
0289+  05D4 C7 D1 05    	jne get_tok_comment
0290+  05D7 0A B5 04    	jmp get_tok_skip_spaces
0291+  05DA             
0292+  05DA             
0293+  05DA             get_number:
0294+  05DA D7          	push a
0295+  05DB DA          	push d
0296+  05DC E2          	push si
0297+  05DD E3          	push di
0298+  05DE 19 00       	mov al, 0
0299+  05E0 3D 42 06    	mov [tokstr], al			; nullify tokstr string
0300+  05E3 19 00       	mov al, TOK_NULL
0301+  05E5 3D 41 06    	mov [tok], al				; nullify token
0302+  05E8 14 3E 06    	mov a, [prog]
0303+  05EB 4D          	mov si, a
0304+  05EC FD 4F 42 06 	mov di, tokstr
0305+  05F0             get_number_skip_spaces:
0306+  05F0 F6          	lodsb
0307+  05F1 07 34 0B    	call isspace
0308+  05F4 C6 F0 05    	je get_number_skip_spaces
0309+  05F7 B9 00       	cmp al, 0			; check for end of input (NULL)
0310+  05F9 C7 09 06    	jne get_number_L0
0311+  05FC 19 14       	mov al, TOK_END
0312+  05FE 3D 41 06    	mov [tok], al
0313+  0601 19 06       	mov al, TOKTYP_END
0314+  0603 3D 40 06    	mov [toktyp], al
0315+  0606 0A 20 06    	jmp get_number_return
0316+  0609             get_number_L0:
0317+  0609 F7          	stosb
0318+  060A F6          	lodsb
0319+  060B 07 C8 0A    	call isdigit			;check if is numeric
0320+  060E C6 09 06    	jz get_number_L0
0321+  0611 19 00       	mov al, 0
0322+  0613 F7          	stosb
0323+  0614 19 05       	mov al, TOKTYP_NUMERIC
0324+  0616 3D 40 06    	mov [toktyp], al
0325+  0619 D5 01 00    	sub si, 1
0326+  061C 4E          	mov a, si
0327+  061D 42 3E 06    	mov [prog], a		; update pointer
0328+  0620             get_number_return:
0329+  0620 F0          	pop di
0330+  0621 EF          	pop si
0331+  0622 E7          	pop d
0332+  0623 E4          	pop a
0333+  0624 09          	ret
0334+  0625             
0335+  0625             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  0625             ;; PUT BACK TOKEN
0337+  0625             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
0338+  0625             putback:
0339+  0625 D7          	push a
0340+  0626 E2          	push si
0341+  0627 FD 4D 42 06 	mov si, tokstr	
0342+  062B             putback_loop:
0343+  062B F6          	lodsb
0344+  062C B9 00       	cmp al, 0
0345+  062E C6 3B 06    	je putback_end
0346+  0631 14 3E 06    	mov a, [prog]
0347+  0634 7D          	dec a
0348+  0635 42 3E 06    	mov [prog], a			; update pointer
0349+  0638 0A 2B 06    	jmp putback_loop
0350+  063B             putback_end:
0351+  063B EF          	pop si
0352+  063C E4          	pop a
0353+  063D 09          	ret
0354+  063E             
0355+  063E             
0356+  063E             
0357+  063E             
0358+  063E 00 00       prog:		.dw 0			; pointer to current position in buffer
0359+  0640             
0360+  0640 00          toktyp: 	.db 0			; token type symbol
0361+  0641 00          tok:		.db 0			; current token symbol
0362+  0642 00 00 00 00 tokstr:		.fill 256, 0	; token as a string
0362+  0646 00 00 00 00 
0362+  064A 00 00 00 00 
0362+  064E 00 00 00 00 
0362+  0652 00 00 00 00 
0362+  0656 00 00 00 00 
0362+  065A 00 00 00 00 
0362+  065E 00 00 00 00 
0362+  0662 00 00 00 00 
0362+  0666 00 00 00 00 
0362+  066A 00 00 00 00 
0362+  066E 00 00 00 00 
0362+  0672 00 00 00 00 
0362+  0676 00 00 00 00 
0362+  067A 00 00 00 00 
0362+  067E 00 00 00 00 
0362+  0682 00 00 00 00 
0362+  0686 00 00 00 00 
0362+  068A 00 00 00 00 
0362+  068E 00 00 00 00 
0362+  0692 00 00 00 00 
0362+  0696 00 00 00 00 
0362+  069A 00 00 00 00 
0362+  069E 00 00 00 00 
0362+  06A2 00 00 00 00 
0362+  06A6 00 00 00 00 
0362+  06AA 00 00 00 00 
0362+  06AE 00 00 00 00 
0362+  06B2 00 00 00 00 
0362+  06B6 00 00 00 00 
0362+  06BA 00 00 00 00 
0362+  06BE 00 00 00 00 
0362+  06C2 00 00 00 00 
0362+  06C6 00 00 00 00 
0362+  06CA 00 00 00 00 
0362+  06CE 00 00 00 00 
0362+  06D2 00 00 00 00 
0362+  06D6 00 00 00 00 
0362+  06DA 00 00 00 00 
0362+  06DE 00 00 00 00 
0362+  06E2 00 00 00 00 
0362+  06E6 00 00 00 00 
0362+  06EA 00 00 00 00 
0362+  06EE 00 00 00 00 
0362+  06F2 00 00 00 00 
0362+  06F6 00 00 00 00 
0362+  06FA 00 00 00 00 
0362+  06FE 00 00 00 00 
0362+  0702 00 00 00 00 
0362+  0706 00 00 00 00 
0362+  070A 00 00 00 00 
0362+  070E 00 00 00 00 
0362+  0712 00 00 00 00 
0362+  0716 00 00 00 00 
0362+  071A 00 00 00 00 
0362+  071E 00 00 00 00 
0362+  0722 00 00 00 00 
0362+  0726 00 00 00 00 
0362+  072A 00 00 00 00 
0362+  072E 00 00 00 00 
0362+  0732 00 00 00 00 
0362+  0736 00 00 00 00 
0362+  073A 00 00 00 00 
0362+  073E 00 00 00 00 
0016   0742             .include "stdio.asm"
0001+  0742             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0742             ; stdio.s
0003+  0742             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0742             .include "string.asm"
0001++ 0742             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0742             ; string.s
0003++ 0742             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0742             
0005++ 0742             
0006++ 0742             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0742             ; strrev
0008++ 0742             ; reverse a string
0009++ 0742             ; D = string address
0010++ 0742             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0742             ; 01234
0012++ 0742             strrev:
0013++ 0742 4B          	pusha
0014++ 0743 07 89 07    	call strlen	; length in C
0015++ 0746 12          	mov a, c
0016++ 0747 AF 01 00    	cmp a, 1
0017++ 074A D0 64 07    	jleu strrev_end	; check string length. string len must be > 1
0018++ 074D 7D          	dec a
0019++ 074E FD 4E       	mov si, d	; beginning of string
0020++ 0750 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0752 59          	add d, a	; end of string
0022++ 0753 12          	mov a, c
0023++ 0754 FD 9B       	shr a		; divide by 2
0024++ 0756 39          	mov c, a	; C now counts the steps
0025++ 0757             strrev_L0:
0026++ 0757 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0758 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0759 3E          	mov [d], al	; store left char into right side
0029++ 075A 1B          	mov al, bl
0030++ 075B F7          	stosb		; store right-side char into left-side; increase DI
0031++ 075C 7E          	dec c
0032++ 075D 7F          	dec d
0033++ 075E C2 00 00    	cmp c, 0
0034++ 0761 C7 57 07    	jne strrev_L0
0035++ 0764             strrev_end:
0036++ 0764 4C          	popa
0037++ 0765 09          	ret
0038++ 0766             	
0039++ 0766             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0766             ; strchr
0041++ 0766             ; search string in D for char in AL
0042++ 0766             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0766             strchr:
0044++ 0766             strchr_L0:
0045++ 0766 32          	mov bl, [d]
0046++ 0767 C1 00       	cmp bl, 0
0047++ 0769 C6 74 07    	je strchr_end
0048++ 076C BA          	cmp al, bl
0049++ 076D C6 74 07    	je strchr_end
0050++ 0770 79          	inc d
0051++ 0771 0A 66 07    	jmp strchr_L0
0052++ 0774             strchr_end:
0053++ 0774 1B          	mov al, bl
0054++ 0775 09          	ret
0055++ 0776             
0056++ 0776             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0776             ; strstr
0058++ 0776             ; find sub-string
0059++ 0776             ; str1 in SI
0060++ 0776             ; str2 in DI
0061++ 0776             ; SI points to end of source string
0062++ 0776             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0776             strstr:
0064++ 0776 DB          	push al
0065++ 0777 DA          	push d
0066++ 0778 E3          	push di
0067++ 0779             strstr_loop:
0068++ 0779 F3          	cmpsb					; compare a byte of the strings
0069++ 077A C7 85 07    	jne strstr_ret
0070++ 077D FC 00 00    	lea d, [di + 0]
0071++ 0780 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0782 C7 79 07    	jne strstr_loop				; equal chars but not at end
0073++ 0785             strstr_ret:
0074++ 0785 F0          	pop di
0075++ 0786 E7          	pop d
0076++ 0787 E8          	pop al
0077++ 0788 09          	ret
0078++ 0789             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0789             ; length of null terminated string
0080++ 0789             ; result in C
0081++ 0789             ; pointer in D
0082++ 0789             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0789             strlen:
0084++ 0789 DA          	push d
0085++ 078A 38 00 00    	mov c, 0
0086++ 078D             strlen_L1:
0087++ 078D BD 00       	cmp byte [d], 0
0088++ 078F C6 97 07    	je strlen_ret
0089++ 0792 79          	inc d
0090++ 0793 78          	inc c
0091++ 0794 0A 8D 07    	jmp strlen_L1
0092++ 0797             strlen_ret:
0093++ 0797 E7          	pop d
0094++ 0798 09          	ret
0095++ 0799             
0096++ 0799             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0799             ; STRCMP
0098++ 0799             ; compare two strings
0099++ 0799             ; str1 in SI
0100++ 0799             ; str2 in DI
0101++ 0799             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0799             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0799             strcmp:
0104++ 0799 DB          	push al
0105++ 079A DA          	push d
0106++ 079B E3          	push di
0107++ 079C E2          	push si
0108++ 079D             strcmp_loop:
0109++ 079D F3          	cmpsb					; compare a byte of the strings
0110++ 079E C7 A9 07    	jne strcmp_ret
0111++ 07A1 FB FF FF    	lea d, [si +- 1]
0112++ 07A4 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 07A6 C7 9D 07    	jne strcmp_loop				; equal chars but not at end
0114++ 07A9             strcmp_ret:
0115++ 07A9 EF          	pop si
0116++ 07AA F0          	pop di
0117++ 07AB E7          	pop d
0118++ 07AC E8          	pop al
0119++ 07AD 09          	ret
0120++ 07AE             
0121++ 07AE             
0122++ 07AE             ; STRCPY
0123++ 07AE             ; copy null terminated string from SI to DI
0124++ 07AE             ; source in SI
0125++ 07AE             ; destination in DI
0126++ 07AE             strcpy:
0127++ 07AE E2          	push si
0128++ 07AF E3          	push di
0129++ 07B0 DB          	push al
0130++ 07B1             strcpy_L1:
0131++ 07B1 F6          	lodsb
0132++ 07B2 F7          	stosb
0133++ 07B3 B9 00       	cmp al, 0
0134++ 07B5 C7 B1 07    	jne strcpy_L1
0135++ 07B8             strcpy_end:
0136++ 07B8 E8          	pop al
0137++ 07B9 F0          	pop di
0138++ 07BA EF          	pop si
0139++ 07BB 09          	ret
0140++ 07BC             
0141++ 07BC             ; STRCAT
0142++ 07BC             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 07BC             ; source in SI
0144++ 07BC             ; destination in DI
0145++ 07BC             strcat:
0146++ 07BC E2          	push si
0147++ 07BD E3          	push di
0148++ 07BE D7          	push a
0149++ 07BF DA          	push d
0150++ 07C0 50          	mov a, di
0151++ 07C1 3C          	mov d, a
0152++ 07C2             strcat_goto_end_L1:
0153++ 07C2 BD 00       	cmp byte[d], 0
0154++ 07C4 C6 CB 07    	je strcat_start
0155++ 07C7 79          	inc d
0156++ 07C8 0A C2 07    	jmp strcat_goto_end_L1
0157++ 07CB             strcat_start:
0158++ 07CB FD 50       	mov di, d
0159++ 07CD             strcat_L1:
0160++ 07CD F6          	lodsb
0161++ 07CE F7          	stosb
0162++ 07CF B9 00       	cmp al, 0
0163++ 07D1 C7 CD 07    	jne strcat_L1
0164++ 07D4             strcat_end:
0165++ 07D4 E7          	pop d
0166++ 07D5 E4          	pop a
0167++ 07D6 F0          	pop di
0168++ 07D7 EF          	pop si
0169++ 07D8 09          	ret
0005+  07D9             
0006+  07D9 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  07DD 34 35 36 37 
0006+  07E1 38 39 41 42 
0006+  07E5 43 44 45 46 
0007+  07E9             
0008+  07E9 01 00       table_power:.dw 1
0009+  07EB 0A 00       			.dw 10
0010+  07ED 64 00       			.dw 100
0011+  07EF E8 03       			.dw 1000
0012+  07F1 10 27       			.dw 10000
0013+  07F3             
0014+  07F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0015+  07F3             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0016+  07F3             ; ASCII in BL
0017+  07F3             ; result in AL
0018+  07F3             ; ascii for F = 0100 0110
0019+  07F3             ; ascii for 9 = 0011 1001
0020+  07F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0021+  07F3             hex_ascii_encode:
0022+  07F3 1B          	mov al, bl
0023+  07F4 93 40       	test al, $40				; test if letter or number
0024+  07F6 C7 FC 07    	jnz hex_letter
0025+  07F9 87 0F       	and al, $0F				; get number
0026+  07FB 09          	ret
0027+  07FC             hex_letter:
0028+  07FC 87 0F       	and al, $0F				; get letter
0029+  07FE 6A 09       	add al, 9
0030+  0800 09          	ret
0031+  0801             
0032+  0801             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0033+  0801             ; ATOI
0034+  0801             ; 2 letter hex string in B
0035+  0801             ; 8bit integer returned in AL
0036+  0801             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0037+  0801             atoi:
0038+  0801 D8          	push b
0039+  0802 07 F3 07    	call hex_ascii_encode			; convert BL to 4bit code in AL
0040+  0805 30          	mov bl, bh
0041+  0806 DB          	push al					; save a
0042+  0807 07 F3 07    	call hex_ascii_encode
0043+  080A EA          	pop bl	
0044+  080B FD 9E 04    	shl al, 4
0045+  080E 8C          	or al, bl
0046+  080F E5          	pop b
0047+  0810 09          	ret	
0048+  0811             
0049+  0811             
0050+  0811             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  0811             ; printf
0052+  0811             ; no need for explanations!
0053+  0811             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0054+  0811             printf:
0055+  0811 09          	ret
0056+  0812             
0057+  0812             
0058+  0812             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  0812             ; scanf
0060+  0812             ; no need for explanations!
0061+  0812             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  0812             scanf:
0063+  0812 09          	ret
0064+  0813             
0065+  0813             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  0813             ; ITOA
0067+  0813             ; 8bit value in BL
0068+  0813             ; 2 byte ASCII result in A
0069+  0813             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0070+  0813             itoa:
0071+  0813 DA          	push d
0072+  0814 D8          	push b
0073+  0815 A7 00       	mov bh, 0
0074+  0817 FD A4 04    	shr bl, 4	
0075+  081A 74          	mov d, b
0076+  081B 1F D9 07    	mov al, [d + s_hex_digits]
0077+  081E 23          	mov ah, al
0078+  081F             	
0079+  081F E5          	pop b
0080+  0820 D8          	push b
0081+  0821 A7 00       	mov bh, 0
0082+  0823 FD 87 0F    	and bl, $0F
0083+  0826 74          	mov d, b
0084+  0827 1F D9 07    	mov al, [d + s_hex_digits]
0085+  082A E5          	pop b
0086+  082B E7          	pop d
0087+  082C 09          	ret
0088+  082D             
0089+  082D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0090+  082D             ; HEX STRING TO BINARY
0091+  082D             ; di = destination address
0092+  082D             ; si = source
0093+  082D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0094+  082D             hex_to_int:
0095+  082D             hex_to_int_L1:
0096+  082D F6          	lodsb					; load from [SI] to AL
0097+  082E B9 00       	cmp al, 0				; check if ASCII 0
0098+  0830 C6 3D 08    	jz hex_to_int_ret
0099+  0833 36          	mov bh, al
0100+  0834 F6          	lodsb
0101+  0835 2F          	mov bl, al
0102+  0836 07 01 08    	call atoi				; convert ASCII byte in B to int (to AL)
0103+  0839 F7          	stosb					; store AL to [DI]
0104+  083A 0A 2D 08    	jmp hex_to_int_L1
0105+  083D             hex_to_int_ret:
0106+  083D 09          	ret		
0107+  083E             
0108+  083E             
0109+  083E             
0110+  083E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  083E             ; GETCHAR
0112+  083E             ; char in ah
0113+  083E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0114+  083E             getchar:
0115+  083E DB          	push al
0116+  083F             getchar_retry:
0117+  083F FD 0C       	sti
0118+  0841 19 01       	mov al, 1
0119+  0843 05 03       	syscall sys_io			; receive in AH
0120+  0845 B9 00       	cmp al, 0			; check if any char was receive
0121+  0847 C6 3F 08    	je getchar_retry
0122+  084A E8          	pop al
0123+  084B 09          	ret
0124+  084C             
0125+  084C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0126+  084C             ; PUTCHAR
0127+  084C             ; char in ah
0128+  084C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  084C             putchar:
0130+  084C D7          	push a
0131+  084D 19 00       	mov al, 0
0132+  084F 05 03       	syscall sys_io			; char in AH
0133+  0851 E4          	pop a
0134+  0852 09          	ret
0135+  0853             
0136+  0853             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0137+  0853             ;; INPUT A STRING
0138+  0853             ;; terminates with null
0139+  0853             ;; pointer in D
0140+  0853             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  0853             gets:
0142+  0853 D7          	push a
0143+  0854 DA          	push d
0144+  0855             gets_loop:
0145+  0855 FD 0C       	sti
0146+  0857 19 01       	mov al, 1
0147+  0859 05 03       	syscall sys_io			; receive in AH
0148+  085B B9 00       	cmp al, 0				; check error code (AL)
0149+  085D C6 55 08    	je gets_loop			; if no char received, retry
0150+  0860             
0151+  0860 76 1B       	cmp ah, 27
0152+  0862 C6 83 08    	je gets_telnet_escape
0153+  0865 76 0A       	cmp ah, $0A				; LF
0154+  0867 C6 DC 08    	je gets_end
0155+  086A 76 0D       	cmp ah, $0D				; CR
0156+  086C C6 DC 08    	je gets_end
0157+  086F 76 5C       	cmp ah, $5C				; '\\'
0158+  0871 C6 B3 08    	je gets_escape
0159+  0874             	
0160+  0874 76 08       	cmp ah, $08			; check for backspace
0161+  0876 C6 7F 08    	je gets_backspace
0162+  0879             
0163+  0879 1A          	mov al, ah
0164+  087A 3E          	mov [d], al
0165+  087B 79          	inc d
0166+  087C 0A 55 08    	jmp gets_loop
0167+  087F             gets_backspace:
0168+  087F 7F          	dec d
0169+  0880 0A 55 08    	jmp gets_loop
0170+  0883             gets_telnet_escape:
0171+  0883 FD 0C       	sti
0172+  0885 19 01       	mov al, 1
0173+  0887 05 03       	syscall sys_io				; receive in AH without echo
0174+  0889 B9 00       	cmp al, 0					; check error code (AL)
0175+  088B C6 83 08    	je gets_telnet_escape		; if no char received, retry
0176+  088E 76 5B       	cmp ah, '['
0177+  0890 C7 55 08    	jne gets_loop
0178+  0893             gets_telnet_escape_phase2:
0179+  0893 FD 0C       	sti
0180+  0895 19 01       	mov al, 1
0181+  0897 05 03       	syscall sys_io					; receive in AH without echo
0182+  0899 B9 00       	cmp al, 0						; check error code (AL)
0183+  089B C6 93 08    	je gets_telnet_escape_phase2	; if no char received, retry
0184+  089E 76 44       	cmp ah, 'D'
0185+  08A0 C6 AB 08    	je gets_left_arrow
0186+  08A3 76 43       	cmp ah, 'C'
0187+  08A5 C6 AF 08    	je gets_right_arrow
0188+  08A8 0A 55 08    	jmp gets_loop
0189+  08AB             gets_left_arrow:
0190+  08AB 7F          	dec d
0191+  08AC 0A 55 08    	jmp gets_loop
0192+  08AF             gets_right_arrow:
0193+  08AF 79          	inc d
0194+  08B0 0A 55 08    	jmp gets_loop
0195+  08B3             gets_escape:
0196+  08B3 FD 0C       	sti
0197+  08B5 19 01       	mov al, 1
0198+  08B7 05 03       	syscall sys_io			; receive in AH
0199+  08B9 B9 00       	cmp al, 0				; check error code (AL)
0200+  08BB C6 B3 08    	je gets_escape			; if no char received, retry
0201+  08BE 76 6E       	cmp ah, 'n'
0202+  08C0 C6 CE 08    	je gets_LF
0203+  08C3 76 72       	cmp ah, 'r'
0204+  08C5 C6 D5 08    	je gets_CR
0205+  08C8 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0206+  08C9 3E          	mov [d], al
0207+  08CA 79          	inc d
0208+  08CB 0A 55 08    	jmp gets_loop
0209+  08CE             gets_LF:
0210+  08CE 19 0A       	mov al, $0A
0211+  08D0 3E          	mov [d], al
0212+  08D1 79          	inc d
0213+  08D2 0A 55 08    	jmp gets_loop
0214+  08D5             gets_CR:
0215+  08D5 19 0D       	mov al, $0D
0216+  08D7 3E          	mov [d], al
0217+  08D8 79          	inc d
0218+  08D9 0A 55 08    	jmp gets_loop
0219+  08DC             gets_end:
0220+  08DC 19 00       	mov al, 0
0221+  08DE 3E          	mov [d], al				; terminate string
0222+  08DF E7          	pop d
0223+  08E0 E4          	pop a
0224+  08E1 09          	ret
0225+  08E2             
0226+  08E2             
0227+  08E2             
0228+  08E2             
0229+  08E2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0230+  08E2             ;; INPUT TEXT
0231+  08E2             ;; terminated with CTRL+D
0232+  08E2             ;; pointer in D
0233+  08E2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0234+  08E2             gettxt:
0235+  08E2 D7          	push a
0236+  08E3 DA          	push d
0237+  08E4             gettxt_loop:
0238+  08E4 19 01       	mov al, 1
0239+  08E6 05 03       	syscall sys_io			; receive in AH
0240+  08E8 B9 00       	cmp al, 0				; check error code (AL)
0241+  08EA C6 E4 08    	je gettxt_loop		; if no char received, retry
0242+  08ED 76 04       	cmp ah, 4			; EOT
0243+  08EF C6 2D 09    	je gettxt_end
0244+  08F2 76 08       	cmp ah, $08			; check for backspace
0245+  08F4 C6 29 09    	je gettxt_backspace
0246+  08F7 76 5C       	cmp ah, $5C				; '\\'
0247+  08F9 C6 02 09    	je gettxt_escape
0248+  08FC 1A          	mov al, ah
0249+  08FD 3E          	mov [d], al
0250+  08FE 79          	inc d
0251+  08FF 0A E4 08    	jmp gettxt_loop
0252+  0902             gettxt_escape:
0253+  0902 19 01       	mov al, 1
0254+  0904 05 03       	syscall sys_io			; receive in AH
0255+  0906 B9 00       	cmp al, 0				; check error code (AL)
0256+  0908 C6 02 09    	je gettxt_escape		; if no char received, retry
0257+  090B 76 6E       	cmp ah, 'n'
0258+  090D C6 1B 09    	je gettxt_LF
0259+  0910 76 72       	cmp ah, 'r'
0260+  0912 C6 22 09    	je gettxt_CR
0261+  0915 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0262+  0916 3E          	mov [d], al
0263+  0917 79          	inc d
0264+  0918 0A E4 08    	jmp gettxt_loop
0265+  091B             gettxt_LF:
0266+  091B 19 0A       	mov al, $0A
0267+  091D 3E          	mov [d], al
0268+  091E 79          	inc d
0269+  091F 0A E4 08    	jmp gettxt_loop
0270+  0922             gettxt_CR:
0271+  0922 19 0D       	mov al, $0D
0272+  0924 3E          	mov [d], al
0273+  0925 79          	inc d
0274+  0926 0A E4 08    	jmp gettxt_loop
0275+  0929             gettxt_backspace:
0276+  0929 7F          	dec d
0277+  092A 0A E4 08    	jmp gettxt_loop
0278+  092D             gettxt_end:
0279+  092D 19 00       	mov al, 0
0280+  092F 3E          	mov [d], al				; terminate string
0281+  0930 E7          	pop d
0282+  0931 E4          	pop a
0283+  0932 09          	ret
0284+  0933             
0285+  0933             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0286+  0933             ; PRINT NEW LINE
0287+  0933             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  0933             printnl:
0289+  0933 D7          	push a
0290+  0934 10 00 0A    	mov a, $0A00
0291+  0937 05 03       	syscall sys_io
0292+  0939 10 00 0D    	mov a, $0D00
0293+  093C 05 03       	syscall sys_io
0294+  093E E4          	pop a
0295+  093F 09          	ret
0296+  0940             
0297+  0940             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0298+  0940             ; strtoint
0299+  0940             ; 4 digit hex string number in d
0300+  0940             ; integer returned in A
0301+  0940             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0302+  0940             strtointx:
0303+  0940 D8          	push b
0304+  0941 32          	mov bl, [d]
0305+  0942 37          	mov bh, bl
0306+  0943 33 01 00    	mov bl, [d + 1]
0307+  0946 07 01 08    	call atoi				; convert to int in AL
0308+  0949 23          	mov ah, al				; move to AH
0309+  094A 33 02 00    	mov bl, [d + 2]
0310+  094D 37          	mov bh, bl
0311+  094E 33 03 00    	mov bl, [d + 3]
0312+  0951 07 01 08    	call atoi				; convert to int in AL
0313+  0954 E5          	pop b
0314+  0955 09          	ret
0315+  0956             
0316+  0956             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0317+  0956             ; strtoint
0318+  0956             ; 5 digit base10 string number in d
0319+  0956             ; integer returned in A
0320+  0956             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0321+  0956             strtoint:
0322+  0956 E2          	push si
0323+  0957 D8          	push b
0324+  0958 D9          	push c
0325+  0959 DA          	push d
0326+  095A 07 89 07    	call strlen			; get string length in C
0327+  095D 7E          	dec c
0328+  095E FD 4E       	mov si, d
0329+  0960 12          	mov a, c
0330+  0961 FD 99       	shl a
0331+  0963 3B E9 07    	mov d, table_power
0332+  0966 59          	add d, a
0333+  0967 38 00 00    	mov c, 0
0334+  096A             strtoint_L0:
0335+  096A F6          	lodsb			; load ASCII to al
0336+  096B B9 00       	cmp al, 0
0337+  096D C6 80 09    	je strtoint_end
0338+  0970 6F 30       	sub al, $30		; make into integer
0339+  0972 22 00       	mov ah, 0
0340+  0974 2A          	mov b, [d]
0341+  0975 AC          	mul a, b			; result in B since it fits in 16bits
0342+  0976 11          	mov a, b
0343+  0977 28          	mov b, c
0344+  0978 54          	add a, b
0345+  0979 39          	mov c, a
0346+  097A 63 02 00    	sub d, 2
0347+  097D 0A 6A 09    	jmp strtoint_L0
0348+  0980             strtoint_end:
0349+  0980 12          	mov a, c
0350+  0981 E7          	pop d
0351+  0982 E6          	pop c
0352+  0983 E5          	pop b
0353+  0984 EF          	pop si
0354+  0985 09          	ret
0355+  0986             
0356+  0986             
0357+  0986             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0358+  0986             ; PRINT NULL TERMINATED STRING
0359+  0986             ; pointer in D
0360+  0986             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0361+  0986             puts:
0362+  0986 D7          	push a
0363+  0987 DA          	push d
0364+  0988             puts_L1:
0365+  0988 1E          	mov al, [d]
0366+  0989 B9 00       	cmp al, 0
0367+  098B C6 97 09    	jz puts_END
0368+  098E 23          	mov ah, al
0369+  098F 19 00       	mov al, 0
0370+  0991 05 03       	syscall sys_io
0371+  0993 79          	inc d
0372+  0994 0A 88 09    	jmp puts_L1
0373+  0997             puts_END:
0374+  0997 E7          	pop d
0375+  0998 E4          	pop a
0376+  0999 09          	ret
0377+  099A             
0378+  099A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  099A             ; PRINT N SIZE STRING
0380+  099A             ; pointer in D
0381+  099A             ; size in C
0382+  099A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0383+  099A             putsn:
0384+  099A DB          	push al
0385+  099B DA          	push d
0386+  099C D9          	push c
0387+  099D             putsn_L0:
0388+  099D 1E          	mov al, [d]
0389+  099E 23          	mov ah, al
0390+  099F 19 00       	mov al, 0
0391+  09A1 05 03       	syscall sys_io
0392+  09A3 79          	inc d
0393+  09A4 7E          	dec c	
0394+  09A5 C2 00 00    	cmp c, 0
0395+  09A8 C7 9D 09    	jne putsn_L0
0396+  09AB             putsn_end:
0397+  09AB E6          	pop c
0398+  09AC E7          	pop d
0399+  09AD E8          	pop al
0400+  09AE 09          	ret
0401+  09AF             
0402+  09AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0403+  09AF             ; print 16bit decimal number
0404+  09AF             ; input number in A
0405+  09AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  09AF             print_u16d:
0407+  09AF D7          	push a
0408+  09B0 D8          	push b
0409+  09B1 26 10 27    	mov b, 10000
0410+  09B4 AE          	div a, b			; get 10000 coeff.
0411+  09B5 07 DB 09    	call print_number
0412+  09B8 11          	mov a, b
0413+  09B9 26 E8 03    	mov b, 1000
0414+  09BC AE          	div a, b			; get 10000 coeff.
0415+  09BD 07 DB 09    	call print_number
0416+  09C0 11          	mov a, b
0417+  09C1 26 64 00    	mov b, 100
0418+  09C4 AE          	div a, b
0419+  09C5 07 DB 09    	call print_number
0420+  09C8 11          	mov a, b
0421+  09C9 26 0A 00    	mov b, 10
0422+  09CC AE          	div a, b
0423+  09CD 07 DB 09    	call print_number
0424+  09D0 11          	mov a, b
0425+  09D1 6A 30       	add al, $30
0426+  09D3 23          	mov ah, al
0427+  09D4 19 00       	mov al, 0
0428+  09D6 05 03       	syscall sys_io	; print coeff
0429+  09D8 E5          	pop b
0430+  09D9 E4          	pop a
0431+  09DA 09          	ret
0432+  09DB             
0433+  09DB             
0434+  09DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0435+  09DB             ; if A == 0, print space
0436+  09DB             ; else print A
0437+  09DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0438+  09DB             print_number:
0439+  09DB 6A 30       	add al, $30
0440+  09DD 23          	mov ah, al
0441+  09DE 07 4C 08    	call putchar
0442+  09E1 09          	ret
0443+  09E2             
0444+  09E2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  09E2             ; PRINT 16BIT HEX INTEGER
0446+  09E2             ; integer value in reg B
0447+  09E2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  09E2             print_u16x:
0449+  09E2 D7          	push a
0450+  09E3 D8          	push b
0451+  09E4 DD          	push bl
0452+  09E5 30          	mov bl, bh
0453+  09E6 07 13 08    	call itoa				; convert bh to char in A
0454+  09E9 2F          	mov bl, al				; save al
0455+  09EA 19 00       	mov al, 0
0456+  09EC 05 03       	syscall sys_io				; display AH
0457+  09EE 24          	mov ah, bl				; retrieve al
0458+  09EF 19 00       	mov al, 0
0459+  09F1 05 03       	syscall sys_io				; display AL
0460+  09F3             
0461+  09F3 EA          	pop bl
0462+  09F4 07 13 08    	call itoa				; convert bh to char in A
0463+  09F7 2F          	mov bl, al				; save al
0464+  09F8 19 00       	mov al, 0
0465+  09FA 05 03       	syscall sys_io				; display AH
0466+  09FC 24          	mov ah, bl				; retrieve al
0467+  09FD 19 00       	mov al, 0
0468+  09FF 05 03       	syscall sys_io				; display AL
0469+  0A01             
0470+  0A01 E5          	pop b
0471+  0A02 E4          	pop a
0472+  0A03 09          	ret
0473+  0A04             
0474+  0A04             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0475+  0A04             ; INPUT 16BIT HEX INTEGER
0476+  0A04             ; read 16bit integer into A
0477+  0A04             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0478+  0A04             scan_u16x:
0479+  0A04 F8 10 00    	enter 16
0480+  0A07 D8          	push b
0481+  0A08 DA          	push d
0482+  0A09             
0483+  0A09 FA F1 FF    	lea d, [bp + -15]
0484+  0A0C 07 53 08    	call gets				; get number
0485+  0A0F             
0486+  0A0F 32          	mov bl, [d]
0487+  0A10 37          	mov bh, bl
0488+  0A11 33 01 00    	mov bl, [d + 1]
0489+  0A14 07 01 08    	call atoi				; convert to int in AL
0490+  0A17 23          	mov ah, al				; move to AH
0491+  0A18             
0492+  0A18 33 02 00    	mov bl, [d + 2]
0493+  0A1B 37          	mov bh, bl
0494+  0A1C 33 03 00    	mov bl, [d + 3]
0495+  0A1F 07 01 08    	call atoi				; convert to int in AL
0496+  0A22             
0497+  0A22 E7          	pop d
0498+  0A23 E5          	pop b
0499+  0A24 F9          	leave
0500+  0A25 09          	ret
0501+  0A26             
0502+  0A26             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0503+  0A26             ; PRINT 8bit HEX INTEGER
0504+  0A26             ; integer value in reg bl
0505+  0A26             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0506+  0A26             print_u8x:
0507+  0A26 D7          	push a
0508+  0A27 DD          	push bl
0509+  0A28             
0510+  0A28 07 13 08    	call itoa				; convert bl to char in A
0511+  0A2B 2F          	mov bl, al				; save al
0512+  0A2C 19 00       	mov al, 0
0513+  0A2E 05 03       	syscall sys_io				; display AH
0514+  0A30 24          	mov ah, bl				; retrieve al
0515+  0A31 19 00       	mov al, 0
0516+  0A33 05 03       	syscall sys_io				; display AL
0517+  0A35             
0518+  0A35 EA          	pop bl
0519+  0A36 E4          	pop a
0520+  0A37 09          	ret
0521+  0A38             
0522+  0A38             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0523+  0A38             ; print 8bit decimal unsigned number
0524+  0A38             ; input number in AL
0525+  0A38             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0526+  0A38             print_u8d:
0527+  0A38 D7          	push a
0528+  0A39 D8          	push b
0529+  0A3A             
0530+  0A3A 22 00       	mov ah, 0
0531+  0A3C 26 64 00    	mov b, 100
0532+  0A3F AE          	div a, b
0533+  0A40 D8          	push b			; save remainder
0534+  0A41 B9 00       	cmp al, 0
0535+  0A43 C6 4D 0A    	je skip100
0536+  0A46 6A 30       	add al, $30
0537+  0A48 23          	mov ah, al
0538+  0A49 19 00       	mov al, 0
0539+  0A4B 05 03       	syscall sys_io	; print coeff
0540+  0A4D             skip100:
0541+  0A4D E4          	pop a
0542+  0A4E 22 00       	mov ah, 0
0543+  0A50 26 0A 00    	mov b, 10
0544+  0A53 AE          	div a, b
0545+  0A54 D8          	push b			; save remainder
0546+  0A55 B9 00       	cmp al, 0
0547+  0A57 C6 61 0A    	je skip10
0548+  0A5A 6A 30       	add al, $30
0549+  0A5C 23          	mov ah, al
0550+  0A5D 19 00       	mov al, 0
0551+  0A5F 05 03       	syscall sys_io	; print coeff
0552+  0A61             skip10:
0553+  0A61 E4          	pop a
0554+  0A62 1B          	mov al, bl
0555+  0A63 6A 30       	add al, $30
0556+  0A65 23          	mov ah, al
0557+  0A66 19 00       	mov al, 0
0558+  0A68 05 03       	syscall sys_io	; print coeff
0559+  0A6A E5          	pop b
0560+  0A6B E4          	pop a
0561+  0A6C 09          	ret
0562+  0A6D             
0563+  0A6D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0564+  0A6D             ; INPUT 8BIT HEX INTEGER
0565+  0A6D             ; read 8bit integer into AL
0566+  0A6D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0567+  0A6D             scan_u8x:
0568+  0A6D F8 04 00    	enter 4
0569+  0A70 D8          	push b
0570+  0A71 DA          	push d
0571+  0A72             
0572+  0A72 FA FD FF    	lea d, [bp + -3]
0573+  0A75 07 53 08    	call gets				; get number
0574+  0A78             
0575+  0A78 32          	mov bl, [d]
0576+  0A79 37          	mov bh, bl
0577+  0A7A 33 01 00    	mov bl, [d + 1]
0578+  0A7D 07 01 08    	call atoi				; convert to int in AL
0579+  0A80             
0580+  0A80 E7          	pop d
0581+  0A81 E5          	pop b
0582+  0A82 F9          	leave
0583+  0A83 09          	ret
0584+  0A84             
0585+  0A84             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0586+  0A84             ; input decimal number
0587+  0A84             ; result in A
0588+  0A84             ; 655'\0'
0589+  0A84             ; low--------high
0590+  0A84             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0591+  0A84             scan_u16d:
0592+  0A84 F8 08 00    	enter 8
0593+  0A87 E2          	push si
0594+  0A88 D8          	push b
0595+  0A89 D9          	push c
0596+  0A8A DA          	push d
0597+  0A8B FA F9 FF    	lea d, [bp +- 7]
0598+  0A8E 07 53 08    	call gets
0599+  0A91 07 89 07    	call strlen			; get string length in C
0600+  0A94 7E          	dec c
0601+  0A95 FD 4E       	mov si, d
0602+  0A97 12          	mov a, c
0603+  0A98 FD 99       	shl a
0604+  0A9A 3B E9 07    	mov d, table_power
0605+  0A9D 59          	add d, a
0606+  0A9E 38 00 00    	mov c, 0
0607+  0AA1             mul_loop:
0608+  0AA1 F6          	lodsb			; load ASCII to al
0609+  0AA2 B9 00       	cmp al, 0
0610+  0AA4 C6 B7 0A    	je mul_exit
0611+  0AA7 6F 30       	sub al, $30		; make into integer
0612+  0AA9 22 00       	mov ah, 0
0613+  0AAB 2A          	mov b, [d]
0614+  0AAC AC          	mul a, b			; result in B since it fits in 16bits
0615+  0AAD 11          	mov a, b
0616+  0AAE 28          	mov b, c
0617+  0AAF 54          	add a, b
0618+  0AB0 39          	mov c, a
0619+  0AB1 63 02 00    	sub d, 2
0620+  0AB4 0A A1 0A    	jmp mul_loop
0621+  0AB7             mul_exit:
0622+  0AB7 12          	mov a, c
0623+  0AB8 E7          	pop d
0624+  0AB9 E6          	pop c
0625+  0ABA E5          	pop b
0626+  0ABB EF          	pop si
0627+  0ABC F9          	leave
0628+  0ABD 09          	ret
0017   0ABE             .include "ctype.asm"
0001+  0ABE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0ABE             ; ctype.s
0003+  0ABE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0ABE             
0005+  0ABE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  0ABE             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  0ABE             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  0ABE             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  0ABE             ;; characters are supported.
0010+  0ABE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  0ABE             ;; isalnum 
0012+  0ABE             ;; isalpha 
0013+  0ABE             ;; islower 
0014+  0ABE             ;; isupper 
0015+  0ABE             ;; isdigit 
0016+  0ABE             ;; isxdigit
0017+  0ABE             ;; iscntrl 
0018+  0ABE             ;; isgraph 
0019+  0ABE             ;; isspace 
0020+  0ABE             ;; isblank 
0021+  0ABE             ;; isprint 
0022+  0ABE             ;; ispunct 
0023+  0ABE             ;; tolower 
0024+  0ABE             ;; toupper
0025+  0ABE             
0026+  0ABE             
0027+  0ABE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  0ABE             ;; IS ALPHANUMERIC
0029+  0ABE             ;; sets ZF according with result
0030+  0ABE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  0ABE             isalnum:
0032+  0ABE 07 DB 0A    	call isalpha
0033+  0AC1 C6 C7 0A    	je isalnum_exit
0034+  0AC4 07 C8 0A    	call isdigit
0035+  0AC7             isalnum_exit:
0036+  0AC7 09          	ret	
0037+  0AC8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0AC8             ;; IS DIGIT
0039+  0AC8             ;; sets ZF according with result
0040+  0AC8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  0AC8             isdigit:
0042+  0AC8 DB          	push al
0043+  0AC9 B9 30       	cmp al, '0'
0044+  0ACB C8 D7 0A    	jlu isdigit_false
0045+  0ACE B9 39       	cmp al, '9'
0046+  0AD0 D1 D7 0A    	jgu isdigit_false
0047+  0AD3 87 00       	and al, 0	; set ZF
0048+  0AD5 E8          	pop al
0049+  0AD6 09          	ret
0050+  0AD7             isdigit_false:
0051+  0AD7 8B 01       	or al, 1	; clear ZF
0052+  0AD9 E8          	pop al
0053+  0ADA 09          	ret	
0054+  0ADB             	
0055+  0ADB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  0ADB             ;; IS ALPHA
0057+  0ADB             ;; sets ZF according with result
0058+  0ADB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  0ADB             isalpha:
0060+  0ADB DB          	push al
0061+  0ADC B9 5F       	cmp al, '_'
0062+  0ADE C6 FE 0A    	je isalpha_true
0063+  0AE1 B9 2E       	cmp al, '.'
0064+  0AE3 C6 FE 0A    	je isalpha_true
0065+  0AE6 B9 41       	cmp al, 'A'
0066+  0AE8 C8 FA 0A    	jlu isalpha_false
0067+  0AEB B9 7A       	cmp al, 'z'
0068+  0AED D1 FA 0A    	jgu isalpha_false
0069+  0AF0 B9 5A       	cmp al, 'Z'
0070+  0AF2 D0 FE 0A    	jleu isalpha_true
0071+  0AF5 B9 61       	cmp al, 'a'
0072+  0AF7 C9 FE 0A    	jgeu isalpha_true
0073+  0AFA             isalpha_false:
0074+  0AFA 8B 01       	or al, 1	; clear ZF
0075+  0AFC E8          	pop al
0076+  0AFD 09          	ret
0077+  0AFE             isalpha_true:
0078+  0AFE 87 00       	and al, 0	; set ZF
0079+  0B00 E8          	pop al
0080+  0B01 09          	ret
0081+  0B02             
0082+  0B02             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  0B02             ;; IS PATH-ALPHA
0084+  0B02             ;; sets ZF according with result
0085+  0B02             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  0B02             ispath:
0087+  0B02 DB          	push al
0088+  0B03 07 C8 0A    	call isdigit
0089+  0B06 C6 30 0B    	je ispath_true
0090+  0B09 B9 5F       	cmp al, '_'
0091+  0B0B C6 30 0B    	je ispath_true
0092+  0B0E B9 2F       	cmp al, '/'
0093+  0B10 C6 30 0B    	je ispath_true
0094+  0B13 B9 2E       	cmp al, '.'
0095+  0B15 C6 30 0B    	je ispath_true
0096+  0B18 B9 41       	cmp al, 'A'
0097+  0B1A C8 2C 0B    	jlu ispath_false
0098+  0B1D B9 7A       	cmp al, 'z'
0099+  0B1F D1 2C 0B    	jgu ispath_false
0100+  0B22 B9 5A       	cmp al, 'Z'
0101+  0B24 D0 30 0B    	jleu ispath_true
0102+  0B27 B9 61       	cmp al, 'a'
0103+  0B29 C9 30 0B    	jgeu ispath_true
0104+  0B2C             ispath_false:
0105+  0B2C 8B 01       	or al, 1	; clear ZF
0106+  0B2E E8          	pop al
0107+  0B2F 09          	ret
0108+  0B30             ispath_true:
0109+  0B30 87 00       	and al, 0	; set ZF
0110+  0B32 E8          	pop al
0111+  0B33 09          	ret
0112+  0B34             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  0B34             ;; IS SPACE
0114+  0B34             ;; sets ZF according with result
0115+  0B34             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  0B34             isspace:
0117+  0B34 B9 20       	cmp al, $20		; ' '
0118+  0B36 C6 4A 0B    	je isspace_exit
0119+  0B39 B9 09       	cmp al, $09		; '\t'
0120+  0B3B C6 4A 0B    	je isspace_exit
0121+  0B3E B9 0A       	cmp al, $0A		; '\n'
0122+  0B40 C6 4A 0B    	je isspace_exit
0123+  0B43 B9 0D       	cmp al, $0D		; '\r'
0124+  0B45 C6 4A 0B    	je isspace_exit
0125+  0B48 B9 0B       	cmp al, $0B		; '\v'
0126+  0B4A             isspace_exit:
0127+  0B4A 09          	ret	
0128+  0B4B             
0129+  0B4B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0B4B             ; TO LOWER
0131+  0B4B             ; input in AL
0132+  0B4B             ; output in AL
0133+  0B4B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  0B4B             to_lower:
0135+  0B4B B9 5A       	cmp al, 'Z'
0136+  0B4D D1 52 0B    	jgu to_lower_ret
0137+  0B50 6A 20       	add al, $20				; convert to lower case
0138+  0B52             to_lower_ret:
0139+  0B52 09          	ret
0140+  0B53             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  0B53             ; TO UPPER
0142+  0B53             ; input in AL
0143+  0B53             ; output in AL
0144+  0B53             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  0B53             to_upper:
0146+  0B53 B9 61       	cmp al, 'a'
0147+  0B55 C8 5A 0B    	jlu to_upper_ret
0148+  0B58 6F 20       	sub al, $20			; convert to upper case
0149+  0B5A             to_upper_ret:
0150+  0B5A 09          	ret
0151+  0B5B             
0018   0B5B             
0019   0B5B             .end
0020   0B5B             
0021   0B5B             
tasm: Number of errors = 0
