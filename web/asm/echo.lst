0001   0000             .include "kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0002   0000             
0003   0400             .org PROC_TEXT_ORG			; origin at 1024
0004   0400             
0005   0400             cmd_echo:
0006   0400 10 00 00    	mov a, 0
0007   0403 42 3E 06    	mov [prog], a			; move tokennizer pointer to the beginning of the arguments area (address 0)
0008   0406 07 14 04    	call get_arg			; read argument line
0009   0409 3B 42 06    	mov d, tokstr
0010   040C 07 81 09    	call puts
0011   040F 07 2E 09    	call printnl
0012   0412 05 0B       	syscall sys_terminate_proc
0013   0414             
0014   0414             
0015   0414             .include "token.asm"
0001+  0414             TOKTYP_IDENTIFIER	.equ 0
0002+  0414             TOKTYP_KEYWORD		.equ 1
0003+  0414             TOKTYP_DELIMITER	.equ 2
0004+  0414             TOKTYP_STRING		.equ 3
0005+  0414             TOKTYP_CHAR			.equ 4
0006+  0414             TOKTYP_NUMERIC		.equ 5
0007+  0414             TOKTYP_END			.equ 6
0008+  0414             
0009+  0414             TOK_NULL			.equ 0
0010+  0414             TOK_FSLASH			.equ 1
0011+  0414             TOK_TIMES 			.equ 2
0012+  0414             TOK_PLUS 			.equ 3
0013+  0414             TOK_MINUS 			.equ 4
0014+  0414             TOK_DOT				.equ 5
0015+  0414             TOK_SEMI			.equ 6
0016+  0414             TOK_ANGLE			.equ 7
0017+  0414             TOK_TILDE			.equ 8
0018+  0414             TOK_EQUAL			.equ 9
0019+  0414             TOK_COLON			.equ 10
0020+  0414             TOK_COMMA			.equ 11
0021+  0414             
0022+  0414             TOK_END				.equ 20
0023+  0414             
0024+  0414             
0025+  0414             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  0414             ;; read a full command argment from shell input buffer
0027+  0414             ;; argument is written into tokstr
0028+  0414             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  0414             get_arg:
0030+  0414 D7          	push a
0031+  0415 E2          	push si
0032+  0416 E3          	push di
0033+  0417 19 00       	mov al, 0
0034+  0419 3D 42 06    	mov [tokstr], al			; nullify tokstr string
0035+  041C 14 3E 06    	mov a, [prog]
0036+  041F 4D          	mov si, a
0037+  0420 FD 4F 42 06 	mov di, tokstr
0038+  0424             get_arg_skip_spaces:
0039+  0424 F6          	lodsb
0040+  0425 07 2F 0B    	call isspace
0041+  0428 C6 24 04    	je get_arg_skip_spaces
0042+  042B             get_arg_L0:
0043+  042B B9 3B       	cmp al, $3B				; check if is ';'
0044+  042D C6 3A 04    	je get_arg_end
0045+  0430 B9 00       	cmp al, 0
0046+  0432 C6 3A 04    	je get_arg_end			; check if end of input
0047+  0435 F7          	stosb
0048+  0436 F6          	lodsb
0049+  0437 0A 2B 04    	jmp get_arg_L0
0050+  043A             get_arg_end:
0051+  043A 19 00       	mov al, 0
0052+  043C F7          	stosb
0053+  043D D5 01 00    	sub si, 1
0054+  0440 4E          	mov a, si
0055+  0441 42 3E 06    	mov [prog], a		; update pointer
0056+  0444 F0          	pop di
0057+  0445 EF          	pop si
0058+  0446 E4          	pop a
0059+  0447 09          	ret
0060+  0448             
0061+  0448             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  0448             ;; read a path formation from shell input buffer
0063+  0448             ;; path is written into tokstr
0064+  0448             ;; /usr/bin
0065+  0448             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  0448             get_path:
0067+  0448 D7          	push a
0068+  0449 E2          	push si
0069+  044A E3          	push di
0070+  044B 19 00       	mov al, 0
0071+  044D 3D 42 06    	mov [tokstr], al			; nullify tokstr string
0072+  0450 14 3E 06    	mov a, [prog]
0073+  0453 4D          	mov si, a
0074+  0454 FD 4F 42 06 	mov di, tokstr
0075+  0458             get_path_skip_spaces:
0076+  0458 F6          	lodsb
0077+  0459 07 2F 0B    	call isspace
0078+  045C C6 58 04    	je get_path_skip_spaces
0079+  045F             get_path_is_pathchar:
0080+  045F F7          	stosb
0081+  0460 F6          	lodsb
0082+  0461 07 B9 0A    	call isalnum			;check if is alphanumeric
0083+  0464 C6 5F 04    	je get_path_is_pathchar
0084+  0467 B9 2F       	cmp al, '/'				; check if is '/'
0085+  0469 C6 5F 04    	je get_path_is_pathchar
0086+  046C 19 00       	mov al, 0
0087+  046E F7          	stosb
0088+  046F D5 01 00    	sub si, 1
0089+  0472 4E          	mov a, si
0090+  0473 42 3E 06    	mov [prog], a		; update pointer
0091+  0476             get_path_end:
0092+  0476 F0          	pop di
0093+  0477 EF          	pop si
0094+  0478 E4          	pop a
0095+  0479 09          	ret
0096+  047A             
0097+  047A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  047A             ;; read a line
0099+  047A             ;; line is written into tokstr
0100+  047A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  047A             get_line:
0102+  047A D7          	push a
0103+  047B E2          	push si
0104+  047C E3          	push di
0105+  047D 19 00       	mov al, 0
0106+  047F 3D 42 06    	mov [tokstr], al			; nullify tokstr string
0107+  0482 14 3E 06    	mov a, [prog]
0108+  0485 4D          	mov si, a
0109+  0486 FD 4F 42 06 	mov di, tokstr
0110+  048A             get_line_L0:
0111+  048A F6          	lodsb
0112+  048B B9 0A       	cmp al, $0A		; check for new line
0113+  048D C6 94 04    	je get_line_exit
0114+  0490 F7          	stosb
0115+  0491 0A 8A 04    	jmp get_line_L0
0116+  0494             get_line_exit:
0117+  0494 19 00       	mov al, 0
0118+  0496 F7          	stosb
0119+  0497 4E          	mov a, si
0120+  0498 42 3E 06    	mov [prog], a		; update pointer
0121+  049B F0          	pop di
0122+  049C EF          	pop si
0123+  049D E4          	pop a
0124+  049E 09          	ret
0125+  049F             
0126+  049F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  049F             ;; token parser
0128+  049F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  049F             get_token:
0130+  049F D7          	push a
0131+  04A0 DA          	push d
0132+  04A1 E2          	push si
0133+  04A2 E3          	push di
0134+  04A3 19 00       	mov al, 0
0135+  04A5 3D 42 06    	mov [tokstr], al			; nullify tokstr string
0136+  04A8 19 00       	mov al, TOK_NULL
0137+  04AA 3D 41 06    	mov [tok], al				; nullify token
0138+  04AD 14 3E 06    	mov a, [prog]
0139+  04B0 4D          	mov si, a
0140+  04B1 FD 4F 42 06 	mov di, tokstr
0141+  04B5             get_tok_skip_spaces:
0142+  04B5 F6          	lodsb
0143+  04B6 07 2F 0B    	call isspace
0144+  04B9 C6 B5 04    	je get_tok_skip_spaces
0145+  04BC B9 00       	cmp al, 0			; check for end of input (NULL)
0146+  04BE C6 A3 05    	je get_token_end
0147+  04C1 B9 23       	cmp al, '#'			; comments!
0148+  04C3 C6 D1 05    	je get_tok_comment
0149+  04C6 07 B9 0A    	call isalnum
0150+  04C9 C6 B0 05    	jz is_alphanumeric
0151+  04CC             ; other token types
0152+  04CC             get_token_slash:
0153+  04CC B9 2F       	cmp al, '/'				; check if '/'
0154+  04CE C7 E6 04    	jne get_token_minus
0155+  04D1 F7          	stosb					; store '/' into token string
0156+  04D2 19 00       	mov al, 0
0157+  04D4 F7          	stosb					; terminate token string
0158+  04D5 19 01       	mov al, TOK_FSLASH
0159+  04D7 3D 41 06    	mov [tok], al			
0160+  04DA 19 02       	mov al, TOKTYP_DELIMITER
0161+  04DC 3D 40 06    	mov [toktyp], al
0162+  04DF 4E          	mov a, si
0163+  04E0 42 3E 06    	mov [prog], a		; update pointer
0164+  04E3 0A CC 05    	jmp get_token_return
0165+  04E6             get_token_minus:
0166+  04E6 B9 2D       	cmp al, '-'				; check if '-'
0167+  04E8 C7 00 05    	jne get_token_comma
0168+  04EB F7          	stosb					; store '-' into token string
0169+  04EC 19 00       	mov al, 0
0170+  04EE F7          	stosb					; terminate token string
0171+  04EF 19 04       	mov al, TOK_MINUS
0172+  04F1 3D 41 06    	mov [tok], al			
0173+  04F4 19 02       	mov al, TOKTYP_DELIMITER
0174+  04F6 3D 40 06    	mov [toktyp], al
0175+  04F9 4E          	mov a, si
0176+  04FA 42 3E 06    	mov [prog], a		; update pointer
0177+  04FD 0A CC 05    	jmp get_token_return
0178+  0500             get_token_comma:
0179+  0500 B9 2C       	cmp al, ','				; check if ','
0180+  0502 C7 1A 05    	jne get_token_semi
0181+  0505 F7          	stosb					; store ',' into token string
0182+  0506 19 00       	mov al, 0
0183+  0508 F7          	stosb					; terminate token string
0184+  0509 19 0B       	mov al, TOK_COMMA
0185+  050B 3D 41 06    	mov [tok], al			
0186+  050E 19 02       	mov al, TOKTYP_DELIMITER
0187+  0510 3D 40 06    	mov [toktyp], al
0188+  0513 4E          	mov a, si
0189+  0514 42 3E 06    	mov [prog], a		; update pointer
0190+  0517 0A CC 05    	jmp get_token_return
0191+  051A             get_token_semi:
0192+  051A B9 3B       	cmp al, $3B				; check if ';'
0193+  051C C7 34 05    	jne get_token_colon
0194+  051F F7          	stosb					; store ';' into token string
0195+  0520 19 00       	mov al, 0
0196+  0522 F7          	stosb					; terminate token string
0197+  0523 19 06       	mov al, TOK_SEMI
0198+  0525 3D 41 06    	mov [tok], al			
0199+  0528 19 02       	mov al, TOKTYP_DELIMITER
0200+  052A 3D 40 06    	mov [toktyp], al
0201+  052D 4E          	mov a, si
0202+  052E 42 3E 06    	mov [prog], a		; update pointer
0203+  0531 0A CC 05    	jmp get_token_return
0204+  0534             get_token_colon:
0205+  0534 B9 3A       	cmp al, $3A				; check if ':'
0206+  0536 C7 4E 05    	jne get_token_angle
0207+  0539 F7          	stosb					; store ':' into token string
0208+  053A 19 00       	mov al, 0
0209+  053C F7          	stosb					; terminate token string
0210+  053D 19 0A       	mov al, TOK_COLON
0211+  053F 3D 41 06    	mov [tok], al			
0212+  0542 19 02       	mov al, TOKTYP_DELIMITER
0213+  0544 3D 40 06    	mov [toktyp], al
0214+  0547 4E          	mov a, si
0215+  0548 42 3E 06    	mov [prog], a		; update pointer
0216+  054B 0A CC 05    	jmp get_token_return
0217+  054E             get_token_angle:
0218+  054E B9 3E       	cmp al, $3E				; check if '>'
0219+  0550 C7 68 05    	jne get_token_tilde
0220+  0553 F7          	stosb					; store '>' into token string
0221+  0554 19 00       	mov al, 0
0222+  0556 F7          	stosb					; terminate token string
0223+  0557 19 07       	mov al, TOK_ANGLE
0224+  0559 3D 41 06    	mov [tok], al			
0225+  055C 19 02       	mov al, TOKTYP_DELIMITER
0226+  055E 3D 40 06    	mov [toktyp], al
0227+  0561 4E          	mov a, si
0228+  0562 42 3E 06    	mov [prog], a		; update pointer
0229+  0565 0A CC 05    	jmp get_token_return
0230+  0568             get_token_tilde:
0231+  0568 B9 7E       	cmp al, '~'				; check if '~'
0232+  056A C7 82 05    	jne get_token_equal
0233+  056D F7          	stosb					; store '~' into token string
0234+  056E 19 00       	mov al, 0
0235+  0570 F7          	stosb					; terminate token string
0236+  0571 19 08       	mov al, TOK_TILDE
0237+  0573 3D 41 06    	mov [tok], al			
0238+  0576 19 02       	mov al, TOKTYP_DELIMITER
0239+  0578 3D 40 06    	mov [toktyp], al
0240+  057B 4E          	mov a, si
0241+  057C 42 3E 06    	mov [prog], a		; update pointer
0242+  057F 0A CC 05    	jmp get_token_return
0243+  0582             get_token_equal:
0244+  0582 B9 3D       	cmp al, '='				; check if '='
0245+  0584 C7 9C 05    	jne get_token_skip
0246+  0587 F7          	stosb					; store '=' into token string
0247+  0588 19 00       	mov al, 0
0248+  058A F7          	stosb					; terminate token string
0249+  058B 19 09       	mov al, TOK_EQUAL
0250+  058D 3D 41 06    	mov [tok], al			
0251+  0590 19 02       	mov al, TOKTYP_DELIMITER
0252+  0592 3D 40 06    	mov [toktyp], al
0253+  0595 4E          	mov a, si
0254+  0596 42 3E 06    	mov [prog], a		; update pointer
0255+  0599 0A CC 05    	jmp get_token_return
0256+  059C             get_token_skip:
0257+  059C 4E          	mov a, si
0258+  059D 42 3E 06    	mov [prog], a		; update pointer
0259+  05A0 0A CC 05    	jmp get_token_return
0260+  05A3             get_token_end:				; end of file token
0261+  05A3 19 14       	mov al, TOK_END
0262+  05A5 3D 41 06    	mov [tok], al
0263+  05A8 19 06       	mov al, TOKTYP_END
0264+  05AA 3D 40 06    	mov [toktyp], al
0265+  05AD 0A CC 05    	jmp get_token_return
0266+  05B0             is_alphanumeric:
0267+  05B0 F7          	stosb
0268+  05B1 F6          	lodsb
0269+  05B2 07 B9 0A    	call isalnum			;check if is alphanumeric
0270+  05B5 C6 B0 05    	jz is_alphanumeric
0271+  05B8 B9 2E       	cmp al, $2E				; check if is '.'
0272+  05BA C6 B0 05    	je is_alphanumeric
0273+  05BD 19 00       	mov al, 0
0274+  05BF F7          	stosb
0275+  05C0 19 00       	mov al, TOKTYP_IDENTIFIER
0276+  05C2 3D 40 06    	mov [toktyp], al
0277+  05C5 D5 01 00    	sub si, 1
0278+  05C8 4E          	mov a, si
0279+  05C9 42 3E 06    	mov [prog], a		; update pointer
0280+  05CC             get_token_return:
0281+  05CC F0          	pop di
0282+  05CD EF          	pop si
0283+  05CE E7          	pop d
0284+  05CF E4          	pop a
0285+  05D0 09          	ret
0286+  05D1             get_tok_comment:
0287+  05D1 F6          	lodsb
0288+  05D2 B9 0A       	cmp al, $0A			; new line
0289+  05D4 C7 D1 05    	jne get_tok_comment
0290+  05D7 0A B5 04    	jmp get_tok_skip_spaces
0291+  05DA             
0292+  05DA             
0293+  05DA             get_number:
0294+  05DA D7          	push a
0295+  05DB DA          	push d
0296+  05DC E2          	push si
0297+  05DD E3          	push di
0298+  05DE 19 00       	mov al, 0
0299+  05E0 3D 42 06    	mov [tokstr], al			; nullify tokstr string
0300+  05E3 19 00       	mov al, TOK_NULL
0301+  05E5 3D 41 06    	mov [tok], al				; nullify token
0302+  05E8 14 3E 06    	mov a, [prog]
0303+  05EB 4D          	mov si, a
0304+  05EC FD 4F 42 06 	mov di, tokstr
0305+  05F0             get_number_skip_spaces:
0306+  05F0 F6          	lodsb
0307+  05F1 07 2F 0B    	call isspace
0308+  05F4 C6 F0 05    	je get_number_skip_spaces
0309+  05F7 B9 00       	cmp al, 0			; check for end of input (NULL)
0310+  05F9 C7 09 06    	jne get_number_L0
0311+  05FC 19 14       	mov al, TOK_END
0312+  05FE 3D 41 06    	mov [tok], al
0313+  0601 19 06       	mov al, TOKTYP_END
0314+  0603 3D 40 06    	mov [toktyp], al
0315+  0606 0A 20 06    	jmp get_number_return
0316+  0609             get_number_L0:
0317+  0609 F7          	stosb
0318+  060A F6          	lodsb
0319+  060B 07 C3 0A    	call isdigit			;check if is numeric
0320+  060E C6 09 06    	jz get_number_L0
0321+  0611 19 00       	mov al, 0
0322+  0613 F7          	stosb
0323+  0614 19 05       	mov al, TOKTYP_NUMERIC
0324+  0616 3D 40 06    	mov [toktyp], al
0325+  0619 D5 01 00    	sub si, 1
0326+  061C 4E          	mov a, si
0327+  061D 42 3E 06    	mov [prog], a		; update pointer
0328+  0620             get_number_return:
0329+  0620 F0          	pop di
0330+  0621 EF          	pop si
0331+  0622 E7          	pop d
0332+  0623 E4          	pop a
0333+  0624 09          	ret
0334+  0625             
0335+  0625             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  0625             ;; PUT BACK TOKEN
0337+  0625             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
0338+  0625             putback:
0339+  0625 D7          	push a
0340+  0626 E2          	push si
0341+  0627 FD 4D 42 06 	mov si, tokstr	
0342+  062B             putback_loop:
0343+  062B F6          	lodsb
0344+  062C B9 00       	cmp al, 0
0345+  062E C6 3B 06    	je putback_end
0346+  0631 14 3E 06    	mov a, [prog]
0347+  0634 7D          	dec a
0348+  0635 42 3E 06    	mov [prog], a			; update pointer
0349+  0638 0A 2B 06    	jmp putback_loop
0350+  063B             putback_end:
0351+  063B EF          	pop si
0352+  063C E4          	pop a
0353+  063D 09          	ret
0354+  063E             
0355+  063E             
0356+  063E             
0357+  063E             
0358+  063E 00 00       prog:		.dw 0			; pointer to current position in buffer
0359+  0640             
0360+  0640 00          toktyp: 	.db 0			; token type symbol
0361+  0641 00          tok:		.db 0			; current token symbol
0362+  0642 00 00 00 00 tokstr:		.fill 256, 0	; token as a string
0362+  0646 00 00 00 00 
0362+  064A 00 00 00 00 
0362+  064E 00 00 00 00 
0362+  0652 00 00 00 00 
0362+  0656 00 00 00 00 
0362+  065A 00 00 00 00 
0362+  065E 00 00 00 00 
0362+  0662 00 00 00 00 
0362+  0666 00 00 00 00 
0362+  066A 00 00 00 00 
0362+  066E 00 00 00 00 
0362+  0672 00 00 00 00 
0362+  0676 00 00 00 00 
0362+  067A 00 00 00 00 
0362+  067E 00 00 00 00 
0362+  0682 00 00 00 00 
0362+  0686 00 00 00 00 
0362+  068A 00 00 00 00 
0362+  068E 00 00 00 00 
0362+  0692 00 00 00 00 
0362+  0696 00 00 00 00 
0362+  069A 00 00 00 00 
0362+  069E 00 00 00 00 
0362+  06A2 00 00 00 00 
0362+  06A6 00 00 00 00 
0362+  06AA 00 00 00 00 
0362+  06AE 00 00 00 00 
0362+  06B2 00 00 00 00 
0362+  06B6 00 00 00 00 
0362+  06BA 00 00 00 00 
0362+  06BE 00 00 00 00 
0362+  06C2 00 00 00 00 
0362+  06C6 00 00 00 00 
0362+  06CA 00 00 00 00 
0362+  06CE 00 00 00 00 
0362+  06D2 00 00 00 00 
0362+  06D6 00 00 00 00 
0362+  06DA 00 00 00 00 
0362+  06DE 00 00 00 00 
0362+  06E2 00 00 00 00 
0362+  06E6 00 00 00 00 
0362+  06EA 00 00 00 00 
0362+  06EE 00 00 00 00 
0362+  06F2 00 00 00 00 
0362+  06F6 00 00 00 00 
0362+  06FA 00 00 00 00 
0362+  06FE 00 00 00 00 
0362+  0702 00 00 00 00 
0362+  0706 00 00 00 00 
0362+  070A 00 00 00 00 
0362+  070E 00 00 00 00 
0362+  0712 00 00 00 00 
0362+  0716 00 00 00 00 
0362+  071A 00 00 00 00 
0362+  071E 00 00 00 00 
0362+  0722 00 00 00 00 
0362+  0726 00 00 00 00 
0362+  072A 00 00 00 00 
0362+  072E 00 00 00 00 
0362+  0732 00 00 00 00 
0362+  0736 00 00 00 00 
0362+  073A 00 00 00 00 
0362+  073E 00 00 00 00 
0016   0742             .include "stdio.asm"
0001+  0742             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0742             ; stdio.s
0003+  0742             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0742             .include "string.asm"
0001++ 0742             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0742             ; string.s
0003++ 0742             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0742             
0005++ 0742             
0006++ 0742             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0742             ; strrev
0008++ 0742             ; reverse a string
0009++ 0742             ; D = string address
0010++ 0742             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0742             ; 01234
0012++ 0742             strrev:
0013++ 0742 4B          	pusha
0014++ 0743 07 89 07    	call strlen	; length in C
0015++ 0746 12          	mov a, c
0016++ 0747 AF 01 00    	cmp a, 1
0017++ 074A D0 64 07    	jleu strrev_end	; check string length. string len must be > 1
0018++ 074D 7D          	dec a
0019++ 074E FD 4E       	mov si, d	; beginning of string
0020++ 0750 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0752 59          	add d, a	; end of string
0022++ 0753 12          	mov a, c
0023++ 0754 FD 9B       	shr a		; divide by 2
0024++ 0756 39          	mov c, a	; C now counts the steps
0025++ 0757             strrev_L0:
0026++ 0757 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0758 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0759 3E          	mov [d], al	; store left char into right side
0029++ 075A 1B          	mov al, bl
0030++ 075B F7          	stosb		; store right-side char into left-side; increase DI
0031++ 075C 7E          	dec c
0032++ 075D 7F          	dec d
0033++ 075E C2 00 00    	cmp c, 0
0034++ 0761 C7 57 07    	jne strrev_L0
0035++ 0764             strrev_end:
0036++ 0764 4C          	popa
0037++ 0765 09          	ret
0038++ 0766             	
0039++ 0766             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0766             ; strchr
0041++ 0766             ; search string in D for char in AL
0042++ 0766             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0766             strchr:
0044++ 0766             strchr_L0:
0045++ 0766 32          	mov bl, [d]
0046++ 0767 C1 00       	cmp bl, 0
0047++ 0769 C6 74 07    	je strchr_end
0048++ 076C BA          	cmp al, bl
0049++ 076D C6 74 07    	je strchr_end
0050++ 0770 79          	inc d
0051++ 0771 0A 66 07    	jmp strchr_L0
0052++ 0774             strchr_end:
0053++ 0774 1B          	mov al, bl
0054++ 0775 09          	ret
0055++ 0776             
0056++ 0776             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0776             ; strstr
0058++ 0776             ; find sub-string
0059++ 0776             ; str1 in SI
0060++ 0776             ; str2 in DI
0061++ 0776             ; SI points to end of source string
0062++ 0776             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0776             strstr:
0064++ 0776 DB          	push al
0065++ 0777 DA          	push d
0066++ 0778 E3          	push di
0067++ 0779             strstr_loop:
0068++ 0779 F3          	cmpsb					; compare a byte of the strings
0069++ 077A C7 85 07    	jne strstr_ret
0070++ 077D FC 00 00    	lea d, [di + 0]
0071++ 0780 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0782 C7 79 07    	jne strstr_loop				; equal chars but not at end
0073++ 0785             strstr_ret:
0074++ 0785 F0          	pop di
0075++ 0786 E7          	pop d
0076++ 0787 E8          	pop al
0077++ 0788 09          	ret
0078++ 0789             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0789             ; length of null terminated string
0080++ 0789             ; result in C
0081++ 0789             ; pointer in D
0082++ 0789             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0789             strlen:
0084++ 0789 DA          	push d
0085++ 078A 38 00 00    	mov c, 0
0086++ 078D             strlen_L1:
0087++ 078D BD 00       	cmp byte [d], 0
0088++ 078F C6 97 07    	je strlen_ret
0089++ 0792 79          	inc d
0090++ 0793 78          	inc c
0091++ 0794 0A 8D 07    	jmp strlen_L1
0092++ 0797             strlen_ret:
0093++ 0797 E7          	pop d
0094++ 0798 09          	ret
0095++ 0799             
0096++ 0799             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0799             ; STRCMP
0098++ 0799             ; compare two strings
0099++ 0799             ; str1 in SI
0100++ 0799             ; str2 in DI
0101++ 0799             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0799             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0799             strcmp:
0104++ 0799 DB          	push al
0105++ 079A DA          	push d
0106++ 079B E3          	push di
0107++ 079C E2          	push si
0108++ 079D             strcmp_loop:
0109++ 079D F3          	cmpsb					; compare a byte of the strings
0110++ 079E C7 A9 07    	jne strcmp_ret
0111++ 07A1 FB FF FF    	lea d, [si +- 1]
0112++ 07A4 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 07A6 C7 9D 07    	jne strcmp_loop				; equal chars but not at end
0114++ 07A9             strcmp_ret:
0115++ 07A9 EF          	pop si
0116++ 07AA F0          	pop di
0117++ 07AB E7          	pop d
0118++ 07AC E8          	pop al
0119++ 07AD 09          	ret
0120++ 07AE             
0121++ 07AE             
0122++ 07AE             ; STRCPY
0123++ 07AE             ; copy null terminated string from SI to DI
0124++ 07AE             ; source in SI
0125++ 07AE             ; destination in DI
0126++ 07AE             strcpy:
0127++ 07AE E2          	push si
0128++ 07AF E3          	push di
0129++ 07B0 DB          	push al
0130++ 07B1             strcpy_L1:
0131++ 07B1 F6          	lodsb
0132++ 07B2 F7          	stosb
0133++ 07B3 B9 00       	cmp al, 0
0134++ 07B5 C7 B1 07    	jne strcpy_L1
0135++ 07B8             strcpy_end:
0136++ 07B8 E8          	pop al
0137++ 07B9 F0          	pop di
0138++ 07BA EF          	pop si
0139++ 07BB 09          	ret
0140++ 07BC             
0141++ 07BC             ; STRCAT
0142++ 07BC             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 07BC             ; source in SI
0144++ 07BC             ; destination in DI
0145++ 07BC             strcat:
0146++ 07BC E2          	push si
0147++ 07BD E3          	push di
0148++ 07BE D7          	push a
0149++ 07BF DA          	push d
0150++ 07C0 50          	mov a, di
0151++ 07C1 3C          	mov d, a
0152++ 07C2             strcat_goto_end_L1:
0153++ 07C2 BD 00       	cmp byte[d], 0
0154++ 07C4 C6 CB 07    	je strcat_start
0155++ 07C7 79          	inc d
0156++ 07C8 0A C2 07    	jmp strcat_goto_end_L1
0157++ 07CB             strcat_start:
0158++ 07CB FD 50       	mov di, d
0159++ 07CD             strcat_L1:
0160++ 07CD F6          	lodsb
0161++ 07CE F7          	stosb
0162++ 07CF B9 00       	cmp al, 0
0163++ 07D1 C7 CD 07    	jne strcat_L1
0164++ 07D4             strcat_end:
0165++ 07D4 E7          	pop d
0166++ 07D5 E4          	pop a
0167++ 07D6 F0          	pop di
0168++ 07D7 EF          	pop si
0169++ 07D8 09          	ret
0005+  07D9             
0006+  07D9 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  07DD 34 35 36 37 
0006+  07E1 38 39 41 42 
0006+  07E5 43 44 45 46 
0007+  07E9             
0008+  07E9 01 00       table_power:.dw 1
0009+  07EB 0A 00       			.dw 10
0010+  07ED 64 00       			.dw 100
0011+  07EF E8 03       			.dw 1000
0012+  07F1 10 27       			.dw 10000
0013+  07F3             
0014+  07F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0015+  07F3             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0016+  07F3             ; ASCII in BL
0017+  07F3             ; result in AL
0018+  07F3             ; ascii for F = 0100 0110
0019+  07F3             ; ascii for 9 = 0011 1001
0020+  07F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0021+  07F3             hex_ascii_encode:
0022+  07F3 1B          	mov al, bl
0023+  07F4 93 40       	test al, $40				; test if letter or number
0024+  07F6 C7 FC 07    	jnz hex_letter
0025+  07F9 87 0F       	and al, $0F				; get number
0026+  07FB 09          	ret
0027+  07FC             hex_letter:
0028+  07FC 87 0F       	and al, $0F				; get letter
0029+  07FE 6A 09       	add al, 9
0030+  0800 09          	ret
0031+  0801             
0032+  0801             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0033+  0801             ; ATOI
0034+  0801             ; 2 letter hex string in B
0035+  0801             ; 8bit integer returned in AL
0036+  0801             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0037+  0801             atoi:
0038+  0801 D8          	push b
0039+  0802 07 F3 07    	call hex_ascii_encode			; convert BL to 4bit code in AL
0040+  0805 30          	mov bl, bh
0041+  0806 DB          	push al					; save a
0042+  0807 07 F3 07    	call hex_ascii_encode
0043+  080A EA          	pop bl	
0044+  080B FD 9E 04    	shl al, 4
0045+  080E 8C          	or al, bl
0046+  080F E5          	pop b
0047+  0810 09          	ret	
0048+  0811             
0049+  0811             
0050+  0811             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  0811             ; printf
0052+  0811             ; no need for explanations!
0053+  0811             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0054+  0811             printf:
0055+  0811 09          	ret
0056+  0812             
0057+  0812             
0058+  0812             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  0812             ; scanf
0060+  0812             ; no need for explanations!
0061+  0812             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  0812             scanf:
0063+  0812 09          	ret
0064+  0813             
0065+  0813             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  0813             ; ITOA
0067+  0813             ; 8bit value in BL
0068+  0813             ; 2 byte ASCII result in A
0069+  0813             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0070+  0813             itoa:
0071+  0813 DA          	push d
0072+  0814 D8          	push b
0073+  0815 A7 00       	mov bh, 0
0074+  0817 FD A4 04    	shr bl, 4	
0075+  081A 74          	mov d, b
0076+  081B 1F D9 07    	mov al, [d + s_hex_digits]
0077+  081E 23          	mov ah, al
0078+  081F             	
0079+  081F E5          	pop b
0080+  0820 D8          	push b
0081+  0821 A7 00       	mov bh, 0
0082+  0823 FD 87 0F    	and bl, $0F
0083+  0826 74          	mov d, b
0084+  0827 1F D9 07    	mov al, [d + s_hex_digits]
0085+  082A E5          	pop b
0086+  082B E7          	pop d
0087+  082C 09          	ret
0088+  082D             
0089+  082D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0090+  082D             ; HEX STRING TO BINARY
0091+  082D             ; di = destination address
0092+  082D             ; si = source
0093+  082D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0094+  082D             hex_to_int:
0095+  082D             hex_to_int_L1:
0096+  082D F6          	lodsb					; load from [SI] to AL
0097+  082E B9 00       	cmp al, 0				; check if ASCII 0
0098+  0830 C6 3D 08    	jz hex_to_int_ret
0099+  0833 36          	mov bh, al
0100+  0834 F6          	lodsb
0101+  0835 2F          	mov bl, al
0102+  0836 07 01 08    	call atoi				; convert ASCII byte in B to int (to AL)
0103+  0839 F7          	stosb					; store AL to [DI]
0104+  083A 0A 2D 08    	jmp hex_to_int_L1
0105+  083D             hex_to_int_ret:
0106+  083D 09          	ret		
0107+  083E             
0108+  083E             
0109+  083E             
0110+  083E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  083E             ; GETCHAR
0112+  083E             ; char in ah
0113+  083E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0114+  083E             getchar:
0115+  083E DB          	push al
0116+  083F             getchar_retry:
0117+  083F FD 0C       	sti
0118+  0841 19 01       	mov al, 1
0119+  0843 05 03       	syscall sys_io			; receive in AH
0120+  0845 B9 00       	cmp al, 0			; check if any char was receive
0121+  0847 C6 3F 08    	je getchar_retry
0122+  084A E8          	pop al
0123+  084B 09          	ret
0124+  084C             
0125+  084C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0126+  084C             ; PUTCHAR
0127+  084C             ; char in ah
0128+  084C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  084C             putchar:
0130+  084C D7          	push a
0131+  084D 19 00       	mov al, 0
0132+  084F 05 03       	syscall sys_io			; char in AH
0133+  0851 E4          	pop a
0134+  0852 09          	ret
0135+  0853             
0136+  0853             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0137+  0853             ;; INPUT A STRING
0138+  0853             ;; terminates with null
0139+  0853             ;; pointer in D
0140+  0853             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  0853             gets:
0142+  0853 D7          	push a
0143+  0854 DA          	push d
0144+  0855             gets_loop:
0145+  0855 FD 0C       	sti
0146+  0857 19 01       	mov al, 1
0147+  0859 05 03       	syscall sys_io			; receive in AH
0148+  085B B9 00       	cmp al, 0				; check error code (AL)
0149+  085D C6 55 08    	je gets_loop			; if no char received, retry
0150+  0860             
0151+  0860 76 1B       	cmp ah, 27
0152+  0862 C6 7E 08    	je gets_telnet_escape
0153+  0865 76 0A       	cmp ah, $0A				; LF
0154+  0867 C6 D7 08    	je gets_end
0155+  086A 76 5C       	cmp ah, $5C				; '\\'
0156+  086C C6 AE 08    	je gets_escape
0157+  086F             	
0158+  086F 76 08       	cmp ah, $08			; check for backspace
0159+  0871 C6 7A 08    	je gets_backspace
0160+  0874             
0161+  0874 1A          	mov al, ah
0162+  0875 3E          	mov [d], al
0163+  0876 79          	inc d
0164+  0877 0A 55 08    	jmp gets_loop
0165+  087A             gets_backspace:
0166+  087A 7F          	dec d
0167+  087B 0A 55 08    	jmp gets_loop
0168+  087E             gets_telnet_escape:
0169+  087E FD 0C       	sti
0170+  0880 19 01       	mov al, 1
0171+  0882 05 03       	syscall sys_io				; receive in AH without echo
0172+  0884 B9 00       	cmp al, 0					; check error code (AL)
0173+  0886 C6 7E 08    	je gets_telnet_escape		; if no char received, retry
0174+  0889 76 5B       	cmp ah, '['
0175+  088B C7 55 08    	jne gets_loop
0176+  088E             gets_telnet_escape_phase2:
0177+  088E FD 0C       	sti
0178+  0890 19 01       	mov al, 1
0179+  0892 05 03       	syscall sys_io					; receive in AH without echo
0180+  0894 B9 00       	cmp al, 0						; check error code (AL)
0181+  0896 C6 8E 08    	je gets_telnet_escape_phase2	; if no char received, retry
0182+  0899 76 44       	cmp ah, 'D'
0183+  089B C6 A6 08    	je gets_left_arrow
0184+  089E 76 43       	cmp ah, 'C'
0185+  08A0 C6 AA 08    	je gets_right_arrow
0186+  08A3 0A 55 08    	jmp gets_loop
0187+  08A6             gets_left_arrow:
0188+  08A6 7F          	dec d
0189+  08A7 0A 55 08    	jmp gets_loop
0190+  08AA             gets_right_arrow:
0191+  08AA 79          	inc d
0192+  08AB 0A 55 08    	jmp gets_loop
0193+  08AE             gets_escape:
0194+  08AE FD 0C       	sti
0195+  08B0 19 01       	mov al, 1
0196+  08B2 05 03       	syscall sys_io			; receive in AH
0197+  08B4 B9 00       	cmp al, 0				; check error code (AL)
0198+  08B6 C6 AE 08    	je gets_escape			; if no char received, retry
0199+  08B9 76 6E       	cmp ah, 'n'
0200+  08BB C6 C9 08    	je gets_LF
0201+  08BE 76 72       	cmp ah, 'r'
0202+  08C0 C6 D0 08    	je gets_CR
0203+  08C3 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0204+  08C4 3E          	mov [d], al
0205+  08C5 79          	inc d
0206+  08C6 0A 55 08    	jmp gets_loop
0207+  08C9             gets_LF:
0208+  08C9 19 0A       	mov al, $0A
0209+  08CB 3E          	mov [d], al
0210+  08CC 79          	inc d
0211+  08CD 0A 55 08    	jmp gets_loop
0212+  08D0             gets_CR:
0213+  08D0 19 0D       	mov al, $0D
0214+  08D2 3E          	mov [d], al
0215+  08D3 79          	inc d
0216+  08D4 0A 55 08    	jmp gets_loop
0217+  08D7             gets_end:
0218+  08D7 19 00       	mov al, 0
0219+  08D9 3E          	mov [d], al				; terminate string
0220+  08DA E7          	pop d
0221+  08DB E4          	pop a
0222+  08DC 09          	ret
0223+  08DD             
0224+  08DD             
0225+  08DD             
0226+  08DD             
0227+  08DD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0228+  08DD             ;; INPUT TEXT
0229+  08DD             ;; terminated with CTRL+D
0230+  08DD             ;; pointer in D
0231+  08DD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0232+  08DD             gettxt:
0233+  08DD D7          	push a
0234+  08DE DA          	push d
0235+  08DF             gettxt_loop:
0236+  08DF 19 01       	mov al, 1
0237+  08E1 05 03       	syscall sys_io			; receive in AH
0238+  08E3 B9 00       	cmp al, 0				; check error code (AL)
0239+  08E5 C6 DF 08    	je gettxt_loop		; if no char received, retry
0240+  08E8 76 04       	cmp ah, 4			; EOT
0241+  08EA C6 28 09    	je gettxt_end
0242+  08ED 76 08       	cmp ah, $08			; check for backspace
0243+  08EF C6 24 09    	je gettxt_backspace
0244+  08F2 76 5C       	cmp ah, $5C				; '\\'
0245+  08F4 C6 FD 08    	je gettxt_escape
0246+  08F7 1A          	mov al, ah
0247+  08F8 3E          	mov [d], al
0248+  08F9 79          	inc d
0249+  08FA 0A DF 08    	jmp gettxt_loop
0250+  08FD             gettxt_escape:
0251+  08FD 19 01       	mov al, 1
0252+  08FF 05 03       	syscall sys_io			; receive in AH
0253+  0901 B9 00       	cmp al, 0				; check error code (AL)
0254+  0903 C6 FD 08    	je gettxt_escape		; if no char received, retry
0255+  0906 76 6E       	cmp ah, 'n'
0256+  0908 C6 16 09    	je gettxt_LF
0257+  090B 76 72       	cmp ah, 'r'
0258+  090D C6 1D 09    	je gettxt_CR
0259+  0910 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0260+  0911 3E          	mov [d], al
0261+  0912 79          	inc d
0262+  0913 0A DF 08    	jmp gettxt_loop
0263+  0916             gettxt_LF:
0264+  0916 19 0A       	mov al, $0A
0265+  0918 3E          	mov [d], al
0266+  0919 79          	inc d
0267+  091A 0A DF 08    	jmp gettxt_loop
0268+  091D             gettxt_CR:
0269+  091D 19 0D       	mov al, $0D
0270+  091F 3E          	mov [d], al
0271+  0920 79          	inc d
0272+  0921 0A DF 08    	jmp gettxt_loop
0273+  0924             gettxt_backspace:
0274+  0924 7F          	dec d
0275+  0925 0A DF 08    	jmp gettxt_loop
0276+  0928             gettxt_end:
0277+  0928 19 00       	mov al, 0
0278+  092A 3E          	mov [d], al				; terminate string
0279+  092B E7          	pop d
0280+  092C E4          	pop a
0281+  092D 09          	ret
0282+  092E             
0283+  092E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0284+  092E             ; PRINT NEW LINE
0285+  092E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0286+  092E             printnl:
0287+  092E D7          	push a
0288+  092F 10 00 0A    	mov a, $0A00
0289+  0932 05 03       	syscall sys_io
0290+  0934 10 00 0D    	mov a, $0D00
0291+  0937 05 03       	syscall sys_io
0292+  0939 E4          	pop a
0293+  093A 09          	ret
0294+  093B             
0295+  093B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0296+  093B             ; strtoint
0297+  093B             ; 4 digit hex string number in d
0298+  093B             ; integer returned in A
0299+  093B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0300+  093B             strtointx:
0301+  093B D8          	push b
0302+  093C 32          	mov bl, [d]
0303+  093D 37          	mov bh, bl
0304+  093E 33 01 00    	mov bl, [d + 1]
0305+  0941 07 01 08    	call atoi				; convert to int in AL
0306+  0944 23          	mov ah, al				; move to AH
0307+  0945 33 02 00    	mov bl, [d + 2]
0308+  0948 37          	mov bh, bl
0309+  0949 33 03 00    	mov bl, [d + 3]
0310+  094C 07 01 08    	call atoi				; convert to int in AL
0311+  094F E5          	pop b
0312+  0950 09          	ret
0313+  0951             
0314+  0951             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0315+  0951             ; strtoint
0316+  0951             ; 5 digit base10 string number in d
0317+  0951             ; integer returned in A
0318+  0951             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0319+  0951             strtoint:
0320+  0951 E2          	push si
0321+  0952 D8          	push b
0322+  0953 D9          	push c
0323+  0954 DA          	push d
0324+  0955 07 89 07    	call strlen			; get string length in C
0325+  0958 7E          	dec c
0326+  0959 FD 4E       	mov si, d
0327+  095B 12          	mov a, c
0328+  095C FD 99       	shl a
0329+  095E 3B E9 07    	mov d, table_power
0330+  0961 59          	add d, a
0331+  0962 38 00 00    	mov c, 0
0332+  0965             strtoint_L0:
0333+  0965 F6          	lodsb			; load ASCII to al
0334+  0966 B9 00       	cmp al, 0
0335+  0968 C6 7B 09    	je strtoint_end
0336+  096B 6F 30       	sub al, $30		; make into integer
0337+  096D 22 00       	mov ah, 0
0338+  096F 2A          	mov b, [d]
0339+  0970 AC          	mul a, b			; result in B since it fits in 16bits
0340+  0971 11          	mov a, b
0341+  0972 28          	mov b, c
0342+  0973 54          	add a, b
0343+  0974 39          	mov c, a
0344+  0975 63 02 00    	sub d, 2
0345+  0978 0A 65 09    	jmp strtoint_L0
0346+  097B             strtoint_end:
0347+  097B 12          	mov a, c
0348+  097C E7          	pop d
0349+  097D E6          	pop c
0350+  097E E5          	pop b
0351+  097F EF          	pop si
0352+  0980 09          	ret
0353+  0981             
0354+  0981             
0355+  0981             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  0981             ; PRINT NULL TERMINATED STRING
0357+  0981             ; pointer in D
0358+  0981             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  0981             puts:
0360+  0981 D7          	push a
0361+  0982 DA          	push d
0362+  0983             puts_L1:
0363+  0983 1E          	mov al, [d]
0364+  0984 B9 00       	cmp al, 0
0365+  0986 C6 92 09    	jz puts_END
0366+  0989 23          	mov ah, al
0367+  098A 19 00       	mov al, 0
0368+  098C 05 03       	syscall sys_io
0369+  098E 79          	inc d
0370+  098F 0A 83 09    	jmp puts_L1
0371+  0992             puts_END:
0372+  0992 E7          	pop d
0373+  0993 E4          	pop a
0374+  0994 09          	ret
0375+  0995             
0376+  0995             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0377+  0995             ; PRINT N SIZE STRING
0378+  0995             ; pointer in D
0379+  0995             ; size in C
0380+  0995             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0381+  0995             putsn:
0382+  0995 DB          	push al
0383+  0996 DA          	push d
0384+  0997 D9          	push c
0385+  0998             putsn_L0:
0386+  0998 1E          	mov al, [d]
0387+  0999 23          	mov ah, al
0388+  099A 19 00       	mov al, 0
0389+  099C 05 03       	syscall sys_io
0390+  099E 79          	inc d
0391+  099F 7E          	dec c	
0392+  09A0 C2 00 00    	cmp c, 0
0393+  09A3 C7 98 09    	jne putsn_L0
0394+  09A6             putsn_end:
0395+  09A6 E6          	pop c
0396+  09A7 E7          	pop d
0397+  09A8 E8          	pop al
0398+  09A9 09          	ret
0399+  09AA             
0400+  09AA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0401+  09AA             ; print 16bit decimal number
0402+  09AA             ; input number in A
0403+  09AA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  09AA             print_u16d:
0405+  09AA D7          	push a
0406+  09AB D8          	push b
0407+  09AC 26 10 27    	mov b, 10000
0408+  09AF AE          	div a, b			; get 10000 coeff.
0409+  09B0 07 D6 09    	call print_zero_or_space
0410+  09B3 11          	mov a, b
0411+  09B4 26 E8 03    	mov b, 1000
0412+  09B7 AE          	div a, b			; get 10000 coeff.
0413+  09B8 07 D6 09    	call print_zero_or_space
0414+  09BB 11          	mov a, b
0415+  09BC 26 64 00    	mov b, 100
0416+  09BF AE          	div a, b
0417+  09C0 07 D6 09    	call print_zero_or_space
0418+  09C3 11          	mov a, b
0419+  09C4 26 0A 00    	mov b, 10
0420+  09C7 AE          	div a, b
0421+  09C8 07 D6 09    	call print_zero_or_space
0422+  09CB 11          	mov a, b
0423+  09CC 6A 30       	add al, $30
0424+  09CE 23          	mov ah, al
0425+  09CF 19 00       	mov al, 0
0426+  09D1 05 03       	syscall sys_io	; print coeff
0427+  09D3 E5          	pop b
0428+  09D4 E4          	pop a
0429+  09D5 09          	ret
0430+  09D6             
0431+  09D6             
0432+  09D6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0433+  09D6             ; if A == 0, print space
0434+  09D6             ; else print A
0435+  09D6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  09D6             print_zero_or_space:
0437+  09D6             	; cmp a, 0
0438+  09D6             	; jne print_number
0439+  09D6             	; mov ah, $20
0440+  09D6             	; call putchar
0441+  09D6             	; ret
0442+  09D6             print_number:
0443+  09D6 6A 30       	add al, $30
0444+  09D8 23          	mov ah, al
0445+  09D9 07 4C 08    	call putchar
0446+  09DC 09          	ret
0447+  09DD             
0448+  09DD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  09DD             ; PRINT 16BIT HEX INTEGER
0450+  09DD             ; integer value in reg B
0451+  09DD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0452+  09DD             print_u16x:
0453+  09DD D7          	push a
0454+  09DE D8          	push b
0455+  09DF DD          	push bl
0456+  09E0 30          	mov bl, bh
0457+  09E1 07 13 08    	call itoa				; convert bh to char in A
0458+  09E4 2F          	mov bl, al				; save al
0459+  09E5 19 00       	mov al, 0
0460+  09E7 05 03       	syscall sys_io				; display AH
0461+  09E9 24          	mov ah, bl				; retrieve al
0462+  09EA 19 00       	mov al, 0
0463+  09EC 05 03       	syscall sys_io				; display AL
0464+  09EE             
0465+  09EE EA          	pop bl
0466+  09EF 07 13 08    	call itoa				; convert bh to char in A
0467+  09F2 2F          	mov bl, al				; save al
0468+  09F3 19 00       	mov al, 0
0469+  09F5 05 03       	syscall sys_io				; display AH
0470+  09F7 24          	mov ah, bl				; retrieve al
0471+  09F8 19 00       	mov al, 0
0472+  09FA 05 03       	syscall sys_io				; display AL
0473+  09FC             
0474+  09FC E5          	pop b
0475+  09FD E4          	pop a
0476+  09FE 09          	ret
0477+  09FF             
0478+  09FF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  09FF             ; INPUT 16BIT HEX INTEGER
0480+  09FF             ; read 16bit integer into A
0481+  09FF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0482+  09FF             scan_u16x:
0483+  09FF F8 10 00    	enter 16
0484+  0A02 D8          	push b
0485+  0A03 DA          	push d
0486+  0A04             
0487+  0A04 FA F1 FF    	lea d, [bp + -15]
0488+  0A07 07 53 08    	call gets				; get number
0489+  0A0A             
0490+  0A0A 32          	mov bl, [d]
0491+  0A0B 37          	mov bh, bl
0492+  0A0C 33 01 00    	mov bl, [d + 1]
0493+  0A0F 07 01 08    	call atoi				; convert to int in AL
0494+  0A12 23          	mov ah, al				; move to AH
0495+  0A13             
0496+  0A13 33 02 00    	mov bl, [d + 2]
0497+  0A16 37          	mov bh, bl
0498+  0A17 33 03 00    	mov bl, [d + 3]
0499+  0A1A 07 01 08    	call atoi				; convert to int in AL
0500+  0A1D             
0501+  0A1D E7          	pop d
0502+  0A1E E5          	pop b
0503+  0A1F F9          	leave
0504+  0A20 09          	ret
0505+  0A21             
0506+  0A21             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  0A21             ; PRINT 8bit HEX INTEGER
0508+  0A21             ; integer value in reg bl
0509+  0A21             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0510+  0A21             print_u8x:
0511+  0A21 D7          	push a
0512+  0A22 DD          	push bl
0513+  0A23             
0514+  0A23 07 13 08    	call itoa				; convert bl to char in A
0515+  0A26 2F          	mov bl, al				; save al
0516+  0A27 19 00       	mov al, 0
0517+  0A29 05 03       	syscall sys_io				; display AH
0518+  0A2B 24          	mov ah, bl				; retrieve al
0519+  0A2C 19 00       	mov al, 0
0520+  0A2E 05 03       	syscall sys_io				; display AL
0521+  0A30             
0522+  0A30 EA          	pop bl
0523+  0A31 E4          	pop a
0524+  0A32 09          	ret
0525+  0A33             
0526+  0A33             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  0A33             ; print 8bit decimal unsigned number
0528+  0A33             ; input number in AL
0529+  0A33             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0530+  0A33             print_u8d:
0531+  0A33 D7          	push a
0532+  0A34 D8          	push b
0533+  0A35             
0534+  0A35 22 00       	mov ah, 0
0535+  0A37 26 64 00    	mov b, 100
0536+  0A3A AE          	div a, b
0537+  0A3B D8          	push b			; save remainder
0538+  0A3C B9 00       	cmp al, 0
0539+  0A3E C6 48 0A    	je skip100
0540+  0A41 6A 30       	add al, $30
0541+  0A43 23          	mov ah, al
0542+  0A44 19 00       	mov al, 0
0543+  0A46 05 03       	syscall sys_io	; print coeff
0544+  0A48             skip100:
0545+  0A48 E4          	pop a
0546+  0A49 22 00       	mov ah, 0
0547+  0A4B 26 0A 00    	mov b, 10
0548+  0A4E AE          	div a, b
0549+  0A4F D8          	push b			; save remainder
0550+  0A50 B9 00       	cmp al, 0
0551+  0A52 C6 5C 0A    	je skip10
0552+  0A55 6A 30       	add al, $30
0553+  0A57 23          	mov ah, al
0554+  0A58 19 00       	mov al, 0
0555+  0A5A 05 03       	syscall sys_io	; print coeff
0556+  0A5C             skip10:
0557+  0A5C E4          	pop a
0558+  0A5D 1B          	mov al, bl
0559+  0A5E 6A 30       	add al, $30
0560+  0A60 23          	mov ah, al
0561+  0A61 19 00       	mov al, 0
0562+  0A63 05 03       	syscall sys_io	; print coeff
0563+  0A65 E5          	pop b
0564+  0A66 E4          	pop a
0565+  0A67 09          	ret
0566+  0A68             
0567+  0A68             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  0A68             ; INPUT 8BIT HEX INTEGER
0569+  0A68             ; read 8bit integer into AL
0570+  0A68             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0571+  0A68             scan_u8x:
0572+  0A68 F8 04 00    	enter 4
0573+  0A6B D8          	push b
0574+  0A6C DA          	push d
0575+  0A6D             
0576+  0A6D FA FD FF    	lea d, [bp + -3]
0577+  0A70 07 53 08    	call gets				; get number
0578+  0A73             
0579+  0A73 32          	mov bl, [d]
0580+  0A74 37          	mov bh, bl
0581+  0A75 33 01 00    	mov bl, [d + 1]
0582+  0A78 07 01 08    	call atoi				; convert to int in AL
0583+  0A7B             
0584+  0A7B E7          	pop d
0585+  0A7C E5          	pop b
0586+  0A7D F9          	leave
0587+  0A7E 09          	ret
0588+  0A7F             
0589+  0A7F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0590+  0A7F             ; input decimal number
0591+  0A7F             ; result in A
0592+  0A7F             ; 655'\0'
0593+  0A7F             ; low--------high
0594+  0A7F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0595+  0A7F             scan_u16d:
0596+  0A7F F8 08 00    	enter 8
0597+  0A82 E2          	push si
0598+  0A83 D8          	push b
0599+  0A84 D9          	push c
0600+  0A85 DA          	push d
0601+  0A86 FA F9 FF    	lea d, [bp +- 7]
0602+  0A89 07 53 08    	call gets
0603+  0A8C 07 89 07    	call strlen			; get string length in C
0604+  0A8F 7E          	dec c
0605+  0A90 FD 4E       	mov si, d
0606+  0A92 12          	mov a, c
0607+  0A93 FD 99       	shl a
0608+  0A95 3B E9 07    	mov d, table_power
0609+  0A98 59          	add d, a
0610+  0A99 38 00 00    	mov c, 0
0611+  0A9C             mul_loop:
0612+  0A9C F6          	lodsb			; load ASCII to al
0613+  0A9D B9 00       	cmp al, 0
0614+  0A9F C6 B2 0A    	je mul_exit
0615+  0AA2 6F 30       	sub al, $30		; make into integer
0616+  0AA4 22 00       	mov ah, 0
0617+  0AA6 2A          	mov b, [d]
0618+  0AA7 AC          	mul a, b			; result in B since it fits in 16bits
0619+  0AA8 11          	mov a, b
0620+  0AA9 28          	mov b, c
0621+  0AAA 54          	add a, b
0622+  0AAB 39          	mov c, a
0623+  0AAC 63 02 00    	sub d, 2
0624+  0AAF 0A 9C 0A    	jmp mul_loop
0625+  0AB2             mul_exit:
0626+  0AB2 12          	mov a, c
0627+  0AB3 E7          	pop d
0628+  0AB4 E6          	pop c
0629+  0AB5 E5          	pop b
0630+  0AB6 EF          	pop si
0631+  0AB7 F9          	leave
0632+  0AB8 09          	ret
0017   0AB9             .include "ctype.asm"
0001+  0AB9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0AB9             ; ctype.s
0003+  0AB9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0AB9             
0005+  0AB9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  0AB9             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  0AB9             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  0AB9             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  0AB9             ;; characters are supported.
0010+  0AB9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  0AB9             ;; isalnum 
0012+  0AB9             ;; isalpha 
0013+  0AB9             ;; islower 
0014+  0AB9             ;; isupper 
0015+  0AB9             ;; isdigit 
0016+  0AB9             ;; isxdigit
0017+  0AB9             ;; iscntrl 
0018+  0AB9             ;; isgraph 
0019+  0AB9             ;; isspace 
0020+  0AB9             ;; isblank 
0021+  0AB9             ;; isprint 
0022+  0AB9             ;; ispunct 
0023+  0AB9             ;; tolower 
0024+  0AB9             ;; toupper
0025+  0AB9             
0026+  0AB9             
0027+  0AB9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  0AB9             ;; IS ALPHANUMERIC
0029+  0AB9             ;; sets ZF according with result
0030+  0AB9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  0AB9             isalnum:
0032+  0AB9 07 D6 0A    	call isalpha
0033+  0ABC C6 C2 0A    	je isalnum_exit
0034+  0ABF 07 C3 0A    	call isdigit
0035+  0AC2             isalnum_exit:
0036+  0AC2 09          	ret	
0037+  0AC3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0AC3             ;; IS DIGIT
0039+  0AC3             ;; sets ZF according with result
0040+  0AC3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  0AC3             isdigit:
0042+  0AC3 DB          	push al
0043+  0AC4 B9 30       	cmp al, '0'
0044+  0AC6 C8 D2 0A    	jlu isdigit_false
0045+  0AC9 B9 39       	cmp al, '9'
0046+  0ACB D1 D2 0A    	jgu isdigit_false
0047+  0ACE 87 00       	and al, 0	; set ZF
0048+  0AD0 E8          	pop al
0049+  0AD1 09          	ret
0050+  0AD2             isdigit_false:
0051+  0AD2 8B 01       	or al, 1	; clear ZF
0052+  0AD4 E8          	pop al
0053+  0AD5 09          	ret	
0054+  0AD6             	
0055+  0AD6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  0AD6             ;; IS ALPHA
0057+  0AD6             ;; sets ZF according with result
0058+  0AD6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  0AD6             isalpha:
0060+  0AD6 DB          	push al
0061+  0AD7 B9 5F       	cmp al, '_'
0062+  0AD9 C6 F9 0A    	je isalpha_true
0063+  0ADC B9 2E       	cmp al, '.'
0064+  0ADE C6 F9 0A    	je isalpha_true
0065+  0AE1 B9 41       	cmp al, 'A'
0066+  0AE3 C8 F5 0A    	jlu isalpha_false
0067+  0AE6 B9 7A       	cmp al, 'z'
0068+  0AE8 D1 F5 0A    	jgu isalpha_false
0069+  0AEB B9 5A       	cmp al, 'Z'
0070+  0AED D0 F9 0A    	jleu isalpha_true
0071+  0AF0 B9 61       	cmp al, 'a'
0072+  0AF2 C9 F9 0A    	jgeu isalpha_true
0073+  0AF5             isalpha_false:
0074+  0AF5 8B 01       	or al, 1	; clear ZF
0075+  0AF7 E8          	pop al
0076+  0AF8 09          	ret
0077+  0AF9             isalpha_true:
0078+  0AF9 87 00       	and al, 0	; set ZF
0079+  0AFB E8          	pop al
0080+  0AFC 09          	ret
0081+  0AFD             
0082+  0AFD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  0AFD             ;; IS PATH-ALPHA
0084+  0AFD             ;; sets ZF according with result
0085+  0AFD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  0AFD             ispath:
0087+  0AFD DB          	push al
0088+  0AFE 07 C3 0A    	call isdigit
0089+  0B01 C6 2B 0B    	je ispath_true
0090+  0B04 B9 5F       	cmp al, '_'
0091+  0B06 C6 2B 0B    	je ispath_true
0092+  0B09 B9 2F       	cmp al, '/'
0093+  0B0B C6 2B 0B    	je ispath_true
0094+  0B0E B9 2E       	cmp al, '.'
0095+  0B10 C6 2B 0B    	je ispath_true
0096+  0B13 B9 41       	cmp al, 'A'
0097+  0B15 C8 27 0B    	jlu ispath_false
0098+  0B18 B9 7A       	cmp al, 'z'
0099+  0B1A D1 27 0B    	jgu ispath_false
0100+  0B1D B9 5A       	cmp al, 'Z'
0101+  0B1F D0 2B 0B    	jleu ispath_true
0102+  0B22 B9 61       	cmp al, 'a'
0103+  0B24 C9 2B 0B    	jgeu ispath_true
0104+  0B27             ispath_false:
0105+  0B27 8B 01       	or al, 1	; clear ZF
0106+  0B29 E8          	pop al
0107+  0B2A 09          	ret
0108+  0B2B             ispath_true:
0109+  0B2B 87 00       	and al, 0	; set ZF
0110+  0B2D E8          	pop al
0111+  0B2E 09          	ret
0112+  0B2F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  0B2F             ;; IS SPACE
0114+  0B2F             ;; sets ZF according with result
0115+  0B2F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  0B2F             isspace:
0117+  0B2F B9 20       	cmp al, $20		; ' '
0118+  0B31 C6 45 0B    	je isspace_exit
0119+  0B34 B9 09       	cmp al, $09		; '\t'
0120+  0B36 C6 45 0B    	je isspace_exit
0121+  0B39 B9 0A       	cmp al, $0A		; '\n'
0122+  0B3B C6 45 0B    	je isspace_exit
0123+  0B3E B9 0D       	cmp al, $0D		; '\r'
0124+  0B40 C6 45 0B    	je isspace_exit
0125+  0B43 B9 0B       	cmp al, $0B		; '\v'
0126+  0B45             isspace_exit:
0127+  0B45 09          	ret	
0128+  0B46             
0129+  0B46             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0B46             ; TO LOWER
0131+  0B46             ; input in AL
0132+  0B46             ; output in AL
0133+  0B46             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  0B46             to_lower:
0135+  0B46 B9 5A       	cmp al, 'Z'
0136+  0B48 D1 4D 0B    	jgu to_lower_ret
0137+  0B4B 6A 20       	add al, $20				; convert to lower case
0138+  0B4D             to_lower_ret:
0139+  0B4D 09          	ret
0140+  0B4E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  0B4E             ; TO UPPER
0142+  0B4E             ; input in AL
0143+  0B4E             ; output in AL
0144+  0B4E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  0B4E             to_upper:
0146+  0B4E B9 61       	cmp al, 'a'
0147+  0B50 C8 55 0B    	jlu to_upper_ret
0148+  0B53 6F 20       	sub al, $20			; convert to upper case
0149+  0B55             to_upper_ret:
0150+  0B55 09          	ret
0151+  0B56             
0018   0B56             
0019   0B56             .end
0020   0B56             
0021   0B56             
tasm: Number of errors = 0
