0001   0000             .include "kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0002   0000             
0003   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0005   0000             
0006   0400             .org PROC_TEXT_ORG			; origin at 1024
0007   0400             
0008   0400             ; 1) read /etc/boot.conf to find kernel filename
0009   0400             ; 2) from filename, obtain LBA address of kernel file
0010   0400             ; 3) write LBA address to bootloader sector, at address 1FF (511)
0011   0400             
0012   0400             bootloader_installer:
0013   0400             ; open /etc/boot.conf file
0014   0400             ; read image config entry
0015   0400 3B 73 04    	mov d, s_etc_bootconf			; '/etc/boot.conf'
0016   0403 FD 4D 82 04 	mov si, s_image					; config entry name is "image"
0017   0407 FD 4F 88 04 	mov di, kernel_filename		
0018   040B 07 2A 04    	call read_config
0019   040E             	
0020   040E 3B 88 04    	mov d, kernel_filename
0021   0411 07 35 0A    	call puts
0022   0414 07 E2 09    	call printnl
0023   0417             	
0024   0417 3B 88 04    	mov d, kernel_filename
0025   041A 19 13       	mov al, 19
0026   041C 05 04       	syscall sys_fileio		; obtain dirID for kernel file, in A
0027   041E 77          	inc a					; increment LBA because data starts after the header sector
0028   041F 27          	mov b, a
0029   0420 07 91 0A    	call print_u16x
0030   0423 05 0D       	syscall sys_boot_install
0031   0425             
0032   0425 07 E2 09    	call printnl
0033   0428 05 0B       	syscall sys_terminate_proc
0034   042A             
0035   042A             ; inputs:
0036   042A             ; D = filename ptr
0037   042A             ; SI = entry name ptr
0038   042A             ; DI = output value string ptr
0039   042A             read_config:
0040   042A E3          	push di
0041   042B E2          	push si
0042   042C FD 4F 0A 0C 	mov di, transient_area
0043   0430 19 14       	mov al, 20
0044   0432 05 04       	syscall sys_fileio				; read entire config file
0045   0434 10 0A 0C    	mov a, transient_area
0046   0437 42 F2 06    	mov [prog], a
0047   043A EF          	pop si
0048   043B             read_config_L0:
0049   043B 07 53 05    	call get_token
0050   043E BC F5 06 14 	cmp byte[tok], TOK_END
0051   0442 C6 6E 04    	je read_config_EOF
0052   0445 FD 4F F6 06 	mov di, tokstr
0053   0449 07 4D 08    	call strcmp
0054   044C C6 5C 04    	je read_config_found_entry
0055   044F             read_config_L0_L0:
0056   044F 07 53 05    	call get_token
0057   0452 BC F5 06 06 	cmp byte[tok], TOK_SEMI
0058   0456 C6 3B 04    	je read_config_L0
0059   0459 0A 4F 04    	jmp read_config_L0_L0
0060   045C             read_config_found_entry:
0061   045C 07 53 05    	call get_token			; bypass '=' sign
0062   045F F0          	pop di
0063   0460 14 F2 06    	mov a, [prog]
0064   0463 4D          	mov si, a
0065   0464             read_conf_L1:
0066   0464 F6          	lodsb
0067   0465 B9 3B       	cmp al, $3B				; ';'
0068   0467 C6 6F 04    	je read_config_EOF_2
0069   046A F7          	stosb
0070   046B 0A 64 04    	jmp read_conf_L1
0071   046E             read_config_EOF:
0072   046E F0          	pop di
0073   046F             read_config_EOF_2:
0074   046F 19 00       	mov al, 0
0075   0471 F7          	stosb					; terminate value with NULL
0076   0472 09          	ret
0077   0473             
0078   0473 2F 65 74 63 s_etc_bootconf:		.db "/etc/boot.conf", 0
0078   0477 2F 62 6F 6F 
0078   047B 74 2E 63 6F 
0078   047F 6E 66 00 
0079   0482 69 6D 61 67 s_image:			.db "image", 0
0079   0486 65 00 
0080   0488 00 00 00 00 kernel_filename:	.fill 64, 0
0080   048C 00 00 00 00 
0080   0490 00 00 00 00 
0080   0494 00 00 00 00 
0080   0498 00 00 00 00 
0080   049C 00 00 00 00 
0080   04A0 00 00 00 00 
0080   04A4 00 00 00 00 
0080   04A8 00 00 00 00 
0080   04AC 00 00 00 00 
0080   04B0 00 00 00 00 
0080   04B4 00 00 00 00 
0080   04B8 00 00 00 00 
0080   04BC 00 00 00 00 
0080   04C0 00 00 00 00 
0080   04C4 00 00 00 00 
0081   04C8             
0082   04C8             .include "token.asm"
0001+  04C8             TOKTYP_IDENTIFIER	.equ 0
0002+  04C8             TOKTYP_KEYWORD		.equ 1
0003+  04C8             TOKTYP_DELIMITER	.equ 2
0004+  04C8             TOKTYP_STRING		.equ 3
0005+  04C8             TOKTYP_CHAR			.equ 4
0006+  04C8             TOKTYP_NUMERIC		.equ 5
0007+  04C8             TOKTYP_END			.equ 6
0008+  04C8             
0009+  04C8             TOK_NULL			.equ 0
0010+  04C8             TOK_FSLASH			.equ 1
0011+  04C8             TOK_TIMES 			.equ 2
0012+  04C8             TOK_PLUS 			.equ 3
0013+  04C8             TOK_MINUS 			.equ 4
0014+  04C8             TOK_DOT				.equ 5
0015+  04C8             TOK_SEMI			.equ 6
0016+  04C8             TOK_ANGLE			.equ 7
0017+  04C8             TOK_TILDE			.equ 8
0018+  04C8             TOK_EQUAL			.equ 9
0019+  04C8             TOK_COLON			.equ 10
0020+  04C8             TOK_COMMA			.equ 11
0021+  04C8             
0022+  04C8             TOK_END				.equ 20
0023+  04C8             
0024+  04C8             
0025+  04C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  04C8             ;; read a full command argment from shell input buffer
0027+  04C8             ;; argument is written into tokstr
0028+  04C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  04C8             get_arg:
0030+  04C8 D7          	push a
0031+  04C9 E2          	push si
0032+  04CA E3          	push di
0033+  04CB 19 00       	mov al, 0
0034+  04CD 3D F6 06    	mov [tokstr], al			; nullify tokstr string
0035+  04D0 14 F2 06    	mov a, [prog]
0036+  04D3 4D          	mov si, a
0037+  04D4 FD 4F F6 06 	mov di, tokstr
0038+  04D8             get_arg_skip_spaces:
0039+  04D8 F6          	lodsb
0040+  04D9 07 E3 0B    	call isspace
0041+  04DC C6 D8 04    	je get_arg_skip_spaces
0042+  04DF             get_arg_L0:
0043+  04DF B9 3B       	cmp al, $3B				; check if is ';'
0044+  04E1 C6 EE 04    	je get_arg_end
0045+  04E4 B9 00       	cmp al, 0
0046+  04E6 C6 EE 04    	je get_arg_end			; check if end of input
0047+  04E9 F7          	stosb
0048+  04EA F6          	lodsb
0049+  04EB 0A DF 04    	jmp get_arg_L0
0050+  04EE             get_arg_end:
0051+  04EE 19 00       	mov al, 0
0052+  04F0 F7          	stosb
0053+  04F1 D5 01 00    	sub si, 1
0054+  04F4 4E          	mov a, si
0055+  04F5 42 F2 06    	mov [prog], a		; update pointer
0056+  04F8 F0          	pop di
0057+  04F9 EF          	pop si
0058+  04FA E4          	pop a
0059+  04FB 09          	ret
0060+  04FC             
0061+  04FC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  04FC             ;; read a path formation from shell input buffer
0063+  04FC             ;; path is written into tokstr
0064+  04FC             ;; /usr/bin
0065+  04FC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  04FC             get_path:
0067+  04FC D7          	push a
0068+  04FD E2          	push si
0069+  04FE E3          	push di
0070+  04FF 19 00       	mov al, 0
0071+  0501 3D F6 06    	mov [tokstr], al			; nullify tokstr string
0072+  0504 14 F2 06    	mov a, [prog]
0073+  0507 4D          	mov si, a
0074+  0508 FD 4F F6 06 	mov di, tokstr
0075+  050C             get_path_skip_spaces:
0076+  050C F6          	lodsb
0077+  050D 07 E3 0B    	call isspace
0078+  0510 C6 0C 05    	je get_path_skip_spaces
0079+  0513             get_path_is_pathchar:
0080+  0513 F7          	stosb
0081+  0514 F6          	lodsb
0082+  0515 07 6D 0B    	call isalnum			;check if is alphanumeric
0083+  0518 C6 13 05    	je get_path_is_pathchar
0084+  051B B9 2F       	cmp al, '/'				; check if is '/'
0085+  051D C6 13 05    	je get_path_is_pathchar
0086+  0520 19 00       	mov al, 0
0087+  0522 F7          	stosb
0088+  0523 D5 01 00    	sub si, 1
0089+  0526 4E          	mov a, si
0090+  0527 42 F2 06    	mov [prog], a		; update pointer
0091+  052A             get_path_end:
0092+  052A F0          	pop di
0093+  052B EF          	pop si
0094+  052C E4          	pop a
0095+  052D 09          	ret
0096+  052E             
0097+  052E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  052E             ;; read a line
0099+  052E             ;; line is written into tokstr
0100+  052E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  052E             get_line:
0102+  052E D7          	push a
0103+  052F E2          	push si
0104+  0530 E3          	push di
0105+  0531 19 00       	mov al, 0
0106+  0533 3D F6 06    	mov [tokstr], al			; nullify tokstr string
0107+  0536 14 F2 06    	mov a, [prog]
0108+  0539 4D          	mov si, a
0109+  053A FD 4F F6 06 	mov di, tokstr
0110+  053E             get_line_L0:
0111+  053E F6          	lodsb
0112+  053F B9 0A       	cmp al, $0A		; check for new line
0113+  0541 C6 48 05    	je get_line_exit
0114+  0544 F7          	stosb
0115+  0545 0A 3E 05    	jmp get_line_L0
0116+  0548             get_line_exit:
0117+  0548 19 00       	mov al, 0
0118+  054A F7          	stosb
0119+  054B 4E          	mov a, si
0120+  054C 42 F2 06    	mov [prog], a		; update pointer
0121+  054F F0          	pop di
0122+  0550 EF          	pop si
0123+  0551 E4          	pop a
0124+  0552 09          	ret
0125+  0553             
0126+  0553             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  0553             ;; token parser
0128+  0553             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  0553             get_token:
0130+  0553 D7          	push a
0131+  0554 DA          	push d
0132+  0555 E2          	push si
0133+  0556 E3          	push di
0134+  0557 19 00       	mov al, 0
0135+  0559 3D F6 06    	mov [tokstr], al			; nullify tokstr string
0136+  055C 19 00       	mov al, TOK_NULL
0137+  055E 3D F5 06    	mov [tok], al				; nullify token
0138+  0561 14 F2 06    	mov a, [prog]
0139+  0564 4D          	mov si, a
0140+  0565 FD 4F F6 06 	mov di, tokstr
0141+  0569             get_tok_skip_spaces:
0142+  0569 F6          	lodsb
0143+  056A 07 E3 0B    	call isspace
0144+  056D C6 69 05    	je get_tok_skip_spaces
0145+  0570 B9 00       	cmp al, 0			; check for end of input (NULL)
0146+  0572 C6 57 06    	je get_token_end
0147+  0575 B9 23       	cmp al, '#'			; comments!
0148+  0577 C6 85 06    	je get_tok_comment
0149+  057A 07 6D 0B    	call isalnum
0150+  057D C6 64 06    	jz is_alphanumeric
0151+  0580             ; other token types
0152+  0580             get_token_slash:
0153+  0580 B9 2F       	cmp al, '/'				; check if '/'
0154+  0582 C7 9A 05    	jne get_token_minus
0155+  0585 F7          	stosb					; store '/' into token string
0156+  0586 19 00       	mov al, 0
0157+  0588 F7          	stosb					; terminate token string
0158+  0589 19 01       	mov al, TOK_FSLASH
0159+  058B 3D F5 06    	mov [tok], al			
0160+  058E 19 02       	mov al, TOKTYP_DELIMITER
0161+  0590 3D F4 06    	mov [toktyp], al
0162+  0593 4E          	mov a, si
0163+  0594 42 F2 06    	mov [prog], a		; update pointer
0164+  0597 0A 80 06    	jmp get_token_return
0165+  059A             get_token_minus:
0166+  059A B9 2D       	cmp al, '-'				; check if '-'
0167+  059C C7 B4 05    	jne get_token_comma
0168+  059F F7          	stosb					; store '-' into token string
0169+  05A0 19 00       	mov al, 0
0170+  05A2 F7          	stosb					; terminate token string
0171+  05A3 19 04       	mov al, TOK_MINUS
0172+  05A5 3D F5 06    	mov [tok], al			
0173+  05A8 19 02       	mov al, TOKTYP_DELIMITER
0174+  05AA 3D F4 06    	mov [toktyp], al
0175+  05AD 4E          	mov a, si
0176+  05AE 42 F2 06    	mov [prog], a		; update pointer
0177+  05B1 0A 80 06    	jmp get_token_return
0178+  05B4             get_token_comma:
0179+  05B4 B9 2C       	cmp al, ','				; check if ','
0180+  05B6 C7 CE 05    	jne get_token_semi
0181+  05B9 F7          	stosb					; store ',' into token string
0182+  05BA 19 00       	mov al, 0
0183+  05BC F7          	stosb					; terminate token string
0184+  05BD 19 0B       	mov al, TOK_COMMA
0185+  05BF 3D F5 06    	mov [tok], al			
0186+  05C2 19 02       	mov al, TOKTYP_DELIMITER
0187+  05C4 3D F4 06    	mov [toktyp], al
0188+  05C7 4E          	mov a, si
0189+  05C8 42 F2 06    	mov [prog], a		; update pointer
0190+  05CB 0A 80 06    	jmp get_token_return
0191+  05CE             get_token_semi:
0192+  05CE B9 3B       	cmp al, $3B				; check if ';'
0193+  05D0 C7 E8 05    	jne get_token_colon
0194+  05D3 F7          	stosb					; store ';' into token string
0195+  05D4 19 00       	mov al, 0
0196+  05D6 F7          	stosb					; terminate token string
0197+  05D7 19 06       	mov al, TOK_SEMI
0198+  05D9 3D F5 06    	mov [tok], al			
0199+  05DC 19 02       	mov al, TOKTYP_DELIMITER
0200+  05DE 3D F4 06    	mov [toktyp], al
0201+  05E1 4E          	mov a, si
0202+  05E2 42 F2 06    	mov [prog], a		; update pointer
0203+  05E5 0A 80 06    	jmp get_token_return
0204+  05E8             get_token_colon:
0205+  05E8 B9 3A       	cmp al, $3A				; check if ':'
0206+  05EA C7 02 06    	jne get_token_angle
0207+  05ED F7          	stosb					; store ':' into token string
0208+  05EE 19 00       	mov al, 0
0209+  05F0 F7          	stosb					; terminate token string
0210+  05F1 19 0A       	mov al, TOK_COLON
0211+  05F3 3D F5 06    	mov [tok], al			
0212+  05F6 19 02       	mov al, TOKTYP_DELIMITER
0213+  05F8 3D F4 06    	mov [toktyp], al
0214+  05FB 4E          	mov a, si
0215+  05FC 42 F2 06    	mov [prog], a		; update pointer
0216+  05FF 0A 80 06    	jmp get_token_return
0217+  0602             get_token_angle:
0218+  0602 B9 3E       	cmp al, $3E				; check if '>'
0219+  0604 C7 1C 06    	jne get_token_tilde
0220+  0607 F7          	stosb					; store '>' into token string
0221+  0608 19 00       	mov al, 0
0222+  060A F7          	stosb					; terminate token string
0223+  060B 19 07       	mov al, TOK_ANGLE
0224+  060D 3D F5 06    	mov [tok], al			
0225+  0610 19 02       	mov al, TOKTYP_DELIMITER
0226+  0612 3D F4 06    	mov [toktyp], al
0227+  0615 4E          	mov a, si
0228+  0616 42 F2 06    	mov [prog], a		; update pointer
0229+  0619 0A 80 06    	jmp get_token_return
0230+  061C             get_token_tilde:
0231+  061C B9 7E       	cmp al, '~'				; check if '~'
0232+  061E C7 36 06    	jne get_token_equal
0233+  0621 F7          	stosb					; store '~' into token string
0234+  0622 19 00       	mov al, 0
0235+  0624 F7          	stosb					; terminate token string
0236+  0625 19 08       	mov al, TOK_TILDE
0237+  0627 3D F5 06    	mov [tok], al			
0238+  062A 19 02       	mov al, TOKTYP_DELIMITER
0239+  062C 3D F4 06    	mov [toktyp], al
0240+  062F 4E          	mov a, si
0241+  0630 42 F2 06    	mov [prog], a		; update pointer
0242+  0633 0A 80 06    	jmp get_token_return
0243+  0636             get_token_equal:
0244+  0636 B9 3D       	cmp al, '='				; check if '='
0245+  0638 C7 50 06    	jne get_token_skip
0246+  063B F7          	stosb					; store '=' into token string
0247+  063C 19 00       	mov al, 0
0248+  063E F7          	stosb					; terminate token string
0249+  063F 19 09       	mov al, TOK_EQUAL
0250+  0641 3D F5 06    	mov [tok], al			
0251+  0644 19 02       	mov al, TOKTYP_DELIMITER
0252+  0646 3D F4 06    	mov [toktyp], al
0253+  0649 4E          	mov a, si
0254+  064A 42 F2 06    	mov [prog], a		; update pointer
0255+  064D 0A 80 06    	jmp get_token_return
0256+  0650             get_token_skip:
0257+  0650 4E          	mov a, si
0258+  0651 42 F2 06    	mov [prog], a		; update pointer
0259+  0654 0A 80 06    	jmp get_token_return
0260+  0657             get_token_end:				; end of file token
0261+  0657 19 14       	mov al, TOK_END
0262+  0659 3D F5 06    	mov [tok], al
0263+  065C 19 06       	mov al, TOKTYP_END
0264+  065E 3D F4 06    	mov [toktyp], al
0265+  0661 0A 80 06    	jmp get_token_return
0266+  0664             is_alphanumeric:
0267+  0664 F7          	stosb
0268+  0665 F6          	lodsb
0269+  0666 07 6D 0B    	call isalnum			;check if is alphanumeric
0270+  0669 C6 64 06    	jz is_alphanumeric
0271+  066C B9 2E       	cmp al, $2E				; check if is '.'
0272+  066E C6 64 06    	je is_alphanumeric
0273+  0671 19 00       	mov al, 0
0274+  0673 F7          	stosb
0275+  0674 19 00       	mov al, TOKTYP_IDENTIFIER
0276+  0676 3D F4 06    	mov [toktyp], al
0277+  0679 D5 01 00    	sub si, 1
0278+  067C 4E          	mov a, si
0279+  067D 42 F2 06    	mov [prog], a		; update pointer
0280+  0680             get_token_return:
0281+  0680 F0          	pop di
0282+  0681 EF          	pop si
0283+  0682 E7          	pop d
0284+  0683 E4          	pop a
0285+  0684 09          	ret
0286+  0685             get_tok_comment:
0287+  0685 F6          	lodsb
0288+  0686 B9 0A       	cmp al, $0A			; new line
0289+  0688 C7 85 06    	jne get_tok_comment
0290+  068B 0A 69 05    	jmp get_tok_skip_spaces
0291+  068E             
0292+  068E             
0293+  068E             get_number:
0294+  068E D7          	push a
0295+  068F DA          	push d
0296+  0690 E2          	push si
0297+  0691 E3          	push di
0298+  0692 19 00       	mov al, 0
0299+  0694 3D F6 06    	mov [tokstr], al			; nullify tokstr string
0300+  0697 19 00       	mov al, TOK_NULL
0301+  0699 3D F5 06    	mov [tok], al				; nullify token
0302+  069C 14 F2 06    	mov a, [prog]
0303+  069F 4D          	mov si, a
0304+  06A0 FD 4F F6 06 	mov di, tokstr
0305+  06A4             get_number_skip_spaces:
0306+  06A4 F6          	lodsb
0307+  06A5 07 E3 0B    	call isspace
0308+  06A8 C6 A4 06    	je get_number_skip_spaces
0309+  06AB B9 00       	cmp al, 0			; check for end of input (NULL)
0310+  06AD C7 BD 06    	jne get_number_L0
0311+  06B0 19 14       	mov al, TOK_END
0312+  06B2 3D F5 06    	mov [tok], al
0313+  06B5 19 06       	mov al, TOKTYP_END
0314+  06B7 3D F4 06    	mov [toktyp], al
0315+  06BA 0A D4 06    	jmp get_number_return
0316+  06BD             get_number_L0:
0317+  06BD F7          	stosb
0318+  06BE F6          	lodsb
0319+  06BF 07 77 0B    	call isdigit			;check if is numeric
0320+  06C2 C6 BD 06    	jz get_number_L0
0321+  06C5 19 00       	mov al, 0
0322+  06C7 F7          	stosb
0323+  06C8 19 05       	mov al, TOKTYP_NUMERIC
0324+  06CA 3D F4 06    	mov [toktyp], al
0325+  06CD D5 01 00    	sub si, 1
0326+  06D0 4E          	mov a, si
0327+  06D1 42 F2 06    	mov [prog], a		; update pointer
0328+  06D4             get_number_return:
0329+  06D4 F0          	pop di
0330+  06D5 EF          	pop si
0331+  06D6 E7          	pop d
0332+  06D7 E4          	pop a
0333+  06D8 09          	ret
0334+  06D9             
0335+  06D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  06D9             ;; PUT BACK TOKEN
0337+  06D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
0338+  06D9             putback:
0339+  06D9 D7          	push a
0340+  06DA E2          	push si
0341+  06DB FD 4D F6 06 	mov si, tokstr	
0342+  06DF             putback_loop:
0343+  06DF F6          	lodsb
0344+  06E0 B9 00       	cmp al, 0
0345+  06E2 C6 EF 06    	je putback_end
0346+  06E5 14 F2 06    	mov a, [prog]
0347+  06E8 7D          	dec a
0348+  06E9 42 F2 06    	mov [prog], a			; update pointer
0349+  06EC 0A DF 06    	jmp putback_loop
0350+  06EF             putback_end:
0351+  06EF EF          	pop si
0352+  06F0 E4          	pop a
0353+  06F1 09          	ret
0354+  06F2             
0355+  06F2             
0356+  06F2             
0357+  06F2             
0358+  06F2 00 00       prog:		.dw 0			; pointer to current position in buffer
0359+  06F4             
0360+  06F4 00          toktyp: 	.db 0			; token type symbol
0361+  06F5 00          tok:		.db 0			; current token symbol
0362+  06F6 00 00 00 00 tokstr:		.fill 256, 0	; token as a string
0362+  06FA 00 00 00 00 
0362+  06FE 00 00 00 00 
0362+  0702 00 00 00 00 
0362+  0706 00 00 00 00 
0362+  070A 00 00 00 00 
0362+  070E 00 00 00 00 
0362+  0712 00 00 00 00 
0362+  0716 00 00 00 00 
0362+  071A 00 00 00 00 
0362+  071E 00 00 00 00 
0362+  0722 00 00 00 00 
0362+  0726 00 00 00 00 
0362+  072A 00 00 00 00 
0362+  072E 00 00 00 00 
0362+  0732 00 00 00 00 
0362+  0736 00 00 00 00 
0362+  073A 00 00 00 00 
0362+  073E 00 00 00 00 
0362+  0742 00 00 00 00 
0362+  0746 00 00 00 00 
0362+  074A 00 00 00 00 
0362+  074E 00 00 00 00 
0362+  0752 00 00 00 00 
0362+  0756 00 00 00 00 
0362+  075A 00 00 00 00 
0362+  075E 00 00 00 00 
0362+  0762 00 00 00 00 
0362+  0766 00 00 00 00 
0362+  076A 00 00 00 00 
0362+  076E 00 00 00 00 
0362+  0772 00 00 00 00 
0362+  0776 00 00 00 00 
0362+  077A 00 00 00 00 
0362+  077E 00 00 00 00 
0362+  0782 00 00 00 00 
0362+  0786 00 00 00 00 
0362+  078A 00 00 00 00 
0362+  078E 00 00 00 00 
0362+  0792 00 00 00 00 
0362+  0796 00 00 00 00 
0362+  079A 00 00 00 00 
0362+  079E 00 00 00 00 
0362+  07A2 00 00 00 00 
0362+  07A6 00 00 00 00 
0362+  07AA 00 00 00 00 
0362+  07AE 00 00 00 00 
0362+  07B2 00 00 00 00 
0362+  07B6 00 00 00 00 
0362+  07BA 00 00 00 00 
0362+  07BE 00 00 00 00 
0362+  07C2 00 00 00 00 
0362+  07C6 00 00 00 00 
0362+  07CA 00 00 00 00 
0362+  07CE 00 00 00 00 
0362+  07D2 00 00 00 00 
0362+  07D6 00 00 00 00 
0362+  07DA 00 00 00 00 
0362+  07DE 00 00 00 00 
0362+  07E2 00 00 00 00 
0362+  07E6 00 00 00 00 
0362+  07EA 00 00 00 00 
0362+  07EE 00 00 00 00 
0362+  07F2 00 00 00 00 
0083   07F6             .include "stdio.asm"
0001+  07F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  07F6             ; stdio.s
0003+  07F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  07F6             .include "string.asm"
0001++ 07F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 07F6             ; string.s
0003++ 07F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 07F6             
0005++ 07F6             
0006++ 07F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 07F6             ; strrev
0008++ 07F6             ; reverse a string
0009++ 07F6             ; D = string address
0010++ 07F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 07F6             ; 01234
0012++ 07F6             strrev:
0013++ 07F6 4B          	pusha
0014++ 07F7 07 3D 08    	call strlen	; length in C
0015++ 07FA 12          	mov a, c
0016++ 07FB AF 01 00    	cmp a, 1
0017++ 07FE D0 18 08    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0801 7D          	dec a
0019++ 0802 FD 4E       	mov si, d	; beginning of string
0020++ 0804 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0806 59          	add d, a	; end of string
0022++ 0807 12          	mov a, c
0023++ 0808 FD 9B       	shr a		; divide by 2
0024++ 080A 39          	mov c, a	; C now counts the steps
0025++ 080B             strrev_L0:
0026++ 080B 32          	mov bl, [d]	; save load right-side char into BL
0027++ 080C F6          	lodsb		; load left-side char into AL; increase SI
0028++ 080D 3E          	mov [d], al	; store left char into right side
0029++ 080E 1B          	mov al, bl
0030++ 080F F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0810 7E          	dec c
0032++ 0811 7F          	dec d
0033++ 0812 C2 00 00    	cmp c, 0
0034++ 0815 C7 0B 08    	jne strrev_L0
0035++ 0818             strrev_end:
0036++ 0818 4C          	popa
0037++ 0819 09          	ret
0038++ 081A             	
0039++ 081A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 081A             ; strchr
0041++ 081A             ; search string in D for char in AL
0042++ 081A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 081A             strchr:
0044++ 081A             strchr_L0:
0045++ 081A 32          	mov bl, [d]
0046++ 081B C1 00       	cmp bl, 0
0047++ 081D C6 28 08    	je strchr_end
0048++ 0820 BA          	cmp al, bl
0049++ 0821 C6 28 08    	je strchr_end
0050++ 0824 79          	inc d
0051++ 0825 0A 1A 08    	jmp strchr_L0
0052++ 0828             strchr_end:
0053++ 0828 1B          	mov al, bl
0054++ 0829 09          	ret
0055++ 082A             
0056++ 082A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 082A             ; strstr
0058++ 082A             ; find sub-string
0059++ 082A             ; str1 in SI
0060++ 082A             ; str2 in DI
0061++ 082A             ; SI points to end of source string
0062++ 082A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 082A             strstr:
0064++ 082A DB          	push al
0065++ 082B DA          	push d
0066++ 082C E3          	push di
0067++ 082D             strstr_loop:
0068++ 082D F3          	cmpsb					; compare a byte of the strings
0069++ 082E C7 39 08    	jne strstr_ret
0070++ 0831 FC 00 00    	lea d, [di + 0]
0071++ 0834 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0836 C7 2D 08    	jne strstr_loop				; equal chars but not at end
0073++ 0839             strstr_ret:
0074++ 0839 F0          	pop di
0075++ 083A E7          	pop d
0076++ 083B E8          	pop al
0077++ 083C 09          	ret
0078++ 083D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 083D             ; length of null terminated string
0080++ 083D             ; result in C
0081++ 083D             ; pointer in D
0082++ 083D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 083D             strlen:
0084++ 083D DA          	push d
0085++ 083E 38 00 00    	mov c, 0
0086++ 0841             strlen_L1:
0087++ 0841 BD 00       	cmp byte [d], 0
0088++ 0843 C6 4B 08    	je strlen_ret
0089++ 0846 79          	inc d
0090++ 0847 78          	inc c
0091++ 0848 0A 41 08    	jmp strlen_L1
0092++ 084B             strlen_ret:
0093++ 084B E7          	pop d
0094++ 084C 09          	ret
0095++ 084D             
0096++ 084D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 084D             ; STRCMP
0098++ 084D             ; compare two strings
0099++ 084D             ; str1 in SI
0100++ 084D             ; str2 in DI
0101++ 084D             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 084D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 084D             strcmp:
0104++ 084D DB          	push al
0105++ 084E DA          	push d
0106++ 084F E3          	push di
0107++ 0850 E2          	push si
0108++ 0851             strcmp_loop:
0109++ 0851 F3          	cmpsb					; compare a byte of the strings
0110++ 0852 C7 5D 08    	jne strcmp_ret
0111++ 0855 FB FF FF    	lea d, [si +- 1]
0112++ 0858 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 085A C7 51 08    	jne strcmp_loop				; equal chars but not at end
0114++ 085D             strcmp_ret:
0115++ 085D EF          	pop si
0116++ 085E F0          	pop di
0117++ 085F E7          	pop d
0118++ 0860 E8          	pop al
0119++ 0861 09          	ret
0120++ 0862             
0121++ 0862             
0122++ 0862             ; STRCPY
0123++ 0862             ; copy null terminated string from SI to DI
0124++ 0862             ; source in SI
0125++ 0862             ; destination in DI
0126++ 0862             strcpy:
0127++ 0862 E2          	push si
0128++ 0863 E3          	push di
0129++ 0864 DB          	push al
0130++ 0865             strcpy_L1:
0131++ 0865 F6          	lodsb
0132++ 0866 F7          	stosb
0133++ 0867 B9 00       	cmp al, 0
0134++ 0869 C7 65 08    	jne strcpy_L1
0135++ 086C             strcpy_end:
0136++ 086C E8          	pop al
0137++ 086D F0          	pop di
0138++ 086E EF          	pop si
0139++ 086F 09          	ret
0140++ 0870             
0141++ 0870             ; STRCAT
0142++ 0870             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0870             ; source in SI
0144++ 0870             ; destination in DI
0145++ 0870             strcat:
0146++ 0870 E2          	push si
0147++ 0871 E3          	push di
0148++ 0872 D7          	push a
0149++ 0873 DA          	push d
0150++ 0874 50          	mov a, di
0151++ 0875 3C          	mov d, a
0152++ 0876             strcat_goto_end_L1:
0153++ 0876 BD 00       	cmp byte[d], 0
0154++ 0878 C6 7F 08    	je strcat_start
0155++ 087B 79          	inc d
0156++ 087C 0A 76 08    	jmp strcat_goto_end_L1
0157++ 087F             strcat_start:
0158++ 087F FD 50       	mov di, d
0159++ 0881             strcat_L1:
0160++ 0881 F6          	lodsb
0161++ 0882 F7          	stosb
0162++ 0883 B9 00       	cmp al, 0
0163++ 0885 C7 81 08    	jne strcat_L1
0164++ 0888             strcat_end:
0165++ 0888 E7          	pop d
0166++ 0889 E4          	pop a
0167++ 088A F0          	pop di
0168++ 088B EF          	pop si
0169++ 088C 09          	ret
0005+  088D             
0006+  088D 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  0891 34 35 36 37 
0006+  0895 38 39 41 42 
0006+  0899 43 44 45 46 
0007+  089D             
0008+  089D 01 00       table_power:.dw 1
0009+  089F 0A 00       			.dw 10
0010+  08A1 64 00       			.dw 100
0011+  08A3 E8 03       			.dw 1000
0012+  08A5 10 27       			.dw 10000
0013+  08A7             
0014+  08A7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0015+  08A7             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0016+  08A7             ; ASCII in BL
0017+  08A7             ; result in AL
0018+  08A7             ; ascii for F = 0100 0110
0019+  08A7             ; ascii for 9 = 0011 1001
0020+  08A7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0021+  08A7             hex_ascii_encode:
0022+  08A7 1B          	mov al, bl
0023+  08A8 93 40       	test al, $40				; test if letter or number
0024+  08AA C7 B0 08    	jnz hex_letter
0025+  08AD 87 0F       	and al, $0F				; get number
0026+  08AF 09          	ret
0027+  08B0             hex_letter:
0028+  08B0 87 0F       	and al, $0F				; get letter
0029+  08B2 6A 09       	add al, 9
0030+  08B4 09          	ret
0031+  08B5             
0032+  08B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0033+  08B5             ; ATOI
0034+  08B5             ; 2 letter hex string in B
0035+  08B5             ; 8bit integer returned in AL
0036+  08B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0037+  08B5             atoi:
0038+  08B5 D8          	push b
0039+  08B6 07 A7 08    	call hex_ascii_encode			; convert BL to 4bit code in AL
0040+  08B9 30          	mov bl, bh
0041+  08BA DB          	push al					; save a
0042+  08BB 07 A7 08    	call hex_ascii_encode
0043+  08BE EA          	pop bl	
0044+  08BF FD 9E 04    	shl al, 4
0045+  08C2 8C          	or al, bl
0046+  08C3 E5          	pop b
0047+  08C4 09          	ret	
0048+  08C5             
0049+  08C5             
0050+  08C5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  08C5             ; printf
0052+  08C5             ; no need for explanations!
0053+  08C5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0054+  08C5             printf:
0055+  08C5 09          	ret
0056+  08C6             
0057+  08C6             
0058+  08C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  08C6             ; scanf
0060+  08C6             ; no need for explanations!
0061+  08C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  08C6             scanf:
0063+  08C6 09          	ret
0064+  08C7             
0065+  08C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  08C7             ; ITOA
0067+  08C7             ; 8bit value in BL
0068+  08C7             ; 2 byte ASCII result in A
0069+  08C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0070+  08C7             itoa:
0071+  08C7 DA          	push d
0072+  08C8 D8          	push b
0073+  08C9 A7 00       	mov bh, 0
0074+  08CB FD A4 04    	shr bl, 4	
0075+  08CE 74          	mov d, b
0076+  08CF 1F 8D 08    	mov al, [d + s_hex_digits]
0077+  08D2 23          	mov ah, al
0078+  08D3             	
0079+  08D3 E5          	pop b
0080+  08D4 D8          	push b
0081+  08D5 A7 00       	mov bh, 0
0082+  08D7 FD 87 0F    	and bl, $0F
0083+  08DA 74          	mov d, b
0084+  08DB 1F 8D 08    	mov al, [d + s_hex_digits]
0085+  08DE E5          	pop b
0086+  08DF E7          	pop d
0087+  08E0 09          	ret
0088+  08E1             
0089+  08E1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0090+  08E1             ; HEX STRING TO BINARY
0091+  08E1             ; di = destination address
0092+  08E1             ; si = source
0093+  08E1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0094+  08E1             hex_to_int:
0095+  08E1             hex_to_int_L1:
0096+  08E1 F6          	lodsb					; load from [SI] to AL
0097+  08E2 B9 00       	cmp al, 0				; check if ASCII 0
0098+  08E4 C6 F1 08    	jz hex_to_int_ret
0099+  08E7 36          	mov bh, al
0100+  08E8 F6          	lodsb
0101+  08E9 2F          	mov bl, al
0102+  08EA 07 B5 08    	call atoi				; convert ASCII byte in B to int (to AL)
0103+  08ED F7          	stosb					; store AL to [DI]
0104+  08EE 0A E1 08    	jmp hex_to_int_L1
0105+  08F1             hex_to_int_ret:
0106+  08F1 09          	ret		
0107+  08F2             
0108+  08F2             
0109+  08F2             
0110+  08F2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  08F2             ; GETCHAR
0112+  08F2             ; char in ah
0113+  08F2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0114+  08F2             getchar:
0115+  08F2 DB          	push al
0116+  08F3             getchar_retry:
0117+  08F3 FD 0C       	sti
0118+  08F5 19 01       	mov al, 1
0119+  08F7 05 03       	syscall sys_io			; receive in AH
0120+  08F9 B9 00       	cmp al, 0			; check if any char was receive
0121+  08FB C6 F3 08    	je getchar_retry
0122+  08FE E8          	pop al
0123+  08FF 09          	ret
0124+  0900             
0125+  0900             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0126+  0900             ; PUTCHAR
0127+  0900             ; char in ah
0128+  0900             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  0900             putchar:
0130+  0900 D7          	push a
0131+  0901 19 00       	mov al, 0
0132+  0903 05 03       	syscall sys_io			; char in AH
0133+  0905 E4          	pop a
0134+  0906 09          	ret
0135+  0907             
0136+  0907             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0137+  0907             ;; INPUT A STRING
0138+  0907             ;; terminates with null
0139+  0907             ;; pointer in D
0140+  0907             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  0907             gets:
0142+  0907 D7          	push a
0143+  0908 DA          	push d
0144+  0909             gets_loop:
0145+  0909 FD 0C       	sti
0146+  090B 19 01       	mov al, 1
0147+  090D 05 03       	syscall sys_io			; receive in AH
0148+  090F B9 00       	cmp al, 0				; check error code (AL)
0149+  0911 C6 09 09    	je gets_loop			; if no char received, retry
0150+  0914             
0151+  0914 76 1B       	cmp ah, 27
0152+  0916 C6 32 09    	je gets_telnet_escape
0153+  0919 76 0A       	cmp ah, $0A				; LF
0154+  091B C6 8B 09    	je gets_end
0155+  091E 76 5C       	cmp ah, $5C				; '\\'
0156+  0920 C6 62 09    	je gets_escape
0157+  0923             	
0158+  0923 76 08       	cmp ah, $08			; check for backspace
0159+  0925 C6 2E 09    	je gets_backspace
0160+  0928             
0161+  0928 1A          	mov al, ah
0162+  0929 3E          	mov [d], al
0163+  092A 79          	inc d
0164+  092B 0A 09 09    	jmp gets_loop
0165+  092E             gets_backspace:
0166+  092E 7F          	dec d
0167+  092F 0A 09 09    	jmp gets_loop
0168+  0932             gets_telnet_escape:
0169+  0932 FD 0C       	sti
0170+  0934 19 01       	mov al, 1
0171+  0936 05 03       	syscall sys_io				; receive in AH without echo
0172+  0938 B9 00       	cmp al, 0					; check error code (AL)
0173+  093A C6 32 09    	je gets_telnet_escape		; if no char received, retry
0174+  093D 76 5B       	cmp ah, '['
0175+  093F C7 09 09    	jne gets_loop
0176+  0942             gets_telnet_escape_phase2:
0177+  0942 FD 0C       	sti
0178+  0944 19 01       	mov al, 1
0179+  0946 05 03       	syscall sys_io					; receive in AH without echo
0180+  0948 B9 00       	cmp al, 0						; check error code (AL)
0181+  094A C6 42 09    	je gets_telnet_escape_phase2	; if no char received, retry
0182+  094D 76 44       	cmp ah, 'D'
0183+  094F C6 5A 09    	je gets_left_arrow
0184+  0952 76 43       	cmp ah, 'C'
0185+  0954 C6 5E 09    	je gets_right_arrow
0186+  0957 0A 09 09    	jmp gets_loop
0187+  095A             gets_left_arrow:
0188+  095A 7F          	dec d
0189+  095B 0A 09 09    	jmp gets_loop
0190+  095E             gets_right_arrow:
0191+  095E 79          	inc d
0192+  095F 0A 09 09    	jmp gets_loop
0193+  0962             gets_escape:
0194+  0962 FD 0C       	sti
0195+  0964 19 01       	mov al, 1
0196+  0966 05 03       	syscall sys_io			; receive in AH
0197+  0968 B9 00       	cmp al, 0				; check error code (AL)
0198+  096A C6 62 09    	je gets_escape			; if no char received, retry
0199+  096D 76 6E       	cmp ah, 'n'
0200+  096F C6 7D 09    	je gets_LF
0201+  0972 76 72       	cmp ah, 'r'
0202+  0974 C6 84 09    	je gets_CR
0203+  0977 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0204+  0978 3E          	mov [d], al
0205+  0979 79          	inc d
0206+  097A 0A 09 09    	jmp gets_loop
0207+  097D             gets_LF:
0208+  097D 19 0A       	mov al, $0A
0209+  097F 3E          	mov [d], al
0210+  0980 79          	inc d
0211+  0981 0A 09 09    	jmp gets_loop
0212+  0984             gets_CR:
0213+  0984 19 0D       	mov al, $0D
0214+  0986 3E          	mov [d], al
0215+  0987 79          	inc d
0216+  0988 0A 09 09    	jmp gets_loop
0217+  098B             gets_end:
0218+  098B 19 00       	mov al, 0
0219+  098D 3E          	mov [d], al				; terminate string
0220+  098E E7          	pop d
0221+  098F E4          	pop a
0222+  0990 09          	ret
0223+  0991             
0224+  0991             
0225+  0991             
0226+  0991             
0227+  0991             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0228+  0991             ;; INPUT TEXT
0229+  0991             ;; terminated with CTRL+D
0230+  0991             ;; pointer in D
0231+  0991             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0232+  0991             gettxt:
0233+  0991 D7          	push a
0234+  0992 DA          	push d
0235+  0993             gettxt_loop:
0236+  0993 19 01       	mov al, 1
0237+  0995 05 03       	syscall sys_io			; receive in AH
0238+  0997 B9 00       	cmp al, 0				; check error code (AL)
0239+  0999 C6 93 09    	je gettxt_loop		; if no char received, retry
0240+  099C 76 04       	cmp ah, 4			; EOT
0241+  099E C6 DC 09    	je gettxt_end
0242+  09A1 76 08       	cmp ah, $08			; check for backspace
0243+  09A3 C6 D8 09    	je gettxt_backspace
0244+  09A6 76 5C       	cmp ah, $5C				; '\\'
0245+  09A8 C6 B1 09    	je gettxt_escape
0246+  09AB 1A          	mov al, ah
0247+  09AC 3E          	mov [d], al
0248+  09AD 79          	inc d
0249+  09AE 0A 93 09    	jmp gettxt_loop
0250+  09B1             gettxt_escape:
0251+  09B1 19 01       	mov al, 1
0252+  09B3 05 03       	syscall sys_io			; receive in AH
0253+  09B5 B9 00       	cmp al, 0				; check error code (AL)
0254+  09B7 C6 B1 09    	je gettxt_escape		; if no char received, retry
0255+  09BA 76 6E       	cmp ah, 'n'
0256+  09BC C6 CA 09    	je gettxt_LF
0257+  09BF 76 72       	cmp ah, 'r'
0258+  09C1 C6 D1 09    	je gettxt_CR
0259+  09C4 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0260+  09C5 3E          	mov [d], al
0261+  09C6 79          	inc d
0262+  09C7 0A 93 09    	jmp gettxt_loop
0263+  09CA             gettxt_LF:
0264+  09CA 19 0A       	mov al, $0A
0265+  09CC 3E          	mov [d], al
0266+  09CD 79          	inc d
0267+  09CE 0A 93 09    	jmp gettxt_loop
0268+  09D1             gettxt_CR:
0269+  09D1 19 0D       	mov al, $0D
0270+  09D3 3E          	mov [d], al
0271+  09D4 79          	inc d
0272+  09D5 0A 93 09    	jmp gettxt_loop
0273+  09D8             gettxt_backspace:
0274+  09D8 7F          	dec d
0275+  09D9 0A 93 09    	jmp gettxt_loop
0276+  09DC             gettxt_end:
0277+  09DC 19 00       	mov al, 0
0278+  09DE 3E          	mov [d], al				; terminate string
0279+  09DF E7          	pop d
0280+  09E0 E4          	pop a
0281+  09E1 09          	ret
0282+  09E2             
0283+  09E2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0284+  09E2             ; PRINT NEW LINE
0285+  09E2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0286+  09E2             printnl:
0287+  09E2 D7          	push a
0288+  09E3 10 00 0A    	mov a, $0A00
0289+  09E6 05 03       	syscall sys_io
0290+  09E8 10 00 0D    	mov a, $0D00
0291+  09EB 05 03       	syscall sys_io
0292+  09ED E4          	pop a
0293+  09EE 09          	ret
0294+  09EF             
0295+  09EF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0296+  09EF             ; strtoint
0297+  09EF             ; 4 digit hex string number in d
0298+  09EF             ; integer returned in A
0299+  09EF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0300+  09EF             strtointx:
0301+  09EF D8          	push b
0302+  09F0 32          	mov bl, [d]
0303+  09F1 37          	mov bh, bl
0304+  09F2 33 01 00    	mov bl, [d + 1]
0305+  09F5 07 B5 08    	call atoi				; convert to int in AL
0306+  09F8 23          	mov ah, al				; move to AH
0307+  09F9 33 02 00    	mov bl, [d + 2]
0308+  09FC 37          	mov bh, bl
0309+  09FD 33 03 00    	mov bl, [d + 3]
0310+  0A00 07 B5 08    	call atoi				; convert to int in AL
0311+  0A03 E5          	pop b
0312+  0A04 09          	ret
0313+  0A05             
0314+  0A05             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0315+  0A05             ; strtoint
0316+  0A05             ; 5 digit base10 string number in d
0317+  0A05             ; integer returned in A
0318+  0A05             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0319+  0A05             strtoint:
0320+  0A05 E2          	push si
0321+  0A06 D8          	push b
0322+  0A07 D9          	push c
0323+  0A08 DA          	push d
0324+  0A09 07 3D 08    	call strlen			; get string length in C
0325+  0A0C 7E          	dec c
0326+  0A0D FD 4E       	mov si, d
0327+  0A0F 12          	mov a, c
0328+  0A10 FD 99       	shl a
0329+  0A12 3B 9D 08    	mov d, table_power
0330+  0A15 59          	add d, a
0331+  0A16 38 00 00    	mov c, 0
0332+  0A19             strtoint_L0:
0333+  0A19 F6          	lodsb			; load ASCII to al
0334+  0A1A B9 00       	cmp al, 0
0335+  0A1C C6 2F 0A    	je strtoint_end
0336+  0A1F 6F 30       	sub al, $30		; make into integer
0337+  0A21 22 00       	mov ah, 0
0338+  0A23 2A          	mov b, [d]
0339+  0A24 AC          	mul a, b			; result in B since it fits in 16bits
0340+  0A25 11          	mov a, b
0341+  0A26 28          	mov b, c
0342+  0A27 54          	add a, b
0343+  0A28 39          	mov c, a
0344+  0A29 63 02 00    	sub d, 2
0345+  0A2C 0A 19 0A    	jmp strtoint_L0
0346+  0A2F             strtoint_end:
0347+  0A2F 12          	mov a, c
0348+  0A30 E7          	pop d
0349+  0A31 E6          	pop c
0350+  0A32 E5          	pop b
0351+  0A33 EF          	pop si
0352+  0A34 09          	ret
0353+  0A35             
0354+  0A35             
0355+  0A35             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  0A35             ; PRINT NULL TERMINATED STRING
0357+  0A35             ; pointer in D
0358+  0A35             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  0A35             puts:
0360+  0A35 D7          	push a
0361+  0A36 DA          	push d
0362+  0A37             puts_L1:
0363+  0A37 1E          	mov al, [d]
0364+  0A38 B9 00       	cmp al, 0
0365+  0A3A C6 46 0A    	jz puts_END
0366+  0A3D 23          	mov ah, al
0367+  0A3E 19 00       	mov al, 0
0368+  0A40 05 03       	syscall sys_io
0369+  0A42 79          	inc d
0370+  0A43 0A 37 0A    	jmp puts_L1
0371+  0A46             puts_END:
0372+  0A46 E7          	pop d
0373+  0A47 E4          	pop a
0374+  0A48 09          	ret
0375+  0A49             
0376+  0A49             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0377+  0A49             ; PRINT N SIZE STRING
0378+  0A49             ; pointer in D
0379+  0A49             ; size in C
0380+  0A49             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0381+  0A49             putsn:
0382+  0A49 DB          	push al
0383+  0A4A DA          	push d
0384+  0A4B D9          	push c
0385+  0A4C             putsn_L0:
0386+  0A4C 1E          	mov al, [d]
0387+  0A4D 23          	mov ah, al
0388+  0A4E 19 00       	mov al, 0
0389+  0A50 05 03       	syscall sys_io
0390+  0A52 79          	inc d
0391+  0A53 7E          	dec c	
0392+  0A54 C2 00 00    	cmp c, 0
0393+  0A57 C7 4C 0A    	jne putsn_L0
0394+  0A5A             putsn_end:
0395+  0A5A E6          	pop c
0396+  0A5B E7          	pop d
0397+  0A5C E8          	pop al
0398+  0A5D 09          	ret
0399+  0A5E             
0400+  0A5E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0401+  0A5E             ; print 16bit decimal number
0402+  0A5E             ; input number in A
0403+  0A5E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  0A5E             print_u16d:
0405+  0A5E D7          	push a
0406+  0A5F D8          	push b
0407+  0A60 26 10 27    	mov b, 10000
0408+  0A63 AE          	div a, b			; get 10000 coeff.
0409+  0A64 07 8A 0A    	call print_zero_or_space
0410+  0A67 11          	mov a, b
0411+  0A68 26 E8 03    	mov b, 1000
0412+  0A6B AE          	div a, b			; get 10000 coeff.
0413+  0A6C 07 8A 0A    	call print_zero_or_space
0414+  0A6F 11          	mov a, b
0415+  0A70 26 64 00    	mov b, 100
0416+  0A73 AE          	div a, b
0417+  0A74 07 8A 0A    	call print_zero_or_space
0418+  0A77 11          	mov a, b
0419+  0A78 26 0A 00    	mov b, 10
0420+  0A7B AE          	div a, b
0421+  0A7C 07 8A 0A    	call print_zero_or_space
0422+  0A7F 11          	mov a, b
0423+  0A80 6A 30       	add al, $30
0424+  0A82 23          	mov ah, al
0425+  0A83 19 00       	mov al, 0
0426+  0A85 05 03       	syscall sys_io	; print coeff
0427+  0A87 E5          	pop b
0428+  0A88 E4          	pop a
0429+  0A89 09          	ret
0430+  0A8A             
0431+  0A8A             
0432+  0A8A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0433+  0A8A             ; if A == 0, print space
0434+  0A8A             ; else print A
0435+  0A8A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  0A8A             print_zero_or_space:
0437+  0A8A             	; cmp a, 0
0438+  0A8A             	; jne print_number
0439+  0A8A             	; mov ah, $20
0440+  0A8A             	; call putchar
0441+  0A8A             	; ret
0442+  0A8A             print_number:
0443+  0A8A 6A 30       	add al, $30
0444+  0A8C 23          	mov ah, al
0445+  0A8D 07 00 09    	call putchar
0446+  0A90 09          	ret
0447+  0A91             
0448+  0A91             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  0A91             ; PRINT 16BIT HEX INTEGER
0450+  0A91             ; integer value in reg B
0451+  0A91             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0452+  0A91             print_u16x:
0453+  0A91 D7          	push a
0454+  0A92 D8          	push b
0455+  0A93 DD          	push bl
0456+  0A94 30          	mov bl, bh
0457+  0A95 07 C7 08    	call itoa				; convert bh to char in A
0458+  0A98 2F          	mov bl, al				; save al
0459+  0A99 19 00       	mov al, 0
0460+  0A9B 05 03       	syscall sys_io				; display AH
0461+  0A9D 24          	mov ah, bl				; retrieve al
0462+  0A9E 19 00       	mov al, 0
0463+  0AA0 05 03       	syscall sys_io				; display AL
0464+  0AA2             
0465+  0AA2 EA          	pop bl
0466+  0AA3 07 C7 08    	call itoa				; convert bh to char in A
0467+  0AA6 2F          	mov bl, al				; save al
0468+  0AA7 19 00       	mov al, 0
0469+  0AA9 05 03       	syscall sys_io				; display AH
0470+  0AAB 24          	mov ah, bl				; retrieve al
0471+  0AAC 19 00       	mov al, 0
0472+  0AAE 05 03       	syscall sys_io				; display AL
0473+  0AB0             
0474+  0AB0 E5          	pop b
0475+  0AB1 E4          	pop a
0476+  0AB2 09          	ret
0477+  0AB3             
0478+  0AB3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  0AB3             ; INPUT 16BIT HEX INTEGER
0480+  0AB3             ; read 16bit integer into A
0481+  0AB3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0482+  0AB3             scan_u16x:
0483+  0AB3 F8 10 00    	enter 16
0484+  0AB6 D8          	push b
0485+  0AB7 DA          	push d
0486+  0AB8             
0487+  0AB8 FA F1 FF    	lea d, [bp + -15]
0488+  0ABB 07 07 09    	call gets				; get number
0489+  0ABE             
0490+  0ABE 32          	mov bl, [d]
0491+  0ABF 37          	mov bh, bl
0492+  0AC0 33 01 00    	mov bl, [d + 1]
0493+  0AC3 07 B5 08    	call atoi				; convert to int in AL
0494+  0AC6 23          	mov ah, al				; move to AH
0495+  0AC7             
0496+  0AC7 33 02 00    	mov bl, [d + 2]
0497+  0ACA 37          	mov bh, bl
0498+  0ACB 33 03 00    	mov bl, [d + 3]
0499+  0ACE 07 B5 08    	call atoi				; convert to int in AL
0500+  0AD1             
0501+  0AD1 E7          	pop d
0502+  0AD2 E5          	pop b
0503+  0AD3 F9          	leave
0504+  0AD4 09          	ret
0505+  0AD5             
0506+  0AD5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  0AD5             ; PRINT 8bit HEX INTEGER
0508+  0AD5             ; integer value in reg bl
0509+  0AD5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0510+  0AD5             print_u8x:
0511+  0AD5 D7          	push a
0512+  0AD6 DD          	push bl
0513+  0AD7             
0514+  0AD7 07 C7 08    	call itoa				; convert bl to char in A
0515+  0ADA 2F          	mov bl, al				; save al
0516+  0ADB 19 00       	mov al, 0
0517+  0ADD 05 03       	syscall sys_io				; display AH
0518+  0ADF 24          	mov ah, bl				; retrieve al
0519+  0AE0 19 00       	mov al, 0
0520+  0AE2 05 03       	syscall sys_io				; display AL
0521+  0AE4             
0522+  0AE4 EA          	pop bl
0523+  0AE5 E4          	pop a
0524+  0AE6 09          	ret
0525+  0AE7             
0526+  0AE7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  0AE7             ; print 8bit decimal unsigned number
0528+  0AE7             ; input number in AL
0529+  0AE7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0530+  0AE7             print_u8d:
0531+  0AE7 D7          	push a
0532+  0AE8 D8          	push b
0533+  0AE9             
0534+  0AE9 22 00       	mov ah, 0
0535+  0AEB 26 64 00    	mov b, 100
0536+  0AEE AE          	div a, b
0537+  0AEF D8          	push b			; save remainder
0538+  0AF0 B9 00       	cmp al, 0
0539+  0AF2 C6 FC 0A    	je skip100
0540+  0AF5 6A 30       	add al, $30
0541+  0AF7 23          	mov ah, al
0542+  0AF8 19 00       	mov al, 0
0543+  0AFA 05 03       	syscall sys_io	; print coeff
0544+  0AFC             skip100:
0545+  0AFC E4          	pop a
0546+  0AFD 22 00       	mov ah, 0
0547+  0AFF 26 0A 00    	mov b, 10
0548+  0B02 AE          	div a, b
0549+  0B03 D8          	push b			; save remainder
0550+  0B04 B9 00       	cmp al, 0
0551+  0B06 C6 10 0B    	je skip10
0552+  0B09 6A 30       	add al, $30
0553+  0B0B 23          	mov ah, al
0554+  0B0C 19 00       	mov al, 0
0555+  0B0E 05 03       	syscall sys_io	; print coeff
0556+  0B10             skip10:
0557+  0B10 E4          	pop a
0558+  0B11 1B          	mov al, bl
0559+  0B12 6A 30       	add al, $30
0560+  0B14 23          	mov ah, al
0561+  0B15 19 00       	mov al, 0
0562+  0B17 05 03       	syscall sys_io	; print coeff
0563+  0B19 E5          	pop b
0564+  0B1A E4          	pop a
0565+  0B1B 09          	ret
0566+  0B1C             
0567+  0B1C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  0B1C             ; INPUT 8BIT HEX INTEGER
0569+  0B1C             ; read 8bit integer into AL
0570+  0B1C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0571+  0B1C             scan_u8x:
0572+  0B1C F8 04 00    	enter 4
0573+  0B1F D8          	push b
0574+  0B20 DA          	push d
0575+  0B21             
0576+  0B21 FA FD FF    	lea d, [bp + -3]
0577+  0B24 07 07 09    	call gets				; get number
0578+  0B27             
0579+  0B27 32          	mov bl, [d]
0580+  0B28 37          	mov bh, bl
0581+  0B29 33 01 00    	mov bl, [d + 1]
0582+  0B2C 07 B5 08    	call atoi				; convert to int in AL
0583+  0B2F             
0584+  0B2F E7          	pop d
0585+  0B30 E5          	pop b
0586+  0B31 F9          	leave
0587+  0B32 09          	ret
0588+  0B33             
0589+  0B33             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0590+  0B33             ; input decimal number
0591+  0B33             ; result in A
0592+  0B33             ; 655'\0'
0593+  0B33             ; low--------high
0594+  0B33             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0595+  0B33             scan_u16d:
0596+  0B33 F8 08 00    	enter 8
0597+  0B36 E2          	push si
0598+  0B37 D8          	push b
0599+  0B38 D9          	push c
0600+  0B39 DA          	push d
0601+  0B3A FA F9 FF    	lea d, [bp +- 7]
0602+  0B3D 07 07 09    	call gets
0603+  0B40 07 3D 08    	call strlen			; get string length in C
0604+  0B43 7E          	dec c
0605+  0B44 FD 4E       	mov si, d
0606+  0B46 12          	mov a, c
0607+  0B47 FD 99       	shl a
0608+  0B49 3B 9D 08    	mov d, table_power
0609+  0B4C 59          	add d, a
0610+  0B4D 38 00 00    	mov c, 0
0611+  0B50             mul_loop:
0612+  0B50 F6          	lodsb			; load ASCII to al
0613+  0B51 B9 00       	cmp al, 0
0614+  0B53 C6 66 0B    	je mul_exit
0615+  0B56 6F 30       	sub al, $30		; make into integer
0616+  0B58 22 00       	mov ah, 0
0617+  0B5A 2A          	mov b, [d]
0618+  0B5B AC          	mul a, b			; result in B since it fits in 16bits
0619+  0B5C 11          	mov a, b
0620+  0B5D 28          	mov b, c
0621+  0B5E 54          	add a, b
0622+  0B5F 39          	mov c, a
0623+  0B60 63 02 00    	sub d, 2
0624+  0B63 0A 50 0B    	jmp mul_loop
0625+  0B66             mul_exit:
0626+  0B66 12          	mov a, c
0627+  0B67 E7          	pop d
0628+  0B68 E6          	pop c
0629+  0B69 E5          	pop b
0630+  0B6A EF          	pop si
0631+  0B6B F9          	leave
0632+  0B6C 09          	ret
0084   0B6D             .include "ctype.asm"
0001+  0B6D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0B6D             ; ctype.s
0003+  0B6D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0B6D             
0005+  0B6D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  0B6D             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  0B6D             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  0B6D             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  0B6D             ;; characters are supported.
0010+  0B6D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  0B6D             ;; isalnum 
0012+  0B6D             ;; isalpha 
0013+  0B6D             ;; islower 
0014+  0B6D             ;; isupper 
0015+  0B6D             ;; isdigit 
0016+  0B6D             ;; isxdigit
0017+  0B6D             ;; iscntrl 
0018+  0B6D             ;; isgraph 
0019+  0B6D             ;; isspace 
0020+  0B6D             ;; isblank 
0021+  0B6D             ;; isprint 
0022+  0B6D             ;; ispunct 
0023+  0B6D             ;; tolower 
0024+  0B6D             ;; toupper
0025+  0B6D             
0026+  0B6D             
0027+  0B6D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  0B6D             ;; IS ALPHANUMERIC
0029+  0B6D             ;; sets ZF according with result
0030+  0B6D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  0B6D             isalnum:
0032+  0B6D 07 8A 0B    	call isalpha
0033+  0B70 C6 76 0B    	je isalnum_exit
0034+  0B73 07 77 0B    	call isdigit
0035+  0B76             isalnum_exit:
0036+  0B76 09          	ret	
0037+  0B77             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0B77             ;; IS DIGIT
0039+  0B77             ;; sets ZF according with result
0040+  0B77             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  0B77             isdigit:
0042+  0B77 DB          	push al
0043+  0B78 B9 30       	cmp al, '0'
0044+  0B7A C8 86 0B    	jlu isdigit_false
0045+  0B7D B9 39       	cmp al, '9'
0046+  0B7F D1 86 0B    	jgu isdigit_false
0047+  0B82 87 00       	and al, 0	; set ZF
0048+  0B84 E8          	pop al
0049+  0B85 09          	ret
0050+  0B86             isdigit_false:
0051+  0B86 8B 01       	or al, 1	; clear ZF
0052+  0B88 E8          	pop al
0053+  0B89 09          	ret	
0054+  0B8A             	
0055+  0B8A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  0B8A             ;; IS ALPHA
0057+  0B8A             ;; sets ZF according with result
0058+  0B8A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  0B8A             isalpha:
0060+  0B8A DB          	push al
0061+  0B8B B9 5F       	cmp al, '_'
0062+  0B8D C6 AD 0B    	je isalpha_true
0063+  0B90 B9 2E       	cmp al, '.'
0064+  0B92 C6 AD 0B    	je isalpha_true
0065+  0B95 B9 41       	cmp al, 'A'
0066+  0B97 C8 A9 0B    	jlu isalpha_false
0067+  0B9A B9 7A       	cmp al, 'z'
0068+  0B9C D1 A9 0B    	jgu isalpha_false
0069+  0B9F B9 5A       	cmp al, 'Z'
0070+  0BA1 D0 AD 0B    	jleu isalpha_true
0071+  0BA4 B9 61       	cmp al, 'a'
0072+  0BA6 C9 AD 0B    	jgeu isalpha_true
0073+  0BA9             isalpha_false:
0074+  0BA9 8B 01       	or al, 1	; clear ZF
0075+  0BAB E8          	pop al
0076+  0BAC 09          	ret
0077+  0BAD             isalpha_true:
0078+  0BAD 87 00       	and al, 0	; set ZF
0079+  0BAF E8          	pop al
0080+  0BB0 09          	ret
0081+  0BB1             
0082+  0BB1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  0BB1             ;; IS PATH-ALPHA
0084+  0BB1             ;; sets ZF according with result
0085+  0BB1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  0BB1             ispath:
0087+  0BB1 DB          	push al
0088+  0BB2 07 77 0B    	call isdigit
0089+  0BB5 C6 DF 0B    	je ispath_true
0090+  0BB8 B9 5F       	cmp al, '_'
0091+  0BBA C6 DF 0B    	je ispath_true
0092+  0BBD B9 2F       	cmp al, '/'
0093+  0BBF C6 DF 0B    	je ispath_true
0094+  0BC2 B9 2E       	cmp al, '.'
0095+  0BC4 C6 DF 0B    	je ispath_true
0096+  0BC7 B9 41       	cmp al, 'A'
0097+  0BC9 C8 DB 0B    	jlu ispath_false
0098+  0BCC B9 7A       	cmp al, 'z'
0099+  0BCE D1 DB 0B    	jgu ispath_false
0100+  0BD1 B9 5A       	cmp al, 'Z'
0101+  0BD3 D0 DF 0B    	jleu ispath_true
0102+  0BD6 B9 61       	cmp al, 'a'
0103+  0BD8 C9 DF 0B    	jgeu ispath_true
0104+  0BDB             ispath_false:
0105+  0BDB 8B 01       	or al, 1	; clear ZF
0106+  0BDD E8          	pop al
0107+  0BDE 09          	ret
0108+  0BDF             ispath_true:
0109+  0BDF 87 00       	and al, 0	; set ZF
0110+  0BE1 E8          	pop al
0111+  0BE2 09          	ret
0112+  0BE3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  0BE3             ;; IS SPACE
0114+  0BE3             ;; sets ZF according with result
0115+  0BE3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  0BE3             isspace:
0117+  0BE3 B9 20       	cmp al, $20		; ' '
0118+  0BE5 C6 F9 0B    	je isspace_exit
0119+  0BE8 B9 09       	cmp al, $09		; '\t'
0120+  0BEA C6 F9 0B    	je isspace_exit
0121+  0BED B9 0A       	cmp al, $0A		; '\n'
0122+  0BEF C6 F9 0B    	je isspace_exit
0123+  0BF2 B9 0D       	cmp al, $0D		; '\r'
0124+  0BF4 C6 F9 0B    	je isspace_exit
0125+  0BF7 B9 0B       	cmp al, $0B		; '\v'
0126+  0BF9             isspace_exit:
0127+  0BF9 09          	ret	
0128+  0BFA             
0129+  0BFA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0BFA             ; TO LOWER
0131+  0BFA             ; input in AL
0132+  0BFA             ; output in AL
0133+  0BFA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  0BFA             to_lower:
0135+  0BFA B9 5A       	cmp al, 'Z'
0136+  0BFC D1 01 0C    	jgu to_lower_ret
0137+  0BFF 6A 20       	add al, $20				; convert to lower case
0138+  0C01             to_lower_ret:
0139+  0C01 09          	ret
0140+  0C02             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  0C02             ; TO UPPER
0142+  0C02             ; input in AL
0143+  0C02             ; output in AL
0144+  0C02             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  0C02             to_upper:
0146+  0C02 B9 61       	cmp al, 'a'
0147+  0C04 C8 09 0C    	jlu to_upper_ret
0148+  0C07 6F 20       	sub al, $20			; convert to upper case
0149+  0C09             to_upper_ret:
0150+  0C09 09          	ret
0151+  0C0A             
0085   0C0A             
0086   0C0A             transient_area:
0087   0C0A             
0088   0C0A             .end
0089   0C0A             
0090   0C0A             
0091   0C0A             
tasm: Number of errors = 0
