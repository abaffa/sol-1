0001   0000             .include "kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0002   0000             
0003   0400             .org PROC_TEXT_ORG			; origin at 1024
0004   0400             
0005   0400             TRUE:	.equ 1
0006   0400             FALSE:	.equ 0
0007   0400             SIZE:	.equ 8190
0008   0400             SIZEP1:	.equ 8191
0009   0400             
0010   0400             main:
0011   0400 3B A2 04    	mov d, s_title
0012   0403 07 D3 07    	call puts
0013   0406             
0014   0406 10 01 00    	mov a, 1
0015   0409 42 92 05    	mov [iter], a
0016   040C             L0:
0017   040C FD 10       	cla
0018   040E 42 90 05    	mov [count], a
0019   0411 42 8A 05    	mov [i], a
0020   0414             L0_0:
0021   0414 14 8A 05    	mov a, [i]
0022   0417 3C          	mov d, a
0023   0418 19 01       	mov al, TRUE
0024   041A 3F 0B 09    	mov [d + flags], al
0025   041D 14 8A 05    	mov a, [i]
0026   0420 77          	inc a
0027   0421 42 8A 05    	mov [i], a
0028   0424 AF FE 1F    	cmp a, SIZE
0029   0427 D0 14 04    	jleu L0_0	
0030   042A             
0031   042A 10 00 00    	mov a, 0
0032   042D 42 8A 05    	mov [i], a
0033   0430             L0_1:
0034   0430 14 8A 05    	mov a, [i]
0035   0433 3C          	mov d, a
0036   0434 1F 0B 09    	mov al, [d + flags]
0037   0437 B9 01       	cmp al, TRUE
0038   0439 C6 59 04    	je IF_0_TRUE
0039   043C             L0_1_COND:	
0040   043C 14 8A 05    	mov a, [i]
0041   043F 77          	inc a
0042   0440 42 8A 05    	mov [i], a
0043   0443 AF FE 1F    	cmp a, SIZE
0044   0446 D0 30 04    	jleu L0_1	
0045   0449             L0_COND:
0046   0449 14 92 05    	mov a, [iter]
0047   044C 77          	inc a
0048   044D 42 92 05    	mov [iter], a
0049   0450 AF 0A 00    	cmp a, 10
0050   0453 D0 0C 04    	jleu L0
0051   0456 0A 94 04    	jmp L0_EXIT
0052   0459             IF_0_TRUE:
0053   0459 29 8A 05    	mov b, [i]
0054   045C 14 8A 05    	mov a, [i]
0055   045F 54          	add a, b
0056   0460 53 03 00    	add a, 3
0057   0463 42 8C 05    	mov [prime], a		; prime = i + i + 3
0058   0466 54          	add a, b
0059   0467 42 8E 05    	mov [k], a			; k = i + prime	
0060   046A             WHILE:
0061   046A 14 8E 05    	mov a, [k]
0062   046D 26 FE 1F    	mov b, SIZE
0063   0470 B0          	cmp a, b
0064   0471 D1 8A 04    	jgu WHILE_EXIT
0065   0474 14 8E 05    	mov a, [k]
0066   0477 3C          	mov d, a
0067   0478 19 00       	mov al, FALSE
0068   047A 3F 0B 09    	mov [d + flags], al
0069   047D 14 8E 05    	mov a, [k]
0070   0480 29 8C 05    	mov b, [prime]
0071   0483 54          	add a, b
0072   0484 42 8E 05    	mov [k], a
0073   0487 0A 6A 04    	jmp WHILE
0074   048A             WHILE_EXIT:	
0075   048A 14 90 05    	mov a, [count]
0076   048D 77          	inc a
0077   048E 42 90 05    	mov [count], a	
0078   0491 0A 3C 04    	jmp L0_1_COND
0079   0494             
0080   0494             L0_EXIT:
0081   0494 14 90 05    	mov a, [count]
0082   0497 07 FC 07    	call print_u16d
0083   049A 3B 4D 05    	mov d, s_result
0084   049D 07 D3 07    	call puts
0085   04A0             
0086   04A0 05 0B       	syscall sys_terminate_proc
0087   04A2             
0088   04A2 2D 2D 2D 2D s_title:	.db "-----------------------------------------------\n"
0088   04A6 2D 2D 2D 2D 
0088   04AA 2D 2D 2D 2D 
0088   04AE 2D 2D 2D 2D 
0088   04B2 2D 2D 2D 2D 
0088   04B6 2D 2D 2D 2D 
0088   04BA 2D 2D 2D 2D 
0088   04BE 2D 2D 2D 2D 
0088   04C2 2D 2D 2D 2D 
0088   04C6 2D 2D 2D 2D 
0088   04CA 2D 2D 2D 2D 
0088   04CE 2D 2D 2D 0A 
0089   04D2 42 79 74 65 			.db "Byte Magazine\'s Sieve of Erastothenes Benchmark\n"
0089   04D6 20 4D 61 67 
0089   04DA 61 7A 69 6E 
0089   04DE 65 27 73 20 
0089   04E2 53 69 65 76 
0089   04E6 65 20 6F 66 
0089   04EA 20 45 72 61 
0089   04EE 73 74 6F 74 
0089   04F2 68 65 6E 65 
0089   04F6 73 20 42 65 
0089   04FA 6E 63 68 6D 
0089   04FE 61 72 6B 0A 
0090   0502 53 69 7A 65 			.db "Size: 8192\n"
0090   0506 3A 20 38 31 
0090   050A 39 32 0A 
0091   050D 49 74 65 72 			.db "Iterations: 10\n"
0091   0511 61 74 69 6F 
0091   0515 6E 73 3A 20 
0091   0519 31 30 0A 
0092   051C 2D 2D 2D 2D 			.db "-----------------------------------------------\n", 0
0092   0520 2D 2D 2D 2D 
0092   0524 2D 2D 2D 2D 
0092   0528 2D 2D 2D 2D 
0092   052C 2D 2D 2D 2D 
0092   0530 2D 2D 2D 2D 
0092   0534 2D 2D 2D 2D 
0092   0538 2D 2D 2D 2D 
0092   053C 2D 2D 2D 2D 
0092   0540 2D 2D 2D 2D 
0092   0544 2D 2D 2D 2D 
0092   0548 2D 2D 2D 0A 
0092   054C 00 
0093   054D             
0094   054D 20 70 72 69 s_result:	.db " primes.\n"
0094   0551 6D 65 73 2E 
0094   0555 0A 
0095   0556 2D 2D 2D 2D 			.db "-----------------------------------------------\n", 0
0095   055A 2D 2D 2D 2D 
0095   055E 2D 2D 2D 2D 
0095   0562 2D 2D 2D 2D 
0095   0566 2D 2D 2D 2D 
0095   056A 2D 2D 2D 2D 
0095   056E 2D 2D 2D 2D 
0095   0572 2D 2D 2D 2D 
0095   0576 2D 2D 2D 2D 
0095   057A 2D 2D 2D 2D 
0095   057E 2D 2D 2D 2D 
0095   0582 2D 2D 2D 0A 
0095   0586 00 
0096   0587             
0097   0587 2C 20 00    s_comma:	.db ", ", 0
0098   058A             
0099   058A 00 00       i:		.dw
0100   058C 00 00       prime:	.dw
0101   058E 00 00       k:		.dw
0102   0590 00 00       count:	.dw
0103   0592 00 00       iter:	.dw
0104   0594             
0105   0594             
0106   0594             .include "stdio.asm"
0001+  0594             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0594             ; stdio.s
0003+  0594             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0594             .include "string.asm"
0001++ 0594             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0594             ; string.s
0003++ 0594             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0594             
0005++ 0594             
0006++ 0594             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0594             ; strrev
0008++ 0594             ; reverse a string
0009++ 0594             ; D = string address
0010++ 0594             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0594             ; 01234
0012++ 0594             strrev:
0013++ 0594 4B          	pusha
0014++ 0595 07 DB 05    	call strlen	; length in C
0015++ 0598 12          	mov a, c
0016++ 0599 AF 01 00    	cmp a, 1
0017++ 059C D0 B6 05    	jleu strrev_end	; check string length. string len must be > 1
0018++ 059F 7D          	dec a
0019++ 05A0 FD 4E       	mov si, d	; beginning of string
0020++ 05A2 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 05A4 59          	add d, a	; end of string
0022++ 05A5 12          	mov a, c
0023++ 05A6 FD 9B       	shr a		; divide by 2
0024++ 05A8 39          	mov c, a	; C now counts the steps
0025++ 05A9             strrev_L0:
0026++ 05A9 32          	mov bl, [d]	; save load right-side char into BL
0027++ 05AA F6          	lodsb		; load left-side char into AL; increase SI
0028++ 05AB 3E          	mov [d], al	; store left char into right side
0029++ 05AC 1B          	mov al, bl
0030++ 05AD F7          	stosb		; store right-side char into left-side; increase DI
0031++ 05AE 7E          	dec c
0032++ 05AF 7F          	dec d
0033++ 05B0 C2 00 00    	cmp c, 0
0034++ 05B3 C7 A9 05    	jne strrev_L0
0035++ 05B6             strrev_end:
0036++ 05B6 4C          	popa
0037++ 05B7 09          	ret
0038++ 05B8             	
0039++ 05B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 05B8             ; strchr
0041++ 05B8             ; search string in D for char in AL
0042++ 05B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 05B8             strchr:
0044++ 05B8             strchr_L0:
0045++ 05B8 32          	mov bl, [d]
0046++ 05B9 C1 00       	cmp bl, 0
0047++ 05BB C6 C6 05    	je strchr_end
0048++ 05BE BA          	cmp al, bl
0049++ 05BF C6 C6 05    	je strchr_end
0050++ 05C2 79          	inc d
0051++ 05C3 0A B8 05    	jmp strchr_L0
0052++ 05C6             strchr_end:
0053++ 05C6 1B          	mov al, bl
0054++ 05C7 09          	ret
0055++ 05C8             
0056++ 05C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 05C8             ; strstr
0058++ 05C8             ; find sub-string
0059++ 05C8             ; str1 in SI
0060++ 05C8             ; str2 in DI
0061++ 05C8             ; SI points to end of source string
0062++ 05C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 05C8             strstr:
0064++ 05C8 DB          	push al
0065++ 05C9 DA          	push d
0066++ 05CA E3          	push di
0067++ 05CB             strstr_loop:
0068++ 05CB F3          	cmpsb					; compare a byte of the strings
0069++ 05CC C7 D7 05    	jne strstr_ret
0070++ 05CF FC 00 00    	lea d, [di + 0]
0071++ 05D2 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 05D4 C7 CB 05    	jne strstr_loop				; equal chars but not at end
0073++ 05D7             strstr_ret:
0074++ 05D7 F0          	pop di
0075++ 05D8 E7          	pop d
0076++ 05D9 E8          	pop al
0077++ 05DA 09          	ret
0078++ 05DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 05DB             ; length of null terminated string
0080++ 05DB             ; result in C
0081++ 05DB             ; pointer in D
0082++ 05DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 05DB             strlen:
0084++ 05DB DA          	push d
0085++ 05DC 38 00 00    	mov c, 0
0086++ 05DF             strlen_L1:
0087++ 05DF BD 00       	cmp byte [d], 0
0088++ 05E1 C6 E9 05    	je strlen_ret
0089++ 05E4 79          	inc d
0090++ 05E5 78          	inc c
0091++ 05E6 0A DF 05    	jmp strlen_L1
0092++ 05E9             strlen_ret:
0093++ 05E9 E7          	pop d
0094++ 05EA 09          	ret
0095++ 05EB             
0096++ 05EB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 05EB             ; STRCMP
0098++ 05EB             ; compare two strings
0099++ 05EB             ; str1 in SI
0100++ 05EB             ; str2 in DI
0101++ 05EB             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 05EB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 05EB             strcmp:
0104++ 05EB DB          	push al
0105++ 05EC DA          	push d
0106++ 05ED E3          	push di
0107++ 05EE E2          	push si
0108++ 05EF             strcmp_loop:
0109++ 05EF F3          	cmpsb					; compare a byte of the strings
0110++ 05F0 C7 FB 05    	jne strcmp_ret
0111++ 05F3 FB FF FF    	lea d, [si +- 1]
0112++ 05F6 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 05F8 C7 EF 05    	jne strcmp_loop				; equal chars but not at end
0114++ 05FB             strcmp_ret:
0115++ 05FB EF          	pop si
0116++ 05FC F0          	pop di
0117++ 05FD E7          	pop d
0118++ 05FE E8          	pop al
0119++ 05FF 09          	ret
0120++ 0600             
0121++ 0600             
0122++ 0600             ; STRCPY
0123++ 0600             ; copy null terminated string from SI to DI
0124++ 0600             ; source in SI
0125++ 0600             ; destination in DI
0126++ 0600             strcpy:
0127++ 0600 E2          	push si
0128++ 0601 E3          	push di
0129++ 0602 DB          	push al
0130++ 0603             strcpy_L1:
0131++ 0603 F6          	lodsb
0132++ 0604 F7          	stosb
0133++ 0605 B9 00       	cmp al, 0
0134++ 0607 C7 03 06    	jne strcpy_L1
0135++ 060A             strcpy_end:
0136++ 060A E8          	pop al
0137++ 060B F0          	pop di
0138++ 060C EF          	pop si
0139++ 060D 09          	ret
0140++ 060E             
0141++ 060E             ; STRCAT
0142++ 060E             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 060E             ; source in SI
0144++ 060E             ; destination in DI
0145++ 060E             strcat:
0146++ 060E E2          	push si
0147++ 060F E3          	push di
0148++ 0610 D7          	push a
0149++ 0611 DA          	push d
0150++ 0612 50          	mov a, di
0151++ 0613 3C          	mov d, a
0152++ 0614             strcat_goto_end_L1:
0153++ 0614 BD 00       	cmp byte[d], 0
0154++ 0616 C6 1D 06    	je strcat_start
0155++ 0619 79          	inc d
0156++ 061A 0A 14 06    	jmp strcat_goto_end_L1
0157++ 061D             strcat_start:
0158++ 061D FD 50       	mov di, d
0159++ 061F             strcat_L1:
0160++ 061F F6          	lodsb
0161++ 0620 F7          	stosb
0162++ 0621 B9 00       	cmp al, 0
0163++ 0623 C7 1F 06    	jne strcat_L1
0164++ 0626             strcat_end:
0165++ 0626 E7          	pop d
0166++ 0627 E4          	pop a
0167++ 0628 F0          	pop di
0168++ 0629 EF          	pop si
0169++ 062A 09          	ret
0005+  062B             
0006+  062B 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  062F 34 35 36 37 
0006+  0633 38 39 41 42 
0006+  0637 43 44 45 46 
0007+  063B             
0008+  063B 01 00       table_power:.dw 1
0009+  063D 0A 00       			.dw 10
0010+  063F 64 00       			.dw 100
0011+  0641 E8 03       			.dw 1000
0012+  0643 10 27       			.dw 10000
0013+  0645             
0014+  0645             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0015+  0645             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0016+  0645             ; ASCII in BL
0017+  0645             ; result in AL
0018+  0645             ; ascii for F = 0100 0110
0019+  0645             ; ascii for 9 = 0011 1001
0020+  0645             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0021+  0645             hex_ascii_encode:
0022+  0645 1B          	mov al, bl
0023+  0646 93 40       	test al, $40				; test if letter or number
0024+  0648 C7 4E 06    	jnz hex_letter
0025+  064B 87 0F       	and al, $0F				; get number
0026+  064D 09          	ret
0027+  064E             hex_letter:
0028+  064E 87 0F       	and al, $0F				; get letter
0029+  0650 6A 09       	add al, 9
0030+  0652 09          	ret
0031+  0653             
0032+  0653             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0033+  0653             ; ATOI
0034+  0653             ; 2 letter hex string in B
0035+  0653             ; 8bit integer returned in AL
0036+  0653             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0037+  0653             atoi:
0038+  0653 D8          	push b
0039+  0654 07 45 06    	call hex_ascii_encode			; convert BL to 4bit code in AL
0040+  0657 30          	mov bl, bh
0041+  0658 DB          	push al					; save a
0042+  0659 07 45 06    	call hex_ascii_encode
0043+  065C EA          	pop bl	
0044+  065D FD 9E 04    	shl al, 4
0045+  0660 8C          	or al, bl
0046+  0661 E5          	pop b
0047+  0662 09          	ret	
0048+  0663             
0049+  0663             
0050+  0663             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  0663             ; printf
0052+  0663             ; no need for explanations!
0053+  0663             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0054+  0663             printf:
0055+  0663 09          	ret
0056+  0664             
0057+  0664             
0058+  0664             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  0664             ; scanf
0060+  0664             ; no need for explanations!
0061+  0664             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  0664             scanf:
0063+  0664 09          	ret
0064+  0665             
0065+  0665             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  0665             ; ITOA
0067+  0665             ; 8bit value in BL
0068+  0665             ; 2 byte ASCII result in A
0069+  0665             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0070+  0665             itoa:
0071+  0665 DA          	push d
0072+  0666 D8          	push b
0073+  0667 A7 00       	mov bh, 0
0074+  0669 FD A4 04    	shr bl, 4	
0075+  066C 74          	mov d, b
0076+  066D 1F 2B 06    	mov al, [d + s_hex_digits]
0077+  0670 23          	mov ah, al
0078+  0671             	
0079+  0671 E5          	pop b
0080+  0672 D8          	push b
0081+  0673 A7 00       	mov bh, 0
0082+  0675 FD 87 0F    	and bl, $0F
0083+  0678 74          	mov d, b
0084+  0679 1F 2B 06    	mov al, [d + s_hex_digits]
0085+  067C E5          	pop b
0086+  067D E7          	pop d
0087+  067E 09          	ret
0088+  067F             
0089+  067F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0090+  067F             ; HEX STRING TO BINARY
0091+  067F             ; di = destination address
0092+  067F             ; si = source
0093+  067F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0094+  067F             hex_to_int:
0095+  067F             hex_to_int_L1:
0096+  067F F6          	lodsb					; load from [SI] to AL
0097+  0680 B9 00       	cmp al, 0				; check if ASCII 0
0098+  0682 C6 8F 06    	jz hex_to_int_ret
0099+  0685 36          	mov bh, al
0100+  0686 F6          	lodsb
0101+  0687 2F          	mov bl, al
0102+  0688 07 53 06    	call atoi				; convert ASCII byte in B to int (to AL)
0103+  068B F7          	stosb					; store AL to [DI]
0104+  068C 0A 7F 06    	jmp hex_to_int_L1
0105+  068F             hex_to_int_ret:
0106+  068F 09          	ret		
0107+  0690             
0108+  0690             
0109+  0690             
0110+  0690             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  0690             ; GETCHAR
0112+  0690             ; char in ah
0113+  0690             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0114+  0690             getchar:
0115+  0690 DB          	push al
0116+  0691             getchar_retry:
0117+  0691 FD 0C       	sti
0118+  0693 19 01       	mov al, 1
0119+  0695 05 03       	syscall sys_io			; receive in AH
0120+  0697 B9 00       	cmp al, 0			; check if any char was receive
0121+  0699 C6 91 06    	je getchar_retry
0122+  069C E8          	pop al
0123+  069D 09          	ret
0124+  069E             
0125+  069E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0126+  069E             ; PUTCHAR
0127+  069E             ; char in ah
0128+  069E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  069E             putchar:
0130+  069E D7          	push a
0131+  069F 19 00       	mov al, 0
0132+  06A1 05 03       	syscall sys_io			; char in AH
0133+  06A3 E4          	pop a
0134+  06A4 09          	ret
0135+  06A5             
0136+  06A5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0137+  06A5             ;; INPUT A STRING
0138+  06A5             ;; terminates with null
0139+  06A5             ;; pointer in D
0140+  06A5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  06A5             gets:
0142+  06A5 D7          	push a
0143+  06A6 DA          	push d
0144+  06A7             gets_loop:
0145+  06A7 FD 0C       	sti
0146+  06A9 19 01       	mov al, 1
0147+  06AB 05 03       	syscall sys_io			; receive in AH
0148+  06AD B9 00       	cmp al, 0				; check error code (AL)
0149+  06AF C6 A7 06    	je gets_loop			; if no char received, retry
0150+  06B2             
0151+  06B2 76 1B       	cmp ah, 27
0152+  06B4 C6 D0 06    	je gets_telnet_escape
0153+  06B7 76 0A       	cmp ah, $0A				; LF
0154+  06B9 C6 29 07    	je gets_end
0155+  06BC 76 5C       	cmp ah, $5C				; '\\'
0156+  06BE C6 00 07    	je gets_escape
0157+  06C1             	
0158+  06C1 76 08       	cmp ah, $08			; check for backspace
0159+  06C3 C6 CC 06    	je gets_backspace
0160+  06C6             
0161+  06C6 1A          	mov al, ah
0162+  06C7 3E          	mov [d], al
0163+  06C8 79          	inc d
0164+  06C9 0A A7 06    	jmp gets_loop
0165+  06CC             gets_backspace:
0166+  06CC 7F          	dec d
0167+  06CD 0A A7 06    	jmp gets_loop
0168+  06D0             gets_telnet_escape:
0169+  06D0 FD 0C       	sti
0170+  06D2 19 01       	mov al, 1
0171+  06D4 05 03       	syscall sys_io				; receive in AH without echo
0172+  06D6 B9 00       	cmp al, 0					; check error code (AL)
0173+  06D8 C6 D0 06    	je gets_telnet_escape		; if no char received, retry
0174+  06DB 76 5B       	cmp ah, '['
0175+  06DD C7 A7 06    	jne gets_loop
0176+  06E0             gets_telnet_escape_phase2:
0177+  06E0 FD 0C       	sti
0178+  06E2 19 01       	mov al, 1
0179+  06E4 05 03       	syscall sys_io					; receive in AH without echo
0180+  06E6 B9 00       	cmp al, 0						; check error code (AL)
0181+  06E8 C6 E0 06    	je gets_telnet_escape_phase2	; if no char received, retry
0182+  06EB 76 44       	cmp ah, 'D'
0183+  06ED C6 F8 06    	je gets_left_arrow
0184+  06F0 76 43       	cmp ah, 'C'
0185+  06F2 C6 FC 06    	je gets_right_arrow
0186+  06F5 0A A7 06    	jmp gets_loop
0187+  06F8             gets_left_arrow:
0188+  06F8 7F          	dec d
0189+  06F9 0A A7 06    	jmp gets_loop
0190+  06FC             gets_right_arrow:
0191+  06FC 79          	inc d
0192+  06FD 0A A7 06    	jmp gets_loop
0193+  0700             gets_escape:
0194+  0700 FD 0C       	sti
0195+  0702 19 01       	mov al, 1
0196+  0704 05 03       	syscall sys_io			; receive in AH
0197+  0706 B9 00       	cmp al, 0				; check error code (AL)
0198+  0708 C6 00 07    	je gets_escape			; if no char received, retry
0199+  070B 76 6E       	cmp ah, 'n'
0200+  070D C6 1B 07    	je gets_LF
0201+  0710 76 72       	cmp ah, 'r'
0202+  0712 C6 22 07    	je gets_CR
0203+  0715 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0204+  0716 3E          	mov [d], al
0205+  0717 79          	inc d
0206+  0718 0A A7 06    	jmp gets_loop
0207+  071B             gets_LF:
0208+  071B 19 0A       	mov al, $0A
0209+  071D 3E          	mov [d], al
0210+  071E 79          	inc d
0211+  071F 0A A7 06    	jmp gets_loop
0212+  0722             gets_CR:
0213+  0722 19 0D       	mov al, $0D
0214+  0724 3E          	mov [d], al
0215+  0725 79          	inc d
0216+  0726 0A A7 06    	jmp gets_loop
0217+  0729             gets_end:
0218+  0729 19 00       	mov al, 0
0219+  072B 3E          	mov [d], al				; terminate string
0220+  072C E7          	pop d
0221+  072D E4          	pop a
0222+  072E 09          	ret
0223+  072F             
0224+  072F             
0225+  072F             
0226+  072F             
0227+  072F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0228+  072F             ;; INPUT TEXT
0229+  072F             ;; terminated with CTRL+D
0230+  072F             ;; pointer in D
0231+  072F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0232+  072F             gettxt:
0233+  072F D7          	push a
0234+  0730 DA          	push d
0235+  0731             gettxt_loop:
0236+  0731 19 01       	mov al, 1
0237+  0733 05 03       	syscall sys_io			; receive in AH
0238+  0735 B9 00       	cmp al, 0				; check error code (AL)
0239+  0737 C6 31 07    	je gettxt_loop		; if no char received, retry
0240+  073A 76 04       	cmp ah, 4			; EOT
0241+  073C C6 7A 07    	je gettxt_end
0242+  073F 76 08       	cmp ah, $08			; check for backspace
0243+  0741 C6 76 07    	je gettxt_backspace
0244+  0744 76 5C       	cmp ah, $5C				; '\\'
0245+  0746 C6 4F 07    	je gettxt_escape
0246+  0749 1A          	mov al, ah
0247+  074A 3E          	mov [d], al
0248+  074B 79          	inc d
0249+  074C 0A 31 07    	jmp gettxt_loop
0250+  074F             gettxt_escape:
0251+  074F 19 01       	mov al, 1
0252+  0751 05 03       	syscall sys_io			; receive in AH
0253+  0753 B9 00       	cmp al, 0				; check error code (AL)
0254+  0755 C6 4F 07    	je gettxt_escape		; if no char received, retry
0255+  0758 76 6E       	cmp ah, 'n'
0256+  075A C6 68 07    	je gettxt_LF
0257+  075D 76 72       	cmp ah, 'r'
0258+  075F C6 6F 07    	je gettxt_CR
0259+  0762 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0260+  0763 3E          	mov [d], al
0261+  0764 79          	inc d
0262+  0765 0A 31 07    	jmp gettxt_loop
0263+  0768             gettxt_LF:
0264+  0768 19 0A       	mov al, $0A
0265+  076A 3E          	mov [d], al
0266+  076B 79          	inc d
0267+  076C 0A 31 07    	jmp gettxt_loop
0268+  076F             gettxt_CR:
0269+  076F 19 0D       	mov al, $0D
0270+  0771 3E          	mov [d], al
0271+  0772 79          	inc d
0272+  0773 0A 31 07    	jmp gettxt_loop
0273+  0776             gettxt_backspace:
0274+  0776 7F          	dec d
0275+  0777 0A 31 07    	jmp gettxt_loop
0276+  077A             gettxt_end:
0277+  077A 19 00       	mov al, 0
0278+  077C 3E          	mov [d], al				; terminate string
0279+  077D E7          	pop d
0280+  077E E4          	pop a
0281+  077F 09          	ret
0282+  0780             
0283+  0780             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0284+  0780             ; PRINT NEW LINE
0285+  0780             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0286+  0780             printnl:
0287+  0780 D7          	push a
0288+  0781 10 00 0A    	mov a, $0A00
0289+  0784 05 03       	syscall sys_io
0290+  0786 10 00 0D    	mov a, $0D00
0291+  0789 05 03       	syscall sys_io
0292+  078B E4          	pop a
0293+  078C 09          	ret
0294+  078D             
0295+  078D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0296+  078D             ; strtoint
0297+  078D             ; 4 digit hex string number in d
0298+  078D             ; integer returned in A
0299+  078D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0300+  078D             strtointx:
0301+  078D D8          	push b
0302+  078E 32          	mov bl, [d]
0303+  078F 37          	mov bh, bl
0304+  0790 33 01 00    	mov bl, [d + 1]
0305+  0793 07 53 06    	call atoi				; convert to int in AL
0306+  0796 23          	mov ah, al				; move to AH
0307+  0797 33 02 00    	mov bl, [d + 2]
0308+  079A 37          	mov bh, bl
0309+  079B 33 03 00    	mov bl, [d + 3]
0310+  079E 07 53 06    	call atoi				; convert to int in AL
0311+  07A1 E5          	pop b
0312+  07A2 09          	ret
0313+  07A3             
0314+  07A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0315+  07A3             ; strtoint
0316+  07A3             ; 5 digit base10 string number in d
0317+  07A3             ; integer returned in A
0318+  07A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0319+  07A3             strtoint:
0320+  07A3 E2          	push si
0321+  07A4 D8          	push b
0322+  07A5 D9          	push c
0323+  07A6 DA          	push d
0324+  07A7 07 DB 05    	call strlen			; get string length in C
0325+  07AA 7E          	dec c
0326+  07AB FD 4E       	mov si, d
0327+  07AD 12          	mov a, c
0328+  07AE FD 99       	shl a
0329+  07B0 3B 3B 06    	mov d, table_power
0330+  07B3 59          	add d, a
0331+  07B4 38 00 00    	mov c, 0
0332+  07B7             strtoint_L0:
0333+  07B7 F6          	lodsb			; load ASCII to al
0334+  07B8 B9 00       	cmp al, 0
0335+  07BA C6 CD 07    	je strtoint_end
0336+  07BD 6F 30       	sub al, $30		; make into integer
0337+  07BF 22 00       	mov ah, 0
0338+  07C1 2A          	mov b, [d]
0339+  07C2 AC          	mul a, b			; result in B since it fits in 16bits
0340+  07C3 11          	mov a, b
0341+  07C4 28          	mov b, c
0342+  07C5 54          	add a, b
0343+  07C6 39          	mov c, a
0344+  07C7 63 02 00    	sub d, 2
0345+  07CA 0A B7 07    	jmp strtoint_L0
0346+  07CD             strtoint_end:
0347+  07CD 12          	mov a, c
0348+  07CE E7          	pop d
0349+  07CF E6          	pop c
0350+  07D0 E5          	pop b
0351+  07D1 EF          	pop si
0352+  07D2 09          	ret
0353+  07D3             
0354+  07D3             
0355+  07D3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  07D3             ; PRINT NULL TERMINATED STRING
0357+  07D3             ; pointer in D
0358+  07D3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  07D3             puts:
0360+  07D3 D7          	push a
0361+  07D4 DA          	push d
0362+  07D5             puts_L1:
0363+  07D5 1E          	mov al, [d]
0364+  07D6 B9 00       	cmp al, 0
0365+  07D8 C6 E4 07    	jz puts_END
0366+  07DB 23          	mov ah, al
0367+  07DC 19 00       	mov al, 0
0368+  07DE 05 03       	syscall sys_io
0369+  07E0 79          	inc d
0370+  07E1 0A D5 07    	jmp puts_L1
0371+  07E4             puts_END:
0372+  07E4 E7          	pop d
0373+  07E5 E4          	pop a
0374+  07E6 09          	ret
0375+  07E7             
0376+  07E7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0377+  07E7             ; PRINT N SIZE STRING
0378+  07E7             ; pointer in D
0379+  07E7             ; size in C
0380+  07E7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0381+  07E7             putsn:
0382+  07E7 DB          	push al
0383+  07E8 DA          	push d
0384+  07E9 D9          	push c
0385+  07EA             putsn_L0:
0386+  07EA 1E          	mov al, [d]
0387+  07EB 23          	mov ah, al
0388+  07EC 19 00       	mov al, 0
0389+  07EE 05 03       	syscall sys_io
0390+  07F0 79          	inc d
0391+  07F1 7E          	dec c	
0392+  07F2 C2 00 00    	cmp c, 0
0393+  07F5 C7 EA 07    	jne putsn_L0
0394+  07F8             putsn_end:
0395+  07F8 E6          	pop c
0396+  07F9 E7          	pop d
0397+  07FA E8          	pop al
0398+  07FB 09          	ret
0399+  07FC             
0400+  07FC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0401+  07FC             ; print 16bit decimal number
0402+  07FC             ; input number in A
0403+  07FC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  07FC             print_u16d:
0405+  07FC D7          	push a
0406+  07FD D8          	push b
0407+  07FE 26 10 27    	mov b, 10000
0408+  0801 AE          	div a, b			; get 10000 coeff.
0409+  0802 07 28 08    	call print_zero_or_space
0410+  0805 11          	mov a, b
0411+  0806 26 E8 03    	mov b, 1000
0412+  0809 AE          	div a, b			; get 10000 coeff.
0413+  080A 07 28 08    	call print_zero_or_space
0414+  080D 11          	mov a, b
0415+  080E 26 64 00    	mov b, 100
0416+  0811 AE          	div a, b
0417+  0812 07 28 08    	call print_zero_or_space
0418+  0815 11          	mov a, b
0419+  0816 26 0A 00    	mov b, 10
0420+  0819 AE          	div a, b
0421+  081A 07 28 08    	call print_zero_or_space
0422+  081D 11          	mov a, b
0423+  081E 6A 30       	add al, $30
0424+  0820 23          	mov ah, al
0425+  0821 19 00       	mov al, 0
0426+  0823 05 03       	syscall sys_io	; print coeff
0427+  0825 E5          	pop b
0428+  0826 E4          	pop a
0429+  0827 09          	ret
0430+  0828             
0431+  0828             
0432+  0828             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0433+  0828             ; if A == 0, print space
0434+  0828             ; else print A
0435+  0828             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  0828             print_zero_or_space:
0437+  0828             	; cmp a, 0
0438+  0828             	; jne print_number
0439+  0828             	; mov ah, $20
0440+  0828             	; call putchar
0441+  0828             	; ret
0442+  0828             print_number:
0443+  0828 6A 30       	add al, $30
0444+  082A 23          	mov ah, al
0445+  082B 07 9E 06    	call putchar
0446+  082E 09          	ret
0447+  082F             
0448+  082F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  082F             ; PRINT 16BIT HEX INTEGER
0450+  082F             ; integer value in reg B
0451+  082F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0452+  082F             print_u16x:
0453+  082F D7          	push a
0454+  0830 D8          	push b
0455+  0831 DD          	push bl
0456+  0832 30          	mov bl, bh
0457+  0833 07 65 06    	call itoa				; convert bh to char in A
0458+  0836 2F          	mov bl, al				; save al
0459+  0837 19 00       	mov al, 0
0460+  0839 05 03       	syscall sys_io				; display AH
0461+  083B 24          	mov ah, bl				; retrieve al
0462+  083C 19 00       	mov al, 0
0463+  083E 05 03       	syscall sys_io				; display AL
0464+  0840             
0465+  0840 EA          	pop bl
0466+  0841 07 65 06    	call itoa				; convert bh to char in A
0467+  0844 2F          	mov bl, al				; save al
0468+  0845 19 00       	mov al, 0
0469+  0847 05 03       	syscall sys_io				; display AH
0470+  0849 24          	mov ah, bl				; retrieve al
0471+  084A 19 00       	mov al, 0
0472+  084C 05 03       	syscall sys_io				; display AL
0473+  084E             
0474+  084E E5          	pop b
0475+  084F E4          	pop a
0476+  0850 09          	ret
0477+  0851             
0478+  0851             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  0851             ; INPUT 16BIT HEX INTEGER
0480+  0851             ; read 16bit integer into A
0481+  0851             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0482+  0851             scan_u16x:
0483+  0851 F8 10 00    	enter 16
0484+  0854 D8          	push b
0485+  0855 DA          	push d
0486+  0856             
0487+  0856 FA F1 FF    	lea d, [bp + -15]
0488+  0859 07 A5 06    	call gets				; get number
0489+  085C             
0490+  085C 32          	mov bl, [d]
0491+  085D 37          	mov bh, bl
0492+  085E 33 01 00    	mov bl, [d + 1]
0493+  0861 07 53 06    	call atoi				; convert to int in AL
0494+  0864 23          	mov ah, al				; move to AH
0495+  0865             
0496+  0865 33 02 00    	mov bl, [d + 2]
0497+  0868 37          	mov bh, bl
0498+  0869 33 03 00    	mov bl, [d + 3]
0499+  086C 07 53 06    	call atoi				; convert to int in AL
0500+  086F             
0501+  086F E7          	pop d
0502+  0870 E5          	pop b
0503+  0871 F9          	leave
0504+  0872 09          	ret
0505+  0873             
0506+  0873             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  0873             ; PRINT 8bit HEX INTEGER
0508+  0873             ; integer value in reg bl
0509+  0873             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0510+  0873             print_u8x:
0511+  0873 D7          	push a
0512+  0874 DD          	push bl
0513+  0875             
0514+  0875 07 65 06    	call itoa				; convert bl to char in A
0515+  0878 2F          	mov bl, al				; save al
0516+  0879 19 00       	mov al, 0
0517+  087B 05 03       	syscall sys_io				; display AH
0518+  087D 24          	mov ah, bl				; retrieve al
0519+  087E 19 00       	mov al, 0
0520+  0880 05 03       	syscall sys_io				; display AL
0521+  0882             
0522+  0882 EA          	pop bl
0523+  0883 E4          	pop a
0524+  0884 09          	ret
0525+  0885             
0526+  0885             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  0885             ; print 8bit decimal unsigned number
0528+  0885             ; input number in AL
0529+  0885             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0530+  0885             print_u8d:
0531+  0885 D7          	push a
0532+  0886 D8          	push b
0533+  0887             
0534+  0887 22 00       	mov ah, 0
0535+  0889 26 64 00    	mov b, 100
0536+  088C AE          	div a, b
0537+  088D D8          	push b			; save remainder
0538+  088E B9 00       	cmp al, 0
0539+  0890 C6 9A 08    	je skip100
0540+  0893 6A 30       	add al, $30
0541+  0895 23          	mov ah, al
0542+  0896 19 00       	mov al, 0
0543+  0898 05 03       	syscall sys_io	; print coeff
0544+  089A             skip100:
0545+  089A E4          	pop a
0546+  089B 22 00       	mov ah, 0
0547+  089D 26 0A 00    	mov b, 10
0548+  08A0 AE          	div a, b
0549+  08A1 D8          	push b			; save remainder
0550+  08A2 B9 00       	cmp al, 0
0551+  08A4 C6 AE 08    	je skip10
0552+  08A7 6A 30       	add al, $30
0553+  08A9 23          	mov ah, al
0554+  08AA 19 00       	mov al, 0
0555+  08AC 05 03       	syscall sys_io	; print coeff
0556+  08AE             skip10:
0557+  08AE E4          	pop a
0558+  08AF 1B          	mov al, bl
0559+  08B0 6A 30       	add al, $30
0560+  08B2 23          	mov ah, al
0561+  08B3 19 00       	mov al, 0
0562+  08B5 05 03       	syscall sys_io	; print coeff
0563+  08B7 E5          	pop b
0564+  08B8 E4          	pop a
0565+  08B9 09          	ret
0566+  08BA             
0567+  08BA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  08BA             ; INPUT 8BIT HEX INTEGER
0569+  08BA             ; read 8bit integer into AL
0570+  08BA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0571+  08BA             scan_u8x:
0572+  08BA F8 04 00    	enter 4
0573+  08BD D8          	push b
0574+  08BE DA          	push d
0575+  08BF             
0576+  08BF FA FD FF    	lea d, [bp + -3]
0577+  08C2 07 A5 06    	call gets				; get number
0578+  08C5             
0579+  08C5 32          	mov bl, [d]
0580+  08C6 37          	mov bh, bl
0581+  08C7 33 01 00    	mov bl, [d + 1]
0582+  08CA 07 53 06    	call atoi				; convert to int in AL
0583+  08CD             
0584+  08CD E7          	pop d
0585+  08CE E5          	pop b
0586+  08CF F9          	leave
0587+  08D0 09          	ret
0588+  08D1             
0589+  08D1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0590+  08D1             ; input decimal number
0591+  08D1             ; result in A
0592+  08D1             ; 655'\0'
0593+  08D1             ; low--------high
0594+  08D1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0595+  08D1             scan_u16d:
0596+  08D1 F8 08 00    	enter 8
0597+  08D4 E2          	push si
0598+  08D5 D8          	push b
0599+  08D6 D9          	push c
0600+  08D7 DA          	push d
0601+  08D8 FA F9 FF    	lea d, [bp +- 7]
0602+  08DB 07 A5 06    	call gets
0603+  08DE 07 DB 05    	call strlen			; get string length in C
0604+  08E1 7E          	dec c
0605+  08E2 FD 4E       	mov si, d
0606+  08E4 12          	mov a, c
0607+  08E5 FD 99       	shl a
0608+  08E7 3B 3B 06    	mov d, table_power
0609+  08EA 59          	add d, a
0610+  08EB 38 00 00    	mov c, 0
0611+  08EE             mul_loop:
0612+  08EE F6          	lodsb			; load ASCII to al
0613+  08EF B9 00       	cmp al, 0
0614+  08F1 C6 04 09    	je mul_exit
0615+  08F4 6F 30       	sub al, $30		; make into integer
0616+  08F6 22 00       	mov ah, 0
0617+  08F8 2A          	mov b, [d]
0618+  08F9 AC          	mul a, b			; result in B since it fits in 16bits
0619+  08FA 11          	mov a, b
0620+  08FB 28          	mov b, c
0621+  08FC 54          	add a, b
0622+  08FD 39          	mov c, a
0623+  08FE 63 02 00    	sub d, 2
0624+  0901 0A EE 08    	jmp mul_loop
0625+  0904             mul_exit:
0626+  0904 12          	mov a, c
0627+  0905 E7          	pop d
0628+  0906 E6          	pop c
0629+  0907 E5          	pop b
0630+  0908 EF          	pop si
0631+  0909 F9          	leave
0632+  090A 09          	ret
0107   090B             
0108   090B 00          flags:	.db
0109   090C             
0110   090C             .end
0111   090C             
tasm: Number of errors = 0
