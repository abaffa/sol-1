0001   0000             .include "kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0002   0000             
0003   0400             .org PROC_TEXT_ORG			; origin at 1024
0004   0400             
0005   0400             WIDTH:	.equ	110		; must be even
0006   0400             
0007   0400             menu:
0008   0400 F8 00 02    	enter 512	
0009   0403             __get_math_choice:
0010   0403 3B 1C 0A    	mov d, s_menu
0011   0406 07 0E 07    	call puts
0012   0409 FA 01 FE    	lea d, [bp +- 511]
0013   040C 07 E0 05    	call gets						; get choice
0014   040F 1E          	mov al, [d]
0015   0410 6F 30       	sub al, 30h
0016   0412 B9 02       	cmp al, 2
0017   0414 C6 29 04    	je _math_quit
0018   0417 D1 03 04    	jgu __get_math_choice				; check bounds
0019   041A FD 9E 01    	shl al, 1
0020   041D 22 00       	mov ah, 0
0021   041F FD 07 2C 04 	call [a + __math_menu_jump_table]
0022   0423             
0023   0423 07 BB 06    	call printnl
0024   0426 0A 03 04    	jmp __get_math_choice
0025   0429             _math_quit:
0026   0429 F9          	leave
0027   042A 05 0B       	syscall sys_terminate_proc
0028   042C             
0029   042C             ; ***********************************************************************************
0030   042C             ; MATHS JUMP TABLE
0031   042C             ; ***********************************************************************************
0032   042C             __math_menu_jump_table:
0033   042C 30 04       	.dw automaton
0034   042E B6 04       	.dw chg_rules
0035   0430             	
0036   0430             automaton:
0037   0430 F8 02 00    	enter 2
0038   0433 3B 4D 08    	mov d, s_steps
0039   0436 07 0E 07    	call puts
0040   0439 07 0C 08    	call scan_u16d
0041   043C 45 FF FF    	mov [bp +- 1], a
0042   043F 07 BB 06    	call printnl
0043   0442             ; reset initial state
0044   0442 FD 4D 57 08 	mov si, init_state
0045   0446 FD 4F C6 08 	mov di, prev_state
0046   044A 38 6F 00    	mov c, (WIDTH+1)
0047   044D FD F5       	rep movsb	
0048   044F             auto_L1:
0049   044F 38 01 00    	mov c, 1	
0050   0452 17 FF FF    	mov a, [bp + -1]
0051   0455 AF 00 00    	cmp a, 0
0052   0458 C6 B4 04    	je automaton_ret
0053   045B 7D          	dec a
0054   045C 45 FF FF    	mov [bp + -1], a
0055   045F             auto_L2:	
0056   045F 12          	mov a, c
0057   0460 3C          	mov d, a
0058   0461 FD 10       	cla
0059   0463 79          	inc d
0060   0464 33 C6 08    	mov bl, [d + prev_state]
0061   0467 6B          	add al, bl
0062   0468 7F          	dec d
0063   0469 33 C6 08    	mov bl, [d + prev_state]
0064   046C             	
0065   046C FD A0 01    	shl bl, 1
0066   046F 6B          	add al, bl
0067   0470 7F          	dec d
0068   0471 33 C6 08    	mov bl, [d + prev_state]
0069   0474 FD A0 02    	shl bl, 2
0070   0477 6B          	add al, bl					; now al has the number for the table
0071   0478             	
0072   0478 B7 14 0A    	mov a, [a + automaton_table]
0073   047B 79          	inc d
0074   047C 3F 35 09    	mov [d + state], al
0075   047F 78          	inc c
0076   0480 C2 6E 00    	cmp c, WIDTH
0077   0483 C8 5F 04    	jlu auto_L2
0078   0486             	
0079   0486             ; here we finished updating the current state, now we copy the current state to
0080   0486             ; the previous state
0081   0486 FD 4D 35 09 	mov si, state
0082   048A FD 4F C6 08 	mov di, prev_state
0083   048E 38 6F 00    	mov c, (WIDTH+1)
0084   0491 FD F5       	rep movsb
0085   0493             	
0086   0493             ; now print the current state on the screen
0087   0493 FD 4D 35 09 	mov si, state
0088   0497 FD 4F A4 09 	mov di, state_chars
0089   049B 38 6F 00    	mov c, (WIDTH+1)
0090   049E             state_convert_loop:
0091   049E F6          	lodsb
0092   049F 22 00       	mov ah, 0
0093   04A1 B7 55 08    	mov a, [a + table_translate]
0094   04A4 F7          	stosb
0095   04A5 A9 9E 04    	loopc state_convert_loop
0096   04A8             	
0097   04A8 3B A4 09    	mov d, state_chars
0098   04AB 07 0E 07    	call puts
0099   04AE             	
0100   04AE 07 BB 06    	call printnl
0101   04B1 0A 4F 04    	jmp auto_L1	
0102   04B4             automaton_ret:
0103   04B4 F9          	leave
0104   04B5             	
0105   04B5 09          	ret
0106   04B6             	
0107   04B6             chg_rules:
0108   04B6 3B 46 08    	mov d, s_rule
0109   04B9 07 0E 07    	call puts
0110   04BC 3B 00 00    	mov d, 0
0111   04BF 38 04 00    	mov c, 4
0112   04C2             chg_rule_L1:
0113   04C2 07 8C 07    	call scan_u16x
0114   04C5 44 14 0A    	mov [d + automaton_table], a
0115   04C8 58 02 00    	add d, 2
0116   04CB A9 C2 04    	loopc chg_rule_L1
0117   04CE 09          	ret
0118   04CF             	
0119   04CF             .include "stdio.asm"
0001+  04CF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  04CF             ; stdio.s
0003+  04CF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  04CF             .include "string.asm"
0001++ 04CF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 04CF             ; string.s
0003++ 04CF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 04CF             
0005++ 04CF             
0006++ 04CF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 04CF             ; strrev
0008++ 04CF             ; reverse a string
0009++ 04CF             ; D = string address
0010++ 04CF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 04CF             ; 01234
0012++ 04CF             strrev:
0013++ 04CF 4B          	pusha
0014++ 04D0 07 16 05    	call strlen	; length in C
0015++ 04D3 12          	mov a, c
0016++ 04D4 AF 01 00    	cmp a, 1
0017++ 04D7 D0 F1 04    	jleu strrev_end	; check string length. string len must be > 1
0018++ 04DA 7D          	dec a
0019++ 04DB FD 4E       	mov si, d	; beginning of string
0020++ 04DD FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 04DF 59          	add d, a	; end of string
0022++ 04E0 12          	mov a, c
0023++ 04E1 FD 9B       	shr a		; divide by 2
0024++ 04E3 39          	mov c, a	; C now counts the steps
0025++ 04E4             strrev_L0:
0026++ 04E4 32          	mov bl, [d]	; save load right-side char into BL
0027++ 04E5 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 04E6 3E          	mov [d], al	; store left char into right side
0029++ 04E7 1B          	mov al, bl
0030++ 04E8 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 04E9 7E          	dec c
0032++ 04EA 7F          	dec d
0033++ 04EB C2 00 00    	cmp c, 0
0034++ 04EE C7 E4 04    	jne strrev_L0
0035++ 04F1             strrev_end:
0036++ 04F1 4C          	popa
0037++ 04F2 09          	ret
0038++ 04F3             	
0039++ 04F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 04F3             ; strchr
0041++ 04F3             ; search string in D for char in AL
0042++ 04F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 04F3             strchr:
0044++ 04F3             strchr_L0:
0045++ 04F3 32          	mov bl, [d]
0046++ 04F4 C1 00       	cmp bl, 0
0047++ 04F6 C6 01 05    	je strchr_end
0048++ 04F9 BA          	cmp al, bl
0049++ 04FA C6 01 05    	je strchr_end
0050++ 04FD 79          	inc d
0051++ 04FE 0A F3 04    	jmp strchr_L0
0052++ 0501             strchr_end:
0053++ 0501 1B          	mov al, bl
0054++ 0502 09          	ret
0055++ 0503             
0056++ 0503             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0503             ; strstr
0058++ 0503             ; find sub-string
0059++ 0503             ; str1 in SI
0060++ 0503             ; str2 in DI
0061++ 0503             ; SI points to end of source string
0062++ 0503             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0503             strstr:
0064++ 0503 DB          	push al
0065++ 0504 DA          	push d
0066++ 0505 E3          	push di
0067++ 0506             strstr_loop:
0068++ 0506 F3          	cmpsb					; compare a byte of the strings
0069++ 0507 C7 12 05    	jne strstr_ret
0070++ 050A FC 00 00    	lea d, [di + 0]
0071++ 050D BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 050F C7 06 05    	jne strstr_loop				; equal chars but not at end
0073++ 0512             strstr_ret:
0074++ 0512 F0          	pop di
0075++ 0513 E7          	pop d
0076++ 0514 E8          	pop al
0077++ 0515 09          	ret
0078++ 0516             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0516             ; length of null terminated string
0080++ 0516             ; result in C
0081++ 0516             ; pointer in D
0082++ 0516             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0516             strlen:
0084++ 0516 DA          	push d
0085++ 0517 38 00 00    	mov c, 0
0086++ 051A             strlen_L1:
0087++ 051A BD 00       	cmp byte [d], 0
0088++ 051C C6 24 05    	je strlen_ret
0089++ 051F 79          	inc d
0090++ 0520 78          	inc c
0091++ 0521 0A 1A 05    	jmp strlen_L1
0092++ 0524             strlen_ret:
0093++ 0524 E7          	pop d
0094++ 0525 09          	ret
0095++ 0526             
0096++ 0526             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0526             ; STRCMP
0098++ 0526             ; compare two strings
0099++ 0526             ; str1 in SI
0100++ 0526             ; str2 in DI
0101++ 0526             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0526             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0526             strcmp:
0104++ 0526 DB          	push al
0105++ 0527 DA          	push d
0106++ 0528 E3          	push di
0107++ 0529 E2          	push si
0108++ 052A             strcmp_loop:
0109++ 052A F3          	cmpsb					; compare a byte of the strings
0110++ 052B C7 36 05    	jne strcmp_ret
0111++ 052E FB FF FF    	lea d, [si +- 1]
0112++ 0531 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0533 C7 2A 05    	jne strcmp_loop				; equal chars but not at end
0114++ 0536             strcmp_ret:
0115++ 0536 EF          	pop si
0116++ 0537 F0          	pop di
0117++ 0538 E7          	pop d
0118++ 0539 E8          	pop al
0119++ 053A 09          	ret
0120++ 053B             
0121++ 053B             
0122++ 053B             ; STRCPY
0123++ 053B             ; copy null terminated string from SI to DI
0124++ 053B             ; source in SI
0125++ 053B             ; destination in DI
0126++ 053B             strcpy:
0127++ 053B E2          	push si
0128++ 053C E3          	push di
0129++ 053D DB          	push al
0130++ 053E             strcpy_L1:
0131++ 053E F6          	lodsb
0132++ 053F F7          	stosb
0133++ 0540 B9 00       	cmp al, 0
0134++ 0542 C7 3E 05    	jne strcpy_L1
0135++ 0545             strcpy_end:
0136++ 0545 E8          	pop al
0137++ 0546 F0          	pop di
0138++ 0547 EF          	pop si
0139++ 0548 09          	ret
0140++ 0549             
0141++ 0549             ; STRCAT
0142++ 0549             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0549             ; source in SI
0144++ 0549             ; destination in DI
0145++ 0549             strcat:
0146++ 0549 E2          	push si
0147++ 054A E3          	push di
0148++ 054B D7          	push a
0149++ 054C DA          	push d
0150++ 054D 50          	mov a, di
0151++ 054E 3C          	mov d, a
0152++ 054F             strcat_goto_end_L1:
0153++ 054F BD 00       	cmp byte[d], 0
0154++ 0551 C6 58 05    	je strcat_start
0155++ 0554 79          	inc d
0156++ 0555 0A 4F 05    	jmp strcat_goto_end_L1
0157++ 0558             strcat_start:
0158++ 0558 FD 50       	mov di, d
0159++ 055A             strcat_L1:
0160++ 055A F6          	lodsb
0161++ 055B F7          	stosb
0162++ 055C B9 00       	cmp al, 0
0163++ 055E C7 5A 05    	jne strcat_L1
0164++ 0561             strcat_end:
0165++ 0561 E7          	pop d
0166++ 0562 E4          	pop a
0167++ 0563 F0          	pop di
0168++ 0564 EF          	pop si
0169++ 0565 09          	ret
0005+  0566             
0006+  0566 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  056A 34 35 36 37 
0006+  056E 38 39 41 42 
0006+  0572 43 44 45 46 
0007+  0576             
0008+  0576 01 00       table_power:.dw 1
0009+  0578 0A 00       			.dw 10
0010+  057A 64 00       			.dw 100
0011+  057C E8 03       			.dw 1000
0012+  057E 10 27       			.dw 10000
0013+  0580             
0014+  0580             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0015+  0580             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0016+  0580             ; ASCII in BL
0017+  0580             ; result in AL
0018+  0580             ; ascii for F = 0100 0110
0019+  0580             ; ascii for 9 = 0011 1001
0020+  0580             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0021+  0580             hex_ascii_encode:
0022+  0580 1B          	mov al, bl
0023+  0581 93 40       	test al, $40				; test if letter or number
0024+  0583 C7 89 05    	jnz hex_letter
0025+  0586 87 0F       	and al, $0F				; get number
0026+  0588 09          	ret
0027+  0589             hex_letter:
0028+  0589 87 0F       	and al, $0F				; get letter
0029+  058B 6A 09       	add al, 9
0030+  058D 09          	ret
0031+  058E             
0032+  058E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0033+  058E             ; ATOI
0034+  058E             ; 2 letter hex string in B
0035+  058E             ; 8bit integer returned in AL
0036+  058E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0037+  058E             atoi:
0038+  058E D8          	push b
0039+  058F 07 80 05    	call hex_ascii_encode			; convert BL to 4bit code in AL
0040+  0592 30          	mov bl, bh
0041+  0593 DB          	push al					; save a
0042+  0594 07 80 05    	call hex_ascii_encode
0043+  0597 EA          	pop bl	
0044+  0598 FD 9E 04    	shl al, 4
0045+  059B 8C          	or al, bl
0046+  059C E5          	pop b
0047+  059D 09          	ret	
0048+  059E             
0049+  059E             
0050+  059E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  059E             ; printf
0052+  059E             ; no need for explanations!
0053+  059E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0054+  059E             printf:
0055+  059E 09          	ret
0056+  059F             
0057+  059F             
0058+  059F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  059F             ; scanf
0060+  059F             ; no need for explanations!
0061+  059F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  059F             scanf:
0063+  059F 09          	ret
0064+  05A0             
0065+  05A0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  05A0             ; ITOA
0067+  05A0             ; 8bit value in BL
0068+  05A0             ; 2 byte ASCII result in A
0069+  05A0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0070+  05A0             itoa:
0071+  05A0 DA          	push d
0072+  05A1 D8          	push b
0073+  05A2 A7 00       	mov bh, 0
0074+  05A4 FD A4 04    	shr bl, 4	
0075+  05A7 74          	mov d, b
0076+  05A8 1F 66 05    	mov al, [d + s_hex_digits]
0077+  05AB 23          	mov ah, al
0078+  05AC             	
0079+  05AC E5          	pop b
0080+  05AD D8          	push b
0081+  05AE A7 00       	mov bh, 0
0082+  05B0 FD 87 0F    	and bl, $0F
0083+  05B3 74          	mov d, b
0084+  05B4 1F 66 05    	mov al, [d + s_hex_digits]
0085+  05B7 E5          	pop b
0086+  05B8 E7          	pop d
0087+  05B9 09          	ret
0088+  05BA             
0089+  05BA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0090+  05BA             ; HEX STRING TO BINARY
0091+  05BA             ; di = destination address
0092+  05BA             ; si = source
0093+  05BA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0094+  05BA             hex_to_int:
0095+  05BA             hex_to_int_L1:
0096+  05BA F6          	lodsb					; load from [SI] to AL
0097+  05BB B9 00       	cmp al, 0				; check if ASCII 0
0098+  05BD C6 CA 05    	jz hex_to_int_ret
0099+  05C0 36          	mov bh, al
0100+  05C1 F6          	lodsb
0101+  05C2 2F          	mov bl, al
0102+  05C3 07 8E 05    	call atoi				; convert ASCII byte in B to int (to AL)
0103+  05C6 F7          	stosb					; store AL to [DI]
0104+  05C7 0A BA 05    	jmp hex_to_int_L1
0105+  05CA             hex_to_int_ret:
0106+  05CA 09          	ret		
0107+  05CB             
0108+  05CB             
0109+  05CB             
0110+  05CB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  05CB             ; GETCHAR
0112+  05CB             ; char in ah
0113+  05CB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0114+  05CB             getchar:
0115+  05CB DB          	push al
0116+  05CC             getchar_retry:
0117+  05CC FD 0C       	sti
0118+  05CE 19 01       	mov al, 1
0119+  05D0 05 03       	syscall sys_io			; receive in AH
0120+  05D2 B9 00       	cmp al, 0			; check if any char was receive
0121+  05D4 C6 CC 05    	je getchar_retry
0122+  05D7 E8          	pop al
0123+  05D8 09          	ret
0124+  05D9             
0125+  05D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0126+  05D9             ; PUTCHAR
0127+  05D9             ; char in ah
0128+  05D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  05D9             putchar:
0130+  05D9 D7          	push a
0131+  05DA 19 00       	mov al, 0
0132+  05DC 05 03       	syscall sys_io			; char in AH
0133+  05DE E4          	pop a
0134+  05DF 09          	ret
0135+  05E0             
0136+  05E0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0137+  05E0             ;; INPUT A STRING
0138+  05E0             ;; terminates with null
0139+  05E0             ;; pointer in D
0140+  05E0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  05E0             gets:
0142+  05E0 D7          	push a
0143+  05E1 DA          	push d
0144+  05E2             gets_loop:
0145+  05E2 FD 0C       	sti
0146+  05E4 19 01       	mov al, 1
0147+  05E6 05 03       	syscall sys_io			; receive in AH
0148+  05E8 B9 00       	cmp al, 0				; check error code (AL)
0149+  05EA C6 E2 05    	je gets_loop			; if no char received, retry
0150+  05ED             
0151+  05ED 76 1B       	cmp ah, 27
0152+  05EF C6 0B 06    	je gets_telnet_escape
0153+  05F2 76 0A       	cmp ah, $0A				; LF
0154+  05F4 C6 64 06    	je gets_end
0155+  05F7 76 5C       	cmp ah, $5C				; '\\'
0156+  05F9 C6 3B 06    	je gets_escape
0157+  05FC             	
0158+  05FC 76 08       	cmp ah, $08			; check for backspace
0159+  05FE C6 07 06    	je gets_backspace
0160+  0601             
0161+  0601 1A          	mov al, ah
0162+  0602 3E          	mov [d], al
0163+  0603 79          	inc d
0164+  0604 0A E2 05    	jmp gets_loop
0165+  0607             gets_backspace:
0166+  0607 7F          	dec d
0167+  0608 0A E2 05    	jmp gets_loop
0168+  060B             gets_telnet_escape:
0169+  060B FD 0C       	sti
0170+  060D 19 01       	mov al, 1
0171+  060F 05 03       	syscall sys_io				; receive in AH without echo
0172+  0611 B9 00       	cmp al, 0					; check error code (AL)
0173+  0613 C6 0B 06    	je gets_telnet_escape		; if no char received, retry
0174+  0616 76 5B       	cmp ah, '['
0175+  0618 C7 E2 05    	jne gets_loop
0176+  061B             gets_telnet_escape_phase2:
0177+  061B FD 0C       	sti
0178+  061D 19 01       	mov al, 1
0179+  061F 05 03       	syscall sys_io					; receive in AH without echo
0180+  0621 B9 00       	cmp al, 0						; check error code (AL)
0181+  0623 C6 1B 06    	je gets_telnet_escape_phase2	; if no char received, retry
0182+  0626 76 44       	cmp ah, 'D'
0183+  0628 C6 33 06    	je gets_left_arrow
0184+  062B 76 43       	cmp ah, 'C'
0185+  062D C6 37 06    	je gets_right_arrow
0186+  0630 0A E2 05    	jmp gets_loop
0187+  0633             gets_left_arrow:
0188+  0633 7F          	dec d
0189+  0634 0A E2 05    	jmp gets_loop
0190+  0637             gets_right_arrow:
0191+  0637 79          	inc d
0192+  0638 0A E2 05    	jmp gets_loop
0193+  063B             gets_escape:
0194+  063B FD 0C       	sti
0195+  063D 19 01       	mov al, 1
0196+  063F 05 03       	syscall sys_io			; receive in AH
0197+  0641 B9 00       	cmp al, 0				; check error code (AL)
0198+  0643 C6 3B 06    	je gets_escape			; if no char received, retry
0199+  0646 76 6E       	cmp ah, 'n'
0200+  0648 C6 56 06    	je gets_LF
0201+  064B 76 72       	cmp ah, 'r'
0202+  064D C6 5D 06    	je gets_CR
0203+  0650 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0204+  0651 3E          	mov [d], al
0205+  0652 79          	inc d
0206+  0653 0A E2 05    	jmp gets_loop
0207+  0656             gets_LF:
0208+  0656 19 0A       	mov al, $0A
0209+  0658 3E          	mov [d], al
0210+  0659 79          	inc d
0211+  065A 0A E2 05    	jmp gets_loop
0212+  065D             gets_CR:
0213+  065D 19 0D       	mov al, $0D
0214+  065F 3E          	mov [d], al
0215+  0660 79          	inc d
0216+  0661 0A E2 05    	jmp gets_loop
0217+  0664             gets_end:
0218+  0664 19 00       	mov al, 0
0219+  0666 3E          	mov [d], al				; terminate string
0220+  0667 E7          	pop d
0221+  0668 E4          	pop a
0222+  0669 09          	ret
0223+  066A             
0224+  066A             
0225+  066A             
0226+  066A             
0227+  066A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0228+  066A             ;; INPUT TEXT
0229+  066A             ;; terminated with CTRL+D
0230+  066A             ;; pointer in D
0231+  066A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0232+  066A             gettxt:
0233+  066A D7          	push a
0234+  066B DA          	push d
0235+  066C             gettxt_loop:
0236+  066C 19 01       	mov al, 1
0237+  066E 05 03       	syscall sys_io			; receive in AH
0238+  0670 B9 00       	cmp al, 0				; check error code (AL)
0239+  0672 C6 6C 06    	je gettxt_loop		; if no char received, retry
0240+  0675 76 04       	cmp ah, 4			; EOT
0241+  0677 C6 B5 06    	je gettxt_end
0242+  067A 76 08       	cmp ah, $08			; check for backspace
0243+  067C C6 B1 06    	je gettxt_backspace
0244+  067F 76 5C       	cmp ah, $5C				; '\\'
0245+  0681 C6 8A 06    	je gettxt_escape
0246+  0684 1A          	mov al, ah
0247+  0685 3E          	mov [d], al
0248+  0686 79          	inc d
0249+  0687 0A 6C 06    	jmp gettxt_loop
0250+  068A             gettxt_escape:
0251+  068A 19 01       	mov al, 1
0252+  068C 05 03       	syscall sys_io			; receive in AH
0253+  068E B9 00       	cmp al, 0				; check error code (AL)
0254+  0690 C6 8A 06    	je gettxt_escape		; if no char received, retry
0255+  0693 76 6E       	cmp ah, 'n'
0256+  0695 C6 A3 06    	je gettxt_LF
0257+  0698 76 72       	cmp ah, 'r'
0258+  069A C6 AA 06    	je gettxt_CR
0259+  069D 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0260+  069E 3E          	mov [d], al
0261+  069F 79          	inc d
0262+  06A0 0A 6C 06    	jmp gettxt_loop
0263+  06A3             gettxt_LF:
0264+  06A3 19 0A       	mov al, $0A
0265+  06A5 3E          	mov [d], al
0266+  06A6 79          	inc d
0267+  06A7 0A 6C 06    	jmp gettxt_loop
0268+  06AA             gettxt_CR:
0269+  06AA 19 0D       	mov al, $0D
0270+  06AC 3E          	mov [d], al
0271+  06AD 79          	inc d
0272+  06AE 0A 6C 06    	jmp gettxt_loop
0273+  06B1             gettxt_backspace:
0274+  06B1 7F          	dec d
0275+  06B2 0A 6C 06    	jmp gettxt_loop
0276+  06B5             gettxt_end:
0277+  06B5 19 00       	mov al, 0
0278+  06B7 3E          	mov [d], al				; terminate string
0279+  06B8 E7          	pop d
0280+  06B9 E4          	pop a
0281+  06BA 09          	ret
0282+  06BB             
0283+  06BB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0284+  06BB             ; PRINT NEW LINE
0285+  06BB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0286+  06BB             printnl:
0287+  06BB D7          	push a
0288+  06BC 10 00 0A    	mov a, $0A00
0289+  06BF 05 03       	syscall sys_io
0290+  06C1 10 00 0D    	mov a, $0D00
0291+  06C4 05 03       	syscall sys_io
0292+  06C6 E4          	pop a
0293+  06C7 09          	ret
0294+  06C8             
0295+  06C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0296+  06C8             ; strtoint
0297+  06C8             ; 4 digit hex string number in d
0298+  06C8             ; integer returned in A
0299+  06C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0300+  06C8             strtointx:
0301+  06C8 D8          	push b
0302+  06C9 32          	mov bl, [d]
0303+  06CA 37          	mov bh, bl
0304+  06CB 33 01 00    	mov bl, [d + 1]
0305+  06CE 07 8E 05    	call atoi				; convert to int in AL
0306+  06D1 23          	mov ah, al				; move to AH
0307+  06D2 33 02 00    	mov bl, [d + 2]
0308+  06D5 37          	mov bh, bl
0309+  06D6 33 03 00    	mov bl, [d + 3]
0310+  06D9 07 8E 05    	call atoi				; convert to int in AL
0311+  06DC E5          	pop b
0312+  06DD 09          	ret
0313+  06DE             
0314+  06DE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0315+  06DE             ; strtoint
0316+  06DE             ; 5 digit base10 string number in d
0317+  06DE             ; integer returned in A
0318+  06DE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0319+  06DE             strtoint:
0320+  06DE E2          	push si
0321+  06DF D8          	push b
0322+  06E0 D9          	push c
0323+  06E1 DA          	push d
0324+  06E2 07 16 05    	call strlen			; get string length in C
0325+  06E5 7E          	dec c
0326+  06E6 FD 4E       	mov si, d
0327+  06E8 12          	mov a, c
0328+  06E9 FD 99       	shl a
0329+  06EB 3B 76 05    	mov d, table_power
0330+  06EE 59          	add d, a
0331+  06EF 38 00 00    	mov c, 0
0332+  06F2             strtoint_L0:
0333+  06F2 F6          	lodsb			; load ASCII to al
0334+  06F3 B9 00       	cmp al, 0
0335+  06F5 C6 08 07    	je strtoint_end
0336+  06F8 6F 30       	sub al, $30		; make into integer
0337+  06FA 22 00       	mov ah, 0
0338+  06FC 2A          	mov b, [d]
0339+  06FD AC          	mul a, b			; result in B since it fits in 16bits
0340+  06FE 11          	mov a, b
0341+  06FF 28          	mov b, c
0342+  0700 54          	add a, b
0343+  0701 39          	mov c, a
0344+  0702 63 02 00    	sub d, 2
0345+  0705 0A F2 06    	jmp strtoint_L0
0346+  0708             strtoint_end:
0347+  0708 12          	mov a, c
0348+  0709 E7          	pop d
0349+  070A E6          	pop c
0350+  070B E5          	pop b
0351+  070C EF          	pop si
0352+  070D 09          	ret
0353+  070E             
0354+  070E             
0355+  070E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  070E             ; PRINT NULL TERMINATED STRING
0357+  070E             ; pointer in D
0358+  070E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  070E             puts:
0360+  070E D7          	push a
0361+  070F DA          	push d
0362+  0710             puts_L1:
0363+  0710 1E          	mov al, [d]
0364+  0711 B9 00       	cmp al, 0
0365+  0713 C6 1F 07    	jz puts_END
0366+  0716 23          	mov ah, al
0367+  0717 19 00       	mov al, 0
0368+  0719 05 03       	syscall sys_io
0369+  071B 79          	inc d
0370+  071C 0A 10 07    	jmp puts_L1
0371+  071F             puts_END:
0372+  071F E7          	pop d
0373+  0720 E4          	pop a
0374+  0721 09          	ret
0375+  0722             
0376+  0722             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0377+  0722             ; PRINT N SIZE STRING
0378+  0722             ; pointer in D
0379+  0722             ; size in C
0380+  0722             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0381+  0722             putsn:
0382+  0722 DB          	push al
0383+  0723 DA          	push d
0384+  0724 D9          	push c
0385+  0725             putsn_L0:
0386+  0725 1E          	mov al, [d]
0387+  0726 23          	mov ah, al
0388+  0727 19 00       	mov al, 0
0389+  0729 05 03       	syscall sys_io
0390+  072B 79          	inc d
0391+  072C 7E          	dec c	
0392+  072D C2 00 00    	cmp c, 0
0393+  0730 C7 25 07    	jne putsn_L0
0394+  0733             putsn_end:
0395+  0733 E6          	pop c
0396+  0734 E7          	pop d
0397+  0735 E8          	pop al
0398+  0736 09          	ret
0399+  0737             
0400+  0737             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0401+  0737             ; print 16bit decimal number
0402+  0737             ; input number in A
0403+  0737             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  0737             print_u16d:
0405+  0737 D7          	push a
0406+  0738 D8          	push b
0407+  0739 26 10 27    	mov b, 10000
0408+  073C AE          	div a, b			; get 10000 coeff.
0409+  073D 07 63 07    	call print_zero_or_space
0410+  0740 11          	mov a, b
0411+  0741 26 E8 03    	mov b, 1000
0412+  0744 AE          	div a, b			; get 10000 coeff.
0413+  0745 07 63 07    	call print_zero_or_space
0414+  0748 11          	mov a, b
0415+  0749 26 64 00    	mov b, 100
0416+  074C AE          	div a, b
0417+  074D 07 63 07    	call print_zero_or_space
0418+  0750 11          	mov a, b
0419+  0751 26 0A 00    	mov b, 10
0420+  0754 AE          	div a, b
0421+  0755 07 63 07    	call print_zero_or_space
0422+  0758 11          	mov a, b
0423+  0759 6A 30       	add al, $30
0424+  075B 23          	mov ah, al
0425+  075C 19 00       	mov al, 0
0426+  075E 05 03       	syscall sys_io	; print coeff
0427+  0760 E5          	pop b
0428+  0761 E4          	pop a
0429+  0762 09          	ret
0430+  0763             
0431+  0763             
0432+  0763             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0433+  0763             ; if A == 0, print space
0434+  0763             ; else print A
0435+  0763             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  0763             print_zero_or_space:
0437+  0763             	; cmp a, 0
0438+  0763             	; jne print_number
0439+  0763             	; mov ah, $20
0440+  0763             	; call putchar
0441+  0763             	; ret
0442+  0763             print_number:
0443+  0763 6A 30       	add al, $30
0444+  0765 23          	mov ah, al
0445+  0766 07 D9 05    	call putchar
0446+  0769 09          	ret
0447+  076A             
0448+  076A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  076A             ; PRINT 16BIT HEX INTEGER
0450+  076A             ; integer value in reg B
0451+  076A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0452+  076A             print_u16x:
0453+  076A D7          	push a
0454+  076B D8          	push b
0455+  076C DD          	push bl
0456+  076D 30          	mov bl, bh
0457+  076E 07 A0 05    	call itoa				; convert bh to char in A
0458+  0771 2F          	mov bl, al				; save al
0459+  0772 19 00       	mov al, 0
0460+  0774 05 03       	syscall sys_io				; display AH
0461+  0776 24          	mov ah, bl				; retrieve al
0462+  0777 19 00       	mov al, 0
0463+  0779 05 03       	syscall sys_io				; display AL
0464+  077B             
0465+  077B EA          	pop bl
0466+  077C 07 A0 05    	call itoa				; convert bh to char in A
0467+  077F 2F          	mov bl, al				; save al
0468+  0780 19 00       	mov al, 0
0469+  0782 05 03       	syscall sys_io				; display AH
0470+  0784 24          	mov ah, bl				; retrieve al
0471+  0785 19 00       	mov al, 0
0472+  0787 05 03       	syscall sys_io				; display AL
0473+  0789             
0474+  0789 E5          	pop b
0475+  078A E4          	pop a
0476+  078B 09          	ret
0477+  078C             
0478+  078C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  078C             ; INPUT 16BIT HEX INTEGER
0480+  078C             ; read 16bit integer into A
0481+  078C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0482+  078C             scan_u16x:
0483+  078C F8 10 00    	enter 16
0484+  078F D8          	push b
0485+  0790 DA          	push d
0486+  0791             
0487+  0791 FA F1 FF    	lea d, [bp + -15]
0488+  0794 07 E0 05    	call gets				; get number
0489+  0797             
0490+  0797 32          	mov bl, [d]
0491+  0798 37          	mov bh, bl
0492+  0799 33 01 00    	mov bl, [d + 1]
0493+  079C 07 8E 05    	call atoi				; convert to int in AL
0494+  079F 23          	mov ah, al				; move to AH
0495+  07A0             
0496+  07A0 33 02 00    	mov bl, [d + 2]
0497+  07A3 37          	mov bh, bl
0498+  07A4 33 03 00    	mov bl, [d + 3]
0499+  07A7 07 8E 05    	call atoi				; convert to int in AL
0500+  07AA             
0501+  07AA E7          	pop d
0502+  07AB E5          	pop b
0503+  07AC F9          	leave
0504+  07AD 09          	ret
0505+  07AE             
0506+  07AE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  07AE             ; PRINT 8bit HEX INTEGER
0508+  07AE             ; integer value in reg bl
0509+  07AE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0510+  07AE             print_u8x:
0511+  07AE D7          	push a
0512+  07AF DD          	push bl
0513+  07B0             
0514+  07B0 07 A0 05    	call itoa				; convert bl to char in A
0515+  07B3 2F          	mov bl, al				; save al
0516+  07B4 19 00       	mov al, 0
0517+  07B6 05 03       	syscall sys_io				; display AH
0518+  07B8 24          	mov ah, bl				; retrieve al
0519+  07B9 19 00       	mov al, 0
0520+  07BB 05 03       	syscall sys_io				; display AL
0521+  07BD             
0522+  07BD EA          	pop bl
0523+  07BE E4          	pop a
0524+  07BF 09          	ret
0525+  07C0             
0526+  07C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  07C0             ; print 8bit decimal unsigned number
0528+  07C0             ; input number in AL
0529+  07C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0530+  07C0             print_u8d:
0531+  07C0 D7          	push a
0532+  07C1 D8          	push b
0533+  07C2             
0534+  07C2 22 00       	mov ah, 0
0535+  07C4 26 64 00    	mov b, 100
0536+  07C7 AE          	div a, b
0537+  07C8 D8          	push b			; save remainder
0538+  07C9 B9 00       	cmp al, 0
0539+  07CB C6 D5 07    	je skip100
0540+  07CE 6A 30       	add al, $30
0541+  07D0 23          	mov ah, al
0542+  07D1 19 00       	mov al, 0
0543+  07D3 05 03       	syscall sys_io	; print coeff
0544+  07D5             skip100:
0545+  07D5 E4          	pop a
0546+  07D6 22 00       	mov ah, 0
0547+  07D8 26 0A 00    	mov b, 10
0548+  07DB AE          	div a, b
0549+  07DC D8          	push b			; save remainder
0550+  07DD B9 00       	cmp al, 0
0551+  07DF C6 E9 07    	je skip10
0552+  07E2 6A 30       	add al, $30
0553+  07E4 23          	mov ah, al
0554+  07E5 19 00       	mov al, 0
0555+  07E7 05 03       	syscall sys_io	; print coeff
0556+  07E9             skip10:
0557+  07E9 E4          	pop a
0558+  07EA 1B          	mov al, bl
0559+  07EB 6A 30       	add al, $30
0560+  07ED 23          	mov ah, al
0561+  07EE 19 00       	mov al, 0
0562+  07F0 05 03       	syscall sys_io	; print coeff
0563+  07F2 E5          	pop b
0564+  07F3 E4          	pop a
0565+  07F4 09          	ret
0566+  07F5             
0567+  07F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  07F5             ; INPUT 8BIT HEX INTEGER
0569+  07F5             ; read 8bit integer into AL
0570+  07F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0571+  07F5             scan_u8x:
0572+  07F5 F8 04 00    	enter 4
0573+  07F8 D8          	push b
0574+  07F9 DA          	push d
0575+  07FA             
0576+  07FA FA FD FF    	lea d, [bp + -3]
0577+  07FD 07 E0 05    	call gets				; get number
0578+  0800             
0579+  0800 32          	mov bl, [d]
0580+  0801 37          	mov bh, bl
0581+  0802 33 01 00    	mov bl, [d + 1]
0582+  0805 07 8E 05    	call atoi				; convert to int in AL
0583+  0808             
0584+  0808 E7          	pop d
0585+  0809 E5          	pop b
0586+  080A F9          	leave
0587+  080B 09          	ret
0588+  080C             
0589+  080C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0590+  080C             ; input decimal number
0591+  080C             ; result in A
0592+  080C             ; 655'\0'
0593+  080C             ; low--------high
0594+  080C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0595+  080C             scan_u16d:
0596+  080C F8 08 00    	enter 8
0597+  080F E2          	push si
0598+  0810 D8          	push b
0599+  0811 D9          	push c
0600+  0812 DA          	push d
0601+  0813 FA F9 FF    	lea d, [bp +- 7]
0602+  0816 07 E0 05    	call gets
0603+  0819 07 16 05    	call strlen			; get string length in C
0604+  081C 7E          	dec c
0605+  081D FD 4E       	mov si, d
0606+  081F 12          	mov a, c
0607+  0820 FD 99       	shl a
0608+  0822 3B 76 05    	mov d, table_power
0609+  0825 59          	add d, a
0610+  0826 38 00 00    	mov c, 0
0611+  0829             mul_loop:
0612+  0829 F6          	lodsb			; load ASCII to al
0613+  082A B9 00       	cmp al, 0
0614+  082C C6 3F 08    	je mul_exit
0615+  082F 6F 30       	sub al, $30		; make into integer
0616+  0831 22 00       	mov ah, 0
0617+  0833 2A          	mov b, [d]
0618+  0834 AC          	mul a, b			; result in B since it fits in 16bits
0619+  0835 11          	mov a, b
0620+  0836 28          	mov b, c
0621+  0837 54          	add a, b
0622+  0838 39          	mov c, a
0623+  0839 63 02 00    	sub d, 2
0624+  083C 0A 29 08    	jmp mul_loop
0625+  083F             mul_exit:
0626+  083F 12          	mov a, c
0627+  0840 E7          	pop d
0628+  0841 E6          	pop c
0629+  0842 E5          	pop b
0630+  0843 EF          	pop si
0631+  0844 F9          	leave
0632+  0845 09          	ret
0120   0846             
0121   0846             
0122   0846             	
0123   0846 52 75 6C 65 s_rule:		.db "Rule: ", 0
0123   084A 3A 20 00 
0124   084D 53 74 65 70 s_steps:	.db "Steps: ", 0
0124   0851 73 3A 20 00 
0125   0855             
0126   0855 20          table_translate:	.db ' '
0127   0856 76          					.db 'v'
0128   0857             	
0129   0857 00 00 00 00 init_state: 	.fill (WIDTH/2), 0
0129   085B 00 00 00 00 
0129   085F 00 00 00 00 
0129   0863 00 00 00 00 
0129   0867 00 00 00 00 
0129   086B 00 00 00 00 
0129   086F 00 00 00 00 
0129   0873 00 00 00 00 
0129   0877 00 00 00 00 
0129   087B 00 00 00 00 
0129   087F 00 00 00 00 
0129   0883 00 00 00 00 
0129   0887 00 00 00 00 
0129   088B 00 00 00 
0130   088E 01          				.db 1 
0131   088F 00 00 00 00 				.fill (WIDTH/2), 0
0131   0893 00 00 00 00 
0131   0897 00 00 00 00 
0131   089B 00 00 00 00 
0131   089F 00 00 00 00 
0131   08A3 00 00 00 00 
0131   08A7 00 00 00 00 
0131   08AB 00 00 00 00 
0131   08AF 00 00 00 00 
0131   08B3 00 00 00 00 
0131   08B7 00 00 00 00 
0131   08BB 00 00 00 00 
0131   08BF 00 00 00 00 
0131   08C3 00 00 00 
0132   08C6             
0133   08C6 00 00 00 00 prev_state: 	.fill (WIDTH/2), 0
0133   08CA 00 00 00 00 
0133   08CE 00 00 00 00 
0133   08D2 00 00 00 00 
0133   08D6 00 00 00 00 
0133   08DA 00 00 00 00 
0133   08DE 00 00 00 00 
0133   08E2 00 00 00 00 
0133   08E6 00 00 00 00 
0133   08EA 00 00 00 00 
0133   08EE 00 00 00 00 
0133   08F2 00 00 00 00 
0133   08F6 00 00 00 00 
0133   08FA 00 00 00 
0134   08FD 01          				.db 1 
0135   08FE 00 00 00 00 				.fill (WIDTH/2), 0
0135   0902 00 00 00 00 
0135   0906 00 00 00 00 
0135   090A 00 00 00 00 
0135   090E 00 00 00 00 
0135   0912 00 00 00 00 
0135   0916 00 00 00 00 
0135   091A 00 00 00 00 
0135   091E 00 00 00 00 
0135   0922 00 00 00 00 
0135   0926 00 00 00 00 
0135   092A 00 00 00 00 
0135   092E 00 00 00 00 
0135   0932 00 00 00 
0136   0935             		
0137   0935 00 00 00 00 state: 			.fill (WIDTH+1), 0
0137   0939 00 00 00 00 
0137   093D 00 00 00 00 
0137   0941 00 00 00 00 
0137   0945 00 00 00 00 
0137   0949 00 00 00 00 
0137   094D 00 00 00 00 
0137   0951 00 00 00 00 
0137   0955 00 00 00 00 
0137   0959 00 00 00 00 
0137   095D 00 00 00 00 
0137   0961 00 00 00 00 
0137   0965 00 00 00 00 
0137   0969 00 00 00 00 
0137   096D 00 00 00 00 
0137   0971 00 00 00 00 
0137   0975 00 00 00 00 
0137   0979 00 00 00 00 
0137   097D 00 00 00 00 
0137   0981 00 00 00 00 
0137   0985 00 00 00 00 
0137   0989 00 00 00 00 
0137   098D 00 00 00 00 
0137   0991 00 00 00 00 
0137   0995 00 00 00 00 
0137   0999 00 00 00 00 
0137   099D 00 00 00 00 
0137   09A1 00 00 00 
0138   09A4             
0139   09A4 20 20 20 20 state_chars:	.fill (WIDTH+1), ' '
0139   09A8 20 20 20 20 
0139   09AC 20 20 20 20 
0139   09B0 20 20 20 20 
0139   09B4 20 20 20 20 
0139   09B8 20 20 20 20 
0139   09BC 20 20 20 20 
0139   09C0 20 20 20 20 
0139   09C4 20 20 20 20 
0139   09C8 20 20 20 20 
0139   09CC 20 20 20 20 
0139   09D0 20 20 20 20 
0139   09D4 20 20 20 20 
0139   09D8 20 20 20 20 
0139   09DC 20 20 20 20 
0139   09E0 20 20 20 20 
0139   09E4 20 20 20 20 
0139   09E8 20 20 20 20 
0139   09EC 20 20 20 20 
0139   09F0 20 20 20 20 
0139   09F4 20 20 20 20 
0139   09F8 20 20 20 20 
0139   09FC 20 20 20 20 
0139   0A00 20 20 20 20 
0139   0A04 20 20 20 20 
0139   0A08 20 20 20 20 
0139   0A0C 20 20 20 20 
0139   0A10 20 20 20 
0140   0A13 00          				.db 0
0141   0A14             
0142   0A14             automaton_table:
0143   0A14 01          	.db 1		; 000
0144   0A15 00          	.db 0		; 001
0145   0A16 01          	.db 1		; 010
0146   0A17 00          	.db 0		; 011
0147   0A18 00          	.db 0		; 100
0148   0A19 01          	.db 1		; 101
0149   0A1A 00          	.db 0		; 110
0150   0A1B 01          	.db 1		; 111
0151   0A1C             					
0152   0A1C             
0153   0A1C 0A 0D       s_menu:		.db "\n\r"
0154   0A1E 30 2E 20 52 			.db "0. Run automaton\n\r"
0154   0A22 75 6E 20 61 
0154   0A26 75 74 6F 6D 
0154   0A2A 61 74 6F 6E 
0154   0A2E 0A 0D 
0155   0A30 31 2E 20 43 			.db "1. Change rule\n\r"
0155   0A34 68 61 6E 67 
0155   0A38 65 20 72 75 
0155   0A3C 6C 65 0A 0D 
0156   0A40 32 2E 20 51 			.db "2. Quit\n\r"
0156   0A44 75 69 74 0A 
0156   0A48 0D 
0157   0A49 25 20 00    			.db "% ", 0
0158   0A4C             				
0159   0A4C             .end
tasm: Number of errors = 0
