0001   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002   0000             ; stdio.s
0003   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004   0000             .include "string.s"
0001+  0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0000             ; string.s
0003+  0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0000             
0005+  0000             
0006+  0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007+  0000             ; strrev
0008+  0000             ; reverse a string
0009+  0000             ; D = string address
0010+  0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  0000             ; 01234
0012+  0000             strrev:
0013+  0000 4B          	pusha
0014+  0001 07 48 00    	call strlen	; length in C
0015+  0004 12          	mov a, c
0016+  0005 AF 01 00    	cmp a, 1
0017+  0008 D0 22 00    	jleu strrev_end	; check string length. string len must be > 1
0018+  000B 7D          	dec a
0019+  000C FD 4E       	mov si, d	; beginning of string
0020+  000E FD 50       	mov di, d	; beginning of string (for destinations)
0021+  0010 59          	add d, a	; end of string
0022+  0011 12          	mov a, c
0023+  0012 FD 9B       	shr a		; divide by 2
0024+  0014 39          	mov c, a	; C now counts the steps
0025+  0015             strrev_L0:
0026+  0015 32          	mov bl, [d]	; save load right-side char into BL
0027+  0016 F6          	lodsb		; load left-side char into AL; increase SI
0028+  0017 3E          	mov [d], al	; store left char into right side
0029+  0018 1B          	mov al, bl
0030+  0019 F7          	stosb		; store right-side char into left-side; increase DI
0031+  001A 7E          	dec c
0032+  001B 7F          	dec d
0033+  001C C2 00 00    	cmp c, 0
0034+  001F C7 15 00    	jne strrev_L0
0035+  0022             strrev_end:
0036+  0022 4C          	popa
0037+  0023 09          	ret
0038+  0024             	
0039+  0024             	
0040+  0024             	
0041+  0024             	
0042+  0024             
0043+  0024             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  0024             ; strchr
0045+  0024             ; search string in D for char in AL
0046+  0024             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  0024             strchr:
0048+  0024             strchr_L0:
0049+  0024 32          	mov bl, [d]
0050+  0025 C1 00       	cmp bl, 0
0051+  0027 C6 32 00    	je strchr_end
0052+  002A BA          	cmp al, bl
0053+  002B C6 32 00    	je strchr_end
0054+  002E 79          	inc d
0055+  002F 0A 24 00    	jmp strchr_L0
0056+  0032             strchr_end:
0057+  0032 1B          	mov al, bl
0058+  0033 09          	ret
0059+  0034             
0060+  0034             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0061+  0034             ; strstr
0062+  0034             ; find sub-string
0063+  0034             ; str1 in SI
0064+  0034             ; str2 in DI
0065+  0034             ; SI points to end of source string
0066+  0034             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  0034             strstr:
0068+  0034 DB          	push al
0069+  0035 DA          	push d
0070+  0036 E3          	push di
0071+  0037             strstr_loop:
0072+  0037 F3          	cmpsb					; compare a byte of the strings
0073+  0038 C7 44 00    	jne strstr_ret
0074+  003B FC 00 00    	lea d, [di + 0]
0075+  003E 1E          	mov al, [d]
0076+  003F B9 00       	cmp al, 0				; check if at end of string (null)
0077+  0041 C7 37 00    	jne strstr_loop				; equal chars but not at end
0078+  0044             strstr_ret:
0079+  0044 F0          	pop di
0080+  0045 E7          	pop d
0081+  0046 E8          	pop al
0082+  0047 09          	ret
0083+  0048             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0084+  0048             ; length of null terminated string
0085+  0048             ; result in C
0086+  0048             ; pointer in D
0087+  0048             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0088+  0048             strlen:
0089+  0048 DA          	push d
0090+  0049 38 00 00    	mov c, 0
0091+  004C             strlen_L1:
0092+  004C BD 00       	cmp byte [d], 0
0093+  004E C6 56 00    	je strlen_ret
0094+  0051 79          	inc d
0095+  0052 78          	inc c
0096+  0053 0A 4C 00    	jmp strlen_L1
0097+  0056             strlen_ret:
0098+  0056 E7          	pop d
0099+  0057 09          	ret
0100+  0058             
0101+  0058             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0102+  0058             ; STRCMP
0103+  0058             ; compare two strings
0104+  0058             ; str1 in SI
0105+  0058             ; str2 in DI
0106+  0058             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0107+  0058             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  0058             strcmp:
0109+  0058 DB          	push al
0110+  0059 DA          	push d
0111+  005A E3          	push di
0112+  005B E2          	push si
0113+  005C             strcmp_loop:
0114+  005C F3          	cmpsb					; compare a byte of the strings
0115+  005D C7 69 00    	jne strcmp_ret
0116+  0060 FB FF FF    	lea d, [si +- 1]
0117+  0063 1E          	mov al, [d]
0118+  0064 B9 00       	cmp al, 0				; check if at end of string (null)
0119+  0066 C7 5C 00    	jne strcmp_loop				; equal chars but not at end
0120+  0069             strcmp_ret:
0121+  0069 EF          	pop si
0122+  006A F0          	pop di
0123+  006B E7          	pop d
0124+  006C E8          	pop al
0125+  006D 09          	ret
0126+  006E             
0127+  006E             
0128+  006E             ; STRCPY
0129+  006E             ; copy null terminated string from SI to DI
0130+  006E             ; source in SI
0131+  006E             ; destination in DI
0132+  006E             strcpy:
0133+  006E E2          	push si
0134+  006F E3          	push di
0135+  0070 DB          	push al
0136+  0071             strcpy_L1:
0137+  0071 F6          	lodsb
0138+  0072 F7          	stosb
0139+  0073 B9 00       	cmp al, 0
0140+  0075 C7 71 00    	jne strcpy_L1
0141+  0078             strcpy_end:
0142+  0078 E8          	pop al
0143+  0079 F0          	pop di
0144+  007A EF          	pop si
0145+  007B 09          	ret
0146+  007C             
0147+  007C             ; STRCAT
0148+  007C             ; concatenate a NULL terminated string into string at DI, from string at SI
0149+  007C             ; source in SI
0150+  007C             ; destination in DI
0151+  007C             strcat:
0152+  007C E2          	push si
0153+  007D E3          	push di
0154+  007E D7          	push a
0155+  007F DA          	push d
0156+  0080 50          	mov a, di
0157+  0081 3C          	mov d, a
0158+  0082             strcat_goto_end_L1:
0159+  0082 1E          	mov al, [d]
0160+  0083 B9 00       	cmp al, 0
0161+  0085 C6 8C 00    	je strcat_start
0162+  0088 79          	inc d
0163+  0089 0A 82 00    	jmp strcat_goto_end_L1
0164+  008C             strcat_start:
0165+  008C FD 50       	mov di, d
0166+  008E             strcat_L1:
0167+  008E F6          	lodsb
0168+  008F F7          	stosb
0169+  0090 B9 00       	cmp al, 0
0170+  0092 C7 8E 00    	jne strcat_L1
0171+  0095             strcat_end:
0172+  0095 E7          	pop d
0173+  0096 E4          	pop a
0174+  0097 F0          	pop di
0175+  0098 EF          	pop si
0176+  0099 09          	ret
0005   009A             
0006   009A 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006   009E 34 35 36 37 
0006   00A2 38 39 41 42 
0006   00A6 43 44 45 46 
0007   00AA             
0008   00AA 01 00       table_power:	.dw 1
0009   00AC 0A 00       		.dw 10
0010   00AE 64 00       		.dw 100
0011   00B0 E8 03       		.dw 1000
0012   00B2 10 27       		.dw 10000
0013   00B4 10 27       		.dw 10000
0014   00B6             
0015   00B6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016   00B6             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017   00B6             ; ASCII in BL
0018   00B6             ; result in AL
0019   00B6             ; ascii for F = 0100 0110
0020   00B6             ; ascii for 9 = 0011 1001
0021   00B6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022   00B6             hex_ascii_encode:
0023   00B6 1B          	mov al, bl
0024   00B7 93 40       	test al, 40h				; test if letter or number
0025   00B9 C7 BF 00    	jnz hex_letter
0026   00BC 87 0F       	and al, 0Fh				; get number
0027   00BE 09          	ret
0028   00BF             hex_letter:
0029   00BF 87 0F       	and al, 0Fh				; get letter
0030   00C1 6A 09       	add al, 9
0031   00C3 09          	ret
0032   00C4             
0033   00C4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034   00C4             ; ATOI
0035   00C4             ; 2 letter hex string in B
0036   00C4             ; 8bit integer returned in AL
0037   00C4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038   00C4             atoi:
0039   00C4 FD 79       	mov g, b
0040   00C6 07 B6 00    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041   00C9 30          	mov bl, bh
0042   00CA DB          	push al					; save a
0043   00CB 07 B6 00    	call hex_ascii_encode
0044   00CE EA          	pop bl	
0045   00CF FD 9E 04    	shl al, 4
0046   00D2 8C          	or al, bl
0047   00D3 FD 27       	mov b, g
0048   00D5 09          	ret	
0049   00D6             
0050   00D6             
0051   00D6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052   00D6             ; printf
0053   00D6             ; no need for explanations!
0054   00D6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055   00D6             printf:
0056   00D6             
0057   00D6             
0058   00D6 09          	ret
0059   00D7             
0060   00D7             
0061   00D7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062   00D7             ; scanf
0063   00D7             ; no need for explanations!
0064   00D7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0065   00D7             scanf:
0066   00D7             
0067   00D7             
0068   00D7 09          	ret
0069   00D8             
0070   00D8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071   00D8             ; ITOA
0072   00D8             ; 8bit value in BL
0073   00D8             ; 2 byte ASCII result in A
0074   00D8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075   00D8             itoa:
0076   00D8 DA          	push d
0077   00D9 FD 79       	mov g, b
0078   00DB A7 00       	mov bh, 0
0079   00DD FD A4 04    	shr bl, 4	
0080   00E0 74          	mov d, b
0081   00E1 1F 9A 00    	mov al, [d + s_hex_digits]
0082   00E4 23          	mov ah, al
0083   00E5             	
0084   00E5 FD 27       	mov b, g
0085   00E7 A7 00       	mov bh, 0
0086   00E9 FD 87 0F    	and bl, $0F
0087   00EC 74          	mov d, b
0088   00ED 1F 9A 00    	mov al, [d + s_hex_digits]
0089   00F0 FD 27       	mov b, g
0090   00F2 E7          	pop d
0091   00F3 09          	ret
0092   00F4             
0093   00F4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0094   00F4             ; HEX STRING TO BINARY
0095   00F4             ; di = destination address
0096   00F4             ; si = source
0097   00F4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098   00F4             hex_to_int:
0099   00F4             hex_to_int_L1:
0100   00F4 F6          	lodsb					; load from [SI] to AL
0101   00F5 B9 00       	cmp al, 0				; check if ASCII 0
0102   00F7 C6 04 01    	jz hex_to_int_ret
0103   00FA 36          	mov bh, al
0104   00FB F6          	lodsb
0105   00FC 2F          	mov bl, al
0106   00FD 07 C4 00    	call atoi				; convert ASCII byte in B to int (to AL)
0107   0100 F7          	stosb					; store AL to [DI]
0108   0101 0A F4 00    	jmp hex_to_int_L1
0109   0104             hex_to_int_ret:
0110   0104 09          	ret		
0111   0105             
0112   0105             
0113   0105             
0114   0105             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115   0105             ; GETCHAR
0116   0105             ; char in ah
0117   0105             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0118   0105             getchar:
0119   0105 DB          	push al
0120   0106 19 01       	mov al, 1
stdio.s line 0121: Label not found: (sys_io)
stdio.s line 0121: Unused data in MS byte of argument. (200)
0121   0108 05 00       	syscall sys_io			; receive in AH
0122   010A E8          	pop al
0123   010B 09          	ret
0124   010C             
0125   010C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0126   010C             ; PUTCHAR
0127   010C             ; char in ah
0128   010C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129   010C             putchar:
0130   010C D7          	push a
0131   010D 19 00       	mov al, 0
stdio.s line 0132: Label not found: (sys_io)
stdio.s line 0132: Unused data in MS byte of argument. (200)
0132   010F 05 00       	syscall sys_io			; char in AH
0133   0111 E4          	pop a
0134   0112 09          	ret
0135   0113             
0136   0113             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0137   0113             ;; INPUT A STRING
0138   0113             ;; terminates with null
0139   0113             ;; pointer in D
0140   0113             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141   0113             gets:
0142   0113 D7          	push a
0143   0114 DA          	push d
0144   0115             gets_loop:
0145   0115 19 01       	mov al, 1
stdio.s line 0146: Label not found: (sys_io)
stdio.s line 0146: Unused data in MS byte of argument. (200)
0146   0117 05 00       	syscall sys_io			; receive in AH
0147   0119             
0148   0119 76 0A       	cmp ah, 0Ah				; LF
0149   011B C6 54 01    	je gets_end
0150   011E 76 5C       	cmp ah, $5C				; '\\'
0151   0120 C6 32 01    	je gets_escape
0152   0123             	
0153   0123 76 08       	cmp ah, $08			; check for backspace
0154   0125 C6 2E 01    	je gets_backspace
0155   0128             
0156   0128 1A          	mov al, ah
0157   0129 3E          	mov [d], al
0158   012A 79          	inc d
0159   012B 0A 15 01    	jmp gets_loop
0160   012E             gets_backspace:
0161   012E 7F          	dec d
0162   012F 0A 15 01    	jmp gets_loop
0163   0132             gets_escape:
0164   0132 19 01       	mov al, 1
stdio.s line 0165: Label not found: (sys_io)
stdio.s line 0165: Unused data in MS byte of argument. (200)
0165   0134 05 00       	syscall sys_io			; receive in AH
0166   0136 76 6E       	cmp ah, 'n'
0167   0138 C6 46 01    	je gets_LF
0168   013B 76 72       	cmp ah, 'r'
0169   013D C6 4D 01    	je gets_CR
0170   0140 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0171   0141 3E          	mov [d], al
0172   0142 79          	inc d
0173   0143 0A 15 01    	jmp gets_loop
0174   0146             gets_LF:
0175   0146 19 0A       	mov al, $0A
0176   0148 3E          	mov [d], al
0177   0149 79          	inc d
0178   014A 0A 15 01    	jmp gets_loop
0179   014D             gets_CR:
0180   014D 19 0D       	mov al, $0D
0181   014F 3E          	mov [d], al
0182   0150 79          	inc d
0183   0151 0A 15 01    	jmp gets_loop
0184   0154             gets_end:
0185   0154 19 00       	mov al, 0
0186   0156 3E          	mov [d], al				; terminate string
0187   0157 E7          	pop d
0188   0158 E4          	pop a
0189   0159 09          	ret
0190   015A             
0191   015A             
0192   015A             
0193   015A             
0194   015A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0195   015A             ;; INPUT TEXT
0196   015A             ;; terminated with CTRL+D
0197   015A             ;; pointer in D
0198   015A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0199   015A             gettxt:
0200   015A D7          	push a
0201   015B DA          	push d
0202   015C             gettxt_loop:
0203   015C 19 01       	mov al, 1
stdio.s line 0204: Label not found: (sys_io)
stdio.s line 0204: Unused data in MS byte of argument. (200)
0204   015E 05 00       	syscall sys_io			; receive in AH
0205   0160 76 04       	cmp ah, 4			; EOT
0206   0162 C6 9B 01    	je gettxt_end
0207   0165 76 08       	cmp ah, $08			; check for backspace
0208   0167 C6 97 01    	je gettxt_backspace
0209   016A 76 5C       	cmp ah, $5C				; '\\'
0210   016C C6 75 01    	je gettxt_escape
0211   016F 1A          	mov al, ah
0212   0170 3E          	mov [d], al
0213   0171 79          	inc d
0214   0172 0A 5C 01    	jmp gettxt_loop
0215   0175             gettxt_escape:
0216   0175 19 01       	mov al, 1
stdio.s line 0217: Label not found: (sys_io)
stdio.s line 0217: Unused data in MS byte of argument. (200)
0217   0177 05 00       	syscall sys_io			; receive in AH
0218   0179 76 6E       	cmp ah, 'n'
0219   017B C6 89 01    	je gettxt_LF
0220   017E 76 72       	cmp ah, 'r'
0221   0180 C6 90 01    	je gettxt_CR
0222   0183 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0223   0184 3E          	mov [d], al
0224   0185 79          	inc d
0225   0186 0A 5C 01    	jmp gettxt_loop
0226   0189             gettxt_LF:
0227   0189 19 0A       	mov al, $0A
0228   018B 3E          	mov [d], al
0229   018C 79          	inc d
0230   018D 0A 5C 01    	jmp gettxt_loop
0231   0190             gettxt_CR:
0232   0190 19 0D       	mov al, $0D
0233   0192 3E          	mov [d], al
0234   0193 79          	inc d
0235   0194 0A 5C 01    	jmp gettxt_loop
0236   0197             gettxt_backspace:
0237   0197 7F          	dec d
0238   0198 0A 5C 01    	jmp gettxt_loop
0239   019B             gettxt_end:
0240   019B 19 00       	mov al, 0
0241   019D 3E          	mov [d], al				; terminate string
0242   019E E7          	pop d
0243   019F E4          	pop a
0244   01A0 09          	ret
0245   01A1             
0246   01A1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0247   01A1             ; PRINT NEW LINE
0248   01A1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0249   01A1             printnl:
0250   01A1 D7          	push a
0251   01A2 10 00 0A    	mov a, $0A00
stdio.s line 0252: Label not found: (sys_io)
stdio.s line 0252: Unused data in MS byte of argument. (200)
0252   01A5 05 00       	syscall sys_io
0253   01A7 10 00 0D    	mov a, $0D00
stdio.s line 0254: Label not found: (sys_io)
stdio.s line 0254: Unused data in MS byte of argument. (200)
0254   01AA 05 00       	syscall sys_io
0255   01AC E4          	pop a
0256   01AD 09          	ret
0257   01AE             
0258   01AE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0259   01AE             ; strtoint
0260   01AE             ; 4 digit string number in d
0261   01AE             ; integer returned in A
0262   01AE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0263   01AE             strtoint:
0264   01AE             ;	push b
0265   01AE 32          	mov bl, [d]
0266   01AF 37          	mov bh, bl
0267   01B0 33 01 00    	mov bl, [d + 1]
0268   01B3 07 C4 00    	call atoi				; convert to int in AL
0269   01B6 23          	mov ah, al				; move to AH
0270   01B7 33 02 00    	mov bl, [d + 2]
0271   01BA 37          	mov bh, bl
0272   01BB 33 03 00    	mov bl, [d + 3]
0273   01BE 07 C4 00    	call atoi				; convert to int in AL
0274   01C1             ;	pop b
0275   01C1 09          	ret
0276   01C2             
0277   01C2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0278   01C2             ; PRINT NULL TERMINATED STRING
0279   01C2             ; pointer in D
0280   01C2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0281   01C2             puts:
0282   01C2 D7          	push a
0283   01C3 DA          	push d
0284   01C4             puts_L1:
0285   01C4 1E          	mov al, [d]
0286   01C5 B9 00       	cmp al, 0
0287   01C7 C6 D3 01    	jz puts_END
0288   01CA 23          	mov ah, al
0289   01CB 19 00       	mov al, 0
stdio.s line 0290: Label not found: (sys_io)
stdio.s line 0290: Unused data in MS byte of argument. (200)
0290   01CD 05 00       	syscall sys_io
0291   01CF 79          	inc d
0292   01D0 0A C4 01    	jmp puts_L1
0293   01D3             puts_END:
0294   01D3 E7          	pop d
0295   01D4 E4          	pop a
0296   01D5 09          	ret
0297   01D6             
0298   01D6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299   01D6             ; PRINT N SIZE STRING
0300   01D6             ; pointer in D
0301   01D6             ; size in C
0302   01D6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303   01D6             putsn:
0304   01D6 DB          	push al
0305   01D7 DA          	push d
0306   01D8 D9          	push c
0307   01D9             putsn_L0:
0308   01D9 1E          	mov al, [d]
0309   01DA 23          	mov ah, al
0310   01DB 19 00       	mov al, 0
stdio.s line 0311: Label not found: (sys_io)
stdio.s line 0311: Unused data in MS byte of argument. (200)
0311   01DD 05 00       	syscall sys_io
0312   01DF 79          	inc d
0313   01E0 7E          	dec c	
0314   01E1 C2 00 00    	cmp c, 0
0315   01E4 C7 D9 01    	jne putsn_L0
0316   01E7             putsn_end:
0317   01E7 E6          	pop c
0318   01E8 E7          	pop d
0319   01E9 E8          	pop al
0320   01EA 09          	ret
0321   01EB             
0322   01EB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0323   01EB             ; print 16bit decimal number
0324   01EB             ; input number in A
0325   01EB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0326   01EB             print_u16d:
0327   01EB D7          	push a
0328   01EC D8          	push b
0329   01ED             
0330   01ED 26 10 27    	mov b, 10000
0331   01F0 AE          	div a, b			; get 10000 coeff.
0332   01F1 07 18 02    	call print_zero_or_space
0333   01F4 11          	mov a, b
0334   01F5             
0335   01F5 26 E8 03    	mov b, 1000
0336   01F8 AE          	div a, b			; get 10000 coeff.
0337   01F9 07 18 02    	call print_zero_or_space
0338   01FC 11          	mov a, b
0339   01FD             
0340   01FD 26 64 00    	mov b, 100
0341   0200 AE          	div a, b
0342   0201 07 18 02    	call print_zero_or_space
0343   0204 11          	mov a, b
0344   0205             
0345   0205 26 0A 00    	mov b, 10
0346   0208 AE          	div a, b
0347   0209 07 18 02    	call print_zero_or_space
0348   020C 11          	mov a, b
0349   020D             
0350   020D 1B          	mov al, bl
0351   020E 6A 30       	add al, $30
0352   0210 23          	mov ah, al
0353   0211 19 00       	mov al, 0
stdio.s line 0354: Label not found: (sys_io)
stdio.s line 0354: Unused data in MS byte of argument. (200)
0354   0213 05 00       	syscall sys_io	; print coeff
0355   0215 E5          	pop b
0356   0216 E4          	pop a
0357   0217 09          	ret
0358   0218             
0359   0218             
0360   0218             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0361   0218             ; if A == 0, print space
0362   0218             ; else print A
0363   0218             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0364   0218             print_zero_or_space:
0365   0218             	; cmp a, 0
0366   0218             	; jne print_number
0367   0218             	; mov ah, $20
0368   0218             	; call putchar
0369   0218             	; ret
0370   0218             print_number:
0371   0218 6A 30       	add al, $30
0372   021A 23          	mov ah, al
0373   021B 07 0C 01    	call putchar
0374   021E 09          	ret
0375   021F             
0376   021F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0377   021F             ; PRINT 16BIT HEX INTEGER
0378   021F             ; integer value in reg B
0379   021F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380   021F             print_u16x:
0381   021F D7          	push a
0382   0220 D8          	push b
0383   0221 DD          	push bl
0384   0222 30          	mov bl, bh
0385   0223 07 D8 00    	call itoa				; convert bh to char in A
0386   0226 2F          	mov bl, al				; save al
0387   0227 19 00       	mov al, 0
stdio.s line 0388: Label not found: (sys_io)
stdio.s line 0388: Unused data in MS byte of argument. (200)
0388   0229 05 00       	syscall sys_io				; display AH
0389   022B 24          	mov ah, bl				; retrieve al
0390   022C 19 00       	mov al, 0
stdio.s line 0391: Label not found: (sys_io)
stdio.s line 0391: Unused data in MS byte of argument. (200)
0391   022E 05 00       	syscall sys_io				; display AL
0392   0230             
0393   0230 EA          	pop bl
0394   0231 07 D8 00    	call itoa				; convert bh to char in A
0395   0234 2F          	mov bl, al				; save al
0396   0235 19 00       	mov al, 0
stdio.s line 0397: Label not found: (sys_io)
stdio.s line 0397: Unused data in MS byte of argument. (200)
0397   0237 05 00       	syscall sys_io				; display AH
0398   0239 24          	mov ah, bl				; retrieve al
0399   023A 19 00       	mov al, 0
stdio.s line 0400: Label not found: (sys_io)
stdio.s line 0400: Unused data in MS byte of argument. (200)
0400   023C 05 00       	syscall sys_io				; display AL
0401   023E             
0402   023E E5          	pop b
0403   023F E4          	pop a
0404   0240 09          	ret
0405   0241             
0406   0241             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407   0241             ; INPUT 16BIT HEX INTEGER
0408   0241             ; read 16bit integer into A
0409   0241             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0410   0241             scan_u16x:
0411   0241 F8 10 00    	enter 16
0412   0244 D8          	push b
0413   0245 DA          	push d
0414   0246             
0415   0246 FA F1 FF    	lea d, [bp + -15]
0416   0249 07 13 01    	call gets				; get number
0417   024C             
0418   024C 32          	mov bl, [d]
0419   024D 37          	mov bh, bl
0420   024E 33 01 00    	mov bl, [d + 1]
0421   0251 07 C4 00    	call atoi				; convert to int in AL
0422   0254 23          	mov ah, al				; move to AH
0423   0255             
0424   0255 33 02 00    	mov bl, [d + 2]
0425   0258 37          	mov bh, bl
0426   0259 33 03 00    	mov bl, [d + 3]
0427   025C 07 C4 00    	call atoi				; convert to int in AL
0428   025F             
0429   025F E7          	pop d
0430   0260 E5          	pop b
0431   0261 F9          	leave
0432   0262 09          	ret
0433   0263             
0434   0263             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0435   0263             ; PRINT 8bit HEX INTEGER
0436   0263             ; integer value in reg bl
0437   0263             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0438   0263             print_u8x:
0439   0263 D7          	push a
0440   0264 DD          	push bl
0441   0265             
0442   0265 07 D8 00    	call itoa				; convert bl to char in A
0443   0268 2F          	mov bl, al				; save al
0444   0269 19 00       	mov al, 0
stdio.s line 0445: Label not found: (sys_io)
stdio.s line 0445: Unused data in MS byte of argument. (200)
0445   026B 05 00       	syscall sys_io				; display AH
0446   026D 24          	mov ah, bl				; retrieve al
0447   026E 19 00       	mov al, 0
stdio.s line 0448: Label not found: (sys_io)
stdio.s line 0448: Unused data in MS byte of argument. (200)
0448   0270 05 00       	syscall sys_io				; display AL
0449   0272             
0450   0272 EA          	pop bl
0451   0273 E4          	pop a
0452   0274 09          	ret
0453   0275             
0454   0275             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0455   0275             ; print 8bit decimal unsigned number
0456   0275             ; input number in AL
0457   0275             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0458   0275             print_u8d:
0459   0275 D7          	push a
0460   0276 D8          	push b
0461   0277             
0462   0277 22 00       	mov ah, 0
0463   0279 26 64 00    	mov b, 100
0464   027C AE          	div a, b
0465   027D D8          	push b			; save remainder
0466   027E B9 00       	cmp al, 0
0467   0280 C6 8A 02    	je skip100
0468   0283 6A 30       	add al, $30
0469   0285 23          	mov ah, al
0470   0286 19 00       	mov al, 0
stdio.s line 0471: Label not found: (sys_io)
stdio.s line 0471: Unused data in MS byte of argument. (200)
0471   0288 05 00       	syscall sys_io	; print coeff
0472   028A             skip100:
0473   028A E4          	pop a
0474   028B 22 00       	mov ah, 0
0475   028D 26 0A 00    	mov b, 10
0476   0290 AE          	div a, b
0477   0291 D8          	push b			; save remainder
0478   0292 B9 00       	cmp al, 0
0479   0294 C6 9E 02    	je skip10
0480   0297 6A 30       	add al, $30
0481   0299 23          	mov ah, al
0482   029A 19 00       	mov al, 0
stdio.s line 0483: Label not found: (sys_io)
stdio.s line 0483: Unused data in MS byte of argument. (200)
0483   029C 05 00       	syscall sys_io	; print coeff
0484   029E             skip10:
0485   029E E4          	pop a
0486   029F 1B          	mov al, bl
0487   02A0 6A 30       	add al, $30
0488   02A2 23          	mov ah, al
0489   02A3 19 00       	mov al, 0
stdio.s line 0490: Label not found: (sys_io)
stdio.s line 0490: Unused data in MS byte of argument. (200)
0490   02A5 05 00       	syscall sys_io	; print coeff
0491   02A7 E5          	pop b
0492   02A8 E4          	pop a
0493   02A9 09          	ret
0494   02AA             
0495   02AA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496   02AA             ; INPUT 8BIT HEX INTEGER
0497   02AA             ; read 8bit integer into AL
0498   02AA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0499   02AA             scan_u8x:
0500   02AA F8 04 00    	enter 4
0501   02AD D8          	push b
0502   02AE DA          	push d
0503   02AF             
0504   02AF FA FD FF    	lea d, [bp + -3]
0505   02B2 07 13 01    	call gets				; get number
0506   02B5             
0507   02B5 32          	mov bl, [d]
0508   02B6 37          	mov bh, bl
0509   02B7 33 01 00    	mov bl, [d + 1]
0510   02BA 07 C4 00    	call atoi				; convert to int in AL
0511   02BD             
0512   02BD E7          	pop d
0513   02BE E5          	pop b
0514   02BF F9          	leave
0515   02C0 09          	ret
0516   02C1             
0517   02C1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0518   02C1             ; input decimal number
0519   02C1             ; result in A
0520   02C1             ; 655'\0'
0521   02C1             ; low--------high
0522   02C1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0523   02C1             scan_u16d:
0524   02C1 F8 08 00    	enter 8
0525   02C4 E2          	push si
0526   02C5 D8          	push b
0527   02C6 D9          	push c
0528   02C7 DA          	push d
0529   02C8 FA F9 FF    	lea d, [bp +- 7]
0530   02CB 07 13 01    	call gets
0531   02CE 07 48 00    	call strlen			; get string length in C
0532   02D1 7E          	dec c
0533   02D2 FD 4E       	mov si, d
0534   02D4 12          	mov a, c
0535   02D5 FD 99       	shl a
0536   02D7 3B AA 00    	mov d, table_power
0537   02DA 59          	add d, a
0538   02DB 38 00 00    	mov c, 0
0539   02DE             mul_loop:
0540   02DE F6          	lodsb			; load ASCII to al
0541   02DF B9 00       	cmp al, 0
0542   02E1 C6 F4 02    	je mul_exit
0543   02E4 6F 30       	sub al, $30		; make into integer
0544   02E6 22 00       	mov ah, 0
0545   02E8 2A          	mov b, [d]
0546   02E9 AC          	mul a, b			; result in B since it fits in 16bits
0547   02EA 11          	mov a, b
0548   02EB 28          	mov b, c
0549   02EC 54          	add a, b
0550   02ED 39          	mov c, a
0551   02EE 63 02 00    	sub d, 2
0552   02F1 0A DE 02    	jmp mul_loop
0553   02F4             mul_exit:
0554   02F4 12          	mov a, c
0555   02F5 E7          	pop d
0556   02F6 E6          	pop c
0557   02F7 E5          	pop b
0558   02F8 EF          	pop si
0559   02F9 F9          	leave
0560   02FA 09          	ret
 line 0560: No END directive before EOF.       
tasm: Number of errors = 41
