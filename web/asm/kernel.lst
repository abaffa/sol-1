0001   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002   0000             ; KERNEL
0003   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0005   0000             ; MEMORY MAP
0006   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007   0000             ; 0000		ROM BEGIN
0008   0000             ; ....
0009   0000             ; 7FFF		ROM END
0010   0000             ;
0011   0000             ; 8000		RAM begin
0012   0000             ; ....
0013   0000             ; F7FF		Stack root
0014   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0015   0000             ; I/O MAP
0016   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0017   0000             ; FF80		UART 0		(16550)
0018   0000             ; FF90		UART 1		(16550)
0019   0000             ; FFA0		RTC		(M48T02)
0020   0000             ; FFB0		PIO 0		(8255)
0021   0000             ; FFC0		PIO 1		(8255)
0022   0000             ; FFD0		IDE		(Compact Flash / PATA)
0023   0000             ; FFE0		Timer		(8253)
0024   0000             ; FFF0		BIOS CONFIGURATION NV-RAM STORE AREA
0025   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026   0000             ; SYSTEM CONSTANTS / EQUATIONS
0027   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028   0000             _UART0_DATA			.equ $FF80				; data
0029   0000             _UART0_DLAB_0		.equ $FF80				; divisor latch low byte
0030   0000             _UART0_DLAB_1		.equ $FF81				; divisor latch high byte
0031   0000             _UART0_IER			.equ $FF81				; Interrupt enable register
0032   0000             _UART0_FCR			.equ $FF82				; FIFO control register
0033   0000             _UART0_LCR			.equ $FF83				; line control register
0034   0000             _UART0_LSR			.equ $FF85				; line status register
0035   0000             
0036   0000             _IDE_BASE			.equ $FFD0				; IDE BASE
0037   0000             _IDE_R0				.equ _IDE_BASE + 0		; DATA PORT
0038   0000             _IDE_R1				.equ _IDE_BASE + 1		; READ: ERROR CODE, WRITE: FEATURE
0039   0000             _IDE_R2				.equ _IDE_BASE + 2		; NUMBER OF SECTORS TO TRANSFER
0040   0000             _IDE_R3				.equ _IDE_BASE + 3		; SECTOR ADDRESS LBA 0 [0:7]
0041   0000             _IDE_R4				.equ _IDE_BASE + 4		; SECTOR ADDRESS LBA 1 [8:15]
0042   0000             _IDE_R5				.equ _IDE_BASE + 5		; SECTOR ADDRESS LBA 2 [16:23]
0043   0000             _IDE_R6				.equ _IDE_BASE + 6		; SECTOR ADDRESS LBA 3 [24:27 (LSB)]
0044   0000             _IDE_R7				.equ _IDE_BASE + 7		; READ: STATUS, WRITE: COMMAND
0045   0000             
0046   0000             _7SEG_DISPLAY		.equ $FFB0				; BIOS POST CODE HEX DISPLAY (2 DIGITS)
0047   0000             _BIOS_POST_CTRL		.equ $FFB3				; BIOS POST DISPLAY CONTROL REGISTER, 80h = As Output
0048   0000             _PIO_A				.equ $FFB0		
0049   0000             _PIO_B				.equ $FFB1
0050   0000             _PIO_C				.equ $FFB2
0051   0000             _PIO_CONTROL		.equ $FFB3				; PIO CONTROL PORT
0052   0000             
0053   0000             _TIMER_C_0			.equ $FFE0				; TIMER COUNTER 0
0054   0000             _TIMER_C_1			.equ $FFE1				; TIMER COUNTER 1
0055   0000             _TIMER_C_2			.equ $FFE2				; TIMER COUNTER 2
0056   0000             _TIMER_CTRL			.equ $FFE3				; TIMER CONTROL REGISTER
0057   0000             
0058   0000             STACK_BEGIN			.equ $F7FF				; beginning of stack
0059   0000             FIFO_SIZE			.equ (1024*2)
0060   0000             
0061   0000             PROC_TEXT_ORG		.equ $400
0062   0000             NULL				.equ 0
0063   0000             
0064   0000             
0065   0000             ; for the next iteration:
0066   0000             ; boot-sector(1) | kernel-sectors(32) | inode-bitmap | rawdata-bitmap | inode-table | raw-disk-data
0067   0000             ;
0068   0000             ; inode-table format:
0069   0000             ;	file-type(f, d)
0070   0000             ;	permissons
0071   0000             ;	link-count
0072   0000             ;	filesize
0073   0000             ;	time-stamps
0074   0000             ;	15 data block pointers
0075   0000             ;	single-indirect pointer
0076   0000             ;
0077   0000             
0078   0000             ; for now:
0079   0000             ; boot-sector(1) | kernel-sectors(32) | rawdata-bitmap() | raw-disk-data
0080   0000             ;
0081   0000             ; filename (24)
0082   0000             ; attributes (1) 			:|0|0|file_type(3bits)|x|w|r|
0083   0000             ; LBA (2)					: location of raw data for file entry, or dirID for directory entry
0084   0000             ; size (2)					: filesize
0085   0000             ; day (1)					 
0086   0000             ; month (1)
0087   0000             ; year (1)
0088   0000             ; packet size = 32 bytes	: total packet size in bytes
0089   0000             ;
0090   0000             FST_ENTRY_SIZE			.equ 32
0091   0000             FST_FILES_PER_SECT		.equ (512 / FST_ENTRY_SIZE)
0092   0000             FST_FILES_PER_DIR		.equ 16
0093   0000             FST_NBR_DIRECTORIES		.equ 64
0094   0000             						; 1 sector for header, the rest is for the list of files/dirs
0095   0000             FST_SECTORS_PER_DIR		.equ (1 + (FST_ENTRY_SIZE * FST_FILES_PER_DIR / 512))		
0096   0000             FST_TOTAL_SECTORS		.equ (FST_SECTORS_PER_DIR * FST_NBR_DIRECTORIES)
0097   0000             FST_LBA_START			.equ 32
0098   0000             FST_LBA_END				.equ (FST_LBA_START + FST_TOTAL_SECTORS - 1)
0099   0000             
0100   0000             FS_NBR_FILES 			.equ (FST_NBR_DIRECTORIES * FST_FILES_PER_DIR)
0101   0000             FS_SECTORS_PER_FILE		.equ 32				; the first sector is always a header with a NULL parameter (first byte)
0102   0000             											; so that we know which blocks are free or taken
0103   0000             FS_FILE_SIZE			.equ (FS_SECTORS_PER_FILE * 512)									
0104   0000             FS_TOTAL_SECTORS		.equ (FS_NBR_FILES * FS_SECTORS_PER_FILE)
0105   0000             FS_LBA_START			.equ (FST_LBA_END + 1)
0106   0000             FS_LBA_END				.equ (FS_LBA_START + FS_NBR_FILES - 1)
0107   0000             
0108   0000             CF_CARD_LBA_SIZE		.equ $800			; temporary small size
0109   0000             
0110   0000             ROOT_dirID:				.equ FST_LBA_START
0111   0000             
0112   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113   0000             ; GLOBAL SYSTEM VARIABLES
0114   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115   0000             
0116   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0117   0000             ; EXTERNAL INTERRUPT TABLE
0118   0000             ; highest priority at lowest address
0119   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0120   0000 7E 07       .dw int_0
0121   0002 7F 07       .dw int_1
0122   0004 80 07       .dw int_2
0123   0006 81 07       .dw int_3
0124   0008 82 07       .dw int_4
0125   000A 83 07       .dw int_5
0126   000C 84 07       .dw int_6
0127   000E D0 07       .dw int_7
0128   0010             
0129   0010             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130   0010             ; RESET VECTOR DECLARATION
0131   0010             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0132   0010 88 14       .dw KERNEL_RESET_VECTOR
0133   0012             
0134   0012             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0135   0012             ;; EXCEPTION VECTOR TABLE
0136   0012             ;; total of 7 entries, starting at address $0012
0137   0012             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138   0012 9A 08       .dw trap_privilege
0139   0014 B7 09       .dw trap_div_zero
0140   0016 C4 09       .dw undefined_opcode
0141   0018 00 00       .dw NULL
0142   001A 00 00       .dw NULL
0143   001C 00 00       .dw NULL
0144   001E 00 00       .dw NULL
0145   0020             
0146   0020             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0147   0020             ;; SYSTEM CALL VECTOR TABLE
0148   0020             ;; starts at address $0020
0149   0020             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0150   0020 A6 08       .dw trap_breakpoint
0151   0022 C5 09       .dw rtc_services						
0152   0024 E8 0A       .dw IDE_services_kernel
0153   0026 A8 0B       .dw io_services
0154   0028 34 0C       .dw file_system
0155   002A 5B 15       .dw cmd_fork
0156   002C 5F 08       .dw list_procs
0157   002E F7 09       .dw datetime_services
0158   0030 1B 08       .dw syscall_reboot
0159   0032 25 15       .dw cmd_pause_proc
0160   0034 27 08       .dw resume_proc
0161   0036 E2 14       .dw cmd_terminate_proc
0162   0038 09 08       .dw cmd_system
0163   003A C1 0C       .dw cmd_boot_installer
0164   003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0165   003C             ;; FILE INCLUDES
0166   003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0167   003C             .include "bios.exp"	; to obtain the BIOS_RESET_VECTOR location (for reboots)
0001+  003C             BIOS_RESET_VECTOR .EQU  $01c0
0002+  003C             IDE_buffer       .EQU  $8204
0003+  003C             boot_origin      .EQU  $8004
0004+  003C             bios_uart        .EQU  $0002
0005+  003C             bios_ide         .EQU  $0003
0168   003C             .include "stdio.asm"
0001+  003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  003C             ; stdio.s
0003+  003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  003C             .include "string.asm"
0001++ 003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 003C             ; string.s
0003++ 003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 003C             
0005++ 003C             
0006++ 003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 003C             ; strrev
0008++ 003C             ; reverse a string
0009++ 003C             ; D = string address
0010++ 003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 003C             ; 01234
0012++ 003C             strrev:
0013++ 003C 4B          	pusha
0014++ 003D 07 83 00    	call strlen	; length in C
0015++ 0040 12          	mov a, c
0016++ 0041 AF 01 00    	cmp a, 1
0017++ 0044 D0 5E 00    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0047 7D          	dec a
0019++ 0048 FD 4E       	mov si, d	; beginning of string
0020++ 004A FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 004C 59          	add d, a	; end of string
0022++ 004D 12          	mov a, c
0023++ 004E FD 9B       	shr a		; divide by 2
0024++ 0050 39          	mov c, a	; C now counts the steps
0025++ 0051             strrev_L0:
0026++ 0051 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0052 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0053 3E          	mov [d], al	; store left char into right side
0029++ 0054 1B          	mov al, bl
0030++ 0055 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0056 7E          	dec c
0032++ 0057 7F          	dec d
0033++ 0058 C2 00 00    	cmp c, 0
0034++ 005B C7 51 00    	jne strrev_L0
0035++ 005E             strrev_end:
0036++ 005E 4C          	popa
0037++ 005F 09          	ret
0038++ 0060             	
0039++ 0060             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0060             ; strchr
0041++ 0060             ; search string in D for char in AL
0042++ 0060             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0060             strchr:
0044++ 0060             strchr_L0:
0045++ 0060 32          	mov bl, [d]
0046++ 0061 C1 00       	cmp bl, 0
0047++ 0063 C6 6E 00    	je strchr_end
0048++ 0066 BA          	cmp al, bl
0049++ 0067 C6 6E 00    	je strchr_end
0050++ 006A 79          	inc d
0051++ 006B 0A 60 00    	jmp strchr_L0
0052++ 006E             strchr_end:
0053++ 006E 1B          	mov al, bl
0054++ 006F 09          	ret
0055++ 0070             
0056++ 0070             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0070             ; strstr
0058++ 0070             ; find sub-string
0059++ 0070             ; str1 in SI
0060++ 0070             ; str2 in DI
0061++ 0070             ; SI points to end of source string
0062++ 0070             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0070             strstr:
0064++ 0070 DB          	push al
0065++ 0071 DA          	push d
0066++ 0072 E3          	push di
0067++ 0073             strstr_loop:
0068++ 0073 F3          	cmpsb					; compare a byte of the strings
0069++ 0074 C7 7F 00    	jne strstr_ret
0070++ 0077 FC 00 00    	lea d, [di + 0]
0071++ 007A BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 007C C7 73 00    	jne strstr_loop				; equal chars but not at end
0073++ 007F             strstr_ret:
0074++ 007F F0          	pop di
0075++ 0080 E7          	pop d
0076++ 0081 E8          	pop al
0077++ 0082 09          	ret
0078++ 0083             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0083             ; length of null terminated string
0080++ 0083             ; result in C
0081++ 0083             ; pointer in D
0082++ 0083             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0083             strlen:
0084++ 0083 DA          	push d
0085++ 0084 38 00 00    	mov c, 0
0086++ 0087             strlen_L1:
0087++ 0087 BD 00       	cmp byte [d], 0
0088++ 0089 C6 91 00    	je strlen_ret
0089++ 008C 79          	inc d
0090++ 008D 78          	inc c
0091++ 008E 0A 87 00    	jmp strlen_L1
0092++ 0091             strlen_ret:
0093++ 0091 E7          	pop d
0094++ 0092 09          	ret
0095++ 0093             
0096++ 0093             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0093             ; STRCMP
0098++ 0093             ; compare two strings
0099++ 0093             ; str1 in SI
0100++ 0093             ; str2 in DI
0101++ 0093             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0093             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0093             strcmp:
0104++ 0093 DB          	push al
0105++ 0094 DA          	push d
0106++ 0095 E3          	push di
0107++ 0096 E2          	push si
0108++ 0097             strcmp_loop:
0109++ 0097 F3          	cmpsb					; compare a byte of the strings
0110++ 0098 C7 A3 00    	jne strcmp_ret
0111++ 009B FB FF FF    	lea d, [si +- 1]
0112++ 009E BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 00A0 C7 97 00    	jne strcmp_loop				; equal chars but not at end
0114++ 00A3             strcmp_ret:
0115++ 00A3 EF          	pop si
0116++ 00A4 F0          	pop di
0117++ 00A5 E7          	pop d
0118++ 00A6 E8          	pop al
0119++ 00A7 09          	ret
0120++ 00A8             
0121++ 00A8             
0122++ 00A8             ; STRCPY
0123++ 00A8             ; copy null terminated string from SI to DI
0124++ 00A8             ; source in SI
0125++ 00A8             ; destination in DI
0126++ 00A8             strcpy:
0127++ 00A8 E2          	push si
0128++ 00A9 E3          	push di
0129++ 00AA DB          	push al
0130++ 00AB             strcpy_L1:
0131++ 00AB F6          	lodsb
0132++ 00AC F7          	stosb
0133++ 00AD B9 00       	cmp al, 0
0134++ 00AF C7 AB 00    	jne strcpy_L1
0135++ 00B2             strcpy_end:
0136++ 00B2 E8          	pop al
0137++ 00B3 F0          	pop di
0138++ 00B4 EF          	pop si
0139++ 00B5 09          	ret
0140++ 00B6             
0141++ 00B6             ; STRCAT
0142++ 00B6             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 00B6             ; source in SI
0144++ 00B6             ; destination in DI
0145++ 00B6             strcat:
0146++ 00B6 E2          	push si
0147++ 00B7 E3          	push di
0148++ 00B8 D7          	push a
0149++ 00B9 DA          	push d
0150++ 00BA 50          	mov a, di
0151++ 00BB 3C          	mov d, a
0152++ 00BC             strcat_goto_end_L1:
0153++ 00BC BD 00       	cmp byte[d], 0
0154++ 00BE C6 C5 00    	je strcat_start
0155++ 00C1 79          	inc d
0156++ 00C2 0A BC 00    	jmp strcat_goto_end_L1
0157++ 00C5             strcat_start:
0158++ 00C5 FD 50       	mov di, d
0159++ 00C7             strcat_L1:
0160++ 00C7 F6          	lodsb
0161++ 00C8 F7          	stosb
0162++ 00C9 B9 00       	cmp al, 0
0163++ 00CB C7 C7 00    	jne strcat_L1
0164++ 00CE             strcat_end:
0165++ 00CE E7          	pop d
0166++ 00CF E4          	pop a
0167++ 00D0 F0          	pop di
0168++ 00D1 EF          	pop si
0169++ 00D2 09          	ret
0005+  00D3             
0006+  00D3 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  00D7 34 35 36 37 
0006+  00DB 38 39 41 42 
0006+  00DF 43 44 45 46 
0007+  00E3             
0008+  00E3 01 00       table_power:.dw 1
0009+  00E5 0A 00       			.dw 10
0010+  00E7 64 00       			.dw 100
0011+  00E9 E8 03       			.dw 1000
0012+  00EB 10 27       			.dw 10000
0013+  00ED             
0014+  00ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0015+  00ED             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0016+  00ED             ; ASCII in BL
0017+  00ED             ; result in AL
0018+  00ED             ; ascii for F = 0100 0110
0019+  00ED             ; ascii for 9 = 0011 1001
0020+  00ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0021+  00ED             hex_ascii_encode:
0022+  00ED 1B          	mov al, bl
0023+  00EE 93 40       	test al, $40				; test if letter or number
0024+  00F0 C7 F6 00    	jnz hex_letter
0025+  00F3 87 0F       	and al, $0F				; get number
0026+  00F5 09          	ret
0027+  00F6             hex_letter:
0028+  00F6 87 0F       	and al, $0F				; get letter
0029+  00F8 6A 09       	add al, 9
0030+  00FA 09          	ret
0031+  00FB             
0032+  00FB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0033+  00FB             ; ATOI
0034+  00FB             ; 2 letter hex string in B
0035+  00FB             ; 8bit integer returned in AL
0036+  00FB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0037+  00FB             atoi:
0038+  00FB D8          	push b
0039+  00FC 07 ED 00    	call hex_ascii_encode			; convert BL to 4bit code in AL
0040+  00FF 30          	mov bl, bh
0041+  0100 DB          	push al					; save a
0042+  0101 07 ED 00    	call hex_ascii_encode
0043+  0104 EA          	pop bl	
0044+  0105 FD 9E 04    	shl al, 4
0045+  0108 8C          	or al, bl
0046+  0109 E5          	pop b
0047+  010A 09          	ret	
0048+  010B             
0049+  010B             
0050+  010B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  010B             ; printf
0052+  010B             ; no need for explanations!
0053+  010B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0054+  010B             printf:
0055+  010B 09          	ret
0056+  010C             
0057+  010C             
0058+  010C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  010C             ; scanf
0060+  010C             ; no need for explanations!
0061+  010C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  010C             scanf:
0063+  010C 09          	ret
0064+  010D             
0065+  010D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  010D             ; ITOA
0067+  010D             ; 8bit value in BL
0068+  010D             ; 2 byte ASCII result in A
0069+  010D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0070+  010D             itoa:
0071+  010D DA          	push d
0072+  010E D8          	push b
0073+  010F A7 00       	mov bh, 0
0074+  0111 FD A4 04    	shr bl, 4	
0075+  0114 74          	mov d, b
0076+  0115 1F D3 00    	mov al, [d + s_hex_digits]
0077+  0118 23          	mov ah, al
0078+  0119             	
0079+  0119 E5          	pop b
0080+  011A D8          	push b
0081+  011B A7 00       	mov bh, 0
0082+  011D FD 87 0F    	and bl, $0F
0083+  0120 74          	mov d, b
0084+  0121 1F D3 00    	mov al, [d + s_hex_digits]
0085+  0124 E5          	pop b
0086+  0125 E7          	pop d
0087+  0126 09          	ret
0088+  0127             
0089+  0127             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0090+  0127             ; HEX STRING TO BINARY
0091+  0127             ; di = destination address
0092+  0127             ; si = source
0093+  0127             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0094+  0127             hex_to_int:
0095+  0127             hex_to_int_L1:
0096+  0127 F6          	lodsb					; load from [SI] to AL
0097+  0128 B9 00       	cmp al, 0				; check if ASCII 0
0098+  012A C6 37 01    	jz hex_to_int_ret
0099+  012D 36          	mov bh, al
0100+  012E F6          	lodsb
0101+  012F 2F          	mov bl, al
0102+  0130 07 FB 00    	call atoi				; convert ASCII byte in B to int (to AL)
0103+  0133 F7          	stosb					; store AL to [DI]
0104+  0134 0A 27 01    	jmp hex_to_int_L1
0105+  0137             hex_to_int_ret:
0106+  0137 09          	ret		
0107+  0138             
0108+  0138             
0109+  0138             
0110+  0138             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  0138             ; GETCHAR
0112+  0138             ; char in ah
0113+  0138             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0114+  0138             getchar:
0115+  0138 DB          	push al
0116+  0139             getchar_retry:
0117+  0139 FD 0C       	sti
0118+  013B 19 01       	mov al, 1
0119+  013D 05 03       	syscall sys_io			; receive in AH
0120+  013F B9 00       	cmp al, 0			; check if any char was receive
0121+  0141 C6 39 01    	je getchar_retry
0122+  0144 E8          	pop al
0123+  0145 09          	ret
0124+  0146             
0125+  0146             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0126+  0146             ; PUTCHAR
0127+  0146             ; char in ah
0128+  0146             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  0146             putchar:
0130+  0146 D7          	push a
0131+  0147 19 00       	mov al, 0
0132+  0149 05 03       	syscall sys_io			; char in AH
0133+  014B E4          	pop a
0134+  014C 09          	ret
0135+  014D             
0136+  014D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0137+  014D             ;; INPUT A STRING
0138+  014D             ;; terminates with null
0139+  014D             ;; pointer in D
0140+  014D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  014D             gets:
0142+  014D D7          	push a
0143+  014E DA          	push d
0144+  014F             gets_loop:
0145+  014F FD 0C       	sti
0146+  0151 19 01       	mov al, 1
0147+  0153 05 03       	syscall sys_io			; receive in AH
0148+  0155 B9 00       	cmp al, 0				; check error code (AL)
0149+  0157 C6 4F 01    	je gets_loop			; if no char received, retry
0150+  015A             
0151+  015A 76 1B       	cmp ah, 27
0152+  015C C6 78 01    	je gets_telnet_escape
0153+  015F 76 0A       	cmp ah, $0A				; LF
0154+  0161 C6 D1 01    	je gets_end
0155+  0164 76 5C       	cmp ah, $5C				; '\\'
0156+  0166 C6 A8 01    	je gets_escape
0157+  0169             	
0158+  0169 76 08       	cmp ah, $08			; check for backspace
0159+  016B C6 74 01    	je gets_backspace
0160+  016E             
0161+  016E 1A          	mov al, ah
0162+  016F 3E          	mov [d], al
0163+  0170 79          	inc d
0164+  0171 0A 4F 01    	jmp gets_loop
0165+  0174             gets_backspace:
0166+  0174 7F          	dec d
0167+  0175 0A 4F 01    	jmp gets_loop
0168+  0178             gets_telnet_escape:
0169+  0178 FD 0C       	sti
0170+  017A 19 01       	mov al, 1
0171+  017C 05 03       	syscall sys_io				; receive in AH without echo
0172+  017E B9 00       	cmp al, 0					; check error code (AL)
0173+  0180 C6 78 01    	je gets_telnet_escape		; if no char received, retry
0174+  0183 76 5B       	cmp ah, '['
0175+  0185 C7 4F 01    	jne gets_loop
0176+  0188             gets_telnet_escape_phase2:
0177+  0188 FD 0C       	sti
0178+  018A 19 01       	mov al, 1
0179+  018C 05 03       	syscall sys_io					; receive in AH without echo
0180+  018E B9 00       	cmp al, 0						; check error code (AL)
0181+  0190 C6 88 01    	je gets_telnet_escape_phase2	; if no char received, retry
0182+  0193 76 44       	cmp ah, 'D'
0183+  0195 C6 A0 01    	je gets_left_arrow
0184+  0198 76 43       	cmp ah, 'C'
0185+  019A C6 A4 01    	je gets_right_arrow
0186+  019D 0A 4F 01    	jmp gets_loop
0187+  01A0             gets_left_arrow:
0188+  01A0 7F          	dec d
0189+  01A1 0A 4F 01    	jmp gets_loop
0190+  01A4             gets_right_arrow:
0191+  01A4 79          	inc d
0192+  01A5 0A 4F 01    	jmp gets_loop
0193+  01A8             gets_escape:
0194+  01A8 FD 0C       	sti
0195+  01AA 19 01       	mov al, 1
0196+  01AC 05 03       	syscall sys_io			; receive in AH
0197+  01AE B9 00       	cmp al, 0				; check error code (AL)
0198+  01B0 C6 A8 01    	je gets_escape			; if no char received, retry
0199+  01B3 76 6E       	cmp ah, 'n'
0200+  01B5 C6 C3 01    	je gets_LF
0201+  01B8 76 72       	cmp ah, 'r'
0202+  01BA C6 CA 01    	je gets_CR
0203+  01BD 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0204+  01BE 3E          	mov [d], al
0205+  01BF 79          	inc d
0206+  01C0 0A 4F 01    	jmp gets_loop
0207+  01C3             gets_LF:
0208+  01C3 19 0A       	mov al, $0A
0209+  01C5 3E          	mov [d], al
0210+  01C6 79          	inc d
0211+  01C7 0A 4F 01    	jmp gets_loop
0212+  01CA             gets_CR:
0213+  01CA 19 0D       	mov al, $0D
0214+  01CC 3E          	mov [d], al
0215+  01CD 79          	inc d
0216+  01CE 0A 4F 01    	jmp gets_loop
0217+  01D1             gets_end:
0218+  01D1 19 00       	mov al, 0
0219+  01D3 3E          	mov [d], al				; terminate string
0220+  01D4 E7          	pop d
0221+  01D5 E4          	pop a
0222+  01D6 09          	ret
0223+  01D7             
0224+  01D7             
0225+  01D7             
0226+  01D7             
0227+  01D7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0228+  01D7             ;; INPUT TEXT
0229+  01D7             ;; terminated with CTRL+D
0230+  01D7             ;; pointer in D
0231+  01D7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0232+  01D7             gettxt:
0233+  01D7 D7          	push a
0234+  01D8 DA          	push d
0235+  01D9             gettxt_loop:
0236+  01D9 19 01       	mov al, 1
0237+  01DB 05 03       	syscall sys_io			; receive in AH
0238+  01DD B9 00       	cmp al, 0				; check error code (AL)
0239+  01DF C6 D9 01    	je gettxt_loop		; if no char received, retry
0240+  01E2 76 04       	cmp ah, 4			; EOT
0241+  01E4 C6 22 02    	je gettxt_end
0242+  01E7 76 08       	cmp ah, $08			; check for backspace
0243+  01E9 C6 1E 02    	je gettxt_backspace
0244+  01EC 76 5C       	cmp ah, $5C				; '\\'
0245+  01EE C6 F7 01    	je gettxt_escape
0246+  01F1 1A          	mov al, ah
0247+  01F2 3E          	mov [d], al
0248+  01F3 79          	inc d
0249+  01F4 0A D9 01    	jmp gettxt_loop
0250+  01F7             gettxt_escape:
0251+  01F7 19 01       	mov al, 1
0252+  01F9 05 03       	syscall sys_io			; receive in AH
0253+  01FB B9 00       	cmp al, 0				; check error code (AL)
0254+  01FD C6 F7 01    	je gettxt_escape		; if no char received, retry
0255+  0200 76 6E       	cmp ah, 'n'
0256+  0202 C6 10 02    	je gettxt_LF
0257+  0205 76 72       	cmp ah, 'r'
0258+  0207 C6 17 02    	je gettxt_CR
0259+  020A 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0260+  020B 3E          	mov [d], al
0261+  020C 79          	inc d
0262+  020D 0A D9 01    	jmp gettxt_loop
0263+  0210             gettxt_LF:
0264+  0210 19 0A       	mov al, $0A
0265+  0212 3E          	mov [d], al
0266+  0213 79          	inc d
0267+  0214 0A D9 01    	jmp gettxt_loop
0268+  0217             gettxt_CR:
0269+  0217 19 0D       	mov al, $0D
0270+  0219 3E          	mov [d], al
0271+  021A 79          	inc d
0272+  021B 0A D9 01    	jmp gettxt_loop
0273+  021E             gettxt_backspace:
0274+  021E 7F          	dec d
0275+  021F 0A D9 01    	jmp gettxt_loop
0276+  0222             gettxt_end:
0277+  0222 19 00       	mov al, 0
0278+  0224 3E          	mov [d], al				; terminate string
0279+  0225 E7          	pop d
0280+  0226 E4          	pop a
0281+  0227 09          	ret
0282+  0228             
0283+  0228             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0284+  0228             ; PRINT NEW LINE
0285+  0228             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0286+  0228             printnl:
0287+  0228 D7          	push a
0288+  0229 10 00 0A    	mov a, $0A00
0289+  022C 05 03       	syscall sys_io
0290+  022E 10 00 0D    	mov a, $0D00
0291+  0231 05 03       	syscall sys_io
0292+  0233 E4          	pop a
0293+  0234 09          	ret
0294+  0235             
0295+  0235             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0296+  0235             ; strtoint
0297+  0235             ; 4 digit hex string number in d
0298+  0235             ; integer returned in A
0299+  0235             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0300+  0235             strtointx:
0301+  0235 D8          	push b
0302+  0236 32          	mov bl, [d]
0303+  0237 37          	mov bh, bl
0304+  0238 33 01 00    	mov bl, [d + 1]
0305+  023B 07 FB 00    	call atoi				; convert to int in AL
0306+  023E 23          	mov ah, al				; move to AH
0307+  023F 33 02 00    	mov bl, [d + 2]
0308+  0242 37          	mov bh, bl
0309+  0243 33 03 00    	mov bl, [d + 3]
0310+  0246 07 FB 00    	call atoi				; convert to int in AL
0311+  0249 E5          	pop b
0312+  024A 09          	ret
0313+  024B             
0314+  024B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0315+  024B             ; strtoint
0316+  024B             ; 5 digit base10 string number in d
0317+  024B             ; integer returned in A
0318+  024B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0319+  024B             strtoint:
0320+  024B E2          	push si
0321+  024C D8          	push b
0322+  024D D9          	push c
0323+  024E DA          	push d
0324+  024F 07 83 00    	call strlen			; get string length in C
0325+  0252 7E          	dec c
0326+  0253 FD 4E       	mov si, d
0327+  0255 12          	mov a, c
0328+  0256 FD 99       	shl a
0329+  0258 3B E3 00    	mov d, table_power
0330+  025B 59          	add d, a
0331+  025C 38 00 00    	mov c, 0
0332+  025F             strtoint_L0:
0333+  025F F6          	lodsb			; load ASCII to al
0334+  0260 B9 00       	cmp al, 0
0335+  0262 C6 75 02    	je strtoint_end
0336+  0265 6F 30       	sub al, $30		; make into integer
0337+  0267 22 00       	mov ah, 0
0338+  0269 2A          	mov b, [d]
0339+  026A AC          	mul a, b			; result in B since it fits in 16bits
0340+  026B 11          	mov a, b
0341+  026C 28          	mov b, c
0342+  026D 54          	add a, b
0343+  026E 39          	mov c, a
0344+  026F 63 02 00    	sub d, 2
0345+  0272 0A 5F 02    	jmp strtoint_L0
0346+  0275             strtoint_end:
0347+  0275 12          	mov a, c
0348+  0276 E7          	pop d
0349+  0277 E6          	pop c
0350+  0278 E5          	pop b
0351+  0279 EF          	pop si
0352+  027A 09          	ret
0353+  027B             
0354+  027B             
0355+  027B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  027B             ; PRINT NULL TERMINATED STRING
0357+  027B             ; pointer in D
0358+  027B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  027B             puts:
0360+  027B D7          	push a
0361+  027C DA          	push d
0362+  027D             puts_L1:
0363+  027D 1E          	mov al, [d]
0364+  027E B9 00       	cmp al, 0
0365+  0280 C6 8C 02    	jz puts_END
0366+  0283 23          	mov ah, al
0367+  0284 19 00       	mov al, 0
0368+  0286 05 03       	syscall sys_io
0369+  0288 79          	inc d
0370+  0289 0A 7D 02    	jmp puts_L1
0371+  028C             puts_END:
0372+  028C E7          	pop d
0373+  028D E4          	pop a
0374+  028E 09          	ret
0375+  028F             
0376+  028F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0377+  028F             ; PRINT N SIZE STRING
0378+  028F             ; pointer in D
0379+  028F             ; size in C
0380+  028F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0381+  028F             putsn:
0382+  028F DB          	push al
0383+  0290 DA          	push d
0384+  0291 D9          	push c
0385+  0292             putsn_L0:
0386+  0292 1E          	mov al, [d]
0387+  0293 23          	mov ah, al
0388+  0294 19 00       	mov al, 0
0389+  0296 05 03       	syscall sys_io
0390+  0298 79          	inc d
0391+  0299 7E          	dec c	
0392+  029A C2 00 00    	cmp c, 0
0393+  029D C7 92 02    	jne putsn_L0
0394+  02A0             putsn_end:
0395+  02A0 E6          	pop c
0396+  02A1 E7          	pop d
0397+  02A2 E8          	pop al
0398+  02A3 09          	ret
0399+  02A4             
0400+  02A4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0401+  02A4             ; print 16bit decimal number
0402+  02A4             ; input number in A
0403+  02A4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  02A4             print_u16d:
0405+  02A4 D7          	push a
0406+  02A5 D8          	push b
0407+  02A6 26 10 27    	mov b, 10000
0408+  02A9 AE          	div a, b			; get 10000 coeff.
0409+  02AA 07 D0 02    	call print_zero_or_space
0410+  02AD 11          	mov a, b
0411+  02AE 26 E8 03    	mov b, 1000
0412+  02B1 AE          	div a, b			; get 10000 coeff.
0413+  02B2 07 D0 02    	call print_zero_or_space
0414+  02B5 11          	mov a, b
0415+  02B6 26 64 00    	mov b, 100
0416+  02B9 AE          	div a, b
0417+  02BA 07 D0 02    	call print_zero_or_space
0418+  02BD 11          	mov a, b
0419+  02BE 26 0A 00    	mov b, 10
0420+  02C1 AE          	div a, b
0421+  02C2 07 D0 02    	call print_zero_or_space
0422+  02C5 11          	mov a, b
0423+  02C6 6A 30       	add al, $30
0424+  02C8 23          	mov ah, al
0425+  02C9 19 00       	mov al, 0
0426+  02CB 05 03       	syscall sys_io	; print coeff
0427+  02CD E5          	pop b
0428+  02CE E4          	pop a
0429+  02CF 09          	ret
0430+  02D0             
0431+  02D0             
0432+  02D0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0433+  02D0             ; if A == 0, print space
0434+  02D0             ; else print A
0435+  02D0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  02D0             print_zero_or_space:
0437+  02D0             	; cmp a, 0
0438+  02D0             	; jne print_number
0439+  02D0             	; mov ah, $20
0440+  02D0             	; call putchar
0441+  02D0             	; ret
0442+  02D0             print_number:
0443+  02D0 6A 30       	add al, $30
0444+  02D2 23          	mov ah, al
0445+  02D3 07 46 01    	call putchar
0446+  02D6 09          	ret
0447+  02D7             
0448+  02D7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  02D7             ; PRINT 16BIT HEX INTEGER
0450+  02D7             ; integer value in reg B
0451+  02D7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0452+  02D7             print_u16x:
0453+  02D7 D7          	push a
0454+  02D8 D8          	push b
0455+  02D9 DD          	push bl
0456+  02DA 30          	mov bl, bh
0457+  02DB 07 0D 01    	call itoa				; convert bh to char in A
0458+  02DE 2F          	mov bl, al				; save al
0459+  02DF 19 00       	mov al, 0
0460+  02E1 05 03       	syscall sys_io				; display AH
0461+  02E3 24          	mov ah, bl				; retrieve al
0462+  02E4 19 00       	mov al, 0
0463+  02E6 05 03       	syscall sys_io				; display AL
0464+  02E8             
0465+  02E8 EA          	pop bl
0466+  02E9 07 0D 01    	call itoa				; convert bh to char in A
0467+  02EC 2F          	mov bl, al				; save al
0468+  02ED 19 00       	mov al, 0
0469+  02EF 05 03       	syscall sys_io				; display AH
0470+  02F1 24          	mov ah, bl				; retrieve al
0471+  02F2 19 00       	mov al, 0
0472+  02F4 05 03       	syscall sys_io				; display AL
0473+  02F6             
0474+  02F6 E5          	pop b
0475+  02F7 E4          	pop a
0476+  02F8 09          	ret
0477+  02F9             
0478+  02F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  02F9             ; INPUT 16BIT HEX INTEGER
0480+  02F9             ; read 16bit integer into A
0481+  02F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0482+  02F9             scan_u16x:
0483+  02F9 F8 10 00    	enter 16
0484+  02FC D8          	push b
0485+  02FD DA          	push d
0486+  02FE             
0487+  02FE FA F1 FF    	lea d, [bp + -15]
0488+  0301 07 4D 01    	call gets				; get number
0489+  0304             
0490+  0304 32          	mov bl, [d]
0491+  0305 37          	mov bh, bl
0492+  0306 33 01 00    	mov bl, [d + 1]
0493+  0309 07 FB 00    	call atoi				; convert to int in AL
0494+  030C 23          	mov ah, al				; move to AH
0495+  030D             
0496+  030D 33 02 00    	mov bl, [d + 2]
0497+  0310 37          	mov bh, bl
0498+  0311 33 03 00    	mov bl, [d + 3]
0499+  0314 07 FB 00    	call atoi				; convert to int in AL
0500+  0317             
0501+  0317 E7          	pop d
0502+  0318 E5          	pop b
0503+  0319 F9          	leave
0504+  031A 09          	ret
0505+  031B             
0506+  031B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  031B             ; PRINT 8bit HEX INTEGER
0508+  031B             ; integer value in reg bl
0509+  031B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0510+  031B             print_u8x:
0511+  031B D7          	push a
0512+  031C DD          	push bl
0513+  031D             
0514+  031D 07 0D 01    	call itoa				; convert bl to char in A
0515+  0320 2F          	mov bl, al				; save al
0516+  0321 19 00       	mov al, 0
0517+  0323 05 03       	syscall sys_io				; display AH
0518+  0325 24          	mov ah, bl				; retrieve al
0519+  0326 19 00       	mov al, 0
0520+  0328 05 03       	syscall sys_io				; display AL
0521+  032A             
0522+  032A EA          	pop bl
0523+  032B E4          	pop a
0524+  032C 09          	ret
0525+  032D             
0526+  032D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  032D             ; print 8bit decimal unsigned number
0528+  032D             ; input number in AL
0529+  032D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0530+  032D             print_u8d:
0531+  032D D7          	push a
0532+  032E D8          	push b
0533+  032F             
0534+  032F 22 00       	mov ah, 0
0535+  0331 26 64 00    	mov b, 100
0536+  0334 AE          	div a, b
0537+  0335 D8          	push b			; save remainder
0538+  0336 B9 00       	cmp al, 0
0539+  0338 C6 42 03    	je skip100
0540+  033B 6A 30       	add al, $30
0541+  033D 23          	mov ah, al
0542+  033E 19 00       	mov al, 0
0543+  0340 05 03       	syscall sys_io	; print coeff
0544+  0342             skip100:
0545+  0342 E4          	pop a
0546+  0343 22 00       	mov ah, 0
0547+  0345 26 0A 00    	mov b, 10
0548+  0348 AE          	div a, b
0549+  0349 D8          	push b			; save remainder
0550+  034A B9 00       	cmp al, 0
0551+  034C C6 56 03    	je skip10
0552+  034F 6A 30       	add al, $30
0553+  0351 23          	mov ah, al
0554+  0352 19 00       	mov al, 0
0555+  0354 05 03       	syscall sys_io	; print coeff
0556+  0356             skip10:
0557+  0356 E4          	pop a
0558+  0357 1B          	mov al, bl
0559+  0358 6A 30       	add al, $30
0560+  035A 23          	mov ah, al
0561+  035B 19 00       	mov al, 0
0562+  035D 05 03       	syscall sys_io	; print coeff
0563+  035F E5          	pop b
0564+  0360 E4          	pop a
0565+  0361 09          	ret
0566+  0362             
0567+  0362             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  0362             ; INPUT 8BIT HEX INTEGER
0569+  0362             ; read 8bit integer into AL
0570+  0362             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0571+  0362             scan_u8x:
0572+  0362 F8 04 00    	enter 4
0573+  0365 D8          	push b
0574+  0366 DA          	push d
0575+  0367             
0576+  0367 FA FD FF    	lea d, [bp + -3]
0577+  036A 07 4D 01    	call gets				; get number
0578+  036D             
0579+  036D 32          	mov bl, [d]
0580+  036E 37          	mov bh, bl
0581+  036F 33 01 00    	mov bl, [d + 1]
0582+  0372 07 FB 00    	call atoi				; convert to int in AL
0583+  0375             
0584+  0375 E7          	pop d
0585+  0376 E5          	pop b
0586+  0377 F9          	leave
0587+  0378 09          	ret
0588+  0379             
0589+  0379             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0590+  0379             ; input decimal number
0591+  0379             ; result in A
0592+  0379             ; 655'\0'
0593+  0379             ; low--------high
0594+  0379             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0595+  0379             scan_u16d:
0596+  0379 F8 08 00    	enter 8
0597+  037C E2          	push si
0598+  037D D8          	push b
0599+  037E D9          	push c
0600+  037F DA          	push d
0601+  0380 FA F9 FF    	lea d, [bp +- 7]
0602+  0383 07 4D 01    	call gets
0603+  0386 07 83 00    	call strlen			; get string length in C
0604+  0389 7E          	dec c
0605+  038A FD 4E       	mov si, d
0606+  038C 12          	mov a, c
0607+  038D FD 99       	shl a
0608+  038F 3B E3 00    	mov d, table_power
0609+  0392 59          	add d, a
0610+  0393 38 00 00    	mov c, 0
0611+  0396             mul_loop:
0612+  0396 F6          	lodsb			; load ASCII to al
0613+  0397 B9 00       	cmp al, 0
0614+  0399 C6 AC 03    	je mul_exit
0615+  039C 6F 30       	sub al, $30		; make into integer
0616+  039E 22 00       	mov ah, 0
0617+  03A0 2A          	mov b, [d]
0618+  03A1 AC          	mul a, b			; result in B since it fits in 16bits
0619+  03A2 11          	mov a, b
0620+  03A3 28          	mov b, c
0621+  03A4 54          	add a, b
0622+  03A5 39          	mov c, a
0623+  03A6 63 02 00    	sub d, 2
0624+  03A9 0A 96 03    	jmp mul_loop
0625+  03AC             mul_exit:
0626+  03AC 12          	mov a, c
0627+  03AD E7          	pop d
0628+  03AE E6          	pop c
0629+  03AF E5          	pop b
0630+  03B0 EF          	pop si
0631+  03B1 F9          	leave
0632+  03B2 09          	ret
0169   03B3             .include "ctype.asm"
0001+  03B3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  03B3             ; ctype.s
0003+  03B3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  03B3             
0005+  03B3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  03B3             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  03B3             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  03B3             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  03B3             ;; characters are supported.
0010+  03B3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  03B3             ;; isalnum 
0012+  03B3             ;; isalpha 
0013+  03B3             ;; islower 
0014+  03B3             ;; isupper 
0015+  03B3             ;; isdigit 
0016+  03B3             ;; isxdigit
0017+  03B3             ;; iscntrl 
0018+  03B3             ;; isgraph 
0019+  03B3             ;; isspace 
0020+  03B3             ;; isblank 
0021+  03B3             ;; isprint 
0022+  03B3             ;; ispunct 
0023+  03B3             ;; tolower 
0024+  03B3             ;; toupper
0025+  03B3             
0026+  03B3             
0027+  03B3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  03B3             ;; IS ALPHANUMERIC
0029+  03B3             ;; sets ZF according with result
0030+  03B3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  03B3             isalnum:
0032+  03B3 07 D0 03    	call isalpha
0033+  03B6 C6 BC 03    	je isalnum_exit
0034+  03B9 07 BD 03    	call isdigit
0035+  03BC             isalnum_exit:
0036+  03BC 09          	ret	
0037+  03BD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  03BD             ;; IS DIGIT
0039+  03BD             ;; sets ZF according with result
0040+  03BD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  03BD             isdigit:
0042+  03BD DB          	push al
0043+  03BE B9 30       	cmp al, '0'
0044+  03C0 C8 CC 03    	jlu isdigit_false
0045+  03C3 B9 39       	cmp al, '9'
0046+  03C5 D1 CC 03    	jgu isdigit_false
0047+  03C8 87 00       	and al, 0	; set ZF
0048+  03CA E8          	pop al
0049+  03CB 09          	ret
0050+  03CC             isdigit_false:
0051+  03CC 8B 01       	or al, 1	; clear ZF
0052+  03CE E8          	pop al
0053+  03CF 09          	ret	
0054+  03D0             	
0055+  03D0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  03D0             ;; IS ALPHA
0057+  03D0             ;; sets ZF according with result
0058+  03D0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  03D0             isalpha:
0060+  03D0 DB          	push al
0061+  03D1 B9 5F       	cmp al, '_'
0062+  03D3 C6 F3 03    	je isalpha_true
0063+  03D6 B9 2E       	cmp al, '.'
0064+  03D8 C6 F3 03    	je isalpha_true
0065+  03DB B9 41       	cmp al, 'A'
0066+  03DD C8 EF 03    	jlu isalpha_false
0067+  03E0 B9 7A       	cmp al, 'z'
0068+  03E2 D1 EF 03    	jgu isalpha_false
0069+  03E5 B9 5A       	cmp al, 'Z'
0070+  03E7 D0 F3 03    	jleu isalpha_true
0071+  03EA B9 61       	cmp al, 'a'
0072+  03EC C9 F3 03    	jgeu isalpha_true
0073+  03EF             isalpha_false:
0074+  03EF 8B 01       	or al, 1	; clear ZF
0075+  03F1 E8          	pop al
0076+  03F2 09          	ret
0077+  03F3             isalpha_true:
0078+  03F3 87 00       	and al, 0	; set ZF
0079+  03F5 E8          	pop al
0080+  03F6 09          	ret
0081+  03F7             
0082+  03F7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  03F7             ;; IS PATH-ALPHA
0084+  03F7             ;; sets ZF according with result
0085+  03F7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  03F7             ispath:
0087+  03F7 DB          	push al
0088+  03F8 07 BD 03    	call isdigit
0089+  03FB C6 25 04    	je ispath_true
0090+  03FE B9 5F       	cmp al, '_'
0091+  0400 C6 25 04    	je ispath_true
0092+  0403 B9 2F       	cmp al, '/'
0093+  0405 C6 25 04    	je ispath_true
0094+  0408 B9 2E       	cmp al, '.'
0095+  040A C6 25 04    	je ispath_true
0096+  040D B9 41       	cmp al, 'A'
0097+  040F C8 21 04    	jlu ispath_false
0098+  0412 B9 7A       	cmp al, 'z'
0099+  0414 D1 21 04    	jgu ispath_false
0100+  0417 B9 5A       	cmp al, 'Z'
0101+  0419 D0 25 04    	jleu ispath_true
0102+  041C B9 61       	cmp al, 'a'
0103+  041E C9 25 04    	jgeu ispath_true
0104+  0421             ispath_false:
0105+  0421 8B 01       	or al, 1	; clear ZF
0106+  0423 E8          	pop al
0107+  0424 09          	ret
0108+  0425             ispath_true:
0109+  0425 87 00       	and al, 0	; set ZF
0110+  0427 E8          	pop al
0111+  0428 09          	ret
0112+  0429             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  0429             ;; IS SPACE
0114+  0429             ;; sets ZF according with result
0115+  0429             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  0429             isspace:
0117+  0429 B9 20       	cmp al, $20		; ' '
0118+  042B C6 3F 04    	je isspace_exit
0119+  042E B9 09       	cmp al, $09		; '\t'
0120+  0430 C6 3F 04    	je isspace_exit
0121+  0433 B9 0A       	cmp al, $0A		; '\n'
0122+  0435 C6 3F 04    	je isspace_exit
0123+  0438 B9 0D       	cmp al, $0D		; '\r'
0124+  043A C6 3F 04    	je isspace_exit
0125+  043D B9 0B       	cmp al, $0B		; '\v'
0126+  043F             isspace_exit:
0127+  043F 09          	ret	
0128+  0440             
0129+  0440             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0440             ; TO LOWER
0131+  0440             ; input in AL
0132+  0440             ; output in AL
0133+  0440             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  0440             to_lower:
0135+  0440 B9 5A       	cmp al, 'Z'
0136+  0442 D1 47 04    	jgu to_lower_ret
0137+  0445 6A 20       	add al, $20				; convert to lower case
0138+  0447             to_lower_ret:
0139+  0447 09          	ret
0140+  0448             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  0448             ; TO UPPER
0142+  0448             ; input in AL
0143+  0448             ; output in AL
0144+  0448             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  0448             to_upper:
0146+  0448 B9 61       	cmp al, 'a'
0147+  044A C8 4F 04    	jlu to_upper_ret
0148+  044D 6F 20       	sub al, $20			; convert to upper case
0149+  044F             to_upper_ret:
0150+  044F 09          	ret
0151+  0450             
0170   0450             .include "token.asm"
0001+  0450             TOKTYP_IDENTIFIER	.equ 0
0002+  0450             TOKTYP_KEYWORD		.equ 1
0003+  0450             TOKTYP_DELIMITER	.equ 2
0004+  0450             TOKTYP_STRING		.equ 3
0005+  0450             TOKTYP_CHAR			.equ 4
0006+  0450             TOKTYP_NUMERIC		.equ 5
0007+  0450             TOKTYP_END			.equ 6
0008+  0450             
0009+  0450             TOK_NULL			.equ 0
0010+  0450             TOK_FSLASH			.equ 1
0011+  0450             TOK_TIMES 			.equ 2
0012+  0450             TOK_PLUS 			.equ 3
0013+  0450             TOK_MINUS 			.equ 4
0014+  0450             TOK_DOT				.equ 5
0015+  0450             TOK_SEMI			.equ 6
0016+  0450             TOK_ANGLE			.equ 7
0017+  0450             TOK_TILDE			.equ 8
0018+  0450             TOK_EQUAL			.equ 9
0019+  0450             TOK_COLON			.equ 10
0020+  0450             TOK_COMMA			.equ 11
0021+  0450             
0022+  0450             TOK_END				.equ 20
0023+  0450             
0024+  0450             
0025+  0450             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  0450             ;; read a full command argment from shell input buffer
0027+  0450             ;; argument is written into tokstr
0028+  0450             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  0450             get_arg:
0030+  0450 D7          	push a
0031+  0451 E2          	push si
0032+  0452 E3          	push di
0033+  0453 19 00       	mov al, 0
0034+  0455 3D 7E 06    	mov [tokstr], al			; nullify tokstr string
0035+  0458 14 7A 06    	mov a, [prog]
0036+  045B 4D          	mov si, a
0037+  045C FD 4F 7E 06 	mov di, tokstr
0038+  0460             get_arg_skip_spaces:
0039+  0460 F6          	lodsb
0040+  0461 07 29 04    	call isspace
0041+  0464 C6 60 04    	je get_arg_skip_spaces
0042+  0467             get_arg_L0:
0043+  0467 B9 3B       	cmp al, $3B				; check if is ';'
0044+  0469 C6 76 04    	je get_arg_end
0045+  046C B9 00       	cmp al, 0
0046+  046E C6 76 04    	je get_arg_end			; check if end of input
0047+  0471 F7          	stosb
0048+  0472 F6          	lodsb
0049+  0473 0A 67 04    	jmp get_arg_L0
0050+  0476             get_arg_end:
0051+  0476 19 00       	mov al, 0
0052+  0478 F7          	stosb
0053+  0479 D5 01 00    	sub si, 1
0054+  047C 4E          	mov a, si
0055+  047D 42 7A 06    	mov [prog], a		; update pointer
0056+  0480 F0          	pop di
0057+  0481 EF          	pop si
0058+  0482 E4          	pop a
0059+  0483 09          	ret
0060+  0484             
0061+  0484             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  0484             ;; read a path formation from shell input buffer
0063+  0484             ;; path is written into tokstr
0064+  0484             ;; /usr/bin
0065+  0484             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  0484             get_path:
0067+  0484 D7          	push a
0068+  0485 E2          	push si
0069+  0486 E3          	push di
0070+  0487 19 00       	mov al, 0
0071+  0489 3D 7E 06    	mov [tokstr], al			; nullify tokstr string
0072+  048C 14 7A 06    	mov a, [prog]
0073+  048F 4D          	mov si, a
0074+  0490 FD 4F 7E 06 	mov di, tokstr
0075+  0494             get_path_skip_spaces:
0076+  0494 F6          	lodsb
0077+  0495 07 29 04    	call isspace
0078+  0498 C6 94 04    	je get_path_skip_spaces
0079+  049B             get_path_is_pathchar:
0080+  049B F7          	stosb
0081+  049C F6          	lodsb
0082+  049D 07 B3 03    	call isalnum			;check if is alphanumeric
0083+  04A0 C6 9B 04    	je get_path_is_pathchar
0084+  04A3 B9 2F       	cmp al, '/'				; check if is '/'
0085+  04A5 C6 9B 04    	je get_path_is_pathchar
0086+  04A8 19 00       	mov al, 0
0087+  04AA F7          	stosb
0088+  04AB D5 01 00    	sub si, 1
0089+  04AE 4E          	mov a, si
0090+  04AF 42 7A 06    	mov [prog], a		; update pointer
0091+  04B2             get_path_end:
0092+  04B2 F0          	pop di
0093+  04B3 EF          	pop si
0094+  04B4 E4          	pop a
0095+  04B5 09          	ret
0096+  04B6             
0097+  04B6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  04B6             ;; read a line
0099+  04B6             ;; line is written into tokstr
0100+  04B6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  04B6             get_line:
0102+  04B6 D7          	push a
0103+  04B7 E2          	push si
0104+  04B8 E3          	push di
0105+  04B9 19 00       	mov al, 0
0106+  04BB 3D 7E 06    	mov [tokstr], al			; nullify tokstr string
0107+  04BE 14 7A 06    	mov a, [prog]
0108+  04C1 4D          	mov si, a
0109+  04C2 FD 4F 7E 06 	mov di, tokstr
0110+  04C6             get_line_L0:
0111+  04C6 F6          	lodsb
0112+  04C7 B9 0A       	cmp al, $0A		; check for new line
0113+  04C9 C6 D0 04    	je get_line_exit
0114+  04CC F7          	stosb
0115+  04CD 0A C6 04    	jmp get_line_L0
0116+  04D0             get_line_exit:
0117+  04D0 19 00       	mov al, 0
0118+  04D2 F7          	stosb
0119+  04D3 4E          	mov a, si
0120+  04D4 42 7A 06    	mov [prog], a		; update pointer
0121+  04D7 F0          	pop di
0122+  04D8 EF          	pop si
0123+  04D9 E4          	pop a
0124+  04DA 09          	ret
0125+  04DB             
0126+  04DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  04DB             ;; token parser
0128+  04DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  04DB             get_token:
0130+  04DB D7          	push a
0131+  04DC DA          	push d
0132+  04DD E2          	push si
0133+  04DE E3          	push di
0134+  04DF 19 00       	mov al, 0
0135+  04E1 3D 7E 06    	mov [tokstr], al			; nullify tokstr string
0136+  04E4 19 00       	mov al, TOK_NULL
0137+  04E6 3D 7D 06    	mov [tok], al				; nullify token
0138+  04E9 14 7A 06    	mov a, [prog]
0139+  04EC 4D          	mov si, a
0140+  04ED FD 4F 7E 06 	mov di, tokstr
0141+  04F1             get_tok_skip_spaces:
0142+  04F1 F6          	lodsb
0143+  04F2 07 29 04    	call isspace
0144+  04F5 C6 F1 04    	je get_tok_skip_spaces
0145+  04F8 B9 00       	cmp al, 0			; check for end of input (NULL)
0146+  04FA C6 DF 05    	je get_token_end
0147+  04FD B9 23       	cmp al, '#'			; comments!
0148+  04FF C6 0D 06    	je get_tok_comment
0149+  0502 07 B3 03    	call isalnum
0150+  0505 C6 EC 05    	jz is_alphanumeric
0151+  0508             ; other token types
0152+  0508             get_token_slash:
0153+  0508 B9 2F       	cmp al, '/'				; check if '/'
0154+  050A C7 22 05    	jne get_token_minus
0155+  050D F7          	stosb					; store '/' into token string
0156+  050E 19 00       	mov al, 0
0157+  0510 F7          	stosb					; terminate token string
0158+  0511 19 01       	mov al, TOK_FSLASH
0159+  0513 3D 7D 06    	mov [tok], al			
0160+  0516 19 02       	mov al, TOKTYP_DELIMITER
0161+  0518 3D 7C 06    	mov [toktyp], al
0162+  051B 4E          	mov a, si
0163+  051C 42 7A 06    	mov [prog], a		; update pointer
0164+  051F 0A 08 06    	jmp get_token_return
0165+  0522             get_token_minus:
0166+  0522 B9 2D       	cmp al, '-'				; check if '-'
0167+  0524 C7 3C 05    	jne get_token_comma
0168+  0527 F7          	stosb					; store '-' into token string
0169+  0528 19 00       	mov al, 0
0170+  052A F7          	stosb					; terminate token string
0171+  052B 19 04       	mov al, TOK_MINUS
0172+  052D 3D 7D 06    	mov [tok], al			
0173+  0530 19 02       	mov al, TOKTYP_DELIMITER
0174+  0532 3D 7C 06    	mov [toktyp], al
0175+  0535 4E          	mov a, si
0176+  0536 42 7A 06    	mov [prog], a		; update pointer
0177+  0539 0A 08 06    	jmp get_token_return
0178+  053C             get_token_comma:
0179+  053C B9 2C       	cmp al, ','				; check if ','
0180+  053E C7 56 05    	jne get_token_semi
0181+  0541 F7          	stosb					; store ',' into token string
0182+  0542 19 00       	mov al, 0
0183+  0544 F7          	stosb					; terminate token string
0184+  0545 19 0B       	mov al, TOK_COMMA
0185+  0547 3D 7D 06    	mov [tok], al			
0186+  054A 19 02       	mov al, TOKTYP_DELIMITER
0187+  054C 3D 7C 06    	mov [toktyp], al
0188+  054F 4E          	mov a, si
0189+  0550 42 7A 06    	mov [prog], a		; update pointer
0190+  0553 0A 08 06    	jmp get_token_return
0191+  0556             get_token_semi:
0192+  0556 B9 3B       	cmp al, $3B				; check if ';'
0193+  0558 C7 70 05    	jne get_token_colon
0194+  055B F7          	stosb					; store ';' into token string
0195+  055C 19 00       	mov al, 0
0196+  055E F7          	stosb					; terminate token string
0197+  055F 19 06       	mov al, TOK_SEMI
0198+  0561 3D 7D 06    	mov [tok], al			
0199+  0564 19 02       	mov al, TOKTYP_DELIMITER
0200+  0566 3D 7C 06    	mov [toktyp], al
0201+  0569 4E          	mov a, si
0202+  056A 42 7A 06    	mov [prog], a		; update pointer
0203+  056D 0A 08 06    	jmp get_token_return
0204+  0570             get_token_colon:
0205+  0570 B9 3A       	cmp al, $3A				; check if ':'
0206+  0572 C7 8A 05    	jne get_token_angle
0207+  0575 F7          	stosb					; store ':' into token string
0208+  0576 19 00       	mov al, 0
0209+  0578 F7          	stosb					; terminate token string
0210+  0579 19 0A       	mov al, TOK_COLON
0211+  057B 3D 7D 06    	mov [tok], al			
0212+  057E 19 02       	mov al, TOKTYP_DELIMITER
0213+  0580 3D 7C 06    	mov [toktyp], al
0214+  0583 4E          	mov a, si
0215+  0584 42 7A 06    	mov [prog], a		; update pointer
0216+  0587 0A 08 06    	jmp get_token_return
0217+  058A             get_token_angle:
0218+  058A B9 3E       	cmp al, $3E				; check if '>'
0219+  058C C7 A4 05    	jne get_token_tilde
0220+  058F F7          	stosb					; store '>' into token string
0221+  0590 19 00       	mov al, 0
0222+  0592 F7          	stosb					; terminate token string
0223+  0593 19 07       	mov al, TOK_ANGLE
0224+  0595 3D 7D 06    	mov [tok], al			
0225+  0598 19 02       	mov al, TOKTYP_DELIMITER
0226+  059A 3D 7C 06    	mov [toktyp], al
0227+  059D 4E          	mov a, si
0228+  059E 42 7A 06    	mov [prog], a		; update pointer
0229+  05A1 0A 08 06    	jmp get_token_return
0230+  05A4             get_token_tilde:
0231+  05A4 B9 7E       	cmp al, '~'				; check if '~'
0232+  05A6 C7 BE 05    	jne get_token_equal
0233+  05A9 F7          	stosb					; store '~' into token string
0234+  05AA 19 00       	mov al, 0
0235+  05AC F7          	stosb					; terminate token string
0236+  05AD 19 08       	mov al, TOK_TILDE
0237+  05AF 3D 7D 06    	mov [tok], al			
0238+  05B2 19 02       	mov al, TOKTYP_DELIMITER
0239+  05B4 3D 7C 06    	mov [toktyp], al
0240+  05B7 4E          	mov a, si
0241+  05B8 42 7A 06    	mov [prog], a		; update pointer
0242+  05BB 0A 08 06    	jmp get_token_return
0243+  05BE             get_token_equal:
0244+  05BE B9 3D       	cmp al, '='				; check if '='
0245+  05C0 C7 D8 05    	jne get_token_skip
0246+  05C3 F7          	stosb					; store '=' into token string
0247+  05C4 19 00       	mov al, 0
0248+  05C6 F7          	stosb					; terminate token string
0249+  05C7 19 09       	mov al, TOK_EQUAL
0250+  05C9 3D 7D 06    	mov [tok], al			
0251+  05CC 19 02       	mov al, TOKTYP_DELIMITER
0252+  05CE 3D 7C 06    	mov [toktyp], al
0253+  05D1 4E          	mov a, si
0254+  05D2 42 7A 06    	mov [prog], a		; update pointer
0255+  05D5 0A 08 06    	jmp get_token_return
0256+  05D8             get_token_skip:
0257+  05D8 4E          	mov a, si
0258+  05D9 42 7A 06    	mov [prog], a		; update pointer
0259+  05DC 0A 08 06    	jmp get_token_return
0260+  05DF             get_token_end:				; end of file token
0261+  05DF 19 14       	mov al, TOK_END
0262+  05E1 3D 7D 06    	mov [tok], al
0263+  05E4 19 06       	mov al, TOKTYP_END
0264+  05E6 3D 7C 06    	mov [toktyp], al
0265+  05E9 0A 08 06    	jmp get_token_return
0266+  05EC             is_alphanumeric:
0267+  05EC F7          	stosb
0268+  05ED F6          	lodsb
0269+  05EE 07 B3 03    	call isalnum			;check if is alphanumeric
0270+  05F1 C6 EC 05    	jz is_alphanumeric
0271+  05F4 B9 2E       	cmp al, $2E				; check if is '.'
0272+  05F6 C6 EC 05    	je is_alphanumeric
0273+  05F9 19 00       	mov al, 0
0274+  05FB F7          	stosb
0275+  05FC 19 00       	mov al, TOKTYP_IDENTIFIER
0276+  05FE 3D 7C 06    	mov [toktyp], al
0277+  0601 D5 01 00    	sub si, 1
0278+  0604 4E          	mov a, si
0279+  0605 42 7A 06    	mov [prog], a		; update pointer
0280+  0608             get_token_return:
0281+  0608 F0          	pop di
0282+  0609 EF          	pop si
0283+  060A E7          	pop d
0284+  060B E4          	pop a
0285+  060C 09          	ret
0286+  060D             get_tok_comment:
0287+  060D F6          	lodsb
0288+  060E B9 0A       	cmp al, $0A			; new line
0289+  0610 C7 0D 06    	jne get_tok_comment
0290+  0613 0A F1 04    	jmp get_tok_skip_spaces
0291+  0616             
0292+  0616             
0293+  0616             get_number:
0294+  0616 D7          	push a
0295+  0617 DA          	push d
0296+  0618 E2          	push si
0297+  0619 E3          	push di
0298+  061A 19 00       	mov al, 0
0299+  061C 3D 7E 06    	mov [tokstr], al			; nullify tokstr string
0300+  061F 19 00       	mov al, TOK_NULL
0301+  0621 3D 7D 06    	mov [tok], al				; nullify token
0302+  0624 14 7A 06    	mov a, [prog]
0303+  0627 4D          	mov si, a
0304+  0628 FD 4F 7E 06 	mov di, tokstr
0305+  062C             get_number_skip_spaces:
0306+  062C F6          	lodsb
0307+  062D 07 29 04    	call isspace
0308+  0630 C6 2C 06    	je get_number_skip_spaces
0309+  0633 B9 00       	cmp al, 0			; check for end of input (NULL)
0310+  0635 C7 45 06    	jne get_number_L0
0311+  0638 19 14       	mov al, TOK_END
0312+  063A 3D 7D 06    	mov [tok], al
0313+  063D 19 06       	mov al, TOKTYP_END
0314+  063F 3D 7C 06    	mov [toktyp], al
0315+  0642 0A 5C 06    	jmp get_number_return
0316+  0645             get_number_L0:
0317+  0645 F7          	stosb
0318+  0646 F6          	lodsb
0319+  0647 07 BD 03    	call isdigit			;check if is numeric
0320+  064A C6 45 06    	jz get_number_L0
0321+  064D 19 00       	mov al, 0
0322+  064F F7          	stosb
0323+  0650 19 05       	mov al, TOKTYP_NUMERIC
0324+  0652 3D 7C 06    	mov [toktyp], al
0325+  0655 D5 01 00    	sub si, 1
0326+  0658 4E          	mov a, si
0327+  0659 42 7A 06    	mov [prog], a		; update pointer
0328+  065C             get_number_return:
0329+  065C F0          	pop di
0330+  065D EF          	pop si
0331+  065E E7          	pop d
0332+  065F E4          	pop a
0333+  0660 09          	ret
0334+  0661             
0335+  0661             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  0661             ;; PUT BACK TOKEN
0337+  0661             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
0338+  0661             putback:
0339+  0661 D7          	push a
0340+  0662 E2          	push si
0341+  0663 FD 4D 7E 06 	mov si, tokstr	
0342+  0667             putback_loop:
0343+  0667 F6          	lodsb
0344+  0668 B9 00       	cmp al, 0
0345+  066A C6 77 06    	je putback_end
0346+  066D 14 7A 06    	mov a, [prog]
0347+  0670 7D          	dec a
0348+  0671 42 7A 06    	mov [prog], a			; update pointer
0349+  0674 0A 67 06    	jmp putback_loop
0350+  0677             putback_end:
0351+  0677 EF          	pop si
0352+  0678 E4          	pop a
0353+  0679 09          	ret
0354+  067A             
0355+  067A             
0356+  067A             
0357+  067A             
0358+  067A 00 00       prog:		.dw 0			; pointer to current position in buffer
0359+  067C             
0360+  067C 00          toktyp: 	.db 0			; token type symbol
0361+  067D 00          tok:		.db 0			; current token symbol
0362+  067E 00 00 00 00 tokstr:		.fill 256, 0	; token as a string
0362+  0682 00 00 00 00 
0362+  0686 00 00 00 00 
0362+  068A 00 00 00 00 
0362+  068E 00 00 00 00 
0362+  0692 00 00 00 00 
0362+  0696 00 00 00 00 
0362+  069A 00 00 00 00 
0362+  069E 00 00 00 00 
0362+  06A2 00 00 00 00 
0362+  06A6 00 00 00 00 
0362+  06AA 00 00 00 00 
0362+  06AE 00 00 00 00 
0362+  06B2 00 00 00 00 
0362+  06B6 00 00 00 00 
0362+  06BA 00 00 00 00 
0362+  06BE 00 00 00 00 
0362+  06C2 00 00 00 00 
0362+  06C6 00 00 00 00 
0362+  06CA 00 00 00 00 
0362+  06CE 00 00 00 00 
0362+  06D2 00 00 00 00 
0362+  06D6 00 00 00 00 
0362+  06DA 00 00 00 00 
0362+  06DE 00 00 00 00 
0362+  06E2 00 00 00 00 
0362+  06E6 00 00 00 00 
0362+  06EA 00 00 00 00 
0362+  06EE 00 00 00 00 
0362+  06F2 00 00 00 00 
0362+  06F6 00 00 00 00 
0362+  06FA 00 00 00 00 
0362+  06FE 00 00 00 00 
0362+  0702 00 00 00 00 
0362+  0706 00 00 00 00 
0362+  070A 00 00 00 00 
0362+  070E 00 00 00 00 
0362+  0712 00 00 00 00 
0362+  0716 00 00 00 00 
0362+  071A 00 00 00 00 
0362+  071E 00 00 00 00 
0362+  0722 00 00 00 00 
0362+  0726 00 00 00 00 
0362+  072A 00 00 00 00 
0362+  072E 00 00 00 00 
0362+  0732 00 00 00 00 
0362+  0736 00 00 00 00 
0362+  073A 00 00 00 00 
0362+  073E 00 00 00 00 
0362+  0742 00 00 00 00 
0362+  0746 00 00 00 00 
0362+  074A 00 00 00 00 
0362+  074E 00 00 00 00 
0362+  0752 00 00 00 00 
0362+  0756 00 00 00 00 
0362+  075A 00 00 00 00 
0362+  075E 00 00 00 00 
0362+  0762 00 00 00 00 
0362+  0766 00 00 00 00 
0362+  076A 00 00 00 00 
0362+  076E 00 00 00 00 
0362+  0772 00 00 00 00 
0362+  0776 00 00 00 00 
0362+  077A 00 00 00 00 
0171   077E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0172   077E             
0173   077E             sys_bkpt			.equ 0
0174   077E             sys_rtc				.equ 1
0175   077E             sys_IDE				.equ 2
0176   077E             sys_io				.equ 3
0177   077E             sys_fileio			.equ 4
0178   077E             sys_fork			.equ 5
0179   077E             sys_list			.equ 6
0180   077E             sys_datetime		.equ 7
0181   077E             sys_reboot			.equ 8
0182   077E             sys_pauseproc		.equ 9
0183   077E             sys_resumeproc		.equ 10
0184   077E             sys_terminate_proc	.equ 11
0185   077E             sys_system			.equ 12
0186   077E             sys_boot_install	.equ 13
0187   077E             
0188   077E             .export PROC_TEXT_ORG
0189   077E             .export sys_bkpt
0190   077E             .export sys_IDE
0191   077E             .export sys_io
0192   077E             .export sys_fileio
0193   077E             .export sys_fork
0194   077E             .export sys_list
0195   077E             .export sys_rtc
0196   077E             .export sys_datetime
0197   077E             .export sys_reboot
0198   077E             .export sys_pauseproc
0199   077E             .export sys_resumeproc
0200   077E             .export sys_terminate_proc
0201   077E             .export sys_system
0202   077E             .export sys_boot_install
0203   077E             
0204   077E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0205   077E             ; EXTERNAL INTERRUPTS' CODE BLOCK
0206   077E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0207   077E             ; uart
0208   077E             int_0:
0209   077E 06          	sysret
0210   077F             int_1:
0211   077F 06          	sysret
0212   0780             int_2:
0213   0780 06          	sysret
0214   0781             int_3:
0215   0781 06          	sysret
0216   0782             int_4:
0217   0782 06          	sysret
0218   0783             int_5:
0219   0783 06          	sysret
0220   0784             int_6:	
0221   0784             ; save all registers into kernel stack
0222   0784 4B          	pusha
0223   0785 22 00       	mov ah, 0
0224   0787 1D 1A 16    	mov al, [active_proc_index]
0225   078A FD 99       	shl a							; x2
0226   078C B7 D8 15    	mov a, [proc_table_convert + a]	; get process state start index
0227   078F             		
0228   078F 4F          	mov di, a
0229   0790 48          	mov a, sp
0230   0791 77          	inc a
0231   0792 4D          	mov si, a
0232   0793 38 14 00    	mov c, 20
0233   0796 FD F5       	rep movsb					; save process state!
0234   0798             ; restore kernel stack position to point before interrupt arrived
0235   0798 51 14 00    	add sp, 20
0236   079B             ; now load next process in queue
0237   079B 1D 1A 16    	mov al, [active_proc_index]
0238   079E 31 19 16    	mov bl, [nbr_active_procs]
0239   07A1 BA          	cmp al, bl
0240   07A2 C6 A9 07    	je int6_cycle_back
0241   07A5 7A          	inc al						; next process is next in the series
0242   07A6 0A AB 07    	jmp int6_continue
0243   07A9             int6_cycle_back:
0244   07A9 19 01       	mov al, 1				; next process = process 1
0245   07AB             int6_continue:
0246   07AB 3D 1A 16    	mov [active_proc_index], al		; set next active proc
0247   07AE             
0248   07AE             ; calculate LUT entry for next process
0249   07AE 22 00       	mov ah, 0
0250   07B0 FD 99       	shl a							; x2
0251   07B2 B7 D8 15    	mov a, [proc_table_convert + a]		; get process state start index	
0252   07B5             	
0253   07B5 4D          	mov si, a						; source is proc state block
0254   07B6 48          	mov a, sp
0255   07B7 5F 13 00    	sub a, 19
0256   07BA 4F          	mov di, a						; destination is kernel stack
0257   07BB             ; restore SP
0258   07BB 7D          	dec a
0259   07BC 47          	mov sp, a
0260   07BD 38 14 00    	mov c, 20
0261   07C0 FD F5       	rep movsb
0262   07C2             ; set VM process
0263   07C2 1D 1A 16    	mov al, [active_proc_index]
0264   07C5 01          	setptb
0265   07C6             		
0266   07C6 F2 E0 FF 00 	mov byte[_TIMER_C_0], 0				; load counter 0 low byte
0267   07CA F2 E0 FF 10 	mov byte[_TIMER_C_0], $10				; load counter 0 high byte
0268   07CE             			
0269   07CE 4C          	popa
0270   07CF 06          	sysret
0271   07D0             
0272   07D0             int_7:
0273   07D0 D7          	push a
0274   07D1 DA          	push d
0275   07D2 E1          	pushf
0276   07D3             			
0277   07D3 14 1F 16    	mov a, [fifo_pi]
0278   07D6 3C          	mov d, a
0279   07D7             
0280   07D7 1D 80 FF    	mov al, [_UART0_DATA]	; get character
0281   07DA B9 03       	cmp al, $03				; CTRL-C
0282   07DC C6 F9 07    	je CTRLC
0283   07DF B9 1A       	cmp al, $1A				; CTRL-Z
0284   07E1 C6 FF 07    	je CTRLZ
0285   07E4 3E          	mov [d], al				; add to fifo
0286   07E5             	
0287   07E5 14 1F 16    	mov a, [fifo_pi]
0288   07E8 77          	inc a
0289   07E9 AF CB 26    	cmp a, fifo + FIFO_SIZE 				; check if pointer reached the end of the fifo
0290   07EC C7 F2 07    	jne int_7_continue
0291   07EF 10 CB 1E    	mov a, fifo	
0292   07F2             int_7_continue:	
0293   07F2 42 1F 16    	mov [fifo_pi], a			; update fifo pointer
0294   07F5             	
0295   07F5 EE          	popf
0296   07F6 E7          	pop d
0297   07F7 E4          	pop a	
0298   07F8 06          	sysret
0299   07F9             
0300   07F9             CTRLC:
0301   07F9 EE          	popf
0302   07FA E7          	pop d
0303   07FB E4          	pop a
0304   07FC 0A E2 14    	jmp cmd_terminate_proc
0305   07FF             
0306   07FF             CTRLZ:
0307   07FF EE          	popf
0308   0800 E7          	pop d
0309   0801 E4          	pop a
0310   0802 0A 25 15    	jmp cmd_pause_proc		; pause current process and go back to the shell
0311   0805             
0312   0805             cmd_system_jmptbl:
0313   0805 0D 08       	.dw cmd_system_uname
0314   0807 14 08       	.dw cmd_system_whoami
0315   0809             
0316   0809             cmd_system:
0317   0809 FD 0A 05 08 	jmp [cmd_system_jmptbl + al]
0318   080D             cmd_system_uname:
0319   080D 3B 57 16    	mov d, s_uname
0320   0810 07 7B 02    	call puts
0321   0813 06          	sysret
0322   0814             cmd_system_whoami:
0323   0814 3B 5F 16    	mov d, s_root
0324   0817 07 7B 02    	call puts
0325   081A 06          	sysret
0326   081B             
0327   081B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0328   081B             ; REBOOT SYSTEM
0329   081B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0330   081B             syscall_reboot:
0331   081B FD D7 FF FF 	push word $FFFF 
0332   081F FD DB 00    	push byte %00000000				; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
0333   0822 FD D7 C0 01 	push word BIOS_RESET_VECTOR		; and then push RESET VECTOR of the shell to the stack
0334   0826 06          	sysret
0335   0827             
0336   0827             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0337   0827             ;; switch to another process
0338   0827             ;; inputs:
0339   0827             ;; AL = new process number
0340   0827             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0341   0827             resume_proc:
0342   0827 FD 78       	mov g, a	; save the process number
0343   0829             ; save all registers into kernel stack
0344   0829 4B          	pusha
0345   082A 22 00       	mov ah, 0
0346   082C 1D 1A 16    	mov al, [active_proc_index]
0347   082F FD 99       	shl a							; x2
0348   0831 B7 D8 15    	mov a, [proc_table_convert + a]	; get process state start index
0349   0834 4F          	mov di, a
0350   0835 48          	mov a, sp
0351   0836 77          	inc a
0352   0837 4D          	mov si, a
0353   0838 38 14 00    	mov c, 20
0354   083B FD F5       	rep movsb					; save process state!
0355   083D             ; restore kernel stack position to point before interrupt arrived
0356   083D 51 14 00    	add sp, 20
0357   0840             ; now load the new process number!
0358   0840 FD 12       	mov a, g						; retrieve the process number argument that was saved in the beginning
0359   0842 3D 1A 16    	mov [active_proc_index], al		; set new active proc
0360   0845             ; calculate LUT entry for next process
0361   0845 22 00       	mov ah, 0
0362   0847 FD 99       	shl a							; x2
0363   0849 B7 D8 15    	mov a, [proc_table_convert + a]		; get process state start index	
0364   084C             	
0365   084C 4D          	mov si, a						; source is proc state block
0366   084D 48          	mov a, sp
0367   084E 5F 13 00    	sub a, 19
0368   0851 4F          	mov di, a						; destination is kernel stack
0369   0852             ; restore SP
0370   0852 7D          	dec a
0371   0853 47          	mov sp, a
0372   0854 38 14 00    	mov c, 20
0373   0857 FD F5       	rep movsb
0374   0859             ; set VM process
0375   0859 1D 1A 16    	mov al, [active_proc_index]
0376   085C 01          	setptb
0377   085D             			
0378   085D 4C          	popa
0379   085E 06          	sysret
0380   085F             
0381   085F             
0382   085F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0383   085F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384   085F             list_procs:
0385   085F 3B 43 16    	mov d, s_ps_header
0386   0862 07 7B 02    	call puts
0387   0865 3B BC 18    	mov d, proc_availab_table + 1
0388   0868 38 01 00    	mov c, 1
0389   086B             list_procs_L0:	
0390   086B BD 01       	cmp byte[d], 1
0391   086D C7 91 08    	jne list_procs_next
0392   0870 2D          	mov b, d
0393   0871 61 BB 18    	sub b, proc_availab_table
0394   0874 FD 9F 05    	shl b, 5
0395   0877 DA          	push d
0396   0878 D8          	push b
0397   0879 28          	mov b, c
0398   087A 07 1B 03    	call print_u8x
0399   087D 22 20       	mov ah, ' '
0400   087F 07 46 01    	call putchar
0401   0882 07 46 01    	call putchar
0402   0885 E5          	pop b
0403   0886 74          	mov d, b
0404   0887 58 CB 18    	add d, proc_names
0405   088A 07 7B 02    	call puts
0406   088D 07 28 02    	call printnl
0407   0890 E7          	pop d
0408   0891             list_procs_next:
0409   0891 79          	inc d
0410   0892 78          	inc c
0411   0893 C2 09 00    	cmp c, 9
0412   0896 C7 6B 08    	jne list_procs_L0
0413   0899             list_procs_end:
0414   0899 06          	sysret
0415   089A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0416   089A             ; PRIVILEGE EXCEPTION
0417   089A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418   089A             trap_privilege:
0419   089A 0A 1B 08    	jmp syscall_reboot
0420   089D DA          	push d
0421   089E             
0422   089E 3B AD 16    	mov d, s_priviledge
0423   08A1 07 7B 02    	call puts
0424   08A4             
0425   08A4 E7          	pop d
0426   08A5             	
0427   08A5 06          	sysret
0428   08A6             
0429   08A6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0430   08A6             ; BREAKPOINT EXCEPTION
0431   08A6             ; IMPORTANT: values in the stack are being pushed in big endian. i.e.: MSB at low address
0432   08A6             ; and LSB at high address. *** NEED TO CORRECT THIS IN THE MICROCODE and make it little endian again ***
0433   08A6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0434   08A6             trap_breakpoint:
0435   08A6 4B          	pusha
0436   08A7             trap_break_prompt:
0437   08A7 3B 61 09    	mov d, s_break1
0438   08AA 07 7B 02    	call puts
0439   08AD 07 28 02    	call printnl
0440   08B0 07 79 03    	call scan_u16d
0441   08B3 AF 00 00    	cmp a, 0
0442   08B6 C6 C1 08    	je trap_break_regs
0443   08B9 AF 01 00    	cmp a, 1
0444   08BC C6 E4 08    	je trap_break_mem
0445   08BF             trap_break_end:	
0446   08BF 4C          	popa
0447   08C0 06          	sysret
0448   08C1             trap_break_regs:
0449   08C1 48          	mov a, sp
0450   08C2 53 0E 00    	add a, 14	; back-track 7 registers
0451   08C5 3C          	mov d, a
0452   08C6 3A 07       	mov cl, 7
0453   08C8             trap_regs_L0:
0454   08C8 2A          	mov b, [d]
0455   08C9 FD AB       	swp b
0456   08CB 07 D7 02    	call print_u16x	; print register value
0457   08CE 07 28 02    	call printnl
0458   08D1 63 02 00    	sub d, 2
0459   08D4 71 01       	sub cl, 1
0460   08D6 C3 00       	cmp cl, 0
0461   08D8 C7 C8 08    	jne trap_regs_L0
0462   08DB 0A A7 08    	jmp trap_break_prompt
0463   08DE 07 28 02    	call printnl
0464   08E1 0A A7 08    	jmp trap_break_prompt
0465   08E4             trap_break_mem:
0466   08E4 07 28 02    	call printnl
0467   08E7 07 F9 02    	call scan_u16x
0468   08EA 4D          	mov si, a			; data source from user space
0469   08EB FD 4F CB 26 	mov di, scrap_sector		; destination in kernel space
0470   08EF 38 00 02    	mov c, 512
0471   08F2 04          	load				; transfer data to kernel space!
0472   08F3 3B CB 26    	mov d, scrap_sector		; dump pointer in d
0473   08F6 38 00 00    	mov c, 0
0474   08F9             dump_loop:
0475   08F9 84          	mov al, cl
0476   08FA 87 0F       	and al, $0F
0477   08FC C6 4A 09    	jz print_base
0478   08FF             back:
0479   08FF 1E          	mov al, [d]				; read byte
0480   0900 2F          	mov bl, al
0481   0901 07 1B 03    	call print_u8x
0482   0904 10 00 20    	mov a, $2000
0483   0907 05 03       	syscall sys_io			; space
0484   0909 84          	mov al, cl
0485   090A 87 0F       	and al, $0F
0486   090C B9 0F       	cmp al, $0F
0487   090E C6 1F 09    	je print_ascii
0488   0911             back1:
0489   0911 79          	inc d
0490   0912 78          	inc c
0491   0913 C2 00 02    	cmp c, 512
0492   0916 C7 F9 08    	jne dump_loop
0493   0919 07 28 02    	call printnl
0494   091C 0A A7 08    	jmp trap_break_prompt	; go to trap_breakpoint return point
0495   091F             print_ascii:
0496   091F 10 00 20    	mov a, $2000
0497   0922 05 03       	syscall sys_io
0498   0924 63 10 00    	sub d, 16
0499   0927 26 10 00    	mov b, 16
0500   092A             print_ascii_L:
0501   092A 79          	inc d
0502   092B 1E          	mov al, [d]				; read byte
0503   092C B9 20       	cmp al, $20
0504   092E C8 36 09    	jlu dot
0505   0931 B9 7E       	cmp al, $7E
0506   0933 D0 3E 09    	jleu ascii
0507   0936             dot:
0508   0936 10 00 2E    	mov a, $2E00
0509   0939 05 03       	syscall sys_io
0510   093B 0A 43 09    	jmp ascii_continue
0511   093E             ascii:
0512   093E 23          	mov ah, al
0513   093F 19 00       	mov al, 0
0514   0941 05 03       	syscall sys_io
0515   0943             ascii_continue:
0516   0943 FD A9 2A 09 	loopb print_ascii_L
0517   0947 0A 11 09    	jmp back1
0518   094A             print_base:
0519   094A 07 28 02    	call printnl
0520   094D 2D          	mov b, d
0521   094E 61 CB 26    	sub b, scrap_sector			; remove this later and fix address bases which display incorrectly
0522   0951 07 D7 02    	call print_u16x				; display row
0523   0954 10 00 3A    	mov a, $3A00
0524   0957 05 03       	syscall sys_io
0525   0959 10 00 20    	mov a, $2000
0526   095C 05 03       	syscall sys_io
0527   095E 0A FF 08    	jmp back
0528   0961             
0529   0961 0A 44 65 62 s_break1:	.db "\nDebugger entry point.\n"
0529   0965 75 67 67 65 
0529   0969 72 20 65 6E 
0529   096D 74 72 79 20 
0529   0971 70 6F 69 6E 
0529   0975 74 2E 0A 
0530   0978 30 2E 20 53 			.db "0. Show Registers\n"
0530   097C 68 6F 77 20 
0530   0980 52 65 67 69 
0530   0984 73 74 65 72 
0530   0988 73 0A 
0531   098A 31 2E 20 53 			.db "1. Show 512B RAM block\n"
0531   098E 68 6F 77 20 
0531   0992 35 31 32 42 
0531   0996 20 52 41 4D 
0531   099A 20 62 6C 6F 
0531   099E 63 6B 0A 
0532   09A1 32 2E 20 43 			.db "2. Continue Execution", 0
0532   09A5 6F 6E 74 69 
0532   09A9 6E 75 65 20 
0532   09AD 45 78 65 63 
0532   09B1 75 74 69 6F 
0532   09B5 6E 00 
0533   09B7             
0534   09B7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535   09B7             ; DIVIDE BY ZERO EXCEPTION
0536   09B7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0537   09B7             trap_div_zero:
0538   09B7 D7          	push a
0539   09B8 DA          	push d
0540   09B9 E1          	pushf
0541   09BA             		
0542   09BA 3B D5 16    	mov d, s_divzero
0543   09BD 07 7B 02    	call puts
0544   09C0             	
0545   09C0 EE          	popf
0546   09C1 E7          	pop d
0547   09C2 E4          	pop a
0548   09C3             							; enable interrupts
0549   09C3 06          	sysret
0550   09C4             
0551   09C4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0552   09C4             ; UNDEFINED OPCODE EXCEPTION
0553   09C4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0554   09C4             undefined_opcode:
0555   09C4 06          	sysret
0556   09C5             
0557   09C5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0558   09C5             ; RTC SERVICES INTERRUPT
0559   09C5             ; RTC I/O bank = FFA0 to FFAF
0560   09C5             ; FFA0 to FFA7 is scratch RAM
0561   09C5             ; control register at $FFA8 [ W | R | S | Cal4..Cal0 ]
0562   09C5             ; al = 0..6 -> get
0563   09C5             ; al = 7..D -> set
0564   09C5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0565   09C5             rtc_services:
0566   09C5 DB          	push al
0567   09C6 DA          	push d
0568   09C7 B9 06       	cmp al, 6
0569   09C9 D1 DE 09    	jgu rtc_set
0570   09CC             rtc_get:
0571   09CC 6A A9       	add al, $A9			; generate RTC address to get to address A9 of clock
0572   09CE 22 FF       	mov ah, $FF		
0573   09D0 3C          	mov d, a				; get to FFA9 + offset
0574   09D1 F2 A8 FF 40 	mov byte[$FFA8], $40		; set R bit to 1
0575   09D5 1E          	mov al, [d]			; get data
0576   09D6 F2 A8 FF 00 	mov byte[$FFA8], 0		; reset R bit
0577   09DA 23          	mov ah, al
0578   09DB E7          	pop d
0579   09DC E8          	pop al
0580   09DD 06          	sysret
0581   09DE             rtc_set:
0582   09DE DD          	push bl
0583   09DF 99          	mov bl, ah		; set data asIDE
0584   09E0 6A A2       	add al, $A2		; generate RTC address to get to address A9 of clock
0585   09E2 22 FF       	mov ah, $FF		
0586   09E4 3C          	mov d, a		; get to FFA9 + offset
0587   09E5 1B          	mov al, bl		; get data back
0588   09E6 F2 A8 FF 80 	mov byte[$FFA8], $80	; set W bit to 1
0589   09EA 3E          	mov [d], al		; set data
0590   09EB F2 A8 FF 00 	mov byte[$FFA8], 0		; reset write bit
0591   09EF EA          	pop bl
0592   09F0 E7          	pop d
0593   09F1 E8          	pop al
0594   09F2 06          	sysret
0595   09F3             
0596   09F3             datetime_serv_tbl:
0597   09F3 FB 09       	.dw print_date
0598   09F5 6F 0A       	.dw set_date
0599   09F7             datetime_services:
0600   09F7 FD 0A F3 09 	jmp [datetime_serv_tbl + al]			
0601   09FB             print_date:
0602   09FB 10 00 0D    	mov a, $0D00				; print carriage return char
0603   09FE 19 03       	mov al, 3
0604   0A00 05 01       	syscall sys_rtc				; get week
0605   0A02 1A          	mov al, ah
0606   0A03 22 00       	mov ah, 0
0607   0A05 FD 9D 02    	shl a, 2					; times 16
0608   0A08 3B 5F 17    	mov d, s_week
0609   0A0B 59          	add d, a
0610   0A0C 07 7B 02    	call puts
0611   0A0F 10 00 20    	mov a, $2000
0612   0A12 05 03       	syscall sys_io					; display ' '
0613   0A14             	
0614   0A14 19 04       	mov al, 4
0615   0A16 05 01       	syscall sys_rtc					; get day
0616   0A18 99          	mov bl, ah
0617   0A19 07 1B 03    	call print_u8x
0618   0A1C 10 00 20    	mov a, $2000
0619   0A1F 05 03       	syscall sys_io					; display ' '
0620   0A21             	
0621   0A21 19 05       	mov al, 05
0622   0A23 05 01       	syscall sys_rtc				; get month
0623   0A25 1A          	mov al, ah
0624   0A26 22 00       	mov ah, 0
0625   0A28 FD 9D 02    	shl a, 2					; times 16
0626   0A2B 3B 2B 17    	mov d, s_months
0627   0A2E 59          	add d, a
0628   0A2F 07 7B 02    	call puts
0629   0A32             	
0630   0A32 10 00 20    	mov a, $2000
0631   0A35 05 03       	syscall sys_io			; display ' '
0632   0A37             	
0633   0A37 2E 20       	mov bl, $20
0634   0A39 07 1B 03    	call print_u8x			; print 20 for year prefix
0635   0A3C 19 06       	mov al, 06
0636   0A3E 05 01       	syscall sys_rtc					; get year
0637   0A40 99          	mov bl, ah
0638   0A41 07 1B 03    	call print_u8x
0639   0A44             	
0640   0A44 10 00 20    	mov a, $2000	
0641   0A47 05 03       	syscall sys_io			; display ' '
0642   0A49             
0643   0A49 19 02       	mov al, 2
0644   0A4B 05 01       	syscall sys_rtc					; get hours
0645   0A4D 99          	mov bl, ah
0646   0A4E 07 1B 03    	call print_u8x
0647   0A51 10 00 3A    	mov a, $3A00		
0648   0A54 05 03       	syscall sys_io				; display ':'
0649   0A56             
0650   0A56 19 01       	mov al, 01
0651   0A58 05 01       	syscall sys_rtc					; get minutes
0652   0A5A 99          	mov bl, ah
0653   0A5B 07 1B 03    	call print_u8x
0654   0A5E 10 00 3A    	mov a, $3A00	
0655   0A61 05 03       	syscall sys_io			; display ':'
0656   0A63             
0657   0A63 19 00       	mov al, 0
0658   0A65 05 01       	syscall sys_rtc					; get seconds
0659   0A67 99          	mov bl, ah
0660   0A68 07 1B 03    	call print_u8x
0661   0A6B             	
0662   0A6B 07 28 02    	call printnl
0663   0A6E 06          	sysret
0664   0A6F             	
0665   0A6F             set_date:
0666   0A6F 3B F0 16    	mov d, s_set_year
0667   0A72 07 7B 02    	call puts
0668   0A75 07 62 03    	call scan_u8x				; read integer into A
0669   0A78 FD 9D 08    	shl a, 8				; only AL used, move to AH
0670   0A7B 19 0D       	mov al, 0Dh				; set RTC year
0671   0A7D 05 01       	syscall sys_rtc					; set RTC
0672   0A7F             	
0673   0A7F 3B F7 16    	mov d, s_set_month
0674   0A82 07 7B 02    	call puts
0675   0A85 07 62 03    	call scan_u8x					; read integer into A
0676   0A88 FD 9D 08    	shl a, 8				; only AL used, move to AH
0677   0A8B 19 0C       	mov al, 0Ch				; set RTC month
0678   0A8D 05 01       	syscall sys_rtc					; set RTC
0679   0A8F             
0680   0A8F 3B FF 16    	mov d, s_set_day
0681   0A92 07 7B 02    	call puts
0682   0A95 07 62 03    	call scan_u8x					; read integer into A
0683   0A98 FD 9D 08    	shl a, 8				; only AL used, move to AH
0684   0A9B 19 0B       	mov al, 0Bh				; set RTC month
0685   0A9D 05 01       	syscall sys_rtc					; set RTC
0686   0A9F             
0687   0A9F 3B 05 17    	mov d, s_set_week
0688   0AA2 07 7B 02    	call puts
0689   0AA5 07 62 03    	call scan_u8x					; read integer into A
0690   0AA8 FD 9D 08    	shl a, 8				; only AL used, move to AH
0691   0AAB 19 0A       	mov al, 0Ah				; set RTC month
0692   0AAD 05 01       	syscall sys_rtc					; set RTC
0693   0AAF             
0694   0AAF 3B 0F 17    	mov d, s_set_hours
0695   0AB2 07 7B 02    	call puts
0696   0AB5 07 62 03    	call scan_u8x					; read integer into A
0697   0AB8 FD 9D 08    	shl a, 8				; only AL used, move to AH
0698   0ABB 19 09       	mov al, 09h				; set RTC month
0699   0ABD 05 01       	syscall sys_rtc					; set RTC
0700   0ABF             
0701   0ABF 3B 17 17    	mov d, s_set_minutes
0702   0AC2 07 7B 02    	call puts
0703   0AC5 07 62 03    	call scan_u8x					; read integer into A
0704   0AC8 FD 9D 08    	shl a, 8				; only AL used, move to AH
0705   0ACB 19 08       	mov al, 08h				; set RTC month
0706   0ACD 05 01       	syscall sys_rtc					; set RTC
0707   0ACF             
0708   0ACF 3B 21 17    	mov d, s_set_seconds
0709   0AD2 07 7B 02    	call puts
0710   0AD5 07 62 03    	call scan_u8x					; read integer into A
0711   0AD8 FD 9D 08    	shl a, 8					; only AL used, move to AH
0712   0ADB 19 07       	mov al, 07h				; set RTC month
0713   0ADD 05 01       	syscall sys_rtc					; set RTC
0714   0ADF 06          	sysret
0715   0AE0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0716   0AE0             ; IDE SERVICES INTERRUPT
0717   0AE0             ; al = option
0718   0AE0             ; 0 = IDE reset, 1 = IDE sleep, 2 = read sector, 3 = write sector
0719   0AE0             ; IDE read/write sector
0720   0AE0             ; 512 bytes
0721   0AE0             ; user buffer pointer in D
0722   0AE0             ; AH = number of sectors
0723   0AE0             ; CB = LBA bytes 3..0
0724   0AE0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0725   0AE0             IDE_serv_tbl:
0726   0AE0 EC 0A       	.dw IDE_reset
0727   0AE2 00 0B       	.dw IDE_sleep
0728   0AE4 0F 0B       	.dw IDE_read_sect_wrapper
0729   0AE6 13 0B       	.dw IDE_write_sect_wrapper
0730   0AE8             IDE_services_kernel:
0731   0AE8 FD 0A E0 0A 	jmp [IDE_serv_tbl + al]		
0732   0AEC             	
0733   0AEC             IDE_reset:			
0734   0AEC F2 D7 FF 04 	mov byte[_IDE_R7], 4		; RESET IDE
0735   0AF0 07 99 0B    	call IDE_wait				; wait for IDE ready			 			
0736   0AF3 F2 D6 FF E0 	mov byte[_IDE_R6], $E0		; LBA3= 0, MASTER, MODE= LBA				
0737   0AF7 F2 D1 FF 01 	mov byte[_IDE_R1], 1		; 8-BIT TRANSFERS			
0738   0AFB F2 D7 FF EF 	mov byte[_IDE_R7], $EF		; SET FEATURE COMMAND
0739   0AFF 06          	sysret
0740   0B00             IDE_sleep:
0741   0B00 07 99 0B    	call IDE_wait					; wait for IDE ready			 			
0742   0B03 F2 D6 FF 40 	mov byte [_IDE_R6], %01000000	; lba[3:0](reserved), bit 6=1
0743   0B07 F2 D7 FF E6 	mov byte [_IDE_R7], $E6		; sleep command
0744   0B0B 07 99 0B    	call IDE_wait					; wait for IDE ready
0745   0B0E 06          	sysret
0746   0B0F             IDE_read_sect_wrapper:
0747   0B0F 07 17 0B    	call IDE_read_sect
0748   0B12 06          	sysret
0749   0B13             IDE_write_sect_wrapper:
0750   0B13 07 3D 0B    	call IDE_write_sect
0751   0B16 06          	sysret
0752   0B17             IDE_read_sect:
0753   0B17 1A          	mov al, ah
0754   0B18 24          	mov ah, bl
0755   0B19 42 D2 FF    	mov [_IDE_R2], a			; number of sectors (0..255)
0756   0B1C 1C          	mov al, bh
0757   0B1D 3D D4 FF    	mov [_IDE_R4], al
0758   0B20 12          	mov a, c
0759   0B21 3D D5 FF    	mov [_IDE_R5], al
0760   0B24 1A          	mov al, ah
0761   0B25 87 0F       	and al, %00001111
0762   0B27 8B E0       	or al, %11100000			; mode lba, master
0763   0B29 3D D6 FF    	mov [_IDE_R6], al
0764   0B2C             IDE_read_sect_wait:
0765   0B2C 1D D7 FF    	mov al, [_IDE_R7]	
0766   0B2F 87 80       	and al, $80				; BUSY FLAG
0767   0B31 C7 2C 0B    	jnz IDE_read_sect_wait
0768   0B34 19 20       	mov al, $20
0769   0B36 3D D7 FF    	mov [_IDE_R7], al			; read sector cmd
0770   0B39 07 63 0B    	call IDE_read	
0771   0B3C 09          	ret
0772   0B3D             IDE_write_sect:
0773   0B3D 1A          	mov al, ah
0774   0B3E 24          	mov ah, bl
0775   0B3F 42 D2 FF    	mov [_IDE_R2], a			; number of sectors (0..255)
0776   0B42 1C          	mov al, bh
0777   0B43 3D D4 FF    	mov [_IDE_R4], al
0778   0B46 12          	mov a, c
0779   0B47 3D D5 FF    	mov [_IDE_R5], al
0780   0B4A 1A          	mov al, ah
0781   0B4B 87 0F       	and al, %00001111
0782   0B4D 8B E0       	or al, %11100000			; mode lba, master
0783   0B4F 3D D6 FF    	mov [_IDE_R6], al
0784   0B52             IDE_write_sect_wait:
0785   0B52 1D D7 FF    	mov al, [_IDE_R7]	
0786   0B55 87 80       	and al, $80				; BUSY FLAG
0787   0B57 C7 52 0B    	jnz IDE_write_sect_wait
0788   0B5A 19 30       	mov al, $30
0789   0B5C 3D D7 FF    	mov [_IDE_R7], al			; write sector cmd
0790   0B5F 07 7E 0B    	call IDE_write			
0791   0B62 09          	ret
0792   0B63             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0793   0B63             ; READ IDE DATA
0794   0B63             ; pointer in D
0795   0B63             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0796   0B63             IDE_read:
0797   0B63 DA          	push d
0798   0B64             IDE_read_loop:
0799   0B64 1D D7 FF    	mov al, [_IDE_R7]	
0800   0B67 87 80       	and al, 80h				; BUSY FLAG
0801   0B69 C7 64 0B    	jnz IDE_read_loop			; wait loop
0802   0B6C             	
0803   0B6C 1D D7 FF    	mov al, [_IDE_R7]
0804   0B6F 87 08       	and al, %00001000			; DRQ FLAG
0805   0B71 C6 7C 0B    	jz IDE_read_end
0806   0B74 1D D0 FF    	mov al, [_IDE_R0]
0807   0B77 3E          	mov [d], al
0808   0B78 79          	inc d
0809   0B79 0A 64 0B    	jmp IDE_read_loop
0810   0B7C             IDE_read_end:
0811   0B7C E7          	pop d
0812   0B7D 09          	ret
0813   0B7E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0814   0B7E             ; WRITE IDE DATA
0815   0B7E             ; data pointer in D
0816   0B7E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0817   0B7E             IDE_write:
0818   0B7E DA          	push d
0819   0B7F             IDE_write_loop:
0820   0B7F 1D D7 FF    	mov al, [_IDE_R7]	
0821   0B82 87 80       	and al, 80h				; BUSY FLAG
0822   0B84 C7 7F 0B    	jnz IDE_write_loop			; wait loop
0823   0B87             	
0824   0B87 1D D7 FF    	mov al, [_IDE_R7]
0825   0B8A 87 08       	and al, %00001000			; DRQ FLAG
0826   0B8C C6 97 0B    	jz IDE_write_end
0827   0B8F 1E          	mov al, [d]
0828   0B90 3D D0 FF    	mov [_IDE_R0], al
0829   0B93 79          	inc d 
0830   0B94 0A 7F 0B    	jmp IDE_write_loop
0831   0B97             IDE_write_end:
0832   0B97 E7          	pop d
0833   0B98 09          	ret
0834   0B99             
0835   0B99             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0836   0B99             ; wait for IDE to be ready
0837   0B99             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0838   0B99             IDE_wait:
0839   0B99 1D D7 FF    	mov al, [_IDE_R7]	
0840   0B9C 87 80       	and al, 80h				; BUSY FLAG
0841   0B9E C7 99 0B    	jnz IDE_wait
0842   0BA1 09          	ret
0843   0BA2             
0844   0BA2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0845   0BA2             ; i/o interrupt
0846   0BA2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0847   0BA2             io_services_jmp:
0848   0BA2 C5 0B       	.dw io_putchar
0849   0BA4 D2 0B       	.dw io_getchar
0850   0BA6 AC 0B       	.dw io_uart_init
0851   0BA8             
0852   0BA8             io_services:
0853   0BA8 FD 0A A2 0B 	jmp [io_services_jmp + al]
0854   0BAC             io_uart_init:
0855   0BAC F2 83 FF 83 	mov byte[_UART0_LCR], $83			; 8 data, 1 stop, no parity	, divisor latch = 1, UART address 3 = Line Control Register
0856   0BB0 F2 80 FF 03 	mov byte[_UART0_DLAB_0], 3			; baud = 38400, divisor latch low byte = 3
0857   0BB4 F2 81 FF 00 	mov byte[_UART0_DLAB_1], 0			; divisor latch high byte = 0			
0858   0BB8 F2 83 FF 03 	mov byte[_UART0_LCR], 3			; UART address 3 = Line Control Register
0859   0BBC F2 81 FF 01 	mov byte[_UART0_IER], 1			; enable interrupt: receive data available
0860   0BC0 F2 82 FF 00 	mov byte[_UART0_FCR], 0			; disable FIFO
0861   0BC4 06          	sysret
0862   0BC5             ; char in ah
0863   0BC5             io_putchar:
0864   0BC5             io_putchar_L0:
0865   0BC5 1D 85 FF    	mov al, [_UART0_LSR]			; read Line Status Register
0866   0BC8 93 20       	test al, $20					; isolate Transmitter Empty
0867   0BCA C6 C5 0B    	jz io_putchar_L0		
0868   0BCD 1A          	mov al, ah
0869   0BCE 3D 80 FF    	mov [_UART0_DATA], al			; write char to Transmitter Holding Register
0870   0BD1 06          	sysret
0871   0BD2             ; char in ah
0872   0BD2             ; al = sucess code
0873   0BD2             io_getchar:
0874   0BD2 D8          	push b
0875   0BD3 DA          	push d
0876   0BD4             io_getchar_L0:	
0877   0BD4 14 21 16    	mov a, [fifo_pr]
0878   0BD7 29 1F 16    	mov b, [fifo_pi]
0879   0BDA B0          	cmp a, b
0880   0BDB C6 03 0C    	je io_getchar_fail
0881   0BDE             	
0882   0BDE 3C          	mov d, a
0883   0BDF 1E          	mov al, [d]
0884   0BE0 DB          	push al
0885   0BE1             	
0886   0BE1 14 21 16    	mov a, [fifo_pr]
0887   0BE4 77          	inc a
0888   0BE5 AF CB 26    	cmp a, fifo + FIFO_SIZE				; check if pointer reached the end of the fifo
0889   0BE8 C7 EE 0B    	jne io_getchar_cont
0890   0BEB 10 CB 1E    	mov a, fifo	
0891   0BEE             io_getchar_cont:	
0892   0BEE 42 21 16    	mov [fifo_pr], a			; update fifo pointer
0893   0BF1             	
0894   0BF1 E9          	pop ah
0895   0BF2             ; here we just echo the char back to the console
0896   0BF2             io_getchar_echo_L0:
0897   0BF2 1D 85 FF    	mov al, [_UART0_LSR]			; read Line Status Register
0898   0BF5 93 20       	test al, $20					; isolate Transmitter Empty
0899   0BF7 C6 F2 0B    	jz io_getchar_echo_L0
0900   0BFA 1A          	mov al, ah
0901   0BFB 3D 80 FF    	mov [_UART0_DATA], al			; write char to Transmitter Holding Register
0902   0BFE             
0903   0BFE 19 01       	mov al, 1		; AL = 1 means a char successfully received
0904   0C00 E7          	pop d
0905   0C01 E5          	pop b
0906   0C02 06          	sysret
0907   0C03             io_getchar_fail:
0908   0C03 E7          	pop d
0909   0C04 E5          	pop b
0910   0C05 19 00       	mov al, 0			; AL = 0 means no char received
0911   0C07 06          	sysret
0912   0C08             
0913   0C08             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0914   0C08             ;; FILE SYSTEM DATA
0915   0C08             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0916   0C08             ; infor for : IDE SERVICES INTERRUPT
0917   0C08             ; IDE read/write 512-byte sector
0918   0C08             ; al = option
0919   0C08             ; user buffer pointer in D
0920   0C08             ; AH = number of sectors
0921   0C08             ; CB = LBA bytes 3..0	
0922   0C08             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0923   0C08             ;; FILE SYSTEM DATA STRUCTURE
0924   0C08             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0925   0C08             ; for a directory we have the header first, followed by metadata
0926   0C08             ; header 1 sector (512 bytes)
0927   0C08             ; metadata 1 sector (512 bytes)
0928   0C08             ; HEADER ENTRIES:
0929   0C08             ; filename (64)
0930   0C08             ; parent dir LBA (2) -  to be used for faster backwards navigation...
0931   0C08             ;
0932   0C08             ; metadata entries:
0933   0C08             ; filename (24)
0934   0C08             ; attributes (1)	|_|_|file_type(3bits)|x|w|r| types: file, directory, character device
0935   0C08             ; LBA (2)
0936   0C08             ; size (2)
0937   0C08             ; day (1)
0938   0C08             ; month (1)
0939   0C08             ; year (1)
0940   0C08             ; packet size = 32 bytes
0941   0C08             ;
0942   0C08             ; first directory on disk is the root directory '/'
0943   0C08             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0944   0C08             ;; FILE SYSTEM DISK FORMATTING
0945   0C08             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0946   0C08             ; writes FST_TOTAL_SECTORS + FS_NBR_FILES disk sectors  with 0's
0947   0C08             ; this is the file system table formating
0948   0C08             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0949   0C08             file_system_jmptbl:
0950   0C08 38 0C       	.dw file_system_mkfs
0951   0C0A E3 0C       	.dw cmd_fs_space
0952   0C0C E4 0C       	.dw cmd_mkdir
0953   0C0E 5D 10       	.dw cmd_cd
0954   0C10 62 10       	.dw cmd_ls
0955   0C12 4B 11       	.dw cmd_mktxt
0956   0C14 CC 11       	.dw cmd_mkbin
0957   0C16 89 12       	.dw cmd_pwd
0958   0C18 F7 12       	.dw cmd_cat
0959   0C1A 53 13       	.dw cmd_rmdir					; 9
0960   0C1C AF 13       	.dw cmd_rm
0961   0C1E 00 00       	.dw 0
0962   0C20 00 00       	.dw 0
0963   0C22 00 00       	.dw 0							; 13
0964   0C24 67 0C       	.dw fileio_chmod				; 14
0965   0C26 17 14       	.dw cmd_mv						; 15
0966   0C28 60 0C       	.dw cd_goto_root				; 16
0967   0C2A 59 10       	.dw get_current_dirID			; 17
0968   0C2C 35 0E       	.dw get_path_from_dirID			; 18
0969   0C2E 9B 0E       	.dw get_dirID_from_path_user	; 19
0970   0C30 B5 0F       	.dw loadfile_from_path_user		; 20	
0971   0C32 25 0F       	.dw file_exists_by_path_user	; 21
0972   0C34             file_system:
0973   0C34 FD 0A 08 0C 	jmp [file_system_jmptbl + al]
0974   0C38             
0975   0C38             file_system_mkfs:	
0976   0C38 FD 4F CB 28 	mov di, transient_area
0977   0C3C 19 00       	mov al, 0
0978   0C3E 38 00 02    	mov c, 512
0979   0C41 FD F7       	rep stosb
0980   0C43 26 20 00    	mov b, FST_LBA_START
0981   0C46 38 00 00    	mov c, 0				; reset LBA to 0
0982   0C49             file_system_mkfs_L1:	
0983   0C49 22 01       	mov ah, $01			; one sect
0984   0C4B 3B CB 28    	mov d, transient_area
0985   0C4E 07 3D 0B    	call IDE_write_sect
0986   0C51 FD 77       	inc b
0987   0C53 C0 00 08    	cmp b, CF_CARD_LBA_SIZE
0988   0C56 C7 49 0C    	jne file_system_mkfs_L1
0989   0C59             file_system_mkfs_create_root:
0990   0C59 10 20 00    	mov a, ROOT_dirID
0991   0C5C 42 23 16    	mov [current_dirID], a		; set current directory LBA to ROOT
0992   0C5F 06          	sysret	
0993   0C60             	
0994   0C60             cd_goto_root:
0995   0C60 10 20 00    	mov a, ROOT_dirID
0996   0C63 42 23 16    	mov [current_dirID], a		; set current directory LBA to ROOT
0997   0C66 06          	sysret	
0998   0C67             
0999   0C67             ; filename in D (userspace data)
1000   0C67             ; permission in BL
1001   0C67             fileio_chmod:
1002   0C67 DD          	push bl
1003   0C68 FD 4E       	mov si, d
1004   0C6A FD 4F CB 1C 	mov di, temp_data
1005   0C6E 38 80 00    	mov c, 128
1006   0C71 04          	load					; load filename from user-space
1007   0C72             		
1008   0C72 14 23 16    	mov a, [current_dirID]
1009   0C75 77          	inc a				; metadata sector
1010   0C76 27          	mov b, a
1011   0C77 38 00 00    	mov c, 0				; reset LBA to 0
1012   0C7A 22 01       	mov ah, $01			; disk read
1013   0C7C 3B CB 28    	mov d, transient_area
1014   0C7F 07 17 0B    	call IDE_read_sect		; read directory
1015   0C82 FD 10       	cla
1016   0C84 42 1B 16    	mov [index], a		; reset file counter
1017   0C87             fileio_chmod_L1:
1018   0C87 FD 4E       	mov si, d
1019   0C89 FD 4F CB 1C 	mov di, temp_data
1020   0C8D 07 93 00    	call strcmp
1021   0C90 C6 A7 0C    	je fileio_chmod_found_entry
1022   0C93             
1023   0C93 58 20 00    	add d, 32
1024   0C96 14 1B 16    	mov a, [index]
1025   0C99 77          	inc a
1026   0C9A 42 1B 16    	mov [index], a
1027   0C9D AF 10 00    	cmp a, FST_FILES_PER_DIR
1028   0CA0 C7 87 0C    	jne fileio_chmod_L1
1029   0CA3 EA          	pop bl
1030   0CA4 0A C0 0C    	jmp fileio_chmod_not_found
1031   0CA7             fileio_chmod_found_entry:	
1032   0CA7 FD 79       	mov g, b					; save LBA
1033   0CA9 EA          	pop bl						; retrieve saved permission value
1034   0CAA 1F 18 00    	mov al, [d + 24]			; read file permissions
1035   0CAD 87 F8       	and al, %11111000			; remove all permissions, keep other flags
1036   0CAF 8C          	or al, bl					; set new permissions
1037   0CB0 3F 18 00    	mov [d + 24], al			; write new permissions
1038   0CB3 38 00 00    	mov c, 0
1039   0CB6 3B CB 28    	mov d, transient_area
1040   0CB9 22 01       	mov ah, $01				; disk write 1 sect
1041   0CBB FD 27       	mov b, g					; retrieve LBA
1042   0CBD 07 3D 0B    	call IDE_write_sect		; write sector
1043   0CC0             fileio_chmod_not_found:
1044   0CC0 06          	sysret
1045   0CC1             
1046   0CC1             ;; bootloader installer
1047   0CC1             ;; kernel LBA address in A
1048   0CC1             cmd_boot_installer:
1049   0CC1 D7          	push a
1050   0CC2 26 00 00    	mov b, 0
1051   0CC5 38 00 00    	mov c, 0
1052   0CC8 22 01       	mov ah, $01				; 1 sector
1053   0CCA 3B CB 28    	mov d, transient_area
1054   0CCD 07 17 0B    	call IDE_read_sect			; read sector
1055   0CD0             	
1056   0CD0 E4          	pop a
1057   0CD1 44 FE 01    	mov [d + 510], a		; update LBA address
1058   0CD4 26 00 00    	mov b, 0
1059   0CD7 38 00 00    	mov c, 0
1060   0CDA 22 01       	mov ah, $01				; 1 sector
1061   0CDC 3B CB 28    	mov d, transient_area
1062   0CDF 07 3D 0B    	call IDE_write_sect		; write sector
1063   0CE2             	
1064   0CE2 06          	sysret
1065   0CE3             
1066   0CE3             cmd_fs_space:
1067   0CE3 06          	sysret
1068   0CE4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1069   0CE4             ;; CREATE NEW DIRECTORY
1070   0CE4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1071   0CE4             ; search list for NULL name entry. add new directory to list
1072   0CE4             cmd_mkdir:
1073   0CE4 FD 4E       	mov si, d
1074   0CE6 FD 4F CB 1C 	mov di, temp_data
1075   0CEA 38 00 02    	mov c, 512
1076   0CED 04          	load						; load data from user-space
1077   0CEE 26 22 00    	mov b, FST_LBA_START + 2 	; start at 2 because LBA  0 is ROOT (this would also cause issues 								
1078   0CF1             								; when checking for NULL name, since root has a NULL name)
1079   0CF1 38 00 00    	mov c, 0					; reset LBA to 0
1080   0CF4             cmd_mkdir_L1:	
1081   0CF4 22 01       	mov ah, $01			; disk read
1082   0CF6 3B CB 28    	mov d, transient_area
1083   0CF9 07 17 0B    	call IDE_read_sect		; read sector
1084   0CFC BD 00       	cmp byte[d], 0			; check for NULL
1085   0CFE C6 07 0D    	je cmd_mkdir_found_null
1086   0D01 55 02 00    	add b, FST_SECTORS_PER_DIR					; skip directory
1087   0D04 0A F4 0C    	jmp cmd_mkdir_L1
1088   0D07             cmd_mkdir_found_null:
1089   0D07             ;create header file by grabbing dir name from parameter
1090   0D07 D8          	push b				; save new directory's LBA
1091   0D08 38 40 00    	mov c, 64
1092   0D0B FD 4D CB 1C 	mov si, temp_data
1093   0D0F FD 4F CB 28 	mov di, transient_area
1094   0D13 FD F5       	rep movsb					; copy dirname from temp_data to transient_area
1095   0D15 14 23 16    	mov a, [current_dirID]
1096   0D18 42 0B 29    	mov [transient_area + 64], a		; store parent directory LBA
1097   0D1B 19 00       	mov al, 0
1098   0D1D FD 4F CB 2A 	mov di, transient_area + 512
1099   0D21 38 00 02    	mov c, 512
1100   0D24 FD F7       	rep stosb					; clean buffer
1101   0D26 38 00 00    	mov c, 0				; reset LBA(c) to 0
1102   0D29             ; write directory entry sectors
1103   0D29 3B CB 28    	mov d, transient_area
1104   0D2C 22 02       	mov ah, $02			; disk write, 2 sectors
1105   0D2E 07 3D 0B    	call IDE_write_sect		; write sector
1106   0D31             ; now we need to add the new directory to the list, insIDE the current directory
1107   0D31 14 23 16    	mov a, [current_dirID]
1108   0D34 53 01 00    	add a, 1
1109   0D37 27          	mov b, a					; metadata sector
1110   0D38 38 00 00    	mov c, 0
1111   0D3B FD 79       	mov g, b					; save LBA
1112   0D3D 3B CB 28    	mov d, transient_area
1113   0D40 22 01       	mov ah, $01			; disk read
1114   0D42 07 17 0B    	call IDE_read_sect		; read metadata sector
1115   0D45             cmd_mkdir_L2:
1116   0D45 BD 00       	cmp byte[d], 0
1117   0D47 C6 50 0D    	je cmd_mkdir_found_null2
1118   0D4A 58 20 00    	add d, FST_ENTRY_SIZE
1119   0D4D 0A 45 0D    	jmp cmd_mkdir_L2					; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1120   0D50             cmd_mkdir_found_null2:
1121   0D50 FD 4D CB 1C 	mov si, temp_data
1122   0D54 FD 50       	mov di, d
1123   0D56 07 A8 00    	call strcpy			; copy directory name
1124   0D59 58 18 00    	add d, 24			; goto ATTRIBUTES
1125   0D5C 19 0B       	mov al, %00001011		;directory, no execute, write, read
1126   0D5E 3E          	mov [d], al			
1127   0D5F 79          	inc d
1128   0D60 E5          	pop b
1129   0D61 D8          	push b				; push LBA back
1130   0D62 FD 43       	mov [d], b			; save LBA
1131   0D64             ; set file creation date	
1132   0D64 58 04 00    	add d, 4
1133   0D67 19 04       	mov al, 4
1134   0D69 05 01       	syscall sys_rtc
1135   0D6B 1A          	mov al, ah
1136   0D6C 3E          	mov [d], al			; set day
1137   0D6D 79          	inc d
1138   0D6E 19 05       	mov al, 5
1139   0D70 05 01       	syscall sys_rtc
1140   0D72 1A          	mov al, ah
1141   0D73 3E          	mov [d], al			; set month
1142   0D74 79          	inc d
1143   0D75 19 06       	mov al, 6
1144   0D77 05 01       	syscall sys_rtc
1145   0D79 1A          	mov al, ah
1146   0D7A 3E          	mov [d], al			; set year
1147   0D7B             ; write sector into disk for new directory entry
1148   0D7B FD 27       	mov b, g
1149   0D7D 38 00 00    	mov c, 0
1150   0D80 3B CB 28    	mov d, transient_area
1151   0D83 22 01       	mov ah, $01			; disk write, 1 sector
1152   0D85 07 3D 0B    	call IDE_write_sect		; write sector
1153   0D88             
1154   0D88             ; after adding the new directory's information to its parent directory's list
1155   0D88             ; we need to now enter the new directory, and to it add two new directories!
1156   0D88             ; which directories do we need to add ? '..' and '.' are the directories needed.
1157   0D88             ; importantly, note that these two new directories are only entries in the list
1158   0D88             ; and do not have actual physical entries in the disk as real directories.
1159   0D88             ; i.e. they only exist as list entries in the new directory created so that
1160   0D88             ; the new directory can reference its parent and itself
1161   0D88             ;
1162   0D88             ; we need to add both '..' and '.'
1163   0D88             ; this first section is for '..' and on the section below we do the same for '.'
1164   0D88 E4          	pop a						; retrieve the new directory's LBA	
1165   0D89 D7          	push a						; and save again
1166   0D8A 53 01 00    	add a, 1
1167   0D8D 27          	mov b, a					; metadata sector
1168   0D8E 38 00 00    	mov c, 0
1169   0D91 FD 79       	mov g, b					; save LBA
1170   0D93 3B CB 28    	mov d, transient_area
1171   0D96 22 01       	mov ah, $01			; disk read
1172   0D98 07 17 0B    	call IDE_read_sect		; read metadata sector
1173   0D9B             cmd_mkdir_L3:
1174   0D9B BD 00       	cmp byte[d], 0
1175   0D9D C6 A6 0D    	je cmd_mkdir_found_null3
1176   0DA0 58 20 00    	add d, FST_ENTRY_SIZE
1177   0DA3 0A 9B 0D    	jmp cmd_mkdir_L3	; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1178   0DA6             cmd_mkdir_found_null3:
1179   0DA6 FD 4D 30 16 	mov si, s_parent_dir
1180   0DAA FD 50       	mov di, d
1181   0DAC 07 A8 00    	call strcpy			; copy directory name
1182   0DAF 58 18 00    	add d, 24			; goto ATTRIBUTES
1183   0DB2 19 0B       	mov al, %00001011		;directory, no execute, write, read, 
1184   0DB4 3E          	mov [d], al			
1185   0DB5 79          	inc d
1186   0DB6 29 23 16    	mov b, [current_dirID]	; retrieve the parent directorys LBA
1187   0DB9 FD 43       	mov [d], b			; save LBA
1188   0DBB             ; set file creation date	
1189   0DBB 58 04 00    	add d, 4
1190   0DBE 19 04       	mov al, 4
1191   0DC0 05 01       	syscall sys_rtc
1192   0DC2 1A          	mov al, ah
1193   0DC3 3E          	mov [d], al			; set day
1194   0DC4 79          	inc d
1195   0DC5 19 05       	mov al, 5
1196   0DC7 05 01       	syscall sys_rtc
1197   0DC9 1A          	mov al, ah
1198   0DCA 3E          	mov [d], al			; set month
1199   0DCB 79          	inc d
1200   0DCC 19 06       	mov al, 6
1201   0DCE 05 01       	syscall sys_rtc
1202   0DD0 1A          	mov al, ah
1203   0DD1 3E          	mov [d], al			; set year
1204   0DD2             ; write sector into disk for new directory entry
1205   0DD2 FD 27       	mov b, g
1206   0DD4 38 00 00    	mov c, 0
1207   0DD7 3B CB 28    	mov d, transient_area
1208   0DDA 22 01       	mov ah, $01			; disk write, 1 sector
1209   0DDC 07 3D 0B    	call IDE_write_sect		; write sector
1210   0DDF             
1211   0DDF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1212   0DDF             ; like we did above for '..', we need to now add the '.' directory to the list.
1213   0DDF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1214   0DDF E4          	pop a						; retrieve the new directory's LBA	
1215   0DE0 D7          	push a
1216   0DE1 53 01 00    	add a, 1
1217   0DE4 27          	mov b, a					; metadata sector
1218   0DE5 38 00 00    	mov c, 0
1219   0DE8 FD 79       	mov g, b					; save LBA
1220   0DEA 3B CB 28    	mov d, transient_area
1221   0DED 22 01       	mov ah, $01				; disk read
1222   0DEF 07 17 0B    	call IDE_read_sect				; read metadata sector
1223   0DF2             cmd_mkdir_L4:
1224   0DF2 BD 00       	cmp byte[d], 0
1225   0DF4 C6 FD 0D    	je cmd_mkdir_found_null4
1226   0DF7 58 20 00    	add d, FST_ENTRY_SIZE
1227   0DFA 0A F2 0D    	jmp cmd_mkdir_L4	; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1228   0DFD             cmd_mkdir_found_null4:
1229   0DFD FD 4D 33 16 	mov si, s_current_dir
1230   0E01 FD 50       	mov di, d
1231   0E03 07 A8 00    	call strcpy			; copy directory name
1232   0E06 58 18 00    	add d, 24			; goto ATTRIBUTES
1233   0E09 19 0B       	mov al, %00001011		;directory, no execute, write, read, 
1234   0E0B 3E          	mov [d], al			
1235   0E0C 79          	inc d
1236   0E0D E5          	pop b				; new directory's LBA itself. for self-referential directory entry '.'
1237   0E0E FD 43       	mov [d], b			; save LBA
1238   0E10             ; set file creation date	
1239   0E10 58 04 00    	add d, 4
1240   0E13 19 04       	mov al, 4
1241   0E15 05 01       	syscall sys_rtc
1242   0E17 1A          	mov al, ah
1243   0E18 3E          	mov [d], al			; set day
1244   0E19 79          	inc d
1245   0E1A 19 05       	mov al, 5
1246   0E1C 05 01       	syscall sys_rtc
1247   0E1E 1A          	mov al, ah
1248   0E1F 3E          	mov [d], al			; set month
1249   0E20 79          	inc d
1250   0E21 19 06       	mov al, 6
1251   0E23 05 01       	syscall sys_rtc
1252   0E25 1A          	mov al, ah
1253   0E26 3E          	mov [d], al			; set year
1254   0E27             ; write sector into disk for new directory entry
1255   0E27 FD 27       	mov b, g
1256   0E29 38 00 00    	mov c, 0
1257   0E2C 3B CB 28    	mov d, transient_area
1258   0E2F 22 01       	mov ah, $01			; disk write, 1 sector
1259   0E31 07 3D 0B    	call IDE_write_sect		; write sector
1260   0E34             cmd_mkdir_end:
1261   0E34 06          	sysret
1262   0E35             
1263   0E35             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1264   0E35             ;; get path from a given directory dirID
1265   0E35             ;; pseudo code:
1266   0E35             ;	get_path_from_dirID(int dirID, char *D){
1267   0E35             ;		if(dirID == 0){
1268   0E35             ;			reverse path in D;
1269   0E35             ;			return;
1270   0E35             ;		}
1271   0E35             ;		else{
1272   0E35             ;			copy directory name to end of D;
1273   0E35             ;			add '/' to end of D;
1274   0E35             ;			parentID = get parent directory ID;
1275   0E35             ;			get_path_from_dirID(parentID, D);
1276   0E35             ;		}
1277   0E35             ;	}
1278   0E35             ;; A = dirID
1279   0E35             ;; D = generated path string pointer
1280   0E35             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1281   0E35             ;; sample path: /usr/bin
1282   0E35             get_path_from_dirID:
1283   0E35 3B CB 1A    	mov d, filename
1284   0E38 19 00       	mov al, 0
1285   0E3A 3E          	mov [d], al				; initialize path string 
1286   0E3B 14 23 16    	mov a, [current_dirID]
1287   0E3E 07 4B 0E    	call get_path_from_dirID_E0
1288   0E41 3B CB 1A    	mov d, filename
1289   0E44 07 3C 00    	call strrev
1290   0E47 07 7B 02    	call puts
1291   0E4A 06          	sysret
1292   0E4B             get_path_from_dirID_E0:
1293   0E4B 07 6A 0E    	call get_dirname_from_dirID
1294   0E4E FD 4D 35 16 	mov si, s_fslash
1295   0E52 FD 50       	mov di, d
1296   0E54 07 B6 00    	call strcat						; add '/' to end of path
1297   0E57 AF 20 00    	cmp a, ROOT_dirID				; check if we are at the root directory
1298   0E5A C6 69 0E    	je get_path_from_dirID_root
1299   0E5D 07 87 0E    	call get_parentID_from_dirID	; use current ID (A) to find parentID (into A)
1300   0E60 AF 20 00    	cmp a, ROOT_dirID				; check if we are at the root directory
1301   0E63 C6 69 0E    	je get_path_from_dirID_root
1302   0E66 07 4B 0E    	call get_path_from_dirID_E0		; recursively call itself
1303   0E69             get_path_from_dirID_root:
1304   0E69 09          	ret
1305   0E6A             
1306   0E6A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1307   0E6A             ;; inputs:
1308   0E6A             ;; A = directory ID
1309   0E6A             ;; outputs:
1310   0E6A             ;; D = pointer to directory name string
1311   0E6A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1312   0E6A             get_dirname_from_dirID:
1313   0E6A D7          	push a
1314   0E6B D8          	push b
1315   0E6C DA          	push d
1316   0E6D 27          	mov b, a
1317   0E6E 38 00 00    	mov c, 0				; reset LBA to 0
1318   0E71 22 01       	mov ah, $01			; disk read
1319   0E73 3B CB 26    	mov d, transient_area - 512
1320   0E76 07 17 0B    	call IDE_read_sect			; read directory
1321   0E79 07 3C 00    	call strrev				; reverse dir name before copying
1322   0E7C FD 4E       	mov si, d
1323   0E7E E7          	pop d					; destination address = D value pushed at beginning
1324   0E7F FD 50       	mov di, d
1325   0E81 07 B6 00    	call strcat				; copy filename to D
1326   0E84 E5          	pop b
1327   0E85 E4          	pop a
1328   0E86 09          	ret
1329   0E87             
1330   0E87             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1331   0E87             ;; inputs:
1332   0E87             ;; A = directory ID
1333   0E87             ;; outputs:
1334   0E87             ;; A = parent directory ID
1335   0E87             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1336   0E87             get_parentID_from_dirID:
1337   0E87 D8          	push b
1338   0E88 DA          	push d
1339   0E89 27          	mov b, a
1340   0E8A 38 00 00    	mov c, 0				; reset LBA to 0
1341   0E8D 22 01       	mov ah, $01			; disk read
1342   0E8F 3B CB 26    	mov d, transient_area - 512
1343   0E92 07 17 0B    	call IDE_read_sect			; read directory
1344   0E95 16 40 00    	mov a, [d + 64]			; copy parent ID value to A
1345   0E98 E7          	pop d
1346   0E99 E5          	pop b
1347   0E9A 09          	ret
1348   0E9B             
1349   0E9B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1350   0E9B             ;; get dirID from a given path string
1351   0E9B             ;; inputs:
1352   0E9B             ;; D = path pointer 
1353   0E9B             ;; outputs:
1354   0E9B             ;; A = dirID
1355   0E9B             ;; if dir non existent, A = FFFF (fail code)
1356   0E9B             ;; /usr/local/bin		- absolute
1357   0E9B             ;; local/bin/games		- relative
1358   0E9B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1359   0E9B             get_dirID_from_path_user:
1360   0E9B FD 4E       	mov si, d
1361   0E9D FD 4F CB 1C 	mov di, temp_data
1362   0EA1 38 00 02    	mov c, 512
1363   0EA4 04          	load
1364   0EA5 07 A9 0E    	call get_dirID_from_path
1365   0EA8 06          	sysret
1366   0EA9             
1367   0EA9             get_dirID_from_path:
1368   0EA9 26 CB 1C    	mov b, temp_data
1369   0EAC FD 42 7A 06 	mov [prog], b			; token pointer set to path string
1370   0EB0 07 DB 04    	call get_token
1371   0EB3 31 7D 06    	mov bl, [tok]
1372   0EB6 C1 01       	cmp bl, TOK_FSLASH
1373   0EB8 C6 C4 0E    	je get_dirID_from_path_abs 
1374   0EBB 14 23 16    	mov a, [current_dirID]
1375   0EBE 07 61 06    	call putback
1376   0EC1 0A C7 0E    	jmp get_dirID_from_path_E0
1377   0EC4             get_dirID_from_path_abs:
1378   0EC4 10 20 00    	mov a, ROOT_dirID
1379   0EC7             get_dirID_from_path_E0:
1380   0EC7 07 DB 04    	call get_token
1381   0ECA 31 7C 06    	mov bl, [toktyp]
1382   0ECD C1 00       	cmp bl, TOKTYP_IDENTIFIER
1383   0ECF C7 20 0F    	jne get_dirID_from_path_end	; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1384   0ED2             
1385   0ED2 FD 4D 7E 06 	mov si, tokstr
1386   0ED6 FD 4F CB 1A 	mov di, filename
1387   0EDA 07 A8 00    	call strcpy				
1388   0EDD 77          	inc a					; metadata sector
1389   0EDE 27          	mov b, a
1390   0EDF 38 00 00    	mov c, 0				; reset LBA to 0
1391   0EE2 22 01       	mov ah, $01			; disk read
1392   0EE4 3B CB 28    	mov d, transient_area
1393   0EE7 07 17 0B    	call IDE_read_sect		; read directory
1394   0EEA FD 10       	cla
1395   0EEC 42 1B 16    	mov [index], a
1396   0EEF             get_dirID_from_path_L1:
1397   0EEF FD 4E       	mov si, d
1398   0EF1 FD 4F CB 1A 	mov di, filename
1399   0EF5 07 93 00    	call strcmp
1400   0EF8 C6 0E 0F    	je get_dirID_from_path_name_equal	
1401   0EFB 58 20 00    	add d, 32
1402   0EFE 14 1B 16    	mov a, [index]
1403   0F01 77          	inc a
1404   0F02 42 1B 16    	mov [index], a
1405   0F05 AF 10 00    	cmp a, FST_FILES_PER_DIR
1406   0F08 C6 21 0F    	je get_dirID_from_path_fail
1407   0F0B 0A EF 0E    	jmp get_dirID_from_path_L1
1408   0F0E             get_dirID_from_path_name_equal:
1409   0F0E 58 19 00    	add d, 25					; 
1410   0F11 15          	mov a, [d]					; set result register A = dirID
1411   0F12 07 DB 04    	call get_token
1412   0F15 31 7D 06    	mov bl, [tok]
1413   0F18 C1 01       	cmp bl, TOK_FSLASH			; check if there are more elements in the path
1414   0F1A C6 C7 0E    	je get_dirID_from_path_E0
1415   0F1D 07 61 06    	call putback
1416   0F20             get_dirID_from_path_end:
1417   0F20 09          	ret
1418   0F21             get_dirID_from_path_fail:
1419   0F21 10 FF FF    	mov A, $FFFF
1420   0F24 09          	ret
1421   0F25             
1422   0F25             
1423   0F25             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1424   0F25             ;; check if file exists by a given path string
1425   0F25             ;; inputs:
1426   0F25             ;; D = path pointer 
1427   0F25             ;; OUTPUTS:
1428   0F25             ;; A = success code, if file exists gives LBA, else, give 0
1429   0F25             ;; /usr/local/bin/ed
1430   0F25             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1431   0F25             file_exists_by_path_user:
1432   0F25 FD 4E       	mov si, d
1433   0F27 FD 4F CB 1C 	mov di, temp_data
1434   0F2B 38 00 02    	mov c, 512
1435   0F2E 04          	load
1436   0F2F 07 33 0F    	call file_exists_by_path
1437   0F32 06          	sysret
1438   0F33             file_exists_by_path:
1439   0F33 26 CB 1C    	mov b, temp_data
1440   0F36 FD 42 7A 06 	mov [prog], b			; token pointer set to path string
1441   0F3A 07 DB 04    	call get_token
1442   0F3D 31 7D 06    	mov bl, [tok]
1443   0F40 C1 01       	cmp bl, TOK_FSLASH
1444   0F42 C6 4E 0F    	je  file_exists_by_path_abs
1445   0F45 14 23 16    	mov a, [current_dirID]
1446   0F48 07 61 06    	call putback
1447   0F4B 0A 51 0F    	jmp file_exists_by_path_E0
1448   0F4E             file_exists_by_path_abs:
1449   0F4E 10 20 00    	mov a, ROOT_dirID
1450   0F51             file_exists_by_path_E0:
1451   0F51 07 DB 04    	call get_token
1452   0F54 31 7C 06    	mov bl, [toktyp]
1453   0F57 C1 00       	cmp bl, TOKTYP_IDENTIFIER
1454   0F59 C7 B1 0F    	jne file_exists_by_path_end	; check if there are tokens after '/'
1455   0F5C FD 4D 7E 06 	mov si, tokstr
1456   0F60 FD 4F CB 1A 	mov di, filename
1457   0F64 07 A8 00    	call strcpy				
1458   0F67 77          	inc a					; metadata sector
1459   0F68 27          	mov b, a
1460   0F69 38 00 00    	mov c, 0				; reset LBA to 0
1461   0F6C 22 01       	mov ah, $01			; disk read
1462   0F6E 3B CB 28    	mov d, transient_area
1463   0F71 07 17 0B    	call IDE_read_sect		; read directory
1464   0F74 FD 10       	cla
1465   0F76 42 1B 16    	mov [index], a
1466   0F79             file_exists_by_path_L1:
1467   0F79 FD 4E       	mov si, d
1468   0F7B FD 4F CB 1A 	mov di, filename
1469   0F7F 07 93 00    	call strcmp
1470   0F82 C6 98 0F    	je 	file_exists_by_path_name_equal
1471   0F85 58 20 00    	add d, 32
1472   0F88 14 1B 16    	mov a, [index]
1473   0F8B 77          	inc a
1474   0F8C 42 1B 16    	mov [index], a
1475   0F8F AF 10 00    	cmp a, FST_FILES_PER_DIR
1476   0F92 C6 B1 0F    	je file_exists_by_path_end
1477   0F95 0A 79 0F    	jmp file_exists_by_path_L1
1478   0F98             file_exists_by_path_name_equal:
1479   0F98 33 18 00    	mov bl, [d + 24]
1480   0F9B FD 87 38    	and bl, %00111000			; directory flag
1481   0F9E C1 08       	cmp bl, %00001000			; is dir?
1482   0FA0 C6 A7 0F    	je file_exists_by_path_isdir;
1483   0FA3             ; entry is a file
1484   0FA3 16 19 00    	mov a, [d + 25]			; get and return LBA of file
1485   0FA6 09          	ret
1486   0FA7             file_exists_by_path_isdir:
1487   0FA7 58 19 00    	add d, 25					; 
1488   0FAA 15          	mov a, [d]					; set result register A = dirID
1489   0FAB 07 DB 04    	call get_token
1490   0FAE 0A 51 0F    	jmp file_exists_by_path_E0
1491   0FB1             file_exists_by_path_end:
1492   0FB1 10 00 00    	mov a, 0			; return 0 because file was not found
1493   0FB4 09          	ret
1494   0FB5             
1495   0FB5             
1496   0FB5             
1497   0FB5             
1498   0FB5             
1499   0FB5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1500   0FB5             ;; load file data from a given path string
1501   0FB5             ;; inputs:
1502   0FB5             ;; D = path pointer 
1503   0FB5             ;; DI = userspace program data destination
1504   0FB5             ;; /usr/local/bin/ed
1505   0FB5             ;; ./ed
1506   0FB5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1507   0FB5             loadfile_from_path_user:
1508   0FB5 E3          	push di
1509   0FB6 FD 4E       	mov si, d
1510   0FB8 FD 4F CB 1C 	mov di, temp_data
1511   0FBC 38 00 02    	mov c, 512
1512   0FBF 04          	load
1513   0FC0 07 CD 0F    	call loadfile_from_path
1514   0FC3 F0          	pop di
1515   0FC4 FD 4D CB 28 	mov si, transient_area
1516   0FC8 38 00 3E    	mov c, 512 * (FS_SECTORS_PER_FILE-1)
1517   0FCB 03          	store
1518   0FCC 06          	sysret
1519   0FCD             loadfile_from_path:
1520   0FCD 26 CB 1C    	mov b, temp_data
1521   0FD0 FD 42 7A 06 	mov [prog], b			; token pointer set to path string
1522   0FD4 07 DB 04    	call get_token
1523   0FD7 31 7D 06    	mov bl, [tok]
1524   0FDA C1 01       	cmp bl, TOK_FSLASH
1525   0FDC C6 E8 0F    	je loadfile_from_path_abs 
1526   0FDF 14 23 16    	mov a, [current_dirID]
1527   0FE2 07 61 06    	call putback
1528   0FE5 0A EB 0F    	jmp loadfile_from_path_E0
1529   0FE8             loadfile_from_path_abs:
1530   0FE8 10 20 00    	mov a, ROOT_dirID
1531   0FEB             loadfile_from_path_E0:
1532   0FEB 07 DB 04    	call get_token
1533   0FEE 31 7C 06    	mov bl, [toktyp]
1534   0FF1 C1 00       	cmp bl, TOKTYP_IDENTIFIER
1535   0FF3 C7 58 10    	jne loadfile_from_path_end	; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1536   0FF6 FD 4D 7E 06 	mov si, tokstr
1537   0FFA FD 4F CB 1A 	mov di, filename
1538   0FFE 07 A8 00    	call strcpy				
1539   1001 77          	inc a					; metadata sector
1540   1002 27          	mov b, a
1541   1003 38 00 00    	mov c, 0				; reset LBA to 0
1542   1006 22 01       	mov ah, $01			; disk read
1543   1008 3B CB 28    	mov d, transient_area
1544   100B 07 17 0B    	call IDE_read_sect		; read directory
1545   100E FD 10       	cla
1546   1010 42 1B 16    	mov [index], a
1547   1013             loadfile_from_path_L1:
1548   1013 FD 4E       	mov si, d
1549   1015 FD 4F CB 1A 	mov di, filename
1550   1019 07 93 00    	call strcmp
1551   101C C6 32 10    	je loadfile_from_path_name_equal	
1552   101F 58 20 00    	add d, 32
1553   1022 14 1B 16    	mov a, [index]
1554   1025 77          	inc a
1555   1026 42 1B 16    	mov [index], a
1556   1029 AF 10 00    	cmp a, FST_FILES_PER_DIR
1557   102C C6 58 10    	je loadfile_from_path_end
1558   102F 0A 13 10    	jmp loadfile_from_path_L1
1559   1032             loadfile_from_path_name_equal:
1560   1032 33 18 00    	mov bl, [d + 24]
1561   1035 FD 87 38    	and bl, %00111000			; directory flag
1562   1038 C1 08       	cmp bl, %00001000			; is dir?
1563   103A C6 4E 10    	je loadfile_isdirectory	;
1564   103D             ; entry is a file
1565   103D 2B 19 00    	mov b, [d + 25]			; get LBA
1566   1040 FD 77       	inc b				; add 1 to B because the LBA for data comes after the header sector
1567   1042 3B CB 28    	mov d, transient_area
1568   1045 38 00 00    	mov c, 0
1569   1048 22 1F       	mov ah, FS_SECTORS_PER_FILE-1		; number of sectors
1570   104A 07 17 0B    	call IDE_read_sect				; read sector
1571   104D 09          	ret
1572   104E             loadfile_isdirectory:
1573   104E 58 19 00    	add d, 25					; 
1574   1051 15          	mov a, [d]					; set result register A = dirID
1575   1052 07 DB 04    	call get_token
1576   1055 0A EB 0F    	jmp loadfile_from_path_E0
1577   1058             loadfile_from_path_end:
1578   1058 09          	ret
1579   1059             
1580   1059             
1581   1059             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1582   1059             ;; return the ID of the current directory
1583   1059             ;; ID returned in B
1584   1059             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1585   1059             get_current_dirID:
1586   1059 29 23 16    	mov b, [current_dirID]
1587   105C 06          	sysret
1588   105D             
1589   105D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1590   105D             ;; CD
1591   105D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1592   105D             ; new dirID in B
1593   105D             cmd_cd:
1594   105D FD 42 23 16 	mov [current_dirID], b
1595   1061 06          	sysret	
1596   1062             
1597   1062             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1598   1062             ;; LS
1599   1062             ;; dirID in B
1600   1062             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1601   1062             cmd_ls:
1602   1062 FD 77       	inc b				; metadata sector
1603   1064 38 00 00    	mov c, 0				; reset LBA to 0
1604   1067 22 01       	mov ah, $01			; disk read
1605   1069 3B CB 28    	mov d, transient_area
1606   106C 07 17 0B    	call IDE_read_sect		; read directory
1607   106F FD 10       	cla
1608   1071 42 1B 16    	mov [index], a		; reset entry index
1609   1074             cmd_ls_L1:
1610   1074 BD 00       	cmp byte [d], 0		; check for NULL
1611   1076 C6 06 11    	je cmd_ls_next
1612   1079             cmd_ls_non_null:
1613   1079 1F 18 00    	mov al, [d + 24]
1614   107C 87 38       	and al, %00111000
1615   107E FD A2 03    	shr al, 3
1616   1081 22 00       	mov ah, 0					; file type
1617   1083 B7 40 16    	mov a, [a + file_type]			
1618   1086 23          	mov ah, al
1619   1087 07 46 01    	call putchar
1620   108A 1F 18 00    	mov al, [d + 24]
1621   108D 87 01       	and al, %00000001
1622   108F 22 00       	mov ah, 0
1623   1091 B7 3B 16    	mov a, [a + file_attrib]		; read
1624   1094 23          	mov ah, al
1625   1095 07 46 01    	call putchar
1626   1098 1F 18 00    	mov al, [d + 24]
1627   109B 87 02       	and al, %00000010
1628   109D 22 00       	mov ah, 0
1629   109F B7 3B 16    	mov a, [a + file_attrib]		; write
1630   10A2 23          	mov ah, al
1631   10A3 07 46 01    	call putchar
1632   10A6 1F 18 00    	mov al, [d + 24]
1633   10A9 87 04       	and al, %00000100
1634   10AB 22 00       	mov ah, 0
1635   10AD B7 3B 16    	mov a, [a + file_attrib]		; execute
1636   10B0 23          	mov ah, al
1637   10B1 07 46 01    	call putchar
1638   10B4 22 20       	mov ah, $20
1639   10B6 07 46 01    	call putchar	
1640   10B9 16 1B 00    	mov a, [d + 27]
1641   10BC 07 A4 02    	call print_u16d				; filesize
1642   10BF 22 20       	mov ah, $20
1643   10C1 07 46 01    	call putchar	
1644   10C4 16 19 00    	mov a, [d + 25]
1645   10C7 07 A4 02    	call print_u16d			; dirID / LBA
1646   10CA 22 20       	mov ah, $20
1647   10CC 07 46 01    	call putchar
1648   10CF             ; print date
1649   10CF 33 1D 00    	mov bl, [d + 29]			; day
1650   10D2 07 1B 03    	call print_u8x
1651   10D5 22 20       	mov ah, $20
1652   10D7 07 46 01    	call putchar	
1653   10DA 1F 1E 00    	mov al, [d + 30]			; month
1654   10DD FD 9E 02    	shl al, 2
1655   10E0 DA          	push d
1656   10E1 3B 2B 17    	mov d, s_months
1657   10E4 22 00       	mov ah, 0
1658   10E6 59          	add d, a
1659   10E7 07 7B 02    	call puts
1660   10EA E7          	pop d
1661   10EB 22 20       	mov ah, $20
1662   10ED 07 46 01    	call putchar
1663   10F0 2E 20       	mov bl, $20
1664   10F2 07 1B 03    	call print_u8x
1665   10F5 33 1F 00    	mov bl, [d + 31]			; year
1666   10F8 07 1B 03    	call print_u8x	
1667   10FB 22 20       	mov ah, $20
1668   10FD 07 46 01    	call putchar	
1669   1100 07 7B 02    	call puts				; print filename	
1670   1103 07 28 02    	call printnl
1671   1106             cmd_ls_next:
1672   1106 14 1B 16    	mov a, [index]
1673   1109 77          	inc a
1674   110A 42 1B 16    	mov [index], a
1675   110D AF 10 00    	cmp a, FST_FILES_PER_DIR
1676   1110 C6 19 11    	je cmd_ls_end
1677   1113 58 20 00    	add d, 32			
1678   1116 0A 74 10    	jmp cmd_ls_L1	
1679   1119             cmd_ls_end:
1680   1119 06          	sysret
1681   111A             
1682   111A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1683   111A             ;; pad string to 32 chars
1684   111A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1685   111A             ; count in C
1686   111A             padding:
1687   111A D7          	push a
1688   111B D8          	push b
1689   111C 10 20 00    	mov a, 32
1690   111F 28          	mov b, c
1691   1120 60          	sub a, b
1692   1121 39          	mov c, a
1693   1122             padding_L1:
1694   1122 22 20       	mov ah, $20
1695   1124 07 46 01    	call putchar
1696   1127 7E          	dec c
1697   1128 C2 00 00    	cmp c, 0
1698   112B C7 22 11    	jne padding_L1
1699   112E E5          	pop b
1700   112F E4          	pop a
1701   1130 09          	ret
1702   1131             
1703   1131             
1704   1131             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1705   1131             ;; finds an empty data block
1706   1131             ;; block LBA returned in B
1707   1131             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1708   1131             fs_find_empty_block:
1709   1131 26 A0 00    	mov b, FS_LBA_START		; raw files starting block
1710   1134 38 00 00    	mov c, 0						; reset LBA to 0
1711   1137             fs_find_empty_block_L1:	
1712   1137 22 01       	mov ah, $01			; disk read
1713   1139 3B CB 26    	mov d, transient_area - 512
1714   113C 07 17 0B    	call IDE_read_sect		; read sector
1715   113F BD 00       	cmp byte [d], 0
1716   1141 C6 4A 11    	je fs_find_empty_block_found_null
1717   1144 55 20 00    	add b, FS_SECTORS_PER_FILE
1718   1147 0A 37 11    	jmp fs_find_empty_block_L1
1719   114A             fs_find_empty_block_found_null:
1720   114A 09          	ret
1721   114B             
1722   114B             ; file structure:
1723   114B             ; 512 bytes header
1724   114B             ; header used to tell whether the block is free
1725   114B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1726   114B             ;; CREATE NEW TEXTFILE
1727   114B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1728   114B             cmd_mktxt:
1729   114B FD 4E       	mov si, d
1730   114D FD 4F CB 28 	mov di, transient_area
1731   1151 38 00 40    	mov c, FS_SECTORS_PER_FILE * 512
1732   1154 04          	load					; load data from user-space
1733   1155 07 31 11    	call fs_find_empty_block	; look for empty data blocks
1734   1158 D8          	push b				; save empty block LBA
1735   1159             ;create header file by grabbing file name from parameter	
1736   1159 3B CB 2A    	mov d, transient_area + 512			; pointer to file contents
1737   115C             	;call gettxt
1738   115C 07 83 00    	call strlen						; get length of the text file
1739   115F D9          	push c							; save length
1740   1160 19 01       	mov al, 1
1741   1162 3D CB 28    	mov [transient_area], al					; mark sectors as USED (not NULL)
1742   1165 3B CB 28    	mov d, transient_area
1743   1168             cmd_mktxt_L2:
1744   1168 38 00 00    	mov c, 0
1745   116B 22 20       	mov ah, FS_SECTORS_PER_FILE		; number of sectors to write
1746   116D 07 3D 0B    	call IDE_write_sect			; write sectors
1747   1170             ; now we add the file to the current directory!
1748   1170             cmd_mktxt_add_to_dir:	
1749   1170 14 23 16    	mov a, [current_dirID]
1750   1173 77          	inc a
1751   1174 27          	mov b, a					; metadata sector
1752   1175 38 00 00    	mov c, 0
1753   1178 FD 79       	mov g, b					; save LBA
1754   117A 3B CB 26    	mov d, transient_area - 512
1755   117D 22 01       	mov ah, $01			; disk read
1756   117F 07 17 0B    	call IDE_read_sect		; read metadata sector
1757   1182             cmd_mktxt_add_to_dir_L2:
1758   1182 BD 00       	cmp byte[d], 0
1759   1184 C6 8D 11    	je cmd_mktxt_add_to_dir_null
1760   1187 58 20 00    	add d, FST_ENTRY_SIZE
1761   118A 0A 82 11    	jmp cmd_mktxt_add_to_dir_L2		; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1762   118D             cmd_mktxt_add_to_dir_null:
1763   118D FD 4D CC 28 	mov si, transient_area + 1		; filename located after the data block 'USED' marker byte
1764   1191 FD 50       	mov di, d
1765   1193 07 A8 00    	call strcpy			; copy file name
1766   1196 58 18 00    	add d, 24			; skip name
1767   1199 19 03       	mov al, %00000011	; type=file, no execute, write, read
1768   119B 3E          	mov [d], al			
1769   119C 58 03 00    	add d, 3
1770   119F E4          	pop a
1771   11A0 43          	mov [d], a
1772   11A1 63 02 00    	sub d, 2
1773   11A4 E5          	pop b				; get file LBA
1774   11A5 FD 43       	mov [d], b			; save LBA	
1775   11A7             	
1776   11A7             	; set file creation date	
1777   11A7 58 04 00    	add d, 4
1778   11AA 19 04       	mov al, 4
1779   11AC 05 01       	syscall sys_rtc
1780   11AE 1A          	mov al, ah
1781   11AF 3E          	mov [d], al			; set day
1782   11B0             	
1783   11B0 79          	inc d
1784   11B1 19 05       	mov al, 5
1785   11B3 05 01       	syscall sys_rtc
1786   11B5 1A          	mov al, ah
1787   11B6 3E          	mov [d], al			; set month
1788   11B7             	
1789   11B7 79          	inc d
1790   11B8 19 06       	mov al, 6
1791   11BA 05 01       	syscall sys_rtc
1792   11BC 1A          	mov al, ah
1793   11BD 3E          	mov [d], al			; set year
1794   11BE             	
1795   11BE             ; write sector into disk for new directory entry
1796   11BE FD 27       	mov b, g
1797   11C0 38 00 00    	mov c, 0
1798   11C3 3B CB 26    	mov d, transient_area - 512
1799   11C6 22 01       	mov ah, $01			; disk write, 1 sector
1800   11C8 07 3D 0B    	call IDE_write_sect		; write sector
1801   11CB 06          	sysret
1802   11CC             
1803   11CC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1804   11CC             ;; CREATE NEW BINARY FILE
1805   11CC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1806   11CC             ; search for first null block
1807   11CC             cmd_mkbin:
1808   11CC FD 4E       	mov si, d
1809   11CE FD 4F CB 1C 	mov di, temp_data
1810   11D2 38 00 02    	mov c, 512
1811   11D5 04          	load					; load data from user-space
1812   11D6             	
1813   11D6 26 A0 00    	mov b, FS_LBA_START		; files start when directories end
1814   11D9 38 00 00    	mov c, 0				; reset LBA to 0
1815   11DC             cmd_mkbin_L1:	
1816   11DC 22 01       	mov ah, $01			; disk read
1817   11DE 3B CB 28    	mov d, transient_area
1818   11E1 07 17 0B    	call IDE_read_sect		; read sector
1819   11E4 BD 00       	cmp byte[d], 0			; check for NULL
1820   11E6 C6 EF 11    	je cmd_mkbin_found_null
1821   11E9 55 20 00    	add b, FS_SECTORS_PER_FILE
1822   11EC 0A DC 11    	jmp cmd_mkbin_L1
1823   11EF             cmd_mkbin_found_null:
1824   11EF D8          	push b				; save LBA
1825   11F0             ;create header file by grabbing file name from parameter
1826   11F0 FD 4F CB 2A 	mov di, transient_area + 512	; pointer to file contents
1827   11F4 07 E8 15    	call _load_hex			; load binary hex
1828   11F7 D9          	push c					; save size (nbr of bytes)
1829   11F8 19 01       	mov al, 1
1830   11FA 3D CB 28    	mov [transient_area], al		; mark sectors as USED (not NULL)
1831   11FD FD 10       	cla
1832   11FF 42 1B 16    	mov [index], a
1833   1202 3B CB 28    	mov d, transient_area
1834   1205 13          	mov a, d
1835   1206 42 1D 16    	mov [buffer_addr], a
1836   1209             cmd_mkbin_L2:
1837   1209 38 00 00    	mov c, 0
1838   120C 22 01       	mov ah, $01				; disk write, 1 sector
1839   120E 07 3D 0B    	call IDE_write_sect			; write sector
1840   1211 14 1B 16    	mov a, [index]
1841   1214 77          	inc a
1842   1215 42 1B 16    	mov [index], a
1843   1218 AF 20 00    	cmp a, FS_SECTORS_PER_FILE		; remove 1 from this because we dont count the header sector
1844   121B C6 2D 12    	je cmd_mkbin_add_to_dir
1845   121E FD 77       	inc b
1846   1220 14 1D 16    	mov a, [buffer_addr]
1847   1223 53 00 02    	add a, 512
1848   1226 42 1D 16    	mov [buffer_addr], a
1849   1229 3C          	mov d, a
1850   122A 0A 09 12    	jmp cmd_mkbin_L2
1851   122D             ; now we add the file to the current directory!
1852   122D             cmd_mkbin_add_to_dir:	
1853   122D 14 23 16    	mov a, [current_dirID]
1854   1230 77          	inc a
1855   1231 27          	mov b, a					; metadata sector
1856   1232 38 00 00    	mov c, 0
1857   1235 FD 79       	mov g, b					; save LBA
1858   1237 3B CB 28    	mov d, transient_area
1859   123A 22 01       	mov ah, $01			; disk read
1860   123C 07 17 0B    	call IDE_read_sect		; read metadata sector
1861   123F             cmd_mkbin_add_to_dir_L2:
1862   123F BD 00       	cmp byte[d], 0
1863   1241 C6 4A 12    	je cmd_mkbin_add_to_dir_null
1864   1244 58 20 00    	add d, FST_ENTRY_SIZE
1865   1247 0A 3F 12    	jmp cmd_mkbin_add_to_dir_L2		; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1866   124A             cmd_mkbin_add_to_dir_null:
1867   124A FD 4D CB 1C 	mov si, temp_data
1868   124E FD 50       	mov di, d
1869   1250 07 A8 00    	call strcpy			; copy file name
1870   1253 58 18 00    	add d, 24			; skip name
1871   1256 19 07       	mov al, %00000111		;type=file, execute, write, read, 
1872   1258 3E          	mov [d], al
1873   1259 58 03 00    	add d, 3
1874   125C E4          	pop a
1875   125D 43          	mov [d], a
1876   125E 63 02 00    	sub d, 2
1877   1261 E5          	pop b				; get file LBA
1878   1262 FD 43       	mov [d], b			; save LBA
1879   1264             	
1880   1264             	; set file creation date	
1881   1264 58 04 00    	add d, 4
1882   1267 19 04       	mov al, 4
1883   1269 05 01       	syscall sys_rtc
1884   126B 1A          	mov al, ah
1885   126C 3E          	mov [d], al			; set day
1886   126D             	
1887   126D 79          	inc d
1888   126E 19 05       	mov al, 5
1889   1270 05 01       	syscall sys_rtc
1890   1272 1A          	mov al, ah
1891   1273 3E          	mov [d], al			; set month
1892   1274             	
1893   1274 79          	inc d
1894   1275 19 06       	mov al, 6
1895   1277 05 01       	syscall sys_rtc
1896   1279 1A          	mov al, ah
1897   127A 3E          	mov [d], al			; set year
1898   127B             	
1899   127B             ; write sector into disk for new directory entry
1900   127B FD 27       	mov b, g
1901   127D 38 00 00    	mov c, 0
1902   1280 3B CB 28    	mov d, transient_area
1903   1283 22 01       	mov ah, $01			; disk write, 1 sector
1904   1285 07 3D 0B    	call IDE_write_sect		; write sector
1905   1288 06          	sysret
1906   1289             
1907   1289             			
1908   1289             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1909   1289             ;; PWD - PRINT WORKING DIRECTORY
1910   1289             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		
1911   1289             cmd_pwd:
1912   1289 3B CB 1A    	mov d, filename
1913   128C 19 00       	mov al, 0
1914   128E 3E          	mov [d], al				; initialize path string 
1915   128F 14 23 16    	mov a, [current_dirID]
1916   1292 07 4B 0E    	call get_path_from_dirID_E0
1917   1295 3B CB 1A    	mov d, filename
1918   1298 07 3C 00    	call strrev
1919   129B 07 7B 02    	call puts
1920   129E 07 28 02    	call printnl
1921   12A1 06          	sysret
1922   12A2             
1923   12A2             
1924   12A2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1925   12A2             ;; get current directory LBA
1926   12A2             ;; A: returned LBA
1927   12A2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:
1928   12A2             cmd_get_curr_dir_LBA:
1929   12A2 14 23 16    	mov a, [current_dirID]
1930   12A5 06          	sysret
1931   12A6             
1932   12A6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1933   12A6             ;; LOAD FILE INTO MEM
1934   12A6             ;; file loaded to transient_area
1935   12A6             ;; D: filename pointer
1936   12A6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:
1937   12A6             cmd_loadfile_user:
1938   12A6 FD 4E       	mov si, d
1939   12A8 FD 4F CB 1A 	mov di, filename
1940   12AC 38 00 01    	mov c, 256
1941   12AF 04          	load
1942   12B0 07 B4 12    	call cmd_loadfile
1943   12B3 06          	sysret
1944   12B4             
1945   12B4             cmd_loadfile:
1946   12B4 14 23 16    	mov a, [current_dirID]
1947   12B7 77          	inc a				; metadata sector
1948   12B8 27          	mov b, a
1949   12B9 38 00 00    	mov c, 0				; reset LBA to 0
1950   12BC 22 01       	mov ah, $01			; disk read
1951   12BE 3B CB 26    	mov d, transient_area-512
1952   12C1 07 17 0B    	call IDE_read_sect		; read directory
1953   12C4 FD 10       	cla
1954   12C6 42 1B 16    	mov [index], a		; reset file counter
1955   12C9             cmd_loadfile_L1:
1956   12C9 FD 4E       	mov si, d
1957   12CB FD 4F CB 1A 	mov di, filename
1958   12CF 07 93 00    	call strcmp
1959   12D2 C6 E8 12    	je cmd_loadfile_found_entry
1960   12D5 58 20 00    	add d, 32
1961   12D8 14 1B 16    	mov a, [index]
1962   12DB 77          	inc a
1963   12DC 42 1B 16    	mov [index], a
1964   12DF AF 10 00    	cmp a, FST_FILES_PER_DIR
1965   12E2 C6 F6 12    	je cmd_loadfile_not_found
1966   12E5 0A C9 12    	jmp cmd_loadfile_L1
1967   12E8             cmd_loadfile_found_entry:
1968   12E8 58 19 00    	add d, 25			; get to dirID of file in disk
1969   12EB 2A          	mov b, [d]			; get LBA
1970   12EC FD 77       	inc b				; add 1 to B because the LBA for data comes after the header sector
1971   12EE 3B CB 28    	mov d, transient_area
1972   12F1 22 1F       	mov ah, FS_SECTORS_PER_FILE-1		; number of sectors
1973   12F3 07 17 0B    	call IDE_read_sect				; read sector
1974   12F6             cmd_loadfile_not_found:
1975   12F6 09          	ret
1976   12F7             
1977   12F7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1978   12F7             ;; CAT
1979   12F7             ;; userspace destination data pointer in D
1980   12F7             ;; filename starts at D, but is overwritten after the read is made
1981   12F7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:
1982   12F7             cmd_cat:
1983   12F7 DA          	push d					; save userspace file data destination
1984   12F8 FD 4E       	mov si, d
1985   12FA FD 4F CB 1C 	mov di, temp_data
1986   12FE 38 00 02    	mov c, 512
1987   1301 04          	load					; copy filename from user-space
1988   1302 29 23 16    	mov b, [current_dirID]
1989   1305 FD 77       	inc b				; metadata sector
1990   1307 38 00 00    	mov c, 0				; reset LBA to 0
1991   130A 22 01       	mov ah, $01			; disk read
1992   130C 3B CB 26    	mov d, transient_area-512
1993   130F 07 17 0B    	call IDE_read_sect		; read directory
1994   1312 FD 10       	cla
1995   1314 42 1B 16    	mov [index], a		; reset file counter
1996   1317             cmd_cat_L1:
1997   1317 FD 4E       	mov si, d
1998   1319 FD 4F CB 1C 	mov di, temp_data
1999   131D 07 93 00    	call strcmp
2000   1320 C6 36 13    	je cmd_cat_found_entry
2001   1323 58 20 00    	add d, 32
2002   1326 14 1B 16    	mov a, [index]
2003   1329 77          	inc a
2004   132A 42 1B 16    	mov [index], a
2005   132D AF 10 00    	cmp a, FST_FILES_PER_DIR
2006   1330 C6 51 13    	je cmd_cat_not_found
2007   1333 0A 17 13    	jmp cmd_cat_L1
2008   1336             cmd_cat_found_entry:
2009   1336 58 19 00    	add d, 25			; get to dirID of file in disk
2010   1339 2A          	mov b, [d]			; get LBA
2011   133A FD 77       	inc b				; add 1 to B because the LBA for data comes after the header sector 
2012   133C 3B CB 28    	mov d, transient_area	
2013   133F 38 00 00    	mov c, 0
2014   1342 22 1F       	mov ah, FS_SECTORS_PER_FILE-1	; nbr sectors
2015   1344 07 17 0B    	call IDE_read_sect		; read sectors
2016   1347 F0          	pop di						; write userspace file data destination to DI
2017   1348 FD 4D CB 28 	mov si, transient_area		; data origin
2018   134C 38 00 3E    	mov c, 512*(FS_SECTORS_PER_FILE-1)
2019   134F 03          	store
2020   1350 06          	sysret
2021   1351             cmd_cat_not_found:
2022   1351 E7          	pop d
2023   1352 06          	sysret
2024   1353             
2025   1353             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2026   1353             ;; RMDIR - remove DIR by dirID
2027   1353             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2028   1353             ; deletes a directory entry in the given directory's file list 
2029   1353             ; also deletes the actual directory entry in the FST
2030   1353             ; synopsis: rmdir /usr/local/testdir
2031   1353             ; B = dirID
2032   1353             cmd_rmdir:
2033   1353 FD 79       	mov g, b
2034   1355 11          	mov a, b
2035   1356 07 87 0E    	call get_parentID_from_dirID	; now get the directory's parent, in A
2036   1359 D7          	push a						; save dirID
2037   135A             ; search for directory's entry in the parent's directory then and delete it
2038   135A 77          	inc a						; metadata sector
2039   135B 27          	mov b, a
2040   135C 38 00 00    	mov c, 0					; reset LBA to 0
2041   135F 22 01       	mov ah, $01					;
2042   1361 3B CB 28    	mov d, transient_area
2043   1364 07 17 0B    	call IDE_read_sect			; read directory
2044   1367 FD 10       	cla
2045   1369 42 1B 16    	mov [index], a				; reset file counter
2046   136C FD 27       	mov b, g					; retrieve directory's dirID
2047   136E             cmd_rmdir_L1:
2048   136E 16 19 00    	mov a, [d + 25]				; get entry's dirID/LBA value
2049   1371 B0          	cmp a, b					; compare dirID's to find the directory
2050   1372 C6 88 13    	je cmd_rmdir_found_entry
2051   1375 58 20 00    	add d, 32
2052   1378 14 1B 16    	mov a, [index]
2053   137B 77          	inc a
2054   137C 42 1B 16    	mov [index], a
2055   137F AF 10 00    	cmp a, FST_FILES_PER_DIR
2056   1382 C6 AD 13    	je cmd_rmdir_not_found
2057   1385 0A 6E 13    	jmp cmd_rmdir_L1
2058   1388             cmd_rmdir_found_entry:
2059   1388 FD 10       	cla
2060   138A 3E          	mov [d], al					; make filename NULL
2061   138B 44 19 00    	mov [d + 25], a				; clear dirID/LBA as well not to generate problems with previously deleted directories
2062   138E E5          	pop b
2063   138F FD 77       	inc b						; metadata sector
2064   1391 38 00 00    	mov c, 0					; reset LBA to 0
2065   1394 22 01       	mov ah, $01					; 
2066   1396 3B CB 28    	mov d, transient_area
2067   1399 07 3D 0B    	call IDE_write_sect			; write sector and erase file's entry in the current DIR
2068   139C             
2069   139C FD 27       	mov b, g
2070   139E 3B CB 28    	mov d, transient_area	
2071   13A1 FD 10       	cla
2072   13A3 3E          	mov [d], al					; make directory's name header NULL for re-use
2073   13A4 38 00 00    	mov c, 0
2074   13A7 22 01       	mov ah, $01					; disk write 1 sect
2075   13A9 07 3D 0B    	call IDE_write_sect			; delete directory given by dirID in B
2076   13AC 06          	sysret
2077   13AD             cmd_rmdir_not_found:
2078   13AD E5          	pop b
2079   13AE 06          	sysret
2080   13AF             
2081   13AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2082   13AF             ;; RM - remove file
2083   13AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2084   13AF             ; frees up the data sectors for the file further down the disk
2085   13AF             ; deletes file entry in the directory's file list 
2086   13AF             cmd_rm:
2087   13AF FD 4E       	mov si, d
2088   13B1 FD 4F CB 1C 	mov di, temp_data
2089   13B5 38 00 02    	mov c, 512
2090   13B8 04          	load					; load data from user-space
2091   13B9 14 23 16    	mov a, [current_dirID]
2092   13BC 77          	inc a				; metadata sector
2093   13BD 27          	mov b, a
2094   13BE 38 00 00    	mov c, 0				; reset LBA to 0
2095   13C1 22 01       	mov ah, $01			; disk read
2096   13C3 3B CB 28    	mov d, transient_area
2097   13C6 07 17 0B    	call IDE_read_sect		; read directory
2098   13C9 10 00 00    	mov a, 0
2099   13CC 42 1B 16    	mov [index], a		; reset file counter
2100   13CF             cmd_rm_L1:
2101   13CF FD 4E       	mov si, d
2102   13D1 FD 4F CB 1C 	mov di, temp_data
2103   13D5 07 93 00    	call strcmp
2104   13D8 C6 EE 13    	je cmd_rm_found_entry
2105   13DB 58 20 00    	add d, 32
2106   13DE 14 1B 16    	mov a, [index]
2107   13E1 77          	inc a
2108   13E2 42 1B 16    	mov [index], a
2109   13E5 AF 10 00    	cmp a, FST_FILES_PER_DIR
2110   13E8 C6 16 14    	je cmd_rm_not_found
2111   13EB 0A CF 13    	jmp cmd_rm_L1
2112   13EE             cmd_rm_found_entry:
2113   13EE 2B 19 00    	mov b, [d + 25]			; get LBA
2114   13F1 FD 79       	mov g, b				; save LBA
2115   13F3 19 00       	mov al, 0
2116   13F5 3E          	mov [d], al			; make file entry NULL
2117   13F6 14 23 16    	mov a, [current_dirID]
2118   13F9 77          	inc a				; metadata sector
2119   13FA 27          	mov b, a
2120   13FB 38 00 00    	mov c, 0				; reset LBA to 0
2121   13FE 22 01       	mov ah, $01			; disk write
2122   1400 3B CB 28    	mov d, transient_area
2123   1403 07 3D 0B    	call IDE_write_sect		; write sector and erase file's entry in the current DIR
2124   1406 3B CB 28    	mov d, transient_area	
2125   1409 19 00       	mov al, 0
2126   140B 3E          	mov [d], al			; make file's data header NULL for re-use
2127   140C 38 00 00    	mov c, 0
2128   140F FD 27       	mov b, g				; get data header LBA
2129   1411 22 01       	mov ah, $01					; disk write 1 sect
2130   1413 07 3D 0B    	call IDE_write_sect				; write sector
2131   1416             cmd_rm_not_found:	
2132   1416 06          	sysret	
2133   1417             
2134   1417             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2135   1417             ;; mv - move / change file name
2136   1417             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2137   1417             cmd_mv:
2138   1417 FD 4E       	mov si, d
2139   1419 FD 4F CB 1C 	mov di, temp_data
2140   141D 38 00 02    	mov c, 512
2141   1420 04          	load						; load data from user-space
2142   1421 14 23 16    	mov a, [current_dirID]
2143   1424 77          	inc a						; metadata sector
2144   1425 27          	mov b, a	
2145   1426 38 00 00    	mov c, 0					; reset LBA to 0
2146   1429 22 01       	mov ah, $01				; disk read
2147   142B 3B CB 28    	mov d, transient_area
2148   142E 07 17 0B    	call IDE_read_sect		;read directory
2149   1431 FD 10       	cla
2150   1433 42 1B 16    	mov [index], a				;reset file counter
2151   1436             cmd_mv_L1:
2152   1436 FD 4E       	mov si, d
2153   1438 FD 4F CB 1C 	mov di, temp_data
2154   143C 07 93 00    	call strcmp
2155   143F C6 55 14    	je cmd_mv_found_entry
2156   1442 58 20 00    	add d, 32
2157   1445 14 1B 16    	mov a, [index]
2158   1448 77          	inc a
2159   1449 42 1B 16    	mov [index], a
2160   144C AF 10 00    	cmp a, FST_FILES_PER_DIR
2161   144F C6 87 14    	je cmd_mv_not_found
2162   1452 0A 36 14    	jmp cmd_mv_L1
2163   1455             cmd_mv_found_entry:	
2164   1455 DA          	push d
2165   1456 FD 4D 4B 1D 	mov si, temp_data + 128	; (0...127) = original filename , (128...255) = new name
2166   145A FD 50       	mov di, d
2167   145C 07 A8 00    	call strcpy	
2168   145F 38 00 00    	mov c, 0
2169   1462 3B CB 28    	mov d, transient_area
2170   1465 22 01       	mov ah, $01					;disk write 1 sect
2171   1467 07 3D 0B    	call IDE_write_sect			;write sector
2172   146A E7          	pop d
2173   146B             ;;;;;;;; need to check whether its a dir or a file here ;;;;;;;;;;;;;;
2174   146B 2B 19 00    	mov b, [d + 25]				; get the dirID of the directory so we can locate its own entry in the list
2175   146E 22 01       	mov ah, $01
2176   1470 3B CB 28    	mov d, transient_area
2177   1473 38 00 00    	mov c, 0
2178   1476 07 17 0B    	call IDE_read_sect			; read directory entry
2179   1479 FD 4D 4B 1D 	mov si, temp_data + 128
2180   147D FD 50       	mov di, d
2181   147F 07 A8 00    	call strcpy					; change directory's name
2182   1482 22 01       	mov ah, $01
2183   1484 07 3D 0B    	call IDE_write_sect			; rewrite directory back to disk
2184   1487             cmd_mv_not_found:
2185   1487 06          	sysret
2186   1488             
2187   1488             KERNEL_RESET_VECTOR:	
2188   1488 FD 49 FF F7 	mov bp, STACK_BEGIN
2189   148C FD 47 FF F7 	mov sp, STACK_BEGIN
2190   1490             	
2191   1490 19 80       	mov al, %10000000
2192   1492 FD 0F       	stomsk					; mask out timer interrupt for now (only allow UART to interrupt)
2193   1494 FD 0C       	sti	
2194   1496             	
2195   1496             ; reset fifo pointers
2196   1496 10 CB 1E    	mov a, fifo
2197   1499 3B 1F 16    	mov d, fifo_pi
2198   149C 43          	mov [d], a
2199   149D 3B 21 16    	mov d, fifo_pr
2200   14A0 43          	mov [d], a	
2201   14A1 19 02       	mov al, 2
2202   14A3 05 03       	syscall sys_io			; enable uart in interrupt mode
2203   14A5             	
2204   14A5 3B 79 16    	mov d, s_kernel_started
2205   14A8 07 7B 02    	call puts
2206   14AB             	
2207   14AB 3B 9E 16    	mov d, s_prompt_init
2208   14AE 07 7B 02    	call puts
2209   14B1             
2210   14B1 19 10       	mov al, 16
2211   14B3 05 04       	syscall sys_fileio		; set root dirID
2212   14B5             
2213   14B5 3B 25 16    	mov d, s_init_path
2214   14B8 05 05       	syscall sys_fork		; launch init as a new process
2215   14BA             
2216   14BA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2217   14BA             ;;; Process Index in A
2218   14BA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2219   14BA             find_free_proc:
2220   14BA FD 4D BC 18 	mov si, proc_availab_table + 1			; skip process 0 (kernel)
2221   14BE             find_free_proc_L0:
2222   14BE F6          	lodsb						; get process state
2223   14BF B9 00       	cmp al, 0
2224   14C1 C6 C7 14    	je find_free_proc_free			; if free, jump
2225   14C4 0A BE 14    	jmp find_free_proc_L0			; else, goto next
2226   14C7             find_free_proc_free:
2227   14C7 4E          	mov a, si
2228   14C8 5F BC 18    	sub a, 1 + proc_availab_table				; get process index
2229   14CB 09          	ret
2230   14CC             	
2231   14CC             
2232   14CC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2233   14CC             ;;; Process Index in AL
2234   14CC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2235   14CC             proc_memory_map:
2236   14CC 22 00       	mov ah, 0
2237   14CE 27          	mov b, a			; page in BL, 0 in BH
2238   14CF FD 9D 05    	shl a, 5			; multiply by 32
2239   14D2 39          	mov c, a			; save in C
2240   14D3 57 20 00    	add c, 32
2241   14D6             proc_memory_map_L0:
2242   14D6 02          	pagemap
2243   14D7 55 00 08    	add b, $0800					; increase page number (msb 5 bits of BH only)
2244   14DA 53 01 00    	add a, 1						; increase both 
2245   14DD B1          	cmp a, c						; check to see if we reached the end of memory
2246   14DE C7 D6 14    	jne proc_memory_map_L0
2247   14E1 09          	ret
2248   14E2             	
2249   14E2             
2250   14E2             cmd_terminate_proc:
2251   14E2 51 05 00    	add sp, 5		; clear stack of the values that were pushed by the interrupt (SP, Status, PC)
2252   14E5             					; since they will not be used for anything here.
2253   14E5 1D 1A 16    	mov al, [active_proc_index]
2254   14E8 22 00       	mov ah, 0	
2255   14EA FD 9D 05    	shl a, 5						; x32
2256   14ED 53 CB 18    	add a, proc_names
2257   14F0 3C          	mov d, a
2258   14F1 19 00       	mov al, 0
2259   14F3 3E          	mov [d], al			; nullify process name
2260   14F4             
2261   14F4 1D 1A 16    	mov al, [active_proc_index]
2262   14F7 22 00       	mov ah, 0	
2263   14F9 3C          	mov d, a
2264   14FA 19 00       	mov al, 0
2265   14FC 3F BB 18    	mov [d + proc_availab_table], al					; make process empty again
2266   14FF             	
2267   14FF 1D 19 16    	mov al, [nbr_active_procs]			; decrease nbr of active processes
2268   1502 80          	dec al
2269   1503 3D 19 16    	mov [nbr_active_procs], al
2270   1506             
2271   1506             ; now load the shell process again
2272   1506 19 02       	mov al, 2				; next process = process 2 = shell
2273   1508 3D 1A 16    	mov [active_proc_index], al		; set next active proc
2274   150B             
2275   150B             ; calculate LUT entry for next process
2276   150B 22 00       	mov ah, 0
2277   150D FD 99       	shl a							; x2
2278   150F B7 D8 15    	mov a, [proc_table_convert + a]		; get process state start index	
2279   1512             	
2280   1512 4D          	mov si, a						; source is proc state block
2281   1513 48          	mov a, sp
2282   1514 5F 13 00    	sub a, 19
2283   1517 4F          	mov di, a						; destination is kernel stack
2284   1518             ; restore SP
2285   1518 7D          	dec a
2286   1519 47          	mov sp, a
2287   151A 38 14 00    	mov c, 20
2288   151D FD F5       	rep movsb
2289   151F             ; set VM process
2290   151F 1D 1A 16    	mov al, [active_proc_index]
2291   1522 01          	setptb
2292   1523             		
2293   1523 4C          	popa
2294   1524 06          	sysret
2295   1525             
2296   1525             cmd_pause_proc:
2297   1525             ; save all registers into kernel stack
2298   1525 4B          	pusha
2299   1526 22 00       	mov ah, 0
2300   1528 1D 1A 16    	mov al, [active_proc_index]
2301   152B FD 99       	shl a							; x2
2302   152D B7 D8 15    	mov a, [proc_table_convert + a]	; get process state start index
2303   1530             		
2304   1530 4F          	mov di, a
2305   1531 48          	mov a, sp
2306   1532 77          	inc a
2307   1533 4D          	mov si, a
2308   1534 38 14 00    	mov c, 20
2309   1537 FD F5       	rep movsb					; save process state!
2310   1539             ; restore kernel stack position to point before interrupt arrived
2311   1539 51 14 00    	add sp, 20
2312   153C             ; now load the shell process again
2313   153C 19 02       	mov al, 2				; next process = process 2 = shell
2314   153E 3D 1A 16    	mov [active_proc_index], al		; set next active proc
2315   1541             
2316   1541             ; calculate LUT entry for next process
2317   1541 22 00       	mov ah, 0
2318   1543 FD 99       	shl a							; x2
2319   1545 B7 D8 15    	mov a, [proc_table_convert + a]		; get process state start index	
2320   1548             	
2321   1548 4D          	mov si, a						; source is proc state block
2322   1549 48          	mov a, sp
2323   154A 5F 13 00    	sub a, 19
2324   154D 4F          	mov di, a						; destination is kernel stack
2325   154E             ; restore SP
2326   154E 7D          	dec a
2327   154F 47          	mov sp, a
2328   1550 38 14 00    	mov c, 20
2329   1553 FD F5       	rep movsb
2330   1555             ; set VM process
2331   1555 1D 1A 16    	mov al, [active_proc_index]
2332   1558 01          	setptb
2333   1559             		
2334   1559 4C          	popa
2335   155A 06          	sysret
2336   155B             
2337   155B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2338   155B             ;; fork a new process
2339   155B             ;; D = path of the process file to be forked
2340   155B             ;; B = arguments ptr
2341   155B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2342   155B             cmd_fork:
2343   155B             ; we save the active process first	
2344   155B 4B          	pusha
2345   155C 22 00       	mov ah, 0
2346   155E 1D 1A 16    	mov al, [active_proc_index]
2347   1561 FD 99       	shl a							; x2
2348   1563 B7 D8 15    	mov a, [proc_table_convert + a]		; get process state table's start index
2349   1566             	
2350   1566 4F          	mov di, a
2351   1567 48          	mov a, sp
2352   1568 77          	inc a
2353   1569 4D          	mov si, a
2354   156A 38 14 00    	mov c, 20
2355   156D FD F5       	rep movsb					; save process state!
2356   156F             ; restore kernel stack position to point before interrupt arrived
2357   156F 51 14 00    	add sp, 20
2358   1572             	
2359   1572 FD 4E       	mov si, d				; copy the file path
2360   1574 FD 4F CB 1C 	mov di, temp_data
2361   1578 38 00 02    	mov c, 512
2362   157B 04          	load
2363   157C 11          	mov a, b
2364   157D 4D          	mov si, a				; copy the arguments
2365   157E FD 4F CB 26 	mov di, scrap_sector
2366   1582 38 00 02    	mov c, 512
2367   1585 04          	load
2368   1586 07 CD 0F    	call loadfile_from_path		; load the process file from disk by path (path is in temp_data)
2369   1589             								; the file data is loaded into transient_area
2370   1589             ; now we allocate a new process	
2371   1589 07 BA 14    	call find_free_proc			; index in A
2372   158C 01          	setptb
2373   158D 07 CC 14    	call proc_memory_map			; map process memory pages
2374   1590             ; copy arguments into process's memory
2375   1590 FD 4D CB 26 	mov si, scrap_sector
2376   1594 FD 4F 00 00 	mov di, 0
2377   1598 38 00 02    	mov c, 512
2378   159B 03          	store
2379   159C             ; now copy process binary data into process's memory
2380   159C FD 4D CB 28 	mov si, transient_area
2381   15A0 FD 4F 00 04 	mov di, PROC_TEXT_ORG		; code origin address for all user processes
2382   15A4 38 00 40    	mov c, FS_FILE_SIZE			; size of memory space to copy, which is equal to the max file size in disk (for now)
2383   15A7 03          	store						; copy process data
2384   15A8             		
2385   15A8 07 BA 14    	call find_free_proc			; index in A
2386   15AB 3D 1A 16    	mov [active_proc_index], al		; set new active process
2387   15AE FD 9D 05    	shl a, 5						; x32
2388   15B1 53 CB 18    	add a, proc_names
2389   15B4 4F          	mov di, a
2390   15B5 FD 4D CB 1C 	mov si, temp_data			; copy and store process filename
2391   15B9 07 A8 00    	call strcpy
2392   15BC             	
2393   15BC 07 BA 14    	call find_free_proc			; index in A
2394   15BF 3C          	mov d, a
2395   15C0 19 01       	mov al, 1
2396   15C2 3F BB 18    	mov [d + proc_availab_table], al					; make process busy
2397   15C5             	
2398   15C5 1D 19 16    	mov al, [nbr_active_procs]			; increase nbr of active processes
2399   15C8 7A          	inc al
2400   15C9 3D 19 16    	mov [nbr_active_procs], al
2401   15CC             ; launch process
2402   15CC FD D7 FF FF 	push word $FFFF 
2403   15D0 FD DB 0E    	push byte %00001110		; dma_ack = 0, interrupts enabled = 1, mode = user, paging = on, halt=0, display_reg_load=0, dir=0
2404   15D3 FD D7 00 04 	push word PROC_TEXT_ORG
2405   15D7 06          	sysret
2406   15D8             
2407   15D8             proc_table_convert:
2408   15D8 7B 17       	.dw proc_state_table + 0
2409   15DA 8F 17       	.dw proc_state_table + 20
2410   15DC A3 17       	.dw proc_state_table + 40
2411   15DE B7 17       	.dw proc_state_table + 60
2412   15E0 CB 17       	.dw proc_state_table + 80
2413   15E2 DF 17       	.dw proc_state_table + 100
2414   15E4 F3 17       	.dw proc_state_table + 120
2415   15E6 07 18       	.dw proc_state_table + 140
2416   15E8             	
2417   15E8             ; ************************************************************
2418   15E8             ; GET HEX FILE
2419   15E8             ; di = destination address
2420   15E8             ; return length in bytes in C
2421   15E8             ; ************************************************************
2422   15E8             _load_hex:
2423   15E8 D2          	push bp
2424   15E9 9B          	mov bp, sp
2425   15EA D7          	push a
2426   15EB D8          	push b
2427   15EC DA          	push d
2428   15ED E2          	push si
2429   15EE E3          	push di
2430   15EF 52 00 60    	sub sp, $6000				; string data block
2431   15F2 38 00 00    	mov c, 0
2432   15F5 48          	mov a, sp
2433   15F6 77          	inc a
2434   15F7 3C          	mov d, a				; start of string data block
2435   15F8 07 4D 01    	call gets				; get program string
2436   15FB 4D          	mov si, a
2437   15FC             __load_hex_loop:
2438   15FC F6          	lodsb					; load from [SI] to AL
2439   15FD B9 00       	cmp al, 0				; check if ASCII 0
2440   15FF C6 0D 16    	jz __load_hex_ret
2441   1602 36          	mov bh, al
2442   1603 F6          	lodsb
2443   1604 2F          	mov bl, al
2444   1605 07 FB 00    	call atoi				; convert ASCII byte in B to int (to AL)
2445   1608 F7          	stosb					; store AL to [DI]
2446   1609 78          	inc c
2447   160A 0A FC 15    	jmp __load_hex_loop
2448   160D             __load_hex_ret:
2449   160D 51 00 60    	add sp, $6000
2450   1610 F0          	pop di
2451   1611 EF          	pop si
2452   1612 E7          	pop d
2453   1613 E5          	pop b
2454   1614 E4          	pop a
2455   1615 9C          	mov sp, bp
2456   1616 F1          	pop bp
2457   1617 09          	ret
2458   1618             
2459   1618             ; synopsis: look insIDE a certain DIRECTORY for files/directories
2460   1618             ; BEFORE CALLING THIS FUNCTION, CD INTO REQUIRED DIRECTORY
2461   1618             ; for each entry insIDE DIRECTORY:
2462   1618             ;	if entry is a file:
2463   1618             ;		compare filename to searched filename
2464   1618             ;		if filenames are the same, print filename
2465   1618             ;	else if entry is a directory:
2466   1618             ;		cd to the given directory
2467   1618             ;		recursively call cmd_find
2468   1618             ;		cd outsIDE previous directory
2469   1618             ;	if current entry == last entry, return
2470   1618             ; endfor
2471   1618             ;		
2472   1618             ;	
2473   1618             f_find:
2474   1618             	
2475   1618 09          	ret
2476   1619             
2477   1619             
2478   1619             
2479   1619 00          nbr_active_procs:	.db 0
2480   161A 01          active_proc_index:	.db 1
2481   161B             
2482   161B 00 00       index:				.dw 0
2483   161D 00 00       buffer_addr:		.dw 0
2484   161F             
2485   161F CB 1E       fifo_pi:			.dw fifo
2486   1621 CB 1E       fifo_pr:			.dw fifo
2487   1623             
2488   1623             ; file system variables
2489   1623 00 00       current_dirID:		.dw 0				; keep dirID of current directory
2490   1625 2F 73 62 69 s_init_path:		.db "/sbin/init", 0
2490   1629 6E 2F 69 6E 
2490   162D 69 74 00 
2491   1630             
2492   1630 2E 2E 00    s_parent_dir:		.db "..", 0
2493   1633 2E 00       s_current_dir:		.db ".", 0
2494   1635 2F 00       s_fslash: 			.db "/", 0
2495   1637 20 23 20 00 s_hash:				.db " # ", 0
2496   163B 2D 72 77 20 file_attrib:		.db "-rw x"			; chars at multiples of 2
2496   163F 78 
2497   1640 2D 64 63    file_type:			.db "-dc"
2498   1643 50 49 44 20 s_ps_header:		.db "PID COMMAND\n", 0
2498   1647 43 4F 4D 4D 
2498   164B 41 4E 44 0A 
2498   164F 00 
2499   1650 53 6F 6C 2D s_host: 			.db "Sol-1:", 0
2499   1654 31 3A 00 
2500   1657 53 6F 6C 2D s_uname:			.db "Sol-OS\n", 0
2500   165B 4F 53 0A 00 
2501   165F             
2502   165F 72 6F 6F 74 s_root:				.db "root\n", 0
2502   1663 0A 00 
2503   1665             
2504   1665 69 6E 74 65 s_int_en:			.db "interrupts enabled\n", 0
2504   1669 72 72 75 70 
2504   166D 74 73 20 65 
2504   1671 6E 61 62 6C 
2504   1675 65 64 0A 00 
2505   1679 6B 65 72 6E s_kernel_started:	.db "kernel started\n", 0
2505   167D 65 6C 20 73 
2505   1681 74 61 72 74 
2505   1685 65 64 0A 00 
2506   1689 65 6E 74 65 s_procname:			.db "enter process name: ", 0
2506   168D 72 20 70 72 
2506   1691 6F 63 65 73 
2506   1695 73 20 6E 61 
2506   1699 6D 65 3A 20 
2506   169D 00 
2507   169E 73 74 61 72 s_prompt_init:		.db "starting init\n", 0
2507   16A2 74 69 6E 67 
2507   16A6 20 69 6E 69 
2507   16AA 74 0A 00 
2508   16AD 0A 73 6F 66 s_priviledge:		.db "\nsoftware failure: privilege exception\n", 0
2508   16B1 74 77 61 72 
2508   16B5 65 20 66 61 
2508   16B9 69 6C 75 72 
2508   16BD 65 3A 20 70 
2508   16C1 72 69 76 69 
2508   16C5 6C 65 67 65 
2508   16C9 20 65 78 63 
2508   16CD 65 70 74 69 
2508   16D1 6F 6E 0A 00 
2509   16D5 0A 65 78 63 s_divzero:			.db "\nexception: zero division\n", 0
2509   16D9 65 70 74 69 
2509   16DD 6F 6E 3A 20 
2509   16E1 7A 65 72 6F 
2509   16E5 20 64 69 76 
2509   16E9 69 73 69 6F 
2509   16ED 6E 0A 00 
2510   16F0             
2511   16F0 59 65 61 72 s_set_year:			.db "Year: ", 0
2511   16F4 3A 20 00 
2512   16F7 4D 6F 6E 74 s_set_month:		.db "Month: ", 0
2512   16FB 68 3A 20 00 
2513   16FF 44 61 79 3A s_set_day:			.db "Day: ", 0
2513   1703 20 00 
2514   1705 57 65 65 6B s_set_week:			.db "Weekday: ", 0
2514   1709 64 61 79 3A 
2514   170D 20 00 
2515   170F 48 6F 75 72 s_set_hours:		.db "Hours: ", 0
2515   1713 73 3A 20 00 
2516   1717 4D 69 6E 75 s_set_minutes:		.db "Minutes: ", 0
2516   171B 74 65 73 3A 
2516   171F 20 00 
2517   1721 53 65 63 6F s_set_seconds:		.db "Seconds: ", 0
2517   1725 6E 64 73 3A 
2517   1729 20 00 
2518   172B 20 20 20 00 s_months:			.db "   ", 0
2519   172F 4A 61 6E 00 					.db "Jan", 0
2520   1733 46 65 62 00 					.db "Feb", 0
2521   1737 4D 61 72 00 					.db "Mar", 0
2522   173B 41 70 72 00 					.db "Apr", 0
2523   173F 4D 61 79 00 					.db "May", 0
2524   1743 4A 75 6E 00 					.db "Jun", 0
2525   1747 4A 75 6C 00 					.db "Jul", 0
2526   174B 41 75 67 00 					.db "Aug", 0
2527   174F 53 65 70 00 					.db "Sep", 0
2528   1753 4F 63 74 00 					.db "Oct", 0
2529   1757 4E 6F 76 00 					.db "Nov", 0
2530   175B 44 65 63 00 					.db "Dec", 0
2531   175F 53 75 6E 00 s_week:				.db "Sun", 0 
2532   1763 4D 6F 6E 00 					.db "Mon", 0 
2533   1767 54 75 65 00 					.db "Tue", 0 
2534   176B 57 65 64 00 					.db "Wed", 0 
2535   176F 54 68 75 00 					.db "Thu", 0 
2536   1773 46 72 69 00 					.db "Fri", 0 
2537   1777 53 61 74 00 					.db "Sat", 0
2538   177B             
2539   177B 00 00 00 00 proc_state_table:	.fill 16 * 20, 0	; for 15 processes max
2539   177F 00 00 00 00 
2539   1783 00 00 00 00 
2539   1787 00 00 00 00 
2539   178B 00 00 00 00 
2539   178F 00 00 00 00 
2539   1793 00 00 00 00 
2539   1797 00 00 00 00 
2539   179B 00 00 00 00 
2539   179F 00 00 00 00 
2539   17A3 00 00 00 00 
2539   17A7 00 00 00 00 
2539   17AB 00 00 00 00 
2539   17AF 00 00 00 00 
2539   17B3 00 00 00 00 
2539   17B7 00 00 00 00 
2539   17BB 00 00 00 00 
2539   17BF 00 00 00 00 
2539   17C3 00 00 00 00 
2539   17C7 00 00 00 00 
2539   17CB 00 00 00 00 
2539   17CF 00 00 00 00 
2539   17D3 00 00 00 00 
2539   17D7 00 00 00 00 
2539   17DB 00 00 00 00 
2539   17DF 00 00 00 00 
2539   17E3 00 00 00 00 
2539   17E7 00 00 00 00 
2539   17EB 00 00 00 00 
2539   17EF 00 00 00 00 
2539   17F3 00 00 00 00 
2539   17F7 00 00 00 00 
2539   17FB 00 00 00 00 
2539   17FF 00 00 00 00 
2539   1803 00 00 00 00 
2539   1807 00 00 00 00 
2539   180B 00 00 00 00 
2539   180F 00 00 00 00 
2539   1813 00 00 00 00 
2539   1817 00 00 00 00 
2539   181B 00 00 00 00 
2539   181F 00 00 00 00 
2539   1823 00 00 00 00 
2539   1827 00 00 00 00 
2539   182B 00 00 00 00 
2539   182F 00 00 00 00 
2539   1833 00 00 00 00 
2539   1837 00 00 00 00 
2539   183B 00 00 00 00 
2539   183F 00 00 00 00 
2539   1843 00 00 00 00 
2539   1847 00 00 00 00 
2539   184B 00 00 00 00 
2539   184F 00 00 00 00 
2539   1853 00 00 00 00 
2539   1857 00 00 00 00 
2539   185B 00 00 00 00 
2539   185F 00 00 00 00 
2539   1863 00 00 00 00 
2539   1867 00 00 00 00 
2539   186B 00 00 00 00 
2539   186F 00 00 00 00 
2539   1873 00 00 00 00 
2539   1877 00 00 00 00 
2539   187B 00 00 00 00 
2539   187F 00 00 00 00 
2539   1883 00 00 00 00 
2539   1887 00 00 00 00 
2539   188B 00 00 00 00 
2539   188F 00 00 00 00 
2539   1893 00 00 00 00 
2539   1897 00 00 00 00 
2539   189B 00 00 00 00 
2539   189F 00 00 00 00 
2539   18A3 00 00 00 00 
2539   18A7 00 00 00 00 
2539   18AB 00 00 00 00 
2539   18AF 00 00 00 00 
2539   18B3 00 00 00 00 
2539   18B7 00 00 00 00 
2540   18BB 00 00 00 00 proc_availab_table:	.fill 16, 0			; space for 15 processes. 0 = process empty, 1 = process taken
2540   18BF 00 00 00 00 
2540   18C3 00 00 00 00 
2540   18C7 00 00 00 00 
2541   18CB 00 00 00 00 proc_names:			.fill 16 * 32, 0	; process names
2541   18CF 00 00 00 00 
2541   18D3 00 00 00 00 
2541   18D7 00 00 00 00 
2541   18DB 00 00 00 00 
2541   18DF 00 00 00 00 
2541   18E3 00 00 00 00 
2541   18E7 00 00 00 00 
2541   18EB 00 00 00 00 
2541   18EF 00 00 00 00 
2541   18F3 00 00 00 00 
2541   18F7 00 00 00 00 
2541   18FB 00 00 00 00 
2541   18FF 00 00 00 00 
2541   1903 00 00 00 00 
2541   1907 00 00 00 00 
2541   190B 00 00 00 00 
2541   190F 00 00 00 00 
2541   1913 00 00 00 00 
2541   1917 00 00 00 00 
2541   191B 00 00 00 00 
2541   191F 00 00 00 00 
2541   1923 00 00 00 00 
2541   1927 00 00 00 00 
2541   192B 00 00 00 00 
2541   192F 00 00 00 00 
2541   1933 00 00 00 00 
2541   1937 00 00 00 00 
2541   193B 00 00 00 00 
2541   193F 00 00 00 00 
2541   1943 00 00 00 00 
2541   1947 00 00 00 00 
2541   194B 00 00 00 00 
2541   194F 00 00 00 00 
2541   1953 00 00 00 00 
2541   1957 00 00 00 00 
2541   195B 00 00 00 00 
2541   195F 00 00 00 00 
2541   1963 00 00 00 00 
2541   1967 00 00 00 00 
2541   196B 00 00 00 00 
2541   196F 00 00 00 00 
2541   1973 00 00 00 00 
2541   1977 00 00 00 00 
2541   197B 00 00 00 00 
2541   197F 00 00 00 00 
2541   1983 00 00 00 00 
2541   1987 00 00 00 00 
2541   198B 00 00 00 00 
2541   198F 00 00 00 00 
2541   1993 00 00 00 00 
2541   1997 00 00 00 00 
2541   199B 00 00 00 00 
2541   199F 00 00 00 00 
2541   19A3 00 00 00 00 
2541   19A7 00 00 00 00 
2541   19AB 00 00 00 00 
2541   19AF 00 00 00 00 
2541   19B3 00 00 00 00 
2541   19B7 00 00 00 00 
2541   19BB 00 00 00 00 
2541   19BF 00 00 00 00 
2541   19C3 00 00 00 00 
2541   19C7 00 00 00 00 
2541   19CB 00 00 00 00 
2541   19CF 00 00 00 00 
2541   19D3 00 00 00 00 
2541   19D7 00 00 00 00 
2541   19DB 00 00 00 00 
2541   19DF 00 00 00 00 
2541   19E3 00 00 00 00 
2541   19E7 00 00 00 00 
2541   19EB 00 00 00 00 
2541   19EF 00 00 00 00 
2541   19F3 00 00 00 00 
2541   19F7 00 00 00 00 
2541   19FB 00 00 00 00 
2541   19FF 00 00 00 00 
2541   1A03 00 00 00 00 
2541   1A07 00 00 00 00 
2541   1A0B 00 00 00 00 
2541   1A0F 00 00 00 00 
2541   1A13 00 00 00 00 
2541   1A17 00 00 00 00 
2541   1A1B 00 00 00 00 
2541   1A1F 00 00 00 00 
2541   1A23 00 00 00 00 
2541   1A27 00 00 00 00 
2541   1A2B 00 00 00 00 
2541   1A2F 00 00 00 00 
2541   1A33 00 00 00 00 
2541   1A37 00 00 00 00 
2541   1A3B 00 00 00 00 
2541   1A3F 00 00 00 00 
2541   1A43 00 00 00 00 
2541   1A47 00 00 00 00 
2541   1A4B 00 00 00 00 
2541   1A4F 00 00 00 00 
2541   1A53 00 00 00 00 
2541   1A57 00 00 00 00 
2541   1A5B 00 00 00 00 
2541   1A5F 00 00 00 00 
2541   1A63 00 00 00 00 
2541   1A67 00 00 00 00 
2541   1A6B 00 00 00 00 
2541   1A6F 00 00 00 00 
2541   1A73 00 00 00 00 
2541   1A77 00 00 00 00 
2541   1A7B 00 00 00 00 
2541   1A7F 00 00 00 00 
2541   1A83 00 00 00 00 
2541   1A87 00 00 00 00 
2541   1A8B 00 00 00 00 
2541   1A8F 00 00 00 00 
2541   1A93 00 00 00 00 
2541   1A97 00 00 00 00 
2541   1A9B 00 00 00 00 
2541   1A9F 00 00 00 00 
2541   1AA3 00 00 00 00 
2541   1AA7 00 00 00 00 
2541   1AAB 00 00 00 00 
2541   1AAF 00 00 00 00 
2541   1AB3 00 00 00 00 
2541   1AB7 00 00 00 00 
2541   1ABB 00 00 00 00 
2541   1ABF 00 00 00 00 
2541   1AC3 00 00 00 00 
2541   1AC7 00 00 00 00 
2542   1ACB 00 00 00 00 filename:			.fill 512, 0		; holds a path for file search
2542   1ACF 00 00 00 00 
2542   1AD3 00 00 00 00 
2542   1AD7 00 00 00 00 
2542   1ADB 00 00 00 00 
2542   1ADF 00 00 00 00 
2542   1AE3 00 00 00 00 
2542   1AE7 00 00 00 00 
2542   1AEB 00 00 00 00 
2542   1AEF 00 00 00 00 
2542   1AF3 00 00 00 00 
2542   1AF7 00 00 00 00 
2542   1AFB 00 00 00 00 
2542   1AFF 00 00 00 00 
2542   1B03 00 00 00 00 
2542   1B07 00 00 00 00 
2542   1B0B 00 00 00 00 
2542   1B0F 00 00 00 00 
2542   1B13 00 00 00 00 
2542   1B17 00 00 00 00 
2542   1B1B 00 00 00 00 
2542   1B1F 00 00 00 00 
2542   1B23 00 00 00 00 
2542   1B27 00 00 00 00 
2542   1B2B 00 00 00 00 
2542   1B2F 00 00 00 00 
2542   1B33 00 00 00 00 
2542   1B37 00 00 00 00 
2542   1B3B 00 00 00 00 
2542   1B3F 00 00 00 00 
2542   1B43 00 00 00 00 
2542   1B47 00 00 00 00 
2542   1B4B 00 00 00 00 
2542   1B4F 00 00 00 00 
2542   1B53 00 00 00 00 
2542   1B57 00 00 00 00 
2542   1B5B 00 00 00 00 
2542   1B5F 00 00 00 00 
2542   1B63 00 00 00 00 
2542   1B67 00 00 00 00 
2542   1B6B 00 00 00 00 
2542   1B6F 00 00 00 00 
2542   1B73 00 00 00 00 
2542   1B77 00 00 00 00 
2542   1B7B 00 00 00 00 
2542   1B7F 00 00 00 00 
2542   1B83 00 00 00 00 
2542   1B87 00 00 00 00 
2542   1B8B 00 00 00 00 
2542   1B8F 00 00 00 00 
2542   1B93 00 00 00 00 
2542   1B97 00 00 00 00 
2542   1B9B 00 00 00 00 
2542   1B9F 00 00 00 00 
2542   1BA3 00 00 00 00 
2542   1BA7 00 00 00 00 
2542   1BAB 00 00 00 00 
2542   1BAF 00 00 00 00 
2542   1BB3 00 00 00 00 
2542   1BB7 00 00 00 00 
2542   1BBB 00 00 00 00 
2542   1BBF 00 00 00 00 
2542   1BC3 00 00 00 00 
2542   1BC7 00 00 00 00 
2542   1BCB 00 00 00 00 
2542   1BCF 00 00 00 00 
2542   1BD3 00 00 00 00 
2542   1BD7 00 00 00 00 
2542   1BDB 00 00 00 00 
2542   1BDF 00 00 00 00 
2542   1BE3 00 00 00 00 
2542   1BE7 00 00 00 00 
2542   1BEB 00 00 00 00 
2542   1BEF 00 00 00 00 
2542   1BF3 00 00 00 00 
2542   1BF7 00 00 00 00 
2542   1BFB 00 00 00 00 
2542   1BFF 00 00 00 00 
2542   1C03 00 00 00 00 
2542   1C07 00 00 00 00 
2542   1C0B 00 00 00 00 
2542   1C0F 00 00 00 00 
2542   1C13 00 00 00 00 
2542   1C17 00 00 00 00 
2542   1C1B 00 00 00 00 
2542   1C1F 00 00 00 00 
2542   1C23 00 00 00 00 
2542   1C27 00 00 00 00 
2542   1C2B 00 00 00 00 
2542   1C2F 00 00 00 00 
2542   1C33 00 00 00 00 
2542   1C37 00 00 00 00 
2542   1C3B 00 00 00 00 
2542   1C3F 00 00 00 00 
2542   1C43 00 00 00 00 
2542   1C47 00 00 00 00 
2542   1C4B 00 00 00 00 
2542   1C4F 00 00 00 00 
2542   1C53 00 00 00 00 
2542   1C57 00 00 00 00 
2542   1C5B 00 00 00 00 
2542   1C5F 00 00 00 00 
2542   1C63 00 00 00 00 
2542   1C67 00 00 00 00 
2542   1C6B 00 00 00 00 
2542   1C6F 00 00 00 00 
2542   1C73 00 00 00 00 
2542   1C77 00 00 00 00 
2542   1C7B 00 00 00 00 
2542   1C7F 00 00 00 00 
2542   1C83 00 00 00 00 
2542   1C87 00 00 00 00 
2542   1C8B 00 00 00 00 
2542   1C8F 00 00 00 00 
2542   1C93 00 00 00 00 
2542   1C97 00 00 00 00 
2542   1C9B 00 00 00 00 
2542   1C9F 00 00 00 00 
2542   1CA3 00 00 00 00 
2542   1CA7 00 00 00 00 
2542   1CAB 00 00 00 00 
2542   1CAF 00 00 00 00 
2542   1CB3 00 00 00 00 
2542   1CB7 00 00 00 00 
2542   1CBB 00 00 00 00 
2542   1CBF 00 00 00 00 
2542   1CC3 00 00 00 00 
2542   1CC7 00 00 00 00 
2543   1CCB 00 00 00 00 temp_data:			.fill 512, 0   		;  user space data
2543   1CCF 00 00 00 00 
2543   1CD3 00 00 00 00 
2543   1CD7 00 00 00 00 
2543   1CDB 00 00 00 00 
2543   1CDF 00 00 00 00 
2543   1CE3 00 00 00 00 
2543   1CE7 00 00 00 00 
2543   1CEB 00 00 00 00 
2543   1CEF 00 00 00 00 
2543   1CF3 00 00 00 00 
2543   1CF7 00 00 00 00 
2543   1CFB 00 00 00 00 
2543   1CFF 00 00 00 00 
2543   1D03 00 00 00 00 
2543   1D07 00 00 00 00 
2543   1D0B 00 00 00 00 
2543   1D0F 00 00 00 00 
2543   1D13 00 00 00 00 
2543   1D17 00 00 00 00 
2543   1D1B 00 00 00 00 
2543   1D1F 00 00 00 00 
2543   1D23 00 00 00 00 
2543   1D27 00 00 00 00 
2543   1D2B 00 00 00 00 
2543   1D2F 00 00 00 00 
2543   1D33 00 00 00 00 
2543   1D37 00 00 00 00 
2543   1D3B 00 00 00 00 
2543   1D3F 00 00 00 00 
2543   1D43 00 00 00 00 
2543   1D47 00 00 00 00 
2543   1D4B 00 00 00 00 
2543   1D4F 00 00 00 00 
2543   1D53 00 00 00 00 
2543   1D57 00 00 00 00 
2543   1D5B 00 00 00 00 
2543   1D5F 00 00 00 00 
2543   1D63 00 00 00 00 
2543   1D67 00 00 00 00 
2543   1D6B 00 00 00 00 
2543   1D6F 00 00 00 00 
2543   1D73 00 00 00 00 
2543   1D77 00 00 00 00 
2543   1D7B 00 00 00 00 
2543   1D7F 00 00 00 00 
2543   1D83 00 00 00 00 
2543   1D87 00 00 00 00 
2543   1D8B 00 00 00 00 
2543   1D8F 00 00 00 00 
2543   1D93 00 00 00 00 
2543   1D97 00 00 00 00 
2543   1D9B 00 00 00 00 
2543   1D9F 00 00 00 00 
2543   1DA3 00 00 00 00 
2543   1DA7 00 00 00 00 
2543   1DAB 00 00 00 00 
2543   1DAF 00 00 00 00 
2543   1DB3 00 00 00 00 
2543   1DB7 00 00 00 00 
2543   1DBB 00 00 00 00 
2543   1DBF 00 00 00 00 
2543   1DC3 00 00 00 00 
2543   1DC7 00 00 00 00 
2543   1DCB 00 00 00 00 
2543   1DCF 00 00 00 00 
2543   1DD3 00 00 00 00 
2543   1DD7 00 00 00 00 
2543   1DDB 00 00 00 00 
2543   1DDF 00 00 00 00 
2543   1DE3 00 00 00 00 
2543   1DE7 00 00 00 00 
2543   1DEB 00 00 00 00 
2543   1DEF 00 00 00 00 
2543   1DF3 00 00 00 00 
2543   1DF7 00 00 00 00 
2543   1DFB 00 00 00 00 
2543   1DFF 00 00 00 00 
2543   1E03 00 00 00 00 
2543   1E07 00 00 00 00 
2543   1E0B 00 00 00 00 
2543   1E0F 00 00 00 00 
2543   1E13 00 00 00 00 
2543   1E17 00 00 00 00 
2543   1E1B 00 00 00 00 
2543   1E1F 00 00 00 00 
2543   1E23 00 00 00 00 
2543   1E27 00 00 00 00 
2543   1E2B 00 00 00 00 
2543   1E2F 00 00 00 00 
2543   1E33 00 00 00 00 
2543   1E37 00 00 00 00 
2543   1E3B 00 00 00 00 
2543   1E3F 00 00 00 00 
2543   1E43 00 00 00 00 
2543   1E47 00 00 00 00 
2543   1E4B 00 00 00 00 
2543   1E4F 00 00 00 00 
2543   1E53 00 00 00 00 
2543   1E57 00 00 00 00 
2543   1E5B 00 00 00 00 
2543   1E5F 00 00 00 00 
2543   1E63 00 00 00 00 
2543   1E67 00 00 00 00 
2543   1E6B 00 00 00 00 
2543   1E6F 00 00 00 00 
2543   1E73 00 00 00 00 
2543   1E77 00 00 00 00 
2543   1E7B 00 00 00 00 
2543   1E7F 00 00 00 00 
2543   1E83 00 00 00 00 
2543   1E87 00 00 00 00 
2543   1E8B 00 00 00 00 
2543   1E8F 00 00 00 00 
2543   1E93 00 00 00 00 
2543   1E97 00 00 00 00 
2543   1E9B 00 00 00 00 
2543   1E9F 00 00 00 00 
2543   1EA3 00 00 00 00 
2543   1EA7 00 00 00 00 
2543   1EAB 00 00 00 00 
2543   1EAF 00 00 00 00 
2543   1EB3 00 00 00 00 
2543   1EB7 00 00 00 00 
2543   1EBB 00 00 00 00 
2543   1EBF 00 00 00 00 
2543   1EC3 00 00 00 00 
2543   1EC7 00 00 00 00 
2544   1ECB FF FF FF FF fifo:				.fill FIFO_SIZE
2544   1ECF FF FF FF FF 
2544   1ED3 FF FF FF FF 
2544   1ED7 FF FF FF FF 
2544   1EDB FF FF FF FF 
2544   1EDF FF FF FF FF 
2544   1EE3 FF FF FF FF 
2544   1EE7 FF FF FF FF 
2544   1EEB FF FF FF FF 
2544   1EEF FF FF FF FF 
2544   1EF3 FF FF FF FF 
2544   1EF7 FF FF FF FF 
2544   1EFB FF FF FF FF 
2544   1EFF FF FF FF FF 
2544   1F03 FF FF FF FF 
2544   1F07 FF FF FF FF 
2544   1F0B FF FF FF FF 
2544   1F0F FF FF FF FF 
2544   1F13 FF FF FF FF 
2544   1F17 FF FF FF FF 
2544   1F1B FF FF FF FF 
2544   1F1F FF FF FF FF 
2544   1F23 FF FF FF FF 
2544   1F27 FF FF FF FF 
2544   1F2B FF FF FF FF 
2544   1F2F FF FF FF FF 
2544   1F33 FF FF FF FF 
2544   1F37 FF FF FF FF 
2544   1F3B FF FF FF FF 
2544   1F3F FF FF FF FF 
2544   1F43 FF FF FF FF 
2544   1F47 FF FF FF FF 
2544   1F4B FF FF FF FF 
2544   1F4F FF FF FF FF 
2544   1F53 FF FF FF FF 
2544   1F57 FF FF FF FF 
2544   1F5B FF FF FF FF 
2544   1F5F FF FF FF FF 
2544   1F63 FF FF FF FF 
2544   1F67 FF FF FF FF 
2544   1F6B FF FF FF FF 
2544   1F6F FF FF FF FF 
2544   1F73 FF FF FF FF 
2544   1F77 FF FF FF FF 
2544   1F7B FF FF FF FF 
2544   1F7F FF FF FF FF 
2544   1F83 FF FF FF FF 
2544   1F87 FF FF FF FF 
2544   1F8B FF FF FF FF 
2544   1F8F FF FF FF FF 
2544   1F93 FF FF FF FF 
2544   1F97 FF FF FF FF 
2544   1F9B FF FF FF FF 
2544   1F9F FF FF FF FF 
2544   1FA3 FF FF FF FF 
2544   1FA7 FF FF FF FF 
2544   1FAB FF FF FF FF 
2544   1FAF FF FF FF FF 
2544   1FB3 FF FF FF FF 
2544   1FB7 FF FF FF FF 
2544   1FBB FF FF FF FF 
2544   1FBF FF FF FF FF 
2544   1FC3 FF FF FF FF 
2544   1FC7 FF FF FF FF 
2544   1FCB FF FF FF FF 
2544   1FCF FF FF FF FF 
2544   1FD3 FF FF FF FF 
2544   1FD7 FF FF FF FF 
2544   1FDB FF FF FF FF 
2544   1FDF FF FF FF FF 
2544   1FE3 FF FF FF FF 
2544   1FE7 FF FF FF FF 
2544   1FEB FF FF FF FF 
2544   1FEF FF FF FF FF 
2544   1FF3 FF FF FF FF 
2544   1FF7 FF FF FF FF 
2544   1FFB FF FF FF FF 
2544   1FFF FF FF FF FF 
2544   2003 FF FF FF FF 
2544   2007 FF FF FF FF 
2544   200B FF FF FF FF 
2544   200F FF FF FF FF 
2544   2013 FF FF FF FF 
2544   2017 FF FF FF FF 
2544   201B FF FF FF FF 
2544   201F FF FF FF FF 
2544   2023 FF FF FF FF 
2544   2027 FF FF FF FF 
2544   202B FF FF FF FF 
2544   202F FF FF FF FF 
2544   2033 FF FF FF FF 
2544   2037 FF FF FF FF 
2544   203B FF FF FF FF 
2544   203F FF FF FF FF 
2544   2043 FF FF FF FF 
2544   2047 FF FF FF FF 
2544   204B FF FF FF FF 
2544   204F FF FF FF FF 
2544   2053 FF FF FF FF 
2544   2057 FF FF FF FF 
2544   205B FF FF FF FF 
2544   205F FF FF FF FF 
2544   2063 FF FF FF FF 
2544   2067 FF FF FF FF 
2544   206B FF FF FF FF 
2544   206F FF FF FF FF 
2544   2073 FF FF FF FF 
2544   2077 FF FF FF FF 
2544   207B FF FF FF FF 
2544   207F FF FF FF FF 
2544   2083 FF FF FF FF 
2544   2087 FF FF FF FF 
2544   208B FF FF FF FF 
2544   208F FF FF FF FF 
2544   2093 FF FF FF FF 
2544   2097 FF FF FF FF 
2544   209B FF FF FF FF 
2544   209F FF FF FF FF 
2544   20A3 FF FF FF FF 
2544   20A7 FF FF FF FF 
2544   20AB FF FF FF FF 
2544   20AF FF FF FF FF 
2544   20B3 FF FF FF FF 
2544   20B7 FF FF FF FF 
2544   20BB FF FF FF FF 
2544   20BF FF FF FF FF 
2544   20C3 FF FF FF FF 
2544   20C7 FF FF FF FF 
2544   20CB FF FF FF FF 
2544   20CF FF FF FF FF 
2544   20D3 FF FF FF FF 
2544   20D7 FF FF FF FF 
2544   20DB FF FF FF FF 
2544   20DF FF FF FF FF 
2544   20E3 FF FF FF FF 
2544   20E7 FF FF FF FF 
2544   20EB FF FF FF FF 
2544   20EF FF FF FF FF 
2544   20F3 FF FF FF FF 
2544   20F7 FF FF FF FF 
2544   20FB FF FF FF FF 
2544   20FF FF FF FF FF 
2544   2103 FF FF FF FF 
2544   2107 FF FF FF FF 
2544   210B FF FF FF FF 
2544   210F FF FF FF FF 
2544   2113 FF FF FF FF 
2544   2117 FF FF FF FF 
2544   211B FF FF FF FF 
2544   211F FF FF FF FF 
2544   2123 FF FF FF FF 
2544   2127 FF FF FF FF 
2544   212B FF FF FF FF 
2544   212F FF FF FF FF 
2544   2133 FF FF FF FF 
2544   2137 FF FF FF FF 
2544   213B FF FF FF FF 
2544   213F FF FF FF FF 
2544   2143 FF FF FF FF 
2544   2147 FF FF FF FF 
2544   214B FF FF FF FF 
2544   214F FF FF FF FF 
2544   2153 FF FF FF FF 
2544   2157 FF FF FF FF 
2544   215B FF FF FF FF 
2544   215F FF FF FF FF 
2544   2163 FF FF FF FF 
2544   2167 FF FF FF FF 
2544   216B FF FF FF FF 
2544   216F FF FF FF FF 
2544   2173 FF FF FF FF 
2544   2177 FF FF FF FF 
2544   217B FF FF FF FF 
2544   217F FF FF FF FF 
2544   2183 FF FF FF FF 
2544   2187 FF FF FF FF 
2544   218B FF FF FF FF 
2544   218F FF FF FF FF 
2544   2193 FF FF FF FF 
2544   2197 FF FF FF FF 
2544   219B FF FF FF FF 
2544   219F FF FF FF FF 
2544   21A3 FF FF FF FF 
2544   21A7 FF FF FF FF 
2544   21AB FF FF FF FF 
2544   21AF FF FF FF FF 
2544   21B3 FF FF FF FF 
2544   21B7 FF FF FF FF 
2544   21BB FF FF FF FF 
2544   21BF FF FF FF FF 
2544   21C3 FF FF FF FF 
2544   21C7 FF FF FF FF 
2544   21CB FF FF FF FF 
2544   21CF FF FF FF FF 
2544   21D3 FF FF FF FF 
2544   21D7 FF FF FF FF 
2544   21DB FF FF FF FF 
2544   21DF FF FF FF FF 
2544   21E3 FF FF FF FF 
2544   21E7 FF FF FF FF 
2544   21EB FF FF FF FF 
2544   21EF FF FF FF FF 
2544   21F3 FF FF FF FF 
2544   21F7 FF FF FF FF 
2544   21FB FF FF FF FF 
2544   21FF FF FF FF FF 
2544   2203 FF FF FF FF 
2544   2207 FF FF FF FF 
2544   220B FF FF FF FF 
2544   220F FF FF FF FF 
2544   2213 FF FF FF FF 
2544   2217 FF FF FF FF 
2544   221B FF FF FF FF 
2544   221F FF FF FF FF 
2544   2223 FF FF FF FF 
2544   2227 FF FF FF FF 
2544   222B FF FF FF FF 
2544   222F FF FF FF FF 
2544   2233 FF FF FF FF 
2544   2237 FF FF FF FF 
2544   223B FF FF FF FF 
2544   223F FF FF FF FF 
2544   2243 FF FF FF FF 
2544   2247 FF FF FF FF 
2544   224B FF FF FF FF 
2544   224F FF FF FF FF 
2544   2253 FF FF FF FF 
2544   2257 FF FF FF FF 
2544   225B FF FF FF FF 
2544   225F FF FF FF FF 
2544   2263 FF FF FF FF 
2544   2267 FF FF FF FF 
2544   226B FF FF FF FF 
2544   226F FF FF FF FF 
2544   2273 FF FF FF FF 
2544   2277 FF FF FF FF 
2544   227B FF FF FF FF 
2544   227F FF FF FF FF 
2544   2283 FF FF FF FF 
2544   2287 FF FF FF FF 
2544   228B FF FF FF FF 
2544   228F FF FF FF FF 
2544   2293 FF FF FF FF 
2544   2297 FF FF FF FF 
2544   229B FF FF FF FF 
2544   229F FF FF FF FF 
2544   22A3 FF FF FF FF 
2544   22A7 FF FF FF FF 
2544   22AB FF FF FF FF 
2544   22AF FF FF FF FF 
2544   22B3 FF FF FF FF 
2544   22B7 FF FF FF FF 
2544   22BB FF FF FF FF 
2544   22BF FF FF FF FF 
2544   22C3 FF FF FF FF 
2544   22C7 FF FF FF FF 
2544   22CB FF FF FF FF 
2544   22CF FF FF FF FF 
2544   22D3 FF FF FF FF 
2544   22D7 FF FF FF FF 
2544   22DB FF FF FF FF 
2544   22DF FF FF FF FF 
2544   22E3 FF FF FF FF 
2544   22E7 FF FF FF FF 
2544   22EB FF FF FF FF 
2544   22EF FF FF FF FF 
2544   22F3 FF FF FF FF 
2544   22F7 FF FF FF FF 
2544   22FB FF FF FF FF 
2544   22FF FF FF FF FF 
2544   2303 FF FF FF FF 
2544   2307 FF FF FF FF 
2544   230B FF FF FF FF 
2544   230F FF FF FF FF 
2544   2313 FF FF FF FF 
2544   2317 FF FF FF FF 
2544   231B FF FF FF FF 
2544   231F FF FF FF FF 
2544   2323 FF FF FF FF 
2544   2327 FF FF FF FF 
2544   232B FF FF FF FF 
2544   232F FF FF FF FF 
2544   2333 FF FF FF FF 
2544   2337 FF FF FF FF 
2544   233B FF FF FF FF 
2544   233F FF FF FF FF 
2544   2343 FF FF FF FF 
2544   2347 FF FF FF FF 
2544   234B FF FF FF FF 
2544   234F FF FF FF FF 
2544   2353 FF FF FF FF 
2544   2357 FF FF FF FF 
2544   235B FF FF FF FF 
2544   235F FF FF FF FF 
2544   2363 FF FF FF FF 
2544   2367 FF FF FF FF 
2544   236B FF FF FF FF 
2544   236F FF FF FF FF 
2544   2373 FF FF FF FF 
2544   2377 FF FF FF FF 
2544   237B FF FF FF FF 
2544   237F FF FF FF FF 
2544   2383 FF FF FF FF 
2544   2387 FF FF FF FF 
2544   238B FF FF FF FF 
2544   238F FF FF FF FF 
2544   2393 FF FF FF FF 
2544   2397 FF FF FF FF 
2544   239B FF FF FF FF 
2544   239F FF FF FF FF 
2544   23A3 FF FF FF FF 
2544   23A7 FF FF FF FF 
2544   23AB FF FF FF FF 
2544   23AF FF FF FF FF 
2544   23B3 FF FF FF FF 
2544   23B7 FF FF FF FF 
2544   23BB FF FF FF FF 
2544   23BF FF FF FF FF 
2544   23C3 FF FF FF FF 
2544   23C7 FF FF FF FF 
2544   23CB FF FF FF FF 
2544   23CF FF FF FF FF 
2544   23D3 FF FF FF FF 
2544   23D7 FF FF FF FF 
2544   23DB FF FF FF FF 
2544   23DF FF FF FF FF 
2544   23E3 FF FF FF FF 
2544   23E7 FF FF FF FF 
2544   23EB FF FF FF FF 
2544   23EF FF FF FF FF 
2544   23F3 FF FF FF FF 
2544   23F7 FF FF FF FF 
2544   23FB FF FF FF FF 
2544   23FF FF FF FF FF 
2544   2403 FF FF FF FF 
2544   2407 FF FF FF FF 
2544   240B FF FF FF FF 
2544   240F FF FF FF FF 
2544   2413 FF FF FF FF 
2544   2417 FF FF FF FF 
2544   241B FF FF FF FF 
2544   241F FF FF FF FF 
2544   2423 FF FF FF FF 
2544   2427 FF FF FF FF 
2544   242B FF FF FF FF 
2544   242F FF FF FF FF 
2544   2433 FF FF FF FF 
2544   2437 FF FF FF FF 
2544   243B FF FF FF FF 
2544   243F FF FF FF FF 
2544   2443 FF FF FF FF 
2544   2447 FF FF FF FF 
2544   244B FF FF FF FF 
2544   244F FF FF FF FF 
2544   2453 FF FF FF FF 
2544   2457 FF FF FF FF 
2544   245B FF FF FF FF 
2544   245F FF FF FF FF 
2544   2463 FF FF FF FF 
2544   2467 FF FF FF FF 
2544   246B FF FF FF FF 
2544   246F FF FF FF FF 
2544   2473 FF FF FF FF 
2544   2477 FF FF FF FF 
2544   247B FF FF FF FF 
2544   247F FF FF FF FF 
2544   2483 FF FF FF FF 
2544   2487 FF FF FF FF 
2544   248B FF FF FF FF 
2544   248F FF FF FF FF 
2544   2493 FF FF FF FF 
2544   2497 FF FF FF FF 
2544   249B FF FF FF FF 
2544   249F FF FF FF FF 
2544   24A3 FF FF FF FF 
2544   24A7 FF FF FF FF 
2544   24AB FF FF FF FF 
2544   24AF FF FF FF FF 
2544   24B3 FF FF FF FF 
2544   24B7 FF FF FF FF 
2544   24BB FF FF FF FF 
2544   24BF FF FF FF FF 
2544   24C3 FF FF FF FF 
2544   24C7 FF FF FF FF 
2544   24CB FF FF FF FF 
2544   24CF FF FF FF FF 
2544   24D3 FF FF FF FF 
2544   24D7 FF FF FF FF 
2544   24DB FF FF FF FF 
2544   24DF FF FF FF FF 
2544   24E3 FF FF FF FF 
2544   24E7 FF FF FF FF 
2544   24EB FF FF FF FF 
2544   24EF FF FF FF FF 
2544   24F3 FF FF FF FF 
2544   24F7 FF FF FF FF 
2544   24FB FF FF FF FF 
2544   24FF FF FF FF FF 
2544   2503 FF FF FF FF 
2544   2507 FF FF FF FF 
2544   250B FF FF FF FF 
2544   250F FF FF FF FF 
2544   2513 FF FF FF FF 
2544   2517 FF FF FF FF 
2544   251B FF FF FF FF 
2544   251F FF FF FF FF 
2544   2523 FF FF FF FF 
2544   2527 FF FF FF FF 
2544   252B FF FF FF FF 
2544   252F FF FF FF FF 
2544   2533 FF FF FF FF 
2544   2537 FF FF FF FF 
2544   253B FF FF FF FF 
2544   253F FF FF FF FF 
2544   2543 FF FF FF FF 
2544   2547 FF FF FF FF 
2544   254B FF FF FF FF 
2544   254F FF FF FF FF 
2544   2553 FF FF FF FF 
2544   2557 FF FF FF FF 
2544   255B FF FF FF FF 
2544   255F FF FF FF FF 
2544   2563 FF FF FF FF 
2544   2567 FF FF FF FF 
2544   256B FF FF FF FF 
2544   256F FF FF FF FF 
2544   2573 FF FF FF FF 
2544   2577 FF FF FF FF 
2544   257B FF FF FF FF 
2544   257F FF FF FF FF 
2544   2583 FF FF FF FF 
2544   2587 FF FF FF FF 
2544   258B FF FF FF FF 
2544   258F FF FF FF FF 
2544   2593 FF FF FF FF 
2544   2597 FF FF FF FF 
2544   259B FF FF FF FF 
2544   259F FF FF FF FF 
2544   25A3 FF FF FF FF 
2544   25A7 FF FF FF FF 
2544   25AB FF FF FF FF 
2544   25AF FF FF FF FF 
2544   25B3 FF FF FF FF 
2544   25B7 FF FF FF FF 
2544   25BB FF FF FF FF 
2544   25BF FF FF FF FF 
2544   25C3 FF FF FF FF 
2544   25C7 FF FF FF FF 
2544   25CB FF FF FF FF 
2544   25CF FF FF FF FF 
2544   25D3 FF FF FF FF 
2544   25D7 FF FF FF FF 
2544   25DB FF FF FF FF 
2544   25DF FF FF FF FF 
2544   25E3 FF FF FF FF 
2544   25E7 FF FF FF FF 
2544   25EB FF FF FF FF 
2544   25EF FF FF FF FF 
2544   25F3 FF FF FF FF 
2544   25F7 FF FF FF FF 
2544   25FB FF FF FF FF 
2544   25FF FF FF FF FF 
2544   2603 FF FF FF FF 
2544   2607 FF FF FF FF 
2544   260B FF FF FF FF 
2544   260F FF FF FF FF 
2544   2613 FF FF FF FF 
2544   2617 FF FF FF FF 
2544   261B FF FF FF FF 
2544   261F FF FF FF FF 
2544   2623 FF FF FF FF 
2544   2627 FF FF FF FF 
2544   262B FF FF FF FF 
2544   262F FF FF FF FF 
2544   2633 FF FF FF FF 
2544   2637 FF FF FF FF 
2544   263B FF FF FF FF 
2544   263F FF FF FF FF 
2544   2643 FF FF FF FF 
2544   2647 FF FF FF FF 
2544   264B FF FF FF FF 
2544   264F FF FF FF FF 
2544   2653 FF FF FF FF 
2544   2657 FF FF FF FF 
2544   265B FF FF FF FF 
2544   265F FF FF FF FF 
2544   2663 FF FF FF FF 
2544   2667 FF FF FF FF 
2544   266B FF FF FF FF 
2544   266F FF FF FF FF 
2544   2673 FF FF FF FF 
2544   2677 FF FF FF FF 
2544   267B FF FF FF FF 
2544   267F FF FF FF FF 
2544   2683 FF FF FF FF 
2544   2687 FF FF FF FF 
2544   268B FF FF FF FF 
2544   268F FF FF FF FF 
2544   2693 FF FF FF FF 
2544   2697 FF FF FF FF 
2544   269B FF FF FF FF 
2544   269F FF FF FF FF 
2544   26A3 FF FF FF FF 
2544   26A7 FF FF FF FF 
2544   26AB FF FF FF FF 
2544   26AF FF FF FF FF 
2544   26B3 FF FF FF FF 
2544   26B7 FF FF FF FF 
2544   26BB FF FF FF FF 
2544   26BF FF FF FF FF 
2544   26C3 FF FF FF FF 
2544   26C7 FF FF FF FF 
2545   26CB             
2546   26CB FF FF FF FF scrap_sector:		.fill 512		; scrap sector
2546   26CF FF FF FF FF 
2546   26D3 FF FF FF FF 
2546   26D7 FF FF FF FF 
2546   26DB FF FF FF FF 
2546   26DF FF FF FF FF 
2546   26E3 FF FF FF FF 
2546   26E7 FF FF FF FF 
2546   26EB FF FF FF FF 
2546   26EF FF FF FF FF 
2546   26F3 FF FF FF FF 
2546   26F7 FF FF FF FF 
2546   26FB FF FF FF FF 
2546   26FF FF FF FF FF 
2546   2703 FF FF FF FF 
2546   2707 FF FF FF FF 
2546   270B FF FF FF FF 
2546   270F FF FF FF FF 
2546   2713 FF FF FF FF 
2546   2717 FF FF FF FF 
2546   271B FF FF FF FF 
2546   271F FF FF FF FF 
2546   2723 FF FF FF FF 
2546   2727 FF FF FF FF 
2546   272B FF FF FF FF 
2546   272F FF FF FF FF 
2546   2733 FF FF FF FF 
2546   2737 FF FF FF FF 
2546   273B FF FF FF FF 
2546   273F FF FF FF FF 
2546   2743 FF FF FF FF 
2546   2747 FF FF FF FF 
2546   274B FF FF FF FF 
2546   274F FF FF FF FF 
2546   2753 FF FF FF FF 
2546   2757 FF FF FF FF 
2546   275B FF FF FF FF 
2546   275F FF FF FF FF 
2546   2763 FF FF FF FF 
2546   2767 FF FF FF FF 
2546   276B FF FF FF FF 
2546   276F FF FF FF FF 
2546   2773 FF FF FF FF 
2546   2777 FF FF FF FF 
2546   277B FF FF FF FF 
2546   277F FF FF FF FF 
2546   2783 FF FF FF FF 
2546   2787 FF FF FF FF 
2546   278B FF FF FF FF 
2546   278F FF FF FF FF 
2546   2793 FF FF FF FF 
2546   2797 FF FF FF FF 
2546   279B FF FF FF FF 
2546   279F FF FF FF FF 
2546   27A3 FF FF FF FF 
2546   27A7 FF FF FF FF 
2546   27AB FF FF FF FF 
2546   27AF FF FF FF FF 
2546   27B3 FF FF FF FF 
2546   27B7 FF FF FF FF 
2546   27BB FF FF FF FF 
2546   27BF FF FF FF FF 
2546   27C3 FF FF FF FF 
2546   27C7 FF FF FF FF 
2546   27CB FF FF FF FF 
2546   27CF FF FF FF FF 
2546   27D3 FF FF FF FF 
2546   27D7 FF FF FF FF 
2546   27DB FF FF FF FF 
2546   27DF FF FF FF FF 
2546   27E3 FF FF FF FF 
2546   27E7 FF FF FF FF 
2546   27EB FF FF FF FF 
2546   27EF FF FF FF FF 
2546   27F3 FF FF FF FF 
2546   27F7 FF FF FF FF 
2546   27FB FF FF FF FF 
2546   27FF FF FF FF FF 
2546   2803 FF FF FF FF 
2546   2807 FF FF FF FF 
2546   280B FF FF FF FF 
2546   280F FF FF FF FF 
2546   2813 FF FF FF FF 
2546   2817 FF FF FF FF 
2546   281B FF FF FF FF 
2546   281F FF FF FF FF 
2546   2823 FF FF FF FF 
2546   2827 FF FF FF FF 
2546   282B FF FF FF FF 
2546   282F FF FF FF FF 
2546   2833 FF FF FF FF 
2546   2837 FF FF FF FF 
2546   283B FF FF FF FF 
2546   283F FF FF FF FF 
2546   2843 FF FF FF FF 
2546   2847 FF FF FF FF 
2546   284B FF FF FF FF 
2546   284F FF FF FF FF 
2546   2853 FF FF FF FF 
2546   2857 FF FF FF FF 
2546   285B FF FF FF FF 
2546   285F FF FF FF FF 
2546   2863 FF FF FF FF 
2546   2867 FF FF FF FF 
2546   286B FF FF FF FF 
2546   286F FF FF FF FF 
2546   2873 FF FF FF FF 
2546   2877 FF FF FF FF 
2546   287B FF FF FF FF 
2546   287F FF FF FF FF 
2546   2883 FF FF FF FF 
2546   2887 FF FF FF FF 
2546   288B FF FF FF FF 
2546   288F FF FF FF FF 
2546   2893 FF FF FF FF 
2546   2897 FF FF FF FF 
2546   289B FF FF FF FF 
2546   289F FF FF FF FF 
2546   28A3 FF FF FF FF 
2546   28A7 FF FF FF FF 
2546   28AB FF FF FF FF 
2546   28AF FF FF FF FF 
2546   28B3 FF FF FF FF 
2546   28B7 FF FF FF FF 
2546   28BB FF FF FF FF 
2546   28BF FF FF FF FF 
2546   28C3 FF FF FF FF 
2546   28C7 FF FF FF FF 
2547   28CB 00          transient_area:		.db 0			; beginning of the transient memory area. used for disk reads and other purposes		
2548   28CC             
2549   28CC             
2550   28CC             .end
tasm: Number of errors = 0
