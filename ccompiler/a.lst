0001   0000             ; --- FILENAME: ivosol1d.c
0002   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0400             .org PROC_TEXT_ORG
0004   0400             
0005   0400             ; --- BEGIN TEXT BLOCK
0006   0400             main:
0007   0400 D2            push bp
0008   0401 9B            mov bp, sp
0009   0402             _while1_cond:
0010   0402 29 23 12      mov b, [exitflag]
0011   0405 D7            push a
0012   0406 11            mov a, b
0013   0407 26 00 00      mov b, 0
0014   040A B0            cmp a, b
0015   040B 0E            lodflgs
0016   040C 87 01         and al, %00000001 ; ==
0017   040E B9 00         cmp al, 0
0018   0410 0E            lodflgs
0019   0411 96            not al
0020   0412 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0021   0414 22 00         mov ah, 0
0022   0416 27            mov b, a
0023   0417 E4            pop a
0024   0418 C0 00 00      cmp b, 0
0025   041B C6 FA 0F      je _while1_exit
0026   041E             _while1_block:
0027   041E 26 10 0E      mov b, 3600
0028   0421 FD 42 21 12   mov [runlimit], b
0029   0425             _while2_cond:
0030   0425 26 01 00      mov b, 1
0031   0428 C0 00 00      cmp b, 0
0032   042B C6 A8 07      je _while2_exit
0033   042E             _while2_block:
0034   042E 26 00 00      mov b, 0
0035   0431 FD 42 13 12   mov [pc], b
0036   0435 26 18 30      mov b, 12312
0037   0438 FD AB         swp b
0038   043A D8            push b
0039   043B 07 0A 10      call displaynumber
0040   043E 51 02 00      add sp, 2
0041   0441 07 FA 0F      call readint
0042   0444 FD 42 09 12   mov [cmdadr], b
0043   0448             _if3_cond:
0044   0448 29 09 12      mov b, [cmdadr]
0045   044B D7            push a
0046   044C 11            mov a, b
0047   044D 26 1E 00      mov b, 30
0048   0450 B0            cmp a, b
0049   0451 0E            lodflgs
0050   0452 87 03         and al, %00000011 ; <=
0051   0454 B9 00         cmp al, 0
0052   0456 0E            lodflgs
0053   0457 96            not al
0054   0458 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0055   045A 22 00         mov ah, 0
0056   045C 27            mov b, a
0057   045D E4            pop a
0058   045E C0 00 00      cmp b, 0
0059   0461 C6 63 05      je _if3_else
0060   0464             _if3_true:
0061   0464 07 FA 0F      call readint
0062   0467 FD 42 0B 12   mov [opr], b
0063   046B 07 FA 0F      call readint
0064   046E FD 42 0D 12   mov [datadr1], b
0065   0472 07 FA 0F      call readint
0066   0475 FD 42 0F 12   mov [datadr2], b
0067   0479 07 FA 0F      call readint
0068   047C FD 42 11 12   mov [datadr3], b
0069   0480 29 07 12      mov b, [instruction]
0070   0483 74            mov d, b
0071   0484 DA            push d
0072   0485 29 09 12      mov b, [cmdadr]
0073   0488 D7            push a
0074   0489 11            mov a, b
0075   048A 26 04 00      mov b, 4
0076   048D AC            mul a, b
0077   048E E4            pop a
0078   048F E7            pop d
0079   0490 10 02 00      mov a, 2
0080   0493 AC            mul a, b
0081   0494 5A            add d, b
0082   0495 DA            push d
0083   0496 29 0B 12      mov b, [opr]
0084   0499 E7            pop d
0085   049A 11            mov a, b
0086   049B 43            mov [d], a
0087   049C 29 07 12      mov b, [instruction]
0088   049F 74            mov d, b
0089   04A0 DA            push d
0090   04A1 29 09 12      mov b, [cmdadr]
0091   04A4 D7            push a
0092   04A5 11            mov a, b
0093   04A6 26 04 00      mov b, 4
0094   04A9 AC            mul a, b
0095   04AA 11            mov a, b
0096   04AB 26 01 00      mov b, 1
0097   04AE 54            add a, b
0098   04AF 27            mov b, a
0099   04B0 E4            pop a
0100   04B1 E7            pop d
0101   04B2 10 02 00      mov a, 2
0102   04B5 AC            mul a, b
0103   04B6 5A            add d, b
0104   04B7 DA            push d
0105   04B8 29 0D 12      mov b, [datadr1]
0106   04BB E7            pop d
0107   04BC 11            mov a, b
0108   04BD 43            mov [d], a
0109   04BE 29 07 12      mov b, [instruction]
0110   04C1 74            mov d, b
0111   04C2 DA            push d
0112   04C3 29 09 12      mov b, [cmdadr]
0113   04C6 D7            push a
0114   04C7 11            mov a, b
0115   04C8 26 04 00      mov b, 4
0116   04CB AC            mul a, b
0117   04CC 11            mov a, b
0118   04CD 26 02 00      mov b, 2
0119   04D0 54            add a, b
0120   04D1 27            mov b, a
0121   04D2 E4            pop a
0122   04D3 E7            pop d
0123   04D4 10 02 00      mov a, 2
0124   04D7 AC            mul a, b
0125   04D8 5A            add d, b
0126   04D9 DA            push d
0127   04DA 29 0F 12      mov b, [datadr2]
0128   04DD E7            pop d
0129   04DE 11            mov a, b
0130   04DF 43            mov [d], a
0131   04E0 29 07 12      mov b, [instruction]
0132   04E3 74            mov d, b
0133   04E4 DA            push d
0134   04E5 29 09 12      mov b, [cmdadr]
0135   04E8 D7            push a
0136   04E9 11            mov a, b
0137   04EA 26 04 00      mov b, 4
0138   04ED AC            mul a, b
0139   04EE 11            mov a, b
0140   04EF 26 03 00      mov b, 3
0141   04F2 54            add a, b
0142   04F3 27            mov b, a
0143   04F4 E4            pop a
0144   04F5 E7            pop d
0145   04F6 10 02 00      mov a, 2
0146   04F9 AC            mul a, b
0147   04FA 5A            add d, b
0148   04FB DA            push d
0149   04FC 29 11 12      mov b, [datadr3]
0150   04FF E7            pop d
0151   0500 11            mov a, b
0152   0501 43            mov [d], a
0153   0502 29 09 12      mov b, [cmdadr]
0154   0505 FD AB         swp b
0155   0507 D8            push b
0156   0508 07 0A 10      call displaynumber
0157   050B 51 02 00      add sp, 2
0158   050E 29 0B 12      mov b, [opr]
0159   0511 FD AB         swp b
0160   0513 D8            push b
0161   0514 07 0A 10      call displaynumber
0162   0517 51 02 00      add sp, 2
0163   051A 29 0D 12      mov b, [datadr1]
0164   051D FD AB         swp b
0165   051F D8            push b
0166   0520 07 0A 10      call displaynumber
0167   0523 51 02 00      add sp, 2
0168   0526 29 0F 12      mov b, [datadr2]
0169   0529 FD AB         swp b
0170   052B D8            push b
0171   052C 07 0A 10      call displaynumber
0172   052F 51 02 00      add sp, 2
0173   0532 29 11 12      mov b, [datadr3]
0174   0535 FD AB         swp b
0175   0537 D8            push b
0176   0538 07 0A 10      call displaynumber
0177   053B 51 02 00      add sp, 2
0178   053E             _if4_cond:
0179   053E 29 09 12      mov b, [cmdadr]
0180   0541 D7            push a
0181   0542 11            mov a, b
0182   0543 26 00 00      mov b, 0
0183   0546 B0            cmp a, b
0184   0547 0E            lodflgs
0185   0548 87 01         and al, %00000001 ; ==
0186   054A B9 00         cmp al, 0
0187   054C 0E            lodflgs
0188   054D 96            not al
0189   054E 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0190   0550 22 00         mov ah, 0
0191   0552 27            mov b, a
0192   0553 E4            pop a
0193   0554 C0 00 00      cmp b, 0
0194   0557 C6 60 05      je _if4_exit
0195   055A             _if4_true:
0196   055A 0A A8 07      jmp _while2_exit ; while break
0197   055D 0A 60 05      jmp _if4_exit
0198   0560             _if4_exit:
0199   0560 0A A5 07      jmp _if3_exit
0200   0563             _if3_else:
0201   0563             _if5_cond:
0202   0563 29 09 12      mov b, [cmdadr]
0203   0566 D7            push a
0204   0567 11            mov a, b
0205   0568 26 57 04      mov b, 1111
0206   056B B0            cmp a, b
0207   056C 0E            lodflgs
0208   056D 87 01         and al, %00000001 ; ==
0209   056F B9 00         cmp al, 0
0210   0571 0E            lodflgs
0211   0572 96            not al
0212   0573 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0213   0575 22 00         mov ah, 0
0214   0577 27            mov b, a
0215   0578 E4            pop a
0216   0579 C0 00 00      cmp b, 0
0217   057C C6 1F 06      je _if5_else
0218   057F             _if5_true:
0219   057F 07 FA 0F      call readint
0220   0582 FD 42 17 12   mov [i], b
0221   0586 29 07 12      mov b, [instruction]
0222   0589 D7            push a
0223   058A 74            mov d, b
0224   058B DA            push d
0225   058C 29 17 12      mov b, [i]
0226   058F D7            push a
0227   0590 11            mov a, b
0228   0591 26 04 00      mov b, 4
0229   0594 AC            mul a, b
0230   0595 E4            pop a
0231   0596 E7            pop d
0232   0597 10 02 00      mov a, 2
0233   059A AC            mul a, b
0234   059B 5A            add d, b
0235   059C 2A            mov b, [d]
0236   059D E4            pop a
0237   059E FD AB         swp b
0238   05A0 D8            push b
0239   05A1 07 0A 10      call displaynumber
0240   05A4 51 02 00      add sp, 2
0241   05A7 29 07 12      mov b, [instruction]
0242   05AA D7            push a
0243   05AB 74            mov d, b
0244   05AC DA            push d
0245   05AD 29 17 12      mov b, [i]
0246   05B0 D7            push a
0247   05B1 11            mov a, b
0248   05B2 26 04 00      mov b, 4
0249   05B5 AC            mul a, b
0250   05B6 11            mov a, b
0251   05B7 26 01 00      mov b, 1
0252   05BA 54            add a, b
0253   05BB 27            mov b, a
0254   05BC E4            pop a
0255   05BD E7            pop d
0256   05BE 10 02 00      mov a, 2
0257   05C1 AC            mul a, b
0258   05C2 5A            add d, b
0259   05C3 2A            mov b, [d]
0260   05C4 E4            pop a
0261   05C5 FD AB         swp b
0262   05C7 D8            push b
0263   05C8 07 0A 10      call displaynumber
0264   05CB 51 02 00      add sp, 2
0265   05CE 29 07 12      mov b, [instruction]
0266   05D1 D7            push a
0267   05D2 74            mov d, b
0268   05D3 DA            push d
0269   05D4 29 17 12      mov b, [i]
0270   05D7 D7            push a
0271   05D8 11            mov a, b
0272   05D9 26 04 00      mov b, 4
0273   05DC AC            mul a, b
0274   05DD 11            mov a, b
0275   05DE 26 02 00      mov b, 2
0276   05E1 54            add a, b
0277   05E2 27            mov b, a
0278   05E3 E4            pop a
0279   05E4 E7            pop d
0280   05E5 10 02 00      mov a, 2
0281   05E8 AC            mul a, b
0282   05E9 5A            add d, b
0283   05EA 2A            mov b, [d]
0284   05EB E4            pop a
0285   05EC FD AB         swp b
0286   05EE D8            push b
0287   05EF 07 0A 10      call displaynumber
0288   05F2 51 02 00      add sp, 2
0289   05F5 29 07 12      mov b, [instruction]
0290   05F8 D7            push a
0291   05F9 74            mov d, b
0292   05FA DA            push d
0293   05FB 29 17 12      mov b, [i]
0294   05FE D7            push a
0295   05FF 11            mov a, b
0296   0600 26 04 00      mov b, 4
0297   0603 AC            mul a, b
0298   0604 11            mov a, b
0299   0605 26 03 00      mov b, 3
0300   0608 54            add a, b
0301   0609 27            mov b, a
0302   060A E4            pop a
0303   060B E7            pop d
0304   060C 10 02 00      mov a, 2
0305   060F AC            mul a, b
0306   0610 5A            add d, b
0307   0611 2A            mov b, [d]
0308   0612 E4            pop a
0309   0613 FD AB         swp b
0310   0615 D8            push b
0311   0616 07 0A 10      call displaynumber
0312   0619 51 02 00      add sp, 2
0313   061C 0A A5 07      jmp _if5_exit
0314   061F             _if5_else:
0315   061F             _if6_cond:
0316   061F 29 09 12      mov b, [cmdadr]
0317   0622 D7            push a
0318   0623 11            mov a, b
0319   0624 26 AE 08      mov b, 2222
0320   0627 B0            cmp a, b
0321   0628 0E            lodflgs
0322   0629 87 01         and al, %00000001 ; ==
0323   062B B9 00         cmp al, 0
0324   062D 0E            lodflgs
0325   062E 96            not al
0326   062F 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0327   0631 22 00         mov ah, 0
0328   0633 27            mov b, a
0329   0634 E4            pop a
0330   0635 C0 00 00      cmp b, 0
0331   0638 C6 5F 06      je _if6_else
0332   063B             _if6_true:
0333   063B 07 FA 0F      call readint
0334   063E FD 42 17 12   mov [i], b
0335   0642 29 15 11      mov b, [datum]
0336   0645 D7            push a
0337   0646 74            mov d, b
0338   0647 DA            push d
0339   0648 29 17 12      mov b, [i]
0340   064B E7            pop d
0341   064C 10 02 00      mov a, 2
0342   064F AC            mul a, b
0343   0650 5A            add d, b
0344   0651 2A            mov b, [d]
0345   0652 E4            pop a
0346   0653 FD AB         swp b
0347   0655 D8            push b
0348   0656 07 0A 10      call displaynumber
0349   0659 51 02 00      add sp, 2
0350   065C 0A A5 07      jmp _if6_exit
0351   065F             _if6_else:
0352   065F             _if7_cond:
0353   065F 29 09 12      mov b, [cmdadr]
0354   0662 D7            push a
0355   0663 11            mov a, b
0356   0664 26 5C 11      mov b, 4444
0357   0667 B0            cmp a, b
0358   0668 0E            lodflgs
0359   0669 87 01         and al, %00000001 ; ==
0360   066B B9 00         cmp al, 0
0361   066D 0E            lodflgs
0362   066E 96            not al
0363   066F 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0364   0671 22 00         mov ah, 0
0365   0673 27            mov b, a
0366   0674 E4            pop a
0367   0675 C0 00 00      cmp b, 0
0368   0678 C6 93 06      je _if7_else
0369   067B             _if7_true:
0370   067B 29 15 11      mov b, [datum]
0371   067E 74            mov d, b
0372   067F DA            push d
0373   0680 07 FA 0F      call readint
0374   0683 E7            pop d
0375   0684 10 02 00      mov a, 2
0376   0687 AC            mul a, b
0377   0688 5A            add d, b
0378   0689 DA            push d
0379   068A 07 FA 0F      call readint
0380   068D E7            pop d
0381   068E 11            mov a, b
0382   068F 43            mov [d], a
0383   0690 0A A5 07      jmp _if7_exit
0384   0693             _if7_else:
0385   0693             _if8_cond:
0386   0693 29 09 12      mov b, [cmdadr]
0387   0696 D7            push a
0388   0697 11            mov a, b
0389   0698 26 B3 15      mov b, 5555
0390   069B B0            cmp a, b
0391   069C 0E            lodflgs
0392   069D 87 01         and al, %00000001 ; ==
0393   069F B9 00         cmp al, 0
0394   06A1 0E            lodflgs
0395   06A2 96            not al
0396   06A3 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0397   06A5 22 00         mov ah, 0
0398   06A7 27            mov b, a
0399   06A8 E4            pop a
0400   06A9 C0 00 00      cmp b, 0
0401   06AC C6 F6 06      je _if8_else
0402   06AF             _if8_true:
0403   06AF             _for9_init:
0404   06AF 26 00 00      mov b, 0
0405   06B2 FD 42 17 12   mov [i], b
0406   06B6             _for9_cond:
0407   06B6 29 17 12      mov b, [i]
0408   06B9 D7            push a
0409   06BA 11            mov a, b
0410   06BB 26 1E 00      mov b, 30
0411   06BE B0            cmp a, b
0412   06BF 0E            lodflgs
0413   06C0 87 02         and al, %00000010 ; <
0414   06C2 B9 00         cmp al, 0
0415   06C4 0E            lodflgs
0416   06C5 96            not al
0417   06C6 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0418   06C8 22 00         mov ah, 0
0419   06CA 27            mov b, a
0420   06CB E4            pop a
0421   06CC C0 00 00      cmp b, 0
0422   06CF C6 F3 06      je _for9_exit
0423   06D2             _for9_block:
0424   06D2 29 07 12      mov b, [instruction]
0425   06D5 74            mov d, b
0426   06D6 DA            push d
0427   06D7 29 17 12      mov b, [i]
0428   06DA E7            pop d
0429   06DB 10 02 00      mov a, 2
0430   06DE AC            mul a, b
0431   06DF 5A            add d, b
0432   06E0 DA            push d
0433   06E1 26 00 00      mov b, 0
0434   06E4 E7            pop d
0435   06E5 11            mov a, b
0436   06E6 43            mov [d], a
0437   06E7             _for9_update:
0438   06E7 29 17 12      mov b, [i]
0439   06EA FD 77         inc b
0440   06EC FD 42 17 12   mov [i], b
0441   06F0 0A B6 06      jmp _for9_cond
0442   06F3             _for9_exit:
0443   06F3 0A A5 07      jmp _if8_exit
0444   06F6             _if8_else:
0445   06F6             _if10_cond:
0446   06F6 29 09 12      mov b, [cmdadr]
0447   06F9 D7            push a
0448   06FA 11            mov a, b
0449   06FB 26 0A 1A      mov b, 6666
0450   06FE B0            cmp a, b
0451   06FF 0E            lodflgs
0452   0700 87 01         and al, %00000001 ; ==
0453   0702 B9 00         cmp al, 0
0454   0704 0E            lodflgs
0455   0705 96            not al
0456   0706 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0457   0708 22 00         mov ah, 0
0458   070A 27            mov b, a
0459   070B E4            pop a
0460   070C C0 00 00      cmp b, 0
0461   070F C6 59 07      je _if10_else
0462   0712             _if10_true:
0463   0712             _for11_init:
0464   0712 29 0D 12      mov b, [datadr1]
0465   0715 FD 42 17 12   mov [i], b
0466   0719             _for11_cond:
0467   0719 29 17 12      mov b, [i]
0468   071C D7            push a
0469   071D 11            mov a, b
0470   071E 26 7B 00      mov b, 123
0471   0721 B0            cmp a, b
0472   0722 0E            lodflgs
0473   0723 87 02         and al, %00000010 ; <
0474   0725 B9 00         cmp al, 0
0475   0727 0E            lodflgs
0476   0728 96            not al
0477   0729 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0478   072B 22 00         mov ah, 0
0479   072D 27            mov b, a
0480   072E E4            pop a
0481   072F C0 00 00      cmp b, 0
0482   0732 C6 56 07      je _for11_exit
0483   0735             _for11_block:
0484   0735 29 15 11      mov b, [datum]
0485   0738 74            mov d, b
0486   0739 DA            push d
0487   073A 29 17 12      mov b, [i]
0488   073D E7            pop d
0489   073E 10 02 00      mov a, 2
0490   0741 AC            mul a, b
0491   0742 5A            add d, b
0492   0743 DA            push d
0493   0744 26 00 00      mov b, 0
0494   0747 E7            pop d
0495   0748 11            mov a, b
0496   0749 43            mov [d], a
0497   074A             _for11_update:
0498   074A 29 17 12      mov b, [i]
0499   074D FD 77         inc b
0500   074F FD 42 17 12   mov [i], b
0501   0753 0A 19 07      jmp _for11_cond
0502   0756             _for11_exit:
0503   0756 0A A5 07      jmp _if10_exit
0504   0759             _if10_else:
0505   0759             _if12_cond:
0506   0759 29 09 12      mov b, [cmdadr]
0507   075C D7            push a
0508   075D 11            mov a, b
0509   075E 26 0F 27      mov b, 9999
0510   0761 B0            cmp a, b
0511   0762 0E            lodflgs
0512   0763 87 01         and al, %00000001 ; ==
0513   0765 B9 00         cmp al, 0
0514   0767 0E            lodflgs
0515   0768 96            not al
0516   0769 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0517   076B 22 00         mov ah, 0
0518   076D 27            mov b, a
0519   076E E4            pop a
0520   076F C0 00 00      cmp b, 0
0521   0772 C6 7F 07      je _if12_else
0522   0775             _if12_true:
0523   0775 07 FA 0F      call readint
0524   0778 FD 42 21 12   mov [runlimit], b
0525   077C 0A A5 07      jmp _if12_exit
0526   077F             _if12_else:
0527   077F             _if13_cond:
0528   077F 29 09 12      mov b, [cmdadr]
0529   0782 D7            push a
0530   0783 11            mov a, b
0531   0784 26 B8 22      mov b, 8888
0532   0787 B0            cmp a, b
0533   0788 0E            lodflgs
0534   0789 87 01         and al, %00000001 ; ==
0535   078B B9 00         cmp al, 0
0536   078D 0E            lodflgs
0537   078E 96            not al
0538   078F 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0539   0791 22 00         mov ah, 0
0540   0793 27            mov b, a
0541   0794 E4            pop a
0542   0795 C0 00 00      cmp b, 0
0543   0798 C6 A5 07      je _if13_exit
0544   079B             _if13_true:
0545   079B 26 01 00      mov b, 1
0546   079E FD 42 23 12   mov [exitflag], b
0547   07A2 0A A5 07      jmp _if13_exit
0548   07A5             _if13_exit:
0549   07A5             _if12_exit:
0550   07A5             _if10_exit:
0551   07A5             _if8_exit:
0552   07A5             _if7_exit:
0553   07A5             _if6_exit:
0554   07A5             _if5_exit:
0555   07A5             _if3_exit:
0556   07A5 0A 25 04      jmp _while2_cond
0557   07A8             _while2_exit:
0558   07A8 26 00 00      mov b, 0
0559   07AB FD 42 25 12   mov [exitexec], b
0560   07AF             _if14_cond:
0561   07AF 29 23 12      mov b, [exitflag]
0562   07B2 D7            push a
0563   07B3 11            mov a, b
0564   07B4 26 00 00      mov b, 0
0565   07B7 B0            cmp a, b
0566   07B8 0E            lodflgs
0567   07B9 87 01         and al, %00000001 ; ==
0568   07BB B9 00         cmp al, 0
0569   07BD 0E            lodflgs
0570   07BE 96            not al
0571   07BF 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0572   07C1 22 00         mov ah, 0
0573   07C3 27            mov b, a
0574   07C4 E4            pop a
0575   07C5 C0 00 00      cmp b, 0
0576   07C8 C6 F7 0F      je _if14_exit
0577   07CB             _if14_true:
0578   07CB             _while15_cond:
0579   07CB 29 13 12      mov b, [pc]
0580   07CE D7            push a
0581   07CF 11            mov a, b
0582   07D0 26 1E 00      mov b, 30
0583   07D3 B0            cmp a, b
0584   07D4 0E            lodflgs
0585   07D5 87 02         and al, %00000010 ; <
0586   07D7 B9 00         cmp al, 0
0587   07D9 0E            lodflgs
0588   07DA 96            not al
0589   07DB 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0590   07DD 22 00         mov ah, 0
0591   07DF 27            mov b, a
0592   07E0 E4            pop a
0593   07E1 C0 00 00      cmp b, 0
0594   07E4 C6 F4 0F      je _while15_exit
0595   07E7             _while15_block:
0596   07E7             _if16_cond:
0597   07E7 29 21 12      mov b, [runlimit]
0598   07EA D7            push a
0599   07EB 11            mov a, b
0600   07EC 26 01 00      mov b, 1
0601   07EF B0            cmp a, b
0602   07F0 0E            lodflgs
0603   07F1 87 01         and al, %00000001 ; ==
0604   07F3 B9 00         cmp al, 0
0605   07F5 0E            lodflgs
0606   07F6 96            not al
0607   07F7 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0608   07F9 22 00         mov ah, 0
0609   07FB 27            mov b, a
0610   07FC E4            pop a
0611   07FD C0 00 00      cmp b, 0
0612   0800 C6 09 08      je _if16_else
0613   0803             _if16_true:
0614   0803 0A F4 0F      jmp _while15_exit ; while break
0615   0806 0A 36 08      jmp _if16_exit
0616   0809             _if16_else:
0617   0809             _if17_cond:
0618   0809 29 21 12      mov b, [runlimit]
0619   080C D7            push a
0620   080D 11            mov a, b
0621   080E 26 01 00      mov b, 1
0622   0811 B0            cmp a, b
0623   0812 0E            lodflgs
0624   0813 87 03         and al, %00000011
0625   0815 B9 00         cmp al, %00000000
0626   0817 0E            lodflgs
0627   0818 87 01         and al, %00000001 ; >
0628   081A B9 00         cmp al, 0
0629   081C 0E            lodflgs
0630   081D 96            not al
0631   081E 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0632   0820 22 00         mov ah, 0
0633   0822 27            mov b, a
0634   0823 E4            pop a
0635   0824 C0 00 00      cmp b, 0
0636   0827 C6 36 08      je _if17_exit
0637   082A             _if17_true:
0638   082A 29 21 12      mov b, [runlimit]
0639   082D FD 7D         dec b
0640   082F FD 42 21 12   mov [runlimit], b
0641   0833 0A 36 08      jmp _if17_exit
0642   0836             _if17_exit:
0643   0836             _if16_exit:
0644   0836 29 15 11      mov b, [datum]
0645   0839 74            mov d, b
0646   083A DA            push d
0647   083B 26 00 00      mov b, 0
0648   083E E7            pop d
0649   083F 10 02 00      mov a, 2
0650   0842 AC            mul a, b
0651   0843 5A            add d, b
0652   0844 DA            push d
0653   0845 26 00 00      mov b, 0
0654   0848 E7            pop d
0655   0849 11            mov a, b
0656   084A 43            mov [d], a
0657   084B 29 07 12      mov b, [instruction]
0658   084E D7            push a
0659   084F 74            mov d, b
0660   0850 DA            push d
0661   0851 29 13 12      mov b, [pc]
0662   0854 D7            push a
0663   0855 11            mov a, b
0664   0856 26 04 00      mov b, 4
0665   0859 AC            mul a, b
0666   085A E4            pop a
0667   085B E7            pop d
0668   085C 10 02 00      mov a, 2
0669   085F AC            mul a, b
0670   0860 5A            add d, b
0671   0861 2A            mov b, [d]
0672   0862 E4            pop a
0673   0863 FD 42 0B 12   mov [opr], b
0674   0867 29 07 12      mov b, [instruction]
0675   086A D7            push a
0676   086B 74            mov d, b
0677   086C DA            push d
0678   086D 29 13 12      mov b, [pc]
0679   0870 D7            push a
0680   0871 11            mov a, b
0681   0872 26 04 00      mov b, 4
0682   0875 AC            mul a, b
0683   0876 11            mov a, b
0684   0877 26 01 00      mov b, 1
0685   087A 54            add a, b
0686   087B 27            mov b, a
0687   087C E4            pop a
0688   087D E7            pop d
0689   087E 10 02 00      mov a, 2
0690   0881 AC            mul a, b
0691   0882 5A            add d, b
0692   0883 2A            mov b, [d]
0693   0884 E4            pop a
0694   0885 FD 42 0D 12   mov [datadr1], b
0695   0889 29 07 12      mov b, [instruction]
0696   088C D7            push a
0697   088D 74            mov d, b
0698   088E DA            push d
0699   088F 29 13 12      mov b, [pc]
0700   0892 D7            push a
0701   0893 11            mov a, b
0702   0894 26 04 00      mov b, 4
0703   0897 AC            mul a, b
0704   0898 11            mov a, b
0705   0899 26 02 00      mov b, 2
0706   089C 54            add a, b
0707   089D 27            mov b, a
0708   089E E4            pop a
0709   089F E7            pop d
0710   08A0 10 02 00      mov a, 2
0711   08A3 AC            mul a, b
0712   08A4 5A            add d, b
0713   08A5 2A            mov b, [d]
0714   08A6 E4            pop a
0715   08A7 FD 42 0F 12   mov [datadr2], b
0716   08AB 29 07 12      mov b, [instruction]
0717   08AE D7            push a
0718   08AF 74            mov d, b
0719   08B0 DA            push d
0720   08B1 29 13 12      mov b, [pc]
0721   08B4 D7            push a
0722   08B5 11            mov a, b
0723   08B6 26 04 00      mov b, 4
0724   08B9 AC            mul a, b
0725   08BA 11            mov a, b
0726   08BB 26 03 00      mov b, 3
0727   08BE 54            add a, b
0728   08BF 27            mov b, a
0729   08C0 E4            pop a
0730   08C1 E7            pop d
0731   08C2 10 02 00      mov a, 2
0732   08C5 AC            mul a, b
0733   08C6 5A            add d, b
0734   08C7 2A            mov b, [d]
0735   08C8 E4            pop a
0736   08C9 FD 42 11 12   mov [datadr3], b
0737   08CD             _if18_cond:
0738   08CD 29 15 12      mov b, [h]
0739   08D0 D7            push a
0740   08D1 11            mov a, b
0741   08D2 26 00 00      mov b, 0
0742   08D5 B0            cmp a, b
0743   08D6 0E            lodflgs
0744   08D7 87 03         and al, %00000011
0745   08D9 B9 00         cmp al, %00000000
0746   08DB 0E            lodflgs
0747   08DC 87 01         and al, %00000001 ; >
0748   08DE B9 00         cmp al, 0
0749   08E0 0E            lodflgs
0750   08E1 96            not al
0751   08E2 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0752   08E4 22 00         mov ah, 0
0753   08E6 27            mov b, a
0754   08E7 E4            pop a
0755   08E8 D7            push a
0756   08E9 11            mov a, b
0757   08EA 29 1B 12      mov b, [k]
0758   08ED D7            push a
0759   08EE 11            mov a, b
0760   08EF 26 00 00      mov b, 0
0761   08F2 B0            cmp a, b
0762   08F3 0E            lodflgs
0763   08F4 87 03         and al, %00000011
0764   08F6 B9 00         cmp al, %00000000
0765   08F8 0E            lodflgs
0766   08F9 87 01         and al, %00000001 ; >
0767   08FB B9 00         cmp al, 0
0768   08FD 0E            lodflgs
0769   08FE 96            not al
0770   08FF 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0771   0901 22 00         mov ah, 0
0772   0903 27            mov b, a
0773   0904 E4            pop a
0774   0905 8A            or a, b
0775   0906 27            mov b, a
0776   0907 E4            pop a
0777   0908 D7            push a
0778   0909 11            mov a, b
0779   090A 29 1D 12      mov b, [l]
0780   090D D7            push a
0781   090E 11            mov a, b
0782   090F 26 00 00      mov b, 0
0783   0912 B0            cmp a, b
0784   0913 0E            lodflgs
0785   0914 87 03         and al, %00000011
0786   0916 B9 00         cmp al, %00000000
0787   0918 0E            lodflgs
0788   0919 87 01         and al, %00000001 ; >
0789   091B B9 00         cmp al, 0
0790   091D 0E            lodflgs
0791   091E 96            not al
0792   091F 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0793   0921 22 00         mov ah, 0
0794   0923 27            mov b, a
0795   0924 E4            pop a
0796   0925 8A            or a, b
0797   0926 27            mov b, a
0798   0927 E4            pop a
0799   0928 C0 00 00      cmp b, 0
0800   092B C6 5B 09      je _if18_exit
0801   092E             _if18_true:
0802   092E 29 15 12      mov b, [h]
0803   0931 FD 42 0D 12   mov [datadr1], b
0804   0935 29 1B 12      mov b, [k]
0805   0938 FD 42 0F 12   mov [datadr2], b
0806   093C 29 1D 12      mov b, [l]
0807   093F FD 42 11 12   mov [datadr3], b
0808   0943 26 00 00      mov b, 0
0809   0946 FD 42 15 12   mov [h], b
0810   094A 26 00 00      mov b, 0
0811   094D FD 42 1B 12   mov [k], b
0812   0951 26 00 00      mov b, 0
0813   0954 FD 42 1D 12   mov [l], b
0814   0958 0A 5B 09      jmp _if18_exit
0815   095B             _if18_exit:
0816   095B 29 13 12      mov b, [pc]
0817   095E D7            push a
0818   095F 11            mov a, b
0819   0960 26 64 00      mov b, 100
0820   0963 AC            mul a, b
0821   0964 11            mov a, b
0822   0965 29 0B 12      mov b, [opr]
0823   0968 54            add a, b
0824   0969 27            mov b, a
0825   096A E4            pop a
0826   096B FD AB         swp b
0827   096D D8            push b
0828   096E 07 0A 10      call displaynumber
0829   0971 51 02 00      add sp, 2
0830   0974             _if19_cond:
0831   0974 29 0B 12      mov b, [opr]
0832   0977 D7            push a
0833   0978 11            mov a, b
0834   0979 26 00 00      mov b, 0
0835   097C B0            cmp a, b
0836   097D 0E            lodflgs
0837   097E 87 01         and al, %00000001 ; ==
0838   0980 B9 00         cmp al, 0
0839   0982 0E            lodflgs
0840   0983 96            not al
0841   0984 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0842   0986 22 00         mov ah, 0
0843   0988 27            mov b, a
0844   0989 E4            pop a
0845   098A C0 00 00      cmp b, 0
0846   098D C6 93 09      je _if19_else
0847   0990             _if19_true:
0848   0990 0A 7D 0F      jmp _if19_exit
0849   0993             _if19_else:
0850   0993             _if20_cond:
0851   0993 29 0B 12      mov b, [opr]
0852   0996 D7            push a
0853   0997 11            mov a, b
0854   0998 26 01 00      mov b, 1
0855   099B B0            cmp a, b
0856   099C 0E            lodflgs
0857   099D 87 01         and al, %00000001 ; ==
0858   099F B9 00         cmp al, 0
0859   09A1 0E            lodflgs
0860   09A2 96            not al
0861   09A3 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0862   09A5 22 00         mov ah, 0
0863   09A7 27            mov b, a
0864   09A8 E4            pop a
0865   09A9 C0 00 00      cmp b, 0
0866   09AC C6 A5 0C      je _if20_else
0867   09AF             _if20_true:
0868   09AF 26 00 00      mov b, 0
0869   09B2 FD 42 1B 12   mov [k], b
0870   09B6             _if21_cond:
0871   09B6 29 11 12      mov b, [datadr3]
0872   09B9 D7            push a
0873   09BA 11            mov a, b
0874   09BB 26 06 00      mov b, 6
0875   09BE B0            cmp a, b
0876   09BF 0E            lodflgs
0877   09C0 87 03         and al, %00000011
0878   09C2 B9 00         cmp al, %00000000
0879   09C4 0E            lodflgs
0880   09C5 87 01         and al, %00000001 ; >
0881   09C7 B9 00         cmp al, 0
0882   09C9 0E            lodflgs
0883   09CA 96            not al
0884   09CB 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0885   09CD 22 00         mov ah, 0
0886   09CF 27            mov b, a
0887   09D0 E4            pop a
0888   09D1 C0 00 00      cmp b, 0
0889   09D4 C6 F0 09      je _if21_exit
0890   09D7             _if21_true:
0891   09D7 29 11 12      mov b, [datadr3]
0892   09DA D7            push a
0893   09DB 11            mov a, b
0894   09DC 26 07 00      mov b, 7
0895   09DF 60            sub a, b
0896   09E0 27            mov b, a
0897   09E1 E4            pop a
0898   09E2 FD 42 11 12   mov [datadr3], b
0899   09E6 26 40 00      mov b, 64
0900   09E9 FD 42 1B 12   mov [k], b
0901   09ED 0A F0 09      jmp _if21_exit
0902   09F0             _if21_exit:
0903   09F0             _if22_cond:
0904   09F0 29 15 11      mov b, [datum]
0905   09F3 D7            push a
0906   09F4 74            mov d, b
0907   09F5 DA            push d
0908   09F6 29 0D 12      mov b, [datadr1]
0909   09F9 E7            pop d
0910   09FA 10 02 00      mov a, 2
0911   09FD AC            mul a, b
0912   09FE 5A            add d, b
0913   09FF 2A            mov b, [d]
0914   0A00 11            mov a, b
0915   0A01 26 00 00      mov b, 0
0916   0A04 B0            cmp a, b
0917   0A05 0E            lodflgs
0918   0A06 87 01         and al, %00000001 ; ==
0919   0A08 B9 00         cmp al, 0
0920   0A0A 0E            lodflgs
0921   0A0B 96            not al
0922   0A0C 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0923   0A0E 22 00         mov ah, 0
0924   0A10 27            mov b, a
0925   0A11 E4            pop a
0926   0A12 D7            push a
0927   0A13 11            mov a, b
0928   0A14 AF 00 00      cmp a, 0
0929   0A17 0E            lodflgs
0930   0A18 96            not al
0931   0A19 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
0932   0A1B 29 11 12      mov b, [datadr3]
0933   0A1E D7            push a
0934   0A1F 11            mov a, b
0935   0A20 26 00 00      mov b, 0
0936   0A23 B0            cmp a, b
0937   0A24 0E            lodflgs
0938   0A25 87 01         and al, %00000001 ; ==
0939   0A27 B9 00         cmp al, 0
0940   0A29 0E            lodflgs
0941   0A2A 96            not al
0942   0A2B 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0943   0A2D 22 00         mov ah, 0
0944   0A2F 27            mov b, a
0945   0A30 E4            pop a
0946   0A31 DB            push al
0947   0A32 C0 00 00      cmp b, 0
0948   0A35 0E            lodflgs
0949   0A36 96            not al
0950   0A37 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
0951   0A39 EA            pop bl
0952   0A3A 88            and al, bl
0953   0A3B 2F            mov bl, al
0954   0A3C A7 00         mov bh, 0
0955   0A3E 11            mov a, b
0956   0A3F 29 15 11      mov b, [datum]
0957   0A42 D7            push a
0958   0A43 74            mov d, b
0959   0A44 DA            push d
0960   0A45 29 0D 12      mov b, [datadr1]
0961   0A48 E7            pop d
0962   0A49 10 02 00      mov a, 2
0963   0A4C AC            mul a, b
0964   0A4D 5A            add d, b
0965   0A4E 2A            mov b, [d]
0966   0A4F 11            mov a, b
0967   0A50 26 FF 7F      mov b, 32767
0968   0A53 B0            cmp a, b
0969   0A54 0E            lodflgs
0970   0A55 87 03         and al, %00000011
0971   0A57 B9 00         cmp al, %00000000
0972   0A59 0E            lodflgs
0973   0A5A 87 01         and al, %00000001 ; >
0974   0A5C B9 00         cmp al, 0
0975   0A5E 0E            lodflgs
0976   0A5F 96            not al
0977   0A60 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0978   0A62 22 00         mov ah, 0
0979   0A64 27            mov b, a
0980   0A65 E4            pop a
0981   0A66 D7            push a
0982   0A67 11            mov a, b
0983   0A68 AF 00 00      cmp a, 0
0984   0A6B 0E            lodflgs
0985   0A6C 96            not al
0986   0A6D 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
0987   0A6F 29 11 12      mov b, [datadr3]
0988   0A72 D7            push a
0989   0A73 11            mov a, b
0990   0A74 26 02 00      mov b, 2
0991   0A77 B0            cmp a, b
0992   0A78 0E            lodflgs
0993   0A79 87 01         and al, %00000001 ; ==
0994   0A7B B9 00         cmp al, 0
0995   0A7D 0E            lodflgs
0996   0A7E 96            not al
0997   0A7F 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0998   0A81 22 00         mov ah, 0
0999   0A83 27            mov b, a
1000   0A84 E4            pop a
1001   0A85 DB            push al
1002   0A86 C0 00 00      cmp b, 0
1003   0A89 0E            lodflgs
1004   0A8A 96            not al
1005   0A8B 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
1006   0A8D EA            pop bl
1007   0A8E 88            and al, bl
1008   0A8F 2F            mov bl, al
1009   0A90 A7 00         mov bh, 0
1010   0A92 E4            pop a
1011   0A93 8A            or a, b
1012   0A94 27            mov b, a
1013   0A95 E4            pop a
1014   0A96 D7            push a
1015   0A97 11            mov a, b
1016   0A98 29 15 11      mov b, [datum]
1017   0A9B D7            push a
1018   0A9C 74            mov d, b
1019   0A9D DA            push d
1020   0A9E 29 0D 12      mov b, [datadr1]
1021   0AA1 E7            pop d
1022   0AA2 10 02 00      mov a, 2
1023   0AA5 AC            mul a, b
1024   0AA6 5A            add d, b
1025   0AA7 2A            mov b, [d]
1026   0AA8 11            mov a, b
1027   0AA9 26 FF 7F      mov b, 32767
1028   0AAC B0            cmp a, b
1029   0AAD 0E            lodflgs
1030   0AAE 87 03         and al, %00000011
1031   0AB0 8F 02         xor al, %00000010 ; >=
1032   0AB2 B9 00         cmp al, 0
1033   0AB4 0E            lodflgs
1034   0AB5 96            not al
1035   0AB6 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1036   0AB8 22 00         mov ah, 0
1037   0ABA 27            mov b, a
1038   0ABB E4            pop a
1039   0ABC D7            push a
1040   0ABD 11            mov a, b
1041   0ABE AF 00 00      cmp a, 0
1042   0AC1 0E            lodflgs
1043   0AC2 96            not al
1044   0AC3 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
1045   0AC5 29 11 12      mov b, [datadr3]
1046   0AC8 D7            push a
1047   0AC9 11            mov a, b
1048   0ACA 26 04 00      mov b, 4
1049   0ACD B0            cmp a, b
1050   0ACE 0E            lodflgs
1051   0ACF 87 01         and al, %00000001 ; ==
1052   0AD1 B9 00         cmp al, 0
1053   0AD3 0E            lodflgs
1054   0AD4 96            not al
1055   0AD5 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1056   0AD7 22 00         mov ah, 0
1057   0AD9 27            mov b, a
1058   0ADA E4            pop a
1059   0ADB DB            push al
1060   0ADC C0 00 00      cmp b, 0
1061   0ADF 0E            lodflgs
1062   0AE0 96            not al
1063   0AE1 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
1064   0AE3 EA            pop bl
1065   0AE4 88            and al, bl
1066   0AE5 2F            mov bl, al
1067   0AE6 A7 00         mov bh, 0
1068   0AE8 E4            pop a
1069   0AE9 8A            or a, b
1070   0AEA 27            mov b, a
1071   0AEB E4            pop a
1072   0AEC D7            push a
1073   0AED 11            mov a, b
1074   0AEE 29 15 11      mov b, [datum]
1075   0AF1 D7            push a
1076   0AF2 74            mov d, b
1077   0AF3 DA            push d
1078   0AF4 29 0D 12      mov b, [datadr1]
1079   0AF7 E7            pop d
1080   0AF8 10 02 00      mov a, 2
1081   0AFB AC            mul a, b
1082   0AFC 5A            add d, b
1083   0AFD 2A            mov b, [d]
1084   0AFE 11            mov a, b
1085   0AFF 26 00 00      mov b, 0
1086   0B02 B0            cmp a, b
1087   0B03 0E            lodflgs
1088   0B04 87 03         and al, %00000011
1089   0B06 B9 00         cmp al, %00000000
1090   0B08 0E            lodflgs
1091   0B09 87 01         and al, %00000001 ; >
1092   0B0B B9 00         cmp al, 0
1093   0B0D 0E            lodflgs
1094   0B0E 96            not al
1095   0B0F 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1096   0B11 22 00         mov ah, 0
1097   0B13 27            mov b, a
1098   0B14 E4            pop a
1099   0B15 D7            push a
1100   0B16 11            mov a, b
1101   0B17 AF 00 00      cmp a, 0
1102   0B1A 0E            lodflgs
1103   0B1B 96            not al
1104   0B1C 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
1105   0B1E 29 15 11      mov b, [datum]
1106   0B21 D7            push a
1107   0B22 74            mov d, b
1108   0B23 DA            push d
1109   0B24 29 0D 12      mov b, [datadr1]
1110   0B27 E7            pop d
1111   0B28 10 02 00      mov a, 2
1112   0B2B AC            mul a, b
1113   0B2C 5A            add d, b
1114   0B2D 2A            mov b, [d]
1115   0B2E 11            mov a, b
1116   0B2F 26 FF 7F      mov b, 32767
1117   0B32 B0            cmp a, b
1118   0B33 0E            lodflgs
1119   0B34 87 03         and al, %00000011 ; <=
1120   0B36 B9 00         cmp al, 0
1121   0B38 0E            lodflgs
1122   0B39 96            not al
1123   0B3A 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1124   0B3C 22 00         mov ah, 0
1125   0B3E 27            mov b, a
1126   0B3F E4            pop a
1127   0B40 DB            push al
1128   0B41 C0 00 00      cmp b, 0
1129   0B44 0E            lodflgs
1130   0B45 96            not al
1131   0B46 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
1132   0B48 EA            pop bl
1133   0B49 88            and al, bl
1134   0B4A 2F            mov bl, al
1135   0B4B A7 00         mov bh, 0
1136   0B4D 11            mov a, b
1137   0B4E AF 00 00      cmp a, 0
1138   0B51 0E            lodflgs
1139   0B52 96            not al
1140   0B53 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
1141   0B55 29 11 12      mov b, [datadr3]
1142   0B58 D7            push a
1143   0B59 11            mov a, b
1144   0B5A 26 01 00      mov b, 1
1145   0B5D B0            cmp a, b
1146   0B5E 0E            lodflgs
1147   0B5F 87 01         and al, %00000001 ; ==
1148   0B61 B9 00         cmp al, 0
1149   0B63 0E            lodflgs
1150   0B64 96            not al
1151   0B65 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1152   0B67 22 00         mov ah, 0
1153   0B69 27            mov b, a
1154   0B6A E4            pop a
1155   0B6B DB            push al
1156   0B6C C0 00 00      cmp b, 0
1157   0B6F 0E            lodflgs
1158   0B70 96            not al
1159   0B71 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
1160   0B73 EA            pop bl
1161   0B74 88            and al, bl
1162   0B75 2F            mov bl, al
1163   0B76 A7 00         mov bh, 0
1164   0B78 E4            pop a
1165   0B79 8A            or a, b
1166   0B7A 27            mov b, a
1167   0B7B E4            pop a
1168   0B7C D7            push a
1169   0B7D 11            mov a, b
1170   0B7E 29 15 11      mov b, [datum]
1171   0B81 D7            push a
1172   0B82 74            mov d, b
1173   0B83 DA            push d
1174   0B84 29 0D 12      mov b, [datadr1]
1175   0B87 E7            pop d
1176   0B88 10 02 00      mov a, 2
1177   0B8B AC            mul a, b
1178   0B8C 5A            add d, b
1179   0B8D 2A            mov b, [d]
1180   0B8E 11            mov a, b
1181   0B8F 26 00 00      mov b, 0
1182   0B92 B0            cmp a, b
1183   0B93 0E            lodflgs
1184   0B94 87 03         and al, %00000011
1185   0B96 8F 02         xor al, %00000010 ; >=
1186   0B98 B9 00         cmp al, 0
1187   0B9A 0E            lodflgs
1188   0B9B 96            not al
1189   0B9C 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1190   0B9E 22 00         mov ah, 0
1191   0BA0 27            mov b, a
1192   0BA1 E4            pop a
1193   0BA2 D7            push a
1194   0BA3 11            mov a, b
1195   0BA4 AF 00 00      cmp a, 0
1196   0BA7 0E            lodflgs
1197   0BA8 96            not al
1198   0BA9 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
1199   0BAB 29 15 11      mov b, [datum]
1200   0BAE D7            push a
1201   0BAF 74            mov d, b
1202   0BB0 DA            push d
1203   0BB1 29 0D 12      mov b, [datadr1]
1204   0BB4 E7            pop d
1205   0BB5 10 02 00      mov a, 2
1206   0BB8 AC            mul a, b
1207   0BB9 5A            add d, b
1208   0BBA 2A            mov b, [d]
1209   0BBB 11            mov a, b
1210   0BBC 26 FF 7F      mov b, 32767
1211   0BBF B0            cmp a, b
1212   0BC0 0E            lodflgs
1213   0BC1 87 03         and al, %00000011 ; <=
1214   0BC3 B9 00         cmp al, 0
1215   0BC5 0E            lodflgs
1216   0BC6 96            not al
1217   0BC7 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1218   0BC9 22 00         mov ah, 0
1219   0BCB 27            mov b, a
1220   0BCC E4            pop a
1221   0BCD DB            push al
1222   0BCE C0 00 00      cmp b, 0
1223   0BD1 0E            lodflgs
1224   0BD2 96            not al
1225   0BD3 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
1226   0BD5 EA            pop bl
1227   0BD6 88            and al, bl
1228   0BD7 2F            mov bl, al
1229   0BD8 A7 00         mov bh, 0
1230   0BDA 11            mov a, b
1231   0BDB AF 00 00      cmp a, 0
1232   0BDE 0E            lodflgs
1233   0BDF 96            not al
1234   0BE0 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
1235   0BE2 29 11 12      mov b, [datadr3]
1236   0BE5 D7            push a
1237   0BE6 11            mov a, b
1238   0BE7 26 03 00      mov b, 3
1239   0BEA B0            cmp a, b
1240   0BEB 0E            lodflgs
1241   0BEC 87 01         and al, %00000001 ; ==
1242   0BEE B9 00         cmp al, 0
1243   0BF0 0E            lodflgs
1244   0BF1 96            not al
1245   0BF2 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1246   0BF4 22 00         mov ah, 0
1247   0BF6 27            mov b, a
1248   0BF7 E4            pop a
1249   0BF8 DB            push al
1250   0BF9 C0 00 00      cmp b, 0
1251   0BFC 0E            lodflgs
1252   0BFD 96            not al
1253   0BFE 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
1254   0C00 EA            pop bl
1255   0C01 88            and al, bl
1256   0C02 2F            mov bl, al
1257   0C03 A7 00         mov bh, 0
1258   0C05 E4            pop a
1259   0C06 8A            or a, b
1260   0C07 27            mov b, a
1261   0C08 E4            pop a
1262   0C09 D7            push a
1263   0C0A 11            mov a, b
1264   0C0B 29 15 11      mov b, [datum]
1265   0C0E D7            push a
1266   0C0F 74            mov d, b
1267   0C10 DA            push d
1268   0C11 29 0D 12      mov b, [datadr1]
1269   0C14 E7            pop d
1270   0C15 10 02 00      mov a, 2
1271   0C18 AC            mul a, b
1272   0C19 5A            add d, b
1273   0C1A 2A            mov b, [d]
1274   0C1B 11            mov a, b
1275   0C1C 26 00 00      mov b, 0
1276   0C1F B0            cmp a, b
1277   0C20 0E            lodflgs
1278   0C21 87 01         and al, %00000001
1279   0C23 8F 01         xor al, %00000001 ; !=
1280   0C25 B9 00         cmp al, 0
1281   0C27 0E            lodflgs
1282   0C28 96            not al
1283   0C29 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1284   0C2B 22 00         mov ah, 0
1285   0C2D 27            mov b, a
1286   0C2E E4            pop a
1287   0C2F D7            push a
1288   0C30 11            mov a, b
1289   0C31 AF 00 00      cmp a, 0
1290   0C34 0E            lodflgs
1291   0C35 96            not al
1292   0C36 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
1293   0C38 29 11 12      mov b, [datadr3]
1294   0C3B D7            push a
1295   0C3C 11            mov a, b
1296   0C3D 26 05 00      mov b, 5
1297   0C40 B0            cmp a, b
1298   0C41 0E            lodflgs
1299   0C42 87 01         and al, %00000001 ; ==
1300   0C44 B9 00         cmp al, 0
1301   0C46 0E            lodflgs
1302   0C47 96            not al
1303   0C48 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1304   0C4A 22 00         mov ah, 0
1305   0C4C 27            mov b, a
1306   0C4D E4            pop a
1307   0C4E DB            push al
1308   0C4F C0 00 00      cmp b, 0
1309   0C52 0E            lodflgs
1310   0C53 96            not al
1311   0C54 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
1312   0C56 EA            pop bl
1313   0C57 88            and al, bl
1314   0C58 2F            mov bl, al
1315   0C59 A7 00         mov bh, 0
1316   0C5B E4            pop a
1317   0C5C 8A            or a, b
1318   0C5D 27            mov b, a
1319   0C5E E4            pop a
1320   0C5F D7            push a
1321   0C60 11            mov a, b
1322   0C61 29 11 12      mov b, [datadr3]
1323   0C64 D7            push a
1324   0C65 11            mov a, b
1325   0C66 26 06 00      mov b, 6
1326   0C69 B0            cmp a, b
1327   0C6A 0E            lodflgs
1328   0C6B 87 01         and al, %00000001 ; ==
1329   0C6D B9 00         cmp al, 0
1330   0C6F 0E            lodflgs
1331   0C70 96            not al
1332   0C71 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1333   0C73 22 00         mov ah, 0
1334   0C75 27            mov b, a
1335   0C76 E4            pop a
1336   0C77 8A            or a, b
1337   0C78 27            mov b, a
1338   0C79 E4            pop a
1339   0C7A C0 00 00      cmp b, 0
1340   0C7D C6 99 0C      je _if22_else
1341   0C80             _if22_true:
1342   0C80 29 0F 12      mov b, [datadr2]
1343   0C83 D7            push a
1344   0C84 11            mov a, b
1345   0C85 29 1B 12      mov b, [k]
1346   0C88 54            add a, b
1347   0C89 27            mov b, a
1348   0C8A E4            pop a
1349   0C8B FD 42 13 12   mov [pc], b
1350   0C8F 26 00 00      mov b, 0
1351   0C92 FD 42 1B 12   mov [k], b
1352   0C96 0A A2 0C      jmp _if22_exit
1353   0C99             _if22_else:
1354   0C99 29 13 12      mov b, [pc]
1355   0C9C FD 77         inc b
1356   0C9E FD 42 13 12   mov [pc], b
1357   0CA2             _if22_exit:
1358   0CA2 0A 7D 0F      jmp _if20_exit
1359   0CA5             _if20_else:
1360   0CA5             _if23_cond:
1361   0CA5 29 0B 12      mov b, [opr]
1362   0CA8 D7            push a
1363   0CA9 11            mov a, b
1364   0CAA 26 02 00      mov b, 2
1365   0CAD B0            cmp a, b
1366   0CAE 0E            lodflgs
1367   0CAF 87 01         and al, %00000001 ; ==
1368   0CB1 B9 00         cmp al, 0
1369   0CB3 0E            lodflgs
1370   0CB4 96            not al
1371   0CB5 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1372   0CB7 22 00         mov ah, 0
1373   0CB9 27            mov b, a
1374   0CBA E4            pop a
1375   0CBB C0 00 00      cmp b, 0
1376   0CBE C6 03 0D      je _if23_else
1377   0CC1             _if23_true:
1378   0CC1 29 15 11      mov b, [datum]
1379   0CC4 D7            push a
1380   0CC5 74            mov d, b
1381   0CC6 DA            push d
1382   0CC7 29 0D 12      mov b, [datadr1]
1383   0CCA E7            pop d
1384   0CCB 10 02 00      mov a, 2
1385   0CCE AC            mul a, b
1386   0CCF 5A            add d, b
1387   0CD0 2A            mov b, [d]
1388   0CD1 E4            pop a
1389   0CD2 FD 42 15 12   mov [h], b
1390   0CD6 29 15 11      mov b, [datum]
1391   0CD9 D7            push a
1392   0CDA 74            mov d, b
1393   0CDB DA            push d
1394   0CDC 29 0F 12      mov b, [datadr2]
1395   0CDF E7            pop d
1396   0CE0 10 02 00      mov a, 2
1397   0CE3 AC            mul a, b
1398   0CE4 5A            add d, b
1399   0CE5 2A            mov b, [d]
1400   0CE6 E4            pop a
1401   0CE7 FD 42 1B 12   mov [k], b
1402   0CEB 29 15 11      mov b, [datum]
1403   0CEE D7            push a
1404   0CEF 74            mov d, b
1405   0CF0 DA            push d
1406   0CF1 29 11 12      mov b, [datadr3]
1407   0CF4 E7            pop d
1408   0CF5 10 02 00      mov a, 2
1409   0CF8 AC            mul a, b
1410   0CF9 5A            add d, b
1411   0CFA 2A            mov b, [d]
1412   0CFB E4            pop a
1413   0CFC FD 42 1D 12   mov [l], b
1414   0D00 0A 7D 0F      jmp _if23_exit
1415   0D03             _if23_else:
1416   0D03             _if24_cond:
1417   0D03 29 0B 12      mov b, [opr]
1418   0D06 D7            push a
1419   0D07 11            mov a, b
1420   0D08 26 05 00      mov b, 5
1421   0D0B B0            cmp a, b
1422   0D0C 0E            lodflgs
1423   0D0D 87 01         and al, %00000001 ; ==
1424   0D0F B9 00         cmp al, 0
1425   0D11 0E            lodflgs
1426   0D12 96            not al
1427   0D13 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1428   0D15 22 00         mov ah, 0
1429   0D17 27            mov b, a
1430   0D18 E4            pop a
1431   0D19 C0 00 00      cmp b, 0
1432   0D1C C6 3F 0D      je _if24_else
1433   0D1F             _if24_true:
1434   0D1F 29 15 11      mov b, [datum]
1435   0D22 74            mov d, b
1436   0D23 DA            push d
1437   0D24 29 11 12      mov b, [datadr3]
1438   0D27 E7            pop d
1439   0D28 10 02 00      mov a, 2
1440   0D2B AC            mul a, b
1441   0D2C 5A            add d, b
1442   0D2D DA            push d
1443   0D2E 29 0F 12      mov b, [datadr2]
1444   0D31 D7            push a
1445   0D32 11            mov a, b
1446   0D33 29 0D 12      mov b, [datadr1]
1447   0D36 54            add a, b
1448   0D37 27            mov b, a
1449   0D38 E4            pop a
1450   0D39 E7            pop d
1451   0D3A 11            mov a, b
1452   0D3B 43            mov [d], a
1453   0D3C 0A 7D 0F      jmp _if24_exit
1454   0D3F             _if24_else:
1455   0D3F             _if25_cond:
1456   0D3F 29 0B 12      mov b, [opr]
1457   0D42 D7            push a
1458   0D43 11            mov a, b
1459   0D44 26 06 00      mov b, 6
1460   0D47 B0            cmp a, b
1461   0D48 0E            lodflgs
1462   0D49 87 01         and al, %00000001 ; ==
1463   0D4B B9 00         cmp al, 0
1464   0D4D 0E            lodflgs
1465   0D4E 96            not al
1466   0D4F 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1467   0D51 22 00         mov ah, 0
1468   0D53 27            mov b, a
1469   0D54 E4            pop a
1470   0D55 C0 00 00      cmp b, 0
1471   0D58 C6 81 0D      je _if25_else
1472   0D5B             _if25_true:
1473   0D5B 29 15 11      mov b, [datum]
1474   0D5E 74            mov d, b
1475   0D5F DA            push d
1476   0D60 29 11 12      mov b, [datadr3]
1477   0D63 E7            pop d
1478   0D64 10 02 00      mov a, 2
1479   0D67 AC            mul a, b
1480   0D68 5A            add d, b
1481   0D69 DA            push d
1482   0D6A 29 15 11      mov b, [datum]
1483   0D6D D7            push a
1484   0D6E 74            mov d, b
1485   0D6F DA            push d
1486   0D70 29 0F 12      mov b, [datadr2]
1487   0D73 E7            pop d
1488   0D74 10 02 00      mov a, 2
1489   0D77 AC            mul a, b
1490   0D78 5A            add d, b
1491   0D79 2A            mov b, [d]
1492   0D7A E4            pop a
1493   0D7B E7            pop d
1494   0D7C 11            mov a, b
1495   0D7D 43            mov [d], a
1496   0D7E 0A 7D 0F      jmp _if25_exit
1497   0D81             _if25_else:
1498   0D81             _if26_cond:
1499   0D81 29 0B 12      mov b, [opr]
1500   0D84 D7            push a
1501   0D85 11            mov a, b
1502   0D86 26 08 00      mov b, 8
1503   0D89 B0            cmp a, b
1504   0D8A 0E            lodflgs
1505   0D8B 87 01         and al, %00000001 ; ==
1506   0D8D B9 00         cmp al, 0
1507   0D8F 0E            lodflgs
1508   0D90 96            not al
1509   0D91 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1510   0D93 22 00         mov ah, 0
1511   0D95 27            mov b, a
1512   0D96 E4            pop a
1513   0D97 C0 00 00      cmp b, 0
1514   0D9A C6 D1 0D      je _if26_else
1515   0D9D             _if26_true:
1516   0D9D 29 15 11      mov b, [datum]
1517   0DA0 74            mov d, b
1518   0DA1 DA            push d
1519   0DA2 29 15 11      mov b, [datum]
1520   0DA5 D7            push a
1521   0DA6 74            mov d, b
1522   0DA7 DA            push d
1523   0DA8 29 11 12      mov b, [datadr3]
1524   0DAB E7            pop d
1525   0DAC 10 02 00      mov a, 2
1526   0DAF AC            mul a, b
1527   0DB0 5A            add d, b
1528   0DB1 2A            mov b, [d]
1529   0DB2 E4            pop a
1530   0DB3 E7            pop d
1531   0DB4 10 02 00      mov a, 2
1532   0DB7 AC            mul a, b
1533   0DB8 5A            add d, b
1534   0DB9 DA            push d
1535   0DBA 29 15 11      mov b, [datum]
1536   0DBD D7            push a
1537   0DBE 74            mov d, b
1538   0DBF DA            push d
1539   0DC0 29 0F 12      mov b, [datadr2]
1540   0DC3 E7            pop d
1541   0DC4 10 02 00      mov a, 2
1542   0DC7 AC            mul a, b
1543   0DC8 5A            add d, b
1544   0DC9 2A            mov b, [d]
1545   0DCA E4            pop a
1546   0DCB E7            pop d
1547   0DCC 11            mov a, b
1548   0DCD 43            mov [d], a
1549   0DCE 0A 7D 0F      jmp _if26_exit
1550   0DD1             _if26_else:
1551   0DD1             _if27_cond:
1552   0DD1 29 0B 12      mov b, [opr]
1553   0DD4 D7            push a
1554   0DD5 11            mov a, b
1555   0DD6 26 09 00      mov b, 9
1556   0DD9 B0            cmp a, b
1557   0DDA 0E            lodflgs
1558   0DDB 87 01         and al, %00000001 ; ==
1559   0DDD B9 00         cmp al, 0
1560   0DDF 0E            lodflgs
1561   0DE0 96            not al
1562   0DE1 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1563   0DE3 22 00         mov ah, 0
1564   0DE5 27            mov b, a
1565   0DE6 E4            pop a
1566   0DE7 C0 00 00      cmp b, 0
1567   0DEA C6 27 0E      je _if27_else
1568   0DED             _if27_true:
1569   0DED 29 15 11      mov b, [datum]
1570   0DF0 74            mov d, b
1571   0DF1 DA            push d
1572   0DF2 29 11 12      mov b, [datadr3]
1573   0DF5 E7            pop d
1574   0DF6 10 02 00      mov a, 2
1575   0DF9 AC            mul a, b
1576   0DFA 5A            add d, b
1577   0DFB DA            push d
1578   0DFC 29 15 11      mov b, [datum]
1579   0DFF D7            push a
1580   0E00 74            mov d, b
1581   0E01 DA            push d
1582   0E02 29 0D 12      mov b, [datadr1]
1583   0E05 E7            pop d
1584   0E06 10 02 00      mov a, 2
1585   0E09 AC            mul a, b
1586   0E0A 5A            add d, b
1587   0E0B 2A            mov b, [d]
1588   0E0C 11            mov a, b
1589   0E0D 29 15 11      mov b, [datum]
1590   0E10 D7            push a
1591   0E11 74            mov d, b
1592   0E12 DA            push d
1593   0E13 29 0F 12      mov b, [datadr2]
1594   0E16 E7            pop d
1595   0E17 10 02 00      mov a, 2
1596   0E1A AC            mul a, b
1597   0E1B 5A            add d, b
1598   0E1C 2A            mov b, [d]
1599   0E1D E4            pop a
1600   0E1E 54            add a, b
1601   0E1F 27            mov b, a
1602   0E20 E4            pop a
1603   0E21 E7            pop d
1604   0E22 11            mov a, b
1605   0E23 43            mov [d], a
1606   0E24 0A 7D 0F      jmp _if27_exit
1607   0E27             _if27_else:
1608   0E27             _if28_cond:
1609   0E27 29 0B 12      mov b, [opr]
1610   0E2A D7            push a
1611   0E2B 11            mov a, b
1612   0E2C 26 0A 00      mov b, 10
1613   0E2F B0            cmp a, b
1614   0E30 0E            lodflgs
1615   0E31 87 01         and al, %00000001 ; ==
1616   0E33 B9 00         cmp al, 0
1617   0E35 0E            lodflgs
1618   0E36 96            not al
1619   0E37 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1620   0E39 22 00         mov ah, 0
1621   0E3B 27            mov b, a
1622   0E3C E4            pop a
1623   0E3D C0 00 00      cmp b, 0
1624   0E40 C6 7D 0E      je _if28_else
1625   0E43             _if28_true:
1626   0E43 29 15 11      mov b, [datum]
1627   0E46 74            mov d, b
1628   0E47 DA            push d
1629   0E48 29 11 12      mov b, [datadr3]
1630   0E4B E7            pop d
1631   0E4C 10 02 00      mov a, 2
1632   0E4F AC            mul a, b
1633   0E50 5A            add d, b
1634   0E51 DA            push d
1635   0E52 29 15 11      mov b, [datum]
1636   0E55 D7            push a
1637   0E56 74            mov d, b
1638   0E57 DA            push d
1639   0E58 29 0D 12      mov b, [datadr1]
1640   0E5B E7            pop d
1641   0E5C 10 02 00      mov a, 2
1642   0E5F AC            mul a, b
1643   0E60 5A            add d, b
1644   0E61 2A            mov b, [d]
1645   0E62 11            mov a, b
1646   0E63 29 15 11      mov b, [datum]
1647   0E66 D7            push a
1648   0E67 74            mov d, b
1649   0E68 DA            push d
1650   0E69 29 0F 12      mov b, [datadr2]
1651   0E6C E7            pop d
1652   0E6D 10 02 00      mov a, 2
1653   0E70 AC            mul a, b
1654   0E71 5A            add d, b
1655   0E72 2A            mov b, [d]
1656   0E73 E4            pop a
1657   0E74 60            sub a, b
1658   0E75 27            mov b, a
1659   0E76 E4            pop a
1660   0E77 E7            pop d
1661   0E78 11            mov a, b
1662   0E79 43            mov [d], a
1663   0E7A 0A 7D 0F      jmp _if28_exit
1664   0E7D             _if28_else:
1665   0E7D             _if29_cond:
1666   0E7D 29 0B 12      mov b, [opr]
1667   0E80 D7            push a
1668   0E81 11            mov a, b
1669   0E82 26 0B 00      mov b, 11
1670   0E85 B0            cmp a, b
1671   0E86 0E            lodflgs
1672   0E87 87 01         and al, %00000001 ; ==
1673   0E89 B9 00         cmp al, 0
1674   0E8B 0E            lodflgs
1675   0E8C 96            not al
1676   0E8D 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1677   0E8F 22 00         mov ah, 0
1678   0E91 27            mov b, a
1679   0E92 E4            pop a
1680   0E93 C0 00 00      cmp b, 0
1681   0E96 C6 DC 0E      je _if29_else
1682   0E99             _if29_true:
1683   0E99 29 15 11      mov b, [datum]
1684   0E9C 74            mov d, b
1685   0E9D DA            push d
1686   0E9E 29 11 12      mov b, [datadr3]
1687   0EA1 E7            pop d
1688   0EA2 10 02 00      mov a, 2
1689   0EA5 AC            mul a, b
1690   0EA6 5A            add d, b
1691   0EA7 DA            push d
1692   0EA8 29 15 11      mov b, [datum]
1693   0EAB D7            push a
1694   0EAC 74            mov d, b
1695   0EAD DA            push d
1696   0EAE 29 0D 12      mov b, [datadr1]
1697   0EB1 E7            pop d
1698   0EB2 10 02 00      mov a, 2
1699   0EB5 AC            mul a, b
1700   0EB6 5A            add d, b
1701   0EB7 2A            mov b, [d]
1702   0EB8 11            mov a, b
1703   0EB9 29 15 11      mov b, [datum]
1704   0EBC D7            push a
1705   0EBD 74            mov d, b
1706   0EBE DA            push d
1707   0EBF 29 0F 12      mov b, [datadr2]
1708   0EC2 E7            pop d
1709   0EC3 10 02 00      mov a, 2
1710   0EC6 AC            mul a, b
1711   0EC7 5A            add d, b
1712   0EC8 2A            mov b, [d]
1713   0EC9 E4            pop a
1714   0ECA AC            mul a, b
1715   0ECB 11            mov a, b
1716   0ECC 26 64 00      mov b, 100
1717   0ECF AE            div a, b
1718   0ED0 FD 78         mov g, a
1719   0ED2 11            mov a, b
1720   0ED3 FD 27         mov b, g
1721   0ED5 E4            pop a
1722   0ED6 E7            pop d
1723   0ED7 11            mov a, b
1724   0ED8 43            mov [d], a
1725   0ED9 0A 7D 0F      jmp _if29_exit
1726   0EDC             _if29_else:
1727   0EDC             _if30_cond:
1728   0EDC 29 0B 12      mov b, [opr]
1729   0EDF D7            push a
1730   0EE0 11            mov a, b
1731   0EE1 26 0C 00      mov b, 12
1732   0EE4 B0            cmp a, b
1733   0EE5 0E            lodflgs
1734   0EE6 87 01         and al, %00000001 ; ==
1735   0EE8 B9 00         cmp al, 0
1736   0EEA 0E            lodflgs
1737   0EEB 96            not al
1738   0EEC 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1739   0EEE 22 00         mov ah, 0
1740   0EF0 27            mov b, a
1741   0EF1 E4            pop a
1742   0EF2 C0 00 00      cmp b, 0
1743   0EF5 C6 7D 0F      je _if30_exit
1744   0EF8             _if30_true:
1745   0EF8             _if31_cond:
1746   0EF8 29 15 11      mov b, [datum]
1747   0EFB D7            push a
1748   0EFC 74            mov d, b
1749   0EFD DA            push d
1750   0EFE 29 0F 12      mov b, [datadr2]
1751   0F01 E7            pop d
1752   0F02 10 02 00      mov a, 2
1753   0F05 AC            mul a, b
1754   0F06 5A            add d, b
1755   0F07 2A            mov b, [d]
1756   0F08 11            mov a, b
1757   0F09 26 00 00      mov b, 0
1758   0F0C B0            cmp a, b
1759   0F0D 0E            lodflgs
1760   0F0E 87 01         and al, %00000001
1761   0F10 8F 01         xor al, %00000001 ; !=
1762   0F12 B9 00         cmp al, 0
1763   0F14 0E            lodflgs
1764   0F15 96            not al
1765   0F16 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1766   0F18 22 00         mov ah, 0
1767   0F1A 27            mov b, a
1768   0F1B E4            pop a
1769   0F1C C0 00 00      cmp b, 0
1770   0F1F C6 65 0F      je _if31_else
1771   0F22             _if31_true:
1772   0F22 29 15 11      mov b, [datum]
1773   0F25 74            mov d, b
1774   0F26 DA            push d
1775   0F27 29 11 12      mov b, [datadr3]
1776   0F2A E7            pop d
1777   0F2B 10 02 00      mov a, 2
1778   0F2E AC            mul a, b
1779   0F2F 5A            add d, b
1780   0F30 DA            push d
1781   0F31 29 15 11      mov b, [datum]
1782   0F34 D7            push a
1783   0F35 74            mov d, b
1784   0F36 DA            push d
1785   0F37 29 0D 12      mov b, [datadr1]
1786   0F3A E7            pop d
1787   0F3B 10 02 00      mov a, 2
1788   0F3E AC            mul a, b
1789   0F3F 5A            add d, b
1790   0F40 2A            mov b, [d]
1791   0F41 11            mov a, b
1792   0F42 26 64 00      mov b, 100
1793   0F45 AC            mul a, b
1794   0F46 11            mov a, b
1795   0F47 29 15 11      mov b, [datum]
1796   0F4A D7            push a
1797   0F4B 74            mov d, b
1798   0F4C DA            push d
1799   0F4D 29 0F 12      mov b, [datadr2]
1800   0F50 E7            pop d
1801   0F51 10 02 00      mov a, 2
1802   0F54 AC            mul a, b
1803   0F55 5A            add d, b
1804   0F56 2A            mov b, [d]
1805   0F57 E4            pop a
1806   0F58 AE            div a, b
1807   0F59 FD 78         mov g, a
1808   0F5B 11            mov a, b
1809   0F5C FD 27         mov b, g
1810   0F5E E4            pop a
1811   0F5F E7            pop d
1812   0F60 11            mov a, b
1813   0F61 43            mov [d], a
1814   0F62 0A 7A 0F      jmp _if31_exit
1815   0F65             _if31_else:
1816   0F65 29 15 11      mov b, [datum]
1817   0F68 74            mov d, b
1818   0F69 DA            push d
1819   0F6A 29 11 12      mov b, [datadr3]
1820   0F6D E7            pop d
1821   0F6E 10 02 00      mov a, 2
1822   0F71 AC            mul a, b
1823   0F72 5A            add d, b
1824   0F73 DA            push d
1825   0F74 26 00 00      mov b, 0
1826   0F77 E7            pop d
1827   0F78 11            mov a, b
1828   0F79 43            mov [d], a
1829   0F7A             _if31_exit:
1830   0F7A 0A 7D 0F      jmp _if30_exit
1831   0F7D             _if30_exit:
1832   0F7D             _if29_exit:
1833   0F7D             _if28_exit:
1834   0F7D             _if27_exit:
1835   0F7D             _if26_exit:
1836   0F7D             _if25_exit:
1837   0F7D             _if24_exit:
1838   0F7D             _if23_exit:
1839   0F7D             _if20_exit:
1840   0F7D             _if19_exit:
1841   0F7D             _if32_cond:
1842   0F7D 29 0B 12      mov b, [opr]
1843   0F80 D7            push a
1844   0F81 11            mov a, b
1845   0F82 26 01 00      mov b, 1
1846   0F85 B0            cmp a, b
1847   0F86 0E            lodflgs
1848   0F87 87 01         and al, %00000001
1849   0F89 8F 01         xor al, %00000001 ; !=
1850   0F8B B9 00         cmp al, 0
1851   0F8D 0E            lodflgs
1852   0F8E 96            not al
1853   0F8F 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1854   0F91 22 00         mov ah, 0
1855   0F93 27            mov b, a
1856   0F94 E4            pop a
1857   0F95 C0 00 00      cmp b, 0
1858   0F98 C6 F1 0F      je _if32_exit
1859   0F9B             _if32_true:
1860   0F9B             _if33_cond:
1861   0F9B 29 13 12      mov b, [pc]
1862   0F9E D7            push a
1863   0F9F 11            mov a, b
1864   0FA0 26 00 00      mov b, 0
1865   0FA3 B0            cmp a, b
1866   0FA4 0E            lodflgs
1867   0FA5 87 03         and al, %00000011
1868   0FA7 B9 00         cmp al, %00000000
1869   0FA9 0E            lodflgs
1870   0FAA 87 01         and al, %00000001 ; >
1871   0FAC B9 00         cmp al, 0
1872   0FAE 0E            lodflgs
1873   0FAF 96            not al
1874   0FB0 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1875   0FB2 22 00         mov ah, 0
1876   0FB4 27            mov b, a
1877   0FB5 E4            pop a
1878   0FB6 C0 00 00      cmp b, 0
1879   0FB9 C6 C8 0F      je _if33_else
1880   0FBC             _if33_true:
1881   0FBC 29 13 12      mov b, [pc]
1882   0FBF FD 77         inc b
1883   0FC1 FD 42 13 12   mov [pc], b
1884   0FC5 0A EE 0F      jmp _if33_exit
1885   0FC8             _if33_else:
1886   0FC8             _if34_cond:
1887   0FC8 29 13 12      mov b, [pc]
1888   0FCB D7            push a
1889   0FCC 11            mov a, b
1890   0FCD 26 00 00      mov b, 0
1891   0FD0 B0            cmp a, b
1892   0FD1 0E            lodflgs
1893   0FD2 87 01         and al, %00000001 ; ==
1894   0FD4 B9 00         cmp al, 0
1895   0FD6 0E            lodflgs
1896   0FD7 96            not al
1897   0FD8 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1898   0FDA 22 00         mov ah, 0
1899   0FDC 27            mov b, a
1900   0FDD E4            pop a
1901   0FDE C0 00 00      cmp b, 0
1902   0FE1 C6 EE 0F      je _if34_exit
1903   0FE4             _if34_true:
1904   0FE4 26 1E 00      mov b, 30
1905   0FE7 FD 42 13 12   mov [pc], b
1906   0FEB 0A EE 0F      jmp _if34_exit
1907   0FEE             _if34_exit:
1908   0FEE             _if33_exit:
1909   0FEE 0A F1 0F      jmp _if32_exit
1910   0FF1             _if32_exit:
1911   0FF1 0A CB 07      jmp _while15_cond
1912   0FF4             _while15_exit:
1913   0FF4 0A F7 0F      jmp _if14_exit
1914   0FF7             _if14_exit:
1915   0FF7 0A 02 04      jmp _while1_cond
1916   0FFA             _while1_exit:
1917   0FFA             readint:
1918   0FFA D2            push bp
1919   0FFB 9B            mov bp, sp
1920   0FFC 52 02 00      sub sp, 2 ; n
1921   0FFF             
1922   0FFF             ; --- BEGIN INLINE ASM BLOCK
1923   0FFF 07 71 15      call scan_u16d
1924   1002 45 FF FF      mov [bp + -1], a
1925   1005             ; --- END INLINE ASM BLOCK
1926   1005             
1927   1005 2C FF FF      mov b, [bp + -1] ; n
1928   1008 F9            leave
1929   1009 09            ret
1930   100A             displaynumber:
1931   100A D2            push bp
1932   100B 9B            mov bp, sp
1933   100C             
1934   100C             ; --- BEGIN INLINE ASM BLOCK
1935   100C 17 05 00      mov a, [bp + 5]
1936   100F 07 9C 14      call print_u16d
1937   1012 14 1D 10      mov a, [ss]
1938   1015 3C            mov d, a
1939   1016 07 73 14      call puts
1940   1019             ; --- END INLINE ASM BLOCK
1941   1019             
1942   1019 F9            leave
1943   101A 09            ret
1944   101B             ; --- END TEXT BLOCK
1945   101B             
1946   101B             ; --- BEGIN DATA BLOCK
1947   101B 0A 00       ss_data: .db "\n", 0
1948   101D 1B 10       ss: .dw ss_data
1949   101F 00 00 00 00 datum_data: .fill 246, 0
1949   1023 00 00 00 00 
1949   1027 00 00 00 00 
1949   102B 00 00 00 00 
1949   102F 00 00 00 00 
1949   1033 00 00 00 00 
1949   1037 00 00 00 00 
1949   103B 00 00 00 00 
1949   103F 00 00 00 00 
1949   1043 00 00 00 00 
1949   1047 00 00 00 00 
1949   104B 00 00 00 00 
1949   104F 00 00 00 00 
1949   1053 00 00 00 00 
1949   1057 00 00 00 00 
1949   105B 00 00 00 00 
1949   105F 00 00 00 00 
1949   1063 00 00 00 00 
1949   1067 00 00 00 00 
1949   106B 00 00 00 00 
1949   106F 00 00 00 00 
1949   1073 00 00 00 00 
1949   1077 00 00 00 00 
1949   107B 00 00 00 00 
1949   107F 00 00 00 00 
1949   1083 00 00 00 00 
1949   1087 00 00 00 00 
1949   108B 00 00 00 00 
1949   108F 00 00 00 00 
1949   1093 00 00 00 00 
1949   1097 00 00 00 00 
1949   109B 00 00 00 00 
1949   109F 00 00 00 00 
1949   10A3 00 00 00 00 
1949   10A7 00 00 00 00 
1949   10AB 00 00 00 00 
1949   10AF 00 00 00 00 
1949   10B3 00 00 00 00 
1949   10B7 00 00 00 00 
1949   10BB 00 00 00 00 
1949   10BF 00 00 00 00 
1949   10C3 00 00 00 00 
1949   10C7 00 00 00 00 
1949   10CB 00 00 00 00 
1949   10CF 00 00 00 00 
1949   10D3 00 00 00 00 
1949   10D7 00 00 00 00 
1949   10DB 00 00 00 00 
1949   10DF 00 00 00 00 
1949   10E3 00 00 00 00 
1949   10E7 00 00 00 00 
1949   10EB 00 00 00 00 
1949   10EF 00 00 00 00 
1949   10F3 00 00 00 00 
1949   10F7 00 00 00 00 
1949   10FB 00 00 00 00 
1949   10FF 00 00 00 00 
1949   1103 00 00 00 00 
1949   1107 00 00 00 00 
1949   110B 00 00 00 00 
1949   110F 00 00 00 00 
1949   1113 00 00 
1950   1115 1F 10       datum: .dw datum_data
1951   1117 00 00 00 00 instruction_data: .fill 240, 0
1951   111B 00 00 00 00 
1951   111F 00 00 00 00 
1951   1123 00 00 00 00 
1951   1127 00 00 00 00 
1951   112B 00 00 00 00 
1951   112F 00 00 00 00 
1951   1133 00 00 00 00 
1951   1137 00 00 00 00 
1951   113B 00 00 00 00 
1951   113F 00 00 00 00 
1951   1143 00 00 00 00 
1951   1147 00 00 00 00 
1951   114B 00 00 00 00 
1951   114F 00 00 00 00 
1951   1153 00 00 00 00 
1951   1157 00 00 00 00 
1951   115B 00 00 00 00 
1951   115F 00 00 00 00 
1951   1163 00 00 00 00 
1951   1167 00 00 00 00 
1951   116B 00 00 00 00 
1951   116F 00 00 00 00 
1951   1173 00 00 00 00 
1951   1177 00 00 00 00 
1951   117B 00 00 00 00 
1951   117F 00 00 00 00 
1951   1183 00 00 00 00 
1951   1187 00 00 00 00 
1951   118B 00 00 00 00 
1951   118F 00 00 00 00 
1951   1193 00 00 00 00 
1951   1197 00 00 00 00 
1951   119B 00 00 00 00 
1951   119F 00 00 00 00 
1951   11A3 00 00 00 00 
1951   11A7 00 00 00 00 
1951   11AB 00 00 00 00 
1951   11AF 00 00 00 00 
1951   11B3 00 00 00 00 
1951   11B7 00 00 00 00 
1951   11BB 00 00 00 00 
1951   11BF 00 00 00 00 
1951   11C3 00 00 00 00 
1951   11C7 00 00 00 00 
1951   11CB 00 00 00 00 
1951   11CF 00 00 00 00 
1951   11D3 00 00 00 00 
1951   11D7 00 00 00 00 
1951   11DB 00 00 00 00 
1951   11DF 00 00 00 00 
1951   11E3 00 00 00 00 
1951   11E7 00 00 00 00 
1951   11EB 00 00 00 00 
1951   11EF 00 00 00 00 
1951   11F3 00 00 00 00 
1951   11F7 00 00 00 00 
1951   11FB 00 00 00 00 
1951   11FF 00 00 00 00 
1951   1203 00 00 00 00 
1952   1207 17 11       instruction: .dw instruction_data
1953   1209 00 00       cmdadr: .dw 0
1954   120B 00 00       opr: .dw 0
1955   120D 00 00       datadr1: .dw 0
1956   120F 00 00       datadr2: .dw 0
1957   1211 00 00       datadr3: .dw 0
1958   1213 00 00       pc: .dw 0
1959   1215 00 00       h: .dw 0
1960   1217 00 00       i: .dw 0
1961   1219 00 00       j: .dw 0
1962   121B 00 00       k: .dw 0
1963   121D 00 00       l: .dw 0
1964   121F 00 00       p: .dw 0
1965   1221 00 00       runlimit: .dw 0
1966   1223 00 00       exitflag: .dw 0
1967   1225 00 00       exitexec: .dw 0
1968   1227             ; --- END DATA BLOCK
1969   1227             
1970   1227             ; --- BEGIN INCLUDE BLOCK
1971   1227             .include "lib/stdio.asm"
0001+  1227             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  1227             ; stdio.s
0003+  1227             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  1227             .include "lib/string.asm"
0001++ 1227             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 1227             ; string.s
0003++ 1227             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 1227             
0005++ 1227             
0006++ 1227             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 1227             ; strrev
0008++ 1227             ; reverse a string
0009++ 1227             ; D = string address
0010++ 1227             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 1227             ; 01234
0012++ 1227             strrev:
0013++ 1227 4B          	pusha
0014++ 1228 07 6E 12    	call strlen	; length in C
0015++ 122B 12          	mov a, c
0016++ 122C AF 01 00    	cmp a, 1
0017++ 122F D0 49 12    	jleu strrev_end	; check string length. string len must be > 1
0018++ 1232 7D          	dec a
0019++ 1233 FD 4E       	mov si, d	; beginning of string
0020++ 1235 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 1237 59          	add d, a	; end of string
0022++ 1238 12          	mov a, c
0023++ 1239 FD 9B       	shr a		; divide by 2
0024++ 123B 39          	mov c, a	; C now counts the steps
0025++ 123C             strrev_L0:
0026++ 123C 32          	mov bl, [d]	; save load right-side char into BL
0027++ 123D F6          	lodsb		; load left-side char into AL; increase SI
0028++ 123E 3E          	mov [d], al	; store left char into right side
0029++ 123F 1B          	mov al, bl
0030++ 1240 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 1241 7E          	dec c
0032++ 1242 7F          	dec d
0033++ 1243 C2 00 00    	cmp c, 0
0034++ 1246 C7 3C 12    	jne strrev_L0
0035++ 1249             strrev_end:
0036++ 1249 4C          	popa
0037++ 124A 09          	ret
0038++ 124B             	
0039++ 124B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 124B             ; strchr
0041++ 124B             ; search string in D for char in AL
0042++ 124B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 124B             strchr:
0044++ 124B             strchr_L0:
0045++ 124B 32          	mov bl, [d]
0046++ 124C C1 00       	cmp bl, 0
0047++ 124E C6 59 12    	je strchr_end
0048++ 1251 BA          	cmp al, bl
0049++ 1252 C6 59 12    	je strchr_end
0050++ 1255 79          	inc d
0051++ 1256 0A 4B 12    	jmp strchr_L0
0052++ 1259             strchr_end:
0053++ 1259 1B          	mov al, bl
0054++ 125A 09          	ret
0055++ 125B             
0056++ 125B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 125B             ; strstr
0058++ 125B             ; find sub-string
0059++ 125B             ; str1 in SI
0060++ 125B             ; str2 in DI
0061++ 125B             ; SI points to end of source string
0062++ 125B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 125B             strstr:
0064++ 125B DB          	push al
0065++ 125C DA          	push d
0066++ 125D E3          	push di
0067++ 125E             strstr_loop:
0068++ 125E F3          	cmpsb					; compare a byte of the strings
0069++ 125F C7 6A 12    	jne strstr_ret
0070++ 1262 FC 00 00    	lea d, [di + 0]
0071++ 1265 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 1267 C7 5E 12    	jne strstr_loop				; equal chars but not at end
0073++ 126A             strstr_ret:
0074++ 126A F0          	pop di
0075++ 126B E7          	pop d
0076++ 126C E8          	pop al
0077++ 126D 09          	ret
0078++ 126E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 126E             ; length of null terminated string
0080++ 126E             ; result in C
0081++ 126E             ; pointer in D
0082++ 126E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 126E             strlen:
0084++ 126E DA          	push d
0085++ 126F 38 00 00    	mov c, 0
0086++ 1272             strlen_L1:
0087++ 1272 BD 00       	cmp byte [d], 0
0088++ 1274 C6 7C 12    	je strlen_ret
0089++ 1277 79          	inc d
0090++ 1278 78          	inc c
0091++ 1279 0A 72 12    	jmp strlen_L1
0092++ 127C             strlen_ret:
0093++ 127C E7          	pop d
0094++ 127D 09          	ret
0095++ 127E             
0096++ 127E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 127E             ; STRCMP
0098++ 127E             ; compare two strings
0099++ 127E             ; str1 in SI
0100++ 127E             ; str2 in DI
0101++ 127E             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 127E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 127E             strcmp:
0104++ 127E DB          	push al
0105++ 127F DA          	push d
0106++ 1280 E3          	push di
0107++ 1281 E2          	push si
0108++ 1282             strcmp_loop:
0109++ 1282 F3          	cmpsb					; compare a byte of the strings
0110++ 1283 C7 8E 12    	jne strcmp_ret
0111++ 1286 FB FF FF    	lea d, [si +- 1]
0112++ 1289 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 128B C7 82 12    	jne strcmp_loop				; equal chars but not at end
0114++ 128E             strcmp_ret:
0115++ 128E EF          	pop si
0116++ 128F F0          	pop di
0117++ 1290 E7          	pop d
0118++ 1291 E8          	pop al
0119++ 1292 09          	ret
0120++ 1293             
0121++ 1293             
0122++ 1293             ; STRCPY
0123++ 1293             ; copy null terminated string from SI to DI
0124++ 1293             ; source in SI
0125++ 1293             ; destination in DI
0126++ 1293             strcpy:
0127++ 1293 E2          	push si
0128++ 1294 E3          	push di
0129++ 1295 DB          	push al
0130++ 1296             strcpy_L1:
0131++ 1296 F6          	lodsb
0132++ 1297 F7          	stosb
0133++ 1298 B9 00       	cmp al, 0
0134++ 129A C7 96 12    	jne strcpy_L1
0135++ 129D             strcpy_end:
0136++ 129D E8          	pop al
0137++ 129E F0          	pop di
0138++ 129F EF          	pop si
0139++ 12A0 09          	ret
0140++ 12A1             
0141++ 12A1             ; STRCAT
0142++ 12A1             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 12A1             ; source in SI
0144++ 12A1             ; destination in DI
0145++ 12A1             strcat:
0146++ 12A1 E2          	push si
0147++ 12A2 E3          	push di
0148++ 12A3 D7          	push a
0149++ 12A4 DA          	push d
0150++ 12A5 50          	mov a, di
0151++ 12A6 3C          	mov d, a
0152++ 12A7             strcat_goto_end_L1:
0153++ 12A7 BD 00       	cmp byte[d], 0
0154++ 12A9 C6 B0 12    	je strcat_start
0155++ 12AC 79          	inc d
0156++ 12AD 0A A7 12    	jmp strcat_goto_end_L1
0157++ 12B0             strcat_start:
0158++ 12B0 FD 50       	mov di, d
0159++ 12B2             strcat_L1:
0160++ 12B2 F6          	lodsb
0161++ 12B3 F7          	stosb
0162++ 12B4 B9 00       	cmp al, 0
0163++ 12B6 C7 B2 12    	jne strcat_L1
0164++ 12B9             strcat_end:
0165++ 12B9 E7          	pop d
0166++ 12BA E4          	pop a
0167++ 12BB F0          	pop di
0168++ 12BC EF          	pop si
0169++ 12BD 09          	ret
0005+  12BE             
0006+  12BE 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  12C2 34 35 36 37 
0006+  12C6 38 39 41 42 
0006+  12CA 43 44 45 46 
0007+  12CE 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  12D2 1B 5B 48 00 
0008+  12D6             
0009+  12D6 01 00       table_power:.dw 1
0010+  12D8 0A 00       			.dw 10
0011+  12DA 64 00       			.dw 100
0012+  12DC E8 03       			.dw 1000
0013+  12DE 10 27       			.dw 10000
0014+  12E0             
0015+  12E0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  12E0             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  12E0             ; ASCII in BL
0018+  12E0             ; result in AL
0019+  12E0             ; ascii for F = 0100 0110
0020+  12E0             ; ascii for 9 = 0011 1001
0021+  12E0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  12E0             hex_ascii_encode:
0023+  12E0 1B          	mov al, bl
0024+  12E1 93 40       	test al, $40				; test if letter or number
0025+  12E3 C7 E9 12    	jnz hex_letter
0026+  12E6 87 0F       	and al, $0F				; get number
0027+  12E8 09          	ret
0028+  12E9             hex_letter:
0029+  12E9 87 0F       	and al, $0F				; get letter
0030+  12EB 6A 09       	add al, 9
0031+  12ED 09          	ret
0032+  12EE             
0033+  12EE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  12EE             ; ATOI
0035+  12EE             ; 2 letter hex string in B
0036+  12EE             ; 8bit integer returned in AL
0037+  12EE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  12EE             atoi:
0039+  12EE D8          	push b
0040+  12EF 07 E0 12    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  12F2 30          	mov bl, bh
0042+  12F3 DB          	push al					; save a
0043+  12F4 07 E0 12    	call hex_ascii_encode
0044+  12F7 EA          	pop bl	
0045+  12F8 FD 9E 04    	shl al, 4
0046+  12FB 8C          	or al, bl
0047+  12FC E5          	pop b
0048+  12FD 09          	ret	
0049+  12FE             
0050+  12FE             
0051+  12FE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  12FE             ; printf
0053+  12FE             ; no need for explanations!
0054+  12FE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  12FE             printf:
0056+  12FE 09          	ret
0057+  12FF             
0058+  12FF             
0059+  12FF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  12FF             ; scanf
0061+  12FF             ; no need for explanations!
0062+  12FF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  12FF             scanf:
0064+  12FF 09          	ret
0065+  1300             
0066+  1300             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  1300             ; ITOA
0068+  1300             ; 8bit value in BL
0069+  1300             ; 2 byte ASCII result in A
0070+  1300             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  1300             itoa:
0072+  1300 DA          	push d
0073+  1301 D8          	push b
0074+  1302 A7 00       	mov bh, 0
0075+  1304 FD A4 04    	shr bl, 4	
0076+  1307 74          	mov d, b
0077+  1308 1F BE 12    	mov al, [d + s_hex_digits]
0078+  130B 23          	mov ah, al
0079+  130C             	
0080+  130C E5          	pop b
0081+  130D D8          	push b
0082+  130E A7 00       	mov bh, 0
0083+  1310 FD 87 0F    	and bl, $0F
0084+  1313 74          	mov d, b
0085+  1314 1F BE 12    	mov al, [d + s_hex_digits]
0086+  1317 E5          	pop b
0087+  1318 E7          	pop d
0088+  1319 09          	ret
0089+  131A             
0090+  131A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  131A             ; HEX STRING TO BINARY
0092+  131A             ; di = destination address
0093+  131A             ; si = source
0094+  131A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  131A             hex_to_int:
0096+  131A             hex_to_int_L1:
0097+  131A F6          	lodsb					; load from [SI] to AL
0098+  131B B9 00       	cmp al, 0				; check if ASCII 0
0099+  131D C6 2A 13    	jz hex_to_int_ret
0100+  1320 36          	mov bh, al
0101+  1321 F6          	lodsb
0102+  1322 2F          	mov bl, al
0103+  1323 07 EE 12    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  1326 F7          	stosb					; store AL to [DI]
0105+  1327 0A 1A 13    	jmp hex_to_int_L1
0106+  132A             hex_to_int_ret:
0107+  132A 09          	ret		
0108+  132B             
0109+  132B             
0110+  132B             
0111+  132B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  132B             ; GETCHAR
0113+  132B             ; char in ah
0114+  132B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  132B             getchar:
0116+  132B DB          	push al
0117+  132C             getchar_retry:
0118+  132C FD 0C       	sti
0119+  132E 19 01       	mov al, 1
0120+  1330 05 03       	syscall sys_io			; receive in AH
0121+  1332 B9 00       	cmp al, 0			; check if any char was receive
0122+  1334 C6 2C 13    	je getchar_retry
0123+  1337 E8          	pop al
0124+  1338 09          	ret
0125+  1339             
0126+  1339             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  1339             ; PUTCHAR
0128+  1339             ; char in ah
0129+  1339             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  1339             putchar:
0131+  1339 D7          	push a
0132+  133A 19 00       	mov al, 0
0133+  133C 05 03       	syscall sys_io			; char in AH
0134+  133E E4          	pop a
0135+  133F 09          	ret
0136+  1340             
0137+  1340             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  1340             ;; INPUT A STRING
0139+  1340             ;; terminates with null
0140+  1340             ;; pointer in D
0141+  1340             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  1340             gets:
0143+  1340 D7          	push a
0144+  1341 DA          	push d
0145+  1342             gets_loop:
0146+  1342 FD 0C       	sti
0147+  1344 19 01       	mov al, 1
0148+  1346 05 03       	syscall sys_io			; receive in AH
0149+  1348 B9 00       	cmp al, 0				; check error code (AL)
0150+  134A C6 42 13    	je gets_loop			; if no char received, retry
0151+  134D             
0152+  134D 76 1B       	cmp ah, 27
0153+  134F C6 70 13    	je gets_telnet_escape
0154+  1352 76 0A       	cmp ah, $0A				; LF
0155+  1354 C6 C9 13    	je gets_end
0156+  1357 76 0D       	cmp ah, $0D				; CR
0157+  1359 C6 C9 13    	je gets_end
0158+  135C 76 5C       	cmp ah, $5C				; '\\'
0159+  135E C6 A0 13    	je gets_escape
0160+  1361             	
0161+  1361 76 08       	cmp ah, $08			; check for backspace
0162+  1363 C6 6C 13    	je gets_backspace
0163+  1366             
0164+  1366 1A          	mov al, ah
0165+  1367 3E          	mov [d], al
0166+  1368 79          	inc d
0167+  1369 0A 42 13    	jmp gets_loop
0168+  136C             gets_backspace:
0169+  136C 7F          	dec d
0170+  136D 0A 42 13    	jmp gets_loop
0171+  1370             gets_telnet_escape:
0172+  1370 FD 0C       	sti
0173+  1372 19 01       	mov al, 1
0174+  1374 05 03       	syscall sys_io				; receive in AH without echo
0175+  1376 B9 00       	cmp al, 0					; check error code (AL)
0176+  1378 C6 70 13    	je gets_telnet_escape		; if no char received, retry
0177+  137B 76 5B       	cmp ah, '['
0178+  137D C7 42 13    	jne gets_loop
0179+  1380             gets_telnet_escape_phase2:
0180+  1380 FD 0C       	sti
0181+  1382 19 01       	mov al, 1
0182+  1384 05 03       	syscall sys_io					; receive in AH without echo
0183+  1386 B9 00       	cmp al, 0						; check error code (AL)
0184+  1388 C6 80 13    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  138B 76 44       	cmp ah, 'D'
0186+  138D C6 98 13    	je gets_left_arrow
0187+  1390 76 43       	cmp ah, 'C'
0188+  1392 C6 9C 13    	je gets_right_arrow
0189+  1395 0A 42 13    	jmp gets_loop
0190+  1398             gets_left_arrow:
0191+  1398 7F          	dec d
0192+  1399 0A 42 13    	jmp gets_loop
0193+  139C             gets_right_arrow:
0194+  139C 79          	inc d
0195+  139D 0A 42 13    	jmp gets_loop
0196+  13A0             gets_escape:
0197+  13A0 FD 0C       	sti
0198+  13A2 19 01       	mov al, 1
0199+  13A4 05 03       	syscall sys_io			; receive in AH
0200+  13A6 B9 00       	cmp al, 0				; check error code (AL)
0201+  13A8 C6 A0 13    	je gets_escape			; if no char received, retry
0202+  13AB 76 6E       	cmp ah, 'n'
0203+  13AD C6 BB 13    	je gets_LF
0204+  13B0 76 72       	cmp ah, 'r'
0205+  13B2 C6 C2 13    	je gets_CR
0206+  13B5 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  13B6 3E          	mov [d], al
0208+  13B7 79          	inc d
0209+  13B8 0A 42 13    	jmp gets_loop
0210+  13BB             gets_LF:
0211+  13BB 19 0A       	mov al, $0A
0212+  13BD 3E          	mov [d], al
0213+  13BE 79          	inc d
0214+  13BF 0A 42 13    	jmp gets_loop
0215+  13C2             gets_CR:
0216+  13C2 19 0D       	mov al, $0D
0217+  13C4 3E          	mov [d], al
0218+  13C5 79          	inc d
0219+  13C6 0A 42 13    	jmp gets_loop
0220+  13C9             gets_end:
0221+  13C9 19 00       	mov al, 0
0222+  13CB 3E          	mov [d], al				; terminate string
0223+  13CC E7          	pop d
0224+  13CD E4          	pop a
0225+  13CE 09          	ret
0226+  13CF             
0227+  13CF             
0228+  13CF             
0229+  13CF             
0230+  13CF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  13CF             ;; INPUT TEXT
0232+  13CF             ;; terminated with CTRL+D
0233+  13CF             ;; pointer in D
0234+  13CF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  13CF             gettxt:
0236+  13CF D7          	push a
0237+  13D0 DA          	push d
0238+  13D1             gettxt_loop:
0239+  13D1 19 01       	mov al, 1
0240+  13D3 05 03       	syscall sys_io			; receive in AH
0241+  13D5 B9 00       	cmp al, 0				; check error code (AL)
0242+  13D7 C6 D1 13    	je gettxt_loop		; if no char received, retry
0243+  13DA 76 04       	cmp ah, 4			; EOT
0244+  13DC C6 1A 14    	je gettxt_end
0245+  13DF 76 08       	cmp ah, $08			; check for backspace
0246+  13E1 C6 16 14    	je gettxt_backspace
0247+  13E4 76 5C       	cmp ah, $5C				; '\\'
0248+  13E6 C6 EF 13    	je gettxt_escape
0249+  13E9 1A          	mov al, ah
0250+  13EA 3E          	mov [d], al
0251+  13EB 79          	inc d
0252+  13EC 0A D1 13    	jmp gettxt_loop
0253+  13EF             gettxt_escape:
0254+  13EF 19 01       	mov al, 1
0255+  13F1 05 03       	syscall sys_io			; receive in AH
0256+  13F3 B9 00       	cmp al, 0				; check error code (AL)
0257+  13F5 C6 EF 13    	je gettxt_escape		; if no char received, retry
0258+  13F8 76 6E       	cmp ah, 'n'
0259+  13FA C6 08 14    	je gettxt_LF
0260+  13FD 76 72       	cmp ah, 'r'
0261+  13FF C6 0F 14    	je gettxt_CR
0262+  1402 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  1403 3E          	mov [d], al
0264+  1404 79          	inc d
0265+  1405 0A D1 13    	jmp gettxt_loop
0266+  1408             gettxt_LF:
0267+  1408 19 0A       	mov al, $0A
0268+  140A 3E          	mov [d], al
0269+  140B 79          	inc d
0270+  140C 0A D1 13    	jmp gettxt_loop
0271+  140F             gettxt_CR:
0272+  140F 19 0D       	mov al, $0D
0273+  1411 3E          	mov [d], al
0274+  1412 79          	inc d
0275+  1413 0A D1 13    	jmp gettxt_loop
0276+  1416             gettxt_backspace:
0277+  1416 7F          	dec d
0278+  1417 0A D1 13    	jmp gettxt_loop
0279+  141A             gettxt_end:
0280+  141A 19 00       	mov al, 0
0281+  141C 3E          	mov [d], al				; terminate string
0282+  141D E7          	pop d
0283+  141E E4          	pop a
0284+  141F 09          	ret
0285+  1420             
0286+  1420             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  1420             ; PRINT NEW LINE
0288+  1420             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  1420             printnl:
0290+  1420 D7          	push a
0291+  1421 10 00 0A    	mov a, $0A00
0292+  1424 05 03       	syscall sys_io
0293+  1426 10 00 0D    	mov a, $0D00
0294+  1429 05 03       	syscall sys_io
0295+  142B E4          	pop a
0296+  142C 09          	ret
0297+  142D             
0298+  142D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  142D             ; strtoint
0300+  142D             ; 4 digit hex string number in d
0301+  142D             ; integer returned in A
0302+  142D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  142D             strtointx:
0304+  142D D8          	push b
0305+  142E 32          	mov bl, [d]
0306+  142F 37          	mov bh, bl
0307+  1430 33 01 00    	mov bl, [d + 1]
0308+  1433 07 EE 12    	call atoi				; convert to int in AL
0309+  1436 23          	mov ah, al				; move to AH
0310+  1437 33 02 00    	mov bl, [d + 2]
0311+  143A 37          	mov bh, bl
0312+  143B 33 03 00    	mov bl, [d + 3]
0313+  143E 07 EE 12    	call atoi				; convert to int in AL
0314+  1441 E5          	pop b
0315+  1442 09          	ret
0316+  1443             
0317+  1443             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  1443             ; strtoint
0319+  1443             ; 5 digit base10 string number in d
0320+  1443             ; integer returned in A
0321+  1443             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  1443             strtoint:
0323+  1443 E2          	push si
0324+  1444 D8          	push b
0325+  1445 D9          	push c
0326+  1446 DA          	push d
0327+  1447 07 6E 12    	call strlen			; get string length in C
0328+  144A 7E          	dec c
0329+  144B FD 4E       	mov si, d
0330+  144D 12          	mov a, c
0331+  144E FD 99       	shl a
0332+  1450 3B D6 12    	mov d, table_power
0333+  1453 59          	add d, a
0334+  1454 38 00 00    	mov c, 0
0335+  1457             strtoint_L0:
0336+  1457 F6          	lodsb			; load ASCII to al
0337+  1458 B9 00       	cmp al, 0
0338+  145A C6 6D 14    	je strtoint_end
0339+  145D 6F 30       	sub al, $30		; make into integer
0340+  145F 22 00       	mov ah, 0
0341+  1461 2A          	mov b, [d]
0342+  1462 AC          	mul a, b			; result in B since it fits in 16bits
0343+  1463 11          	mov a, b
0344+  1464 28          	mov b, c
0345+  1465 54          	add a, b
0346+  1466 39          	mov c, a
0347+  1467 63 02 00    	sub d, 2
0348+  146A 0A 57 14    	jmp strtoint_L0
0349+  146D             strtoint_end:
0350+  146D 12          	mov a, c
0351+  146E E7          	pop d
0352+  146F E6          	pop c
0353+  1470 E5          	pop b
0354+  1471 EF          	pop si
0355+  1472 09          	ret
0356+  1473             
0357+  1473             
0358+  1473             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  1473             ; PRINT NULL TERMINATED STRING
0360+  1473             ; pointer in D
0361+  1473             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  1473             puts:
0363+  1473 D7          	push a
0364+  1474 DA          	push d
0365+  1475             puts_L1:
0366+  1475 1E          	mov al, [d]
0367+  1476 B9 00       	cmp al, 0
0368+  1478 C6 84 14    	jz puts_END
0369+  147B 23          	mov ah, al
0370+  147C 19 00       	mov al, 0
0371+  147E 05 03       	syscall sys_io
0372+  1480 79          	inc d
0373+  1481 0A 75 14    	jmp puts_L1
0374+  1484             puts_END:
0375+  1484 E7          	pop d
0376+  1485 E4          	pop a
0377+  1486 09          	ret
0378+  1487             
0379+  1487             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  1487             ; PRINT N SIZE STRING
0381+  1487             ; pointer in D
0382+  1487             ; size in C
0383+  1487             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  1487             putsn:
0385+  1487 DB          	push al
0386+  1488 DA          	push d
0387+  1489 D9          	push c
0388+  148A             putsn_L0:
0389+  148A 1E          	mov al, [d]
0390+  148B 23          	mov ah, al
0391+  148C 19 00       	mov al, 0
0392+  148E 05 03       	syscall sys_io
0393+  1490 79          	inc d
0394+  1491 7E          	dec c	
0395+  1492 C2 00 00    	cmp c, 0
0396+  1495 C7 8A 14    	jne putsn_L0
0397+  1498             putsn_end:
0398+  1498 E6          	pop c
0399+  1499 E7          	pop d
0400+  149A E8          	pop al
0401+  149B 09          	ret
0402+  149C             
0403+  149C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  149C             ; print 16bit decimal number
0405+  149C             ; input number in A
0406+  149C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  149C             print_u16d:
0408+  149C D7          	push a
0409+  149D D8          	push b
0410+  149E 26 10 27    	mov b, 10000
0411+  14A1 AE          	div a, b			; get 10000 coeff.
0412+  14A2 07 C8 14    	call print_number
0413+  14A5 11          	mov a, b
0414+  14A6 26 E8 03    	mov b, 1000
0415+  14A9 AE          	div a, b			; get 10000 coeff.
0416+  14AA 07 C8 14    	call print_number
0417+  14AD 11          	mov a, b
0418+  14AE 26 64 00    	mov b, 100
0419+  14B1 AE          	div a, b
0420+  14B2 07 C8 14    	call print_number
0421+  14B5 11          	mov a, b
0422+  14B6 26 0A 00    	mov b, 10
0423+  14B9 AE          	div a, b
0424+  14BA 07 C8 14    	call print_number
0425+  14BD 11          	mov a, b
0426+  14BE 6A 30       	add al, $30
0427+  14C0 23          	mov ah, al
0428+  14C1 19 00       	mov al, 0
0429+  14C3 05 03       	syscall sys_io	; print coeff
0430+  14C5 E5          	pop b
0431+  14C6 E4          	pop a
0432+  14C7 09          	ret
0433+  14C8             
0434+  14C8             
0435+  14C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  14C8             ; if A == 0, print space
0437+  14C8             ; else print A
0438+  14C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0439+  14C8             print_number:
0440+  14C8 6A 30       	add al, $30
0441+  14CA 23          	mov ah, al
0442+  14CB 07 39 13    	call putchar
0443+  14CE 09          	ret
0444+  14CF             
0445+  14CF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0446+  14CF             ; PRINT 16BIT HEX INTEGER
0447+  14CF             ; integer value in reg B
0448+  14CF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  14CF             print_u16x:
0450+  14CF D7          	push a
0451+  14D0 D8          	push b
0452+  14D1 DD          	push bl
0453+  14D2 30          	mov bl, bh
0454+  14D3 07 00 13    	call itoa				; convert bh to char in A
0455+  14D6 2F          	mov bl, al				; save al
0456+  14D7 19 00       	mov al, 0
0457+  14D9 05 03       	syscall sys_io				; display AH
0458+  14DB 24          	mov ah, bl				; retrieve al
0459+  14DC 19 00       	mov al, 0
0460+  14DE 05 03       	syscall sys_io				; display AL
0461+  14E0             
0462+  14E0 EA          	pop bl
0463+  14E1 07 00 13    	call itoa				; convert bh to char in A
0464+  14E4 2F          	mov bl, al				; save al
0465+  14E5 19 00       	mov al, 0
0466+  14E7 05 03       	syscall sys_io				; display AH
0467+  14E9 24          	mov ah, bl				; retrieve al
0468+  14EA 19 00       	mov al, 0
0469+  14EC 05 03       	syscall sys_io				; display AL
0470+  14EE             
0471+  14EE E5          	pop b
0472+  14EF E4          	pop a
0473+  14F0 09          	ret
0474+  14F1             
0475+  14F1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  14F1             ; INPUT 16BIT HEX INTEGER
0477+  14F1             ; read 16bit integer into A
0478+  14F1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  14F1             scan_u16x:
0480+  14F1 F8 10 00    	enter 16
0481+  14F4 D8          	push b
0482+  14F5 DA          	push d
0483+  14F6             
0484+  14F6 FA F1 FF    	lea d, [bp + -15]
0485+  14F9 07 40 13    	call gets				; get number
0486+  14FC             
0487+  14FC 32          	mov bl, [d]
0488+  14FD 37          	mov bh, bl
0489+  14FE 33 01 00    	mov bl, [d + 1]
0490+  1501 07 EE 12    	call atoi				; convert to int in AL
0491+  1504 23          	mov ah, al				; move to AH
0492+  1505             
0493+  1505 33 02 00    	mov bl, [d + 2]
0494+  1508 37          	mov bh, bl
0495+  1509 33 03 00    	mov bl, [d + 3]
0496+  150C 07 EE 12    	call atoi				; convert to int in AL
0497+  150F             
0498+  150F E7          	pop d
0499+  1510 E5          	pop b
0500+  1511 F9          	leave
0501+  1512 09          	ret
0502+  1513             
0503+  1513             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0504+  1513             ; PRINT 8bit HEX INTEGER
0505+  1513             ; integer value in reg bl
0506+  1513             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  1513             print_u8x:
0508+  1513 D7          	push a
0509+  1514 DD          	push bl
0510+  1515             
0511+  1515 07 00 13    	call itoa				; convert bl to char in A
0512+  1518 2F          	mov bl, al				; save al
0513+  1519 19 00       	mov al, 0
0514+  151B 05 03       	syscall sys_io				; display AH
0515+  151D 24          	mov ah, bl				; retrieve al
0516+  151E 19 00       	mov al, 0
0517+  1520 05 03       	syscall sys_io				; display AL
0518+  1522             
0519+  1522 EA          	pop bl
0520+  1523 E4          	pop a
0521+  1524 09          	ret
0522+  1525             
0523+  1525             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0524+  1525             ; print 8bit decimal unsigned number
0525+  1525             ; input number in AL
0526+  1525             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  1525             print_u8d:
0528+  1525 D7          	push a
0529+  1526 D8          	push b
0530+  1527             
0531+  1527 22 00       	mov ah, 0
0532+  1529 26 64 00    	mov b, 100
0533+  152C AE          	div a, b
0534+  152D D8          	push b			; save remainder
0535+  152E B9 00       	cmp al, 0
0536+  1530 C6 3A 15    	je skip100
0537+  1533 6A 30       	add al, $30
0538+  1535 23          	mov ah, al
0539+  1536 19 00       	mov al, 0
0540+  1538 05 03       	syscall sys_io	; print coeff
0541+  153A             skip100:
0542+  153A E4          	pop a
0543+  153B 22 00       	mov ah, 0
0544+  153D 26 0A 00    	mov b, 10
0545+  1540 AE          	div a, b
0546+  1541 D8          	push b			; save remainder
0547+  1542 B9 00       	cmp al, 0
0548+  1544 C6 4E 15    	je skip10
0549+  1547 6A 30       	add al, $30
0550+  1549 23          	mov ah, al
0551+  154A 19 00       	mov al, 0
0552+  154C 05 03       	syscall sys_io	; print coeff
0553+  154E             skip10:
0554+  154E E4          	pop a
0555+  154F 1B          	mov al, bl
0556+  1550 6A 30       	add al, $30
0557+  1552 23          	mov ah, al
0558+  1553 19 00       	mov al, 0
0559+  1555 05 03       	syscall sys_io	; print coeff
0560+  1557 E5          	pop b
0561+  1558 E4          	pop a
0562+  1559 09          	ret
0563+  155A             
0564+  155A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0565+  155A             ; INPUT 8BIT HEX INTEGER
0566+  155A             ; read 8bit integer into AL
0567+  155A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  155A             scan_u8x:
0569+  155A F8 04 00    	enter 4
0570+  155D D8          	push b
0571+  155E DA          	push d
0572+  155F             
0573+  155F FA FD FF    	lea d, [bp + -3]
0574+  1562 07 40 13    	call gets				; get number
0575+  1565             
0576+  1565 32          	mov bl, [d]
0577+  1566 37          	mov bh, bl
0578+  1567 33 01 00    	mov bl, [d + 1]
0579+  156A 07 EE 12    	call atoi				; convert to int in AL
0580+  156D             
0581+  156D E7          	pop d
0582+  156E E5          	pop b
0583+  156F F9          	leave
0584+  1570 09          	ret
0585+  1571             
0586+  1571             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  1571             ; input decimal number
0588+  1571             ; result in A
0589+  1571             ; 655'\0'
0590+  1571             ; low--------high
0591+  1571             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0592+  1571             scan_u16d:
0593+  1571 F8 08 00    	enter 8
0594+  1574 E2          	push si
0595+  1575 D8          	push b
0596+  1576 D9          	push c
0597+  1577 DA          	push d
0598+  1578 FA F9 FF    	lea d, [bp +- 7]
0599+  157B 07 40 13    	call gets
0600+  157E 07 6E 12    	call strlen			; get string length in C
0601+  1581 7E          	dec c
0602+  1582 FD 4E       	mov si, d
0603+  1584 12          	mov a, c
0604+  1585 FD 99       	shl a
0605+  1587 3B D6 12    	mov d, table_power
0606+  158A 59          	add d, a
0607+  158B 38 00 00    	mov c, 0
0608+  158E             mul_loop:
0609+  158E F6          	lodsb			; load ASCII to al
0610+  158F B9 00       	cmp al, 0
0611+  1591 C6 A4 15    	je mul_exit
0612+  1594 6F 30       	sub al, $30		; make into integer
0613+  1596 22 00       	mov ah, 0
0614+  1598 2A          	mov b, [d]
0615+  1599 AC          	mul a, b			; result in B since it fits in 16bits
0616+  159A 11          	mov a, b
0617+  159B 28          	mov b, c
0618+  159C 54          	add a, b
0619+  159D 39          	mov c, a
0620+  159E 63 02 00    	sub d, 2
0621+  15A1 0A 8E 15    	jmp mul_loop
0622+  15A4             mul_exit:
0623+  15A4 12          	mov a, c
0624+  15A5 E7          	pop d
0625+  15A6 E6          	pop c
0626+  15A7 E5          	pop b
0627+  15A8 EF          	pop si
0628+  15A9 F9          	leave
0629+  15AA 09          	ret
1972   15AB             ; --- END INCLUDE BLOCK
1973   15AB             
1974   15AB             
1975   15AB             .end
tasm: Number of errors = 0
