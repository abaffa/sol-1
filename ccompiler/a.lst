0001   0000             ; --- FILENAME: polish.c
0002   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0400             .org PROC_TEXT_ORG
0004   0400             
0005   0400             ; --- BEGIN TEXT BLOCK
0006   0400             
0007   0400             main:
0008   0400 D2            push bp
0009   0401 9B            mov bp, sp
0010   0402 52 02 00      sub sp, 2 ; type
0011   0405 52 02 00      sub sp, 2 ; op2
0012   0408 52 64 00      sub sp, 100 ; s
0013   040B             _while1_cond:
0014   040B FA 99 FF      lea d, [bp + -103] ; s_data
0015   040E 2D            mov b, d
0016   040F FD AB         swp b
0017   0411 D8            push b
0018   0412 07 2F 06      call getop
0019   0415 51 02 00      add sp, 2
0020   0418 D7            push a
0021   0419 11            mov a, b
0022   041A 45 FF FF      mov [bp + -1], a ; type
0023   041D E4            pop a
0024   041E D7            push a
0025   041F 11            mov a, b
0026   0420 26 24 00      mov b, '$'
0027   0423 B0            cmp a, b
0028   0424 0E            lodflgs
0029   0425 87 01         and al, %00000001
0030   0427 8F 01         xor al, %00000001 ; !=
0031   0429 B9 00         cmp al, 0
0032   042B 0E            lodflgs
0033   042C 96            not al
0034   042D 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0035   042F 22 00         mov ah, 0
0036   0431 27            mov b, a
0037   0432 E4            pop a
0038   0433 C0 00 00      cmp b, 0
0039   0436 C6 5C 05      je _while1_exit
0040   0439             _while1_block:
0041   0439             _switch2_expr:
0042   0439 2C FF FF      mov b, [bp + -1] ; type
0043   043C             _switch2_comparisons:
0044   043C C0 E7 03      cmp b, 999
0045   043F C6 5F 04      je _switch2_case0
0046   0442 C1 2B         cmp bl, '+'
0047   0444 C6 78 04      je _switch2_case1
0048   0447 C1 2A         cmp bl, '*'
0049   0449 C6 8F 04      je _switch2_case2
0050   044C C1 2D         cmp bl, '-'
0051   044E C6 A5 04      je _switch2_case3
0052   0451 C1 2F         cmp bl, '/'
0053   0453 C6 C5 04      je _switch2_case4
0054   0456 C0 0A 00      cmp b, 10
0055   0459 C6 16 05      je _switch2_case5
0056   045C 0A 31 05      jmp _switch2_default
0057   045F             _switch2_case0:
0058   045F FA 99 FF      lea d, [bp + -103] ; s_data
0059   0462 2D            mov b, d
0060   0463 FD AB         swp b
0061   0465 D8            push b
0062   0466 07 62 05      call _atoi
0063   0469 51 02 00      add sp, 2
0064   046C FD AB         swp b
0065   046E D8            push b
0066   046F 07 77 05      call _push
0067   0472 51 02 00      add sp, 2
0068   0475 0A 59 05      jmp _switch2_exit ; case break
0069   0478             _switch2_case1:
0070   0478 07 D0 05      call _pop
0071   047B D7            push a
0072   047C 11            mov a, b
0073   047D 07 D0 05      call _pop
0074   0480 54            add a, b
0075   0481 27            mov b, a
0076   0482 E4            pop a
0077   0483 FD AB         swp b
0078   0485 D8            push b
0079   0486 07 77 05      call _push
0080   0489 51 02 00      add sp, 2
0081   048C 0A 59 05      jmp _switch2_exit ; case break
0082   048F             _switch2_case2:
0083   048F 07 D0 05      call _pop
0084   0492 D7            push a
0085   0493 11            mov a, b
0086   0494 07 D0 05      call _pop
0087   0497 AC            mul a, b
0088   0498 E4            pop a
0089   0499 FD AB         swp b
0090   049B D8            push b
0091   049C 07 77 05      call _push
0092   049F 51 02 00      add sp, 2
0093   04A2 0A 59 05      jmp _switch2_exit ; case break
0094   04A5             _switch2_case3:
0095   04A5 07 D0 05      call _pop
0096   04A8 D7            push a
0097   04A9 11            mov a, b
0098   04AA 45 FD FF      mov [bp + -3], a ; op2
0099   04AD E4            pop a
0100   04AE 07 D0 05      call _pop
0101   04B1 D7            push a
0102   04B2 11            mov a, b
0103   04B3 2C FD FF      mov b, [bp + -3] ; op2
0104   04B6 60            sub a, b
0105   04B7 27            mov b, a
0106   04B8 E4            pop a
0107   04B9 FD AB         swp b
0108   04BB D8            push b
0109   04BC 07 77 05      call _push
0110   04BF 51 02 00      add sp, 2
0111   04C2 0A 59 05      jmp _switch2_exit ; case break
0112   04C5             _switch2_case4:
0113   04C5 07 D0 05      call _pop
0114   04C8 D7            push a
0115   04C9 11            mov a, b
0116   04CA 45 FD FF      mov [bp + -3], a ; op2
0117   04CD E4            pop a
0118   04CE             _if3_cond:
0119   04CE 2C FD FF      mov b, [bp + -3] ; op2
0120   04D1 D7            push a
0121   04D2 11            mov a, b
0122   04D3 26 00 00      mov b, 0
0123   04D6 B0            cmp a, b
0124   04D7 0E            lodflgs
0125   04D8 87 01         and al, %00000001
0126   04DA 8F 01         xor al, %00000001 ; !=
0127   04DC B9 00         cmp al, 0
0128   04DE 0E            lodflgs
0129   04DF 96            not al
0130   04E0 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0131   04E2 22 00         mov ah, 0
0132   04E4 27            mov b, a
0133   04E5 E4            pop a
0134   04E6 C0 00 00      cmp b, 0
0135   04E9 C6 07 05      je _if3_else
0136   04EC             _if3_true:
0137   04EC 07 D0 05      call _pop
0138   04EF D7            push a
0139   04F0 11            mov a, b
0140   04F1 2C FD FF      mov b, [bp + -3] ; op2
0141   04F4 AE            div a, b
0142   04F5 FD 78         mov g, a
0143   04F7 11            mov a, b
0144   04F8 FD 27         mov b, g
0145   04FA E4            pop a
0146   04FB FD AB         swp b
0147   04FD D8            push b
0148   04FE 07 77 05      call _push
0149   0501 51 02 00      add sp, 2
0150   0504 0A 13 05      jmp _if3_exit
0151   0507             _if3_else:
0152   0507 26 B4 09      mov b, _string_0 ; "Divide by zero error\n"
0153   050A FD AB         swp b
0154   050C D8            push b
0155   050D 07 75 08      call print
0156   0510 51 02 00      add sp, 2
0157   0513             _if3_exit:
0158   0513 0A 59 05      jmp _switch2_exit ; case break
0159   0516             _switch2_case5:
0160   0516 07 D0 05      call _pop
0161   0519 FD AB         swp b
0162   051B D8            push b
0163   051C 07 6B 08      call printn
0164   051F 51 02 00      add sp, 2
0165   0522 26 CA 09      mov b, _string_1 ; "\n"
0166   0525 FD AB         swp b
0167   0527 D8            push b
0168   0528 07 75 08      call print
0169   052B 51 02 00      add sp, 2
0170   052E 0A 59 05      jmp _switch2_exit ; case break
0171   0531             _switch2_default:
0172   0531 26 CC 09      mov b, _string_2 ; "Unknown input: "
0173   0534 FD AB         swp b
0174   0536 D8            push b
0175   0537 07 75 08      call print
0176   053A 51 02 00      add sp, 2
0177   053D FA 99 FF      lea d, [bp + -103] ; s_data
0178   0540 2D            mov b, d
0179   0541 FD AB         swp b
0180   0543 D8            push b
0181   0544 07 75 08      call print
0182   0547 51 02 00      add sp, 2
0183   054A 26 CA 09      mov b, _string_1 ; "\n"
0184   054D FD AB         swp b
0185   054F D8            push b
0186   0550 07 75 08      call print
0187   0553 51 02 00      add sp, 2
0188   0556 0A 59 05      jmp _switch2_exit ; case break
0189   0559             _switch2_exit:
0190   0559 0A 0B 04      jmp _while1_cond
0191   055C             _while1_exit:
0192   055C 26 00 00      mov b, 0
0193   055F F9            leave
0194   0560 05 0B         syscall sys_terminate_proc
0195   0562             
0196   0562             _atoi:
0197   0562 D2            push bp
0198   0563 9B            mov bp, sp
0199   0564 52 02 00      sub sp, 2 ; n
0200   0567             
0201   0567             ; --- BEGIN INLINE ASM BLOCK
0202   0567 FA 05 00      lea d, [bp + 5]
0203   056A 15            mov a, [d]
0204   056B 3C            mov d, a
0205   056C 07 4E 0C      call strtoint
0206   056F 45 FF FF      mov [bp + -1], a
0207   0572             ; --- END INLINE ASM BLOCK
0208   0572             
0209   0572 2C FF FF      mov b, [bp + -1] ; n
0210   0575 F9            leave
0211   0576 09            ret
0212   0577             
0213   0577             _push:
0214   0577 D2            push bp
0215   0578 9B            mov bp, sp
0216   0579             _if4_cond:
0217   0579 29 80 08      mov b, [_sp] ; _sp
0218   057C D7            push a
0219   057D 11            mov a, b
0220   057E 26 64 00      mov b, 100
0221   0581 B0            cmp a, b
0222   0582 0E            lodflgs
0223   0583 87 02         and al, %00000010 ; <
0224   0585 B9 00         cmp al, 0
0225   0587 0E            lodflgs
0226   0588 96            not al
0227   0589 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0228   058B 22 00         mov ah, 0
0229   058D 27            mov b, a
0230   058E E4            pop a
0231   058F C0 00 00      cmp b, 0
0232   0592 C6 B6 05      je _if4_else
0233   0595             _if4_true:
0234   0595 29 4A 09      mov b, [val]
0235   0598 74            mov d, b
0236   0599 DA            push d
0237   059A 29 80 08      mov b, [_sp] ; _sp
0238   059D E7            pop d
0239   059E 10 02 00      mov a, 2
0240   05A1 AC            mul a, b
0241   05A2 5A            add d, b
0242   05A3 DA            push d
0243   05A4 2C 05 00      mov b, [bp + 5] ; f
0244   05A7 E7            pop d
0245   05A8 11            mov a, b
0246   05A9 43            mov [d], a
0247   05AA 29 80 08      mov b, [_sp] ; _sp
0248   05AD FD 77         inc b
0249   05AF FD 42 80 08   mov [_sp], b
0250   05B3 0A CE 05      jmp _if4_exit
0251   05B6             _if4_else:
0252   05B6 26 DC 09      mov b, _string_3 ; "Error: stack full, can't _push: "
0253   05B9 FD AB         swp b
0254   05BB D8            push b
0255   05BC 07 75 08      call print
0256   05BF 51 02 00      add sp, 2
0257   05C2 2C 05 00      mov b, [bp + 5] ; f
0258   05C5 FD AB         swp b
0259   05C7 D8            push b
0260   05C8 07 6B 08      call printn
0261   05CB 51 02 00      add sp, 2
0262   05CE             _if4_exit:
0263   05CE F9            leave
0264   05CF 09            ret
0265   05D0             
0266   05D0             _pop:
0267   05D0 D2            push bp
0268   05D1 9B            mov bp, sp
0269   05D2 26 FC 09      mov b, _string_4 ; "POP"
0270   05D5 FD AB         swp b
0271   05D7 D8            push b
0272   05D8 07 75 08      call print
0273   05DB 51 02 00      add sp, 2
0274   05DE             _if5_cond:
0275   05DE 29 80 08      mov b, [_sp] ; _sp
0276   05E1 D7            push a
0277   05E2 11            mov a, b
0278   05E3 26 00 00      mov b, 0
0279   05E6 B0            cmp a, b
0280   05E7 0E            lodflgs
0281   05E8 87 03         and al, %00000011
0282   05EA B9 00         cmp al, %00000000
0283   05EC 0E            lodflgs
0284   05ED 87 01         and al, %00000001 ; >
0285   05EF B9 00         cmp al, 0
0286   05F1 0E            lodflgs
0287   05F2 96            not al
0288   05F3 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0289   05F5 22 00         mov ah, 0
0290   05F7 27            mov b, a
0291   05F8 E4            pop a
0292   05F9 C0 00 00      cmp b, 0
0293   05FC C6 1E 06      je _if5_else
0294   05FF             _if5_true:
0295   05FF 29 80 08      mov b, [_sp] ; _sp
0296   0602 FD 7D         dec b
0297   0604 FD 42 80 08   mov [_sp], b
0298   0608 29 4A 09      mov b, [val]
0299   060B D7            push a
0300   060C 74            mov d, b
0301   060D DA            push d
0302   060E 29 80 08      mov b, [_sp] ; _sp
0303   0611 E7            pop d
0304   0612 10 02 00      mov a, 2
0305   0615 AC            mul a, b
0306   0616 5A            add d, b
0307   0617 2A            mov b, [d]
0308   0618 E4            pop a
0309   0619 F9            leave
0310   061A 09            ret
0311   061B 0A 2F 06      jmp _if5_exit
0312   061E             _if5_else:
0313   061E 26 00 0A      mov b, _string_5 ; "Error: stack empty.\n"
0314   0621 FD AB         swp b
0315   0623 D8            push b
0316   0624 07 75 08      call print
0317   0627 51 02 00      add sp, 2
0318   062A 26 00 00      mov b, 0
0319   062D F9            leave
0320   062E 09            ret
0321   062F             _if5_exit:
0322   062F             
0323   062F             getop:
0324   062F D2            push bp
0325   0630 9B            mov bp, sp
0326   0631 52 02 00      sub sp, 2 ; i
0327   0634 52 01 00      sub sp, 1 ; c
0328   0637             _while6_cond:
0329   0637 FA 05 00      lea d, [bp + 5] ; s
0330   063A 2A            mov b, [d]
0331   063B 74            mov d, b
0332   063C DA            push d
0333   063D 26 00 00      mov b, 0
0334   0640 E7            pop d
0335   0641 10 01 00      mov a, 1
0336   0644 AC            mul a, b
0337   0645 5A            add d, b
0338   0646 DA            push d
0339   0647 07 48 07      call getch
0340   064A DB            push al
0341   064B 1B            mov al, bl
0342   064C 40 FE FF      mov [bp + -2], al ; c
0343   064F E8            pop al
0344   0650 E7            pop d
0345   0651 1B            mov al, bl
0346   0652 3E            mov [d], al
0347   0653 D7            push a
0348   0654 11            mov a, b
0349   0655 26 20 00      mov b, ' '
0350   0658 B0            cmp a, b
0351   0659 0E            lodflgs
0352   065A 87 01         and al, %00000001 ; ==
0353   065C B9 00         cmp al, 0
0354   065E 0E            lodflgs
0355   065F 96            not al
0356   0660 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0357   0662 22 00         mov ah, 0
0358   0664 27            mov b, a
0359   0665 E4            pop a
0360   0666 C0 00 00      cmp b, 0
0361   0669 C6 6F 06      je _while6_exit
0362   066C             _while6_block:
0363   066C 0A 37 06      jmp _while6_cond
0364   066F             _while6_exit:
0365   066F FA 05 00      lea d, [bp + 5] ; s
0366   0672 2A            mov b, [d]
0367   0673 74            mov d, b
0368   0674 DA            push d
0369   0675 26 01 00      mov b, 1
0370   0678 E7            pop d
0371   0679 10 01 00      mov a, 1
0372   067C AC            mul a, b
0373   067D 5A            add d, b
0374   067E DA            push d
0375   067F 26 00 00      mov b, 0
0376   0682 E7            pop d
0377   0683 1B            mov al, bl
0378   0684 3E            mov [d], al
0379   0685             _if7_cond:
0380   0685 34 FE FF      mov bl, [bp + -2] ; c
0381   0688 A7 00         mov bh, 0
0382   068A DD            push bl
0383   068B 07 E2 07      call isdigit
0384   068E 51 01 00      add sp, 1
0385   0691 DB            push al
0386   0692 C0 00 00      cmp b, 0
0387   0695 0E            lodflgs
0388   0696 87 01         and al, %00000001 ; transform logical not condition result into a single bit
0389   0698 2F            mov bl, al
0390   0699 A7 00         mov bh, 0
0391   069B E8            pop al
0392   069C C0 00 00      cmp b, 0
0393   069F C6 AC 06      je _if7_exit
0394   06A2             _if7_true:
0395   06A2 34 FE FF      mov bl, [bp + -2] ; c
0396   06A5 A7 00         mov bh, 0
0397   06A7 F9            leave
0398   06A8 09            ret
0399   06A9 0A AC 06      jmp _if7_exit
0400   06AC             _if7_exit:
0401   06AC 26 00 00      mov b, 0
0402   06AF D7            push a
0403   06B0 11            mov a, b
0404   06B1 45 FF FF      mov [bp + -1], a ; i
0405   06B4 E4            pop a
0406   06B5             _if8_cond:
0407   06B5 34 FE FF      mov bl, [bp + -2] ; c
0408   06B8 A7 00         mov bh, 0
0409   06BA DD            push bl
0410   06BB 07 E2 07      call isdigit
0411   06BE 51 01 00      add sp, 1
0412   06C1 C0 00 00      cmp b, 0
0413   06C4 C6 FE 06      je _if8_exit
0414   06C7             _if8_true:
0415   06C7             _while9_cond:
0416   06C7 FA 05 00      lea d, [bp + 5] ; s
0417   06CA 2A            mov b, [d]
0418   06CB 74            mov d, b
0419   06CC DA            push d
0420   06CD 2C FF FF      mov b, [bp + -1] ; i
0421   06D0 FD 77         inc b
0422   06D2 D7            push a
0423   06D3 11            mov a, b
0424   06D4 45 FF FF      mov [bp + -1], a ; i
0425   06D7 E4            pop a
0426   06D8 E7            pop d
0427   06D9 10 01 00      mov a, 1
0428   06DC AC            mul a, b
0429   06DD 5A            add d, b
0430   06DE DA            push d
0431   06DF 07 48 07      call getch
0432   06E2 DB            push al
0433   06E3 1B            mov al, bl
0434   06E4 40 FE FF      mov [bp + -2], al ; c
0435   06E7 E8            pop al
0436   06E8 E7            pop d
0437   06E9 1B            mov al, bl
0438   06EA 3E            mov [d], al
0439   06EB DD            push bl
0440   06EC 07 E2 07      call isdigit
0441   06EF 51 01 00      add sp, 1
0442   06F2 C0 00 00      cmp b, 0
0443   06F5 C6 FB 06      je _while9_exit
0444   06F8             _while9_block:
0445   06F8 0A C7 06      jmp _while9_cond
0446   06FB             _while9_exit:
0447   06FB 0A FE 06      jmp _if8_exit
0448   06FE             _if8_exit:
0449   06FE FA 05 00      lea d, [bp + 5] ; s
0450   0701 2A            mov b, [d]
0451   0702 74            mov d, b
0452   0703 DA            push d
0453   0704 2C FF FF      mov b, [bp + -1] ; i
0454   0707 E7            pop d
0455   0708 10 01 00      mov a, 1
0456   070B AC            mul a, b
0457   070C 5A            add d, b
0458   070D DA            push d
0459   070E 26 00 00      mov b, 0
0460   0711 E7            pop d
0461   0712 1B            mov al, bl
0462   0713 3E            mov [d], al
0463   0714             _if10_cond:
0464   0714 34 FE FF      mov bl, [bp + -2] ; c
0465   0717 A7 00         mov bh, 0
0466   0719 D7            push a
0467   071A 11            mov a, b
0468   071B 26 24 00      mov b, '$'
0469   071E B0            cmp a, b
0470   071F 0E            lodflgs
0471   0720 87 01         and al, %00000001
0472   0722 8F 01         xor al, %00000001 ; !=
0473   0724 B9 00         cmp al, 0
0474   0726 0E            lodflgs
0475   0727 96            not al
0476   0728 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0477   072A 22 00         mov ah, 0
0478   072C 27            mov b, a
0479   072D E4            pop a
0480   072E C0 00 00      cmp b, 0
0481   0731 C6 43 07      je _if10_exit
0482   0734             _if10_true:
0483   0734 34 FE FF      mov bl, [bp + -2] ; c
0484   0737 A7 00         mov bh, 0
0485   0739 DD            push bl
0486   073A 07 91 07      call ungetch
0487   073D 51 01 00      add sp, 1
0488   0740 0A 43 07      jmp _if10_exit
0489   0743             _if10_exit:
0490   0743 26 E7 03      mov b, 999
0491   0746 F9            leave
0492   0747 09            ret
0493   0748             
0494   0748             getch:
0495   0748 D2            push bp
0496   0749 9B            mov bp, sp
0497   074A             _if11_cond:
0498   074A 29 B2 09      mov b, [bufp] ; bufp
0499   074D D7            push a
0500   074E 11            mov a, b
0501   074F 26 00 00      mov b, 0
0502   0752 B0            cmp a, b
0503   0753 0E            lodflgs
0504   0754 87 03         and al, %00000011
0505   0756 B9 00         cmp al, %00000000
0506   0758 0E            lodflgs
0507   0759 87 01         and al, %00000001 ; >
0508   075B B9 00         cmp al, 0
0509   075D 0E            lodflgs
0510   075E 96            not al
0511   075F 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0512   0761 22 00         mov ah, 0
0513   0763 27            mov b, a
0514   0764 E4            pop a
0515   0765 C0 00 00      cmp b, 0
0516   0768 C6 8C 07      je _if11_else
0517   076B             _if11_true:
0518   076B 29 B2 09      mov b, [bufp] ; bufp
0519   076E FD 7D         dec b
0520   0770 FD 42 B2 09   mov [bufp], b
0521   0774 29 B0 09      mov b, [buf]
0522   0777 D7            push a
0523   0778 74            mov d, b
0524   0779 DA            push d
0525   077A 29 B2 09      mov b, [bufp] ; bufp
0526   077D E7            pop d
0527   077E 10 01 00      mov a, 1
0528   0781 AC            mul a, b
0529   0782 5A            add d, b
0530   0783 32            mov bl, [d]
0531   0784 A7 00         mov bh, 0
0532   0786 E4            pop a
0533   0787 F9            leave
0534   0788 09            ret
0535   0789 0A 91 07      jmp _if11_exit
0536   078C             _if11_else:
0537   078C 07 40 08      call _getchar
0538   078F F9            leave
0539   0790 09            ret
0540   0791             _if11_exit:
0541   0791             
0542   0791             ungetch:
0543   0791 D2            push bp
0544   0792 9B            mov bp, sp
0545   0793             _if12_cond:
0546   0793 29 B2 09      mov b, [bufp] ; bufp
0547   0796 D7            push a
0548   0797 11            mov a, b
0549   0798 26 64 00      mov b, 100
0550   079B B0            cmp a, b
0551   079C 0E            lodflgs
0552   079D 87 03         and al, %00000011
0553   079F 8F 02         xor al, %00000010 ; >=
0554   07A1 B9 00         cmp al, 0
0555   07A3 0E            lodflgs
0556   07A4 96            not al
0557   07A5 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0558   07A7 22 00         mov ah, 0
0559   07A9 27            mov b, a
0560   07AA E4            pop a
0561   07AB C0 00 00      cmp b, 0
0562   07AE C6 C0 07      je _if12_else
0563   07B1             _if12_true:
0564   07B1 26 15 0A      mov b, _string_6 ; "Error: too many characters.\n"
0565   07B4 FD AB         swp b
0566   07B6 D8            push b
0567   07B7 07 75 08      call print
0568   07BA 51 02 00      add sp, 2
0569   07BD 0A E0 07      jmp _if12_exit
0570   07C0             _if12_else:
0571   07C0 29 B0 09      mov b, [buf]
0572   07C3 74            mov d, b
0573   07C4 DA            push d
0574   07C5 29 B2 09      mov b, [bufp] ; bufp
0575   07C8 E7            pop d
0576   07C9 10 01 00      mov a, 1
0577   07CC AC            mul a, b
0578   07CD 5A            add d, b
0579   07CE DA            push d
0580   07CF 34 05 00      mov bl, [bp + 5] ; c
0581   07D2 A7 00         mov bh, 0
0582   07D4 E7            pop d
0583   07D5 1B            mov al, bl
0584   07D6 3E            mov [d], al
0585   07D7 29 B2 09      mov b, [bufp] ; bufp
0586   07DA FD 77         inc b
0587   07DC FD 42 B2 09   mov [bufp], b
0588   07E0             _if12_exit:
0589   07E0 F9            leave
0590   07E1 09            ret
0591   07E2             
0592   07E2             isdigit:
0593   07E2 D2            push bp
0594   07E3 9B            mov bp, sp
0595   07E4             _if13_cond:
0596   07E4 34 05 00      mov bl, [bp + 5] ; c
0597   07E7 A7 00         mov bh, 0
0598   07E9 D7            push a
0599   07EA 11            mov a, b
0600   07EB 26 30 00      mov b, '0'
0601   07EE B0            cmp a, b
0602   07EF 0E            lodflgs
0603   07F0 87 03         and al, %00000011
0604   07F2 8F 02         xor al, %00000010 ; >=
0605   07F4 B9 00         cmp al, 0
0606   07F6 0E            lodflgs
0607   07F7 96            not al
0608   07F8 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0609   07FA 22 00         mov ah, 0
0610   07FC 27            mov b, a
0611   07FD E4            pop a
0612   07FE D7            push a
0613   07FF 11            mov a, b
0614   0800 AF 00 00      cmp a, 0
0615   0803 0E            lodflgs
0616   0804 96            not al
0617   0805 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
0618   0807 34 05 00      mov bl, [bp + 5] ; c
0619   080A A7 00         mov bh, 0
0620   080C D7            push a
0621   080D 11            mov a, b
0622   080E 26 39 00      mov b, '9'
0623   0811 B0            cmp a, b
0624   0812 0E            lodflgs
0625   0813 87 03         and al, %00000011 ; <=
0626   0815 B9 00         cmp al, 0
0627   0817 0E            lodflgs
0628   0818 96            not al
0629   0819 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0630   081B 22 00         mov ah, 0
0631   081D 27            mov b, a
0632   081E E4            pop a
0633   081F DB            push al
0634   0820 C0 00 00      cmp b, 0
0635   0823 0E            lodflgs
0636   0824 96            not al
0637   0825 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
0638   0827 EA            pop bl
0639   0828 88            and al, bl
0640   0829 2F            mov bl, al
0641   082A A7 00         mov bh, 0
0642   082C E4            pop a
0643   082D C0 00 00      cmp b, 0
0644   0830 C6 3B 08      je _if13_else
0645   0833             _if13_true:
0646   0833 26 01 00      mov b, 1
0647   0836 F9            leave
0648   0837 09            ret
0649   0838 0A 40 08      jmp _if13_exit
0650   083B             _if13_else:
0651   083B 26 00 00      mov b, 0
0652   083E F9            leave
0653   083F 09            ret
0654   0840             _if13_exit:
0655   0840             
0656   0840             _getchar:
0657   0840 D2            push bp
0658   0841 9B            mov bp, sp
0659   0842 52 01 00      sub sp, 1 ; c
0660   0845             
0661   0845             ; --- BEGIN INLINE ASM BLOCK
0662   0845 07 36 0B      call getchar
0663   0848 1A            mov al, ah
0664   0849 40 00 00      mov [bp + 0], al
0665   084C             ; --- END INLINE ASM BLOCK
0666   084C             
0667   084C 34 00 00      mov bl, [bp + 0] ; c
0668   084F A7 00         mov bh, 0
0669   0851 F9            leave
0670   0852 09            ret
0671   0853             
0672   0853             scann:
0673   0853 D2            push bp
0674   0854 9B            mov bp, sp
0675   0855 52 02 00      sub sp, 2 ; m
0676   0858             
0677   0858             ; --- BEGIN INLINE ASM BLOCK
0678   0858 07 7C 0D      call scan_u16d
0679   085B 45 FF FF      mov [bp + -1], a
0680   085E             ; --- END INLINE ASM BLOCK
0681   085E             
0682   085E FA 05 00      lea d, [bp + 5] ; n
0683   0861 2A            mov b, [d]
0684   0862 D8            push b
0685   0863 2C FF FF      mov b, [bp + -1] ; m
0686   0866 E7            pop d
0687   0867 11            mov a, b
0688   0868 43            mov [d], a
0689   0869 F9            leave
0690   086A 09            ret
0691   086B             
0692   086B             printn:
0693   086B D2            push bp
0694   086C 9B            mov bp, sp
0695   086D             
0696   086D             ; --- BEGIN INLINE ASM BLOCK
0697   086D 17 05 00      mov a, [bp + 5]
0698   0870 07 A7 0C      call print_u16d
0699   0873             ; --- END INLINE ASM BLOCK
0700   0873             
0701   0873 F9            leave
0702   0874 09            ret
0703   0875             
0704   0875             print:
0705   0875 D2            push bp
0706   0876 9B            mov bp, sp
0707   0877             
0708   0877             ; --- BEGIN INLINE ASM BLOCK
0709   0877 17 05 00      mov a, [bp + 5]
0710   087A 3C            mov d, a
0711   087B 07 7E 0C      call puts
0712   087E             ; --- END INLINE ASM BLOCK
0713   087E             
0714   087E F9            leave
0715   087F 09            ret
0716   0880             ; --- END TEXT BLOCK
0717   0880             
0718   0880             ; --- BEGIN DATA BLOCK
0719   0880 00 00       _sp: .dw 0
0720   0882 00 00 00 00 val_data: .fill 200, 0
0720   0886 00 00 00 00 
0720   088A 00 00 00 00 
0720   088E 00 00 00 00 
0720   0892 00 00 00 00 
0720   0896 00 00 00 00 
0720   089A 00 00 00 00 
0720   089E 00 00 00 00 
0720   08A2 00 00 00 00 
0720   08A6 00 00 00 00 
0720   08AA 00 00 00 00 
0720   08AE 00 00 00 00 
0720   08B2 00 00 00 00 
0720   08B6 00 00 00 00 
0720   08BA 00 00 00 00 
0720   08BE 00 00 00 00 
0720   08C2 00 00 00 00 
0720   08C6 00 00 00 00 
0720   08CA 00 00 00 00 
0720   08CE 00 00 00 00 
0720   08D2 00 00 00 00 
0720   08D6 00 00 00 00 
0720   08DA 00 00 00 00 
0720   08DE 00 00 00 00 
0720   08E2 00 00 00 00 
0720   08E6 00 00 00 00 
0720   08EA 00 00 00 00 
0720   08EE 00 00 00 00 
0720   08F2 00 00 00 00 
0720   08F6 00 00 00 00 
0720   08FA 00 00 00 00 
0720   08FE 00 00 00 00 
0720   0902 00 00 00 00 
0720   0906 00 00 00 00 
0720   090A 00 00 00 00 
0720   090E 00 00 00 00 
0720   0912 00 00 00 00 
0720   0916 00 00 00 00 
0720   091A 00 00 00 00 
0720   091E 00 00 00 00 
0720   0922 00 00 00 00 
0720   0926 00 00 00 00 
0720   092A 00 00 00 00 
0720   092E 00 00 00 00 
0720   0932 00 00 00 00 
0720   0936 00 00 00 00 
0720   093A 00 00 00 00 
0720   093E 00 00 00 00 
0720   0942 00 00 00 00 
0720   0946 00 00 00 00 
0721   094A 82 08       val: .dw val_data
0722   094C 00 00 00 00 buf_data: .fill 100, 0
0722   0950 00 00 00 00 
0722   0954 00 00 00 00 
0722   0958 00 00 00 00 
0722   095C 00 00 00 00 
0722   0960 00 00 00 00 
0722   0964 00 00 00 00 
0722   0968 00 00 00 00 
0722   096C 00 00 00 00 
0722   0970 00 00 00 00 
0722   0974 00 00 00 00 
0722   0978 00 00 00 00 
0722   097C 00 00 00 00 
0722   0980 00 00 00 00 
0722   0984 00 00 00 00 
0722   0988 00 00 00 00 
0722   098C 00 00 00 00 
0722   0990 00 00 00 00 
0722   0994 00 00 00 00 
0722   0998 00 00 00 00 
0722   099C 00 00 00 00 
0722   09A0 00 00 00 00 
0722   09A4 00 00 00 00 
0722   09A8 00 00 00 00 
0722   09AC 00 00 00 00 
0723   09B0 4C 09       buf: .dw buf_data
0724   09B2 00 00       bufp: .dw 0
0725   09B4 44 69 76 69 _string_0: .db "Divide by zero error\n", 0
0725   09B8 64 65 20 62 
0725   09BC 79 20 7A 65 
0725   09C0 72 6F 20 65 
0725   09C4 72 72 6F 72 
0725   09C8 0A 00 
0726   09CA 0A 00       _string_1: .db "\n", 0
0727   09CC 55 6E 6B 6E _string_2: .db "Unknown input: ", 0
0727   09D0 6F 77 6E 20 
0727   09D4 69 6E 70 75 
0727   09D8 74 3A 20 00 
0728   09DC 45 72 72 6F _string_3: .db "Error: stack full, can't _push: ", 0
0728   09E0 72 3A 20 73 
0728   09E4 74 61 63 6B 
0728   09E8 20 66 75 6C 
0728   09EC 6C 2C 20 63 
0728   09F0 61 6E 27 74 
0728   09F4 20 5F 70 75 
0728   09F8 73 68 3A 20 
0729   09FC 50 4F 50 00 _string_4: .db "POP", 0
0730   0A00 45 72 72 6F _string_5: .db "Error: stack empty.\n", 0
0730   0A04 72 3A 20 73 
0730   0A08 74 61 63 6B 
0730   0A0C 20 65 6D 70 
0730   0A10 74 79 2E 0A 
0730   0A14 00 
0731   0A15 45 72 72 6F _string_6: .db "Error: too many characters.\n", 0
0731   0A19 72 3A 20 74 
0731   0A1D 6F 6F 20 6D 
0731   0A21 61 6E 79 20 
0731   0A25 63 68 61 72 
0731   0A29 61 63 74 65 
0731   0A2D 72 73 2E 0A 
0731   0A31 00 
0732   0A32             ; --- END DATA BLOCK
0733   0A32             
0734   0A32             ; --- BEGIN INCLUDE BLOCK
0735   0A32             .include "lib/stdio.asm"
0001+  0A32             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0A32             ; stdio.s
0003+  0A32             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0A32             .include "lib/string.asm"
0001++ 0A32             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0A32             ; string.s
0003++ 0A32             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0A32             
0005++ 0A32             
0006++ 0A32             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0A32             ; strrev
0008++ 0A32             ; reverse a string
0009++ 0A32             ; D = string address
0010++ 0A32             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0A32             ; 01234
0012++ 0A32             strrev:
0013++ 0A32 4B          	pusha
0014++ 0A33 07 79 0A    	call strlen	; length in C
0015++ 0A36 12          	mov a, c
0016++ 0A37 AF 01 00    	cmp a, 1
0017++ 0A3A D0 54 0A    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0A3D 7D          	dec a
0019++ 0A3E FD 4E       	mov si, d	; beginning of string
0020++ 0A40 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0A42 59          	add d, a	; end of string
0022++ 0A43 12          	mov a, c
0023++ 0A44 FD 9B       	shr a		; divide by 2
0024++ 0A46 39          	mov c, a	; C now counts the steps
0025++ 0A47             strrev_L0:
0026++ 0A47 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0A48 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0A49 3E          	mov [d], al	; store left char into right side
0029++ 0A4A 1B          	mov al, bl
0030++ 0A4B F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0A4C 7E          	dec c
0032++ 0A4D 7F          	dec d
0033++ 0A4E C2 00 00    	cmp c, 0
0034++ 0A51 C7 47 0A    	jne strrev_L0
0035++ 0A54             strrev_end:
0036++ 0A54 4C          	popa
0037++ 0A55 09          	ret
0038++ 0A56             	
0039++ 0A56             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0A56             ; strchr
0041++ 0A56             ; search string in D for char in AL
0042++ 0A56             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0A56             strchr:
0044++ 0A56             strchr_L0:
0045++ 0A56 32          	mov bl, [d]
0046++ 0A57 C1 00       	cmp bl, 0
0047++ 0A59 C6 64 0A    	je strchr_end
0048++ 0A5C BA          	cmp al, bl
0049++ 0A5D C6 64 0A    	je strchr_end
0050++ 0A60 79          	inc d
0051++ 0A61 0A 56 0A    	jmp strchr_L0
0052++ 0A64             strchr_end:
0053++ 0A64 1B          	mov al, bl
0054++ 0A65 09          	ret
0055++ 0A66             
0056++ 0A66             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0A66             ; strstr
0058++ 0A66             ; find sub-string
0059++ 0A66             ; str1 in SI
0060++ 0A66             ; str2 in DI
0061++ 0A66             ; SI points to end of source string
0062++ 0A66             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0A66             strstr:
0064++ 0A66 DB          	push al
0065++ 0A67 DA          	push d
0066++ 0A68 E3          	push di
0067++ 0A69             strstr_loop:
0068++ 0A69 F3          	cmpsb					; compare a byte of the strings
0069++ 0A6A C7 75 0A    	jne strstr_ret
0070++ 0A6D FC 00 00    	lea d, [di + 0]
0071++ 0A70 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0A72 C7 69 0A    	jne strstr_loop				; equal chars but not at end
0073++ 0A75             strstr_ret:
0074++ 0A75 F0          	pop di
0075++ 0A76 E7          	pop d
0076++ 0A77 E8          	pop al
0077++ 0A78 09          	ret
0078++ 0A79             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0A79             ; length of null terminated string
0080++ 0A79             ; result in C
0081++ 0A79             ; pointer in D
0082++ 0A79             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0A79             strlen:
0084++ 0A79 DA          	push d
0085++ 0A7A 38 00 00    	mov c, 0
0086++ 0A7D             strlen_L1:
0087++ 0A7D BD 00       	cmp byte [d], 0
0088++ 0A7F C6 87 0A    	je strlen_ret
0089++ 0A82 79          	inc d
0090++ 0A83 78          	inc c
0091++ 0A84 0A 7D 0A    	jmp strlen_L1
0092++ 0A87             strlen_ret:
0093++ 0A87 E7          	pop d
0094++ 0A88 09          	ret
0095++ 0A89             
0096++ 0A89             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0A89             ; STRCMP
0098++ 0A89             ; compare two strings
0099++ 0A89             ; str1 in SI
0100++ 0A89             ; str2 in DI
0101++ 0A89             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0A89             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0A89             strcmp:
0104++ 0A89 DB          	push al
0105++ 0A8A DA          	push d
0106++ 0A8B E3          	push di
0107++ 0A8C E2          	push si
0108++ 0A8D             strcmp_loop:
0109++ 0A8D F3          	cmpsb					; compare a byte of the strings
0110++ 0A8E C7 99 0A    	jne strcmp_ret
0111++ 0A91 FB FF FF    	lea d, [si +- 1]
0112++ 0A94 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0A96 C7 8D 0A    	jne strcmp_loop				; equal chars but not at end
0114++ 0A99             strcmp_ret:
0115++ 0A99 EF          	pop si
0116++ 0A9A F0          	pop di
0117++ 0A9B E7          	pop d
0118++ 0A9C E8          	pop al
0119++ 0A9D 09          	ret
0120++ 0A9E             
0121++ 0A9E             
0122++ 0A9E             ; STRCPY
0123++ 0A9E             ; copy null terminated string from SI to DI
0124++ 0A9E             ; source in SI
0125++ 0A9E             ; destination in DI
0126++ 0A9E             strcpy:
0127++ 0A9E E2          	push si
0128++ 0A9F E3          	push di
0129++ 0AA0 DB          	push al
0130++ 0AA1             strcpy_L1:
0131++ 0AA1 F6          	lodsb
0132++ 0AA2 F7          	stosb
0133++ 0AA3 B9 00       	cmp al, 0
0134++ 0AA5 C7 A1 0A    	jne strcpy_L1
0135++ 0AA8             strcpy_end:
0136++ 0AA8 E8          	pop al
0137++ 0AA9 F0          	pop di
0138++ 0AAA EF          	pop si
0139++ 0AAB 09          	ret
0140++ 0AAC             
0141++ 0AAC             ; STRCAT
0142++ 0AAC             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0AAC             ; source in SI
0144++ 0AAC             ; destination in DI
0145++ 0AAC             strcat:
0146++ 0AAC E2          	push si
0147++ 0AAD E3          	push di
0148++ 0AAE D7          	push a
0149++ 0AAF DA          	push d
0150++ 0AB0 50          	mov a, di
0151++ 0AB1 3C          	mov d, a
0152++ 0AB2             strcat_goto_end_L1:
0153++ 0AB2 BD 00       	cmp byte[d], 0
0154++ 0AB4 C6 BB 0A    	je strcat_start
0155++ 0AB7 79          	inc d
0156++ 0AB8 0A B2 0A    	jmp strcat_goto_end_L1
0157++ 0ABB             strcat_start:
0158++ 0ABB FD 50       	mov di, d
0159++ 0ABD             strcat_L1:
0160++ 0ABD F6          	lodsb
0161++ 0ABE F7          	stosb
0162++ 0ABF B9 00       	cmp al, 0
0163++ 0AC1 C7 BD 0A    	jne strcat_L1
0164++ 0AC4             strcat_end:
0165++ 0AC4 E7          	pop d
0166++ 0AC5 E4          	pop a
0167++ 0AC6 F0          	pop di
0168++ 0AC7 EF          	pop si
0169++ 0AC8 09          	ret
0005+  0AC9             
0006+  0AC9 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  0ACD 34 35 36 37 
0006+  0AD1 38 39 41 42 
0006+  0AD5 43 44 45 46 
0007+  0AD9 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  0ADD 1B 5B 48 00 
0008+  0AE1             
0009+  0AE1 01 00       table_power:.dw 1
0010+  0AE3 0A 00       			.dw 10
0011+  0AE5 64 00       			.dw 100
0012+  0AE7 E8 03       			.dw 1000
0013+  0AE9 10 27       			.dw 10000
0014+  0AEB             
0015+  0AEB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  0AEB             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  0AEB             ; ASCII in BL
0018+  0AEB             ; result in AL
0019+  0AEB             ; ascii for F = 0100 0110
0020+  0AEB             ; ascii for 9 = 0011 1001
0021+  0AEB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  0AEB             hex_ascii_encode:
0023+  0AEB 1B          	mov al, bl
0024+  0AEC 93 40       	test al, $40				; test if letter or number
0025+  0AEE C7 F4 0A    	jnz hex_letter
0026+  0AF1 87 0F       	and al, $0F				; get number
0027+  0AF3 09          	ret
0028+  0AF4             hex_letter:
0029+  0AF4 87 0F       	and al, $0F				; get letter
0030+  0AF6 6A 09       	add al, 9
0031+  0AF8 09          	ret
0032+  0AF9             
0033+  0AF9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  0AF9             ; ATOI
0035+  0AF9             ; 2 letter hex string in B
0036+  0AF9             ; 8bit integer returned in AL
0037+  0AF9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0AF9             atoi:
0039+  0AF9 D8          	push b
0040+  0AFA 07 EB 0A    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  0AFD 30          	mov bl, bh
0042+  0AFE DB          	push al					; save a
0043+  0AFF 07 EB 0A    	call hex_ascii_encode
0044+  0B02 EA          	pop bl	
0045+  0B03 FD 9E 04    	shl al, 4
0046+  0B06 8C          	or al, bl
0047+  0B07 E5          	pop b
0048+  0B08 09          	ret	
0049+  0B09             
0050+  0B09             
0051+  0B09             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  0B09             ; printf
0053+  0B09             ; no need for explanations!
0054+  0B09             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0B09             printf:
0056+  0B09 09          	ret
0057+  0B0A             
0058+  0B0A             
0059+  0B0A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  0B0A             ; scanf
0061+  0B0A             ; no need for explanations!
0062+  0B0A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  0B0A             scanf:
0064+  0B0A 09          	ret
0065+  0B0B             
0066+  0B0B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  0B0B             ; ITOA
0068+  0B0B             ; 8bit value in BL
0069+  0B0B             ; 2 byte ASCII result in A
0070+  0B0B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  0B0B             itoa:
0072+  0B0B DA          	push d
0073+  0B0C D8          	push b
0074+  0B0D A7 00       	mov bh, 0
0075+  0B0F FD A4 04    	shr bl, 4	
0076+  0B12 74          	mov d, b
0077+  0B13 1F C9 0A    	mov al, [d + s_hex_digits]
0078+  0B16 23          	mov ah, al
0079+  0B17             	
0080+  0B17 E5          	pop b
0081+  0B18 D8          	push b
0082+  0B19 A7 00       	mov bh, 0
0083+  0B1B FD 87 0F    	and bl, $0F
0084+  0B1E 74          	mov d, b
0085+  0B1F 1F C9 0A    	mov al, [d + s_hex_digits]
0086+  0B22 E5          	pop b
0087+  0B23 E7          	pop d
0088+  0B24 09          	ret
0089+  0B25             
0090+  0B25             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  0B25             ; HEX STRING TO BINARY
0092+  0B25             ; di = destination address
0093+  0B25             ; si = source
0094+  0B25             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  0B25             hex_to_int:
0096+  0B25             hex_to_int_L1:
0097+  0B25 F6          	lodsb					; load from [SI] to AL
0098+  0B26 B9 00       	cmp al, 0				; check if ASCII 0
0099+  0B28 C6 35 0B    	jz hex_to_int_ret
0100+  0B2B 36          	mov bh, al
0101+  0B2C F6          	lodsb
0102+  0B2D 2F          	mov bl, al
0103+  0B2E 07 F9 0A    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  0B31 F7          	stosb					; store AL to [DI]
0105+  0B32 0A 25 0B    	jmp hex_to_int_L1
0106+  0B35             hex_to_int_ret:
0107+  0B35 09          	ret		
0108+  0B36             
0109+  0B36             
0110+  0B36             
0111+  0B36             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  0B36             ; GETCHAR
0113+  0B36             ; char in ah
0114+  0B36             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  0B36             getchar:
0116+  0B36 DB          	push al
0117+  0B37             getchar_retry:
0118+  0B37 FD 0C       	sti
0119+  0B39 19 01       	mov al, 1
0120+  0B3B 05 03       	syscall sys_io			; receive in AH
0121+  0B3D B9 00       	cmp al, 0			; check if any char was receive
0122+  0B3F C6 37 0B    	je getchar_retry
0123+  0B42 E8          	pop al
0124+  0B43 09          	ret
0125+  0B44             
0126+  0B44             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  0B44             ; PUTCHAR
0128+  0B44             ; char in ah
0129+  0B44             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0B44             putchar:
0131+  0B44 D7          	push a
0132+  0B45 19 00       	mov al, 0
0133+  0B47 05 03       	syscall sys_io			; char in AH
0134+  0B49 E4          	pop a
0135+  0B4A 09          	ret
0136+  0B4B             
0137+  0B4B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  0B4B             ;; INPUT A STRING
0139+  0B4B             ;; terminates with null
0140+  0B4B             ;; pointer in D
0141+  0B4B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  0B4B             gets:
0143+  0B4B D7          	push a
0144+  0B4C DA          	push d
0145+  0B4D             gets_loop:
0146+  0B4D FD 0C       	sti
0147+  0B4F 19 01       	mov al, 1
0148+  0B51 05 03       	syscall sys_io			; receive in AH
0149+  0B53 B9 00       	cmp al, 0				; check error code (AL)
0150+  0B55 C6 4D 0B    	je gets_loop			; if no char received, retry
0151+  0B58             
0152+  0B58 76 1B       	cmp ah, 27
0153+  0B5A C6 7B 0B    	je gets_telnet_escape
0154+  0B5D 76 0A       	cmp ah, $0A				; LF
0155+  0B5F C6 D4 0B    	je gets_end
0156+  0B62 76 0D       	cmp ah, $0D				; CR
0157+  0B64 C6 D4 0B    	je gets_end
0158+  0B67 76 5C       	cmp ah, $5C				; '\\'
0159+  0B69 C6 AB 0B    	je gets_escape
0160+  0B6C             	
0161+  0B6C 76 08       	cmp ah, $08			; check for backspace
0162+  0B6E C6 77 0B    	je gets_backspace
0163+  0B71             
0164+  0B71 1A          	mov al, ah
0165+  0B72 3E          	mov [d], al
0166+  0B73 79          	inc d
0167+  0B74 0A 4D 0B    	jmp gets_loop
0168+  0B77             gets_backspace:
0169+  0B77 7F          	dec d
0170+  0B78 0A 4D 0B    	jmp gets_loop
0171+  0B7B             gets_telnet_escape:
0172+  0B7B FD 0C       	sti
0173+  0B7D 19 01       	mov al, 1
0174+  0B7F 05 03       	syscall sys_io				; receive in AH without echo
0175+  0B81 B9 00       	cmp al, 0					; check error code (AL)
0176+  0B83 C6 7B 0B    	je gets_telnet_escape		; if no char received, retry
0177+  0B86 76 5B       	cmp ah, '['
0178+  0B88 C7 4D 0B    	jne gets_loop
0179+  0B8B             gets_telnet_escape_phase2:
0180+  0B8B FD 0C       	sti
0181+  0B8D 19 01       	mov al, 1
0182+  0B8F 05 03       	syscall sys_io					; receive in AH without echo
0183+  0B91 B9 00       	cmp al, 0						; check error code (AL)
0184+  0B93 C6 8B 0B    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  0B96 76 44       	cmp ah, 'D'
0186+  0B98 C6 A3 0B    	je gets_left_arrow
0187+  0B9B 76 43       	cmp ah, 'C'
0188+  0B9D C6 A7 0B    	je gets_right_arrow
0189+  0BA0 0A 4D 0B    	jmp gets_loop
0190+  0BA3             gets_left_arrow:
0191+  0BA3 7F          	dec d
0192+  0BA4 0A 4D 0B    	jmp gets_loop
0193+  0BA7             gets_right_arrow:
0194+  0BA7 79          	inc d
0195+  0BA8 0A 4D 0B    	jmp gets_loop
0196+  0BAB             gets_escape:
0197+  0BAB FD 0C       	sti
0198+  0BAD 19 01       	mov al, 1
0199+  0BAF 05 03       	syscall sys_io			; receive in AH
0200+  0BB1 B9 00       	cmp al, 0				; check error code (AL)
0201+  0BB3 C6 AB 0B    	je gets_escape			; if no char received, retry
0202+  0BB6 76 6E       	cmp ah, 'n'
0203+  0BB8 C6 C6 0B    	je gets_LF
0204+  0BBB 76 72       	cmp ah, 'r'
0205+  0BBD C6 CD 0B    	je gets_CR
0206+  0BC0 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  0BC1 3E          	mov [d], al
0208+  0BC2 79          	inc d
0209+  0BC3 0A 4D 0B    	jmp gets_loop
0210+  0BC6             gets_LF:
0211+  0BC6 19 0A       	mov al, $0A
0212+  0BC8 3E          	mov [d], al
0213+  0BC9 79          	inc d
0214+  0BCA 0A 4D 0B    	jmp gets_loop
0215+  0BCD             gets_CR:
0216+  0BCD 19 0D       	mov al, $0D
0217+  0BCF 3E          	mov [d], al
0218+  0BD0 79          	inc d
0219+  0BD1 0A 4D 0B    	jmp gets_loop
0220+  0BD4             gets_end:
0221+  0BD4 19 00       	mov al, 0
0222+  0BD6 3E          	mov [d], al				; terminate string
0223+  0BD7 E7          	pop d
0224+  0BD8 E4          	pop a
0225+  0BD9 09          	ret
0226+  0BDA             
0227+  0BDA             
0228+  0BDA             
0229+  0BDA             
0230+  0BDA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  0BDA             ;; INPUT TEXT
0232+  0BDA             ;; terminated with CTRL+D
0233+  0BDA             ;; pointer in D
0234+  0BDA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  0BDA             gettxt:
0236+  0BDA D7          	push a
0237+  0BDB DA          	push d
0238+  0BDC             gettxt_loop:
0239+  0BDC 19 01       	mov al, 1
0240+  0BDE 05 03       	syscall sys_io			; receive in AH
0241+  0BE0 B9 00       	cmp al, 0				; check error code (AL)
0242+  0BE2 C6 DC 0B    	je gettxt_loop		; if no char received, retry
0243+  0BE5 76 04       	cmp ah, 4			; EOT
0244+  0BE7 C6 25 0C    	je gettxt_end
0245+  0BEA 76 08       	cmp ah, $08			; check for backspace
0246+  0BEC C6 21 0C    	je gettxt_backspace
0247+  0BEF 76 5C       	cmp ah, $5C				; '\\'
0248+  0BF1 C6 FA 0B    	je gettxt_escape
0249+  0BF4 1A          	mov al, ah
0250+  0BF5 3E          	mov [d], al
0251+  0BF6 79          	inc d
0252+  0BF7 0A DC 0B    	jmp gettxt_loop
0253+  0BFA             gettxt_escape:
0254+  0BFA 19 01       	mov al, 1
0255+  0BFC 05 03       	syscall sys_io			; receive in AH
0256+  0BFE B9 00       	cmp al, 0				; check error code (AL)
0257+  0C00 C6 FA 0B    	je gettxt_escape		; if no char received, retry
0258+  0C03 76 6E       	cmp ah, 'n'
0259+  0C05 C6 13 0C    	je gettxt_LF
0260+  0C08 76 72       	cmp ah, 'r'
0261+  0C0A C6 1A 0C    	je gettxt_CR
0262+  0C0D 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  0C0E 3E          	mov [d], al
0264+  0C0F 79          	inc d
0265+  0C10 0A DC 0B    	jmp gettxt_loop
0266+  0C13             gettxt_LF:
0267+  0C13 19 0A       	mov al, $0A
0268+  0C15 3E          	mov [d], al
0269+  0C16 79          	inc d
0270+  0C17 0A DC 0B    	jmp gettxt_loop
0271+  0C1A             gettxt_CR:
0272+  0C1A 19 0D       	mov al, $0D
0273+  0C1C 3E          	mov [d], al
0274+  0C1D 79          	inc d
0275+  0C1E 0A DC 0B    	jmp gettxt_loop
0276+  0C21             gettxt_backspace:
0277+  0C21 7F          	dec d
0278+  0C22 0A DC 0B    	jmp gettxt_loop
0279+  0C25             gettxt_end:
0280+  0C25 19 00       	mov al, 0
0281+  0C27 3E          	mov [d], al				; terminate string
0282+  0C28 E7          	pop d
0283+  0C29 E4          	pop a
0284+  0C2A 09          	ret
0285+  0C2B             
0286+  0C2B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  0C2B             ; PRINT NEW LINE
0288+  0C2B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  0C2B             printnl:
0290+  0C2B D7          	push a
0291+  0C2C 10 00 0A    	mov a, $0A00
0292+  0C2F 05 03       	syscall sys_io
0293+  0C31 10 00 0D    	mov a, $0D00
0294+  0C34 05 03       	syscall sys_io
0295+  0C36 E4          	pop a
0296+  0C37 09          	ret
0297+  0C38             
0298+  0C38             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  0C38             ; strtoint
0300+  0C38             ; 4 digit hex string number in d
0301+  0C38             ; integer returned in A
0302+  0C38             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  0C38             strtointx:
0304+  0C38 D8          	push b
0305+  0C39 32          	mov bl, [d]
0306+  0C3A 37          	mov bh, bl
0307+  0C3B 33 01 00    	mov bl, [d + 1]
0308+  0C3E 07 F9 0A    	call atoi				; convert to int in AL
0309+  0C41 23          	mov ah, al				; move to AH
0310+  0C42 33 02 00    	mov bl, [d + 2]
0311+  0C45 37          	mov bh, bl
0312+  0C46 33 03 00    	mov bl, [d + 3]
0313+  0C49 07 F9 0A    	call atoi				; convert to int in AL
0314+  0C4C E5          	pop b
0315+  0C4D 09          	ret
0316+  0C4E             
0317+  0C4E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  0C4E             ; strtoint
0319+  0C4E             ; 5 digit base10 string number in d
0320+  0C4E             ; integer returned in A
0321+  0C4E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  0C4E             strtoint:
0323+  0C4E E2          	push si
0324+  0C4F D8          	push b
0325+  0C50 D9          	push c
0326+  0C51 DA          	push d
0327+  0C52 07 79 0A    	call strlen			; get string length in C
0328+  0C55 7E          	dec c
0329+  0C56 FD 4E       	mov si, d
0330+  0C58 12          	mov a, c
0331+  0C59 FD 99       	shl a
0332+  0C5B 3B E1 0A    	mov d, table_power
0333+  0C5E 59          	add d, a
0334+  0C5F 38 00 00    	mov c, 0
0335+  0C62             strtoint_L0:
0336+  0C62 F6          	lodsb			; load ASCII to al
0337+  0C63 B9 00       	cmp al, 0
0338+  0C65 C6 78 0C    	je strtoint_end
0339+  0C68 6F 30       	sub al, $30		; make into integer
0340+  0C6A 22 00       	mov ah, 0
0341+  0C6C 2A          	mov b, [d]
0342+  0C6D AC          	mul a, b			; result in B since it fits in 16bits
0343+  0C6E 11          	mov a, b
0344+  0C6F 28          	mov b, c
0345+  0C70 54          	add a, b
0346+  0C71 39          	mov c, a
0347+  0C72 63 02 00    	sub d, 2
0348+  0C75 0A 62 0C    	jmp strtoint_L0
0349+  0C78             strtoint_end:
0350+  0C78 12          	mov a, c
0351+  0C79 E7          	pop d
0352+  0C7A E6          	pop c
0353+  0C7B E5          	pop b
0354+  0C7C EF          	pop si
0355+  0C7D 09          	ret
0356+  0C7E             
0357+  0C7E             
0358+  0C7E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  0C7E             ; PRINT NULL TERMINATED STRING
0360+  0C7E             ; pointer in D
0361+  0C7E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  0C7E             puts:
0363+  0C7E D7          	push a
0364+  0C7F DA          	push d
0365+  0C80             puts_L1:
0366+  0C80 1E          	mov al, [d]
0367+  0C81 B9 00       	cmp al, 0
0368+  0C83 C6 8F 0C    	jz puts_END
0369+  0C86 23          	mov ah, al
0370+  0C87 19 00       	mov al, 0
0371+  0C89 05 03       	syscall sys_io
0372+  0C8B 79          	inc d
0373+  0C8C 0A 80 0C    	jmp puts_L1
0374+  0C8F             puts_END:
0375+  0C8F E7          	pop d
0376+  0C90 E4          	pop a
0377+  0C91 09          	ret
0378+  0C92             
0379+  0C92             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  0C92             ; PRINT N SIZE STRING
0381+  0C92             ; pointer in D
0382+  0C92             ; size in C
0383+  0C92             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  0C92             putsn:
0385+  0C92 DB          	push al
0386+  0C93 DA          	push d
0387+  0C94 D9          	push c
0388+  0C95             putsn_L0:
0389+  0C95 1E          	mov al, [d]
0390+  0C96 23          	mov ah, al
0391+  0C97 19 00       	mov al, 0
0392+  0C99 05 03       	syscall sys_io
0393+  0C9B 79          	inc d
0394+  0C9C 7E          	dec c	
0395+  0C9D C2 00 00    	cmp c, 0
0396+  0CA0 C7 95 0C    	jne putsn_L0
0397+  0CA3             putsn_end:
0398+  0CA3 E6          	pop c
0399+  0CA4 E7          	pop d
0400+  0CA5 E8          	pop al
0401+  0CA6 09          	ret
0402+  0CA7             
0403+  0CA7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  0CA7             ; print 16bit decimal number
0405+  0CA7             ; input number in A
0406+  0CA7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  0CA7             print_u16d:
0408+  0CA7 D7          	push a
0409+  0CA8 D8          	push b
0410+  0CA9 26 10 27    	mov b, 10000
0411+  0CAC AE          	div a, b			; get 10000 coeff.
0412+  0CAD 07 D3 0C    	call print_number
0413+  0CB0 11          	mov a, b
0414+  0CB1 26 E8 03    	mov b, 1000
0415+  0CB4 AE          	div a, b			; get 10000 coeff.
0416+  0CB5 07 D3 0C    	call print_number
0417+  0CB8 11          	mov a, b
0418+  0CB9 26 64 00    	mov b, 100
0419+  0CBC AE          	div a, b
0420+  0CBD 07 D3 0C    	call print_number
0421+  0CC0 11          	mov a, b
0422+  0CC1 26 0A 00    	mov b, 10
0423+  0CC4 AE          	div a, b
0424+  0CC5 07 D3 0C    	call print_number
0425+  0CC8 11          	mov a, b
0426+  0CC9 6A 30       	add al, $30
0427+  0CCB 23          	mov ah, al
0428+  0CCC 19 00       	mov al, 0
0429+  0CCE 05 03       	syscall sys_io	; print coeff
0430+  0CD0 E5          	pop b
0431+  0CD1 E4          	pop a
0432+  0CD2 09          	ret
0433+  0CD3             
0434+  0CD3             
0435+  0CD3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  0CD3             ; if A == 0, print space
0437+  0CD3             ; else print A
0438+  0CD3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0439+  0CD3             print_number:
0440+  0CD3 6A 30       	add al, $30
0441+  0CD5 23          	mov ah, al
0442+  0CD6 07 44 0B    	call putchar
0443+  0CD9 09          	ret
0444+  0CDA             
0445+  0CDA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0446+  0CDA             ; PRINT 16BIT HEX INTEGER
0447+  0CDA             ; integer value in reg B
0448+  0CDA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  0CDA             print_u16x:
0450+  0CDA D7          	push a
0451+  0CDB D8          	push b
0452+  0CDC DD          	push bl
0453+  0CDD 30          	mov bl, bh
0454+  0CDE 07 0B 0B    	call itoa				; convert bh to char in A
0455+  0CE1 2F          	mov bl, al				; save al
0456+  0CE2 19 00       	mov al, 0
0457+  0CE4 05 03       	syscall sys_io				; display AH
0458+  0CE6 24          	mov ah, bl				; retrieve al
0459+  0CE7 19 00       	mov al, 0
0460+  0CE9 05 03       	syscall sys_io				; display AL
0461+  0CEB             
0462+  0CEB EA          	pop bl
0463+  0CEC 07 0B 0B    	call itoa				; convert bh to char in A
0464+  0CEF 2F          	mov bl, al				; save al
0465+  0CF0 19 00       	mov al, 0
0466+  0CF2 05 03       	syscall sys_io				; display AH
0467+  0CF4 24          	mov ah, bl				; retrieve al
0468+  0CF5 19 00       	mov al, 0
0469+  0CF7 05 03       	syscall sys_io				; display AL
0470+  0CF9             
0471+  0CF9 E5          	pop b
0472+  0CFA E4          	pop a
0473+  0CFB 09          	ret
0474+  0CFC             
0475+  0CFC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  0CFC             ; INPUT 16BIT HEX INTEGER
0477+  0CFC             ; read 16bit integer into A
0478+  0CFC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  0CFC             scan_u16x:
0480+  0CFC F8 10 00    	enter 16
0481+  0CFF D8          	push b
0482+  0D00 DA          	push d
0483+  0D01             
0484+  0D01 FA F1 FF    	lea d, [bp + -15]
0485+  0D04 07 4B 0B    	call gets				; get number
0486+  0D07             
0487+  0D07 32          	mov bl, [d]
0488+  0D08 37          	mov bh, bl
0489+  0D09 33 01 00    	mov bl, [d + 1]
0490+  0D0C 07 F9 0A    	call atoi				; convert to int in AL
0491+  0D0F 23          	mov ah, al				; move to AH
0492+  0D10             
0493+  0D10 33 02 00    	mov bl, [d + 2]
0494+  0D13 37          	mov bh, bl
0495+  0D14 33 03 00    	mov bl, [d + 3]
0496+  0D17 07 F9 0A    	call atoi				; convert to int in AL
0497+  0D1A             
0498+  0D1A E7          	pop d
0499+  0D1B E5          	pop b
0500+  0D1C F9          	leave
0501+  0D1D 09          	ret
0502+  0D1E             
0503+  0D1E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0504+  0D1E             ; PRINT 8bit HEX INTEGER
0505+  0D1E             ; integer value in reg bl
0506+  0D1E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  0D1E             print_u8x:
0508+  0D1E D7          	push a
0509+  0D1F DD          	push bl
0510+  0D20             
0511+  0D20 07 0B 0B    	call itoa				; convert bl to char in A
0512+  0D23 2F          	mov bl, al				; save al
0513+  0D24 19 00       	mov al, 0
0514+  0D26 05 03       	syscall sys_io				; display AH
0515+  0D28 24          	mov ah, bl				; retrieve al
0516+  0D29 19 00       	mov al, 0
0517+  0D2B 05 03       	syscall sys_io				; display AL
0518+  0D2D             
0519+  0D2D EA          	pop bl
0520+  0D2E E4          	pop a
0521+  0D2F 09          	ret
0522+  0D30             
0523+  0D30             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0524+  0D30             ; print 8bit decimal unsigned number
0525+  0D30             ; input number in AL
0526+  0D30             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  0D30             print_u8d:
0528+  0D30 D7          	push a
0529+  0D31 D8          	push b
0530+  0D32             
0531+  0D32 22 00       	mov ah, 0
0532+  0D34 26 64 00    	mov b, 100
0533+  0D37 AE          	div a, b
0534+  0D38 D8          	push b			; save remainder
0535+  0D39 B9 00       	cmp al, 0
0536+  0D3B C6 45 0D    	je skip100
0537+  0D3E 6A 30       	add al, $30
0538+  0D40 23          	mov ah, al
0539+  0D41 19 00       	mov al, 0
0540+  0D43 05 03       	syscall sys_io	; print coeff
0541+  0D45             skip100:
0542+  0D45 E4          	pop a
0543+  0D46 22 00       	mov ah, 0
0544+  0D48 26 0A 00    	mov b, 10
0545+  0D4B AE          	div a, b
0546+  0D4C D8          	push b			; save remainder
0547+  0D4D B9 00       	cmp al, 0
0548+  0D4F C6 59 0D    	je skip10
0549+  0D52 6A 30       	add al, $30
0550+  0D54 23          	mov ah, al
0551+  0D55 19 00       	mov al, 0
0552+  0D57 05 03       	syscall sys_io	; print coeff
0553+  0D59             skip10:
0554+  0D59 E4          	pop a
0555+  0D5A 1B          	mov al, bl
0556+  0D5B 6A 30       	add al, $30
0557+  0D5D 23          	mov ah, al
0558+  0D5E 19 00       	mov al, 0
0559+  0D60 05 03       	syscall sys_io	; print coeff
0560+  0D62 E5          	pop b
0561+  0D63 E4          	pop a
0562+  0D64 09          	ret
0563+  0D65             
0564+  0D65             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0565+  0D65             ; INPUT 8BIT HEX INTEGER
0566+  0D65             ; read 8bit integer into AL
0567+  0D65             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  0D65             scan_u8x:
0569+  0D65 F8 04 00    	enter 4
0570+  0D68 D8          	push b
0571+  0D69 DA          	push d
0572+  0D6A             
0573+  0D6A FA FD FF    	lea d, [bp + -3]
0574+  0D6D 07 4B 0B    	call gets				; get number
0575+  0D70             
0576+  0D70 32          	mov bl, [d]
0577+  0D71 37          	mov bh, bl
0578+  0D72 33 01 00    	mov bl, [d + 1]
0579+  0D75 07 F9 0A    	call atoi				; convert to int in AL
0580+  0D78             
0581+  0D78 E7          	pop d
0582+  0D79 E5          	pop b
0583+  0D7A F9          	leave
0584+  0D7B 09          	ret
0585+  0D7C             
0586+  0D7C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  0D7C             ; input decimal number
0588+  0D7C             ; result in A
0589+  0D7C             ; 655'\0'
0590+  0D7C             ; low--------high
0591+  0D7C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0592+  0D7C             scan_u16d:
0593+  0D7C F8 08 00    	enter 8
0594+  0D7F E2          	push si
0595+  0D80 D8          	push b
0596+  0D81 D9          	push c
0597+  0D82 DA          	push d
0598+  0D83 FA F9 FF    	lea d, [bp +- 7]
0599+  0D86 07 4B 0B    	call gets
0600+  0D89 07 79 0A    	call strlen			; get string length in C
0601+  0D8C 7E          	dec c
0602+  0D8D FD 4E       	mov si, d
0603+  0D8F 12          	mov a, c
0604+  0D90 FD 99       	shl a
0605+  0D92 3B E1 0A    	mov d, table_power
0606+  0D95 59          	add d, a
0607+  0D96 38 00 00    	mov c, 0
0608+  0D99             mul_loop:
0609+  0D99 F6          	lodsb			; load ASCII to al
0610+  0D9A B9 00       	cmp al, 0
0611+  0D9C C6 AF 0D    	je mul_exit
0612+  0D9F 6F 30       	sub al, $30		; make into integer
0613+  0DA1 22 00       	mov ah, 0
0614+  0DA3 2A          	mov b, [d]
0615+  0DA4 AC          	mul a, b			; result in B since it fits in 16bits
0616+  0DA5 11          	mov a, b
0617+  0DA6 28          	mov b, c
0618+  0DA7 54          	add a, b
0619+  0DA8 39          	mov c, a
0620+  0DA9 63 02 00    	sub d, 2
0621+  0DAC 0A 99 0D    	jmp mul_loop
0622+  0DAF             mul_exit:
0623+  0DAF 12          	mov a, c
0624+  0DB0 E7          	pop d
0625+  0DB1 E6          	pop c
0626+  0DB2 E5          	pop b
0627+  0DB3 EF          	pop si
0628+  0DB4 F9          	leave
0629+  0DB5 09          	ret
0736   0DB6             ; --- END INCLUDE BLOCK
0737   0DB6             
0738   0DB6             
0739   0DB6             .end
tasm: Number of errors = 0
