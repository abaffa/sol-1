0001   0000             ; --- FILENAME: test.c
0002   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0400             .org PROC_TEXT_ORG
0004   0400             
0005   0400             ; --- BEGIN TEXT BLOCK
0006   0400             main:
0007   0400 D2            push bp
0008   0401 9B            mov bp, sp
0009   0402 52 02 00      sub sp, 2 ; a
0010   0405 FA FF FF      lea d, [bp + -1]
0011   0408 2D            mov b, d
0012   0409 FD AB         swp b
0013   040B D8            push b
0014   040C 07 54 04      call scann
0015   040F 51 02 00      add sp, 2
0016   0412             _switch1_expr:
0017   0412 2C FF FF      mov b, [bp + -1] ; a
0018   0415             _switch1_comparisons:
0019   0415 C0 01 00      cmp b, 1
0020   0418 C6 30 04      je _switch1_case0
0021   041B C0 02 00      cmp b, 2
0022   041E C6 3F 04      je _switch1_case1
0023   0421             _switch1_default:
0024   0421 26 63 00      mov b, 99
0025   0424 FD AB         swp b
0026   0426 D8            push b
0027   0427 07 6B 04      call printn
0028   042A 51 02 00      add sp, 2
0029   042D 0A 4E 04      jmp _switch1_exit
0030   0430             _switch1_case0:
0031   0430 26 01 00      mov b, 1
0032   0433 FD AB         swp b
0033   0435 D8            push b
0034   0436 07 6B 04      call printn
0035   0439 51 02 00      add sp, 2
0036   043C 0A 4E 04      jmp _switch1_exit ; case break
0037   043F             _switch1_case1:
0038   043F 26 02 00      mov b, 2
0039   0442 FD AB         swp b
0040   0444 D8            push b
0041   0445 07 6B 04      call printn
0042   0448 51 02 00      add sp, 2
0043   044B 0A 4E 04      jmp _switch1_exit ; case break
0044   044E             _switch1_exit:
0045   044E 26 00 00      mov b, 0
0046   0451 F9            leave
0047   0452 05 0B         syscall sys_terminate_proc
0048   0454             scann:
0049   0454 D2            push bp
0050   0455 9B            mov bp, sp
0051   0456 52 02 00      sub sp, 2 ; m
0052   0459             
0053   0459             ; --- BEGIN INLINE ASM BLOCK
0054   0459 07 F5 07      call scan_u16d
0055   045C 45 FF FF      mov [bp + -1], a
0056   045F             ; --- END INLINE ASM BLOCK
0057   045F             
0058   045F FA 05 00      lea d, [bp + 5] ; n
0059   0462 2A            mov b, [d]
0060   0463 74            mov d, b
0061   0464 2C FF FF      mov b, [bp + -1] ; m
0062   0467 11            mov a, b
0063   0468 43            mov [d], a
0064   0469 F9            leave
0065   046A 09            ret
0066   046B             printn:
0067   046B D2            push bp
0068   046C 9B            mov bp, sp
0069   046D             
0070   046D             ; --- BEGIN INLINE ASM BLOCK
0071   046D 17 05 00      mov a, [bp + 5]
0072   0470 07 20 07      call print_u16d
0073   0473             ; --- END INLINE ASM BLOCK
0074   0473             
0075   0473 F9            leave
0076   0474 09            ret
0077   0475             print:
0078   0475 D2            push bp
0079   0476 9B            mov bp, sp
0080   0477             
0081   0477             ; --- BEGIN INLINE ASM BLOCK
0082   0477 17 05 00      mov a, [bp + 5]
0083   047A 3C            mov d, a
0084   047B 07 F7 06      call puts
0085   047E             ; --- END INLINE ASM BLOCK
0086   047E             
0087   047E F9            leave
0088   047F 09            ret
0089   0480             ; --- END TEXT BLOCK
0090   0480             
0091   0480             ; --- BEGIN DATA BLOCK
0092   0480             s_data: 
0093   0480 01 00 02 00 .dw 1, 2, _string_0, 
0093   0484 A6 04 
0094   0486 00 00 00 00 .fill 26, 0
0094   048A 00 00 00 00 
0094   048E 00 00 00 00 
0094   0492 00 00 00 00 
0094   0496 00 00 00 00 
0094   049A 00 00 00 00 
0094   049E 00 00 
0095   04A0 80 04       s: .dw s_data
0096   04A2             i_data: 
0097   04A2 16 00       .dw 22, 
0098   04A4             .fill 0, 0
0099   04A4 A2 04       i: .dw i_data
0100   04A6 48 65 6C 6F _string_0: .db "Helo", 0
0100   04AA 00 
0101   04AB             ; --- END DATA BLOCK
0102   04AB             
0103   04AB             ; --- BEGIN INCLUDE BLOCK
0104   04AB             .include "lib/stdio.asm"
0001+  04AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  04AB             ; stdio.s
0003+  04AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  04AB             .include "lib/string.asm"
0001++ 04AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 04AB             ; string.s
0003++ 04AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 04AB             
0005++ 04AB             
0006++ 04AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 04AB             ; strrev
0008++ 04AB             ; reverse a string
0009++ 04AB             ; D = string address
0010++ 04AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 04AB             ; 01234
0012++ 04AB             strrev:
0013++ 04AB 4B          	pusha
0014++ 04AC 07 F2 04    	call strlen	; length in C
0015++ 04AF 12          	mov a, c
0016++ 04B0 AF 01 00    	cmp a, 1
0017++ 04B3 D0 CD 04    	jleu strrev_end	; check string length. string len must be > 1
0018++ 04B6 7D          	dec a
0019++ 04B7 FD 4E       	mov si, d	; beginning of string
0020++ 04B9 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 04BB 59          	add d, a	; end of string
0022++ 04BC 12          	mov a, c
0023++ 04BD FD 9B       	shr a		; divide by 2
0024++ 04BF 39          	mov c, a	; C now counts the steps
0025++ 04C0             strrev_L0:
0026++ 04C0 32          	mov bl, [d]	; save load right-side char into BL
0027++ 04C1 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 04C2 3E          	mov [d], al	; store left char into right side
0029++ 04C3 1B          	mov al, bl
0030++ 04C4 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 04C5 7E          	dec c
0032++ 04C6 7F          	dec d
0033++ 04C7 C2 00 00    	cmp c, 0
0034++ 04CA C7 C0 04    	jne strrev_L0
0035++ 04CD             strrev_end:
0036++ 04CD 4C          	popa
0037++ 04CE 09          	ret
0038++ 04CF             	
0039++ 04CF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 04CF             ; strchr
0041++ 04CF             ; search string in D for char in AL
0042++ 04CF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 04CF             strchr:
0044++ 04CF             strchr_L0:
0045++ 04CF 32          	mov bl, [d]
0046++ 04D0 C1 00       	cmp bl, 0
0047++ 04D2 C6 DD 04    	je strchr_end
0048++ 04D5 BA          	cmp al, bl
0049++ 04D6 C6 DD 04    	je strchr_end
0050++ 04D9 79          	inc d
0051++ 04DA 0A CF 04    	jmp strchr_L0
0052++ 04DD             strchr_end:
0053++ 04DD 1B          	mov al, bl
0054++ 04DE 09          	ret
0055++ 04DF             
0056++ 04DF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 04DF             ; strstr
0058++ 04DF             ; find sub-string
0059++ 04DF             ; str1 in SI
0060++ 04DF             ; str2 in DI
0061++ 04DF             ; SI points to end of source string
0062++ 04DF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 04DF             strstr:
0064++ 04DF DB          	push al
0065++ 04E0 DA          	push d
0066++ 04E1 E3          	push di
0067++ 04E2             strstr_loop:
0068++ 04E2 F3          	cmpsb					; compare a byte of the strings
0069++ 04E3 C7 EE 04    	jne strstr_ret
0070++ 04E6 FC 00 00    	lea d, [di + 0]
0071++ 04E9 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 04EB C7 E2 04    	jne strstr_loop				; equal chars but not at end
0073++ 04EE             strstr_ret:
0074++ 04EE F0          	pop di
0075++ 04EF E7          	pop d
0076++ 04F0 E8          	pop al
0077++ 04F1 09          	ret
0078++ 04F2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 04F2             ; length of null terminated string
0080++ 04F2             ; result in C
0081++ 04F2             ; pointer in D
0082++ 04F2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 04F2             strlen:
0084++ 04F2 DA          	push d
0085++ 04F3 38 00 00    	mov c, 0
0086++ 04F6             strlen_L1:
0087++ 04F6 BD 00       	cmp byte [d], 0
0088++ 04F8 C6 00 05    	je strlen_ret
0089++ 04FB 79          	inc d
0090++ 04FC 78          	inc c
0091++ 04FD 0A F6 04    	jmp strlen_L1
0092++ 0500             strlen_ret:
0093++ 0500 E7          	pop d
0094++ 0501 09          	ret
0095++ 0502             
0096++ 0502             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0502             ; STRCMP
0098++ 0502             ; compare two strings
0099++ 0502             ; str1 in SI
0100++ 0502             ; str2 in DI
0101++ 0502             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0502             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0502             strcmp:
0104++ 0502 DB          	push al
0105++ 0503 DA          	push d
0106++ 0504 E3          	push di
0107++ 0505 E2          	push si
0108++ 0506             strcmp_loop:
0109++ 0506 F3          	cmpsb					; compare a byte of the strings
0110++ 0507 C7 12 05    	jne strcmp_ret
0111++ 050A FB FF FF    	lea d, [si +- 1]
0112++ 050D BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 050F C7 06 05    	jne strcmp_loop				; equal chars but not at end
0114++ 0512             strcmp_ret:
0115++ 0512 EF          	pop si
0116++ 0513 F0          	pop di
0117++ 0514 E7          	pop d
0118++ 0515 E8          	pop al
0119++ 0516 09          	ret
0120++ 0517             
0121++ 0517             
0122++ 0517             ; STRCPY
0123++ 0517             ; copy null terminated string from SI to DI
0124++ 0517             ; source in SI
0125++ 0517             ; destination in DI
0126++ 0517             strcpy:
0127++ 0517 E2          	push si
0128++ 0518 E3          	push di
0129++ 0519 DB          	push al
0130++ 051A             strcpy_L1:
0131++ 051A F6          	lodsb
0132++ 051B F7          	stosb
0133++ 051C B9 00       	cmp al, 0
0134++ 051E C7 1A 05    	jne strcpy_L1
0135++ 0521             strcpy_end:
0136++ 0521 E8          	pop al
0137++ 0522 F0          	pop di
0138++ 0523 EF          	pop si
0139++ 0524 09          	ret
0140++ 0525             
0141++ 0525             ; STRCAT
0142++ 0525             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0525             ; source in SI
0144++ 0525             ; destination in DI
0145++ 0525             strcat:
0146++ 0525 E2          	push si
0147++ 0526 E3          	push di
0148++ 0527 D7          	push a
0149++ 0528 DA          	push d
0150++ 0529 50          	mov a, di
0151++ 052A 3C          	mov d, a
0152++ 052B             strcat_goto_end_L1:
0153++ 052B BD 00       	cmp byte[d], 0
0154++ 052D C6 34 05    	je strcat_start
0155++ 0530 79          	inc d
0156++ 0531 0A 2B 05    	jmp strcat_goto_end_L1
0157++ 0534             strcat_start:
0158++ 0534 FD 50       	mov di, d
0159++ 0536             strcat_L1:
0160++ 0536 F6          	lodsb
0161++ 0537 F7          	stosb
0162++ 0538 B9 00       	cmp al, 0
0163++ 053A C7 36 05    	jne strcat_L1
0164++ 053D             strcat_end:
0165++ 053D E7          	pop d
0166++ 053E E4          	pop a
0167++ 053F F0          	pop di
0168++ 0540 EF          	pop si
0169++ 0541 09          	ret
0005+  0542             
0006+  0542 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  0546 34 35 36 37 
0006+  054A 38 39 41 42 
0006+  054E 43 44 45 46 
0007+  0552 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  0556 1B 5B 48 00 
0008+  055A             
0009+  055A 01 00       table_power:.dw 1
0010+  055C 0A 00       			.dw 10
0011+  055E 64 00       			.dw 100
0012+  0560 E8 03       			.dw 1000
0013+  0562 10 27       			.dw 10000
0014+  0564             
0015+  0564             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  0564             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  0564             ; ASCII in BL
0018+  0564             ; result in AL
0019+  0564             ; ascii for F = 0100 0110
0020+  0564             ; ascii for 9 = 0011 1001
0021+  0564             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  0564             hex_ascii_encode:
0023+  0564 1B          	mov al, bl
0024+  0565 93 40       	test al, $40				; test if letter or number
0025+  0567 C7 6D 05    	jnz hex_letter
0026+  056A 87 0F       	and al, $0F				; get number
0027+  056C 09          	ret
0028+  056D             hex_letter:
0029+  056D 87 0F       	and al, $0F				; get letter
0030+  056F 6A 09       	add al, 9
0031+  0571 09          	ret
0032+  0572             
0033+  0572             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  0572             ; ATOI
0035+  0572             ; 2 letter hex string in B
0036+  0572             ; 8bit integer returned in AL
0037+  0572             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0572             atoi:
0039+  0572 D8          	push b
0040+  0573 07 64 05    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  0576 30          	mov bl, bh
0042+  0577 DB          	push al					; save a
0043+  0578 07 64 05    	call hex_ascii_encode
0044+  057B EA          	pop bl	
0045+  057C FD 9E 04    	shl al, 4
0046+  057F 8C          	or al, bl
0047+  0580 E5          	pop b
0048+  0581 09          	ret	
0049+  0582             
0050+  0582             
0051+  0582             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  0582             ; printf
0053+  0582             ; no need for explanations!
0054+  0582             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0582             printf:
0056+  0582 09          	ret
0057+  0583             
0058+  0583             
0059+  0583             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  0583             ; scanf
0061+  0583             ; no need for explanations!
0062+  0583             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  0583             scanf:
0064+  0583 09          	ret
0065+  0584             
0066+  0584             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  0584             ; ITOA
0068+  0584             ; 8bit value in BL
0069+  0584             ; 2 byte ASCII result in A
0070+  0584             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  0584             itoa:
0072+  0584 DA          	push d
0073+  0585 D8          	push b
0074+  0586 A7 00       	mov bh, 0
0075+  0588 FD A4 04    	shr bl, 4	
0076+  058B 74          	mov d, b
0077+  058C 1F 42 05    	mov al, [d + s_hex_digits]
0078+  058F 23          	mov ah, al
0079+  0590             	
0080+  0590 E5          	pop b
0081+  0591 D8          	push b
0082+  0592 A7 00       	mov bh, 0
0083+  0594 FD 87 0F    	and bl, $0F
0084+  0597 74          	mov d, b
0085+  0598 1F 42 05    	mov al, [d + s_hex_digits]
0086+  059B E5          	pop b
0087+  059C E7          	pop d
0088+  059D 09          	ret
0089+  059E             
0090+  059E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  059E             ; HEX STRING TO BINARY
0092+  059E             ; di = destination address
0093+  059E             ; si = source
0094+  059E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  059E             hex_to_int:
0096+  059E             hex_to_int_L1:
0097+  059E F6          	lodsb					; load from [SI] to AL
0098+  059F B9 00       	cmp al, 0				; check if ASCII 0
0099+  05A1 C6 AE 05    	jz hex_to_int_ret
0100+  05A4 36          	mov bh, al
0101+  05A5 F6          	lodsb
0102+  05A6 2F          	mov bl, al
0103+  05A7 07 72 05    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  05AA F7          	stosb					; store AL to [DI]
0105+  05AB 0A 9E 05    	jmp hex_to_int_L1
0106+  05AE             hex_to_int_ret:
0107+  05AE 09          	ret		
0108+  05AF             
0109+  05AF             
0110+  05AF             
0111+  05AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  05AF             ; GETCHAR
0113+  05AF             ; char in ah
0114+  05AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  05AF             getchar:
0116+  05AF DB          	push al
0117+  05B0             getchar_retry:
0118+  05B0 FD 0C       	sti
0119+  05B2 19 01       	mov al, 1
0120+  05B4 05 03       	syscall sys_io			; receive in AH
0121+  05B6 B9 00       	cmp al, 0			; check if any char was receive
0122+  05B8 C6 B0 05    	je getchar_retry
0123+  05BB E8          	pop al
0124+  05BC 09          	ret
0125+  05BD             
0126+  05BD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  05BD             ; PUTCHAR
0128+  05BD             ; char in ah
0129+  05BD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  05BD             putchar:
0131+  05BD D7          	push a
0132+  05BE 19 00       	mov al, 0
0133+  05C0 05 03       	syscall sys_io			; char in AH
0134+  05C2 E4          	pop a
0135+  05C3 09          	ret
0136+  05C4             
0137+  05C4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  05C4             ;; INPUT A STRING
0139+  05C4             ;; terminates with null
0140+  05C4             ;; pointer in D
0141+  05C4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  05C4             gets:
0143+  05C4 D7          	push a
0144+  05C5 DA          	push d
0145+  05C6             gets_loop:
0146+  05C6 FD 0C       	sti
0147+  05C8 19 01       	mov al, 1
0148+  05CA 05 03       	syscall sys_io			; receive in AH
0149+  05CC B9 00       	cmp al, 0				; check error code (AL)
0150+  05CE C6 C6 05    	je gets_loop			; if no char received, retry
0151+  05D1             
0152+  05D1 76 1B       	cmp ah, 27
0153+  05D3 C6 F4 05    	je gets_telnet_escape
0154+  05D6 76 0A       	cmp ah, $0A				; LF
0155+  05D8 C6 4D 06    	je gets_end
0156+  05DB 76 0D       	cmp ah, $0D				; CR
0157+  05DD C6 4D 06    	je gets_end
0158+  05E0 76 5C       	cmp ah, $5C				; '\\'
0159+  05E2 C6 24 06    	je gets_escape
0160+  05E5             	
0161+  05E5 76 08       	cmp ah, $08			; check for backspace
0162+  05E7 C6 F0 05    	je gets_backspace
0163+  05EA             
0164+  05EA 1A          	mov al, ah
0165+  05EB 3E          	mov [d], al
0166+  05EC 79          	inc d
0167+  05ED 0A C6 05    	jmp gets_loop
0168+  05F0             gets_backspace:
0169+  05F0 7F          	dec d
0170+  05F1 0A C6 05    	jmp gets_loop
0171+  05F4             gets_telnet_escape:
0172+  05F4 FD 0C       	sti
0173+  05F6 19 01       	mov al, 1
0174+  05F8 05 03       	syscall sys_io				; receive in AH without echo
0175+  05FA B9 00       	cmp al, 0					; check error code (AL)
0176+  05FC C6 F4 05    	je gets_telnet_escape		; if no char received, retry
0177+  05FF 76 5B       	cmp ah, '['
0178+  0601 C7 C6 05    	jne gets_loop
0179+  0604             gets_telnet_escape_phase2:
0180+  0604 FD 0C       	sti
0181+  0606 19 01       	mov al, 1
0182+  0608 05 03       	syscall sys_io					; receive in AH without echo
0183+  060A B9 00       	cmp al, 0						; check error code (AL)
0184+  060C C6 04 06    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  060F 76 44       	cmp ah, 'D'
0186+  0611 C6 1C 06    	je gets_left_arrow
0187+  0614 76 43       	cmp ah, 'C'
0188+  0616 C6 20 06    	je gets_right_arrow
0189+  0619 0A C6 05    	jmp gets_loop
0190+  061C             gets_left_arrow:
0191+  061C 7F          	dec d
0192+  061D 0A C6 05    	jmp gets_loop
0193+  0620             gets_right_arrow:
0194+  0620 79          	inc d
0195+  0621 0A C6 05    	jmp gets_loop
0196+  0624             gets_escape:
0197+  0624 FD 0C       	sti
0198+  0626 19 01       	mov al, 1
0199+  0628 05 03       	syscall sys_io			; receive in AH
0200+  062A B9 00       	cmp al, 0				; check error code (AL)
0201+  062C C6 24 06    	je gets_escape			; if no char received, retry
0202+  062F 76 6E       	cmp ah, 'n'
0203+  0631 C6 3F 06    	je gets_LF
0204+  0634 76 72       	cmp ah, 'r'
0205+  0636 C6 46 06    	je gets_CR
0206+  0639 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  063A 3E          	mov [d], al
0208+  063B 79          	inc d
0209+  063C 0A C6 05    	jmp gets_loop
0210+  063F             gets_LF:
0211+  063F 19 0A       	mov al, $0A
0212+  0641 3E          	mov [d], al
0213+  0642 79          	inc d
0214+  0643 0A C6 05    	jmp gets_loop
0215+  0646             gets_CR:
0216+  0646 19 0D       	mov al, $0D
0217+  0648 3E          	mov [d], al
0218+  0649 79          	inc d
0219+  064A 0A C6 05    	jmp gets_loop
0220+  064D             gets_end:
0221+  064D 19 00       	mov al, 0
0222+  064F 3E          	mov [d], al				; terminate string
0223+  0650 E7          	pop d
0224+  0651 E4          	pop a
0225+  0652 09          	ret
0226+  0653             
0227+  0653             
0228+  0653             
0229+  0653             
0230+  0653             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  0653             ;; INPUT TEXT
0232+  0653             ;; terminated with CTRL+D
0233+  0653             ;; pointer in D
0234+  0653             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  0653             gettxt:
0236+  0653 D7          	push a
0237+  0654 DA          	push d
0238+  0655             gettxt_loop:
0239+  0655 19 01       	mov al, 1
0240+  0657 05 03       	syscall sys_io			; receive in AH
0241+  0659 B9 00       	cmp al, 0				; check error code (AL)
0242+  065B C6 55 06    	je gettxt_loop		; if no char received, retry
0243+  065E 76 04       	cmp ah, 4			; EOT
0244+  0660 C6 9E 06    	je gettxt_end
0245+  0663 76 08       	cmp ah, $08			; check for backspace
0246+  0665 C6 9A 06    	je gettxt_backspace
0247+  0668 76 5C       	cmp ah, $5C				; '\\'
0248+  066A C6 73 06    	je gettxt_escape
0249+  066D 1A          	mov al, ah
0250+  066E 3E          	mov [d], al
0251+  066F 79          	inc d
0252+  0670 0A 55 06    	jmp gettxt_loop
0253+  0673             gettxt_escape:
0254+  0673 19 01       	mov al, 1
0255+  0675 05 03       	syscall sys_io			; receive in AH
0256+  0677 B9 00       	cmp al, 0				; check error code (AL)
0257+  0679 C6 73 06    	je gettxt_escape		; if no char received, retry
0258+  067C 76 6E       	cmp ah, 'n'
0259+  067E C6 8C 06    	je gettxt_LF
0260+  0681 76 72       	cmp ah, 'r'
0261+  0683 C6 93 06    	je gettxt_CR
0262+  0686 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  0687 3E          	mov [d], al
0264+  0688 79          	inc d
0265+  0689 0A 55 06    	jmp gettxt_loop
0266+  068C             gettxt_LF:
0267+  068C 19 0A       	mov al, $0A
0268+  068E 3E          	mov [d], al
0269+  068F 79          	inc d
0270+  0690 0A 55 06    	jmp gettxt_loop
0271+  0693             gettxt_CR:
0272+  0693 19 0D       	mov al, $0D
0273+  0695 3E          	mov [d], al
0274+  0696 79          	inc d
0275+  0697 0A 55 06    	jmp gettxt_loop
0276+  069A             gettxt_backspace:
0277+  069A 7F          	dec d
0278+  069B 0A 55 06    	jmp gettxt_loop
0279+  069E             gettxt_end:
0280+  069E 19 00       	mov al, 0
0281+  06A0 3E          	mov [d], al				; terminate string
0282+  06A1 E7          	pop d
0283+  06A2 E4          	pop a
0284+  06A3 09          	ret
0285+  06A4             
0286+  06A4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  06A4             ; PRINT NEW LINE
0288+  06A4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  06A4             printnl:
0290+  06A4 D7          	push a
0291+  06A5 10 00 0A    	mov a, $0A00
0292+  06A8 05 03       	syscall sys_io
0293+  06AA 10 00 0D    	mov a, $0D00
0294+  06AD 05 03       	syscall sys_io
0295+  06AF E4          	pop a
0296+  06B0 09          	ret
0297+  06B1             
0298+  06B1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  06B1             ; strtoint
0300+  06B1             ; 4 digit hex string number in d
0301+  06B1             ; integer returned in A
0302+  06B1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  06B1             strtointx:
0304+  06B1 D8          	push b
0305+  06B2 32          	mov bl, [d]
0306+  06B3 37          	mov bh, bl
0307+  06B4 33 01 00    	mov bl, [d + 1]
0308+  06B7 07 72 05    	call atoi				; convert to int in AL
0309+  06BA 23          	mov ah, al				; move to AH
0310+  06BB 33 02 00    	mov bl, [d + 2]
0311+  06BE 37          	mov bh, bl
0312+  06BF 33 03 00    	mov bl, [d + 3]
0313+  06C2 07 72 05    	call atoi				; convert to int in AL
0314+  06C5 E5          	pop b
0315+  06C6 09          	ret
0316+  06C7             
0317+  06C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  06C7             ; strtoint
0319+  06C7             ; 5 digit base10 string number in d
0320+  06C7             ; integer returned in A
0321+  06C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  06C7             strtoint:
0323+  06C7 E2          	push si
0324+  06C8 D8          	push b
0325+  06C9 D9          	push c
0326+  06CA DA          	push d
0327+  06CB 07 F2 04    	call strlen			; get string length in C
0328+  06CE 7E          	dec c
0329+  06CF FD 4E       	mov si, d
0330+  06D1 12          	mov a, c
0331+  06D2 FD 99       	shl a
0332+  06D4 3B 5A 05    	mov d, table_power
0333+  06D7 59          	add d, a
0334+  06D8 38 00 00    	mov c, 0
0335+  06DB             strtoint_L0:
0336+  06DB F6          	lodsb			; load ASCII to al
0337+  06DC B9 00       	cmp al, 0
0338+  06DE C6 F1 06    	je strtoint_end
0339+  06E1 6F 30       	sub al, $30		; make into integer
0340+  06E3 22 00       	mov ah, 0
0341+  06E5 2A          	mov b, [d]
0342+  06E6 AC          	mul a, b			; result in B since it fits in 16bits
0343+  06E7 11          	mov a, b
0344+  06E8 28          	mov b, c
0345+  06E9 54          	add a, b
0346+  06EA 39          	mov c, a
0347+  06EB 63 02 00    	sub d, 2
0348+  06EE 0A DB 06    	jmp strtoint_L0
0349+  06F1             strtoint_end:
0350+  06F1 12          	mov a, c
0351+  06F2 E7          	pop d
0352+  06F3 E6          	pop c
0353+  06F4 E5          	pop b
0354+  06F5 EF          	pop si
0355+  06F6 09          	ret
0356+  06F7             
0357+  06F7             
0358+  06F7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  06F7             ; PRINT NULL TERMINATED STRING
0360+  06F7             ; pointer in D
0361+  06F7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  06F7             puts:
0363+  06F7 D7          	push a
0364+  06F8 DA          	push d
0365+  06F9             puts_L1:
0366+  06F9 1E          	mov al, [d]
0367+  06FA B9 00       	cmp al, 0
0368+  06FC C6 08 07    	jz puts_END
0369+  06FF 23          	mov ah, al
0370+  0700 19 00       	mov al, 0
0371+  0702 05 03       	syscall sys_io
0372+  0704 79          	inc d
0373+  0705 0A F9 06    	jmp puts_L1
0374+  0708             puts_END:
0375+  0708 E7          	pop d
0376+  0709 E4          	pop a
0377+  070A 09          	ret
0378+  070B             
0379+  070B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  070B             ; PRINT N SIZE STRING
0381+  070B             ; pointer in D
0382+  070B             ; size in C
0383+  070B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  070B             putsn:
0385+  070B DB          	push al
0386+  070C DA          	push d
0387+  070D D9          	push c
0388+  070E             putsn_L0:
0389+  070E 1E          	mov al, [d]
0390+  070F 23          	mov ah, al
0391+  0710 19 00       	mov al, 0
0392+  0712 05 03       	syscall sys_io
0393+  0714 79          	inc d
0394+  0715 7E          	dec c	
0395+  0716 C2 00 00    	cmp c, 0
0396+  0719 C7 0E 07    	jne putsn_L0
0397+  071C             putsn_end:
0398+  071C E6          	pop c
0399+  071D E7          	pop d
0400+  071E E8          	pop al
0401+  071F 09          	ret
0402+  0720             
0403+  0720             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  0720             ; print 16bit decimal number
0405+  0720             ; input number in A
0406+  0720             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  0720             print_u16d:
0408+  0720 D7          	push a
0409+  0721 D8          	push b
0410+  0722 26 10 27    	mov b, 10000
0411+  0725 AE          	div a, b			; get 10000 coeff.
0412+  0726 07 4C 07    	call print_number
0413+  0729 11          	mov a, b
0414+  072A 26 E8 03    	mov b, 1000
0415+  072D AE          	div a, b			; get 10000 coeff.
0416+  072E 07 4C 07    	call print_number
0417+  0731 11          	mov a, b
0418+  0732 26 64 00    	mov b, 100
0419+  0735 AE          	div a, b
0420+  0736 07 4C 07    	call print_number
0421+  0739 11          	mov a, b
0422+  073A 26 0A 00    	mov b, 10
0423+  073D AE          	div a, b
0424+  073E 07 4C 07    	call print_number
0425+  0741 11          	mov a, b
0426+  0742 6A 30       	add al, $30
0427+  0744 23          	mov ah, al
0428+  0745 19 00       	mov al, 0
0429+  0747 05 03       	syscall sys_io	; print coeff
0430+  0749 E5          	pop b
0431+  074A E4          	pop a
0432+  074B 09          	ret
0433+  074C             
0434+  074C             
0435+  074C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  074C             ; if A == 0, print space
0437+  074C             ; else print A
0438+  074C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0439+  074C             print_number:
0440+  074C 6A 30       	add al, $30
0441+  074E 23          	mov ah, al
0442+  074F 07 BD 05    	call putchar
0443+  0752 09          	ret
0444+  0753             
0445+  0753             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0446+  0753             ; PRINT 16BIT HEX INTEGER
0447+  0753             ; integer value in reg B
0448+  0753             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  0753             print_u16x:
0450+  0753 D7          	push a
0451+  0754 D8          	push b
0452+  0755 DD          	push bl
0453+  0756 30          	mov bl, bh
0454+  0757 07 84 05    	call itoa				; convert bh to char in A
0455+  075A 2F          	mov bl, al				; save al
0456+  075B 19 00       	mov al, 0
0457+  075D 05 03       	syscall sys_io				; display AH
0458+  075F 24          	mov ah, bl				; retrieve al
0459+  0760 19 00       	mov al, 0
0460+  0762 05 03       	syscall sys_io				; display AL
0461+  0764             
0462+  0764 EA          	pop bl
0463+  0765 07 84 05    	call itoa				; convert bh to char in A
0464+  0768 2F          	mov bl, al				; save al
0465+  0769 19 00       	mov al, 0
0466+  076B 05 03       	syscall sys_io				; display AH
0467+  076D 24          	mov ah, bl				; retrieve al
0468+  076E 19 00       	mov al, 0
0469+  0770 05 03       	syscall sys_io				; display AL
0470+  0772             
0471+  0772 E5          	pop b
0472+  0773 E4          	pop a
0473+  0774 09          	ret
0474+  0775             
0475+  0775             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  0775             ; INPUT 16BIT HEX INTEGER
0477+  0775             ; read 16bit integer into A
0478+  0775             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  0775             scan_u16x:
0480+  0775 F8 10 00    	enter 16
0481+  0778 D8          	push b
0482+  0779 DA          	push d
0483+  077A             
0484+  077A FA F1 FF    	lea d, [bp + -15]
0485+  077D 07 C4 05    	call gets				; get number
0486+  0780             
0487+  0780 32          	mov bl, [d]
0488+  0781 37          	mov bh, bl
0489+  0782 33 01 00    	mov bl, [d + 1]
0490+  0785 07 72 05    	call atoi				; convert to int in AL
0491+  0788 23          	mov ah, al				; move to AH
0492+  0789             
0493+  0789 33 02 00    	mov bl, [d + 2]
0494+  078C 37          	mov bh, bl
0495+  078D 33 03 00    	mov bl, [d + 3]
0496+  0790 07 72 05    	call atoi				; convert to int in AL
0497+  0793             
0498+  0793 E7          	pop d
0499+  0794 E5          	pop b
0500+  0795 F9          	leave
0501+  0796 09          	ret
0502+  0797             
0503+  0797             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0504+  0797             ; PRINT 8bit HEX INTEGER
0505+  0797             ; integer value in reg bl
0506+  0797             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  0797             print_u8x:
0508+  0797 D7          	push a
0509+  0798 DD          	push bl
0510+  0799             
0511+  0799 07 84 05    	call itoa				; convert bl to char in A
0512+  079C 2F          	mov bl, al				; save al
0513+  079D 19 00       	mov al, 0
0514+  079F 05 03       	syscall sys_io				; display AH
0515+  07A1 24          	mov ah, bl				; retrieve al
0516+  07A2 19 00       	mov al, 0
0517+  07A4 05 03       	syscall sys_io				; display AL
0518+  07A6             
0519+  07A6 EA          	pop bl
0520+  07A7 E4          	pop a
0521+  07A8 09          	ret
0522+  07A9             
0523+  07A9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0524+  07A9             ; print 8bit decimal unsigned number
0525+  07A9             ; input number in AL
0526+  07A9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  07A9             print_u8d:
0528+  07A9 D7          	push a
0529+  07AA D8          	push b
0530+  07AB             
0531+  07AB 22 00       	mov ah, 0
0532+  07AD 26 64 00    	mov b, 100
0533+  07B0 AE          	div a, b
0534+  07B1 D8          	push b			; save remainder
0535+  07B2 B9 00       	cmp al, 0
0536+  07B4 C6 BE 07    	je skip100
0537+  07B7 6A 30       	add al, $30
0538+  07B9 23          	mov ah, al
0539+  07BA 19 00       	mov al, 0
0540+  07BC 05 03       	syscall sys_io	; print coeff
0541+  07BE             skip100:
0542+  07BE E4          	pop a
0543+  07BF 22 00       	mov ah, 0
0544+  07C1 26 0A 00    	mov b, 10
0545+  07C4 AE          	div a, b
0546+  07C5 D8          	push b			; save remainder
0547+  07C6 B9 00       	cmp al, 0
0548+  07C8 C6 D2 07    	je skip10
0549+  07CB 6A 30       	add al, $30
0550+  07CD 23          	mov ah, al
0551+  07CE 19 00       	mov al, 0
0552+  07D0 05 03       	syscall sys_io	; print coeff
0553+  07D2             skip10:
0554+  07D2 E4          	pop a
0555+  07D3 1B          	mov al, bl
0556+  07D4 6A 30       	add al, $30
0557+  07D6 23          	mov ah, al
0558+  07D7 19 00       	mov al, 0
0559+  07D9 05 03       	syscall sys_io	; print coeff
0560+  07DB E5          	pop b
0561+  07DC E4          	pop a
0562+  07DD 09          	ret
0563+  07DE             
0564+  07DE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0565+  07DE             ; INPUT 8BIT HEX INTEGER
0566+  07DE             ; read 8bit integer into AL
0567+  07DE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  07DE             scan_u8x:
0569+  07DE F8 04 00    	enter 4
0570+  07E1 D8          	push b
0571+  07E2 DA          	push d
0572+  07E3             
0573+  07E3 FA FD FF    	lea d, [bp + -3]
0574+  07E6 07 C4 05    	call gets				; get number
0575+  07E9             
0576+  07E9 32          	mov bl, [d]
0577+  07EA 37          	mov bh, bl
0578+  07EB 33 01 00    	mov bl, [d + 1]
0579+  07EE 07 72 05    	call atoi				; convert to int in AL
0580+  07F1             
0581+  07F1 E7          	pop d
0582+  07F2 E5          	pop b
0583+  07F3 F9          	leave
0584+  07F4 09          	ret
0585+  07F5             
0586+  07F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  07F5             ; input decimal number
0588+  07F5             ; result in A
0589+  07F5             ; 655'\0'
0590+  07F5             ; low--------high
0591+  07F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0592+  07F5             scan_u16d:
0593+  07F5 F8 08 00    	enter 8
0594+  07F8 E2          	push si
0595+  07F9 D8          	push b
0596+  07FA D9          	push c
0597+  07FB DA          	push d
0598+  07FC FA F9 FF    	lea d, [bp +- 7]
0599+  07FF 07 C4 05    	call gets
0600+  0802 07 F2 04    	call strlen			; get string length in C
0601+  0805 7E          	dec c
0602+  0806 FD 4E       	mov si, d
0603+  0808 12          	mov a, c
0604+  0809 FD 99       	shl a
0605+  080B 3B 5A 05    	mov d, table_power
0606+  080E 59          	add d, a
0607+  080F 38 00 00    	mov c, 0
0608+  0812             mul_loop:
0609+  0812 F6          	lodsb			; load ASCII to al
0610+  0813 B9 00       	cmp al, 0
0611+  0815 C6 28 08    	je mul_exit
0612+  0818 6F 30       	sub al, $30		; make into integer
0613+  081A 22 00       	mov ah, 0
0614+  081C 2A          	mov b, [d]
0615+  081D AC          	mul a, b			; result in B since it fits in 16bits
0616+  081E 11          	mov a, b
0617+  081F 28          	mov b, c
0618+  0820 54          	add a, b
0619+  0821 39          	mov c, a
0620+  0822 63 02 00    	sub d, 2
0621+  0825 0A 12 08    	jmp mul_loop
0622+  0828             mul_exit:
0623+  0828 12          	mov a, c
0624+  0829 E7          	pop d
0625+  082A E6          	pop c
0626+  082B E5          	pop b
0627+  082C EF          	pop si
0628+  082D F9          	leave
0629+  082E 09          	ret
0105   082F             ; --- END INCLUDE BLOCK
0106   082F             
0107   082F             
0108   082F             .end
tasm: Number of errors = 0
