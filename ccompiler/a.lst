0001   0000             ; --- Filename: test.c
0002   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0400             .org PROC_TEXT_ORG
0004   0400             
0005   0400             ; --- begin text block
0006   0400             main:
0007   0400 D2            push bp
0008   0401 9B            mov bp, sp
0009   0402 FD DB 41      push byte 'A'
0010   0405 FD DB 41      push byte 'A'
0011   0408 FD DB 41      push byte 'A'
0012   040B 34 FE FF      mov bl, [bp + -2] ; c1
0013   040E DD            push bl
0014   040F 07 18 04      call f1
0015   0412 51 03 00      add sp, 3
0016   0415 F9            leave
0017   0416 05 0B         syscall sys_terminate_proc
0018   0418             f1:
0019   0418 D2            push bp
0020   0419 9B            mov bp, sp
0021   041A 3B 00 00      mov d, 0
0022   041D 26 02 00      mov b, 2
0023   0420 5A            add d, b
0024   0421 2D            mov b, d
0025   0422 FA 05 00      lea d, [bp + 5]
0026   0425 5A            add d, b
0027   0426 32            mov bl, [d]
0028   0427 FD 3D 33 04   mov [cc], bl
0029   042B             ; --- begin inline asm block
0030   042B 14 33 04        mov a, [cc];
0031   042E FD AA           swp a
0032   0430 07 3E 05        call putchar
0033   0433               ; --- end inline asm block
0034   0433             ; --- end text block
0035   0433             
0036   0433             ; --- begin data block
0037   0433 00          cc: .fill 1, 0
0038   0434             ; --- end data block
0039   0434             ; --- begin include block
0040   0434             .include "lib/stdio.asm"
0001+  0434             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0434             ; stdio.s
0003+  0434             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0434             .include "lib/string.asm"
0001++ 0434             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0434             ; string.s
0003++ 0434             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0434             
0005++ 0434             
0006++ 0434             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0434             ; strrev
0008++ 0434             ; reverse a string
0009++ 0434             ; D = string address
0010++ 0434             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0434             ; 01234
0012++ 0434             strrev:
0013++ 0434 4B          	pusha
0014++ 0435 07 7B 04    	call strlen	; length in C
0015++ 0438 12          	mov a, c
0016++ 0439 AF 01 00    	cmp a, 1
0017++ 043C D0 56 04    	jleu strrev_end	; check string length. string len must be > 1
0018++ 043F 7D          	dec a
0019++ 0440 FD 4E       	mov si, d	; beginning of string
0020++ 0442 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0444 59          	add d, a	; end of string
0022++ 0445 12          	mov a, c
0023++ 0446 FD 9B       	shr a		; divide by 2
0024++ 0448 39          	mov c, a	; C now counts the steps
0025++ 0449             strrev_L0:
0026++ 0449 32          	mov bl, [d]	; save load right-side char into BL
0027++ 044A F6          	lodsb		; load left-side char into AL; increase SI
0028++ 044B 3E          	mov [d], al	; store left char into right side
0029++ 044C 1B          	mov al, bl
0030++ 044D F7          	stosb		; store right-side char into left-side; increase DI
0031++ 044E 7E          	dec c
0032++ 044F 7F          	dec d
0033++ 0450 C2 00 00    	cmp c, 0
0034++ 0453 C7 49 04    	jne strrev_L0
0035++ 0456             strrev_end:
0036++ 0456 4C          	popa
0037++ 0457 09          	ret
0038++ 0458             	
0039++ 0458             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0458             ; strchr
0041++ 0458             ; search string in D for char in AL
0042++ 0458             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0458             strchr:
0044++ 0458             strchr_L0:
0045++ 0458 32          	mov bl, [d]
0046++ 0459 C1 00       	cmp bl, 0
0047++ 045B C6 66 04    	je strchr_end
0048++ 045E BA          	cmp al, bl
0049++ 045F C6 66 04    	je strchr_end
0050++ 0462 79          	inc d
0051++ 0463 0A 58 04    	jmp strchr_L0
0052++ 0466             strchr_end:
0053++ 0466 1B          	mov al, bl
0054++ 0467 09          	ret
0055++ 0468             
0056++ 0468             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0468             ; strstr
0058++ 0468             ; find sub-string
0059++ 0468             ; str1 in SI
0060++ 0468             ; str2 in DI
0061++ 0468             ; SI points to end of source string
0062++ 0468             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0468             strstr:
0064++ 0468 DB          	push al
0065++ 0469 DA          	push d
0066++ 046A E3          	push di
0067++ 046B             strstr_loop:
0068++ 046B F3          	cmpsb					; compare a byte of the strings
0069++ 046C C7 77 04    	jne strstr_ret
0070++ 046F FC 00 00    	lea d, [di + 0]
0071++ 0472 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0474 C7 6B 04    	jne strstr_loop				; equal chars but not at end
0073++ 0477             strstr_ret:
0074++ 0477 F0          	pop di
0075++ 0478 E7          	pop d
0076++ 0479 E8          	pop al
0077++ 047A 09          	ret
0078++ 047B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 047B             ; length of null terminated string
0080++ 047B             ; result in C
0081++ 047B             ; pointer in D
0082++ 047B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 047B             strlen:
0084++ 047B DA          	push d
0085++ 047C 38 00 00    	mov c, 0
0086++ 047F             strlen_L1:
0087++ 047F BD 00       	cmp byte [d], 0
0088++ 0481 C6 89 04    	je strlen_ret
0089++ 0484 79          	inc d
0090++ 0485 78          	inc c
0091++ 0486 0A 7F 04    	jmp strlen_L1
0092++ 0489             strlen_ret:
0093++ 0489 E7          	pop d
0094++ 048A 09          	ret
0095++ 048B             
0096++ 048B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 048B             ; STRCMP
0098++ 048B             ; compare two strings
0099++ 048B             ; str1 in SI
0100++ 048B             ; str2 in DI
0101++ 048B             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 048B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 048B             strcmp:
0104++ 048B DB          	push al
0105++ 048C DA          	push d
0106++ 048D E3          	push di
0107++ 048E E2          	push si
0108++ 048F             strcmp_loop:
0109++ 048F F3          	cmpsb					; compare a byte of the strings
0110++ 0490 C7 9B 04    	jne strcmp_ret
0111++ 0493 FB FF FF    	lea d, [si +- 1]
0112++ 0496 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0498 C7 8F 04    	jne strcmp_loop				; equal chars but not at end
0114++ 049B             strcmp_ret:
0115++ 049B EF          	pop si
0116++ 049C F0          	pop di
0117++ 049D E7          	pop d
0118++ 049E E8          	pop al
0119++ 049F 09          	ret
0120++ 04A0             
0121++ 04A0             
0122++ 04A0             ; STRCPY
0123++ 04A0             ; copy null terminated string from SI to DI
0124++ 04A0             ; source in SI
0125++ 04A0             ; destination in DI
0126++ 04A0             strcpy:
0127++ 04A0 E2          	push si
0128++ 04A1 E3          	push di
0129++ 04A2 DB          	push al
0130++ 04A3             strcpy_L1:
0131++ 04A3 F6          	lodsb
0132++ 04A4 F7          	stosb
0133++ 04A5 B9 00       	cmp al, 0
0134++ 04A7 C7 A3 04    	jne strcpy_L1
0135++ 04AA             strcpy_end:
0136++ 04AA E8          	pop al
0137++ 04AB F0          	pop di
0138++ 04AC EF          	pop si
0139++ 04AD 09          	ret
0140++ 04AE             
0141++ 04AE             ; STRCAT
0142++ 04AE             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 04AE             ; source in SI
0144++ 04AE             ; destination in DI
0145++ 04AE             strcat:
0146++ 04AE E2          	push si
0147++ 04AF E3          	push di
0148++ 04B0 D7          	push a
0149++ 04B1 DA          	push d
0150++ 04B2 50          	mov a, di
0151++ 04B3 3C          	mov d, a
0152++ 04B4             strcat_goto_end_L1:
0153++ 04B4 BD 00       	cmp byte[d], 0
0154++ 04B6 C6 BD 04    	je strcat_start
0155++ 04B9 79          	inc d
0156++ 04BA 0A B4 04    	jmp strcat_goto_end_L1
0157++ 04BD             strcat_start:
0158++ 04BD FD 50       	mov di, d
0159++ 04BF             strcat_L1:
0160++ 04BF F6          	lodsb
0161++ 04C0 F7          	stosb
0162++ 04C1 B9 00       	cmp al, 0
0163++ 04C3 C7 BF 04    	jne strcat_L1
0164++ 04C6             strcat_end:
0165++ 04C6 E7          	pop d
0166++ 04C7 E4          	pop a
0167++ 04C8 F0          	pop di
0168++ 04C9 EF          	pop si
0169++ 04CA 09          	ret
0005+  04CB             
0006+  04CB 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  04CF 34 35 36 37 
0006+  04D3 38 39 41 42 
0006+  04D7 43 44 45 46 
0007+  04DB             
0008+  04DB 01 00       table_power:.dw 1
0009+  04DD 0A 00       			.dw 10
0010+  04DF 64 00       			.dw 100
0011+  04E1 E8 03       			.dw 1000
0012+  04E3 10 27       			.dw 10000
0013+  04E5             
0014+  04E5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0015+  04E5             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0016+  04E5             ; ASCII in BL
0017+  04E5             ; result in AL
0018+  04E5             ; ascii for F = 0100 0110
0019+  04E5             ; ascii for 9 = 0011 1001
0020+  04E5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0021+  04E5             hex_ascii_encode:
0022+  04E5 1B          	mov al, bl
0023+  04E6 93 40       	test al, $40				; test if letter or number
0024+  04E8 C7 EE 04    	jnz hex_letter
0025+  04EB 87 0F       	and al, $0F				; get number
0026+  04ED 09          	ret
0027+  04EE             hex_letter:
0028+  04EE 87 0F       	and al, $0F				; get letter
0029+  04F0 6A 09       	add al, 9
0030+  04F2 09          	ret
0031+  04F3             
0032+  04F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0033+  04F3             ; ATOI
0034+  04F3             ; 2 letter hex string in B
0035+  04F3             ; 8bit integer returned in AL
0036+  04F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0037+  04F3             atoi:
0038+  04F3 D8          	push b
0039+  04F4 07 E5 04    	call hex_ascii_encode			; convert BL to 4bit code in AL
0040+  04F7 30          	mov bl, bh
0041+  04F8 DB          	push al					; save a
0042+  04F9 07 E5 04    	call hex_ascii_encode
0043+  04FC EA          	pop bl	
0044+  04FD FD 9E 04    	shl al, 4
0045+  0500 8C          	or al, bl
0046+  0501 E5          	pop b
0047+  0502 09          	ret	
0048+  0503             
0049+  0503             
0050+  0503             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  0503             ; printf
0052+  0503             ; no need for explanations!
0053+  0503             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0054+  0503             printf:
0055+  0503 09          	ret
0056+  0504             
0057+  0504             
0058+  0504             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  0504             ; scanf
0060+  0504             ; no need for explanations!
0061+  0504             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  0504             scanf:
0063+  0504 09          	ret
0064+  0505             
0065+  0505             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  0505             ; ITOA
0067+  0505             ; 8bit value in BL
0068+  0505             ; 2 byte ASCII result in A
0069+  0505             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0070+  0505             itoa:
0071+  0505 DA          	push d
0072+  0506 D8          	push b
0073+  0507 A7 00       	mov bh, 0
0074+  0509 FD A4 04    	shr bl, 4	
0075+  050C 74          	mov d, b
0076+  050D 1F CB 04    	mov al, [d + s_hex_digits]
0077+  0510 23          	mov ah, al
0078+  0511             	
0079+  0511 E5          	pop b
0080+  0512 D8          	push b
0081+  0513 A7 00       	mov bh, 0
0082+  0515 FD 87 0F    	and bl, $0F
0083+  0518 74          	mov d, b
0084+  0519 1F CB 04    	mov al, [d + s_hex_digits]
0085+  051C E5          	pop b
0086+  051D E7          	pop d
0087+  051E 09          	ret
0088+  051F             
0089+  051F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0090+  051F             ; HEX STRING TO BINARY
0091+  051F             ; di = destination address
0092+  051F             ; si = source
0093+  051F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0094+  051F             hex_to_int:
0095+  051F             hex_to_int_L1:
0096+  051F F6          	lodsb					; load from [SI] to AL
0097+  0520 B9 00       	cmp al, 0				; check if ASCII 0
0098+  0522 C6 2F 05    	jz hex_to_int_ret
0099+  0525 36          	mov bh, al
0100+  0526 F6          	lodsb
0101+  0527 2F          	mov bl, al
0102+  0528 07 F3 04    	call atoi				; convert ASCII byte in B to int (to AL)
0103+  052B F7          	stosb					; store AL to [DI]
0104+  052C 0A 1F 05    	jmp hex_to_int_L1
0105+  052F             hex_to_int_ret:
0106+  052F 09          	ret		
0107+  0530             
0108+  0530             
0109+  0530             
0110+  0530             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  0530             ; GETCHAR
0112+  0530             ; char in ah
0113+  0530             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0114+  0530             getchar:
0115+  0530 DB          	push al
0116+  0531             getchar_retry:
0117+  0531 FD 0C       	sti
0118+  0533 19 01       	mov al, 1
0119+  0535 05 03       	syscall sys_io			; receive in AH
0120+  0537 B9 00       	cmp al, 0			; check if any char was receive
0121+  0539 C6 31 05    	je getchar_retry
0122+  053C E8          	pop al
0123+  053D 09          	ret
0124+  053E             
0125+  053E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0126+  053E             ; PUTCHAR
0127+  053E             ; char in ah
0128+  053E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  053E             putchar:
0130+  053E D7          	push a
0131+  053F 19 00       	mov al, 0
0132+  0541 05 03       	syscall sys_io			; char in AH
0133+  0543 E4          	pop a
0134+  0544 09          	ret
0135+  0545             
0136+  0545             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0137+  0545             ;; INPUT A STRING
0138+  0545             ;; terminates with null
0139+  0545             ;; pointer in D
0140+  0545             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  0545             gets:
0142+  0545 D7          	push a
0143+  0546 DA          	push d
0144+  0547             gets_loop:
0145+  0547 FD 0C       	sti
0146+  0549 19 01       	mov al, 1
0147+  054B 05 03       	syscall sys_io			; receive in AH
0148+  054D B9 00       	cmp al, 0				; check error code (AL)
0149+  054F C6 47 05    	je gets_loop			; if no char received, retry
0150+  0552             
0151+  0552 76 1B       	cmp ah, 27
0152+  0554 C6 75 05    	je gets_telnet_escape
0153+  0557 76 0A       	cmp ah, $0A				; LF
0154+  0559 C6 CE 05    	je gets_end
0155+  055C 76 0D       	cmp ah, $0D				; CR
0156+  055E C6 CE 05    	je gets_end
0157+  0561 76 5C       	cmp ah, $5C				; '\\'
0158+  0563 C6 A5 05    	je gets_escape
0159+  0566             	
0160+  0566 76 08       	cmp ah, $08			; check for backspace
0161+  0568 C6 71 05    	je gets_backspace
0162+  056B             
0163+  056B 1A          	mov al, ah
0164+  056C 3E          	mov [d], al
0165+  056D 79          	inc d
0166+  056E 0A 47 05    	jmp gets_loop
0167+  0571             gets_backspace:
0168+  0571 7F          	dec d
0169+  0572 0A 47 05    	jmp gets_loop
0170+  0575             gets_telnet_escape:
0171+  0575 FD 0C       	sti
0172+  0577 19 01       	mov al, 1
0173+  0579 05 03       	syscall sys_io				; receive in AH without echo
0174+  057B B9 00       	cmp al, 0					; check error code (AL)
0175+  057D C6 75 05    	je gets_telnet_escape		; if no char received, retry
0176+  0580 76 5B       	cmp ah, '['
0177+  0582 C7 47 05    	jne gets_loop
0178+  0585             gets_telnet_escape_phase2:
0179+  0585 FD 0C       	sti
0180+  0587 19 01       	mov al, 1
0181+  0589 05 03       	syscall sys_io					; receive in AH without echo
0182+  058B B9 00       	cmp al, 0						; check error code (AL)
0183+  058D C6 85 05    	je gets_telnet_escape_phase2	; if no char received, retry
0184+  0590 76 44       	cmp ah, 'D'
0185+  0592 C6 9D 05    	je gets_left_arrow
0186+  0595 76 43       	cmp ah, 'C'
0187+  0597 C6 A1 05    	je gets_right_arrow
0188+  059A 0A 47 05    	jmp gets_loop
0189+  059D             gets_left_arrow:
0190+  059D 7F          	dec d
0191+  059E 0A 47 05    	jmp gets_loop
0192+  05A1             gets_right_arrow:
0193+  05A1 79          	inc d
0194+  05A2 0A 47 05    	jmp gets_loop
0195+  05A5             gets_escape:
0196+  05A5 FD 0C       	sti
0197+  05A7 19 01       	mov al, 1
0198+  05A9 05 03       	syscall sys_io			; receive in AH
0199+  05AB B9 00       	cmp al, 0				; check error code (AL)
0200+  05AD C6 A5 05    	je gets_escape			; if no char received, retry
0201+  05B0 76 6E       	cmp ah, 'n'
0202+  05B2 C6 C0 05    	je gets_LF
0203+  05B5 76 72       	cmp ah, 'r'
0204+  05B7 C6 C7 05    	je gets_CR
0205+  05BA 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0206+  05BB 3E          	mov [d], al
0207+  05BC 79          	inc d
0208+  05BD 0A 47 05    	jmp gets_loop
0209+  05C0             gets_LF:
0210+  05C0 19 0A       	mov al, $0A
0211+  05C2 3E          	mov [d], al
0212+  05C3 79          	inc d
0213+  05C4 0A 47 05    	jmp gets_loop
0214+  05C7             gets_CR:
0215+  05C7 19 0D       	mov al, $0D
0216+  05C9 3E          	mov [d], al
0217+  05CA 79          	inc d
0218+  05CB 0A 47 05    	jmp gets_loop
0219+  05CE             gets_end:
0220+  05CE 19 00       	mov al, 0
0221+  05D0 3E          	mov [d], al				; terminate string
0222+  05D1 E7          	pop d
0223+  05D2 E4          	pop a
0224+  05D3 09          	ret
0225+  05D4             
0226+  05D4             
0227+  05D4             
0228+  05D4             
0229+  05D4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0230+  05D4             ;; INPUT TEXT
0231+  05D4             ;; terminated with CTRL+D
0232+  05D4             ;; pointer in D
0233+  05D4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0234+  05D4             gettxt:
0235+  05D4 D7          	push a
0236+  05D5 DA          	push d
0237+  05D6             gettxt_loop:
0238+  05D6 19 01       	mov al, 1
0239+  05D8 05 03       	syscall sys_io			; receive in AH
0240+  05DA B9 00       	cmp al, 0				; check error code (AL)
0241+  05DC C6 D6 05    	je gettxt_loop		; if no char received, retry
0242+  05DF 76 04       	cmp ah, 4			; EOT
0243+  05E1 C6 1F 06    	je gettxt_end
0244+  05E4 76 08       	cmp ah, $08			; check for backspace
0245+  05E6 C6 1B 06    	je gettxt_backspace
0246+  05E9 76 5C       	cmp ah, $5C				; '\\'
0247+  05EB C6 F4 05    	je gettxt_escape
0248+  05EE 1A          	mov al, ah
0249+  05EF 3E          	mov [d], al
0250+  05F0 79          	inc d
0251+  05F1 0A D6 05    	jmp gettxt_loop
0252+  05F4             gettxt_escape:
0253+  05F4 19 01       	mov al, 1
0254+  05F6 05 03       	syscall sys_io			; receive in AH
0255+  05F8 B9 00       	cmp al, 0				; check error code (AL)
0256+  05FA C6 F4 05    	je gettxt_escape		; if no char received, retry
0257+  05FD 76 6E       	cmp ah, 'n'
0258+  05FF C6 0D 06    	je gettxt_LF
0259+  0602 76 72       	cmp ah, 'r'
0260+  0604 C6 14 06    	je gettxt_CR
0261+  0607 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0262+  0608 3E          	mov [d], al
0263+  0609 79          	inc d
0264+  060A 0A D6 05    	jmp gettxt_loop
0265+  060D             gettxt_LF:
0266+  060D 19 0A       	mov al, $0A
0267+  060F 3E          	mov [d], al
0268+  0610 79          	inc d
0269+  0611 0A D6 05    	jmp gettxt_loop
0270+  0614             gettxt_CR:
0271+  0614 19 0D       	mov al, $0D
0272+  0616 3E          	mov [d], al
0273+  0617 79          	inc d
0274+  0618 0A D6 05    	jmp gettxt_loop
0275+  061B             gettxt_backspace:
0276+  061B 7F          	dec d
0277+  061C 0A D6 05    	jmp gettxt_loop
0278+  061F             gettxt_end:
0279+  061F 19 00       	mov al, 0
0280+  0621 3E          	mov [d], al				; terminate string
0281+  0622 E7          	pop d
0282+  0623 E4          	pop a
0283+  0624 09          	ret
0284+  0625             
0285+  0625             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0286+  0625             ; PRINT NEW LINE
0287+  0625             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  0625             printnl:
0289+  0625 D7          	push a
0290+  0626 10 00 0A    	mov a, $0A00
0291+  0629 05 03       	syscall sys_io
0292+  062B 10 00 0D    	mov a, $0D00
0293+  062E 05 03       	syscall sys_io
0294+  0630 E4          	pop a
0295+  0631 09          	ret
0296+  0632             
0297+  0632             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0298+  0632             ; strtoint
0299+  0632             ; 4 digit hex string number in d
0300+  0632             ; integer returned in A
0301+  0632             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0302+  0632             strtointx:
0303+  0632 D8          	push b
0304+  0633 32          	mov bl, [d]
0305+  0634 37          	mov bh, bl
0306+  0635 33 01 00    	mov bl, [d + 1]
0307+  0638 07 F3 04    	call atoi				; convert to int in AL
0308+  063B 23          	mov ah, al				; move to AH
0309+  063C 33 02 00    	mov bl, [d + 2]
0310+  063F 37          	mov bh, bl
0311+  0640 33 03 00    	mov bl, [d + 3]
0312+  0643 07 F3 04    	call atoi				; convert to int in AL
0313+  0646 E5          	pop b
0314+  0647 09          	ret
0315+  0648             
0316+  0648             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0317+  0648             ; strtoint
0318+  0648             ; 5 digit base10 string number in d
0319+  0648             ; integer returned in A
0320+  0648             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0321+  0648             strtoint:
0322+  0648 E2          	push si
0323+  0649 D8          	push b
0324+  064A D9          	push c
0325+  064B DA          	push d
0326+  064C 07 7B 04    	call strlen			; get string length in C
0327+  064F 7E          	dec c
0328+  0650 FD 4E       	mov si, d
0329+  0652 12          	mov a, c
0330+  0653 FD 99       	shl a
0331+  0655 3B DB 04    	mov d, table_power
0332+  0658 59          	add d, a
0333+  0659 38 00 00    	mov c, 0
0334+  065C             strtoint_L0:
0335+  065C F6          	lodsb			; load ASCII to al
0336+  065D B9 00       	cmp al, 0
0337+  065F C6 72 06    	je strtoint_end
0338+  0662 6F 30       	sub al, $30		; make into integer
0339+  0664 22 00       	mov ah, 0
0340+  0666 2A          	mov b, [d]
0341+  0667 AC          	mul a, b			; result in B since it fits in 16bits
0342+  0668 11          	mov a, b
0343+  0669 28          	mov b, c
0344+  066A 54          	add a, b
0345+  066B 39          	mov c, a
0346+  066C 63 02 00    	sub d, 2
0347+  066F 0A 5C 06    	jmp strtoint_L0
0348+  0672             strtoint_end:
0349+  0672 12          	mov a, c
0350+  0673 E7          	pop d
0351+  0674 E6          	pop c
0352+  0675 E5          	pop b
0353+  0676 EF          	pop si
0354+  0677 09          	ret
0355+  0678             
0356+  0678             
0357+  0678             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0358+  0678             ; PRINT NULL TERMINATED STRING
0359+  0678             ; pointer in D
0360+  0678             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0361+  0678             puts:
0362+  0678 D7          	push a
0363+  0679 DA          	push d
0364+  067A             puts_L1:
0365+  067A 1E          	mov al, [d]
0366+  067B B9 00       	cmp al, 0
0367+  067D C6 89 06    	jz puts_END
0368+  0680 23          	mov ah, al
0369+  0681 19 00       	mov al, 0
0370+  0683 05 03       	syscall sys_io
0371+  0685 79          	inc d
0372+  0686 0A 7A 06    	jmp puts_L1
0373+  0689             puts_END:
0374+  0689 E7          	pop d
0375+  068A E4          	pop a
0376+  068B 09          	ret
0377+  068C             
0378+  068C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  068C             ; PRINT N SIZE STRING
0380+  068C             ; pointer in D
0381+  068C             ; size in C
0382+  068C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0383+  068C             putsn:
0384+  068C DB          	push al
0385+  068D DA          	push d
0386+  068E D9          	push c
0387+  068F             putsn_L0:
0388+  068F 1E          	mov al, [d]
0389+  0690 23          	mov ah, al
0390+  0691 19 00       	mov al, 0
0391+  0693 05 03       	syscall sys_io
0392+  0695 79          	inc d
0393+  0696 7E          	dec c	
0394+  0697 C2 00 00    	cmp c, 0
0395+  069A C7 8F 06    	jne putsn_L0
0396+  069D             putsn_end:
0397+  069D E6          	pop c
0398+  069E E7          	pop d
0399+  069F E8          	pop al
0400+  06A0 09          	ret
0401+  06A1             
0402+  06A1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0403+  06A1             ; print 16bit decimal number
0404+  06A1             ; input number in A
0405+  06A1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  06A1             print_u16d:
0407+  06A1 D7          	push a
0408+  06A2 D8          	push b
0409+  06A3 26 10 27    	mov b, 10000
0410+  06A6 AE          	div a, b			; get 10000 coeff.
0411+  06A7 07 CD 06    	call print_number
0412+  06AA 11          	mov a, b
0413+  06AB 26 E8 03    	mov b, 1000
0414+  06AE AE          	div a, b			; get 10000 coeff.
0415+  06AF 07 CD 06    	call print_number
0416+  06B2 11          	mov a, b
0417+  06B3 26 64 00    	mov b, 100
0418+  06B6 AE          	div a, b
0419+  06B7 07 CD 06    	call print_number
0420+  06BA 11          	mov a, b
0421+  06BB 26 0A 00    	mov b, 10
0422+  06BE AE          	div a, b
0423+  06BF 07 CD 06    	call print_number
0424+  06C2 11          	mov a, b
0425+  06C3 6A 30       	add al, $30
0426+  06C5 23          	mov ah, al
0427+  06C6 19 00       	mov al, 0
0428+  06C8 05 03       	syscall sys_io	; print coeff
0429+  06CA E5          	pop b
0430+  06CB E4          	pop a
0431+  06CC 09          	ret
0432+  06CD             
0433+  06CD             
0434+  06CD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0435+  06CD             ; if A == 0, print space
0436+  06CD             ; else print A
0437+  06CD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0438+  06CD             print_number:
0439+  06CD 6A 30       	add al, $30
0440+  06CF 23          	mov ah, al
0441+  06D0 07 3E 05    	call putchar
0442+  06D3 09          	ret
0443+  06D4             
0444+  06D4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  06D4             ; PRINT 16BIT HEX INTEGER
0446+  06D4             ; integer value in reg B
0447+  06D4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  06D4             print_u16x:
0449+  06D4 D7          	push a
0450+  06D5 D8          	push b
0451+  06D6 DD          	push bl
0452+  06D7 30          	mov bl, bh
0453+  06D8 07 05 05    	call itoa				; convert bh to char in A
0454+  06DB 2F          	mov bl, al				; save al
0455+  06DC 19 00       	mov al, 0
0456+  06DE 05 03       	syscall sys_io				; display AH
0457+  06E0 24          	mov ah, bl				; retrieve al
0458+  06E1 19 00       	mov al, 0
0459+  06E3 05 03       	syscall sys_io				; display AL
0460+  06E5             
0461+  06E5 EA          	pop bl
0462+  06E6 07 05 05    	call itoa				; convert bh to char in A
0463+  06E9 2F          	mov bl, al				; save al
0464+  06EA 19 00       	mov al, 0
0465+  06EC 05 03       	syscall sys_io				; display AH
0466+  06EE 24          	mov ah, bl				; retrieve al
0467+  06EF 19 00       	mov al, 0
0468+  06F1 05 03       	syscall sys_io				; display AL
0469+  06F3             
0470+  06F3 E5          	pop b
0471+  06F4 E4          	pop a
0472+  06F5 09          	ret
0473+  06F6             
0474+  06F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0475+  06F6             ; INPUT 16BIT HEX INTEGER
0476+  06F6             ; read 16bit integer into A
0477+  06F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0478+  06F6             scan_u16x:
0479+  06F6 F8 10 00    	enter 16
0480+  06F9 D8          	push b
0481+  06FA DA          	push d
0482+  06FB             
0483+  06FB FA F1 FF    	lea d, [bp + -15]
0484+  06FE 07 45 05    	call gets				; get number
0485+  0701             
0486+  0701 32          	mov bl, [d]
0487+  0702 37          	mov bh, bl
0488+  0703 33 01 00    	mov bl, [d + 1]
0489+  0706 07 F3 04    	call atoi				; convert to int in AL
0490+  0709 23          	mov ah, al				; move to AH
0491+  070A             
0492+  070A 33 02 00    	mov bl, [d + 2]
0493+  070D 37          	mov bh, bl
0494+  070E 33 03 00    	mov bl, [d + 3]
0495+  0711 07 F3 04    	call atoi				; convert to int in AL
0496+  0714             
0497+  0714 E7          	pop d
0498+  0715 E5          	pop b
0499+  0716 F9          	leave
0500+  0717 09          	ret
0501+  0718             
0502+  0718             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0503+  0718             ; PRINT 8bit HEX INTEGER
0504+  0718             ; integer value in reg bl
0505+  0718             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0506+  0718             print_u8x:
0507+  0718 D7          	push a
0508+  0719 DD          	push bl
0509+  071A             
0510+  071A 07 05 05    	call itoa				; convert bl to char in A
0511+  071D 2F          	mov bl, al				; save al
0512+  071E 19 00       	mov al, 0
0513+  0720 05 03       	syscall sys_io				; display AH
0514+  0722 24          	mov ah, bl				; retrieve al
0515+  0723 19 00       	mov al, 0
0516+  0725 05 03       	syscall sys_io				; display AL
0517+  0727             
0518+  0727 EA          	pop bl
0519+  0728 E4          	pop a
0520+  0729 09          	ret
0521+  072A             
0522+  072A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0523+  072A             ; print 8bit decimal unsigned number
0524+  072A             ; input number in AL
0525+  072A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0526+  072A             print_u8d:
0527+  072A D7          	push a
0528+  072B D8          	push b
0529+  072C             
0530+  072C 22 00       	mov ah, 0
0531+  072E 26 64 00    	mov b, 100
0532+  0731 AE          	div a, b
0533+  0732 D8          	push b			; save remainder
0534+  0733 B9 00       	cmp al, 0
0535+  0735 C6 3F 07    	je skip100
0536+  0738 6A 30       	add al, $30
0537+  073A 23          	mov ah, al
0538+  073B 19 00       	mov al, 0
0539+  073D 05 03       	syscall sys_io	; print coeff
0540+  073F             skip100:
0541+  073F E4          	pop a
0542+  0740 22 00       	mov ah, 0
0543+  0742 26 0A 00    	mov b, 10
0544+  0745 AE          	div a, b
0545+  0746 D8          	push b			; save remainder
0546+  0747 B9 00       	cmp al, 0
0547+  0749 C6 53 07    	je skip10
0548+  074C 6A 30       	add al, $30
0549+  074E 23          	mov ah, al
0550+  074F 19 00       	mov al, 0
0551+  0751 05 03       	syscall sys_io	; print coeff
0552+  0753             skip10:
0553+  0753 E4          	pop a
0554+  0754 1B          	mov al, bl
0555+  0755 6A 30       	add al, $30
0556+  0757 23          	mov ah, al
0557+  0758 19 00       	mov al, 0
0558+  075A 05 03       	syscall sys_io	; print coeff
0559+  075C E5          	pop b
0560+  075D E4          	pop a
0561+  075E 09          	ret
0562+  075F             
0563+  075F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0564+  075F             ; INPUT 8BIT HEX INTEGER
0565+  075F             ; read 8bit integer into AL
0566+  075F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0567+  075F             scan_u8x:
0568+  075F F8 04 00    	enter 4
0569+  0762 D8          	push b
0570+  0763 DA          	push d
0571+  0764             
0572+  0764 FA FD FF    	lea d, [bp + -3]
0573+  0767 07 45 05    	call gets				; get number
0574+  076A             
0575+  076A 32          	mov bl, [d]
0576+  076B 37          	mov bh, bl
0577+  076C 33 01 00    	mov bl, [d + 1]
0578+  076F 07 F3 04    	call atoi				; convert to int in AL
0579+  0772             
0580+  0772 E7          	pop d
0581+  0773 E5          	pop b
0582+  0774 F9          	leave
0583+  0775 09          	ret
0584+  0776             
0585+  0776             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0586+  0776             ; input decimal number
0587+  0776             ; result in A
0588+  0776             ; 655'\0'
0589+  0776             ; low--------high
0590+  0776             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0591+  0776             scan_u16d:
0592+  0776 F8 08 00    	enter 8
0593+  0779 E2          	push si
0594+  077A D8          	push b
0595+  077B D9          	push c
0596+  077C DA          	push d
0597+  077D FA F9 FF    	lea d, [bp +- 7]
0598+  0780 07 45 05    	call gets
0599+  0783 07 7B 04    	call strlen			; get string length in C
0600+  0786 7E          	dec c
0601+  0787 FD 4E       	mov si, d
0602+  0789 12          	mov a, c
0603+  078A FD 99       	shl a
0604+  078C 3B DB 04    	mov d, table_power
0605+  078F 59          	add d, a
0606+  0790 38 00 00    	mov c, 0
0607+  0793             mul_loop:
0608+  0793 F6          	lodsb			; load ASCII to al
0609+  0794 B9 00       	cmp al, 0
0610+  0796 C6 A9 07    	je mul_exit
0611+  0799 6F 30       	sub al, $30		; make into integer
0612+  079B 22 00       	mov ah, 0
0613+  079D 2A          	mov b, [d]
0614+  079E AC          	mul a, b			; result in B since it fits in 16bits
0615+  079F 11          	mov a, b
0616+  07A0 28          	mov b, c
0617+  07A1 54          	add a, b
0618+  07A2 39          	mov c, a
0619+  07A3 63 02 00    	sub d, 2
0620+  07A6 0A 93 07    	jmp mul_loop
0621+  07A9             mul_exit:
0622+  07A9 12          	mov a, c
0623+  07AA E7          	pop d
0624+  07AB E6          	pop c
0625+  07AC E5          	pop b
0626+  07AD EF          	pop si
0627+  07AE F9          	leave
0628+  07AF 09          	ret
0041   07B0             ; --- end include block
0042   07B0             
0043   07B0             .end
tasm: Number of errors = 0
