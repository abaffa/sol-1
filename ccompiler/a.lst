0001   0000             ; --- FILENAME: snake.c
0002   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0400             .org PROC_TEXT_ORG
0004   0400             
0005   0400             ; --- BEGIN TEXT BLOCK
0006   0400             
0007   0400             main:
0008   0400 D2            push bp
0009   0401 9B            mov bp, sp
0010   0402 29 98 09      mov b, [__snake_x] ; snake_x
0011   0405 D7            push a
0012   0406 74            mov d, b
0013   0407 DA            push d
0014   0408 26 00 00      mov b, 0
0015   040B E7            pop d
0016   040C 10 02 00      mov a, 2
0017   040F AC            mul a, b
0018   0410 5A            add d, b
0019   0411 E4            pop a
0020   0412 DA            push d
0021   0413 26 28 00      mov b, 40
0022   0416 D7            push a
0023   0417 11            mov a, b
0024   0418 26 02 00      mov b, 2
0025   041B AE            div a, b
0026   041C FD 78         mov g, a
0027   041E 11            mov a, b
0028   041F FD 27         mov b, g
0029   0421 E4            pop a
0030   0422 E7            pop d
0031   0423 FD 43         mov [d], b
0032   0425 29 62 0A      mov b, [__snake_y] ; snake_y
0033   0428 D7            push a
0034   0429 74            mov d, b
0035   042A DA            push d
0036   042B 26 00 00      mov b, 0
0037   042E E7            pop d
0038   042F 10 02 00      mov a, 2
0039   0432 AC            mul a, b
0040   0433 5A            add d, b
0041   0434 E4            pop a
0042   0435 DA            push d
0043   0436 26 14 00      mov b, 20
0044   0439 D7            push a
0045   043A 11            mov a, b
0046   043B 26 02 00      mov b, 2
0047   043E AE            div a, b
0048   043F FD 78         mov g, a
0049   0441 11            mov a, b
0050   0442 FD 27         mov b, g
0051   0444 E4            pop a
0052   0445 E7            pop d
0053   0446 FD 43         mov [d], b
0054   0448             _while1_cond:
0055   0448 26 01 00      mov b, 1
0056   044B C0 00 00      cmp b, 0
0057   044E C6 5A 04      je _while1_exit
0058   0451             _while1_block:
0059   0451 07 60 04      call draw_board
0060   0454 07 43 06      call update_snake
0061   0457 0A 48 04      jmp _while1_cond
0062   045A             _while1_exit:
0063   045A 26 00 00      mov b, 0
0064   045D F9            leave
0065   045E 05 0B         syscall sys_terminate_proc
0066   0460             
0067   0460             draw_board:
0068   0460 D2            push bp
0069   0461 9B            mov bp, sp
0070   0462 52 02 00      sub sp, 2 ; x
0071   0465 52 02 00      sub sp, 2 ; y
0072   0468 52 02 00      sub sp, 2 ; i
0073   046B 52 01 00      sub sp, 1 ; c
0074   046E             _for2_init:
0075   046E 26 00 00      mov b, 0
0076   0471 D7            push a
0077   0472 11            mov a, b
0078   0473 45 FD FF      mov [bp + -3], a ; y
0079   0476 E4            pop a
0080   0477             _for2_cond:
0081   0477 2C FD FF      mov b, [bp + -3] ; y
0082   047A D7            push a
0083   047B 11            mov a, b
0084   047C 26 14 00      mov b, 20
0085   047F B0            cmp a, b
0086   0480 0E            lodflgs
0087   0481 2F            mov bl, al
0088   0482 FD A2 03      shr al, 3
0089   0485 FD A4 02      shr bl, 2
0090   0488 FD 87 01      and bl, %00000001
0091   048B 90            xor al, bl ; < (signed)
0092   048C 22 00         mov ah, 0
0093   048E 27            mov b, a
0094   048F E4            pop a
0095   0490 C0 00 00      cmp b, 0
0096   0493 C6 2B 06      je _for2_exit
0097   0496             _for2_block:
0098   0496             _for3_init:
0099   0496 26 00 00      mov b, 0
0100   0499 D7            push a
0101   049A 11            mov a, b
0102   049B 45 FF FF      mov [bp + -1], a ; x
0103   049E E4            pop a
0104   049F             _for3_cond:
0105   049F 2C FF FF      mov b, [bp + -1] ; x
0106   04A2 D7            push a
0107   04A3 11            mov a, b
0108   04A4 26 28 00      mov b, 40
0109   04A7 B0            cmp a, b
0110   04A8 0E            lodflgs
0111   04A9 2F            mov bl, al
0112   04AA FD A2 03      shr al, 3
0113   04AD FD A4 02      shr bl, 2
0114   04B0 FD 87 01      and bl, %00000001
0115   04B3 90            xor al, bl ; < (signed)
0116   04B4 22 00         mov ah, 0
0117   04B6 27            mov b, a
0118   04B7 E4            pop a
0119   04B8 C0 00 00      cmp b, 0
0120   04BB C6 0F 06      je _for3_exit
0121   04BE             _for3_block:
0122   04BE 26 20 00      mov b, $20
0123   04C1 DB            push al
0124   04C2 1B            mov al, bl
0125   04C3 40 FA FF      mov [bp + -6], al ; c
0126   04C6 E8            pop al
0127   04C7             _if4_cond:
0128   04C7 2C FF FF      mov b, [bp + -1] ; x
0129   04CA D7            push a
0130   04CB 11            mov a, b
0131   04CC 26 00 00      mov b, 0
0132   04CF B0            cmp a, b
0133   04D0 0E            lodflgs
0134   04D1 87 01         and al, %00000001 ; ==
0135   04D3 22 00         mov ah, 0
0136   04D5 27            mov b, a
0137   04D6 E4            pop a
0138   04D7 D7            push a
0139   04D8 11            mov a, b
0140   04D9 2C FF FF      mov b, [bp + -1] ; x
0141   04DC D7            push a
0142   04DD 11            mov a, b
0143   04DE 26 28 00      mov b, 40
0144   04E1 D7            push a
0145   04E2 11            mov a, b
0146   04E3 26 01 00      mov b, 1
0147   04E6 60            sub a, b
0148   04E7 27            mov b, a
0149   04E8 E4            pop a
0150   04E9 B0            cmp a, b
0151   04EA 0E            lodflgs
0152   04EB 87 01         and al, %00000001 ; ==
0153   04ED 22 00         mov ah, 0
0154   04EF 27            mov b, a
0155   04F0 E4            pop a
0156   04F1 8A            or a, b
0157   04F2 27            mov b, a
0158   04F3 E4            pop a
0159   04F4 D7            push a
0160   04F5 11            mov a, b
0161   04F6 2C FD FF      mov b, [bp + -3] ; y
0162   04F9 D7            push a
0163   04FA 11            mov a, b
0164   04FB 26 00 00      mov b, 0
0165   04FE B0            cmp a, b
0166   04FF 0E            lodflgs
0167   0500 87 01         and al, %00000001 ; ==
0168   0502 22 00         mov ah, 0
0169   0504 27            mov b, a
0170   0505 E4            pop a
0171   0506 8A            or a, b
0172   0507 27            mov b, a
0173   0508 E4            pop a
0174   0509 D7            push a
0175   050A 11            mov a, b
0176   050B 2C FD FF      mov b, [bp + -3] ; y
0177   050E D7            push a
0178   050F 11            mov a, b
0179   0510 26 14 00      mov b, 20
0180   0513 D7            push a
0181   0514 11            mov a, b
0182   0515 26 01 00      mov b, 1
0183   0518 60            sub a, b
0184   0519 27            mov b, a
0185   051A E4            pop a
0186   051B B0            cmp a, b
0187   051C 0E            lodflgs
0188   051D 87 01         and al, %00000001 ; ==
0189   051F 22 00         mov ah, 0
0190   0521 27            mov b, a
0191   0522 E4            pop a
0192   0523 8A            or a, b
0193   0524 27            mov b, a
0194   0525 E4            pop a
0195   0526 C0 00 00      cmp b, 0
0196   0529 C6 38 05      je _if4_else
0197   052C             _if4_true:
0198   052C 26 23 00      mov b, $23
0199   052F DB            push al
0200   0530 1B            mov al, bl
0201   0531 40 FA FF      mov [bp + -6], al ; c
0202   0534 E8            pop al
0203   0535 0A F1 05      jmp _if4_exit
0204   0538             _if4_else:
0205   0538             _for5_init:
0206   0538 26 00 00      mov b, 0
0207   053B D7            push a
0208   053C 11            mov a, b
0209   053D 45 FB FF      mov [bp + -5], a ; i
0210   0540 E4            pop a
0211   0541             _for5_cond:
0212   0541 2C FB FF      mov b, [bp + -5] ; i
0213   0544 D7            push a
0214   0545 11            mov a, b
0215   0546 29 64 0A      mov b, [__snake_len] ; snake_len
0216   0549 B0            cmp a, b
0217   054A 0E            lodflgs
0218   054B 2F            mov bl, al
0219   054C FD A2 03      shr al, 3
0220   054F FD A4 02      shr bl, 2
0221   0552 FD 87 01      and bl, %00000001
0222   0555 90            xor al, bl ; < (signed)
0223   0556 22 00         mov ah, 0
0224   0558 27            mov b, a
0225   0559 E4            pop a
0226   055A C0 00 00      cmp b, 0
0227   055D C6 F1 05      je _for5_exit
0228   0560             _for5_block:
0229   0560             _if6_cond:
0230   0560 2C FF FF      mov b, [bp + -1] ; x
0231   0563 D7            push a
0232   0564 11            mov a, b
0233   0565 29 98 09      mov b, [__snake_x] ; snake_x
0234   0568 D7            push a
0235   0569 74            mov d, b
0236   056A DA            push d
0237   056B 2C FB FF      mov b, [bp + -5] ; i
0238   056E E7            pop d
0239   056F 10 02 00      mov a, 2
0240   0572 AC            mul a, b
0241   0573 5A            add d, b
0242   0574 E4            pop a
0243   0575 2A            mov b, [d]
0244   0576 B0            cmp a, b
0245   0577 0E            lodflgs
0246   0578 87 01         and al, %00000001 ; ==
0247   057A 22 00         mov ah, 0
0248   057C 27            mov b, a
0249   057D E4            pop a
0250   057E DB            push al
0251   057F C0 00 00      cmp b, 0
0252   0582 0E            lodflgs ; transform condition into a single bit
0253   0583 2C FD FF      mov b, [bp + -3] ; y
0254   0586 D7            push a
0255   0587 11            mov a, b
0256   0588 29 62 0A      mov b, [__snake_y] ; snake_y
0257   058B D7            push a
0258   058C 74            mov d, b
0259   058D DA            push d
0260   058E 2C FB FF      mov b, [bp + -5] ; i
0261   0591 E7            pop d
0262   0592 10 02 00      mov a, 2
0263   0595 AC            mul a, b
0264   0596 5A            add d, b
0265   0597 E4            pop a
0266   0598 2A            mov b, [d]
0267   0599 B0            cmp a, b
0268   059A 0E            lodflgs
0269   059B 87 01         and al, %00000001 ; ==
0270   059D 22 00         mov ah, 0
0271   059F 27            mov b, a
0272   05A0 E4            pop a
0273   05A1 DB            push al
0274   05A2 C0 00 00      cmp b, 0
0275   05A5 0E            lodflgs
0276   05A6 EA            pop bl ; matches previous 'push al'
0277   05A7 8C            or al, bl
0278   05A8 8F 01         xor al, %00000001
0279   05AA 2F            mov bl, al
0280   05AB A7 00         mov bh, 0
0281   05AD E8            pop al
0282   05AE C0 00 00      cmp b, 0
0283   05B1 C6 DF 05      je _if6_exit
0284   05B4             _if6_true:
0285   05B4             _ternary7_cond:
0286   05B4 2C FB FF      mov b, [bp + -5] ; i
0287   05B7 D7            push a
0288   05B8 11            mov a, b
0289   05B9 26 00 00      mov b, 0
0290   05BC B0            cmp a, b
0291   05BD 0E            lodflgs
0292   05BE 87 01         and al, %00000001 ; ==
0293   05C0 22 00         mov ah, 0
0294   05C2 27            mov b, a
0295   05C3 E4            pop a
0296   05C4 C0 00 00      cmp b, 0
0297   05C7 C6 D0 05      je _ternary7_false
0298   05CA             _ternary7_true:
0299   05CA 26 4F 00      mov b, $4f
0300   05CD 0A D3 05      jmp _ternary7_exit
0301   05D0             _ternary7_false:
0302   05D0 26 6F 00      mov b, $6f
0303   05D3             _ternary7_exit:
0304   05D3 DB            push al
0305   05D4 1B            mov al, bl
0306   05D5 40 FA FF      mov [bp + -6], al ; c
0307   05D8 E8            pop al
0308   05D9 0A F1 05      jmp _for5_exit ; for break
0309   05DC 0A DF 05      jmp _if6_exit
0310   05DF             _if6_exit:
0311   05DF             _for5_update:
0312   05DF 2C FB FF      mov b, [bp + -5] ; i
0313   05E2 D7            push a
0314   05E3 11            mov a, b
0315   05E4 FD 77         inc b
0316   05E6 D7            push a
0317   05E7 11            mov a, b
0318   05E8 45 FB FF      mov [bp + -5], a ; i
0319   05EB E4            pop a
0320   05EC 27            mov b, a
0321   05ED E4            pop a
0322   05EE 0A 41 05      jmp _for5_cond
0323   05F1             _for5_exit:
0324   05F1             _if4_exit:
0325   05F1 34 FA FF      mov bl, [bp + -6] ; c
0326   05F4 A7 00         mov bh, 0
0327   05F6 DD            push bl
0328   05F7 07 38 06      call _putchar
0329   05FA 51 01 00      add sp, 1
0330   05FD             _for3_update:
0331   05FD 2C FF FF      mov b, [bp + -1] ; x
0332   0600 D7            push a
0333   0601 11            mov a, b
0334   0602 FD 77         inc b
0335   0604 D7            push a
0336   0605 11            mov a, b
0337   0606 45 FF FF      mov [bp + -1], a ; x
0338   0609 E4            pop a
0339   060A 27            mov b, a
0340   060B E4            pop a
0341   060C 0A 9F 04      jmp _for3_cond
0342   060F             _for3_exit:
0343   060F 26 0A 00      mov b, $a
0344   0612 DD            push bl
0345   0613 07 38 06      call _putchar
0346   0616 51 01 00      add sp, 1
0347   0619             _for2_update:
0348   0619 2C FD FF      mov b, [bp + -3] ; y
0349   061C D7            push a
0350   061D 11            mov a, b
0351   061E FD 77         inc b
0352   0620 D7            push a
0353   0621 11            mov a, b
0354   0622 45 FD FF      mov [bp + -3], a ; y
0355   0625 E4            pop a
0356   0626 27            mov b, a
0357   0627 E4            pop a
0358   0628 0A 77 04      jmp _for2_cond
0359   062B             _for2_exit:
0360   062B F9            leave
0361   062C 09            ret
0362   062D             
0363   062D             print:
0364   062D D2            push bp
0365   062E 9B            mov bp, sp
0366   062F             
0367   062F             ; --- BEGIN INLINE ASM BLOCK
0368   062F 17 05 00      mov a, [bp + 5]
0369   0632 3C            mov d, a
0370   0633 07 B6 0C      call puts
0371   0636             ; --- END INLINE ASM BLOCK
0372   0636             
0373   0636 F9            leave
0374   0637 09            ret
0375   0638             
0376   0638             _putchar:
0377   0638 D2            push bp
0378   0639 9B            mov bp, sp
0379   063A             
0380   063A             ; --- BEGIN INLINE ASM BLOCK
0381   063A 20 05 00      mov al, [bp + 5]
0382   063D 23            mov ah, al
0383   063E 07 7C 0B      call putchar
0384   0641             ; --- END INLINE ASM BLOCK
0385   0641             
0386   0641 F9            leave
0387   0642 09            ret
0388   0643             
0389   0643             update_snake:
0390   0643 D2            push bp
0391   0644 9B            mov bp, sp
0392   0645 52 02 00      sub sp, 2 ; i
0393   0648             _for8_init:
0394   0648 29 64 0A      mov b, [__snake_len] ; snake_len
0395   064B D7            push a
0396   064C 11            mov a, b
0397   064D 26 01 00      mov b, 1
0398   0650 60            sub a, b
0399   0651 27            mov b, a
0400   0652 E4            pop a
0401   0653 D7            push a
0402   0654 11            mov a, b
0403   0655 45 FF FF      mov [bp + -1], a ; i
0404   0658 E4            pop a
0405   0659             _for8_cond:
0406   0659 2C FF FF      mov b, [bp + -1] ; i
0407   065C D7            push a
0408   065D 11            mov a, b
0409   065E 26 00 00      mov b, 0
0410   0661 B0            cmp a, b
0411   0662 0E            lodflgs
0412   0663 2F            mov bl, al
0413   0664 FD 78         mov g, a
0414   0666 FD A2 03      shr al, 3
0415   0669 FD A4 02      shr bl, 2
0416   066C FD 87 01      and bl, %00000001
0417   066F 90            xor al, bl
0418   0670 FD 27         mov b, g
0419   0672 FD 87 01      and bl, %00000001
0420   0675 8C            or al, bl
0421   0676 8F 01         xor al, %00000001 ; > (signed)
0422   0678 22 00         mov ah, 0
0423   067A 27            mov b, a
0424   067B E4            pop a
0425   067C C0 00 00      cmp b, 0
0426   067F C6 EE 06      je _for8_exit
0427   0682             _for8_block:
0428   0682 29 98 09      mov b, [__snake_x] ; snake_x
0429   0685 D7            push a
0430   0686 74            mov d, b
0431   0687 DA            push d
0432   0688 2C FF FF      mov b, [bp + -1] ; i
0433   068B E7            pop d
0434   068C 10 02 00      mov a, 2
0435   068F AC            mul a, b
0436   0690 5A            add d, b
0437   0691 E4            pop a
0438   0692 DA            push d
0439   0693 29 98 09      mov b, [__snake_x] ; snake_x
0440   0696 D7            push a
0441   0697 74            mov d, b
0442   0698 DA            push d
0443   0699 2C FF FF      mov b, [bp + -1] ; i
0444   069C D7            push a
0445   069D 11            mov a, b
0446   069E 26 01 00      mov b, 1
0447   06A1 60            sub a, b
0448   06A2 27            mov b, a
0449   06A3 E4            pop a
0450   06A4 E7            pop d
0451   06A5 10 02 00      mov a, 2
0452   06A8 AC            mul a, b
0453   06A9 5A            add d, b
0454   06AA E4            pop a
0455   06AB 2A            mov b, [d]
0456   06AC E7            pop d
0457   06AD FD 43         mov [d], b
0458   06AF 29 62 0A      mov b, [__snake_y] ; snake_y
0459   06B2 D7            push a
0460   06B3 74            mov d, b
0461   06B4 DA            push d
0462   06B5 2C FF FF      mov b, [bp + -1] ; i
0463   06B8 E7            pop d
0464   06B9 10 02 00      mov a, 2
0465   06BC AC            mul a, b
0466   06BD 5A            add d, b
0467   06BE E4            pop a
0468   06BF DA            push d
0469   06C0 29 62 0A      mov b, [__snake_y] ; snake_y
0470   06C3 D7            push a
0471   06C4 74            mov d, b
0472   06C5 DA            push d
0473   06C6 2C FF FF      mov b, [bp + -1] ; i
0474   06C9 D7            push a
0475   06CA 11            mov a, b
0476   06CB 26 01 00      mov b, 1
0477   06CE 60            sub a, b
0478   06CF 27            mov b, a
0479   06D0 E4            pop a
0480   06D1 E7            pop d
0481   06D2 10 02 00      mov a, 2
0482   06D5 AC            mul a, b
0483   06D6 5A            add d, b
0484   06D7 E4            pop a
0485   06D8 2A            mov b, [d]
0486   06D9 E7            pop d
0487   06DA FD 43         mov [d], b
0488   06DC             _for8_update:
0489   06DC 2C FF FF      mov b, [bp + -1] ; i
0490   06DF D7            push a
0491   06E0 11            mov a, b
0492   06E1 FD 7D         dec b
0493   06E3 D7            push a
0494   06E4 11            mov a, b
0495   06E5 45 FF FF      mov [bp + -1], a ; i
0496   06E8 E4            pop a
0497   06E9 27            mov b, a
0498   06EA E4            pop a
0499   06EB 0A 59 06      jmp _for8_cond
0500   06EE             _for8_exit:
0501   06EE 29 98 09      mov b, [__snake_x] ; snake_x
0502   06F1 D7            push a
0503   06F2 74            mov d, b
0504   06F3 DA            push d
0505   06F4 26 00 00      mov b, 0
0506   06F7 E7            pop d
0507   06F8 10 02 00      mov a, 2
0508   06FB AC            mul a, b
0509   06FC 5A            add d, b
0510   06FD E4            pop a
0511   06FE DA            push d
0512   06FF 29 98 09      mov b, [__snake_x] ; snake_x
0513   0702 D7            push a
0514   0703 74            mov d, b
0515   0704 DA            push d
0516   0705 26 00 00      mov b, 0
0517   0708 E7            pop d
0518   0709 10 02 00      mov a, 2
0519   070C AC            mul a, b
0520   070D 5A            add d, b
0521   070E E4            pop a
0522   070F 2A            mov b, [d]
0523   0710 D7            push a
0524   0711 11            mov a, b
0525   0712 29 66 0A      mov b, [__dx] ; dx
0526   0715 54            add a, b
0527   0716 27            mov b, a
0528   0717 E4            pop a
0529   0718 E7            pop d
0530   0719 FD 43         mov [d], b
0531   071B 29 62 0A      mov b, [__snake_y] ; snake_y
0532   071E D7            push a
0533   071F 74            mov d, b
0534   0720 DA            push d
0535   0721 26 00 00      mov b, 0
0536   0724 E7            pop d
0537   0725 10 02 00      mov a, 2
0538   0728 AC            mul a, b
0539   0729 5A            add d, b
0540   072A E4            pop a
0541   072B DA            push d
0542   072C 29 62 0A      mov b, [__snake_y] ; snake_y
0543   072F D7            push a
0544   0730 74            mov d, b
0545   0731 DA            push d
0546   0732 26 00 00      mov b, 0
0547   0735 E7            pop d
0548   0736 10 02 00      mov a, 2
0549   0739 AC            mul a, b
0550   073A 5A            add d, b
0551   073B E4            pop a
0552   073C 2A            mov b, [d]
0553   073D D7            push a
0554   073E 11            mov a, b
0555   073F 29 68 0A      mov b, [__dy] ; dy
0556   0742 54            add a, b
0557   0743 27            mov b, a
0558   0744 E4            pop a
0559   0745 E7            pop d
0560   0746 FD 43         mov [d], b
0561   0748             _if9_cond:
0562   0748 29 98 09      mov b, [__snake_x] ; snake_x
0563   074B D7            push a
0564   074C 74            mov d, b
0565   074D DA            push d
0566   074E 26 00 00      mov b, 0
0567   0751 E7            pop d
0568   0752 10 02 00      mov a, 2
0569   0755 AC            mul a, b
0570   0756 5A            add d, b
0571   0757 E4            pop a
0572   0758 2A            mov b, [d]
0573   0759 D7            push a
0574   075A 11            mov a, b
0575   075B 26 00 00      mov b, 0
0576   075E B0            cmp a, b
0577   075F 0E            lodflgs
0578   0760 2F            mov bl, al
0579   0761 FD 78         mov g, a
0580   0763 FD A2 03      shr al, 3
0581   0766 FD A4 02      shr bl, 2
0582   0769 FD 87 01      and bl, %00000001
0583   076C 90            xor al, bl
0584   076D FD 27         mov b, g
0585   076F FD 87 01      and bl, %00000001
0586   0772 8C            or al, bl ; <= (signed)
0587   0773 22 00         mov ah, 0
0588   0775 27            mov b, a
0589   0776 E4            pop a
0590   0777 D7            push a
0591   0778 11            mov a, b
0592   0779 29 98 09      mov b, [__snake_x] ; snake_x
0593   077C D7            push a
0594   077D 74            mov d, b
0595   077E DA            push d
0596   077F 26 00 00      mov b, 0
0597   0782 E7            pop d
0598   0783 10 02 00      mov a, 2
0599   0786 AC            mul a, b
0600   0787 5A            add d, b
0601   0788 E4            pop a
0602   0789 2A            mov b, [d]
0603   078A D7            push a
0604   078B 11            mov a, b
0605   078C 26 28 00      mov b, 40
0606   078F D7            push a
0607   0790 11            mov a, b
0608   0791 26 01 00      mov b, 1
0609   0794 60            sub a, b
0610   0795 27            mov b, a
0611   0796 E4            pop a
0612   0797 B0            cmp a, b
0613   0798 0E            lodflgs
0614   0799 2F            mov bl, al
0615   079A FD A2 03      shr al, 3
0616   079D FD A4 02      shr bl, 2
0617   07A0 FD 87 01      and bl, %00000001
0618   07A3 90            xor al, bl
0619   07A4 8F 01         xor al, %00000001 ; >= (signed)
0620   07A6 22 00         mov ah, 0
0621   07A8 27            mov b, a
0622   07A9 E4            pop a
0623   07AA 8A            or a, b
0624   07AB 27            mov b, a
0625   07AC E4            pop a
0626   07AD D7            push a
0627   07AE 11            mov a, b
0628   07AF 29 62 0A      mov b, [__snake_y] ; snake_y
0629   07B2 D7            push a
0630   07B3 74            mov d, b
0631   07B4 DA            push d
0632   07B5 26 00 00      mov b, 0
0633   07B8 E7            pop d
0634   07B9 10 02 00      mov a, 2
0635   07BC AC            mul a, b
0636   07BD 5A            add d, b
0637   07BE E4            pop a
0638   07BF 2A            mov b, [d]
0639   07C0 D7            push a
0640   07C1 11            mov a, b
0641   07C2 26 00 00      mov b, 0
0642   07C5 B0            cmp a, b
0643   07C6 0E            lodflgs
0644   07C7 2F            mov bl, al
0645   07C8 FD 78         mov g, a
0646   07CA FD A2 03      shr al, 3
0647   07CD FD A4 02      shr bl, 2
0648   07D0 FD 87 01      and bl, %00000001
0649   07D3 90            xor al, bl
0650   07D4 FD 27         mov b, g
0651   07D6 FD 87 01      and bl, %00000001
0652   07D9 8C            or al, bl ; <= (signed)
0653   07DA 22 00         mov ah, 0
0654   07DC 27            mov b, a
0655   07DD E4            pop a
0656   07DE 8A            or a, b
0657   07DF 27            mov b, a
0658   07E0 E4            pop a
0659   07E1 D7            push a
0660   07E2 11            mov a, b
0661   07E3 29 62 0A      mov b, [__snake_y] ; snake_y
0662   07E6 D7            push a
0663   07E7 74            mov d, b
0664   07E8 DA            push d
0665   07E9 26 00 00      mov b, 0
0666   07EC E7            pop d
0667   07ED 10 02 00      mov a, 2
0668   07F0 AC            mul a, b
0669   07F1 5A            add d, b
0670   07F2 E4            pop a
0671   07F3 2A            mov b, [d]
0672   07F4 D7            push a
0673   07F5 11            mov a, b
0674   07F6 26 14 00      mov b, 20
0675   07F9 D7            push a
0676   07FA 11            mov a, b
0677   07FB 26 01 00      mov b, 1
0678   07FE 60            sub a, b
0679   07FF 27            mov b, a
0680   0800 E4            pop a
0681   0801 B0            cmp a, b
0682   0802 0E            lodflgs
0683   0803 2F            mov bl, al
0684   0804 FD A2 03      shr al, 3
0685   0807 FD A4 02      shr bl, 2
0686   080A FD 87 01      and bl, %00000001
0687   080D 90            xor al, bl
0688   080E 8F 01         xor al, %00000001 ; >= (signed)
0689   0810 22 00         mov ah, 0
0690   0812 27            mov b, a
0691   0813 E4            pop a
0692   0814 8A            or a, b
0693   0815 27            mov b, a
0694   0816 E4            pop a
0695   0817 C0 00 00      cmp b, 0
0696   081A C6 C4 08      je _if9_exit
0697   081D             _if9_true:
0698   081D             _if10_cond:
0699   081D 29 66 0A      mov b, [__dx] ; dx
0700   0820 D7            push a
0701   0821 11            mov a, b
0702   0822 26 01 00      mov b, 1
0703   0825 B0            cmp a, b
0704   0826 0E            lodflgs
0705   0827 87 01         and al, %00000001 ; ==
0706   0829 22 00         mov ah, 0
0707   082B 27            mov b, a
0708   082C E4            pop a
0709   082D C0 00 00      cmp b, 0
0710   0830 C6 44 08      je _if10_else
0711   0833             _if10_true:
0712   0833 26 00 00      mov b, 0
0713   0836 FD 42 66 0A   mov [__dx], b
0714   083A 26 01 00      mov b, 1
0715   083D FD 42 68 0A   mov [__dy], b
0716   0841 0A C1 08      jmp _if10_exit
0717   0844             _if10_else:
0718   0844             _if11_cond:
0719   0844 29 68 0A      mov b, [__dy] ; dy
0720   0847 D7            push a
0721   0848 11            mov a, b
0722   0849 26 01 00      mov b, 1
0723   084C B0            cmp a, b
0724   084D 0E            lodflgs
0725   084E 87 01         and al, %00000001 ; ==
0726   0850 22 00         mov ah, 0
0727   0852 27            mov b, a
0728   0853 E4            pop a
0729   0854 C0 00 00      cmp b, 0
0730   0857 C6 6D 08      je _if11_else
0731   085A             _if11_true:
0732   085A 26 01 00      mov b, 1
0733   085D FD 97         neg b
0734   085F FD 42 66 0A   mov [__dx], b
0735   0863 26 00 00      mov b, 0
0736   0866 FD 42 68 0A   mov [__dy], b
0737   086A 0A C1 08      jmp _if11_exit
0738   086D             _if11_else:
0739   086D             _if12_cond:
0740   086D 29 66 0A      mov b, [__dx] ; dx
0741   0870 D7            push a
0742   0871 11            mov a, b
0743   0872 26 01 00      mov b, 1
0744   0875 FD 97         neg b
0745   0877 B0            cmp a, b
0746   0878 0E            lodflgs
0747   0879 87 01         and al, %00000001 ; ==
0748   087B 22 00         mov ah, 0
0749   087D 27            mov b, a
0750   087E E4            pop a
0751   087F C0 00 00      cmp b, 0
0752   0882 C6 98 08      je _if12_else
0753   0885             _if12_true:
0754   0885 26 00 00      mov b, 0
0755   0888 FD 42 66 0A   mov [__dx], b
0756   088C 26 01 00      mov b, 1
0757   088F FD 97         neg b
0758   0891 FD 42 68 0A   mov [__dy], b
0759   0895 0A C1 08      jmp _if12_exit
0760   0898             _if12_else:
0761   0898             _if13_cond:
0762   0898 29 68 0A      mov b, [__dy] ; dy
0763   089B D7            push a
0764   089C 11            mov a, b
0765   089D 26 01 00      mov b, 1
0766   08A0 FD 97         neg b
0767   08A2 B0            cmp a, b
0768   08A3 0E            lodflgs
0769   08A4 87 01         and al, %00000001 ; ==
0770   08A6 22 00         mov ah, 0
0771   08A8 27            mov b, a
0772   08A9 E4            pop a
0773   08AA C0 00 00      cmp b, 0
0774   08AD C6 C1 08      je _if13_exit
0775   08B0             _if13_true:
0776   08B0 26 01 00      mov b, 1
0777   08B3 FD 42 66 0A   mov [__dx], b
0778   08B7 26 00 00      mov b, 0
0779   08BA FD 42 68 0A   mov [__dy], b
0780   08BE 0A C1 08      jmp _if13_exit
0781   08C1             _if13_exit:
0782   08C1             _if12_exit:
0783   08C1             _if11_exit:
0784   08C1             _if10_exit:
0785   08C1 0A C4 08      jmp _if9_exit
0786   08C4             _if9_exit:
0787   08C4 F9            leave
0788   08C5 09            ret
0789   08C6             ; --- END TEXT BLOCK
0790   08C6             
0791   08C6             ; --- BEGIN DATA BLOCK
0792   08C6             __s_data: 
0793   08C6 1B 5B 32 4A .db 27,$5b,$32,$4a,27,$5b,$48,0,
0793   08CA 1B 5B 48 00 
0794   08CE             .fill 0, 0
0795   08CE C6 08       __s: .dw __s_data
0796   08D0 00 00 00 00 __snake_x_data: .fill 200, 0
0796   08D4 00 00 00 00 
0796   08D8 00 00 00 00 
0796   08DC 00 00 00 00 
0796   08E0 00 00 00 00 
0796   08E4 00 00 00 00 
0796   08E8 00 00 00 00 
0796   08EC 00 00 00 00 
0796   08F0 00 00 00 00 
0796   08F4 00 00 00 00 
0796   08F8 00 00 00 00 
0796   08FC 00 00 00 00 
0796   0900 00 00 00 00 
0796   0904 00 00 00 00 
0796   0908 00 00 00 00 
0796   090C 00 00 00 00 
0796   0910 00 00 00 00 
0796   0914 00 00 00 00 
0796   0918 00 00 00 00 
0796   091C 00 00 00 00 
0796   0920 00 00 00 00 
0796   0924 00 00 00 00 
0796   0928 00 00 00 00 
0796   092C 00 00 00 00 
0796   0930 00 00 00 00 
0796   0934 00 00 00 00 
0796   0938 00 00 00 00 
0796   093C 00 00 00 00 
0796   0940 00 00 00 00 
0796   0944 00 00 00 00 
0796   0948 00 00 00 00 
0796   094C 00 00 00 00 
0796   0950 00 00 00 00 
0796   0954 00 00 00 00 
0796   0958 00 00 00 00 
0796   095C 00 00 00 00 
0796   0960 00 00 00 00 
0796   0964 00 00 00 00 
0796   0968 00 00 00 00 
0796   096C 00 00 00 00 
0796   0970 00 00 00 00 
0796   0974 00 00 00 00 
0796   0978 00 00 00 00 
0796   097C 00 00 00 00 
0796   0980 00 00 00 00 
0796   0984 00 00 00 00 
0796   0988 00 00 00 00 
0796   098C 00 00 00 00 
0796   0990 00 00 00 00 
0796   0994 00 00 00 00 
0797   0998 D0 08       __snake_x: .dw __snake_x_data
0798   099A 00 00 00 00 __snake_y_data: .fill 200, 0
0798   099E 00 00 00 00 
0798   09A2 00 00 00 00 
0798   09A6 00 00 00 00 
0798   09AA 00 00 00 00 
0798   09AE 00 00 00 00 
0798   09B2 00 00 00 00 
0798   09B6 00 00 00 00 
0798   09BA 00 00 00 00 
0798   09BE 00 00 00 00 
0798   09C2 00 00 00 00 
0798   09C6 00 00 00 00 
0798   09CA 00 00 00 00 
0798   09CE 00 00 00 00 
0798   09D2 00 00 00 00 
0798   09D6 00 00 00 00 
0798   09DA 00 00 00 00 
0798   09DE 00 00 00 00 
0798   09E2 00 00 00 00 
0798   09E6 00 00 00 00 
0798   09EA 00 00 00 00 
0798   09EE 00 00 00 00 
0798   09F2 00 00 00 00 
0798   09F6 00 00 00 00 
0798   09FA 00 00 00 00 
0798   09FE 00 00 00 00 
0798   0A02 00 00 00 00 
0798   0A06 00 00 00 00 
0798   0A0A 00 00 00 00 
0798   0A0E 00 00 00 00 
0798   0A12 00 00 00 00 
0798   0A16 00 00 00 00 
0798   0A1A 00 00 00 00 
0798   0A1E 00 00 00 00 
0798   0A22 00 00 00 00 
0798   0A26 00 00 00 00 
0798   0A2A 00 00 00 00 
0798   0A2E 00 00 00 00 
0798   0A32 00 00 00 00 
0798   0A36 00 00 00 00 
0798   0A3A 00 00 00 00 
0798   0A3E 00 00 00 00 
0798   0A42 00 00 00 00 
0798   0A46 00 00 00 00 
0798   0A4A 00 00 00 00 
0798   0A4E 00 00 00 00 
0798   0A52 00 00 00 00 
0798   0A56 00 00 00 00 
0798   0A5A 00 00 00 00 
0798   0A5E 00 00 00 00 
0799   0A62 9A 09       __snake_y: .dw __snake_y_data
0800   0A64 01 00       __snake_len: .dw 1
0801   0A66 01 00       __dx: .dw 1
0802   0A68 00 00       __dy: .dw 0
0803   0A6A             ; --- END DATA BLOCK
0804   0A6A             
0805   0A6A             ; --- BEGIN INCLUDE BLOCK
0806   0A6A             .include "lib/stdio.asm"
0001+  0A6A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0A6A             ; stdio.s
0003+  0A6A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0A6A             .include "lib/string.asm"
0001++ 0A6A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0A6A             ; string.s
0003++ 0A6A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0A6A             
0005++ 0A6A             
0006++ 0A6A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0A6A             ; strrev
0008++ 0A6A             ; reverse a string
0009++ 0A6A             ; D = string address
0010++ 0A6A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0A6A             ; 01234
0012++ 0A6A             strrev:
0013++ 0A6A 4B          	pusha
0014++ 0A6B 07 B1 0A    	call strlen	; length in C
0015++ 0A6E 12          	mov a, c
0016++ 0A6F AF 01 00    	cmp a, 1
0017++ 0A72 D0 8C 0A    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0A75 7D          	dec a
0019++ 0A76 FD 4E       	mov si, d	; beginning of string
0020++ 0A78 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0A7A 59          	add d, a	; end of string
0022++ 0A7B 12          	mov a, c
0023++ 0A7C FD 9B       	shr a		; divide by 2
0024++ 0A7E 39          	mov c, a	; C now counts the steps
0025++ 0A7F             strrev_L0:
0026++ 0A7F 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0A80 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0A81 3E          	mov [d], al	; store left char into right side
0029++ 0A82 1B          	mov al, bl
0030++ 0A83 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0A84 7E          	dec c
0032++ 0A85 7F          	dec d
0033++ 0A86 C2 00 00    	cmp c, 0
0034++ 0A89 C7 7F 0A    	jne strrev_L0
0035++ 0A8C             strrev_end:
0036++ 0A8C 4C          	popa
0037++ 0A8D 09          	ret
0038++ 0A8E             	
0039++ 0A8E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0A8E             ; strchr
0041++ 0A8E             ; search string in D for char in AL
0042++ 0A8E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0A8E             strchr:
0044++ 0A8E             strchr_L0:
0045++ 0A8E 32          	mov bl, [d]
0046++ 0A8F C1 00       	cmp bl, 0
0047++ 0A91 C6 9C 0A    	je strchr_end
0048++ 0A94 BA          	cmp al, bl
0049++ 0A95 C6 9C 0A    	je strchr_end
0050++ 0A98 79          	inc d
0051++ 0A99 0A 8E 0A    	jmp strchr_L0
0052++ 0A9C             strchr_end:
0053++ 0A9C 1B          	mov al, bl
0054++ 0A9D 09          	ret
0055++ 0A9E             
0056++ 0A9E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0A9E             ; strstr
0058++ 0A9E             ; find sub-string
0059++ 0A9E             ; str1 in SI
0060++ 0A9E             ; str2 in DI
0061++ 0A9E             ; SI points to end of source string
0062++ 0A9E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0A9E             strstr:
0064++ 0A9E DB          	push al
0065++ 0A9F DA          	push d
0066++ 0AA0 E3          	push di
0067++ 0AA1             strstr_loop:
0068++ 0AA1 F3          	cmpsb					; compare a byte of the strings
0069++ 0AA2 C7 AD 0A    	jne strstr_ret
0070++ 0AA5 FC 00 00    	lea d, [di + 0]
0071++ 0AA8 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0AAA C7 A1 0A    	jne strstr_loop				; equal chars but not at end
0073++ 0AAD             strstr_ret:
0074++ 0AAD F0          	pop di
0075++ 0AAE E7          	pop d
0076++ 0AAF E8          	pop al
0077++ 0AB0 09          	ret
0078++ 0AB1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0AB1             ; length of null terminated string
0080++ 0AB1             ; result in C
0081++ 0AB1             ; pointer in D
0082++ 0AB1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0AB1             strlen:
0084++ 0AB1 DA          	push d
0085++ 0AB2 38 00 00    	mov c, 0
0086++ 0AB5             strlen_L1:
0087++ 0AB5 BD 00       	cmp byte [d], 0
0088++ 0AB7 C6 BF 0A    	je strlen_ret
0089++ 0ABA 79          	inc d
0090++ 0ABB 78          	inc c
0091++ 0ABC 0A B5 0A    	jmp strlen_L1
0092++ 0ABF             strlen_ret:
0093++ 0ABF E7          	pop d
0094++ 0AC0 09          	ret
0095++ 0AC1             
0096++ 0AC1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0AC1             ; STRCMP
0098++ 0AC1             ; compare two strings
0099++ 0AC1             ; str1 in SI
0100++ 0AC1             ; str2 in DI
0101++ 0AC1             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0AC1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0AC1             strcmp:
0104++ 0AC1 DB          	push al
0105++ 0AC2 DA          	push d
0106++ 0AC3 E3          	push di
0107++ 0AC4 E2          	push si
0108++ 0AC5             strcmp_loop:
0109++ 0AC5 F3          	cmpsb					; compare a byte of the strings
0110++ 0AC6 C7 D1 0A    	jne strcmp_ret
0111++ 0AC9 FB FF FF    	lea d, [si +- 1]
0112++ 0ACC BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0ACE C7 C5 0A    	jne strcmp_loop				; equal chars but not at end
0114++ 0AD1             strcmp_ret:
0115++ 0AD1 EF          	pop si
0116++ 0AD2 F0          	pop di
0117++ 0AD3 E7          	pop d
0118++ 0AD4 E8          	pop al
0119++ 0AD5 09          	ret
0120++ 0AD6             
0121++ 0AD6             
0122++ 0AD6             ; STRCPY
0123++ 0AD6             ; copy null terminated string from SI to DI
0124++ 0AD6             ; source in SI
0125++ 0AD6             ; destination in DI
0126++ 0AD6             strcpy:
0127++ 0AD6 E2          	push si
0128++ 0AD7 E3          	push di
0129++ 0AD8 DB          	push al
0130++ 0AD9             strcpy_L1:
0131++ 0AD9 F6          	lodsb
0132++ 0ADA F7          	stosb
0133++ 0ADB B9 00       	cmp al, 0
0134++ 0ADD C7 D9 0A    	jne strcpy_L1
0135++ 0AE0             strcpy_end:
0136++ 0AE0 E8          	pop al
0137++ 0AE1 F0          	pop di
0138++ 0AE2 EF          	pop si
0139++ 0AE3 09          	ret
0140++ 0AE4             
0141++ 0AE4             ; STRCAT
0142++ 0AE4             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0AE4             ; source in SI
0144++ 0AE4             ; destination in DI
0145++ 0AE4             strcat:
0146++ 0AE4 E2          	push si
0147++ 0AE5 E3          	push di
0148++ 0AE6 D7          	push a
0149++ 0AE7 DA          	push d
0150++ 0AE8 50          	mov a, di
0151++ 0AE9 3C          	mov d, a
0152++ 0AEA             strcat_goto_end_L1:
0153++ 0AEA BD 00       	cmp byte[d], 0
0154++ 0AEC C6 F3 0A    	je strcat_start
0155++ 0AEF 79          	inc d
0156++ 0AF0 0A EA 0A    	jmp strcat_goto_end_L1
0157++ 0AF3             strcat_start:
0158++ 0AF3 FD 50       	mov di, d
0159++ 0AF5             strcat_L1:
0160++ 0AF5 F6          	lodsb
0161++ 0AF6 F7          	stosb
0162++ 0AF7 B9 00       	cmp al, 0
0163++ 0AF9 C7 F5 0A    	jne strcat_L1
0164++ 0AFC             strcat_end:
0165++ 0AFC E7          	pop d
0166++ 0AFD E4          	pop a
0167++ 0AFE F0          	pop di
0168++ 0AFF EF          	pop si
0169++ 0B00 09          	ret
0005+  0B01             
0006+  0B01 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  0B05 34 35 36 37 
0006+  0B09 38 39 41 42 
0006+  0B0D 43 44 45 46 
0007+  0B11 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  0B15 1B 5B 48 00 
0008+  0B19             
0009+  0B19 01 00       table_power:.dw 1
0010+  0B1B 0A 00       			.dw 10
0011+  0B1D 64 00       			.dw 100
0012+  0B1F E8 03       			.dw 1000
0013+  0B21 10 27       			.dw 10000
0014+  0B23             
0015+  0B23             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  0B23             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  0B23             ; ASCII in BL
0018+  0B23             ; result in AL
0019+  0B23             ; ascii for F = 0100 0110
0020+  0B23             ; ascii for 9 = 0011 1001
0021+  0B23             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  0B23             hex_ascii_encode:
0023+  0B23 1B          	mov al, bl
0024+  0B24 93 40       	test al, $40				; test if letter or number
0025+  0B26 C7 2C 0B    	jnz hex_letter
0026+  0B29 87 0F       	and al, $0F				; get number
0027+  0B2B 09          	ret
0028+  0B2C             hex_letter:
0029+  0B2C 87 0F       	and al, $0F				; get letter
0030+  0B2E 6A 09       	add al, 9
0031+  0B30 09          	ret
0032+  0B31             
0033+  0B31             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  0B31             ; ATOI
0035+  0B31             ; 2 letter hex string in B
0036+  0B31             ; 8bit integer returned in AL
0037+  0B31             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0B31             atoi:
0039+  0B31 D8          	push b
0040+  0B32 07 23 0B    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  0B35 30          	mov bl, bh
0042+  0B36 DB          	push al					; save a
0043+  0B37 07 23 0B    	call hex_ascii_encode
0044+  0B3A EA          	pop bl	
0045+  0B3B FD 9E 04    	shl al, 4
0046+  0B3E 8C          	or al, bl
0047+  0B3F E5          	pop b
0048+  0B40 09          	ret	
0049+  0B41             
0050+  0B41             
0051+  0B41             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  0B41             ; printf
0053+  0B41             ; no need for explanations!
0054+  0B41             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0B41             printf:
0056+  0B41 09          	ret
0057+  0B42             
0058+  0B42             
0059+  0B42             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  0B42             ; scanf
0061+  0B42             ; no need for explanations!
0062+  0B42             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  0B42             scanf:
0064+  0B42 09          	ret
0065+  0B43             
0066+  0B43             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  0B43             ; ITOA
0068+  0B43             ; 8bit value in BL
0069+  0B43             ; 2 byte ASCII result in A
0070+  0B43             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  0B43             itoa:
0072+  0B43 DA          	push d
0073+  0B44 D8          	push b
0074+  0B45 A7 00       	mov bh, 0
0075+  0B47 FD A4 04    	shr bl, 4	
0076+  0B4A 74          	mov d, b
0077+  0B4B 1F 01 0B    	mov al, [d + s_hex_digits]
0078+  0B4E 23          	mov ah, al
0079+  0B4F             	
0080+  0B4F E5          	pop b
0081+  0B50 D8          	push b
0082+  0B51 A7 00       	mov bh, 0
0083+  0B53 FD 87 0F    	and bl, $0F
0084+  0B56 74          	mov d, b
0085+  0B57 1F 01 0B    	mov al, [d + s_hex_digits]
0086+  0B5A E5          	pop b
0087+  0B5B E7          	pop d
0088+  0B5C 09          	ret
0089+  0B5D             
0090+  0B5D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  0B5D             ; HEX STRING TO BINARY
0092+  0B5D             ; di = destination address
0093+  0B5D             ; si = source
0094+  0B5D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  0B5D             hex_to_int:
0096+  0B5D             hex_to_int_L1:
0097+  0B5D F6          	lodsb					; load from [SI] to AL
0098+  0B5E B9 00       	cmp al, 0				; check if ASCII 0
0099+  0B60 C6 6D 0B    	jz hex_to_int_ret
0100+  0B63 36          	mov bh, al
0101+  0B64 F6          	lodsb
0102+  0B65 2F          	mov bl, al
0103+  0B66 07 31 0B    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  0B69 F7          	stosb					; store AL to [DI]
0105+  0B6A 0A 5D 0B    	jmp hex_to_int_L1
0106+  0B6D             hex_to_int_ret:
0107+  0B6D 09          	ret		
0108+  0B6E             
0109+  0B6E             
0110+  0B6E             
0111+  0B6E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  0B6E             ; GETCHAR
0113+  0B6E             ; char in ah
0114+  0B6E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  0B6E             getchar:
0116+  0B6E DB          	push al
0117+  0B6F             getchar_retry:
0118+  0B6F FD 0C       	sti
0119+  0B71 19 01       	mov al, 1
0120+  0B73 05 03       	syscall sys_io			; receive in AH
0121+  0B75 B9 00       	cmp al, 0			; check if any char was receive
0122+  0B77 C6 6F 0B    	je getchar_retry
0123+  0B7A E8          	pop al
0124+  0B7B 09          	ret
0125+  0B7C             
0126+  0B7C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  0B7C             ; PUTCHAR
0128+  0B7C             ; char in ah
0129+  0B7C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0B7C             putchar:
0131+  0B7C D7          	push a
0132+  0B7D 19 00       	mov al, 0
0133+  0B7F 05 03       	syscall sys_io			; char in AH
0134+  0B81 E4          	pop a
0135+  0B82 09          	ret
0136+  0B83             
0137+  0B83             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  0B83             ;; INPUT A STRING
0139+  0B83             ;; terminates with null
0140+  0B83             ;; pointer in D
0141+  0B83             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  0B83             gets:
0143+  0B83 D7          	push a
0144+  0B84 DA          	push d
0145+  0B85             gets_loop:
0146+  0B85 FD 0C       	sti
0147+  0B87 19 01       	mov al, 1
0148+  0B89 05 03       	syscall sys_io			; receive in AH
0149+  0B8B B9 00       	cmp al, 0				; check error code (AL)
0150+  0B8D C6 85 0B    	je gets_loop			; if no char received, retry
0151+  0B90             
0152+  0B90 76 1B       	cmp ah, 27
0153+  0B92 C6 B3 0B    	je gets_telnet_escape
0154+  0B95 76 0A       	cmp ah, $0A				; LF
0155+  0B97 C6 0C 0C    	je gets_end
0156+  0B9A 76 0D       	cmp ah, $0D				; CR
0157+  0B9C C6 0C 0C    	je gets_end
0158+  0B9F 76 5C       	cmp ah, $5C				; '\\'
0159+  0BA1 C6 E3 0B    	je gets_escape
0160+  0BA4             	
0161+  0BA4 76 08       	cmp ah, $08			; check for backspace
0162+  0BA6 C6 AF 0B    	je gets_backspace
0163+  0BA9             
0164+  0BA9 1A          	mov al, ah
0165+  0BAA 3E          	mov [d], al
0166+  0BAB 79          	inc d
0167+  0BAC 0A 85 0B    	jmp gets_loop
0168+  0BAF             gets_backspace:
0169+  0BAF 7F          	dec d
0170+  0BB0 0A 85 0B    	jmp gets_loop
0171+  0BB3             gets_telnet_escape:
0172+  0BB3 FD 0C       	sti
0173+  0BB5 19 01       	mov al, 1
0174+  0BB7 05 03       	syscall sys_io				; receive in AH without echo
0175+  0BB9 B9 00       	cmp al, 0					; check error code (AL)
0176+  0BBB C6 B3 0B    	je gets_telnet_escape		; if no char received, retry
0177+  0BBE 76 5B       	cmp ah, '['
0178+  0BC0 C7 85 0B    	jne gets_loop
0179+  0BC3             gets_telnet_escape_phase2:
0180+  0BC3 FD 0C       	sti
0181+  0BC5 19 01       	mov al, 1
0182+  0BC7 05 03       	syscall sys_io					; receive in AH without echo
0183+  0BC9 B9 00       	cmp al, 0						; check error code (AL)
0184+  0BCB C6 C3 0B    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  0BCE 76 44       	cmp ah, 'D'
0186+  0BD0 C6 DB 0B    	je gets_left_arrow
0187+  0BD3 76 43       	cmp ah, 'C'
0188+  0BD5 C6 DF 0B    	je gets_right_arrow
0189+  0BD8 0A 85 0B    	jmp gets_loop
0190+  0BDB             gets_left_arrow:
0191+  0BDB 7F          	dec d
0192+  0BDC 0A 85 0B    	jmp gets_loop
0193+  0BDF             gets_right_arrow:
0194+  0BDF 79          	inc d
0195+  0BE0 0A 85 0B    	jmp gets_loop
0196+  0BE3             gets_escape:
0197+  0BE3 FD 0C       	sti
0198+  0BE5 19 01       	mov al, 1
0199+  0BE7 05 03       	syscall sys_io			; receive in AH
0200+  0BE9 B9 00       	cmp al, 0				; check error code (AL)
0201+  0BEB C6 E3 0B    	je gets_escape			; if no char received, retry
0202+  0BEE 76 6E       	cmp ah, 'n'
0203+  0BF0 C6 FE 0B    	je gets_LF
0204+  0BF3 76 72       	cmp ah, 'r'
0205+  0BF5 C6 05 0C    	je gets_CR
0206+  0BF8 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  0BF9 3E          	mov [d], al
0208+  0BFA 79          	inc d
0209+  0BFB 0A 85 0B    	jmp gets_loop
0210+  0BFE             gets_LF:
0211+  0BFE 19 0A       	mov al, $0A
0212+  0C00 3E          	mov [d], al
0213+  0C01 79          	inc d
0214+  0C02 0A 85 0B    	jmp gets_loop
0215+  0C05             gets_CR:
0216+  0C05 19 0D       	mov al, $0D
0217+  0C07 3E          	mov [d], al
0218+  0C08 79          	inc d
0219+  0C09 0A 85 0B    	jmp gets_loop
0220+  0C0C             gets_end:
0221+  0C0C 19 00       	mov al, 0
0222+  0C0E 3E          	mov [d], al				; terminate string
0223+  0C0F E7          	pop d
0224+  0C10 E4          	pop a
0225+  0C11 09          	ret
0226+  0C12             
0227+  0C12             
0228+  0C12             
0229+  0C12             
0230+  0C12             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  0C12             ;; INPUT TEXT
0232+  0C12             ;; terminated with CTRL+D
0233+  0C12             ;; pointer in D
0234+  0C12             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  0C12             gettxt:
0236+  0C12 D7          	push a
0237+  0C13 DA          	push d
0238+  0C14             gettxt_loop:
0239+  0C14 19 01       	mov al, 1
0240+  0C16 05 03       	syscall sys_io			; receive in AH
0241+  0C18 B9 00       	cmp al, 0				; check error code (AL)
0242+  0C1A C6 14 0C    	je gettxt_loop		; if no char received, retry
0243+  0C1D 76 04       	cmp ah, 4			; EOT
0244+  0C1F C6 5D 0C    	je gettxt_end
0245+  0C22 76 08       	cmp ah, $08			; check for backspace
0246+  0C24 C6 59 0C    	je gettxt_backspace
0247+  0C27 76 5C       	cmp ah, $5C				; '\\'
0248+  0C29 C6 32 0C    	je gettxt_escape
0249+  0C2C 1A          	mov al, ah
0250+  0C2D 3E          	mov [d], al
0251+  0C2E 79          	inc d
0252+  0C2F 0A 14 0C    	jmp gettxt_loop
0253+  0C32             gettxt_escape:
0254+  0C32 19 01       	mov al, 1
0255+  0C34 05 03       	syscall sys_io			; receive in AH
0256+  0C36 B9 00       	cmp al, 0				; check error code (AL)
0257+  0C38 C6 32 0C    	je gettxt_escape		; if no char received, retry
0258+  0C3B 76 6E       	cmp ah, 'n'
0259+  0C3D C6 4B 0C    	je gettxt_LF
0260+  0C40 76 72       	cmp ah, 'r'
0261+  0C42 C6 52 0C    	je gettxt_CR
0262+  0C45 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  0C46 3E          	mov [d], al
0264+  0C47 79          	inc d
0265+  0C48 0A 14 0C    	jmp gettxt_loop
0266+  0C4B             gettxt_LF:
0267+  0C4B 19 0A       	mov al, $0A
0268+  0C4D 3E          	mov [d], al
0269+  0C4E 79          	inc d
0270+  0C4F 0A 14 0C    	jmp gettxt_loop
0271+  0C52             gettxt_CR:
0272+  0C52 19 0D       	mov al, $0D
0273+  0C54 3E          	mov [d], al
0274+  0C55 79          	inc d
0275+  0C56 0A 14 0C    	jmp gettxt_loop
0276+  0C59             gettxt_backspace:
0277+  0C59 7F          	dec d
0278+  0C5A 0A 14 0C    	jmp gettxt_loop
0279+  0C5D             gettxt_end:
0280+  0C5D 19 00       	mov al, 0
0281+  0C5F 3E          	mov [d], al				; terminate string
0282+  0C60 E7          	pop d
0283+  0C61 E4          	pop a
0284+  0C62 09          	ret
0285+  0C63             
0286+  0C63             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  0C63             ; PRINT NEW LINE
0288+  0C63             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  0C63             printnl:
0290+  0C63 D7          	push a
0291+  0C64 10 00 0A    	mov a, $0A00
0292+  0C67 05 03       	syscall sys_io
0293+  0C69 10 00 0D    	mov a, $0D00
0294+  0C6C 05 03       	syscall sys_io
0295+  0C6E E4          	pop a
0296+  0C6F 09          	ret
0297+  0C70             
0298+  0C70             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  0C70             ; strtoint
0300+  0C70             ; 4 digit hex string number in d
0301+  0C70             ; integer returned in A
0302+  0C70             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  0C70             strtointx:
0304+  0C70 D8          	push b
0305+  0C71 32          	mov bl, [d]
0306+  0C72 37          	mov bh, bl
0307+  0C73 33 01 00    	mov bl, [d + 1]
0308+  0C76 07 31 0B    	call atoi				; convert to int in AL
0309+  0C79 23          	mov ah, al				; move to AH
0310+  0C7A 33 02 00    	mov bl, [d + 2]
0311+  0C7D 37          	mov bh, bl
0312+  0C7E 33 03 00    	mov bl, [d + 3]
0313+  0C81 07 31 0B    	call atoi				; convert to int in AL
0314+  0C84 E5          	pop b
0315+  0C85 09          	ret
0316+  0C86             
0317+  0C86             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  0C86             ; strtoint
0319+  0C86             ; 5 digit base10 string number in d
0320+  0C86             ; integer returned in A
0321+  0C86             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  0C86             strtoint:
0323+  0C86 E2          	push si
0324+  0C87 D8          	push b
0325+  0C88 D9          	push c
0326+  0C89 DA          	push d
0327+  0C8A 07 B1 0A    	call strlen			; get string length in C
0328+  0C8D 7E          	dec c
0329+  0C8E FD 4E       	mov si, d
0330+  0C90 12          	mov a, c
0331+  0C91 FD 99       	shl a
0332+  0C93 3B 19 0B    	mov d, table_power
0333+  0C96 59          	add d, a
0334+  0C97 38 00 00    	mov c, 0
0335+  0C9A             strtoint_L0:
0336+  0C9A F6          	lodsb			; load ASCII to al
0337+  0C9B B9 00       	cmp al, 0
0338+  0C9D C6 B0 0C    	je strtoint_end
0339+  0CA0 6F 30       	sub al, $30		; make into integer
0340+  0CA2 22 00       	mov ah, 0
0341+  0CA4 2A          	mov b, [d]
0342+  0CA5 AC          	mul a, b			; result in B since it fits in 16bits
0343+  0CA6 11          	mov a, b
0344+  0CA7 28          	mov b, c
0345+  0CA8 54          	add a, b
0346+  0CA9 39          	mov c, a
0347+  0CAA 63 02 00    	sub d, 2
0348+  0CAD 0A 9A 0C    	jmp strtoint_L0
0349+  0CB0             strtoint_end:
0350+  0CB0 12          	mov a, c
0351+  0CB1 E7          	pop d
0352+  0CB2 E6          	pop c
0353+  0CB3 E5          	pop b
0354+  0CB4 EF          	pop si
0355+  0CB5 09          	ret
0356+  0CB6             
0357+  0CB6             
0358+  0CB6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  0CB6             ; PRINT NULL TERMINATED STRING
0360+  0CB6             ; pointer in D
0361+  0CB6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  0CB6             puts:
0363+  0CB6 D7          	push a
0364+  0CB7 DA          	push d
0365+  0CB8             puts_L1:
0366+  0CB8 1E          	mov al, [d]
0367+  0CB9 B9 00       	cmp al, 0
0368+  0CBB C6 C7 0C    	jz puts_END
0369+  0CBE 23          	mov ah, al
0370+  0CBF 19 00       	mov al, 0
0371+  0CC1 05 03       	syscall sys_io
0372+  0CC3 79          	inc d
0373+  0CC4 0A B8 0C    	jmp puts_L1
0374+  0CC7             puts_END:
0375+  0CC7 E7          	pop d
0376+  0CC8 E4          	pop a
0377+  0CC9 09          	ret
0378+  0CCA             
0379+  0CCA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  0CCA             ; PRINT N SIZE STRING
0381+  0CCA             ; pointer in D
0382+  0CCA             ; size in C
0383+  0CCA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  0CCA             putsn:
0385+  0CCA DB          	push al
0386+  0CCB DA          	push d
0387+  0CCC D9          	push c
0388+  0CCD             putsn_L0:
0389+  0CCD 1E          	mov al, [d]
0390+  0CCE 23          	mov ah, al
0391+  0CCF 19 00       	mov al, 0
0392+  0CD1 05 03       	syscall sys_io
0393+  0CD3 79          	inc d
0394+  0CD4 7E          	dec c	
0395+  0CD5 C2 00 00    	cmp c, 0
0396+  0CD8 C7 CD 0C    	jne putsn_L0
0397+  0CDB             putsn_end:
0398+  0CDB E6          	pop c
0399+  0CDC E7          	pop d
0400+  0CDD E8          	pop al
0401+  0CDE 09          	ret
0402+  0CDF             
0403+  0CDF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  0CDF             ; print 16bit decimal number
0405+  0CDF             ; input number in A
0406+  0CDF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  0CDF             print_u16d:
0408+  0CDF D7          	push a
0409+  0CE0 D8          	push b
0410+  0CE1 26 10 27    	mov b, 10000
0411+  0CE4 AE          	div a, b			; get 10000 coeff.
0412+  0CE5 07 0B 0D    	call print_number
0413+  0CE8 11          	mov a, b
0414+  0CE9 26 E8 03    	mov b, 1000
0415+  0CEC AE          	div a, b			; get 10000 coeff.
0416+  0CED 07 0B 0D    	call print_number
0417+  0CF0 11          	mov a, b
0418+  0CF1 26 64 00    	mov b, 100
0419+  0CF4 AE          	div a, b
0420+  0CF5 07 0B 0D    	call print_number
0421+  0CF8 11          	mov a, b
0422+  0CF9 26 0A 00    	mov b, 10
0423+  0CFC AE          	div a, b
0424+  0CFD 07 0B 0D    	call print_number
0425+  0D00 11          	mov a, b
0426+  0D01 6A 30       	add al, $30
0427+  0D03 23          	mov ah, al
0428+  0D04 19 00       	mov al, 0
0429+  0D06 05 03       	syscall sys_io	; print coeff
0430+  0D08 E5          	pop b
0431+  0D09 E4          	pop a
0432+  0D0A 09          	ret
0433+  0D0B             
0434+  0D0B             
0435+  0D0B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  0D0B             ; if A == 0, print space
0437+  0D0B             ; else print A
0438+  0D0B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0439+  0D0B             print_number:
0440+  0D0B 6A 30       	add al, $30
0441+  0D0D 23          	mov ah, al
0442+  0D0E 07 7C 0B    	call putchar
0443+  0D11 09          	ret
0444+  0D12             
0445+  0D12             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0446+  0D12             ; PRINT 16BIT HEX INTEGER
0447+  0D12             ; integer value in reg B
0448+  0D12             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  0D12             print_u16x:
0450+  0D12 D7          	push a
0451+  0D13 D8          	push b
0452+  0D14 DD          	push bl
0453+  0D15 30          	mov bl, bh
0454+  0D16 07 43 0B    	call itoa				; convert bh to char in A
0455+  0D19 2F          	mov bl, al				; save al
0456+  0D1A 19 00       	mov al, 0
0457+  0D1C 05 03       	syscall sys_io				; display AH
0458+  0D1E 24          	mov ah, bl				; retrieve al
0459+  0D1F 19 00       	mov al, 0
0460+  0D21 05 03       	syscall sys_io				; display AL
0461+  0D23             
0462+  0D23 EA          	pop bl
0463+  0D24 07 43 0B    	call itoa				; convert bh to char in A
0464+  0D27 2F          	mov bl, al				; save al
0465+  0D28 19 00       	mov al, 0
0466+  0D2A 05 03       	syscall sys_io				; display AH
0467+  0D2C 24          	mov ah, bl				; retrieve al
0468+  0D2D 19 00       	mov al, 0
0469+  0D2F 05 03       	syscall sys_io				; display AL
0470+  0D31             
0471+  0D31 E5          	pop b
0472+  0D32 E4          	pop a
0473+  0D33 09          	ret
0474+  0D34             
0475+  0D34             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  0D34             ; INPUT 16BIT HEX INTEGER
0477+  0D34             ; read 16bit integer into A
0478+  0D34             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  0D34             scan_u16x:
0480+  0D34 F8 10 00    	enter 16
0481+  0D37 D8          	push b
0482+  0D38 DA          	push d
0483+  0D39             
0484+  0D39 FA F1 FF    	lea d, [bp + -15]
0485+  0D3C 07 83 0B    	call gets				; get number
0486+  0D3F             
0487+  0D3F 32          	mov bl, [d]
0488+  0D40 37          	mov bh, bl
0489+  0D41 33 01 00    	mov bl, [d + 1]
0490+  0D44 07 31 0B    	call atoi				; convert to int in AL
0491+  0D47 23          	mov ah, al				; move to AH
0492+  0D48             
0493+  0D48 33 02 00    	mov bl, [d + 2]
0494+  0D4B 37          	mov bh, bl
0495+  0D4C 33 03 00    	mov bl, [d + 3]
0496+  0D4F 07 31 0B    	call atoi				; convert to int in AL
0497+  0D52             
0498+  0D52 E7          	pop d
0499+  0D53 E5          	pop b
0500+  0D54 F9          	leave
0501+  0D55 09          	ret
0502+  0D56             
0503+  0D56             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0504+  0D56             ; PRINT 8bit HEX INTEGER
0505+  0D56             ; integer value in reg bl
0506+  0D56             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  0D56             print_u8x:
0508+  0D56 D7          	push a
0509+  0D57 DD          	push bl
0510+  0D58             
0511+  0D58 07 43 0B    	call itoa				; convert bl to char in A
0512+  0D5B 2F          	mov bl, al				; save al
0513+  0D5C 19 00       	mov al, 0
0514+  0D5E 05 03       	syscall sys_io				; display AH
0515+  0D60 24          	mov ah, bl				; retrieve al
0516+  0D61 19 00       	mov al, 0
0517+  0D63 05 03       	syscall sys_io				; display AL
0518+  0D65             
0519+  0D65 EA          	pop bl
0520+  0D66 E4          	pop a
0521+  0D67 09          	ret
0522+  0D68             
0523+  0D68             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0524+  0D68             ; print 8bit decimal unsigned number
0525+  0D68             ; input number in AL
0526+  0D68             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  0D68             print_u8d:
0528+  0D68 D7          	push a
0529+  0D69 D8          	push b
0530+  0D6A             
0531+  0D6A 22 00       	mov ah, 0
0532+  0D6C 26 64 00    	mov b, 100
0533+  0D6F AE          	div a, b
0534+  0D70 D8          	push b			; save remainder
0535+  0D71 B9 00       	cmp al, 0
0536+  0D73 C6 7D 0D    	je skip100
0537+  0D76 6A 30       	add al, $30
0538+  0D78 23          	mov ah, al
0539+  0D79 19 00       	mov al, 0
0540+  0D7B 05 03       	syscall sys_io	; print coeff
0541+  0D7D             skip100:
0542+  0D7D E4          	pop a
0543+  0D7E 22 00       	mov ah, 0
0544+  0D80 26 0A 00    	mov b, 10
0545+  0D83 AE          	div a, b
0546+  0D84 D8          	push b			; save remainder
0547+  0D85 B9 00       	cmp al, 0
0548+  0D87 C6 91 0D    	je skip10
0549+  0D8A 6A 30       	add al, $30
0550+  0D8C 23          	mov ah, al
0551+  0D8D 19 00       	mov al, 0
0552+  0D8F 05 03       	syscall sys_io	; print coeff
0553+  0D91             skip10:
0554+  0D91 E4          	pop a
0555+  0D92 1B          	mov al, bl
0556+  0D93 6A 30       	add al, $30
0557+  0D95 23          	mov ah, al
0558+  0D96 19 00       	mov al, 0
0559+  0D98 05 03       	syscall sys_io	; print coeff
0560+  0D9A E5          	pop b
0561+  0D9B E4          	pop a
0562+  0D9C 09          	ret
0563+  0D9D             
0564+  0D9D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0565+  0D9D             ; INPUT 8BIT HEX INTEGER
0566+  0D9D             ; read 8bit integer into AL
0567+  0D9D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  0D9D             scan_u8x:
0569+  0D9D F8 04 00    	enter 4
0570+  0DA0 D8          	push b
0571+  0DA1 DA          	push d
0572+  0DA2             
0573+  0DA2 FA FD FF    	lea d, [bp + -3]
0574+  0DA5 07 83 0B    	call gets				; get number
0575+  0DA8             
0576+  0DA8 32          	mov bl, [d]
0577+  0DA9 37          	mov bh, bl
0578+  0DAA 33 01 00    	mov bl, [d + 1]
0579+  0DAD 07 31 0B    	call atoi				; convert to int in AL
0580+  0DB0             
0581+  0DB0 E7          	pop d
0582+  0DB1 E5          	pop b
0583+  0DB2 F9          	leave
0584+  0DB3 09          	ret
0585+  0DB4             
0586+  0DB4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  0DB4             ; input decimal number
0588+  0DB4             ; result in A
0589+  0DB4             ; 655'\0'
0590+  0DB4             ; low--------high
0591+  0DB4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0592+  0DB4             scan_u16d:
0593+  0DB4 F8 08 00    	enter 8
0594+  0DB7 E2          	push si
0595+  0DB8 D8          	push b
0596+  0DB9 D9          	push c
0597+  0DBA DA          	push d
0598+  0DBB FA F9 FF    	lea d, [bp +- 7]
0599+  0DBE 07 83 0B    	call gets
0600+  0DC1 07 B1 0A    	call strlen			; get string length in C
0601+  0DC4 7E          	dec c
0602+  0DC5 FD 4E       	mov si, d
0603+  0DC7 12          	mov a, c
0604+  0DC8 FD 99       	shl a
0605+  0DCA 3B 19 0B    	mov d, table_power
0606+  0DCD 59          	add d, a
0607+  0DCE 38 00 00    	mov c, 0
0608+  0DD1             mul_loop:
0609+  0DD1 F6          	lodsb			; load ASCII to al
0610+  0DD2 B9 00       	cmp al, 0
0611+  0DD4 C6 E7 0D    	je mul_exit
0612+  0DD7 6F 30       	sub al, $30		; make into integer
0613+  0DD9 22 00       	mov ah, 0
0614+  0DDB 2A          	mov b, [d]
0615+  0DDC AC          	mul a, b			; result in B since it fits in 16bits
0616+  0DDD 11          	mov a, b
0617+  0DDE 28          	mov b, c
0618+  0DDF 54          	add a, b
0619+  0DE0 39          	mov c, a
0620+  0DE1 63 02 00    	sub d, 2
0621+  0DE4 0A D1 0D    	jmp mul_loop
0622+  0DE7             mul_exit:
0623+  0DE7 12          	mov a, c
0624+  0DE8 E7          	pop d
0625+  0DE9 E6          	pop c
0626+  0DEA E5          	pop b
0627+  0DEB EF          	pop si
0628+  0DEC F9          	leave
0629+  0DED 09          	ret
0807   0DEE             ; --- END INCLUDE BLOCK
0808   0DEE             
0809   0DEE             
0810   0DEE             .end
tasm: Number of errors = 0
