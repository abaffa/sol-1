0001   0000             ; --- FILENAME: test.c
0002   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0400             .org PROC_TEXT_ORG
0004   0400             
0005   0400             ; --- BEGIN TEXT BLOCK
0006   0400             
0007   0400             main:
0008   0400 D2            push bp
0009   0401 9B            mov bp, sp
0010   0402 52 02 00      sub sp, 2 ; i
0011   0405 52 02 00      sub sp, 2 ; j
0012   0408 52 02 00      sub sp, 2 ; k
0013   040B 26 49 0B      mov b, __string_0 ; "Matrix1:\n"
0014   040E FD AB         swp b
0015   0410 D8            push b
0016   0411 07 D8 0A      call print
0017   0414 51 02 00      add sp, 2
0018   0417             _for1_init:
0019   0417 26 00 00      mov b, 0
0020   041A D7            push a
0021   041B 11            mov a, b
0022   041C 45 FF FF      mov [bp + -1], a ; i
0023   041F E4            pop a
0024   0420             _for1_cond:
0025   0420 2C FF FF      mov b, [bp + -1] ; i
0026   0423 D7            push a
0027   0424 11            mov a, b
0028   0425 26 03 00      mov b, 3
0029   0428 B0            cmp a, b
0030   0429 0E            lodflgs
0031   042A 87 02         and al, %00000010 ; <
0032   042C FD 9C         shr al
0033   042E 22 00         mov ah, 0
0034   0430 27            mov b, a
0035   0431 E4            pop a
0036   0432 C0 00 00      cmp b, 0
0037   0435 C6 B3 04      je _for1_exit
0038   0438             _for1_block:
0039   0438             _for2_init:
0040   0438 26 00 00      mov b, 0
0041   043B D7            push a
0042   043C 11            mov a, b
0043   043D 45 FD FF      mov [bp + -3], a ; j
0044   0440 E4            pop a
0045   0441             _for2_cond:
0046   0441 2C FD FF      mov b, [bp + -3] ; j
0047   0444 D7            push a
0048   0445 11            mov a, b
0049   0446 26 03 00      mov b, 3
0050   0449 B0            cmp a, b
0051   044A 0E            lodflgs
0052   044B 87 02         and al, %00000010 ; <
0053   044D FD 9C         shr al
0054   044F 22 00         mov ah, 0
0055   0451 27            mov b, a
0056   0452 E4            pop a
0057   0453 C0 00 00      cmp b, 0
0058   0456 C6 95 04      je _for2_exit
0059   0459             _for2_block:
0060   0459 26 53 0B      mov b, __string_1 ; " "
0061   045C FD AB         swp b
0062   045E D8            push b
0063   045F 29 F7 0A      mov b, [__matrix1]
0064   0462 D7            push a
0065   0463 74            mov d, b
0066   0464 DA            push d
0067   0465 2C FF FF      mov b, [bp + -1] ; i
0068   0468 E7            pop d
0069   0469 10 06 00      mov a, 6
0070   046C AC            mul a, b
0071   046D 5A            add d, b
0072   046E DA            push d
0073   046F 2C FD FF      mov b, [bp + -3] ; j
0074   0472 E7            pop d
0075   0473 10 02 00      mov a, 2
0076   0476 AC            mul a, b
0077   0477 5A            add d, b
0078   0478 E4            pop a
0079   0479 2A            mov b, [d]
0080   047A FD AB         swp b
0081   047C D8            push b
0082   047D 07 C1 0A      call printn
0083   0480 51 04 00      add sp, 4
0084   0483             _for2_update:
0085   0483 2C FD FF      mov b, [bp + -3] ; j
0086   0486 D7            push a
0087   0487 11            mov a, b
0088   0488 FD 77         inc b
0089   048A D7            push a
0090   048B 11            mov a, b
0091   048C 45 FD FF      mov [bp + -3], a ; j
0092   048F E4            pop a
0093   0490 27            mov b, a
0094   0491 E4            pop a
0095   0492 0A 41 04      jmp _for2_cond
0096   0495             _for2_exit:
0097   0495 26 55 0B      mov b, __string_2 ; "\n"
0098   0498 FD AB         swp b
0099   049A D8            push b
0100   049B 07 D8 0A      call print
0101   049E 51 02 00      add sp, 2
0102   04A1             _for1_update:
0103   04A1 2C FF FF      mov b, [bp + -1] ; i
0104   04A4 D7            push a
0105   04A5 11            mov a, b
0106   04A6 FD 77         inc b
0107   04A8 D7            push a
0108   04A9 11            mov a, b
0109   04AA 45 FF FF      mov [bp + -1], a ; i
0110   04AD E4            pop a
0111   04AE 27            mov b, a
0112   04AF E4            pop a
0113   04B0 0A 20 04      jmp _for1_cond
0114   04B3             _for1_exit:
0115   04B3 26 55 0B      mov b, __string_2 ; "\n"
0116   04B6 FD AB         swp b
0117   04B8 D8            push b
0118   04B9 07 D8 0A      call print
0119   04BC 51 02 00      add sp, 2
0120   04BF 26 57 0B      mov b, __string_3 ; "Matrix2:\n"
0121   04C2 FD AB         swp b
0122   04C4 D8            push b
0123   04C5 07 D8 0A      call print
0124   04C8 51 02 00      add sp, 2
0125   04CB             _for3_init:
0126   04CB 26 00 00      mov b, 0
0127   04CE D7            push a
0128   04CF 11            mov a, b
0129   04D0 45 FF FF      mov [bp + -1], a ; i
0130   04D3 E4            pop a
0131   04D4             _for3_cond:
0132   04D4 2C FF FF      mov b, [bp + -1] ; i
0133   04D7 D7            push a
0134   04D8 11            mov a, b
0135   04D9 26 03 00      mov b, 3
0136   04DC B0            cmp a, b
0137   04DD 0E            lodflgs
0138   04DE 87 02         and al, %00000010 ; <
0139   04E0 FD 9C         shr al
0140   04E2 22 00         mov ah, 0
0141   04E4 27            mov b, a
0142   04E5 E4            pop a
0143   04E6 C0 00 00      cmp b, 0
0144   04E9 C6 67 05      je _for3_exit
0145   04EC             _for3_block:
0146   04EC             _for4_init:
0147   04EC 26 00 00      mov b, 0
0148   04EF D7            push a
0149   04F0 11            mov a, b
0150   04F1 45 FD FF      mov [bp + -3], a ; j
0151   04F4 E4            pop a
0152   04F5             _for4_cond:
0153   04F5 2C FD FF      mov b, [bp + -3] ; j
0154   04F8 D7            push a
0155   04F9 11            mov a, b
0156   04FA 26 03 00      mov b, 3
0157   04FD B0            cmp a, b
0158   04FE 0E            lodflgs
0159   04FF 87 02         and al, %00000010 ; <
0160   0501 FD 9C         shr al
0161   0503 22 00         mov ah, 0
0162   0505 27            mov b, a
0163   0506 E4            pop a
0164   0507 C0 00 00      cmp b, 0
0165   050A C6 49 05      je _for4_exit
0166   050D             _for4_block:
0167   050D 26 53 0B      mov b, __string_1 ; " "
0168   0510 FD AB         swp b
0169   0512 D8            push b
0170   0513 29 0B 0B      mov b, [__matrix2]
0171   0516 D7            push a
0172   0517 74            mov d, b
0173   0518 DA            push d
0174   0519 2C FF FF      mov b, [bp + -1] ; i
0175   051C E7            pop d
0176   051D 10 06 00      mov a, 6
0177   0520 AC            mul a, b
0178   0521 5A            add d, b
0179   0522 DA            push d
0180   0523 2C FD FF      mov b, [bp + -3] ; j
0181   0526 E7            pop d
0182   0527 10 02 00      mov a, 2
0183   052A AC            mul a, b
0184   052B 5A            add d, b
0185   052C E4            pop a
0186   052D 2A            mov b, [d]
0187   052E FD AB         swp b
0188   0530 D8            push b
0189   0531 07 C1 0A      call printn
0190   0534 51 04 00      add sp, 4
0191   0537             _for4_update:
0192   0537 2C FD FF      mov b, [bp + -3] ; j
0193   053A D7            push a
0194   053B 11            mov a, b
0195   053C FD 77         inc b
0196   053E D7            push a
0197   053F 11            mov a, b
0198   0540 45 FD FF      mov [bp + -3], a ; j
0199   0543 E4            pop a
0200   0544 27            mov b, a
0201   0545 E4            pop a
0202   0546 0A F5 04      jmp _for4_cond
0203   0549             _for4_exit:
0204   0549 26 55 0B      mov b, __string_2 ; "\n"
0205   054C FD AB         swp b
0206   054E D8            push b
0207   054F 07 D8 0A      call print
0208   0552 51 02 00      add sp, 2
0209   0555             _for3_update:
0210   0555 2C FF FF      mov b, [bp + -1] ; i
0211   0558 D7            push a
0212   0559 11            mov a, b
0213   055A FD 77         inc b
0214   055C D7            push a
0215   055D 11            mov a, b
0216   055E 45 FF FF      mov [bp + -1], a ; i
0217   0561 E4            pop a
0218   0562 27            mov b, a
0219   0563 E4            pop a
0220   0564 0A D4 04      jmp _for3_cond
0221   0567             _for3_exit:
0222   0567 26 55 0B      mov b, __string_2 ; "\n"
0223   056A FD AB         swp b
0224   056C D8            push b
0225   056D 07 D8 0A      call print
0226   0570 51 02 00      add sp, 2
0227   0573             _for5_init:
0228   0573 26 00 00      mov b, 0
0229   0576 D7            push a
0230   0577 11            mov a, b
0231   0578 45 FF FF      mov [bp + -1], a ; i
0232   057B E4            pop a
0233   057C             _for5_cond:
0234   057C 2C FF FF      mov b, [bp + -1] ; i
0235   057F D7            push a
0236   0580 11            mov a, b
0237   0581 26 03 00      mov b, 3
0238   0584 B0            cmp a, b
0239   0585 0E            lodflgs
0240   0586 87 02         and al, %00000010 ; <
0241   0588 FD 9C         shr al
0242   058A 22 00         mov ah, 0
0243   058C 27            mov b, a
0244   058D E4            pop a
0245   058E C0 00 00      cmp b, 0
0246   0591 C6 A5 06      je _for5_exit
0247   0594             _for5_block:
0248   0594             _for6_init:
0249   0594 26 00 00      mov b, 0
0250   0597 D7            push a
0251   0598 11            mov a, b
0252   0599 45 FD FF      mov [bp + -3], a ; j
0253   059C E4            pop a
0254   059D             _for6_cond:
0255   059D 2C FD FF      mov b, [bp + -3] ; j
0256   05A0 D7            push a
0257   05A1 11            mov a, b
0258   05A2 26 03 00      mov b, 3
0259   05A5 B0            cmp a, b
0260   05A6 0E            lodflgs
0261   05A7 87 02         and al, %00000010 ; <
0262   05A9 FD 9C         shr al
0263   05AB 22 00         mov ah, 0
0264   05AD 27            mov b, a
0265   05AE E4            pop a
0266   05AF C0 00 00      cmp b, 0
0267   05B2 C6 93 06      je _for6_exit
0268   05B5             _for6_block:
0269   05B5 29 1F 0B      mov b, [__result1]
0270   05B8 D7            push a
0271   05B9 74            mov d, b
0272   05BA DA            push d
0273   05BB 2C FF FF      mov b, [bp + -1] ; i
0274   05BE E7            pop d
0275   05BF 10 06 00      mov a, 6
0276   05C2 AC            mul a, b
0277   05C3 5A            add d, b
0278   05C4 DA            push d
0279   05C5 2C FD FF      mov b, [bp + -3] ; j
0280   05C8 E7            pop d
0281   05C9 10 02 00      mov a, 2
0282   05CC AC            mul a, b
0283   05CD 5A            add d, b
0284   05CE E4            pop a
0285   05CF DA            push d
0286   05D0 26 00 00      mov b, 0
0287   05D3 E7            pop d
0288   05D4 FD 43         mov [d], b
0289   05D6             _for7_init:
0290   05D6 26 00 00      mov b, 0
0291   05D9 D7            push a
0292   05DA 11            mov a, b
0293   05DB 45 FB FF      mov [bp + -5], a ; k
0294   05DE E4            pop a
0295   05DF             _for7_cond:
0296   05DF 2C FB FF      mov b, [bp + -5] ; k
0297   05E2 D7            push a
0298   05E3 11            mov a, b
0299   05E4 26 03 00      mov b, 3
0300   05E7 B0            cmp a, b
0301   05E8 0E            lodflgs
0302   05E9 87 02         and al, %00000010 ; <
0303   05EB FD 9C         shr al
0304   05ED 22 00         mov ah, 0
0305   05EF 27            mov b, a
0306   05F0 E4            pop a
0307   05F1 C0 00 00      cmp b, 0
0308   05F4 C6 81 06      je _for7_exit
0309   05F7             _for7_block:
0310   05F7 29 1F 0B      mov b, [__result1]
0311   05FA D7            push a
0312   05FB 74            mov d, b
0313   05FC DA            push d
0314   05FD 2C FF FF      mov b, [bp + -1] ; i
0315   0600 E7            pop d
0316   0601 10 06 00      mov a, 6
0317   0604 AC            mul a, b
0318   0605 5A            add d, b
0319   0606 DA            push d
0320   0607 2C FD FF      mov b, [bp + -3] ; j
0321   060A E7            pop d
0322   060B 10 02 00      mov a, 2
0323   060E AC            mul a, b
0324   060F 5A            add d, b
0325   0610 E4            pop a
0326   0611 DA            push d
0327   0612 29 1F 0B      mov b, [__result1]
0328   0615 D7            push a
0329   0616 74            mov d, b
0330   0617 DA            push d
0331   0618 2C FF FF      mov b, [bp + -1] ; i
0332   061B E7            pop d
0333   061C 10 06 00      mov a, 6
0334   061F AC            mul a, b
0335   0620 5A            add d, b
0336   0621 DA            push d
0337   0622 2C FD FF      mov b, [bp + -3] ; j
0338   0625 E7            pop d
0339   0626 10 02 00      mov a, 2
0340   0629 AC            mul a, b
0341   062A 5A            add d, b
0342   062B E4            pop a
0343   062C 2A            mov b, [d]
0344   062D D7            push a
0345   062E 11            mov a, b
0346   062F 29 F7 0A      mov b, [__matrix1]
0347   0632 D7            push a
0348   0633 74            mov d, b
0349   0634 DA            push d
0350   0635 2C FF FF      mov b, [bp + -1] ; i
0351   0638 E7            pop d
0352   0639 10 06 00      mov a, 6
0353   063C AC            mul a, b
0354   063D 5A            add d, b
0355   063E DA            push d
0356   063F 2C FB FF      mov b, [bp + -5] ; k
0357   0642 E7            pop d
0358   0643 10 02 00      mov a, 2
0359   0646 AC            mul a, b
0360   0647 5A            add d, b
0361   0648 E4            pop a
0362   0649 2A            mov b, [d]
0363   064A D7            push a
0364   064B 11            mov a, b
0365   064C 29 0B 0B      mov b, [__matrix2]
0366   064F D7            push a
0367   0650 74            mov d, b
0368   0651 DA            push d
0369   0652 2C FB FF      mov b, [bp + -5] ; k
0370   0655 E7            pop d
0371   0656 10 06 00      mov a, 6
0372   0659 AC            mul a, b
0373   065A 5A            add d, b
0374   065B DA            push d
0375   065C 2C FD FF      mov b, [bp + -3] ; j
0376   065F E7            pop d
0377   0660 10 02 00      mov a, 2
0378   0663 AC            mul a, b
0379   0664 5A            add d, b
0380   0665 E4            pop a
0381   0666 2A            mov b, [d]
0382   0667 AC            mul a, b
0383   0668 E4            pop a
0384   0669 54            add a, b
0385   066A 27            mov b, a
0386   066B E4            pop a
0387   066C E7            pop d
0388   066D FD 43         mov [d], b
0389   066F             _for7_update:
0390   066F 2C FB FF      mov b, [bp + -5] ; k
0391   0672 D7            push a
0392   0673 11            mov a, b
0393   0674 FD 77         inc b
0394   0676 D7            push a
0395   0677 11            mov a, b
0396   0678 45 FB FF      mov [bp + -5], a ; k
0397   067B E4            pop a
0398   067C 27            mov b, a
0399   067D E4            pop a
0400   067E 0A DF 05      jmp _for7_cond
0401   0681             _for7_exit:
0402   0681             _for6_update:
0403   0681 2C FD FF      mov b, [bp + -3] ; j
0404   0684 D7            push a
0405   0685 11            mov a, b
0406   0686 FD 77         inc b
0407   0688 D7            push a
0408   0689 11            mov a, b
0409   068A 45 FD FF      mov [bp + -3], a ; j
0410   068D E4            pop a
0411   068E 27            mov b, a
0412   068F E4            pop a
0413   0690 0A 9D 05      jmp _for6_cond
0414   0693             _for6_exit:
0415   0693             _for5_update:
0416   0693 2C FF FF      mov b, [bp + -1] ; i
0417   0696 D7            push a
0418   0697 11            mov a, b
0419   0698 FD 77         inc b
0420   069A D7            push a
0421   069B 11            mov a, b
0422   069C 45 FF FF      mov [bp + -1], a ; i
0423   069F E4            pop a
0424   06A0 27            mov b, a
0425   06A1 E4            pop a
0426   06A2 0A 7C 05      jmp _for5_cond
0427   06A5             _for5_exit:
0428   06A5             _for8_init:
0429   06A5 26 00 00      mov b, 0
0430   06A8 D7            push a
0431   06A9 11            mov a, b
0432   06AA 45 FF FF      mov [bp + -1], a ; i
0433   06AD E4            pop a
0434   06AE             _for8_cond:
0435   06AE 2C FF FF      mov b, [bp + -1] ; i
0436   06B1 D7            push a
0437   06B2 11            mov a, b
0438   06B3 26 03 00      mov b, 3
0439   06B6 B0            cmp a, b
0440   06B7 0E            lodflgs
0441   06B8 87 02         and al, %00000010 ; <
0442   06BA FD 9C         shr al
0443   06BC 22 00         mov ah, 0
0444   06BE 27            mov b, a
0445   06BF E4            pop a
0446   06C0 C0 00 00      cmp b, 0
0447   06C3 C6 64 07      je _for8_exit
0448   06C6             _for8_block:
0449   06C6             _for9_init:
0450   06C6 26 00 00      mov b, 0
0451   06C9 D7            push a
0452   06CA 11            mov a, b
0453   06CB 45 FD FF      mov [bp + -3], a ; j
0454   06CE E4            pop a
0455   06CF             _for9_cond:
0456   06CF 2C FD FF      mov b, [bp + -3] ; j
0457   06D2 D7            push a
0458   06D3 11            mov a, b
0459   06D4 26 03 00      mov b, 3
0460   06D7 B0            cmp a, b
0461   06D8 0E            lodflgs
0462   06D9 87 02         and al, %00000010 ; <
0463   06DB FD 9C         shr al
0464   06DD 22 00         mov ah, 0
0465   06DF 27            mov b, a
0466   06E0 E4            pop a
0467   06E1 C0 00 00      cmp b, 0
0468   06E4 C6 52 07      je _for9_exit
0469   06E7             _for9_block:
0470   06E7 29 33 0B      mov b, [__result2]
0471   06EA D7            push a
0472   06EB 74            mov d, b
0473   06EC DA            push d
0474   06ED 2C FF FF      mov b, [bp + -1] ; i
0475   06F0 E7            pop d
0476   06F1 10 06 00      mov a, 6
0477   06F4 AC            mul a, b
0478   06F5 5A            add d, b
0479   06F6 DA            push d
0480   06F7 2C FD FF      mov b, [bp + -3] ; j
0481   06FA E7            pop d
0482   06FB 10 02 00      mov a, 2
0483   06FE AC            mul a, b
0484   06FF 5A            add d, b
0485   0700 E4            pop a
0486   0701 DA            push d
0487   0702 29 F7 0A      mov b, [__matrix1]
0488   0705 D7            push a
0489   0706 74            mov d, b
0490   0707 DA            push d
0491   0708 2C FF FF      mov b, [bp + -1] ; i
0492   070B E7            pop d
0493   070C 10 06 00      mov a, 6
0494   070F AC            mul a, b
0495   0710 5A            add d, b
0496   0711 DA            push d
0497   0712 2C FD FF      mov b, [bp + -3] ; j
0498   0715 E7            pop d
0499   0716 10 02 00      mov a, 2
0500   0719 AC            mul a, b
0501   071A 5A            add d, b
0502   071B E4            pop a
0503   071C 2A            mov b, [d]
0504   071D D7            push a
0505   071E 11            mov a, b
0506   071F 29 0B 0B      mov b, [__matrix2]
0507   0722 D7            push a
0508   0723 74            mov d, b
0509   0724 DA            push d
0510   0725 2C FF FF      mov b, [bp + -1] ; i
0511   0728 E7            pop d
0512   0729 10 06 00      mov a, 6
0513   072C AC            mul a, b
0514   072D 5A            add d, b
0515   072E DA            push d
0516   072F 2C FD FF      mov b, [bp + -3] ; j
0517   0732 E7            pop d
0518   0733 10 02 00      mov a, 2
0519   0736 AC            mul a, b
0520   0737 5A            add d, b
0521   0738 E4            pop a
0522   0739 2A            mov b, [d]
0523   073A 54            add a, b
0524   073B 27            mov b, a
0525   073C E4            pop a
0526   073D E7            pop d
0527   073E FD 43         mov [d], b
0528   0740             _for9_update:
0529   0740 2C FD FF      mov b, [bp + -3] ; j
0530   0743 D7            push a
0531   0744 11            mov a, b
0532   0745 FD 77         inc b
0533   0747 D7            push a
0534   0748 11            mov a, b
0535   0749 45 FD FF      mov [bp + -3], a ; j
0536   074C E4            pop a
0537   074D 27            mov b, a
0538   074E E4            pop a
0539   074F 0A CF 06      jmp _for9_cond
0540   0752             _for9_exit:
0541   0752             _for8_update:
0542   0752 2C FF FF      mov b, [bp + -1] ; i
0543   0755 D7            push a
0544   0756 11            mov a, b
0545   0757 FD 77         inc b
0546   0759 D7            push a
0547   075A 11            mov a, b
0548   075B 45 FF FF      mov [bp + -1], a ; i
0549   075E E4            pop a
0550   075F 27            mov b, a
0551   0760 E4            pop a
0552   0761 0A AE 06      jmp _for8_cond
0553   0764             _for8_exit:
0554   0764             _for10_init:
0555   0764 26 00 00      mov b, 0
0556   0767 D7            push a
0557   0768 11            mov a, b
0558   0769 45 FF FF      mov [bp + -1], a ; i
0559   076C E4            pop a
0560   076D             _for10_cond:
0561   076D 2C FF FF      mov b, [bp + -1] ; i
0562   0770 D7            push a
0563   0771 11            mov a, b
0564   0772 26 03 00      mov b, 3
0565   0775 B0            cmp a, b
0566   0776 0E            lodflgs
0567   0777 87 02         and al, %00000010 ; <
0568   0779 FD 9C         shr al
0569   077B 22 00         mov ah, 0
0570   077D 27            mov b, a
0571   077E E4            pop a
0572   077F C0 00 00      cmp b, 0
0573   0782 C6 23 08      je _for10_exit
0574   0785             _for10_block:
0575   0785             _for11_init:
0576   0785 26 00 00      mov b, 0
0577   0788 D7            push a
0578   0789 11            mov a, b
0579   078A 45 FD FF      mov [bp + -3], a ; j
0580   078D E4            pop a
0581   078E             _for11_cond:
0582   078E 2C FD FF      mov b, [bp + -3] ; j
0583   0791 D7            push a
0584   0792 11            mov a, b
0585   0793 26 03 00      mov b, 3
0586   0796 B0            cmp a, b
0587   0797 0E            lodflgs
0588   0798 87 02         and al, %00000010 ; <
0589   079A FD 9C         shr al
0590   079C 22 00         mov ah, 0
0591   079E 27            mov b, a
0592   079F E4            pop a
0593   07A0 C0 00 00      cmp b, 0
0594   07A3 C6 11 08      je _for11_exit
0595   07A6             _for11_block:
0596   07A6 29 47 0B      mov b, [__result3]
0597   07A9 D7            push a
0598   07AA 74            mov d, b
0599   07AB DA            push d
0600   07AC 2C FF FF      mov b, [bp + -1] ; i
0601   07AF E7            pop d
0602   07B0 10 06 00      mov a, 6
0603   07B3 AC            mul a, b
0604   07B4 5A            add d, b
0605   07B5 DA            push d
0606   07B6 2C FD FF      mov b, [bp + -3] ; j
0607   07B9 E7            pop d
0608   07BA 10 02 00      mov a, 2
0609   07BD AC            mul a, b
0610   07BE 5A            add d, b
0611   07BF E4            pop a
0612   07C0 DA            push d
0613   07C1 29 0B 0B      mov b, [__matrix2]
0614   07C4 D7            push a
0615   07C5 74            mov d, b
0616   07C6 DA            push d
0617   07C7 2C FF FF      mov b, [bp + -1] ; i
0618   07CA E7            pop d
0619   07CB 10 06 00      mov a, 6
0620   07CE AC            mul a, b
0621   07CF 5A            add d, b
0622   07D0 DA            push d
0623   07D1 2C FD FF      mov b, [bp + -3] ; j
0624   07D4 E7            pop d
0625   07D5 10 02 00      mov a, 2
0626   07D8 AC            mul a, b
0627   07D9 5A            add d, b
0628   07DA E4            pop a
0629   07DB 2A            mov b, [d]
0630   07DC D7            push a
0631   07DD 11            mov a, b
0632   07DE 29 F7 0A      mov b, [__matrix1]
0633   07E1 D7            push a
0634   07E2 74            mov d, b
0635   07E3 DA            push d
0636   07E4 2C FF FF      mov b, [bp + -1] ; i
0637   07E7 E7            pop d
0638   07E8 10 06 00      mov a, 6
0639   07EB AC            mul a, b
0640   07EC 5A            add d, b
0641   07ED DA            push d
0642   07EE 2C FD FF      mov b, [bp + -3] ; j
0643   07F1 E7            pop d
0644   07F2 10 02 00      mov a, 2
0645   07F5 AC            mul a, b
0646   07F6 5A            add d, b
0647   07F7 E4            pop a
0648   07F8 2A            mov b, [d]
0649   07F9 60            sub a, b
0650   07FA 27            mov b, a
0651   07FB E4            pop a
0652   07FC E7            pop d
0653   07FD FD 43         mov [d], b
0654   07FF             _for11_update:
0655   07FF 2C FD FF      mov b, [bp + -3] ; j
0656   0802 D7            push a
0657   0803 11            mov a, b
0658   0804 FD 77         inc b
0659   0806 D7            push a
0660   0807 11            mov a, b
0661   0808 45 FD FF      mov [bp + -3], a ; j
0662   080B E4            pop a
0663   080C 27            mov b, a
0664   080D E4            pop a
0665   080E 0A 8E 07      jmp _for11_cond
0666   0811             _for11_exit:
0667   0811             _for10_update:
0668   0811 2C FF FF      mov b, [bp + -1] ; i
0669   0814 D7            push a
0670   0815 11            mov a, b
0671   0816 FD 77         inc b
0672   0818 D7            push a
0673   0819 11            mov a, b
0674   081A 45 FF FF      mov [bp + -1], a ; i
0675   081D E4            pop a
0676   081E 27            mov b, a
0677   081F E4            pop a
0678   0820 0A 6D 07      jmp _for10_cond
0679   0823             _for10_exit:
0680   0823 26 61 0B      mov b, __string_4 ; "Result1 (matrix1 * matrix2):\n"
0681   0826 FD AB         swp b
0682   0828 D8            push b
0683   0829 07 D8 0A      call print
0684   082C 51 02 00      add sp, 2
0685   082F             _for12_init:
0686   082F 26 00 00      mov b, 0
0687   0832 D7            push a
0688   0833 11            mov a, b
0689   0834 45 FF FF      mov [bp + -1], a ; i
0690   0837 E4            pop a
0691   0838             _for12_cond:
0692   0838 2C FF FF      mov b, [bp + -1] ; i
0693   083B D7            push a
0694   083C 11            mov a, b
0695   083D 26 03 00      mov b, 3
0696   0840 B0            cmp a, b
0697   0841 0E            lodflgs
0698   0842 87 02         and al, %00000010 ; <
0699   0844 FD 9C         shr al
0700   0846 22 00         mov ah, 0
0701   0848 27            mov b, a
0702   0849 E4            pop a
0703   084A C0 00 00      cmp b, 0
0704   084D C6 CB 08      je _for12_exit
0705   0850             _for12_block:
0706   0850             _for13_init:
0707   0850 26 00 00      mov b, 0
0708   0853 D7            push a
0709   0854 11            mov a, b
0710   0855 45 FD FF      mov [bp + -3], a ; j
0711   0858 E4            pop a
0712   0859             _for13_cond:
0713   0859 2C FD FF      mov b, [bp + -3] ; j
0714   085C D7            push a
0715   085D 11            mov a, b
0716   085E 26 03 00      mov b, 3
0717   0861 B0            cmp a, b
0718   0862 0E            lodflgs
0719   0863 87 02         and al, %00000010 ; <
0720   0865 FD 9C         shr al
0721   0867 22 00         mov ah, 0
0722   0869 27            mov b, a
0723   086A E4            pop a
0724   086B C0 00 00      cmp b, 0
0725   086E C6 AD 08      je _for13_exit
0726   0871             _for13_block:
0727   0871 26 53 0B      mov b, __string_1 ; " "
0728   0874 FD AB         swp b
0729   0876 D8            push b
0730   0877 29 1F 0B      mov b, [__result1]
0731   087A D7            push a
0732   087B 74            mov d, b
0733   087C DA            push d
0734   087D 2C FF FF      mov b, [bp + -1] ; i
0735   0880 E7            pop d
0736   0881 10 06 00      mov a, 6
0737   0884 AC            mul a, b
0738   0885 5A            add d, b
0739   0886 DA            push d
0740   0887 2C FD FF      mov b, [bp + -3] ; j
0741   088A E7            pop d
0742   088B 10 02 00      mov a, 2
0743   088E AC            mul a, b
0744   088F 5A            add d, b
0745   0890 E4            pop a
0746   0891 2A            mov b, [d]
0747   0892 FD AB         swp b
0748   0894 D8            push b
0749   0895 07 C1 0A      call printn
0750   0898 51 04 00      add sp, 4
0751   089B             _for13_update:
0752   089B 2C FD FF      mov b, [bp + -3] ; j
0753   089E D7            push a
0754   089F 11            mov a, b
0755   08A0 FD 77         inc b
0756   08A2 D7            push a
0757   08A3 11            mov a, b
0758   08A4 45 FD FF      mov [bp + -3], a ; j
0759   08A7 E4            pop a
0760   08A8 27            mov b, a
0761   08A9 E4            pop a
0762   08AA 0A 59 08      jmp _for13_cond
0763   08AD             _for13_exit:
0764   08AD 26 55 0B      mov b, __string_2 ; "\n"
0765   08B0 FD AB         swp b
0766   08B2 D8            push b
0767   08B3 07 D8 0A      call print
0768   08B6 51 02 00      add sp, 2
0769   08B9             _for12_update:
0770   08B9 2C FF FF      mov b, [bp + -1] ; i
0771   08BC D7            push a
0772   08BD 11            mov a, b
0773   08BE FD 77         inc b
0774   08C0 D7            push a
0775   08C1 11            mov a, b
0776   08C2 45 FF FF      mov [bp + -1], a ; i
0777   08C5 E4            pop a
0778   08C6 27            mov b, a
0779   08C7 E4            pop a
0780   08C8 0A 38 08      jmp _for12_cond
0781   08CB             _for12_exit:
0782   08CB 26 55 0B      mov b, __string_2 ; "\n"
0783   08CE FD AB         swp b
0784   08D0 D8            push b
0785   08D1 07 D8 0A      call print
0786   08D4 51 02 00      add sp, 2
0787   08D7 26 7F 0B      mov b, __string_5 ; "Result2 (matrix1 + matrix2):\n"
0788   08DA FD AB         swp b
0789   08DC D8            push b
0790   08DD 07 D8 0A      call print
0791   08E0 51 02 00      add sp, 2
0792   08E3             _for14_init:
0793   08E3 26 00 00      mov b, 0
0794   08E6 D7            push a
0795   08E7 11            mov a, b
0796   08E8 45 FF FF      mov [bp + -1], a ; i
0797   08EB E4            pop a
0798   08EC             _for14_cond:
0799   08EC 2C FF FF      mov b, [bp + -1] ; i
0800   08EF D7            push a
0801   08F0 11            mov a, b
0802   08F1 26 03 00      mov b, 3
0803   08F4 B0            cmp a, b
0804   08F5 0E            lodflgs
0805   08F6 87 02         and al, %00000010 ; <
0806   08F8 FD 9C         shr al
0807   08FA 22 00         mov ah, 0
0808   08FC 27            mov b, a
0809   08FD E4            pop a
0810   08FE C0 00 00      cmp b, 0
0811   0901 C6 7F 09      je _for14_exit
0812   0904             _for14_block:
0813   0904             _for15_init:
0814   0904 26 00 00      mov b, 0
0815   0907 D7            push a
0816   0908 11            mov a, b
0817   0909 45 FD FF      mov [bp + -3], a ; j
0818   090C E4            pop a
0819   090D             _for15_cond:
0820   090D 2C FD FF      mov b, [bp + -3] ; j
0821   0910 D7            push a
0822   0911 11            mov a, b
0823   0912 26 03 00      mov b, 3
0824   0915 B0            cmp a, b
0825   0916 0E            lodflgs
0826   0917 87 02         and al, %00000010 ; <
0827   0919 FD 9C         shr al
0828   091B 22 00         mov ah, 0
0829   091D 27            mov b, a
0830   091E E4            pop a
0831   091F C0 00 00      cmp b, 0
0832   0922 C6 61 09      je _for15_exit
0833   0925             _for15_block:
0834   0925 26 53 0B      mov b, __string_1 ; " "
0835   0928 FD AB         swp b
0836   092A D8            push b
0837   092B 29 33 0B      mov b, [__result2]
0838   092E D7            push a
0839   092F 74            mov d, b
0840   0930 DA            push d
0841   0931 2C FF FF      mov b, [bp + -1] ; i
0842   0934 E7            pop d
0843   0935 10 06 00      mov a, 6
0844   0938 AC            mul a, b
0845   0939 5A            add d, b
0846   093A DA            push d
0847   093B 2C FD FF      mov b, [bp + -3] ; j
0848   093E E7            pop d
0849   093F 10 02 00      mov a, 2
0850   0942 AC            mul a, b
0851   0943 5A            add d, b
0852   0944 E4            pop a
0853   0945 2A            mov b, [d]
0854   0946 FD AB         swp b
0855   0948 D8            push b
0856   0949 07 C1 0A      call printn
0857   094C 51 04 00      add sp, 4
0858   094F             _for15_update:
0859   094F 2C FD FF      mov b, [bp + -3] ; j
0860   0952 D7            push a
0861   0953 11            mov a, b
0862   0954 FD 77         inc b
0863   0956 D7            push a
0864   0957 11            mov a, b
0865   0958 45 FD FF      mov [bp + -3], a ; j
0866   095B E4            pop a
0867   095C 27            mov b, a
0868   095D E4            pop a
0869   095E 0A 0D 09      jmp _for15_cond
0870   0961             _for15_exit:
0871   0961 26 55 0B      mov b, __string_2 ; "\n"
0872   0964 FD AB         swp b
0873   0966 D8            push b
0874   0967 07 D8 0A      call print
0875   096A 51 02 00      add sp, 2
0876   096D             _for14_update:
0877   096D 2C FF FF      mov b, [bp + -1] ; i
0878   0970 D7            push a
0879   0971 11            mov a, b
0880   0972 FD 77         inc b
0881   0974 D7            push a
0882   0975 11            mov a, b
0883   0976 45 FF FF      mov [bp + -1], a ; i
0884   0979 E4            pop a
0885   097A 27            mov b, a
0886   097B E4            pop a
0887   097C 0A EC 08      jmp _for14_cond
0888   097F             _for14_exit:
0889   097F 26 55 0B      mov b, __string_2 ; "\n"
0890   0982 FD AB         swp b
0891   0984 D8            push b
0892   0985 07 D8 0A      call print
0893   0988 51 02 00      add sp, 2
0894   098B 26 9D 0B      mov b, __string_6 ; "Result3 (matrix2 - matrix1):\n"
0895   098E FD AB         swp b
0896   0990 D8            push b
0897   0991 07 D8 0A      call print
0898   0994 51 02 00      add sp, 2
0899   0997             _for16_init:
0900   0997 26 00 00      mov b, 0
0901   099A D7            push a
0902   099B 11            mov a, b
0903   099C 45 FF FF      mov [bp + -1], a ; i
0904   099F E4            pop a
0905   09A0             _for16_cond:
0906   09A0 2C FF FF      mov b, [bp + -1] ; i
0907   09A3 D7            push a
0908   09A4 11            mov a, b
0909   09A5 26 03 00      mov b, 3
0910   09A8 B0            cmp a, b
0911   09A9 0E            lodflgs
0912   09AA 87 02         and al, %00000010 ; <
0913   09AC FD 9C         shr al
0914   09AE 22 00         mov ah, 0
0915   09B0 27            mov b, a
0916   09B1 E4            pop a
0917   09B2 C0 00 00      cmp b, 0
0918   09B5 C6 33 0A      je _for16_exit
0919   09B8             _for16_block:
0920   09B8             _for17_init:
0921   09B8 26 00 00      mov b, 0
0922   09BB D7            push a
0923   09BC 11            mov a, b
0924   09BD 45 FD FF      mov [bp + -3], a ; j
0925   09C0 E4            pop a
0926   09C1             _for17_cond:
0927   09C1 2C FD FF      mov b, [bp + -3] ; j
0928   09C4 D7            push a
0929   09C5 11            mov a, b
0930   09C6 26 03 00      mov b, 3
0931   09C9 B0            cmp a, b
0932   09CA 0E            lodflgs
0933   09CB 87 02         and al, %00000010 ; <
0934   09CD FD 9C         shr al
0935   09CF 22 00         mov ah, 0
0936   09D1 27            mov b, a
0937   09D2 E4            pop a
0938   09D3 C0 00 00      cmp b, 0
0939   09D6 C6 15 0A      je _for17_exit
0940   09D9             _for17_block:
0941   09D9 26 53 0B      mov b, __string_1 ; " "
0942   09DC FD AB         swp b
0943   09DE D8            push b
0944   09DF 29 47 0B      mov b, [__result3]
0945   09E2 D7            push a
0946   09E3 74            mov d, b
0947   09E4 DA            push d
0948   09E5 2C FF FF      mov b, [bp + -1] ; i
0949   09E8 E7            pop d
0950   09E9 10 06 00      mov a, 6
0951   09EC AC            mul a, b
0952   09ED 5A            add d, b
0953   09EE DA            push d
0954   09EF 2C FD FF      mov b, [bp + -3] ; j
0955   09F2 E7            pop d
0956   09F3 10 02 00      mov a, 2
0957   09F6 AC            mul a, b
0958   09F7 5A            add d, b
0959   09F8 E4            pop a
0960   09F9 2A            mov b, [d]
0961   09FA FD AB         swp b
0962   09FC D8            push b
0963   09FD 07 C1 0A      call printn
0964   0A00 51 04 00      add sp, 4
0965   0A03             _for17_update:
0966   0A03 2C FD FF      mov b, [bp + -3] ; j
0967   0A06 D7            push a
0968   0A07 11            mov a, b
0969   0A08 FD 77         inc b
0970   0A0A D7            push a
0971   0A0B 11            mov a, b
0972   0A0C 45 FD FF      mov [bp + -3], a ; j
0973   0A0F E4            pop a
0974   0A10 27            mov b, a
0975   0A11 E4            pop a
0976   0A12 0A C1 09      jmp _for17_cond
0977   0A15             _for17_exit:
0978   0A15 26 55 0B      mov b, __string_2 ; "\n"
0979   0A18 FD AB         swp b
0980   0A1A D8            push b
0981   0A1B 07 D8 0A      call print
0982   0A1E 51 02 00      add sp, 2
0983   0A21             _for16_update:
0984   0A21 2C FF FF      mov b, [bp + -1] ; i
0985   0A24 D7            push a
0986   0A25 11            mov a, b
0987   0A26 FD 77         inc b
0988   0A28 D7            push a
0989   0A29 11            mov a, b
0990   0A2A 45 FF FF      mov [bp + -1], a ; i
0991   0A2D E4            pop a
0992   0A2E 27            mov b, a
0993   0A2F E4            pop a
0994   0A30 0A A0 09      jmp _for16_cond
0995   0A33             _for16_exit:
0996   0A33 26 55 0B      mov b, __string_2 ; "\n"
0997   0A36 FD AB         swp b
0998   0A38 D8            push b
0999   0A39 07 D8 0A      call print
1000   0A3C 51 02 00      add sp, 2
1001   0A3F 26 00 00      mov b, 0
1002   0A42 F9            leave
1003   0A43 05 0B         syscall sys_terminate_proc
1004   0A45             
1005   0A45             assert:
1006   0A45 D2            push bp
1007   0A46 9B            mov bp, sp
1008   0A47             _if18_cond:
1009   0A47 2C 05 00      mov b, [bp + 5] ; i
1010   0A4A C0 00 00      cmp b, 0
1011   0A4D C6 5F 0A      je _if18_else
1012   0A50             _if18_true:
1013   0A50 26 BB 0B      mov b, __string_7 ; "Passed."
1014   0A53 FD AB         swp b
1015   0A55 D8            push b
1016   0A56 07 D8 0A      call print
1017   0A59 51 02 00      add sp, 2
1018   0A5C 0A 6B 0A      jmp _if18_exit
1019   0A5F             _if18_else:
1020   0A5F 26 C3 0B      mov b, __string_8 ; "FAILED."
1021   0A62 FD AB         swp b
1022   0A64 D8            push b
1023   0A65 07 D8 0A      call print
1024   0A68 51 02 00      add sp, 2
1025   0A6B             _if18_exit:
1026   0A6B 26 CB 0B      mov b, __string_9 ; "Index: "
1027   0A6E FD AB         swp b
1028   0A70 D8            push b
1029   0A71 29 E3 0A      mov b, [__index] ; index
1030   0A74 FD AB         swp b
1031   0A76 D8            push b
1032   0A77 07 C1 0A      call printn
1033   0A7A 51 04 00      add sp, 4
1034   0A7D 26 55 0B      mov b, __string_2 ; "\n"
1035   0A80 FD AB         swp b
1036   0A82 D8            push b
1037   0A83 07 D8 0A      call print
1038   0A86 51 02 00      add sp, 2
1039   0A89 29 E3 0A      mov b, [__index] ; index
1040   0A8C D7            push a
1041   0A8D 11            mov a, b
1042   0A8E FD 77         inc b
1043   0A90 FD 42 E3 0A   mov [__index], b
1044   0A94 27            mov b, a
1045   0A95 E4            pop a
1046   0A96 F9            leave
1047   0A97 09            ret
1048   0A98             
1049   0A98             add:
1050   0A98 D2            push bp
1051   0A99 9B            mov bp, sp
1052   0A9A 2C 07 00      mov b, [bp + 7] ; x
1053   0A9D D7            push a
1054   0A9E 11            mov a, b
1055   0A9F 2C 05 00      mov b, [bp + 5] ; y
1056   0AA2 54            add a, b
1057   0AA3 27            mov b, a
1058   0AA4 E4            pop a
1059   0AA5 F9            leave
1060   0AA6 09            ret
1061   0AA7             
1062   0AA7             scann:
1063   0AA7 D2            push bp
1064   0AA8 9B            mov bp, sp
1065   0AA9 52 02 00      sub sp, 2 ; m
1066   0AAC             
1067   0AAC             ; --- BEGIN INLINE ASM BLOCK
1068   0AAC 07 1D 0F      call scan_u16d
1069   0AAF 45 FF FF      mov [bp + -1], a
1070   0AB2             ; --- END INLINE ASM BLOCK
1071   0AB2             
1072   0AB2 FA 05 00      lea d, [bp + 5] ; n
1073   0AB5 2A            mov b, [d]
1074   0AB6 D8            push b
1075   0AB7 2C FF FF      mov b, [bp + -1] ; m
1076   0ABA E7            pop d
1077   0ABB D7            push a
1078   0ABC 11            mov a, b
1079   0ABD 43            mov [d], a
1080   0ABE E4            pop a
1081   0ABF F9            leave
1082   0AC0 09            ret
1083   0AC1             
1084   0AC1             printn:
1085   0AC1 D2            push bp
1086   0AC2 9B            mov bp, sp
1087   0AC3 FA 07 00      lea d, [bp + 7] ; s
1088   0AC6 2A            mov b, [d]
1089   0AC7 FD AB         swp b
1090   0AC9 D8            push b
1091   0ACA 07 D8 0A      call print
1092   0ACD 51 02 00      add sp, 2
1093   0AD0             
1094   0AD0             ; --- BEGIN INLINE ASM BLOCK
1095   0AD0 17 05 00      mov a, [bp + 5]
1096   0AD3 07 48 0E      call print_u16d
1097   0AD6             ; --- END INLINE ASM BLOCK
1098   0AD6             
1099   0AD6 F9            leave
1100   0AD7 09            ret
1101   0AD8             
1102   0AD8             print:
1103   0AD8 D2            push bp
1104   0AD9 9B            mov bp, sp
1105   0ADA             
1106   0ADA             ; --- BEGIN INLINE ASM BLOCK
1107   0ADA 17 05 00      mov a, [bp + 5]
1108   0ADD 3C            mov d, a
1109   0ADE 07 1F 0E      call puts
1110   0AE1             ; --- END INLINE ASM BLOCK
1111   0AE1             
1112   0AE1 F9            leave
1113   0AE2 09            ret
1114   0AE3             ; --- END TEXT BLOCK
1115   0AE3             
1116   0AE3             ; --- BEGIN DATA BLOCK
1117   0AE3 00 00       __index: .dw 0
1118   0AE5             __matrix1_data: 
1119   0AE5 01 00 02 00 .dw 1,2,3,4,5,6,7,8,9,
1119   0AE9 03 00 04 00 
1119   0AED 05 00 06 00 
1119   0AF1 07 00 08 00 
1119   0AF5 09 00 
1120   0AF7             .fill 0, 0
1121   0AF7 E5 0A       __matrix1: .dw __matrix1_data
1122   0AF9             __matrix2_data: 
1123   0AF9 09 00 08 00 .dw 9,8,7,6,5,4,3,2,1,
1123   0AFD 07 00 06 00 
1123   0B01 05 00 04 00 
1123   0B05 03 00 02 00 
1123   0B09 01 00 
1124   0B0B             .fill 0, 0
1125   0B0B F9 0A       __matrix2: .dw __matrix2_data
1126   0B0D 00 00 00 00 __result1_data: .fill 18, 0
1126   0B11 00 00 00 00 
1126   0B15 00 00 00 00 
1126   0B19 00 00 00 00 
1126   0B1D 00 00 
1127   0B1F 0D 0B       __result1: .dw __result1_data
1128   0B21 00 00 00 00 __result2_data: .fill 18, 0
1128   0B25 00 00 00 00 
1128   0B29 00 00 00 00 
1128   0B2D 00 00 00 00 
1128   0B31 00 00 
1129   0B33 21 0B       __result2: .dw __result2_data
1130   0B35 00 00 00 00 __result3_data: .fill 18, 0
1130   0B39 00 00 00 00 
1130   0B3D 00 00 00 00 
1130   0B41 00 00 00 00 
1130   0B45 00 00 
1131   0B47 35 0B       __result3: .dw __result3_data
1132   0B49 4D 61 74 72 __string_0: .db "Matrix1:\n", 0
1132   0B4D 69 78 31 3A 
1132   0B51 0A 00 
1133   0B53 20 00       __string_1: .db " ", 0
1134   0B55 0A 00       __string_2: .db "\n", 0
1135   0B57 4D 61 74 72 __string_3: .db "Matrix2:\n", 0
1135   0B5B 69 78 32 3A 
1135   0B5F 0A 00 
1136   0B61 52 65 73 75 __string_4: .db "Result1 (matrix1 * matrix2):\n", 0
1136   0B65 6C 74 31 20 
1136   0B69 28 6D 61 74 
1136   0B6D 72 69 78 31 
1136   0B71 20 2A 20 6D 
1136   0B75 61 74 72 69 
1136   0B79 78 32 29 3A 
1136   0B7D 0A 00 
1137   0B7F 52 65 73 75 __string_5: .db "Result2 (matrix1 + matrix2):\n", 0
1137   0B83 6C 74 32 20 
1137   0B87 28 6D 61 74 
1137   0B8B 72 69 78 31 
1137   0B8F 20 2B 20 6D 
1137   0B93 61 74 72 69 
1137   0B97 78 32 29 3A 
1137   0B9B 0A 00 
1138   0B9D 52 65 73 75 __string_6: .db "Result3 (matrix2 - matrix1):\n", 0
1138   0BA1 6C 74 33 20 
1138   0BA5 28 6D 61 74 
1138   0BA9 72 69 78 32 
1138   0BAD 20 2D 20 6D 
1138   0BB1 61 74 72 69 
1138   0BB5 78 31 29 3A 
1138   0BB9 0A 00 
1139   0BBB 50 61 73 73 __string_7: .db "Passed.", 0
1139   0BBF 65 64 2E 00 
1140   0BC3 46 41 49 4C __string_8: .db "FAILED.", 0
1140   0BC7 45 44 2E 00 
1141   0BCB 49 6E 64 65 __string_9: .db "Index: ", 0
1141   0BCF 78 3A 20 00 
1142   0BD3             ; --- END DATA BLOCK
1143   0BD3             
1144   0BD3             ; --- BEGIN INCLUDE BLOCK
1145   0BD3             .include "lib/stdio.asm"
0001+  0BD3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0BD3             ; stdio.s
0003+  0BD3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0BD3             .include "lib/string.asm"
0001++ 0BD3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0BD3             ; string.s
0003++ 0BD3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0BD3             
0005++ 0BD3             
0006++ 0BD3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0BD3             ; strrev
0008++ 0BD3             ; reverse a string
0009++ 0BD3             ; D = string address
0010++ 0BD3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0BD3             ; 01234
0012++ 0BD3             strrev:
0013++ 0BD3 4B          	pusha
0014++ 0BD4 07 1A 0C    	call strlen	; length in C
0015++ 0BD7 12          	mov a, c
0016++ 0BD8 AF 01 00    	cmp a, 1
0017++ 0BDB D0 F5 0B    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0BDE 7D          	dec a
0019++ 0BDF FD 4E       	mov si, d	; beginning of string
0020++ 0BE1 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0BE3 59          	add d, a	; end of string
0022++ 0BE4 12          	mov a, c
0023++ 0BE5 FD 9B       	shr a		; divide by 2
0024++ 0BE7 39          	mov c, a	; C now counts the steps
0025++ 0BE8             strrev_L0:
0026++ 0BE8 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0BE9 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0BEA 3E          	mov [d], al	; store left char into right side
0029++ 0BEB 1B          	mov al, bl
0030++ 0BEC F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0BED 7E          	dec c
0032++ 0BEE 7F          	dec d
0033++ 0BEF C2 00 00    	cmp c, 0
0034++ 0BF2 C7 E8 0B    	jne strrev_L0
0035++ 0BF5             strrev_end:
0036++ 0BF5 4C          	popa
0037++ 0BF6 09          	ret
0038++ 0BF7             	
0039++ 0BF7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0BF7             ; strchr
0041++ 0BF7             ; search string in D for char in AL
0042++ 0BF7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0BF7             strchr:
0044++ 0BF7             strchr_L0:
0045++ 0BF7 32          	mov bl, [d]
0046++ 0BF8 C1 00       	cmp bl, 0
0047++ 0BFA C6 05 0C    	je strchr_end
0048++ 0BFD BA          	cmp al, bl
0049++ 0BFE C6 05 0C    	je strchr_end
0050++ 0C01 79          	inc d
0051++ 0C02 0A F7 0B    	jmp strchr_L0
0052++ 0C05             strchr_end:
0053++ 0C05 1B          	mov al, bl
0054++ 0C06 09          	ret
0055++ 0C07             
0056++ 0C07             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0C07             ; strstr
0058++ 0C07             ; find sub-string
0059++ 0C07             ; str1 in SI
0060++ 0C07             ; str2 in DI
0061++ 0C07             ; SI points to end of source string
0062++ 0C07             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0C07             strstr:
0064++ 0C07 DB          	push al
0065++ 0C08 DA          	push d
0066++ 0C09 E3          	push di
0067++ 0C0A             strstr_loop:
0068++ 0C0A F3          	cmpsb					; compare a byte of the strings
0069++ 0C0B C7 16 0C    	jne strstr_ret
0070++ 0C0E FC 00 00    	lea d, [di + 0]
0071++ 0C11 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0C13 C7 0A 0C    	jne strstr_loop				; equal chars but not at end
0073++ 0C16             strstr_ret:
0074++ 0C16 F0          	pop di
0075++ 0C17 E7          	pop d
0076++ 0C18 E8          	pop al
0077++ 0C19 09          	ret
0078++ 0C1A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0C1A             ; length of null terminated string
0080++ 0C1A             ; result in C
0081++ 0C1A             ; pointer in D
0082++ 0C1A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0C1A             strlen:
0084++ 0C1A DA          	push d
0085++ 0C1B 38 00 00    	mov c, 0
0086++ 0C1E             strlen_L1:
0087++ 0C1E BD 00       	cmp byte [d], 0
0088++ 0C20 C6 28 0C    	je strlen_ret
0089++ 0C23 79          	inc d
0090++ 0C24 78          	inc c
0091++ 0C25 0A 1E 0C    	jmp strlen_L1
0092++ 0C28             strlen_ret:
0093++ 0C28 E7          	pop d
0094++ 0C29 09          	ret
0095++ 0C2A             
0096++ 0C2A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0C2A             ; STRCMP
0098++ 0C2A             ; compare two strings
0099++ 0C2A             ; str1 in SI
0100++ 0C2A             ; str2 in DI
0101++ 0C2A             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0C2A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0C2A             strcmp:
0104++ 0C2A DB          	push al
0105++ 0C2B DA          	push d
0106++ 0C2C E3          	push di
0107++ 0C2D E2          	push si
0108++ 0C2E             strcmp_loop:
0109++ 0C2E F3          	cmpsb					; compare a byte of the strings
0110++ 0C2F C7 3A 0C    	jne strcmp_ret
0111++ 0C32 FB FF FF    	lea d, [si +- 1]
0112++ 0C35 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0C37 C7 2E 0C    	jne strcmp_loop				; equal chars but not at end
0114++ 0C3A             strcmp_ret:
0115++ 0C3A EF          	pop si
0116++ 0C3B F0          	pop di
0117++ 0C3C E7          	pop d
0118++ 0C3D E8          	pop al
0119++ 0C3E 09          	ret
0120++ 0C3F             
0121++ 0C3F             
0122++ 0C3F             ; STRCPY
0123++ 0C3F             ; copy null terminated string from SI to DI
0124++ 0C3F             ; source in SI
0125++ 0C3F             ; destination in DI
0126++ 0C3F             strcpy:
0127++ 0C3F E2          	push si
0128++ 0C40 E3          	push di
0129++ 0C41 DB          	push al
0130++ 0C42             strcpy_L1:
0131++ 0C42 F6          	lodsb
0132++ 0C43 F7          	stosb
0133++ 0C44 B9 00       	cmp al, 0
0134++ 0C46 C7 42 0C    	jne strcpy_L1
0135++ 0C49             strcpy_end:
0136++ 0C49 E8          	pop al
0137++ 0C4A F0          	pop di
0138++ 0C4B EF          	pop si
0139++ 0C4C 09          	ret
0140++ 0C4D             
0141++ 0C4D             ; STRCAT
0142++ 0C4D             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0C4D             ; source in SI
0144++ 0C4D             ; destination in DI
0145++ 0C4D             strcat:
0146++ 0C4D E2          	push si
0147++ 0C4E E3          	push di
0148++ 0C4F D7          	push a
0149++ 0C50 DA          	push d
0150++ 0C51 50          	mov a, di
0151++ 0C52 3C          	mov d, a
0152++ 0C53             strcat_goto_end_L1:
0153++ 0C53 BD 00       	cmp byte[d], 0
0154++ 0C55 C6 5C 0C    	je strcat_start
0155++ 0C58 79          	inc d
0156++ 0C59 0A 53 0C    	jmp strcat_goto_end_L1
0157++ 0C5C             strcat_start:
0158++ 0C5C FD 50       	mov di, d
0159++ 0C5E             strcat_L1:
0160++ 0C5E F6          	lodsb
0161++ 0C5F F7          	stosb
0162++ 0C60 B9 00       	cmp al, 0
0163++ 0C62 C7 5E 0C    	jne strcat_L1
0164++ 0C65             strcat_end:
0165++ 0C65 E7          	pop d
0166++ 0C66 E4          	pop a
0167++ 0C67 F0          	pop di
0168++ 0C68 EF          	pop si
0169++ 0C69 09          	ret
0005+  0C6A             
0006+  0C6A 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  0C6E 34 35 36 37 
0006+  0C72 38 39 41 42 
0006+  0C76 43 44 45 46 
0007+  0C7A 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  0C7E 1B 5B 48 00 
0008+  0C82             
0009+  0C82 01 00       table_power:.dw 1
0010+  0C84 0A 00       			.dw 10
0011+  0C86 64 00       			.dw 100
0012+  0C88 E8 03       			.dw 1000
0013+  0C8A 10 27       			.dw 10000
0014+  0C8C             
0015+  0C8C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  0C8C             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  0C8C             ; ASCII in BL
0018+  0C8C             ; result in AL
0019+  0C8C             ; ascii for F = 0100 0110
0020+  0C8C             ; ascii for 9 = 0011 1001
0021+  0C8C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  0C8C             hex_ascii_encode:
0023+  0C8C 1B          	mov al, bl
0024+  0C8D 93 40       	test al, $40				; test if letter or number
0025+  0C8F C7 95 0C    	jnz hex_letter
0026+  0C92 87 0F       	and al, $0F				; get number
0027+  0C94 09          	ret
0028+  0C95             hex_letter:
0029+  0C95 87 0F       	and al, $0F				; get letter
0030+  0C97 6A 09       	add al, 9
0031+  0C99 09          	ret
0032+  0C9A             
0033+  0C9A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  0C9A             ; ATOI
0035+  0C9A             ; 2 letter hex string in B
0036+  0C9A             ; 8bit integer returned in AL
0037+  0C9A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0C9A             atoi:
0039+  0C9A D8          	push b
0040+  0C9B 07 8C 0C    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  0C9E 30          	mov bl, bh
0042+  0C9F DB          	push al					; save a
0043+  0CA0 07 8C 0C    	call hex_ascii_encode
0044+  0CA3 EA          	pop bl	
0045+  0CA4 FD 9E 04    	shl al, 4
0046+  0CA7 8C          	or al, bl
0047+  0CA8 E5          	pop b
0048+  0CA9 09          	ret	
0049+  0CAA             
0050+  0CAA             
0051+  0CAA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  0CAA             ; printf
0053+  0CAA             ; no need for explanations!
0054+  0CAA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0CAA             printf:
0056+  0CAA 09          	ret
0057+  0CAB             
0058+  0CAB             
0059+  0CAB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  0CAB             ; scanf
0061+  0CAB             ; no need for explanations!
0062+  0CAB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  0CAB             scanf:
0064+  0CAB 09          	ret
0065+  0CAC             
0066+  0CAC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  0CAC             ; ITOA
0068+  0CAC             ; 8bit value in BL
0069+  0CAC             ; 2 byte ASCII result in A
0070+  0CAC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  0CAC             itoa:
0072+  0CAC DA          	push d
0073+  0CAD D8          	push b
0074+  0CAE A7 00       	mov bh, 0
0075+  0CB0 FD A4 04    	shr bl, 4	
0076+  0CB3 74          	mov d, b
0077+  0CB4 1F 6A 0C    	mov al, [d + s_hex_digits]
0078+  0CB7 23          	mov ah, al
0079+  0CB8             	
0080+  0CB8 E5          	pop b
0081+  0CB9 D8          	push b
0082+  0CBA A7 00       	mov bh, 0
0083+  0CBC FD 87 0F    	and bl, $0F
0084+  0CBF 74          	mov d, b
0085+  0CC0 1F 6A 0C    	mov al, [d + s_hex_digits]
0086+  0CC3 E5          	pop b
0087+  0CC4 E7          	pop d
0088+  0CC5 09          	ret
0089+  0CC6             
0090+  0CC6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  0CC6             ; HEX STRING TO BINARY
0092+  0CC6             ; di = destination address
0093+  0CC6             ; si = source
0094+  0CC6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  0CC6             hex_to_int:
0096+  0CC6             hex_to_int_L1:
0097+  0CC6 F6          	lodsb					; load from [SI] to AL
0098+  0CC7 B9 00       	cmp al, 0				; check if ASCII 0
0099+  0CC9 C6 D6 0C    	jz hex_to_int_ret
0100+  0CCC 36          	mov bh, al
0101+  0CCD F6          	lodsb
0102+  0CCE 2F          	mov bl, al
0103+  0CCF 07 9A 0C    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  0CD2 F7          	stosb					; store AL to [DI]
0105+  0CD3 0A C6 0C    	jmp hex_to_int_L1
0106+  0CD6             hex_to_int_ret:
0107+  0CD6 09          	ret		
0108+  0CD7             
0109+  0CD7             
0110+  0CD7             
0111+  0CD7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  0CD7             ; GETCHAR
0113+  0CD7             ; char in ah
0114+  0CD7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  0CD7             getchar:
0116+  0CD7 DB          	push al
0117+  0CD8             getchar_retry:
0118+  0CD8 FD 0C       	sti
0119+  0CDA 19 01       	mov al, 1
0120+  0CDC 05 03       	syscall sys_io			; receive in AH
0121+  0CDE B9 00       	cmp al, 0			; check if any char was receive
0122+  0CE0 C6 D8 0C    	je getchar_retry
0123+  0CE3 E8          	pop al
0124+  0CE4 09          	ret
0125+  0CE5             
0126+  0CE5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  0CE5             ; PUTCHAR
0128+  0CE5             ; char in ah
0129+  0CE5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0CE5             putchar:
0131+  0CE5 D7          	push a
0132+  0CE6 19 00       	mov al, 0
0133+  0CE8 05 03       	syscall sys_io			; char in AH
0134+  0CEA E4          	pop a
0135+  0CEB 09          	ret
0136+  0CEC             
0137+  0CEC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  0CEC             ;; INPUT A STRING
0139+  0CEC             ;; terminates with null
0140+  0CEC             ;; pointer in D
0141+  0CEC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  0CEC             gets:
0143+  0CEC D7          	push a
0144+  0CED DA          	push d
0145+  0CEE             gets_loop:
0146+  0CEE FD 0C       	sti
0147+  0CF0 19 01       	mov al, 1
0148+  0CF2 05 03       	syscall sys_io			; receive in AH
0149+  0CF4 B9 00       	cmp al, 0				; check error code (AL)
0150+  0CF6 C6 EE 0C    	je gets_loop			; if no char received, retry
0151+  0CF9             
0152+  0CF9 76 1B       	cmp ah, 27
0153+  0CFB C6 1C 0D    	je gets_telnet_escape
0154+  0CFE 76 0A       	cmp ah, $0A				; LF
0155+  0D00 C6 75 0D    	je gets_end
0156+  0D03 76 0D       	cmp ah, $0D				; CR
0157+  0D05 C6 75 0D    	je gets_end
0158+  0D08 76 5C       	cmp ah, $5C				; '\\'
0159+  0D0A C6 4C 0D    	je gets_escape
0160+  0D0D             	
0161+  0D0D 76 08       	cmp ah, $08			; check for backspace
0162+  0D0F C6 18 0D    	je gets_backspace
0163+  0D12             
0164+  0D12 1A          	mov al, ah
0165+  0D13 3E          	mov [d], al
0166+  0D14 79          	inc d
0167+  0D15 0A EE 0C    	jmp gets_loop
0168+  0D18             gets_backspace:
0169+  0D18 7F          	dec d
0170+  0D19 0A EE 0C    	jmp gets_loop
0171+  0D1C             gets_telnet_escape:
0172+  0D1C FD 0C       	sti
0173+  0D1E 19 01       	mov al, 1
0174+  0D20 05 03       	syscall sys_io				; receive in AH without echo
0175+  0D22 B9 00       	cmp al, 0					; check error code (AL)
0176+  0D24 C6 1C 0D    	je gets_telnet_escape		; if no char received, retry
0177+  0D27 76 5B       	cmp ah, '['
0178+  0D29 C7 EE 0C    	jne gets_loop
0179+  0D2C             gets_telnet_escape_phase2:
0180+  0D2C FD 0C       	sti
0181+  0D2E 19 01       	mov al, 1
0182+  0D30 05 03       	syscall sys_io					; receive in AH without echo
0183+  0D32 B9 00       	cmp al, 0						; check error code (AL)
0184+  0D34 C6 2C 0D    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  0D37 76 44       	cmp ah, 'D'
0186+  0D39 C6 44 0D    	je gets_left_arrow
0187+  0D3C 76 43       	cmp ah, 'C'
0188+  0D3E C6 48 0D    	je gets_right_arrow
0189+  0D41 0A EE 0C    	jmp gets_loop
0190+  0D44             gets_left_arrow:
0191+  0D44 7F          	dec d
0192+  0D45 0A EE 0C    	jmp gets_loop
0193+  0D48             gets_right_arrow:
0194+  0D48 79          	inc d
0195+  0D49 0A EE 0C    	jmp gets_loop
0196+  0D4C             gets_escape:
0197+  0D4C FD 0C       	sti
0198+  0D4E 19 01       	mov al, 1
0199+  0D50 05 03       	syscall sys_io			; receive in AH
0200+  0D52 B9 00       	cmp al, 0				; check error code (AL)
0201+  0D54 C6 4C 0D    	je gets_escape			; if no char received, retry
0202+  0D57 76 6E       	cmp ah, 'n'
0203+  0D59 C6 67 0D    	je gets_LF
0204+  0D5C 76 72       	cmp ah, 'r'
0205+  0D5E C6 6E 0D    	je gets_CR
0206+  0D61 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  0D62 3E          	mov [d], al
0208+  0D63 79          	inc d
0209+  0D64 0A EE 0C    	jmp gets_loop
0210+  0D67             gets_LF:
0211+  0D67 19 0A       	mov al, $0A
0212+  0D69 3E          	mov [d], al
0213+  0D6A 79          	inc d
0214+  0D6B 0A EE 0C    	jmp gets_loop
0215+  0D6E             gets_CR:
0216+  0D6E 19 0D       	mov al, $0D
0217+  0D70 3E          	mov [d], al
0218+  0D71 79          	inc d
0219+  0D72 0A EE 0C    	jmp gets_loop
0220+  0D75             gets_end:
0221+  0D75 19 00       	mov al, 0
0222+  0D77 3E          	mov [d], al				; terminate string
0223+  0D78 E7          	pop d
0224+  0D79 E4          	pop a
0225+  0D7A 09          	ret
0226+  0D7B             
0227+  0D7B             
0228+  0D7B             
0229+  0D7B             
0230+  0D7B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  0D7B             ;; INPUT TEXT
0232+  0D7B             ;; terminated with CTRL+D
0233+  0D7B             ;; pointer in D
0234+  0D7B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  0D7B             gettxt:
0236+  0D7B D7          	push a
0237+  0D7C DA          	push d
0238+  0D7D             gettxt_loop:
0239+  0D7D 19 01       	mov al, 1
0240+  0D7F 05 03       	syscall sys_io			; receive in AH
0241+  0D81 B9 00       	cmp al, 0				; check error code (AL)
0242+  0D83 C6 7D 0D    	je gettxt_loop		; if no char received, retry
0243+  0D86 76 04       	cmp ah, 4			; EOT
0244+  0D88 C6 C6 0D    	je gettxt_end
0245+  0D8B 76 08       	cmp ah, $08			; check for backspace
0246+  0D8D C6 C2 0D    	je gettxt_backspace
0247+  0D90 76 5C       	cmp ah, $5C				; '\\'
0248+  0D92 C6 9B 0D    	je gettxt_escape
0249+  0D95 1A          	mov al, ah
0250+  0D96 3E          	mov [d], al
0251+  0D97 79          	inc d
0252+  0D98 0A 7D 0D    	jmp gettxt_loop
0253+  0D9B             gettxt_escape:
0254+  0D9B 19 01       	mov al, 1
0255+  0D9D 05 03       	syscall sys_io			; receive in AH
0256+  0D9F B9 00       	cmp al, 0				; check error code (AL)
0257+  0DA1 C6 9B 0D    	je gettxt_escape		; if no char received, retry
0258+  0DA4 76 6E       	cmp ah, 'n'
0259+  0DA6 C6 B4 0D    	je gettxt_LF
0260+  0DA9 76 72       	cmp ah, 'r'
0261+  0DAB C6 BB 0D    	je gettxt_CR
0262+  0DAE 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  0DAF 3E          	mov [d], al
0264+  0DB0 79          	inc d
0265+  0DB1 0A 7D 0D    	jmp gettxt_loop
0266+  0DB4             gettxt_LF:
0267+  0DB4 19 0A       	mov al, $0A
0268+  0DB6 3E          	mov [d], al
0269+  0DB7 79          	inc d
0270+  0DB8 0A 7D 0D    	jmp gettxt_loop
0271+  0DBB             gettxt_CR:
0272+  0DBB 19 0D       	mov al, $0D
0273+  0DBD 3E          	mov [d], al
0274+  0DBE 79          	inc d
0275+  0DBF 0A 7D 0D    	jmp gettxt_loop
0276+  0DC2             gettxt_backspace:
0277+  0DC2 7F          	dec d
0278+  0DC3 0A 7D 0D    	jmp gettxt_loop
0279+  0DC6             gettxt_end:
0280+  0DC6 19 00       	mov al, 0
0281+  0DC8 3E          	mov [d], al				; terminate string
0282+  0DC9 E7          	pop d
0283+  0DCA E4          	pop a
0284+  0DCB 09          	ret
0285+  0DCC             
0286+  0DCC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  0DCC             ; PRINT NEW LINE
0288+  0DCC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  0DCC             printnl:
0290+  0DCC D7          	push a
0291+  0DCD 10 00 0A    	mov a, $0A00
0292+  0DD0 05 03       	syscall sys_io
0293+  0DD2 10 00 0D    	mov a, $0D00
0294+  0DD5 05 03       	syscall sys_io
0295+  0DD7 E4          	pop a
0296+  0DD8 09          	ret
0297+  0DD9             
0298+  0DD9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  0DD9             ; strtoint
0300+  0DD9             ; 4 digit hex string number in d
0301+  0DD9             ; integer returned in A
0302+  0DD9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  0DD9             strtointx:
0304+  0DD9 D8          	push b
0305+  0DDA 32          	mov bl, [d]
0306+  0DDB 37          	mov bh, bl
0307+  0DDC 33 01 00    	mov bl, [d + 1]
0308+  0DDF 07 9A 0C    	call atoi				; convert to int in AL
0309+  0DE2 23          	mov ah, al				; move to AH
0310+  0DE3 33 02 00    	mov bl, [d + 2]
0311+  0DE6 37          	mov bh, bl
0312+  0DE7 33 03 00    	mov bl, [d + 3]
0313+  0DEA 07 9A 0C    	call atoi				; convert to int in AL
0314+  0DED E5          	pop b
0315+  0DEE 09          	ret
0316+  0DEF             
0317+  0DEF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  0DEF             ; strtoint
0319+  0DEF             ; 5 digit base10 string number in d
0320+  0DEF             ; integer returned in A
0321+  0DEF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  0DEF             strtoint:
0323+  0DEF E2          	push si
0324+  0DF0 D8          	push b
0325+  0DF1 D9          	push c
0326+  0DF2 DA          	push d
0327+  0DF3 07 1A 0C    	call strlen			; get string length in C
0328+  0DF6 7E          	dec c
0329+  0DF7 FD 4E       	mov si, d
0330+  0DF9 12          	mov a, c
0331+  0DFA FD 99       	shl a
0332+  0DFC 3B 82 0C    	mov d, table_power
0333+  0DFF 59          	add d, a
0334+  0E00 38 00 00    	mov c, 0
0335+  0E03             strtoint_L0:
0336+  0E03 F6          	lodsb			; load ASCII to al
0337+  0E04 B9 00       	cmp al, 0
0338+  0E06 C6 19 0E    	je strtoint_end
0339+  0E09 6F 30       	sub al, $30		; make into integer
0340+  0E0B 22 00       	mov ah, 0
0341+  0E0D 2A          	mov b, [d]
0342+  0E0E AC          	mul a, b			; result in B since it fits in 16bits
0343+  0E0F 11          	mov a, b
0344+  0E10 28          	mov b, c
0345+  0E11 54          	add a, b
0346+  0E12 39          	mov c, a
0347+  0E13 63 02 00    	sub d, 2
0348+  0E16 0A 03 0E    	jmp strtoint_L0
0349+  0E19             strtoint_end:
0350+  0E19 12          	mov a, c
0351+  0E1A E7          	pop d
0352+  0E1B E6          	pop c
0353+  0E1C E5          	pop b
0354+  0E1D EF          	pop si
0355+  0E1E 09          	ret
0356+  0E1F             
0357+  0E1F             
0358+  0E1F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  0E1F             ; PRINT NULL TERMINATED STRING
0360+  0E1F             ; pointer in D
0361+  0E1F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  0E1F             puts:
0363+  0E1F D7          	push a
0364+  0E20 DA          	push d
0365+  0E21             puts_L1:
0366+  0E21 1E          	mov al, [d]
0367+  0E22 B9 00       	cmp al, 0
0368+  0E24 C6 30 0E    	jz puts_END
0369+  0E27 23          	mov ah, al
0370+  0E28 19 00       	mov al, 0
0371+  0E2A 05 03       	syscall sys_io
0372+  0E2C 79          	inc d
0373+  0E2D 0A 21 0E    	jmp puts_L1
0374+  0E30             puts_END:
0375+  0E30 E7          	pop d
0376+  0E31 E4          	pop a
0377+  0E32 09          	ret
0378+  0E33             
0379+  0E33             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  0E33             ; PRINT N SIZE STRING
0381+  0E33             ; pointer in D
0382+  0E33             ; size in C
0383+  0E33             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  0E33             putsn:
0385+  0E33 DB          	push al
0386+  0E34 DA          	push d
0387+  0E35 D9          	push c
0388+  0E36             putsn_L0:
0389+  0E36 1E          	mov al, [d]
0390+  0E37 23          	mov ah, al
0391+  0E38 19 00       	mov al, 0
0392+  0E3A 05 03       	syscall sys_io
0393+  0E3C 79          	inc d
0394+  0E3D 7E          	dec c	
0395+  0E3E C2 00 00    	cmp c, 0
0396+  0E41 C7 36 0E    	jne putsn_L0
0397+  0E44             putsn_end:
0398+  0E44 E6          	pop c
0399+  0E45 E7          	pop d
0400+  0E46 E8          	pop al
0401+  0E47 09          	ret
0402+  0E48             
0403+  0E48             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  0E48             ; print 16bit decimal number
0405+  0E48             ; input number in A
0406+  0E48             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  0E48             print_u16d:
0408+  0E48 D7          	push a
0409+  0E49 D8          	push b
0410+  0E4A 26 10 27    	mov b, 10000
0411+  0E4D AE          	div a, b			; get 10000 coeff.
0412+  0E4E 07 74 0E    	call print_number
0413+  0E51 11          	mov a, b
0414+  0E52 26 E8 03    	mov b, 1000
0415+  0E55 AE          	div a, b			; get 10000 coeff.
0416+  0E56 07 74 0E    	call print_number
0417+  0E59 11          	mov a, b
0418+  0E5A 26 64 00    	mov b, 100
0419+  0E5D AE          	div a, b
0420+  0E5E 07 74 0E    	call print_number
0421+  0E61 11          	mov a, b
0422+  0E62 26 0A 00    	mov b, 10
0423+  0E65 AE          	div a, b
0424+  0E66 07 74 0E    	call print_number
0425+  0E69 11          	mov a, b
0426+  0E6A 6A 30       	add al, $30
0427+  0E6C 23          	mov ah, al
0428+  0E6D 19 00       	mov al, 0
0429+  0E6F 05 03       	syscall sys_io	; print coeff
0430+  0E71 E5          	pop b
0431+  0E72 E4          	pop a
0432+  0E73 09          	ret
0433+  0E74             
0434+  0E74             
0435+  0E74             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  0E74             ; if A == 0, print space
0437+  0E74             ; else print A
0438+  0E74             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0439+  0E74             print_number:
0440+  0E74 6A 30       	add al, $30
0441+  0E76 23          	mov ah, al
0442+  0E77 07 E5 0C    	call putchar
0443+  0E7A 09          	ret
0444+  0E7B             
0445+  0E7B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0446+  0E7B             ; PRINT 16BIT HEX INTEGER
0447+  0E7B             ; integer value in reg B
0448+  0E7B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  0E7B             print_u16x:
0450+  0E7B D7          	push a
0451+  0E7C D8          	push b
0452+  0E7D DD          	push bl
0453+  0E7E 30          	mov bl, bh
0454+  0E7F 07 AC 0C    	call itoa				; convert bh to char in A
0455+  0E82 2F          	mov bl, al				; save al
0456+  0E83 19 00       	mov al, 0
0457+  0E85 05 03       	syscall sys_io				; display AH
0458+  0E87 24          	mov ah, bl				; retrieve al
0459+  0E88 19 00       	mov al, 0
0460+  0E8A 05 03       	syscall sys_io				; display AL
0461+  0E8C             
0462+  0E8C EA          	pop bl
0463+  0E8D 07 AC 0C    	call itoa				; convert bh to char in A
0464+  0E90 2F          	mov bl, al				; save al
0465+  0E91 19 00       	mov al, 0
0466+  0E93 05 03       	syscall sys_io				; display AH
0467+  0E95 24          	mov ah, bl				; retrieve al
0468+  0E96 19 00       	mov al, 0
0469+  0E98 05 03       	syscall sys_io				; display AL
0470+  0E9A             
0471+  0E9A E5          	pop b
0472+  0E9B E4          	pop a
0473+  0E9C 09          	ret
0474+  0E9D             
0475+  0E9D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  0E9D             ; INPUT 16BIT HEX INTEGER
0477+  0E9D             ; read 16bit integer into A
0478+  0E9D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  0E9D             scan_u16x:
0480+  0E9D F8 10 00    	enter 16
0481+  0EA0 D8          	push b
0482+  0EA1 DA          	push d
0483+  0EA2             
0484+  0EA2 FA F1 FF    	lea d, [bp + -15]
0485+  0EA5 07 EC 0C    	call gets				; get number
0486+  0EA8             
0487+  0EA8 32          	mov bl, [d]
0488+  0EA9 37          	mov bh, bl
0489+  0EAA 33 01 00    	mov bl, [d + 1]
0490+  0EAD 07 9A 0C    	call atoi				; convert to int in AL
0491+  0EB0 23          	mov ah, al				; move to AH
0492+  0EB1             
0493+  0EB1 33 02 00    	mov bl, [d + 2]
0494+  0EB4 37          	mov bh, bl
0495+  0EB5 33 03 00    	mov bl, [d + 3]
0496+  0EB8 07 9A 0C    	call atoi				; convert to int in AL
0497+  0EBB             
0498+  0EBB E7          	pop d
0499+  0EBC E5          	pop b
0500+  0EBD F9          	leave
0501+  0EBE 09          	ret
0502+  0EBF             
0503+  0EBF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0504+  0EBF             ; PRINT 8bit HEX INTEGER
0505+  0EBF             ; integer value in reg bl
0506+  0EBF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  0EBF             print_u8x:
0508+  0EBF D7          	push a
0509+  0EC0 DD          	push bl
0510+  0EC1             
0511+  0EC1 07 AC 0C    	call itoa				; convert bl to char in A
0512+  0EC4 2F          	mov bl, al				; save al
0513+  0EC5 19 00       	mov al, 0
0514+  0EC7 05 03       	syscall sys_io				; display AH
0515+  0EC9 24          	mov ah, bl				; retrieve al
0516+  0ECA 19 00       	mov al, 0
0517+  0ECC 05 03       	syscall sys_io				; display AL
0518+  0ECE             
0519+  0ECE EA          	pop bl
0520+  0ECF E4          	pop a
0521+  0ED0 09          	ret
0522+  0ED1             
0523+  0ED1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0524+  0ED1             ; print 8bit decimal unsigned number
0525+  0ED1             ; input number in AL
0526+  0ED1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  0ED1             print_u8d:
0528+  0ED1 D7          	push a
0529+  0ED2 D8          	push b
0530+  0ED3             
0531+  0ED3 22 00       	mov ah, 0
0532+  0ED5 26 64 00    	mov b, 100
0533+  0ED8 AE          	div a, b
0534+  0ED9 D8          	push b			; save remainder
0535+  0EDA B9 00       	cmp al, 0
0536+  0EDC C6 E6 0E    	je skip100
0537+  0EDF 6A 30       	add al, $30
0538+  0EE1 23          	mov ah, al
0539+  0EE2 19 00       	mov al, 0
0540+  0EE4 05 03       	syscall sys_io	; print coeff
0541+  0EE6             skip100:
0542+  0EE6 E4          	pop a
0543+  0EE7 22 00       	mov ah, 0
0544+  0EE9 26 0A 00    	mov b, 10
0545+  0EEC AE          	div a, b
0546+  0EED D8          	push b			; save remainder
0547+  0EEE B9 00       	cmp al, 0
0548+  0EF0 C6 FA 0E    	je skip10
0549+  0EF3 6A 30       	add al, $30
0550+  0EF5 23          	mov ah, al
0551+  0EF6 19 00       	mov al, 0
0552+  0EF8 05 03       	syscall sys_io	; print coeff
0553+  0EFA             skip10:
0554+  0EFA E4          	pop a
0555+  0EFB 1B          	mov al, bl
0556+  0EFC 6A 30       	add al, $30
0557+  0EFE 23          	mov ah, al
0558+  0EFF 19 00       	mov al, 0
0559+  0F01 05 03       	syscall sys_io	; print coeff
0560+  0F03 E5          	pop b
0561+  0F04 E4          	pop a
0562+  0F05 09          	ret
0563+  0F06             
0564+  0F06             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0565+  0F06             ; INPUT 8BIT HEX INTEGER
0566+  0F06             ; read 8bit integer into AL
0567+  0F06             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  0F06             scan_u8x:
0569+  0F06 F8 04 00    	enter 4
0570+  0F09 D8          	push b
0571+  0F0A DA          	push d
0572+  0F0B             
0573+  0F0B FA FD FF    	lea d, [bp + -3]
0574+  0F0E 07 EC 0C    	call gets				; get number
0575+  0F11             
0576+  0F11 32          	mov bl, [d]
0577+  0F12 37          	mov bh, bl
0578+  0F13 33 01 00    	mov bl, [d + 1]
0579+  0F16 07 9A 0C    	call atoi				; convert to int in AL
0580+  0F19             
0581+  0F19 E7          	pop d
0582+  0F1A E5          	pop b
0583+  0F1B F9          	leave
0584+  0F1C 09          	ret
0585+  0F1D             
0586+  0F1D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  0F1D             ; input decimal number
0588+  0F1D             ; result in A
0589+  0F1D             ; 655'\0'
0590+  0F1D             ; low--------high
0591+  0F1D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0592+  0F1D             scan_u16d:
0593+  0F1D F8 08 00    	enter 8
0594+  0F20 E2          	push si
0595+  0F21 D8          	push b
0596+  0F22 D9          	push c
0597+  0F23 DA          	push d
0598+  0F24 FA F9 FF    	lea d, [bp +- 7]
0599+  0F27 07 EC 0C    	call gets
0600+  0F2A 07 1A 0C    	call strlen			; get string length in C
0601+  0F2D 7E          	dec c
0602+  0F2E FD 4E       	mov si, d
0603+  0F30 12          	mov a, c
0604+  0F31 FD 99       	shl a
0605+  0F33 3B 82 0C    	mov d, table_power
0606+  0F36 59          	add d, a
0607+  0F37 38 00 00    	mov c, 0
0608+  0F3A             mul_loop:
0609+  0F3A F6          	lodsb			; load ASCII to al
0610+  0F3B B9 00       	cmp al, 0
0611+  0F3D C6 50 0F    	je mul_exit
0612+  0F40 6F 30       	sub al, $30		; make into integer
0613+  0F42 22 00       	mov ah, 0
0614+  0F44 2A          	mov b, [d]
0615+  0F45 AC          	mul a, b			; result in B since it fits in 16bits
0616+  0F46 11          	mov a, b
0617+  0F47 28          	mov b, c
0618+  0F48 54          	add a, b
0619+  0F49 39          	mov c, a
0620+  0F4A 63 02 00    	sub d, 2
0621+  0F4D 0A 3A 0F    	jmp mul_loop
0622+  0F50             mul_exit:
0623+  0F50 12          	mov a, c
0624+  0F51 E7          	pop d
0625+  0F52 E6          	pop c
0626+  0F53 E5          	pop b
0627+  0F54 EF          	pop si
0628+  0F55 F9          	leave
0629+  0F56 09          	ret
1146   0F57             ; --- END INCLUDE BLOCK
1147   0F57             
1148   0F57             
1149   0F57             .end
tasm: Number of errors = 0
