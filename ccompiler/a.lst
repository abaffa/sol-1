0001   0000             ; --- FILENAME: strcat.c
0002   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0400             .org PROC_TEXT_ORG
0004   0400             
0005   0400             ; --- BEGIN TEXT BLOCK
0006   0400             main:
0007   0400 D2            push bp
0008   0401 9B            mov bp, sp
0009   0402 29 67 05      mov b, [s1]
0010   0405 FD AB         swp b
0011   0407 D8            push b
0012   0408 07 1D 04      call _strlen
0013   040B 51 02 00      add sp, 2
0014   040E FD AB         swp b
0015   0410 D8            push b
0016   0411 07 1A 05      call printn
0017   0414 51 02 00      add sp, 2
0018   0417 26 00 00      mov b, 0
0019   041A F9            leave
0020   041B 05 0B         syscall sys_terminate_proc
0021   041D             _strlen:
0022   041D D2            push bp
0023   041E 9B            mov bp, sp
0024   041F 52 02 00      sub sp, 2 ; length
0025   0422 26 00 00      mov b, 0
0026   0425 D7            push a
0027   0426 11            mov a, b
0028   0427 45 FF FF      mov [bp + -1], a ; length
0029   042A E4            pop a
0030   042B             _while1_cond:
0031   042B FA 05 00      lea d, [bp + 5] ; str
0032   042E 2A            mov b, [d]
0033   042F D7            push a
0034   0430 11            mov a, b
0035   0431 2C FF FF      mov b, [bp + -1] ; length
0036   0434 54            add a, b
0037   0435 27            mov b, a
0038   0436 E4            pop a
0039   0437 74            mov d, b
0040   0438 D7            push a
0041   0439 11            mov a, b
0042   043A 26 00 00      mov b, 0
0043   043D B0            cmp a, b
0044   043E 0E            lodflgs
0045   043F 87 01         and al, %00000001
0046   0441 8F 01         xor al, %00000001 ; !=
0047   0443 B9 00         cmp al, 0
0048   0445 0E            lodflgs
0049   0446 96            not al
0050   0447 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0051   0449 22 00         mov ah, 0
0052   044B 27            mov b, a
0053   044C E4            pop a
0054   044D C0 00 00      cmp b, 0
0055   0450 C6 61 04      je _while1_exit
0056   0453             _while1_block:
0057   0453 2C FF FF      mov b, [bp + -1] ; length
0058   0456 FD 77         inc b
0059   0458 D7            push a
0060   0459 11            mov a, b
0061   045A 45 FF FF      mov [bp + -1], a ; length
0062   045D E4            pop a
0063   045E 0A 2B 04      jmp _while1_cond
0064   0461             _while1_exit:
0065   0461 2C FF FF      mov b, [bp + -1] ; length
0066   0464 F9            leave
0067   0465 09            ret
0068   0466             _strcat:
0069   0466 D2            push bp
0070   0467 9B            mov bp, sp
0071   0468 52 02 00      sub sp, 2 ; dest_len
0072   046B 52 02 00      sub sp, 2 ; i
0073   046E FA 07 00      lea d, [bp + 7] ; dest
0074   0471 2A            mov b, [d]
0075   0472 FD AB         swp b
0076   0474 D8            push b
0077   0475 07 1D 04      call _strlen
0078   0478 51 02 00      add sp, 2
0079   047B D7            push a
0080   047C 11            mov a, b
0081   047D 45 FF FF      mov [bp + -1], a ; dest_len
0082   0480 E4            pop a
0083   0481             _for2_init:
0084   0481 26 00 00      mov b, 0
0085   0484 D7            push a
0086   0485 11            mov a, b
0087   0486 45 FD FF      mov [bp + -3], a ; i
0088   0489 E4            pop a
0089   048A             _for2_cond:
0090   048A FA 05 00      lea d, [bp + 5] ; src
0091   048D 2A            mov b, [d]
0092   048E D7            push a
0093   048F 11            mov a, b
0094   0490 2C FD FF      mov b, [bp + -3] ; i
0095   0493 54            add a, b
0096   0494 27            mov b, a
0097   0495 E4            pop a
0098   0496 74            mov d, b
0099   0497 32            mov bl, [d]
0100   0498 A7 00         mov bh, 0
0101   049A D7            push a
0102   049B 11            mov a, b
0103   049C 26 00 00      mov b, 0
0104   049F B0            cmp a, b
0105   04A0 0E            lodflgs
0106   04A1 87 01         and al, %00000001
0107   04A3 8F 01         xor al, %00000001 ; !=
0108   04A5 B9 00         cmp al, 0
0109   04A7 0E            lodflgs
0110   04A8 96            not al
0111   04A9 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0112   04AB 22 00         mov ah, 0
0113   04AD 27            mov b, a
0114   04AE E4            pop a
0115   04AF C0 00 00      cmp b, 0
0116   04B2 C6 E5 04      je _for2_exit
0117   04B5             _for2_block:
0118   04B5 FA 07 00      lea d, [bp + 7] ; dest
0119   04B8 2A            mov b, [d]
0120   04B9 D7            push a
0121   04BA 11            mov a, b
0122   04BB 2C FF FF      mov b, [bp + -1] ; dest_len
0123   04BE 54            add a, b
0124   04BF 27            mov b, a
0125   04C0 11            mov a, b
0126   04C1 2C FD FF      mov b, [bp + -3] ; i
0127   04C4 54            add a, b
0128   04C5 27            mov b, a
0129   04C6 E4            pop a
0130   04C7 74            mov d, b
0131   04C8 FA 05 00      lea d, [bp + 5] ; src
0132   04CB 2A            mov b, [d]
0133   04CC D7            push a
0134   04CD 11            mov a, b
0135   04CE 2C FD FF      mov b, [bp + -3] ; i
0136   04D1 54            add a, b
0137   04D2 27            mov b, a
0138   04D3 E4            pop a
0139   04D4 74            mov d, b
0140   04D5 11            mov a, b
0141   04D6 43            mov [d], a
0142   04D7             _for2_update:
0143   04D7 2C FD FF      mov b, [bp + -3] ; i
0144   04DA FD 77         inc b
0145   04DC D7            push a
0146   04DD 11            mov a, b
0147   04DE 45 FD FF      mov [bp + -3], a ; i
0148   04E1 E4            pop a
0149   04E2 0A 8A 04      jmp _for2_cond
0150   04E5             _for2_exit:
0151   04E5 FA 07 00      lea d, [bp + 7] ; dest
0152   04E8 2A            mov b, [d]
0153   04E9 D7            push a
0154   04EA 11            mov a, b
0155   04EB 2C FF FF      mov b, [bp + -1] ; dest_len
0156   04EE 54            add a, b
0157   04EF 27            mov b, a
0158   04F0 11            mov a, b
0159   04F1 2C FD FF      mov b, [bp + -3] ; i
0160   04F4 54            add a, b
0161   04F5 27            mov b, a
0162   04F6 E4            pop a
0163   04F7 74            mov d, b
0164   04F8 26 00 00      mov b, 0
0165   04FB 11            mov a, b
0166   04FC 43            mov [d], a
0167   04FD FA 07 00      lea d, [bp + 7] ; dest
0168   0500 2A            mov b, [d]
0169   0501 F9            leave
0170   0502 09            ret
0171   0503             scann:
0172   0503 D2            push bp
0173   0504 9B            mov bp, sp
0174   0505 52 02 00      sub sp, 2 ; m
0175   0508             
0176   0508             ; --- BEGIN INLINE ASM BLOCK
0177   0508 07 C9 08      call scan_u16d
0178   050B 45 FF FF      mov [bp + -1], a
0179   050E             ; --- END INLINE ASM BLOCK
0180   050E             
0181   050E FA 05 00      lea d, [bp + 5] ; n
0182   0511 2A            mov b, [d]
0183   0512 74            mov d, b
0184   0513 2C FF FF      mov b, [bp + -1] ; m
0185   0516 11            mov a, b
0186   0517 43            mov [d], a
0187   0518 F9            leave
0188   0519 09            ret
0189   051A             printn:
0190   051A D2            push bp
0191   051B 9B            mov bp, sp
0192   051C             
0193   051C             ; --- BEGIN INLINE ASM BLOCK
0194   051C 17 05 00      mov a, [bp + 5]
0195   051F 07 F4 07      call print_u16d
0196   0522             ; --- END INLINE ASM BLOCK
0197   0522             
0198   0522 F9            leave
0199   0523 09            ret
0200   0524             print:
0201   0524 D2            push bp
0202   0525 9B            mov bp, sp
0203   0526             
0204   0526             ; --- BEGIN INLINE ASM BLOCK
0205   0526 17 05 00      mov a, [bp + 5]
0206   0529 3C            mov d, a
0207   052A 07 CB 07      call puts
0208   052D             ; --- END INLINE ASM BLOCK
0209   052D             
0210   052D F9            leave
0211   052E 09            ret
0212   052F             ; --- END TEXT BLOCK
0213   052F             
0214   052F             ; --- BEGIN DATA BLOCK
0215   052F             s1_data: 
0216   052F 48 00 65 00 .dw 'H', 'e', 'l', 'l', 'o', 0,
0216   0533 6C 00 6C 00 
0216   0537 6F 00 00 00 
0217   053B 00 00 00 00 .fill 44, 0
0217   053F 00 00 00 00 
0217   0543 00 00 00 00 
0217   0547 00 00 00 00 
0217   054B 00 00 00 00 
0217   054F 00 00 00 00 
0217   0553 00 00 00 00 
0217   0557 00 00 00 00 
0217   055B 00 00 00 00 
0217   055F 00 00 00 00 
0217   0563 00 00 00 00 
0218   0567 2F 05       s1: .dw s1_data
0219   0569 2E 20 4D 79 s2_data: .db ". My name is Sol-1.", 0
0219   056D 20 6E 61 6D 
0219   0571 65 20 69 73 
0219   0575 20 53 6F 6C 
0219   0579 2D 31 2E 00 
0220   057D 69 05       s2: .dw s2_data
0221   057F             ; --- END DATA BLOCK
0222   057F             
0223   057F             ; --- BEGIN INCLUDE BLOCK
0224   057F             .include "lib/stdio.asm"
0001+  057F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  057F             ; stdio.s
0003+  057F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  057F             .include "lib/string.asm"
0001++ 057F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 057F             ; string.s
0003++ 057F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 057F             
0005++ 057F             
0006++ 057F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 057F             ; strrev
0008++ 057F             ; reverse a string
0009++ 057F             ; D = string address
0010++ 057F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 057F             ; 01234
0012++ 057F             strrev:
0013++ 057F 4B          	pusha
0014++ 0580 07 C6 05    	call strlen	; length in C
0015++ 0583 12          	mov a, c
0016++ 0584 AF 01 00    	cmp a, 1
0017++ 0587 D0 A1 05    	jleu strrev_end	; check string length. string len must be > 1
0018++ 058A 7D          	dec a
0019++ 058B FD 4E       	mov si, d	; beginning of string
0020++ 058D FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 058F 59          	add d, a	; end of string
0022++ 0590 12          	mov a, c
0023++ 0591 FD 9B       	shr a		; divide by 2
0024++ 0593 39          	mov c, a	; C now counts the steps
0025++ 0594             strrev_L0:
0026++ 0594 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0595 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0596 3E          	mov [d], al	; store left char into right side
0029++ 0597 1B          	mov al, bl
0030++ 0598 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0599 7E          	dec c
0032++ 059A 7F          	dec d
0033++ 059B C2 00 00    	cmp c, 0
0034++ 059E C7 94 05    	jne strrev_L0
0035++ 05A1             strrev_end:
0036++ 05A1 4C          	popa
0037++ 05A2 09          	ret
0038++ 05A3             	
0039++ 05A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 05A3             ; strchr
0041++ 05A3             ; search string in D for char in AL
0042++ 05A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 05A3             strchr:
0044++ 05A3             strchr_L0:
0045++ 05A3 32          	mov bl, [d]
0046++ 05A4 C1 00       	cmp bl, 0
0047++ 05A6 C6 B1 05    	je strchr_end
0048++ 05A9 BA          	cmp al, bl
0049++ 05AA C6 B1 05    	je strchr_end
0050++ 05AD 79          	inc d
0051++ 05AE 0A A3 05    	jmp strchr_L0
0052++ 05B1             strchr_end:
0053++ 05B1 1B          	mov al, bl
0054++ 05B2 09          	ret
0055++ 05B3             
0056++ 05B3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 05B3             ; strstr
0058++ 05B3             ; find sub-string
0059++ 05B3             ; str1 in SI
0060++ 05B3             ; str2 in DI
0061++ 05B3             ; SI points to end of source string
0062++ 05B3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 05B3             strstr:
0064++ 05B3 DB          	push al
0065++ 05B4 DA          	push d
0066++ 05B5 E3          	push di
0067++ 05B6             strstr_loop:
0068++ 05B6 F3          	cmpsb					; compare a byte of the strings
0069++ 05B7 C7 C2 05    	jne strstr_ret
0070++ 05BA FC 00 00    	lea d, [di + 0]
0071++ 05BD BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 05BF C7 B6 05    	jne strstr_loop				; equal chars but not at end
0073++ 05C2             strstr_ret:
0074++ 05C2 F0          	pop di
0075++ 05C3 E7          	pop d
0076++ 05C4 E8          	pop al
0077++ 05C5 09          	ret
0078++ 05C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 05C6             ; length of null terminated string
0080++ 05C6             ; result in C
0081++ 05C6             ; pointer in D
0082++ 05C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 05C6             strlen:
0084++ 05C6 DA          	push d
0085++ 05C7 38 00 00    	mov c, 0
0086++ 05CA             strlen_L1:
0087++ 05CA BD 00       	cmp byte [d], 0
0088++ 05CC C6 D4 05    	je strlen_ret
0089++ 05CF 79          	inc d
0090++ 05D0 78          	inc c
0091++ 05D1 0A CA 05    	jmp strlen_L1
0092++ 05D4             strlen_ret:
0093++ 05D4 E7          	pop d
0094++ 05D5 09          	ret
0095++ 05D6             
0096++ 05D6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 05D6             ; STRCMP
0098++ 05D6             ; compare two strings
0099++ 05D6             ; str1 in SI
0100++ 05D6             ; str2 in DI
0101++ 05D6             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 05D6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 05D6             strcmp:
0104++ 05D6 DB          	push al
0105++ 05D7 DA          	push d
0106++ 05D8 E3          	push di
0107++ 05D9 E2          	push si
0108++ 05DA             strcmp_loop:
0109++ 05DA F3          	cmpsb					; compare a byte of the strings
0110++ 05DB C7 E6 05    	jne strcmp_ret
0111++ 05DE FB FF FF    	lea d, [si +- 1]
0112++ 05E1 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 05E3 C7 DA 05    	jne strcmp_loop				; equal chars but not at end
0114++ 05E6             strcmp_ret:
0115++ 05E6 EF          	pop si
0116++ 05E7 F0          	pop di
0117++ 05E8 E7          	pop d
0118++ 05E9 E8          	pop al
0119++ 05EA 09          	ret
0120++ 05EB             
0121++ 05EB             
0122++ 05EB             ; STRCPY
0123++ 05EB             ; copy null terminated string from SI to DI
0124++ 05EB             ; source in SI
0125++ 05EB             ; destination in DI
0126++ 05EB             strcpy:
0127++ 05EB E2          	push si
0128++ 05EC E3          	push di
0129++ 05ED DB          	push al
0130++ 05EE             strcpy_L1:
0131++ 05EE F6          	lodsb
0132++ 05EF F7          	stosb
0133++ 05F0 B9 00       	cmp al, 0
0134++ 05F2 C7 EE 05    	jne strcpy_L1
0135++ 05F5             strcpy_end:
0136++ 05F5 E8          	pop al
0137++ 05F6 F0          	pop di
0138++ 05F7 EF          	pop si
0139++ 05F8 09          	ret
0140++ 05F9             
0141++ 05F9             ; STRCAT
0142++ 05F9             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 05F9             ; source in SI
0144++ 05F9             ; destination in DI
0145++ 05F9             strcat:
0146++ 05F9 E2          	push si
0147++ 05FA E3          	push di
0148++ 05FB D7          	push a
0149++ 05FC DA          	push d
0150++ 05FD 50          	mov a, di
0151++ 05FE 3C          	mov d, a
0152++ 05FF             strcat_goto_end_L1:
0153++ 05FF BD 00       	cmp byte[d], 0
0154++ 0601 C6 08 06    	je strcat_start
0155++ 0604 79          	inc d
0156++ 0605 0A FF 05    	jmp strcat_goto_end_L1
0157++ 0608             strcat_start:
0158++ 0608 FD 50       	mov di, d
0159++ 060A             strcat_L1:
0160++ 060A F6          	lodsb
0161++ 060B F7          	stosb
0162++ 060C B9 00       	cmp al, 0
0163++ 060E C7 0A 06    	jne strcat_L1
0164++ 0611             strcat_end:
0165++ 0611 E7          	pop d
0166++ 0612 E4          	pop a
0167++ 0613 F0          	pop di
0168++ 0614 EF          	pop si
0169++ 0615 09          	ret
0005+  0616             
0006+  0616 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  061A 34 35 36 37 
0006+  061E 38 39 41 42 
0006+  0622 43 44 45 46 
0007+  0626 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  062A 1B 5B 48 00 
0008+  062E             
0009+  062E 01 00       table_power:.dw 1
0010+  0630 0A 00       			.dw 10
0011+  0632 64 00       			.dw 100
0012+  0634 E8 03       			.dw 1000
0013+  0636 10 27       			.dw 10000
0014+  0638             
0015+  0638             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  0638             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  0638             ; ASCII in BL
0018+  0638             ; result in AL
0019+  0638             ; ascii for F = 0100 0110
0020+  0638             ; ascii for 9 = 0011 1001
0021+  0638             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  0638             hex_ascii_encode:
0023+  0638 1B          	mov al, bl
0024+  0639 93 40       	test al, $40				; test if letter or number
0025+  063B C7 41 06    	jnz hex_letter
0026+  063E 87 0F       	and al, $0F				; get number
0027+  0640 09          	ret
0028+  0641             hex_letter:
0029+  0641 87 0F       	and al, $0F				; get letter
0030+  0643 6A 09       	add al, 9
0031+  0645 09          	ret
0032+  0646             
0033+  0646             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  0646             ; ATOI
0035+  0646             ; 2 letter hex string in B
0036+  0646             ; 8bit integer returned in AL
0037+  0646             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0646             atoi:
0039+  0646 D8          	push b
0040+  0647 07 38 06    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  064A 30          	mov bl, bh
0042+  064B DB          	push al					; save a
0043+  064C 07 38 06    	call hex_ascii_encode
0044+  064F EA          	pop bl	
0045+  0650 FD 9E 04    	shl al, 4
0046+  0653 8C          	or al, bl
0047+  0654 E5          	pop b
0048+  0655 09          	ret	
0049+  0656             
0050+  0656             
0051+  0656             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  0656             ; printf
0053+  0656             ; no need for explanations!
0054+  0656             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0656             printf:
0056+  0656 09          	ret
0057+  0657             
0058+  0657             
0059+  0657             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  0657             ; scanf
0061+  0657             ; no need for explanations!
0062+  0657             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  0657             scanf:
0064+  0657 09          	ret
0065+  0658             
0066+  0658             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  0658             ; ITOA
0068+  0658             ; 8bit value in BL
0069+  0658             ; 2 byte ASCII result in A
0070+  0658             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  0658             itoa:
0072+  0658 DA          	push d
0073+  0659 D8          	push b
0074+  065A A7 00       	mov bh, 0
0075+  065C FD A4 04    	shr bl, 4	
0076+  065F 74          	mov d, b
0077+  0660 1F 16 06    	mov al, [d + s_hex_digits]
0078+  0663 23          	mov ah, al
0079+  0664             	
0080+  0664 E5          	pop b
0081+  0665 D8          	push b
0082+  0666 A7 00       	mov bh, 0
0083+  0668 FD 87 0F    	and bl, $0F
0084+  066B 74          	mov d, b
0085+  066C 1F 16 06    	mov al, [d + s_hex_digits]
0086+  066F E5          	pop b
0087+  0670 E7          	pop d
0088+  0671 09          	ret
0089+  0672             
0090+  0672             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  0672             ; HEX STRING TO BINARY
0092+  0672             ; di = destination address
0093+  0672             ; si = source
0094+  0672             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  0672             hex_to_int:
0096+  0672             hex_to_int_L1:
0097+  0672 F6          	lodsb					; load from [SI] to AL
0098+  0673 B9 00       	cmp al, 0				; check if ASCII 0
0099+  0675 C6 82 06    	jz hex_to_int_ret
0100+  0678 36          	mov bh, al
0101+  0679 F6          	lodsb
0102+  067A 2F          	mov bl, al
0103+  067B 07 46 06    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  067E F7          	stosb					; store AL to [DI]
0105+  067F 0A 72 06    	jmp hex_to_int_L1
0106+  0682             hex_to_int_ret:
0107+  0682 09          	ret		
0108+  0683             
0109+  0683             
0110+  0683             
0111+  0683             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  0683             ; GETCHAR
0113+  0683             ; char in ah
0114+  0683             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  0683             getchar:
0116+  0683 DB          	push al
0117+  0684             getchar_retry:
0118+  0684 FD 0C       	sti
0119+  0686 19 01       	mov al, 1
0120+  0688 05 03       	syscall sys_io			; receive in AH
0121+  068A B9 00       	cmp al, 0			; check if any char was receive
0122+  068C C6 84 06    	je getchar_retry
0123+  068F E8          	pop al
0124+  0690 09          	ret
0125+  0691             
0126+  0691             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  0691             ; PUTCHAR
0128+  0691             ; char in ah
0129+  0691             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0691             putchar:
0131+  0691 D7          	push a
0132+  0692 19 00       	mov al, 0
0133+  0694 05 03       	syscall sys_io			; char in AH
0134+  0696 E4          	pop a
0135+  0697 09          	ret
0136+  0698             
0137+  0698             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  0698             ;; INPUT A STRING
0139+  0698             ;; terminates with null
0140+  0698             ;; pointer in D
0141+  0698             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  0698             gets:
0143+  0698 D7          	push a
0144+  0699 DA          	push d
0145+  069A             gets_loop:
0146+  069A FD 0C       	sti
0147+  069C 19 01       	mov al, 1
0148+  069E 05 03       	syscall sys_io			; receive in AH
0149+  06A0 B9 00       	cmp al, 0				; check error code (AL)
0150+  06A2 C6 9A 06    	je gets_loop			; if no char received, retry
0151+  06A5             
0152+  06A5 76 1B       	cmp ah, 27
0153+  06A7 C6 C8 06    	je gets_telnet_escape
0154+  06AA 76 0A       	cmp ah, $0A				; LF
0155+  06AC C6 21 07    	je gets_end
0156+  06AF 76 0D       	cmp ah, $0D				; CR
0157+  06B1 C6 21 07    	je gets_end
0158+  06B4 76 5C       	cmp ah, $5C				; '\\'
0159+  06B6 C6 F8 06    	je gets_escape
0160+  06B9             	
0161+  06B9 76 08       	cmp ah, $08			; check for backspace
0162+  06BB C6 C4 06    	je gets_backspace
0163+  06BE             
0164+  06BE 1A          	mov al, ah
0165+  06BF 3E          	mov [d], al
0166+  06C0 79          	inc d
0167+  06C1 0A 9A 06    	jmp gets_loop
0168+  06C4             gets_backspace:
0169+  06C4 7F          	dec d
0170+  06C5 0A 9A 06    	jmp gets_loop
0171+  06C8             gets_telnet_escape:
0172+  06C8 FD 0C       	sti
0173+  06CA 19 01       	mov al, 1
0174+  06CC 05 03       	syscall sys_io				; receive in AH without echo
0175+  06CE B9 00       	cmp al, 0					; check error code (AL)
0176+  06D0 C6 C8 06    	je gets_telnet_escape		; if no char received, retry
0177+  06D3 76 5B       	cmp ah, '['
0178+  06D5 C7 9A 06    	jne gets_loop
0179+  06D8             gets_telnet_escape_phase2:
0180+  06D8 FD 0C       	sti
0181+  06DA 19 01       	mov al, 1
0182+  06DC 05 03       	syscall sys_io					; receive in AH without echo
0183+  06DE B9 00       	cmp al, 0						; check error code (AL)
0184+  06E0 C6 D8 06    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  06E3 76 44       	cmp ah, 'D'
0186+  06E5 C6 F0 06    	je gets_left_arrow
0187+  06E8 76 43       	cmp ah, 'C'
0188+  06EA C6 F4 06    	je gets_right_arrow
0189+  06ED 0A 9A 06    	jmp gets_loop
0190+  06F0             gets_left_arrow:
0191+  06F0 7F          	dec d
0192+  06F1 0A 9A 06    	jmp gets_loop
0193+  06F4             gets_right_arrow:
0194+  06F4 79          	inc d
0195+  06F5 0A 9A 06    	jmp gets_loop
0196+  06F8             gets_escape:
0197+  06F8 FD 0C       	sti
0198+  06FA 19 01       	mov al, 1
0199+  06FC 05 03       	syscall sys_io			; receive in AH
0200+  06FE B9 00       	cmp al, 0				; check error code (AL)
0201+  0700 C6 F8 06    	je gets_escape			; if no char received, retry
0202+  0703 76 6E       	cmp ah, 'n'
0203+  0705 C6 13 07    	je gets_LF
0204+  0708 76 72       	cmp ah, 'r'
0205+  070A C6 1A 07    	je gets_CR
0206+  070D 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  070E 3E          	mov [d], al
0208+  070F 79          	inc d
0209+  0710 0A 9A 06    	jmp gets_loop
0210+  0713             gets_LF:
0211+  0713 19 0A       	mov al, $0A
0212+  0715 3E          	mov [d], al
0213+  0716 79          	inc d
0214+  0717 0A 9A 06    	jmp gets_loop
0215+  071A             gets_CR:
0216+  071A 19 0D       	mov al, $0D
0217+  071C 3E          	mov [d], al
0218+  071D 79          	inc d
0219+  071E 0A 9A 06    	jmp gets_loop
0220+  0721             gets_end:
0221+  0721 19 00       	mov al, 0
0222+  0723 3E          	mov [d], al				; terminate string
0223+  0724 E7          	pop d
0224+  0725 E4          	pop a
0225+  0726 09          	ret
0226+  0727             
0227+  0727             
0228+  0727             
0229+  0727             
0230+  0727             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  0727             ;; INPUT TEXT
0232+  0727             ;; terminated with CTRL+D
0233+  0727             ;; pointer in D
0234+  0727             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  0727             gettxt:
0236+  0727 D7          	push a
0237+  0728 DA          	push d
0238+  0729             gettxt_loop:
0239+  0729 19 01       	mov al, 1
0240+  072B 05 03       	syscall sys_io			; receive in AH
0241+  072D B9 00       	cmp al, 0				; check error code (AL)
0242+  072F C6 29 07    	je gettxt_loop		; if no char received, retry
0243+  0732 76 04       	cmp ah, 4			; EOT
0244+  0734 C6 72 07    	je gettxt_end
0245+  0737 76 08       	cmp ah, $08			; check for backspace
0246+  0739 C6 6E 07    	je gettxt_backspace
0247+  073C 76 5C       	cmp ah, $5C				; '\\'
0248+  073E C6 47 07    	je gettxt_escape
0249+  0741 1A          	mov al, ah
0250+  0742 3E          	mov [d], al
0251+  0743 79          	inc d
0252+  0744 0A 29 07    	jmp gettxt_loop
0253+  0747             gettxt_escape:
0254+  0747 19 01       	mov al, 1
0255+  0749 05 03       	syscall sys_io			; receive in AH
0256+  074B B9 00       	cmp al, 0				; check error code (AL)
0257+  074D C6 47 07    	je gettxt_escape		; if no char received, retry
0258+  0750 76 6E       	cmp ah, 'n'
0259+  0752 C6 60 07    	je gettxt_LF
0260+  0755 76 72       	cmp ah, 'r'
0261+  0757 C6 67 07    	je gettxt_CR
0262+  075A 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  075B 3E          	mov [d], al
0264+  075C 79          	inc d
0265+  075D 0A 29 07    	jmp gettxt_loop
0266+  0760             gettxt_LF:
0267+  0760 19 0A       	mov al, $0A
0268+  0762 3E          	mov [d], al
0269+  0763 79          	inc d
0270+  0764 0A 29 07    	jmp gettxt_loop
0271+  0767             gettxt_CR:
0272+  0767 19 0D       	mov al, $0D
0273+  0769 3E          	mov [d], al
0274+  076A 79          	inc d
0275+  076B 0A 29 07    	jmp gettxt_loop
0276+  076E             gettxt_backspace:
0277+  076E 7F          	dec d
0278+  076F 0A 29 07    	jmp gettxt_loop
0279+  0772             gettxt_end:
0280+  0772 19 00       	mov al, 0
0281+  0774 3E          	mov [d], al				; terminate string
0282+  0775 E7          	pop d
0283+  0776 E4          	pop a
0284+  0777 09          	ret
0285+  0778             
0286+  0778             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  0778             ; PRINT NEW LINE
0288+  0778             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  0778             printnl:
0290+  0778 D7          	push a
0291+  0779 10 00 0A    	mov a, $0A00
0292+  077C 05 03       	syscall sys_io
0293+  077E 10 00 0D    	mov a, $0D00
0294+  0781 05 03       	syscall sys_io
0295+  0783 E4          	pop a
0296+  0784 09          	ret
0297+  0785             
0298+  0785             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  0785             ; strtoint
0300+  0785             ; 4 digit hex string number in d
0301+  0785             ; integer returned in A
0302+  0785             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  0785             strtointx:
0304+  0785 D8          	push b
0305+  0786 32          	mov bl, [d]
0306+  0787 37          	mov bh, bl
0307+  0788 33 01 00    	mov bl, [d + 1]
0308+  078B 07 46 06    	call atoi				; convert to int in AL
0309+  078E 23          	mov ah, al				; move to AH
0310+  078F 33 02 00    	mov bl, [d + 2]
0311+  0792 37          	mov bh, bl
0312+  0793 33 03 00    	mov bl, [d + 3]
0313+  0796 07 46 06    	call atoi				; convert to int in AL
0314+  0799 E5          	pop b
0315+  079A 09          	ret
0316+  079B             
0317+  079B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  079B             ; strtoint
0319+  079B             ; 5 digit base10 string number in d
0320+  079B             ; integer returned in A
0321+  079B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  079B             strtoint:
0323+  079B E2          	push si
0324+  079C D8          	push b
0325+  079D D9          	push c
0326+  079E DA          	push d
0327+  079F 07 C6 05    	call strlen			; get string length in C
0328+  07A2 7E          	dec c
0329+  07A3 FD 4E       	mov si, d
0330+  07A5 12          	mov a, c
0331+  07A6 FD 99       	shl a
0332+  07A8 3B 2E 06    	mov d, table_power
0333+  07AB 59          	add d, a
0334+  07AC 38 00 00    	mov c, 0
0335+  07AF             strtoint_L0:
0336+  07AF F6          	lodsb			; load ASCII to al
0337+  07B0 B9 00       	cmp al, 0
0338+  07B2 C6 C5 07    	je strtoint_end
0339+  07B5 6F 30       	sub al, $30		; make into integer
0340+  07B7 22 00       	mov ah, 0
0341+  07B9 2A          	mov b, [d]
0342+  07BA AC          	mul a, b			; result in B since it fits in 16bits
0343+  07BB 11          	mov a, b
0344+  07BC 28          	mov b, c
0345+  07BD 54          	add a, b
0346+  07BE 39          	mov c, a
0347+  07BF 63 02 00    	sub d, 2
0348+  07C2 0A AF 07    	jmp strtoint_L0
0349+  07C5             strtoint_end:
0350+  07C5 12          	mov a, c
0351+  07C6 E7          	pop d
0352+  07C7 E6          	pop c
0353+  07C8 E5          	pop b
0354+  07C9 EF          	pop si
0355+  07CA 09          	ret
0356+  07CB             
0357+  07CB             
0358+  07CB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  07CB             ; PRINT NULL TERMINATED STRING
0360+  07CB             ; pointer in D
0361+  07CB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  07CB             puts:
0363+  07CB D7          	push a
0364+  07CC DA          	push d
0365+  07CD             puts_L1:
0366+  07CD 1E          	mov al, [d]
0367+  07CE B9 00       	cmp al, 0
0368+  07D0 C6 DC 07    	jz puts_END
0369+  07D3 23          	mov ah, al
0370+  07D4 19 00       	mov al, 0
0371+  07D6 05 03       	syscall sys_io
0372+  07D8 79          	inc d
0373+  07D9 0A CD 07    	jmp puts_L1
0374+  07DC             puts_END:
0375+  07DC E7          	pop d
0376+  07DD E4          	pop a
0377+  07DE 09          	ret
0378+  07DF             
0379+  07DF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  07DF             ; PRINT N SIZE STRING
0381+  07DF             ; pointer in D
0382+  07DF             ; size in C
0383+  07DF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  07DF             putsn:
0385+  07DF DB          	push al
0386+  07E0 DA          	push d
0387+  07E1 D9          	push c
0388+  07E2             putsn_L0:
0389+  07E2 1E          	mov al, [d]
0390+  07E3 23          	mov ah, al
0391+  07E4 19 00       	mov al, 0
0392+  07E6 05 03       	syscall sys_io
0393+  07E8 79          	inc d
0394+  07E9 7E          	dec c	
0395+  07EA C2 00 00    	cmp c, 0
0396+  07ED C7 E2 07    	jne putsn_L0
0397+  07F0             putsn_end:
0398+  07F0 E6          	pop c
0399+  07F1 E7          	pop d
0400+  07F2 E8          	pop al
0401+  07F3 09          	ret
0402+  07F4             
0403+  07F4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  07F4             ; print 16bit decimal number
0405+  07F4             ; input number in A
0406+  07F4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  07F4             print_u16d:
0408+  07F4 D7          	push a
0409+  07F5 D8          	push b
0410+  07F6 26 10 27    	mov b, 10000
0411+  07F9 AE          	div a, b			; get 10000 coeff.
0412+  07FA 07 20 08    	call print_number
0413+  07FD 11          	mov a, b
0414+  07FE 26 E8 03    	mov b, 1000
0415+  0801 AE          	div a, b			; get 10000 coeff.
0416+  0802 07 20 08    	call print_number
0417+  0805 11          	mov a, b
0418+  0806 26 64 00    	mov b, 100
0419+  0809 AE          	div a, b
0420+  080A 07 20 08    	call print_number
0421+  080D 11          	mov a, b
0422+  080E 26 0A 00    	mov b, 10
0423+  0811 AE          	div a, b
0424+  0812 07 20 08    	call print_number
0425+  0815 11          	mov a, b
0426+  0816 6A 30       	add al, $30
0427+  0818 23          	mov ah, al
0428+  0819 19 00       	mov al, 0
0429+  081B 05 03       	syscall sys_io	; print coeff
0430+  081D E5          	pop b
0431+  081E E4          	pop a
0432+  081F 09          	ret
0433+  0820             
0434+  0820             
0435+  0820             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  0820             ; if A == 0, print space
0437+  0820             ; else print A
0438+  0820             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0439+  0820             print_number:
0440+  0820 6A 30       	add al, $30
0441+  0822 23          	mov ah, al
0442+  0823 07 91 06    	call putchar
0443+  0826 09          	ret
0444+  0827             
0445+  0827             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0446+  0827             ; PRINT 16BIT HEX INTEGER
0447+  0827             ; integer value in reg B
0448+  0827             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  0827             print_u16x:
0450+  0827 D7          	push a
0451+  0828 D8          	push b
0452+  0829 DD          	push bl
0453+  082A 30          	mov bl, bh
0454+  082B 07 58 06    	call itoa				; convert bh to char in A
0455+  082E 2F          	mov bl, al				; save al
0456+  082F 19 00       	mov al, 0
0457+  0831 05 03       	syscall sys_io				; display AH
0458+  0833 24          	mov ah, bl				; retrieve al
0459+  0834 19 00       	mov al, 0
0460+  0836 05 03       	syscall sys_io				; display AL
0461+  0838             
0462+  0838 EA          	pop bl
0463+  0839 07 58 06    	call itoa				; convert bh to char in A
0464+  083C 2F          	mov bl, al				; save al
0465+  083D 19 00       	mov al, 0
0466+  083F 05 03       	syscall sys_io				; display AH
0467+  0841 24          	mov ah, bl				; retrieve al
0468+  0842 19 00       	mov al, 0
0469+  0844 05 03       	syscall sys_io				; display AL
0470+  0846             
0471+  0846 E5          	pop b
0472+  0847 E4          	pop a
0473+  0848 09          	ret
0474+  0849             
0475+  0849             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  0849             ; INPUT 16BIT HEX INTEGER
0477+  0849             ; read 16bit integer into A
0478+  0849             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  0849             scan_u16x:
0480+  0849 F8 10 00    	enter 16
0481+  084C D8          	push b
0482+  084D DA          	push d
0483+  084E             
0484+  084E FA F1 FF    	lea d, [bp + -15]
0485+  0851 07 98 06    	call gets				; get number
0486+  0854             
0487+  0854 32          	mov bl, [d]
0488+  0855 37          	mov bh, bl
0489+  0856 33 01 00    	mov bl, [d + 1]
0490+  0859 07 46 06    	call atoi				; convert to int in AL
0491+  085C 23          	mov ah, al				; move to AH
0492+  085D             
0493+  085D 33 02 00    	mov bl, [d + 2]
0494+  0860 37          	mov bh, bl
0495+  0861 33 03 00    	mov bl, [d + 3]
0496+  0864 07 46 06    	call atoi				; convert to int in AL
0497+  0867             
0498+  0867 E7          	pop d
0499+  0868 E5          	pop b
0500+  0869 F9          	leave
0501+  086A 09          	ret
0502+  086B             
0503+  086B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0504+  086B             ; PRINT 8bit HEX INTEGER
0505+  086B             ; integer value in reg bl
0506+  086B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  086B             print_u8x:
0508+  086B D7          	push a
0509+  086C DD          	push bl
0510+  086D             
0511+  086D 07 58 06    	call itoa				; convert bl to char in A
0512+  0870 2F          	mov bl, al				; save al
0513+  0871 19 00       	mov al, 0
0514+  0873 05 03       	syscall sys_io				; display AH
0515+  0875 24          	mov ah, bl				; retrieve al
0516+  0876 19 00       	mov al, 0
0517+  0878 05 03       	syscall sys_io				; display AL
0518+  087A             
0519+  087A EA          	pop bl
0520+  087B E4          	pop a
0521+  087C 09          	ret
0522+  087D             
0523+  087D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0524+  087D             ; print 8bit decimal unsigned number
0525+  087D             ; input number in AL
0526+  087D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  087D             print_u8d:
0528+  087D D7          	push a
0529+  087E D8          	push b
0530+  087F             
0531+  087F 22 00       	mov ah, 0
0532+  0881 26 64 00    	mov b, 100
0533+  0884 AE          	div a, b
0534+  0885 D8          	push b			; save remainder
0535+  0886 B9 00       	cmp al, 0
0536+  0888 C6 92 08    	je skip100
0537+  088B 6A 30       	add al, $30
0538+  088D 23          	mov ah, al
0539+  088E 19 00       	mov al, 0
0540+  0890 05 03       	syscall sys_io	; print coeff
0541+  0892             skip100:
0542+  0892 E4          	pop a
0543+  0893 22 00       	mov ah, 0
0544+  0895 26 0A 00    	mov b, 10
0545+  0898 AE          	div a, b
0546+  0899 D8          	push b			; save remainder
0547+  089A B9 00       	cmp al, 0
0548+  089C C6 A6 08    	je skip10
0549+  089F 6A 30       	add al, $30
0550+  08A1 23          	mov ah, al
0551+  08A2 19 00       	mov al, 0
0552+  08A4 05 03       	syscall sys_io	; print coeff
0553+  08A6             skip10:
0554+  08A6 E4          	pop a
0555+  08A7 1B          	mov al, bl
0556+  08A8 6A 30       	add al, $30
0557+  08AA 23          	mov ah, al
0558+  08AB 19 00       	mov al, 0
0559+  08AD 05 03       	syscall sys_io	; print coeff
0560+  08AF E5          	pop b
0561+  08B0 E4          	pop a
0562+  08B1 09          	ret
0563+  08B2             
0564+  08B2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0565+  08B2             ; INPUT 8BIT HEX INTEGER
0566+  08B2             ; read 8bit integer into AL
0567+  08B2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  08B2             scan_u8x:
0569+  08B2 F8 04 00    	enter 4
0570+  08B5 D8          	push b
0571+  08B6 DA          	push d
0572+  08B7             
0573+  08B7 FA FD FF    	lea d, [bp + -3]
0574+  08BA 07 98 06    	call gets				; get number
0575+  08BD             
0576+  08BD 32          	mov bl, [d]
0577+  08BE 37          	mov bh, bl
0578+  08BF 33 01 00    	mov bl, [d + 1]
0579+  08C2 07 46 06    	call atoi				; convert to int in AL
0580+  08C5             
0581+  08C5 E7          	pop d
0582+  08C6 E5          	pop b
0583+  08C7 F9          	leave
0584+  08C8 09          	ret
0585+  08C9             
0586+  08C9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  08C9             ; input decimal number
0588+  08C9             ; result in A
0589+  08C9             ; 655'\0'
0590+  08C9             ; low--------high
0591+  08C9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0592+  08C9             scan_u16d:
0593+  08C9 F8 08 00    	enter 8
0594+  08CC E2          	push si
0595+  08CD D8          	push b
0596+  08CE D9          	push c
0597+  08CF DA          	push d
0598+  08D0 FA F9 FF    	lea d, [bp +- 7]
0599+  08D3 07 98 06    	call gets
0600+  08D6 07 C6 05    	call strlen			; get string length in C
0601+  08D9 7E          	dec c
0602+  08DA FD 4E       	mov si, d
0603+  08DC 12          	mov a, c
0604+  08DD FD 99       	shl a
0605+  08DF 3B 2E 06    	mov d, table_power
0606+  08E2 59          	add d, a
0607+  08E3 38 00 00    	mov c, 0
0608+  08E6             mul_loop:
0609+  08E6 F6          	lodsb			; load ASCII to al
0610+  08E7 B9 00       	cmp al, 0
0611+  08E9 C6 FC 08    	je mul_exit
0612+  08EC 6F 30       	sub al, $30		; make into integer
0613+  08EE 22 00       	mov ah, 0
0614+  08F0 2A          	mov b, [d]
0615+  08F1 AC          	mul a, b			; result in B since it fits in 16bits
0616+  08F2 11          	mov a, b
0617+  08F3 28          	mov b, c
0618+  08F4 54          	add a, b
0619+  08F5 39          	mov c, a
0620+  08F6 63 02 00    	sub d, 2
0621+  08F9 0A E6 08    	jmp mul_loop
0622+  08FC             mul_exit:
0623+  08FC 12          	mov a, c
0624+  08FD E7          	pop d
0625+  08FE E6          	pop c
0626+  08FF E5          	pop b
0627+  0900 EF          	pop si
0628+  0901 F9          	leave
0629+  0902 09          	ret
0225   0903             ; --- END INCLUDE BLOCK
0226   0903             
0227   0903             
0228   0903             .end
tasm: Number of errors = 0
