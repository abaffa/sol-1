0001   0000             ; --- FILENAME: test.c
0002   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0400             .org PROC_TEXT_ORG
0004   0400             
0005   0400             ; --- BEGIN TEXT BLOCK
0006   0400             main:
0007   0400 D2            push bp
0008   0401 9B            mov bp, sp
0009   0402 52 02 00      sub sp, 2 ; a
0010   0405 52 02 00      sub sp, 2 ; i
0011   0408 52 02 00      sub sp, 2 ; j
0012   040B FA FF FF      lea d, [bp + -1]
0013   040E 2D            mov b, d
0014   040F FD AB         swp b
0015   0411 D8            push b
0016   0412 07 56 05      call scann
0017   0415 51 02 00      add sp, 2
0018   0418             _switch1_expr:
0019   0418 2C FF FF      mov b, [bp + -1] ; a
0020   041B             _switch1_comparisons:
0021   041B C0 01 00      cmp b, 1
0022   041E C6 CC 04      je _switch1_case0
0023   0421 C0 02 00      cmp b, 2
0024   0424 C6 DB 04      je _switch1_case1
0025   0427             _switch1_default:
0026   0427             _switch2_expr:
0027   0427 2C FF FF      mov b, [bp + -1] ; a
0028   042A             _switch2_comparisons:
0029   042A C0 01 00      cmp b, 1
0030   042D C6 45 04      je _switch2_case0
0031   0430 C0 02 00      cmp b, 2
0032   0433 C6 54 04      je _switch2_case1
0033   0436             _switch2_default:
0034   0436 26 63 00      mov b, 99
0035   0439 FD AB         swp b
0036   043B D8            push b
0037   043C 07 6D 05      call printn
0038   043F 51 02 00      add sp, 2
0039   0442 0A C9 04      jmp _switch2_exit
0040   0445             _switch2_case0:
0041   0445 26 01 00      mov b, 1
0042   0448 FD AB         swp b
0043   044A D8            push b
0044   044B 07 6D 05      call printn
0045   044E 51 02 00      add sp, 2
0046   0451 0A C9 04      jmp _switch2_exit ; case break
0047   0454             _switch2_case1:
0048   0454             _for3_init:
0049   0454 26 00 00      mov b, 0
0050   0457 D7            push a
0051   0458 11            mov a, b
0052   0459 45 FD FF      mov [bp + -3], a ; i
0053   045C E4            pop a
0054   045D             _for3_cond:
0055   045D 2C FD FF      mov b, [bp + -3] ; i
0056   0460 D7            push a
0057   0461 11            mov a, b
0058   0462 26 0A 00      mov b, 10
0059   0465 B0            cmp a, b
0060   0466 0E            lodflgs
0061   0467 87 02         and al, %00000010 ; <
0062   0469 B9 00         cmp al, 0
0063   046B 0E            lodflgs
0064   046C 96            not al
0065   046D 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0066   046F 22 00         mov ah, 0
0067   0471 27            mov b, a
0068   0472 E4            pop a
0069   0473 C0 00 00      cmp b, 0
0070   0476 C6 C6 04      je _for3_exit
0071   0479             _for3_block:
0072   0479             _for4_init:
0073   0479 26 00 00      mov b, 0
0074   047C D7            push a
0075   047D 11            mov a, b
0076   047E 45 FB FF      mov [bp + -5], a ; j
0077   0481 E4            pop a
0078   0482             _for4_cond:
0079   0482 2C FB FF      mov b, [bp + -5] ; j
0080   0485 D7            push a
0081   0486 11            mov a, b
0082   0487 26 0A 00      mov b, 10
0083   048A B0            cmp a, b
0084   048B 0E            lodflgs
0085   048C 87 02         and al, %00000010 ; <
0086   048E B9 00         cmp al, 0
0087   0490 0E            lodflgs
0088   0491 96            not al
0089   0492 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0090   0494 22 00         mov ah, 0
0091   0496 27            mov b, a
0092   0497 E4            pop a
0093   0498 C0 00 00      cmp b, 0
0094   049B C6 B8 04      je _for4_exit
0095   049E             _for4_block:
0096   049E 26 02 00      mov b, 2
0097   04A1 FD AB         swp b
0098   04A3 D8            push b
0099   04A4 07 6D 05      call printn
0100   04A7 51 02 00      add sp, 2
0101   04AA             _for4_update:
0102   04AA 2C FB FF      mov b, [bp + -5] ; j
0103   04AD FD 77         inc b
0104   04AF D7            push a
0105   04B0 11            mov a, b
0106   04B1 45 FB FF      mov [bp + -5], a ; j
0107   04B4 E4            pop a
0108   04B5 0A 82 04      jmp _for4_cond
0109   04B8             _for4_exit:
0110   04B8             _for3_update:
0111   04B8 2C FD FF      mov b, [bp + -3] ; i
0112   04BB FD 77         inc b
0113   04BD D7            push a
0114   04BE 11            mov a, b
0115   04BF 45 FD FF      mov [bp + -3], a ; i
0116   04C2 E4            pop a
0117   04C3 0A 5D 04      jmp _for3_cond
0118   04C6             _for3_exit:
0119   04C6 0A C9 04      jmp _switch2_exit ; case break
0120   04C9             _switch2_exit:
0121   04C9 0A 50 05      jmp _switch1_exit
0122   04CC             _switch1_case0:
0123   04CC 26 01 00      mov b, 1
0124   04CF FD AB         swp b
0125   04D1 D8            push b
0126   04D2 07 6D 05      call printn
0127   04D5 51 02 00      add sp, 2
0128   04D8 0A 50 05      jmp _switch1_exit ; case break
0129   04DB             _switch1_case1:
0130   04DB             _for5_init:
0131   04DB 26 00 00      mov b, 0
0132   04DE D7            push a
0133   04DF 11            mov a, b
0134   04E0 45 FD FF      mov [bp + -3], a ; i
0135   04E3 E4            pop a
0136   04E4             _for5_cond:
0137   04E4 2C FD FF      mov b, [bp + -3] ; i
0138   04E7 D7            push a
0139   04E8 11            mov a, b
0140   04E9 26 0A 00      mov b, 10
0141   04EC B0            cmp a, b
0142   04ED 0E            lodflgs
0143   04EE 87 02         and al, %00000010 ; <
0144   04F0 B9 00         cmp al, 0
0145   04F2 0E            lodflgs
0146   04F3 96            not al
0147   04F4 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0148   04F6 22 00         mov ah, 0
0149   04F8 27            mov b, a
0150   04F9 E4            pop a
0151   04FA C0 00 00      cmp b, 0
0152   04FD C6 4D 05      je _for5_exit
0153   0500             _for5_block:
0154   0500             _for6_init:
0155   0500 26 00 00      mov b, 0
0156   0503 D7            push a
0157   0504 11            mov a, b
0158   0505 45 FB FF      mov [bp + -5], a ; j
0159   0508 E4            pop a
0160   0509             _for6_cond:
0161   0509 2C FB FF      mov b, [bp + -5] ; j
0162   050C D7            push a
0163   050D 11            mov a, b
0164   050E 26 0A 00      mov b, 10
0165   0511 B0            cmp a, b
0166   0512 0E            lodflgs
0167   0513 87 02         and al, %00000010 ; <
0168   0515 B9 00         cmp al, 0
0169   0517 0E            lodflgs
0170   0518 96            not al
0171   0519 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0172   051B 22 00         mov ah, 0
0173   051D 27            mov b, a
0174   051E E4            pop a
0175   051F C0 00 00      cmp b, 0
0176   0522 C6 3F 05      je _for6_exit
0177   0525             _for6_block:
0178   0525 26 02 00      mov b, 2
0179   0528 FD AB         swp b
0180   052A D8            push b
0181   052B 07 6D 05      call printn
0182   052E 51 02 00      add sp, 2
0183   0531             _for6_update:
0184   0531 2C FB FF      mov b, [bp + -5] ; j
0185   0534 FD 77         inc b
0186   0536 D7            push a
0187   0537 11            mov a, b
0188   0538 45 FB FF      mov [bp + -5], a ; j
0189   053B E4            pop a
0190   053C 0A 09 05      jmp _for6_cond
0191   053F             _for6_exit:
0192   053F             _for5_update:
0193   053F 2C FD FF      mov b, [bp + -3] ; i
0194   0542 FD 77         inc b
0195   0544 D7            push a
0196   0545 11            mov a, b
0197   0546 45 FD FF      mov [bp + -3], a ; i
0198   0549 E4            pop a
0199   054A 0A E4 04      jmp _for5_cond
0200   054D             _for5_exit:
0201   054D 0A 50 05      jmp _switch1_exit ; case break
0202   0550             _switch1_exit:
0203   0550 26 00 00      mov b, 0
0204   0553 F9            leave
0205   0554 05 0B         syscall sys_terminate_proc
0206   0556             scann:
0207   0556 D2            push bp
0208   0557 9B            mov bp, sp
0209   0558 52 02 00      sub sp, 2 ; m
0210   055B             
0211   055B             ; --- BEGIN INLINE ASM BLOCK
0212   055B 07 F7 08      call scan_u16d
0213   055E 45 FF FF      mov [bp + -1], a
0214   0561             ; --- END INLINE ASM BLOCK
0215   0561             
0216   0561 FA 05 00      lea d, [bp + 5] ; n
0217   0564 2A            mov b, [d]
0218   0565 74            mov d, b
0219   0566 2C FF FF      mov b, [bp + -1] ; m
0220   0569 11            mov a, b
0221   056A 43            mov [d], a
0222   056B F9            leave
0223   056C 09            ret
0224   056D             printn:
0225   056D D2            push bp
0226   056E 9B            mov bp, sp
0227   056F             
0228   056F             ; --- BEGIN INLINE ASM BLOCK
0229   056F 17 05 00      mov a, [bp + 5]
0230   0572 07 22 08      call print_u16d
0231   0575             ; --- END INLINE ASM BLOCK
0232   0575             
0233   0575 F9            leave
0234   0576 09            ret
0235   0577             print:
0236   0577 D2            push bp
0237   0578 9B            mov bp, sp
0238   0579             
0239   0579             ; --- BEGIN INLINE ASM BLOCK
0240   0579 17 05 00      mov a, [bp + 5]
0241   057C 3C            mov d, a
0242   057D 07 F9 07      call puts
0243   0580             ; --- END INLINE ASM BLOCK
0244   0580             
0245   0580 F9            leave
0246   0581 09            ret
0247   0582             ; --- END TEXT BLOCK
0248   0582             
0249   0582             ; --- BEGIN DATA BLOCK
0250   0582             s_data: 
0251   0582 01 00 02 00 .dw 1, 2, _string_0, 
0251   0586 A8 05 
0252   0588 00 00 00 00 .fill 26, 0
0252   058C 00 00 00 00 
0252   0590 00 00 00 00 
0252   0594 00 00 00 00 
0252   0598 00 00 00 00 
0252   059C 00 00 00 00 
0252   05A0 00 00 
0253   05A2 82 05       s: .dw s_data
0254   05A4             i_data: 
0255   05A4 16 00       .dw 22, 
0256   05A6             .fill 0, 0
0257   05A6 A4 05       i: .dw i_data
0258   05A8 48 65 6C 6F _string_0: .db "Helo", 0
0258   05AC 00 
0259   05AD             ; --- END DATA BLOCK
0260   05AD             
0261   05AD             ; --- BEGIN INCLUDE BLOCK
0262   05AD             .include "lib/stdio.asm"
0001+  05AD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  05AD             ; stdio.s
0003+  05AD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  05AD             .include "lib/string.asm"
0001++ 05AD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 05AD             ; string.s
0003++ 05AD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 05AD             
0005++ 05AD             
0006++ 05AD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 05AD             ; strrev
0008++ 05AD             ; reverse a string
0009++ 05AD             ; D = string address
0010++ 05AD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 05AD             ; 01234
0012++ 05AD             strrev:
0013++ 05AD 4B          	pusha
0014++ 05AE 07 F4 05    	call strlen	; length in C
0015++ 05B1 12          	mov a, c
0016++ 05B2 AF 01 00    	cmp a, 1
0017++ 05B5 D0 CF 05    	jleu strrev_end	; check string length. string len must be > 1
0018++ 05B8 7D          	dec a
0019++ 05B9 FD 4E       	mov si, d	; beginning of string
0020++ 05BB FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 05BD 59          	add d, a	; end of string
0022++ 05BE 12          	mov a, c
0023++ 05BF FD 9B       	shr a		; divide by 2
0024++ 05C1 39          	mov c, a	; C now counts the steps
0025++ 05C2             strrev_L0:
0026++ 05C2 32          	mov bl, [d]	; save load right-side char into BL
0027++ 05C3 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 05C4 3E          	mov [d], al	; store left char into right side
0029++ 05C5 1B          	mov al, bl
0030++ 05C6 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 05C7 7E          	dec c
0032++ 05C8 7F          	dec d
0033++ 05C9 C2 00 00    	cmp c, 0
0034++ 05CC C7 C2 05    	jne strrev_L0
0035++ 05CF             strrev_end:
0036++ 05CF 4C          	popa
0037++ 05D0 09          	ret
0038++ 05D1             	
0039++ 05D1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 05D1             ; strchr
0041++ 05D1             ; search string in D for char in AL
0042++ 05D1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 05D1             strchr:
0044++ 05D1             strchr_L0:
0045++ 05D1 32          	mov bl, [d]
0046++ 05D2 C1 00       	cmp bl, 0
0047++ 05D4 C6 DF 05    	je strchr_end
0048++ 05D7 BA          	cmp al, bl
0049++ 05D8 C6 DF 05    	je strchr_end
0050++ 05DB 79          	inc d
0051++ 05DC 0A D1 05    	jmp strchr_L0
0052++ 05DF             strchr_end:
0053++ 05DF 1B          	mov al, bl
0054++ 05E0 09          	ret
0055++ 05E1             
0056++ 05E1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 05E1             ; strstr
0058++ 05E1             ; find sub-string
0059++ 05E1             ; str1 in SI
0060++ 05E1             ; str2 in DI
0061++ 05E1             ; SI points to end of source string
0062++ 05E1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 05E1             strstr:
0064++ 05E1 DB          	push al
0065++ 05E2 DA          	push d
0066++ 05E3 E3          	push di
0067++ 05E4             strstr_loop:
0068++ 05E4 F3          	cmpsb					; compare a byte of the strings
0069++ 05E5 C7 F0 05    	jne strstr_ret
0070++ 05E8 FC 00 00    	lea d, [di + 0]
0071++ 05EB BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 05ED C7 E4 05    	jne strstr_loop				; equal chars but not at end
0073++ 05F0             strstr_ret:
0074++ 05F0 F0          	pop di
0075++ 05F1 E7          	pop d
0076++ 05F2 E8          	pop al
0077++ 05F3 09          	ret
0078++ 05F4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 05F4             ; length of null terminated string
0080++ 05F4             ; result in C
0081++ 05F4             ; pointer in D
0082++ 05F4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 05F4             strlen:
0084++ 05F4 DA          	push d
0085++ 05F5 38 00 00    	mov c, 0
0086++ 05F8             strlen_L1:
0087++ 05F8 BD 00       	cmp byte [d], 0
0088++ 05FA C6 02 06    	je strlen_ret
0089++ 05FD 79          	inc d
0090++ 05FE 78          	inc c
0091++ 05FF 0A F8 05    	jmp strlen_L1
0092++ 0602             strlen_ret:
0093++ 0602 E7          	pop d
0094++ 0603 09          	ret
0095++ 0604             
0096++ 0604             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0604             ; STRCMP
0098++ 0604             ; compare two strings
0099++ 0604             ; str1 in SI
0100++ 0604             ; str2 in DI
0101++ 0604             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0604             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0604             strcmp:
0104++ 0604 DB          	push al
0105++ 0605 DA          	push d
0106++ 0606 E3          	push di
0107++ 0607 E2          	push si
0108++ 0608             strcmp_loop:
0109++ 0608 F3          	cmpsb					; compare a byte of the strings
0110++ 0609 C7 14 06    	jne strcmp_ret
0111++ 060C FB FF FF    	lea d, [si +- 1]
0112++ 060F BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0611 C7 08 06    	jne strcmp_loop				; equal chars but not at end
0114++ 0614             strcmp_ret:
0115++ 0614 EF          	pop si
0116++ 0615 F0          	pop di
0117++ 0616 E7          	pop d
0118++ 0617 E8          	pop al
0119++ 0618 09          	ret
0120++ 0619             
0121++ 0619             
0122++ 0619             ; STRCPY
0123++ 0619             ; copy null terminated string from SI to DI
0124++ 0619             ; source in SI
0125++ 0619             ; destination in DI
0126++ 0619             strcpy:
0127++ 0619 E2          	push si
0128++ 061A E3          	push di
0129++ 061B DB          	push al
0130++ 061C             strcpy_L1:
0131++ 061C F6          	lodsb
0132++ 061D F7          	stosb
0133++ 061E B9 00       	cmp al, 0
0134++ 0620 C7 1C 06    	jne strcpy_L1
0135++ 0623             strcpy_end:
0136++ 0623 E8          	pop al
0137++ 0624 F0          	pop di
0138++ 0625 EF          	pop si
0139++ 0626 09          	ret
0140++ 0627             
0141++ 0627             ; STRCAT
0142++ 0627             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0627             ; source in SI
0144++ 0627             ; destination in DI
0145++ 0627             strcat:
0146++ 0627 E2          	push si
0147++ 0628 E3          	push di
0148++ 0629 D7          	push a
0149++ 062A DA          	push d
0150++ 062B 50          	mov a, di
0151++ 062C 3C          	mov d, a
0152++ 062D             strcat_goto_end_L1:
0153++ 062D BD 00       	cmp byte[d], 0
0154++ 062F C6 36 06    	je strcat_start
0155++ 0632 79          	inc d
0156++ 0633 0A 2D 06    	jmp strcat_goto_end_L1
0157++ 0636             strcat_start:
0158++ 0636 FD 50       	mov di, d
0159++ 0638             strcat_L1:
0160++ 0638 F6          	lodsb
0161++ 0639 F7          	stosb
0162++ 063A B9 00       	cmp al, 0
0163++ 063C C7 38 06    	jne strcat_L1
0164++ 063F             strcat_end:
0165++ 063F E7          	pop d
0166++ 0640 E4          	pop a
0167++ 0641 F0          	pop di
0168++ 0642 EF          	pop si
0169++ 0643 09          	ret
0005+  0644             
0006+  0644 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  0648 34 35 36 37 
0006+  064C 38 39 41 42 
0006+  0650 43 44 45 46 
0007+  0654 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  0658 1B 5B 48 00 
0008+  065C             
0009+  065C 01 00       table_power:.dw 1
0010+  065E 0A 00       			.dw 10
0011+  0660 64 00       			.dw 100
0012+  0662 E8 03       			.dw 1000
0013+  0664 10 27       			.dw 10000
0014+  0666             
0015+  0666             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  0666             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  0666             ; ASCII in BL
0018+  0666             ; result in AL
0019+  0666             ; ascii for F = 0100 0110
0020+  0666             ; ascii for 9 = 0011 1001
0021+  0666             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  0666             hex_ascii_encode:
0023+  0666 1B          	mov al, bl
0024+  0667 93 40       	test al, $40				; test if letter or number
0025+  0669 C7 6F 06    	jnz hex_letter
0026+  066C 87 0F       	and al, $0F				; get number
0027+  066E 09          	ret
0028+  066F             hex_letter:
0029+  066F 87 0F       	and al, $0F				; get letter
0030+  0671 6A 09       	add al, 9
0031+  0673 09          	ret
0032+  0674             
0033+  0674             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  0674             ; ATOI
0035+  0674             ; 2 letter hex string in B
0036+  0674             ; 8bit integer returned in AL
0037+  0674             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0674             atoi:
0039+  0674 D8          	push b
0040+  0675 07 66 06    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  0678 30          	mov bl, bh
0042+  0679 DB          	push al					; save a
0043+  067A 07 66 06    	call hex_ascii_encode
0044+  067D EA          	pop bl	
0045+  067E FD 9E 04    	shl al, 4
0046+  0681 8C          	or al, bl
0047+  0682 E5          	pop b
0048+  0683 09          	ret	
0049+  0684             
0050+  0684             
0051+  0684             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  0684             ; printf
0053+  0684             ; no need for explanations!
0054+  0684             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0684             printf:
0056+  0684 09          	ret
0057+  0685             
0058+  0685             
0059+  0685             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  0685             ; scanf
0061+  0685             ; no need for explanations!
0062+  0685             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  0685             scanf:
0064+  0685 09          	ret
0065+  0686             
0066+  0686             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  0686             ; ITOA
0068+  0686             ; 8bit value in BL
0069+  0686             ; 2 byte ASCII result in A
0070+  0686             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  0686             itoa:
0072+  0686 DA          	push d
0073+  0687 D8          	push b
0074+  0688 A7 00       	mov bh, 0
0075+  068A FD A4 04    	shr bl, 4	
0076+  068D 74          	mov d, b
0077+  068E 1F 44 06    	mov al, [d + s_hex_digits]
0078+  0691 23          	mov ah, al
0079+  0692             	
0080+  0692 E5          	pop b
0081+  0693 D8          	push b
0082+  0694 A7 00       	mov bh, 0
0083+  0696 FD 87 0F    	and bl, $0F
0084+  0699 74          	mov d, b
0085+  069A 1F 44 06    	mov al, [d + s_hex_digits]
0086+  069D E5          	pop b
0087+  069E E7          	pop d
0088+  069F 09          	ret
0089+  06A0             
0090+  06A0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  06A0             ; HEX STRING TO BINARY
0092+  06A0             ; di = destination address
0093+  06A0             ; si = source
0094+  06A0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  06A0             hex_to_int:
0096+  06A0             hex_to_int_L1:
0097+  06A0 F6          	lodsb					; load from [SI] to AL
0098+  06A1 B9 00       	cmp al, 0				; check if ASCII 0
0099+  06A3 C6 B0 06    	jz hex_to_int_ret
0100+  06A6 36          	mov bh, al
0101+  06A7 F6          	lodsb
0102+  06A8 2F          	mov bl, al
0103+  06A9 07 74 06    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  06AC F7          	stosb					; store AL to [DI]
0105+  06AD 0A A0 06    	jmp hex_to_int_L1
0106+  06B0             hex_to_int_ret:
0107+  06B0 09          	ret		
0108+  06B1             
0109+  06B1             
0110+  06B1             
0111+  06B1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  06B1             ; GETCHAR
0113+  06B1             ; char in ah
0114+  06B1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  06B1             getchar:
0116+  06B1 DB          	push al
0117+  06B2             getchar_retry:
0118+  06B2 FD 0C       	sti
0119+  06B4 19 01       	mov al, 1
0120+  06B6 05 03       	syscall sys_io			; receive in AH
0121+  06B8 B9 00       	cmp al, 0			; check if any char was receive
0122+  06BA C6 B2 06    	je getchar_retry
0123+  06BD E8          	pop al
0124+  06BE 09          	ret
0125+  06BF             
0126+  06BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  06BF             ; PUTCHAR
0128+  06BF             ; char in ah
0129+  06BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  06BF             putchar:
0131+  06BF D7          	push a
0132+  06C0 19 00       	mov al, 0
0133+  06C2 05 03       	syscall sys_io			; char in AH
0134+  06C4 E4          	pop a
0135+  06C5 09          	ret
0136+  06C6             
0137+  06C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  06C6             ;; INPUT A STRING
0139+  06C6             ;; terminates with null
0140+  06C6             ;; pointer in D
0141+  06C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  06C6             gets:
0143+  06C6 D7          	push a
0144+  06C7 DA          	push d
0145+  06C8             gets_loop:
0146+  06C8 FD 0C       	sti
0147+  06CA 19 01       	mov al, 1
0148+  06CC 05 03       	syscall sys_io			; receive in AH
0149+  06CE B9 00       	cmp al, 0				; check error code (AL)
0150+  06D0 C6 C8 06    	je gets_loop			; if no char received, retry
0151+  06D3             
0152+  06D3 76 1B       	cmp ah, 27
0153+  06D5 C6 F6 06    	je gets_telnet_escape
0154+  06D8 76 0A       	cmp ah, $0A				; LF
0155+  06DA C6 4F 07    	je gets_end
0156+  06DD 76 0D       	cmp ah, $0D				; CR
0157+  06DF C6 4F 07    	je gets_end
0158+  06E2 76 5C       	cmp ah, $5C				; '\\'
0159+  06E4 C6 26 07    	je gets_escape
0160+  06E7             	
0161+  06E7 76 08       	cmp ah, $08			; check for backspace
0162+  06E9 C6 F2 06    	je gets_backspace
0163+  06EC             
0164+  06EC 1A          	mov al, ah
0165+  06ED 3E          	mov [d], al
0166+  06EE 79          	inc d
0167+  06EF 0A C8 06    	jmp gets_loop
0168+  06F2             gets_backspace:
0169+  06F2 7F          	dec d
0170+  06F3 0A C8 06    	jmp gets_loop
0171+  06F6             gets_telnet_escape:
0172+  06F6 FD 0C       	sti
0173+  06F8 19 01       	mov al, 1
0174+  06FA 05 03       	syscall sys_io				; receive in AH without echo
0175+  06FC B9 00       	cmp al, 0					; check error code (AL)
0176+  06FE C6 F6 06    	je gets_telnet_escape		; if no char received, retry
0177+  0701 76 5B       	cmp ah, '['
0178+  0703 C7 C8 06    	jne gets_loop
0179+  0706             gets_telnet_escape_phase2:
0180+  0706 FD 0C       	sti
0181+  0708 19 01       	mov al, 1
0182+  070A 05 03       	syscall sys_io					; receive in AH without echo
0183+  070C B9 00       	cmp al, 0						; check error code (AL)
0184+  070E C6 06 07    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  0711 76 44       	cmp ah, 'D'
0186+  0713 C6 1E 07    	je gets_left_arrow
0187+  0716 76 43       	cmp ah, 'C'
0188+  0718 C6 22 07    	je gets_right_arrow
0189+  071B 0A C8 06    	jmp gets_loop
0190+  071E             gets_left_arrow:
0191+  071E 7F          	dec d
0192+  071F 0A C8 06    	jmp gets_loop
0193+  0722             gets_right_arrow:
0194+  0722 79          	inc d
0195+  0723 0A C8 06    	jmp gets_loop
0196+  0726             gets_escape:
0197+  0726 FD 0C       	sti
0198+  0728 19 01       	mov al, 1
0199+  072A 05 03       	syscall sys_io			; receive in AH
0200+  072C B9 00       	cmp al, 0				; check error code (AL)
0201+  072E C6 26 07    	je gets_escape			; if no char received, retry
0202+  0731 76 6E       	cmp ah, 'n'
0203+  0733 C6 41 07    	je gets_LF
0204+  0736 76 72       	cmp ah, 'r'
0205+  0738 C6 48 07    	je gets_CR
0206+  073B 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  073C 3E          	mov [d], al
0208+  073D 79          	inc d
0209+  073E 0A C8 06    	jmp gets_loop
0210+  0741             gets_LF:
0211+  0741 19 0A       	mov al, $0A
0212+  0743 3E          	mov [d], al
0213+  0744 79          	inc d
0214+  0745 0A C8 06    	jmp gets_loop
0215+  0748             gets_CR:
0216+  0748 19 0D       	mov al, $0D
0217+  074A 3E          	mov [d], al
0218+  074B 79          	inc d
0219+  074C 0A C8 06    	jmp gets_loop
0220+  074F             gets_end:
0221+  074F 19 00       	mov al, 0
0222+  0751 3E          	mov [d], al				; terminate string
0223+  0752 E7          	pop d
0224+  0753 E4          	pop a
0225+  0754 09          	ret
0226+  0755             
0227+  0755             
0228+  0755             
0229+  0755             
0230+  0755             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  0755             ;; INPUT TEXT
0232+  0755             ;; terminated with CTRL+D
0233+  0755             ;; pointer in D
0234+  0755             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  0755             gettxt:
0236+  0755 D7          	push a
0237+  0756 DA          	push d
0238+  0757             gettxt_loop:
0239+  0757 19 01       	mov al, 1
0240+  0759 05 03       	syscall sys_io			; receive in AH
0241+  075B B9 00       	cmp al, 0				; check error code (AL)
0242+  075D C6 57 07    	je gettxt_loop		; if no char received, retry
0243+  0760 76 04       	cmp ah, 4			; EOT
0244+  0762 C6 A0 07    	je gettxt_end
0245+  0765 76 08       	cmp ah, $08			; check for backspace
0246+  0767 C6 9C 07    	je gettxt_backspace
0247+  076A 76 5C       	cmp ah, $5C				; '\\'
0248+  076C C6 75 07    	je gettxt_escape
0249+  076F 1A          	mov al, ah
0250+  0770 3E          	mov [d], al
0251+  0771 79          	inc d
0252+  0772 0A 57 07    	jmp gettxt_loop
0253+  0775             gettxt_escape:
0254+  0775 19 01       	mov al, 1
0255+  0777 05 03       	syscall sys_io			; receive in AH
0256+  0779 B9 00       	cmp al, 0				; check error code (AL)
0257+  077B C6 75 07    	je gettxt_escape		; if no char received, retry
0258+  077E 76 6E       	cmp ah, 'n'
0259+  0780 C6 8E 07    	je gettxt_LF
0260+  0783 76 72       	cmp ah, 'r'
0261+  0785 C6 95 07    	je gettxt_CR
0262+  0788 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  0789 3E          	mov [d], al
0264+  078A 79          	inc d
0265+  078B 0A 57 07    	jmp gettxt_loop
0266+  078E             gettxt_LF:
0267+  078E 19 0A       	mov al, $0A
0268+  0790 3E          	mov [d], al
0269+  0791 79          	inc d
0270+  0792 0A 57 07    	jmp gettxt_loop
0271+  0795             gettxt_CR:
0272+  0795 19 0D       	mov al, $0D
0273+  0797 3E          	mov [d], al
0274+  0798 79          	inc d
0275+  0799 0A 57 07    	jmp gettxt_loop
0276+  079C             gettxt_backspace:
0277+  079C 7F          	dec d
0278+  079D 0A 57 07    	jmp gettxt_loop
0279+  07A0             gettxt_end:
0280+  07A0 19 00       	mov al, 0
0281+  07A2 3E          	mov [d], al				; terminate string
0282+  07A3 E7          	pop d
0283+  07A4 E4          	pop a
0284+  07A5 09          	ret
0285+  07A6             
0286+  07A6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  07A6             ; PRINT NEW LINE
0288+  07A6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  07A6             printnl:
0290+  07A6 D7          	push a
0291+  07A7 10 00 0A    	mov a, $0A00
0292+  07AA 05 03       	syscall sys_io
0293+  07AC 10 00 0D    	mov a, $0D00
0294+  07AF 05 03       	syscall sys_io
0295+  07B1 E4          	pop a
0296+  07B2 09          	ret
0297+  07B3             
0298+  07B3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  07B3             ; strtoint
0300+  07B3             ; 4 digit hex string number in d
0301+  07B3             ; integer returned in A
0302+  07B3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  07B3             strtointx:
0304+  07B3 D8          	push b
0305+  07B4 32          	mov bl, [d]
0306+  07B5 37          	mov bh, bl
0307+  07B6 33 01 00    	mov bl, [d + 1]
0308+  07B9 07 74 06    	call atoi				; convert to int in AL
0309+  07BC 23          	mov ah, al				; move to AH
0310+  07BD 33 02 00    	mov bl, [d + 2]
0311+  07C0 37          	mov bh, bl
0312+  07C1 33 03 00    	mov bl, [d + 3]
0313+  07C4 07 74 06    	call atoi				; convert to int in AL
0314+  07C7 E5          	pop b
0315+  07C8 09          	ret
0316+  07C9             
0317+  07C9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  07C9             ; strtoint
0319+  07C9             ; 5 digit base10 string number in d
0320+  07C9             ; integer returned in A
0321+  07C9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  07C9             strtoint:
0323+  07C9 E2          	push si
0324+  07CA D8          	push b
0325+  07CB D9          	push c
0326+  07CC DA          	push d
0327+  07CD 07 F4 05    	call strlen			; get string length in C
0328+  07D0 7E          	dec c
0329+  07D1 FD 4E       	mov si, d
0330+  07D3 12          	mov a, c
0331+  07D4 FD 99       	shl a
0332+  07D6 3B 5C 06    	mov d, table_power
0333+  07D9 59          	add d, a
0334+  07DA 38 00 00    	mov c, 0
0335+  07DD             strtoint_L0:
0336+  07DD F6          	lodsb			; load ASCII to al
0337+  07DE B9 00       	cmp al, 0
0338+  07E0 C6 F3 07    	je strtoint_end
0339+  07E3 6F 30       	sub al, $30		; make into integer
0340+  07E5 22 00       	mov ah, 0
0341+  07E7 2A          	mov b, [d]
0342+  07E8 AC          	mul a, b			; result in B since it fits in 16bits
0343+  07E9 11          	mov a, b
0344+  07EA 28          	mov b, c
0345+  07EB 54          	add a, b
0346+  07EC 39          	mov c, a
0347+  07ED 63 02 00    	sub d, 2
0348+  07F0 0A DD 07    	jmp strtoint_L0
0349+  07F3             strtoint_end:
0350+  07F3 12          	mov a, c
0351+  07F4 E7          	pop d
0352+  07F5 E6          	pop c
0353+  07F6 E5          	pop b
0354+  07F7 EF          	pop si
0355+  07F8 09          	ret
0356+  07F9             
0357+  07F9             
0358+  07F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  07F9             ; PRINT NULL TERMINATED STRING
0360+  07F9             ; pointer in D
0361+  07F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  07F9             puts:
0363+  07F9 D7          	push a
0364+  07FA DA          	push d
0365+  07FB             puts_L1:
0366+  07FB 1E          	mov al, [d]
0367+  07FC B9 00       	cmp al, 0
0368+  07FE C6 0A 08    	jz puts_END
0369+  0801 23          	mov ah, al
0370+  0802 19 00       	mov al, 0
0371+  0804 05 03       	syscall sys_io
0372+  0806 79          	inc d
0373+  0807 0A FB 07    	jmp puts_L1
0374+  080A             puts_END:
0375+  080A E7          	pop d
0376+  080B E4          	pop a
0377+  080C 09          	ret
0378+  080D             
0379+  080D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  080D             ; PRINT N SIZE STRING
0381+  080D             ; pointer in D
0382+  080D             ; size in C
0383+  080D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  080D             putsn:
0385+  080D DB          	push al
0386+  080E DA          	push d
0387+  080F D9          	push c
0388+  0810             putsn_L0:
0389+  0810 1E          	mov al, [d]
0390+  0811 23          	mov ah, al
0391+  0812 19 00       	mov al, 0
0392+  0814 05 03       	syscall sys_io
0393+  0816 79          	inc d
0394+  0817 7E          	dec c	
0395+  0818 C2 00 00    	cmp c, 0
0396+  081B C7 10 08    	jne putsn_L0
0397+  081E             putsn_end:
0398+  081E E6          	pop c
0399+  081F E7          	pop d
0400+  0820 E8          	pop al
0401+  0821 09          	ret
0402+  0822             
0403+  0822             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  0822             ; print 16bit decimal number
0405+  0822             ; input number in A
0406+  0822             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  0822             print_u16d:
0408+  0822 D7          	push a
0409+  0823 D8          	push b
0410+  0824 26 10 27    	mov b, 10000
0411+  0827 AE          	div a, b			; get 10000 coeff.
0412+  0828 07 4E 08    	call print_number
0413+  082B 11          	mov a, b
0414+  082C 26 E8 03    	mov b, 1000
0415+  082F AE          	div a, b			; get 10000 coeff.
0416+  0830 07 4E 08    	call print_number
0417+  0833 11          	mov a, b
0418+  0834 26 64 00    	mov b, 100
0419+  0837 AE          	div a, b
0420+  0838 07 4E 08    	call print_number
0421+  083B 11          	mov a, b
0422+  083C 26 0A 00    	mov b, 10
0423+  083F AE          	div a, b
0424+  0840 07 4E 08    	call print_number
0425+  0843 11          	mov a, b
0426+  0844 6A 30       	add al, $30
0427+  0846 23          	mov ah, al
0428+  0847 19 00       	mov al, 0
0429+  0849 05 03       	syscall sys_io	; print coeff
0430+  084B E5          	pop b
0431+  084C E4          	pop a
0432+  084D 09          	ret
0433+  084E             
0434+  084E             
0435+  084E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  084E             ; if A == 0, print space
0437+  084E             ; else print A
0438+  084E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0439+  084E             print_number:
0440+  084E 6A 30       	add al, $30
0441+  0850 23          	mov ah, al
0442+  0851 07 BF 06    	call putchar
0443+  0854 09          	ret
0444+  0855             
0445+  0855             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0446+  0855             ; PRINT 16BIT HEX INTEGER
0447+  0855             ; integer value in reg B
0448+  0855             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  0855             print_u16x:
0450+  0855 D7          	push a
0451+  0856 D8          	push b
0452+  0857 DD          	push bl
0453+  0858 30          	mov bl, bh
0454+  0859 07 86 06    	call itoa				; convert bh to char in A
0455+  085C 2F          	mov bl, al				; save al
0456+  085D 19 00       	mov al, 0
0457+  085F 05 03       	syscall sys_io				; display AH
0458+  0861 24          	mov ah, bl				; retrieve al
0459+  0862 19 00       	mov al, 0
0460+  0864 05 03       	syscall sys_io				; display AL
0461+  0866             
0462+  0866 EA          	pop bl
0463+  0867 07 86 06    	call itoa				; convert bh to char in A
0464+  086A 2F          	mov bl, al				; save al
0465+  086B 19 00       	mov al, 0
0466+  086D 05 03       	syscall sys_io				; display AH
0467+  086F 24          	mov ah, bl				; retrieve al
0468+  0870 19 00       	mov al, 0
0469+  0872 05 03       	syscall sys_io				; display AL
0470+  0874             
0471+  0874 E5          	pop b
0472+  0875 E4          	pop a
0473+  0876 09          	ret
0474+  0877             
0475+  0877             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  0877             ; INPUT 16BIT HEX INTEGER
0477+  0877             ; read 16bit integer into A
0478+  0877             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  0877             scan_u16x:
0480+  0877 F8 10 00    	enter 16
0481+  087A D8          	push b
0482+  087B DA          	push d
0483+  087C             
0484+  087C FA F1 FF    	lea d, [bp + -15]
0485+  087F 07 C6 06    	call gets				; get number
0486+  0882             
0487+  0882 32          	mov bl, [d]
0488+  0883 37          	mov bh, bl
0489+  0884 33 01 00    	mov bl, [d + 1]
0490+  0887 07 74 06    	call atoi				; convert to int in AL
0491+  088A 23          	mov ah, al				; move to AH
0492+  088B             
0493+  088B 33 02 00    	mov bl, [d + 2]
0494+  088E 37          	mov bh, bl
0495+  088F 33 03 00    	mov bl, [d + 3]
0496+  0892 07 74 06    	call atoi				; convert to int in AL
0497+  0895             
0498+  0895 E7          	pop d
0499+  0896 E5          	pop b
0500+  0897 F9          	leave
0501+  0898 09          	ret
0502+  0899             
0503+  0899             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0504+  0899             ; PRINT 8bit HEX INTEGER
0505+  0899             ; integer value in reg bl
0506+  0899             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  0899             print_u8x:
0508+  0899 D7          	push a
0509+  089A DD          	push bl
0510+  089B             
0511+  089B 07 86 06    	call itoa				; convert bl to char in A
0512+  089E 2F          	mov bl, al				; save al
0513+  089F 19 00       	mov al, 0
0514+  08A1 05 03       	syscall sys_io				; display AH
0515+  08A3 24          	mov ah, bl				; retrieve al
0516+  08A4 19 00       	mov al, 0
0517+  08A6 05 03       	syscall sys_io				; display AL
0518+  08A8             
0519+  08A8 EA          	pop bl
0520+  08A9 E4          	pop a
0521+  08AA 09          	ret
0522+  08AB             
0523+  08AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0524+  08AB             ; print 8bit decimal unsigned number
0525+  08AB             ; input number in AL
0526+  08AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  08AB             print_u8d:
0528+  08AB D7          	push a
0529+  08AC D8          	push b
0530+  08AD             
0531+  08AD 22 00       	mov ah, 0
0532+  08AF 26 64 00    	mov b, 100
0533+  08B2 AE          	div a, b
0534+  08B3 D8          	push b			; save remainder
0535+  08B4 B9 00       	cmp al, 0
0536+  08B6 C6 C0 08    	je skip100
0537+  08B9 6A 30       	add al, $30
0538+  08BB 23          	mov ah, al
0539+  08BC 19 00       	mov al, 0
0540+  08BE 05 03       	syscall sys_io	; print coeff
0541+  08C0             skip100:
0542+  08C0 E4          	pop a
0543+  08C1 22 00       	mov ah, 0
0544+  08C3 26 0A 00    	mov b, 10
0545+  08C6 AE          	div a, b
0546+  08C7 D8          	push b			; save remainder
0547+  08C8 B9 00       	cmp al, 0
0548+  08CA C6 D4 08    	je skip10
0549+  08CD 6A 30       	add al, $30
0550+  08CF 23          	mov ah, al
0551+  08D0 19 00       	mov al, 0
0552+  08D2 05 03       	syscall sys_io	; print coeff
0553+  08D4             skip10:
0554+  08D4 E4          	pop a
0555+  08D5 1B          	mov al, bl
0556+  08D6 6A 30       	add al, $30
0557+  08D8 23          	mov ah, al
0558+  08D9 19 00       	mov al, 0
0559+  08DB 05 03       	syscall sys_io	; print coeff
0560+  08DD E5          	pop b
0561+  08DE E4          	pop a
0562+  08DF 09          	ret
0563+  08E0             
0564+  08E0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0565+  08E0             ; INPUT 8BIT HEX INTEGER
0566+  08E0             ; read 8bit integer into AL
0567+  08E0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  08E0             scan_u8x:
0569+  08E0 F8 04 00    	enter 4
0570+  08E3 D8          	push b
0571+  08E4 DA          	push d
0572+  08E5             
0573+  08E5 FA FD FF    	lea d, [bp + -3]
0574+  08E8 07 C6 06    	call gets				; get number
0575+  08EB             
0576+  08EB 32          	mov bl, [d]
0577+  08EC 37          	mov bh, bl
0578+  08ED 33 01 00    	mov bl, [d + 1]
0579+  08F0 07 74 06    	call atoi				; convert to int in AL
0580+  08F3             
0581+  08F3 E7          	pop d
0582+  08F4 E5          	pop b
0583+  08F5 F9          	leave
0584+  08F6 09          	ret
0585+  08F7             
0586+  08F7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  08F7             ; input decimal number
0588+  08F7             ; result in A
0589+  08F7             ; 655'\0'
0590+  08F7             ; low--------high
0591+  08F7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0592+  08F7             scan_u16d:
0593+  08F7 F8 08 00    	enter 8
0594+  08FA E2          	push si
0595+  08FB D8          	push b
0596+  08FC D9          	push c
0597+  08FD DA          	push d
0598+  08FE FA F9 FF    	lea d, [bp +- 7]
0599+  0901 07 C6 06    	call gets
0600+  0904 07 F4 05    	call strlen			; get string length in C
0601+  0907 7E          	dec c
0602+  0908 FD 4E       	mov si, d
0603+  090A 12          	mov a, c
0604+  090B FD 99       	shl a
0605+  090D 3B 5C 06    	mov d, table_power
0606+  0910 59          	add d, a
0607+  0911 38 00 00    	mov c, 0
0608+  0914             mul_loop:
0609+  0914 F6          	lodsb			; load ASCII to al
0610+  0915 B9 00       	cmp al, 0
0611+  0917 C6 2A 09    	je mul_exit
0612+  091A 6F 30       	sub al, $30		; make into integer
0613+  091C 22 00       	mov ah, 0
0614+  091E 2A          	mov b, [d]
0615+  091F AC          	mul a, b			; result in B since it fits in 16bits
0616+  0920 11          	mov a, b
0617+  0921 28          	mov b, c
0618+  0922 54          	add a, b
0619+  0923 39          	mov c, a
0620+  0924 63 02 00    	sub d, 2
0621+  0927 0A 14 09    	jmp mul_loop
0622+  092A             mul_exit:
0623+  092A 12          	mov a, c
0624+  092B E7          	pop d
0625+  092C E6          	pop c
0626+  092D E5          	pop b
0627+  092E EF          	pop si
0628+  092F F9          	leave
0629+  0930 09          	ret
0263   0931             ; --- END INCLUDE BLOCK
0264   0931             
0265   0931             
0266   0931             .end
tasm: Number of errors = 0
