0001   0000             ; --- FILENAME: test.c
0002   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0400             .org PROC_TEXT_ORG
0004   0400             
0005   0400             ; --- BEGIN TEXT BLOCK
0006   0400             
0007   0400             main:
0008   0400 D2            push bp
0009   0401 9B            mov bp, sp
0010   0402 52 02 00      sub sp, 2 ; p
0011   0405 29 7C 06      mov b, [__m] ; m
0012   0408 D7            push a
0013   0409 11            mov a, b
0014   040A 45 FF FF      mov [bp + -1], a ; p
0015   040D E4            pop a
0016   040E D7            push a
0017   040F FA FF FF      lea d, [bp + -1] ; p
0018   0412 2A            mov b, [d]
0019   0413 74            mov d, b
0020   0414 DA            push d
0021   0415 26 02 00      mov b, 2
0022   0418 E7            pop d
0023   0419 11            mov a, b
0024   041A 26 02 00      mov b, 2
0025   041D AC            mul a, b
0026   041E 5A            add d, b
0027   041F 2A            mov b, [d]
0028   0420 E4            pop a
0029   0421 FD AB         swp b
0030   0423 D8            push b
0031   0424 07 89 04      call print_num
0032   0427 51 02 00      add sp, 2
0033   042A 26 00 00      mov b, 0
0034   042D F9            leave
0035   042E 05 0B         syscall sys_terminate_proc
0036   0430             
0037   0430             _gets:
0038   0430 D2            push bp
0039   0431 9B            mov bp, sp
0040   0432             
0041   0432             ; --- BEGIN INLINE ASM BLOCK
0042   0432 17 05 00      mov a, [bp + 5]
0043   0435 3C            mov d, a
0044   0436 07 97 07      call gets
0045   0439             ; --- END INLINE ASM BLOCK
0046   0439             
0047   0439 F9            leave
0048   043A 09            ret
0049   043B             
0050   043B             _strlen:
0051   043B D2            push bp
0052   043C 9B            mov bp, sp
0053   043D 52 02 00      sub sp, 2 ; length
0054   0440 26 00 00      mov b, 0
0055   0443 D7            push a
0056   0444 11            mov a, b
0057   0445 45 FF FF      mov [bp + -1], a ; length
0058   0448 E4            pop a
0059   0449             _while1_cond:
0060   0449 FA 05 00      lea d, [bp + 5] ; str
0061   044C 2A            mov b, [d]
0062   044D D7            push a
0063   044E 74            mov d, b
0064   044F DA            push d
0065   0450 2C FF FF      mov b, [bp + -1] ; length
0066   0453 E7            pop d
0067   0454 10 01 00      mov a, 1
0068   0457 AC            mul a, b
0069   0458 5A            add d, b
0070   0459 E4            pop a
0071   045A 32            mov bl, [d]
0072   045B A7 00         mov bh, 0
0073   045D D7            push a
0074   045E 11            mov a, b
0075   045F 26 00 00      mov b, 0
0076   0462 B0            cmp a, b
0077   0463 0E            lodflgs
0078   0464 87 01         and al, %00000001
0079   0466 8F 01         xor al, %00000001 ; !=
0080   0468 22 00         mov ah, 0
0081   046A 27            mov b, a
0082   046B E4            pop a
0083   046C C0 00 00      cmp b, 0
0084   046F C6 84 04      je _while1_exit
0085   0472             _while1_block:
0086   0472 2C FF FF      mov b, [bp + -1] ; length
0087   0475 D7            push a
0088   0476 11            mov a, b
0089   0477 FD 77         inc b
0090   0479 D7            push a
0091   047A 11            mov a, b
0092   047B 45 FF FF      mov [bp + -1], a ; length
0093   047E E4            pop a
0094   047F 27            mov b, a
0095   0480 E4            pop a
0096   0481 0A 49 04      jmp _while1_cond
0097   0484             _while1_exit:
0098   0484 2C FF FF      mov b, [bp + -1] ; length
0099   0487 F9            leave
0100   0488 09            ret
0101   0489             
0102   0489             print_num:
0103   0489 D2            push bp
0104   048A 9B            mov bp, sp
0105   048B 52 05 00      sub sp, 5 ; digits
0106   048E 52 02 00      sub sp, 2 ; i
0107   0491 26 00 00      mov b, 0
0108   0494 D7            push a
0109   0495 11            mov a, b
0110   0496 45 FA FF      mov [bp + -6], a ; i
0111   0499 E4            pop a
0112   049A             _if2_cond:
0113   049A 2C 05 00      mov b, [bp + 5] ; num
0114   049D D7            push a
0115   049E 11            mov a, b
0116   049F 26 00 00      mov b, 0
0117   04A2 B0            cmp a, b
0118   04A3 0E            lodflgs
0119   04A4 87 01         and al, %00000001 ; ==
0120   04A6 22 00         mov ah, 0
0121   04A8 27            mov b, a
0122   04A9 E4            pop a
0123   04AA C0 00 00      cmp b, 0
0124   04AD C6 BF 04      je _if2_exit
0125   04B0             _if2_true:
0126   04B0 26 30 00      mov b, '0'
0127   04B3 DD            push bl
0128   04B4 07 8E 05      call _putchar
0129   04B7 51 01 00      add sp, 1
0130   04BA F9            leave
0131   04BB 09            ret
0132   04BC 0A BF 04      jmp _if2_exit
0133   04BF             _if2_exit:
0134   04BF             _while3_cond:
0135   04BF 2C 05 00      mov b, [bp + 5] ; num
0136   04C2 D7            push a
0137   04C3 11            mov a, b
0138   04C4 26 00 00      mov b, 0
0139   04C7 B0            cmp a, b
0140   04C8 0E            lodflgs
0141   04C9 2F            mov bl, al
0142   04CA FD 78         mov g, a
0143   04CC FD A2 03      shr al, 3
0144   04CF FD A4 02      shr bl, 2
0145   04D2 FD 87 01      and bl, %00000001
0146   04D5 90            xor al, bl
0147   04D6 FD 27         mov b, g
0148   04D8 FD 87 01      and bl, %00000001
0149   04DB 8C            or al, bl
0150   04DC 8F 01         xor al, %00000001 ; > (signed)
0151   04DE 22 00         mov ah, 0
0152   04E0 27            mov b, a
0153   04E1 E4            pop a
0154   04E2 C0 00 00      cmp b, 0
0155   04E5 C6 36 05      je _while3_exit
0156   04E8             _while3_block:
0157   04E8 FA FC FF      lea d, [bp + -4] ; digits beginning on the stack
0158   04EB 2D            mov b, d
0159   04EC D7            push a
0160   04ED 74            mov d, b
0161   04EE DA            push d
0162   04EF 2C FA FF      mov b, [bp + -6] ; i
0163   04F2 E7            pop d
0164   04F3 10 01 00      mov a, 1
0165   04F6 AC            mul a, b
0166   04F7 5A            add d, b
0167   04F8 E4            pop a
0168   04F9 DA            push d
0169   04FA 26 30 00      mov b, '0'
0170   04FD D7            push a
0171   04FE 11            mov a, b
0172   04FF 2C 05 00      mov b, [bp + 5] ; num
0173   0502 D7            push a
0174   0503 11            mov a, b
0175   0504 26 0A 00      mov b, 10
0176   0507 AE            div a, b
0177   0508 E4            pop a
0178   0509 54            add a, b
0179   050A 27            mov b, a
0180   050B E4            pop a
0181   050C E7            pop d
0182   050D FD 3E         mov [d], bl
0183   050F 2C 05 00      mov b, [bp + 5] ; num
0184   0512 D7            push a
0185   0513 11            mov a, b
0186   0514 26 0A 00      mov b, 10
0187   0517 AE            div a, b
0188   0518 FD 78         mov g, a
0189   051A 11            mov a, b
0190   051B FD 27         mov b, g
0191   051D E4            pop a
0192   051E D7            push a
0193   051F 11            mov a, b
0194   0520 45 05 00      mov [bp + 5], a ; num
0195   0523 E4            pop a
0196   0524 2C FA FF      mov b, [bp + -6] ; i
0197   0527 D7            push a
0198   0528 11            mov a, b
0199   0529 FD 77         inc b
0200   052B D7            push a
0201   052C 11            mov a, b
0202   052D 45 FA FF      mov [bp + -6], a ; i
0203   0530 E4            pop a
0204   0531 27            mov b, a
0205   0532 E4            pop a
0206   0533 0A BF 04      jmp _while3_cond
0207   0536             _while3_exit:
0208   0536             _while4_cond:
0209   0536 2C FA FF      mov b, [bp + -6] ; i
0210   0539 D7            push a
0211   053A 11            mov a, b
0212   053B 26 00 00      mov b, 0
0213   053E B0            cmp a, b
0214   053F 0E            lodflgs
0215   0540 2F            mov bl, al
0216   0541 FD 78         mov g, a
0217   0543 FD A2 03      shr al, 3
0218   0546 FD A4 02      shr bl, 2
0219   0549 FD 87 01      and bl, %00000001
0220   054C 90            xor al, bl
0221   054D FD 27         mov b, g
0222   054F FD 87 01      and bl, %00000001
0223   0552 8C            or al, bl
0224   0553 8F 01         xor al, %00000001 ; > (signed)
0225   0555 22 00         mov ah, 0
0226   0557 27            mov b, a
0227   0558 E4            pop a
0228   0559 C0 00 00      cmp b, 0
0229   055C C6 8C 05      je _while4_exit
0230   055F             _while4_block:
0231   055F 2C FA FF      mov b, [bp + -6] ; i
0232   0562 D7            push a
0233   0563 11            mov a, b
0234   0564 FD 7D         dec b
0235   0566 D7            push a
0236   0567 11            mov a, b
0237   0568 45 FA FF      mov [bp + -6], a ; i
0238   056B E4            pop a
0239   056C 27            mov b, a
0240   056D E4            pop a
0241   056E FA FC FF      lea d, [bp + -4] ; digits beginning on the stack
0242   0571 2D            mov b, d
0243   0572 D7            push a
0244   0573 74            mov d, b
0245   0574 DA            push d
0246   0575 2C FA FF      mov b, [bp + -6] ; i
0247   0578 E7            pop d
0248   0579 10 01 00      mov a, 1
0249   057C AC            mul a, b
0250   057D 5A            add d, b
0251   057E E4            pop a
0252   057F 32            mov bl, [d]
0253   0580 A7 00         mov bh, 0
0254   0582 DD            push bl
0255   0583 07 8E 05      call _putchar
0256   0586 51 01 00      add sp, 1
0257   0589 0A 36 05      jmp _while4_cond
0258   058C             _while4_exit:
0259   058C F9            leave
0260   058D 09            ret
0261   058E             
0262   058E             _putchar:
0263   058E D2            push bp
0264   058F 9B            mov bp, sp
0265   0590             
0266   0590             ; --- BEGIN INLINE ASM BLOCK
0267   0590 20 05 00      mov al, [bp + 5]
0268   0593 23            mov ah, al
0269   0594 07 90 07      call putchar
0270   0597             ; --- END INLINE ASM BLOCK
0271   0597             
0272   0597 F9            leave
0273   0598 09            ret
0274   0599             
0275   0599             scann:
0276   0599 D2            push bp
0277   059A 9B            mov bp, sp
0278   059B 52 02 00      sub sp, 2 ; m
0279   059E             
0280   059E             ; --- BEGIN INLINE ASM BLOCK
0281   059E 07 C8 09      call scan_u16d
0282   05A1 45 FF FF      mov [bp + -1], a
0283   05A4             ; --- END INLINE ASM BLOCK
0284   05A4             
0285   05A4 2C FF FF      mov b, [bp + -1] ; m
0286   05A7 F9            leave
0287   05A8 09            ret
0288   05A9             
0289   05A9             print:
0290   05A9 D2            push bp
0291   05AA 9B            mov bp, sp
0292   05AB             
0293   05AB             ; --- BEGIN INLINE ASM BLOCK
0294   05AB 17 05 00      mov a, [bp + 5]
0295   05AE 3C            mov d, a
0296   05AF 07 CA 08      call puts
0297   05B2             ; --- END INLINE ASM BLOCK
0298   05B2             
0299   05B2 F9            leave
0300   05B3 09            ret
0301   05B4             ; --- END TEXT BLOCK
0302   05B4             
0303   05B4             ; --- BEGIN DATA BLOCK
0304   05B4             __m_data: 
0305   05B4 37 00 42 00 .dw 55,66,77,
0305   05B8 4D 00 
0306   05BA 00 00 00 00 .fill 194, 0
0306   05BE 00 00 00 00 
0306   05C2 00 00 00 00 
0306   05C6 00 00 00 00 
0306   05CA 00 00 00 00 
0306   05CE 00 00 00 00 
0306   05D2 00 00 00 00 
0306   05D6 00 00 00 00 
0306   05DA 00 00 00 00 
0306   05DE 00 00 00 00 
0306   05E2 00 00 00 00 
0306   05E6 00 00 00 00 
0306   05EA 00 00 00 00 
0306   05EE 00 00 00 00 
0306   05F2 00 00 00 00 
0306   05F6 00 00 00 00 
0306   05FA 00 00 00 00 
0306   05FE 00 00 00 00 
0306   0602 00 00 00 00 
0306   0606 00 00 00 00 
0306   060A 00 00 00 00 
0306   060E 00 00 00 00 
0306   0612 00 00 00 00 
0306   0616 00 00 00 00 
0306   061A 00 00 00 00 
0306   061E 00 00 00 00 
0306   0622 00 00 00 00 
0306   0626 00 00 00 00 
0306   062A 00 00 00 00 
0306   062E 00 00 00 00 
0306   0632 00 00 00 00 
0306   0636 00 00 00 00 
0306   063A 00 00 00 00 
0306   063E 00 00 00 00 
0306   0642 00 00 00 00 
0306   0646 00 00 00 00 
0306   064A 00 00 00 00 
0306   064E 00 00 00 00 
0306   0652 00 00 00 00 
0306   0656 00 00 00 00 
0306   065A 00 00 00 00 
0306   065E 00 00 00 00 
0306   0662 00 00 00 00 
0306   0666 00 00 00 00 
0306   066A 00 00 00 00 
0306   066E 00 00 00 00 
0306   0672 00 00 00 00 
0306   0676 00 00 00 00 
0306   067A 00 00 
0307   067C B4 05       __m: .dw __m_data
0308   067E             ; --- END DATA BLOCK
0309   067E             
0310   067E             ; --- BEGIN INCLUDE BLOCK
0311   067E             .include "lib/stdio.asm"
0001+  067E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  067E             ; stdio.s
0003+  067E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  067E             .include "lib/string.asm"
0001++ 067E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 067E             ; string.s
0003++ 067E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 067E             
0005++ 067E             
0006++ 067E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 067E             ; strrev
0008++ 067E             ; reverse a string
0009++ 067E             ; D = string address
0010++ 067E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 067E             ; 01234
0012++ 067E             strrev:
0013++ 067E 4B          	pusha
0014++ 067F 07 C5 06    	call strlen	; length in C
0015++ 0682 12          	mov a, c
0016++ 0683 AF 01 00    	cmp a, 1
0017++ 0686 D0 A0 06    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0689 7D          	dec a
0019++ 068A FD 4E       	mov si, d	; beginning of string
0020++ 068C FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 068E 59          	add d, a	; end of string
0022++ 068F 12          	mov a, c
0023++ 0690 FD 9B       	shr a		; divide by 2
0024++ 0692 39          	mov c, a	; C now counts the steps
0025++ 0693             strrev_L0:
0026++ 0693 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0694 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0695 3E          	mov [d], al	; store left char into right side
0029++ 0696 1B          	mov al, bl
0030++ 0697 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0698 7E          	dec c
0032++ 0699 7F          	dec d
0033++ 069A C2 00 00    	cmp c, 0
0034++ 069D C7 93 06    	jne strrev_L0
0035++ 06A0             strrev_end:
0036++ 06A0 4C          	popa
0037++ 06A1 09          	ret
0038++ 06A2             	
0039++ 06A2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 06A2             ; strchr
0041++ 06A2             ; search string in D for char in AL
0042++ 06A2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 06A2             strchr:
0044++ 06A2             strchr_L0:
0045++ 06A2 32          	mov bl, [d]
0046++ 06A3 C1 00       	cmp bl, 0
0047++ 06A5 C6 B0 06    	je strchr_end
0048++ 06A8 BA          	cmp al, bl
0049++ 06A9 C6 B0 06    	je strchr_end
0050++ 06AC 79          	inc d
0051++ 06AD 0A A2 06    	jmp strchr_L0
0052++ 06B0             strchr_end:
0053++ 06B0 1B          	mov al, bl
0054++ 06B1 09          	ret
0055++ 06B2             
0056++ 06B2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 06B2             ; strstr
0058++ 06B2             ; find sub-string
0059++ 06B2             ; str1 in SI
0060++ 06B2             ; str2 in DI
0061++ 06B2             ; SI points to end of source string
0062++ 06B2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 06B2             strstr:
0064++ 06B2 DB          	push al
0065++ 06B3 DA          	push d
0066++ 06B4 E3          	push di
0067++ 06B5             strstr_loop:
0068++ 06B5 F3          	cmpsb					; compare a byte of the strings
0069++ 06B6 C7 C1 06    	jne strstr_ret
0070++ 06B9 FC 00 00    	lea d, [di + 0]
0071++ 06BC BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 06BE C7 B5 06    	jne strstr_loop				; equal chars but not at end
0073++ 06C1             strstr_ret:
0074++ 06C1 F0          	pop di
0075++ 06C2 E7          	pop d
0076++ 06C3 E8          	pop al
0077++ 06C4 09          	ret
0078++ 06C5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 06C5             ; length of null terminated string
0080++ 06C5             ; result in C
0081++ 06C5             ; pointer in D
0082++ 06C5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 06C5             strlen:
0084++ 06C5 DA          	push d
0085++ 06C6 38 00 00    	mov c, 0
0086++ 06C9             strlen_L1:
0087++ 06C9 BD 00       	cmp byte [d], 0
0088++ 06CB C6 D3 06    	je strlen_ret
0089++ 06CE 79          	inc d
0090++ 06CF 78          	inc c
0091++ 06D0 0A C9 06    	jmp strlen_L1
0092++ 06D3             strlen_ret:
0093++ 06D3 E7          	pop d
0094++ 06D4 09          	ret
0095++ 06D5             
0096++ 06D5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 06D5             ; STRCMP
0098++ 06D5             ; compare two strings
0099++ 06D5             ; str1 in SI
0100++ 06D5             ; str2 in DI
0101++ 06D5             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 06D5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 06D5             strcmp:
0104++ 06D5 DB          	push al
0105++ 06D6 DA          	push d
0106++ 06D7 E3          	push di
0107++ 06D8 E2          	push si
0108++ 06D9             strcmp_loop:
0109++ 06D9 F3          	cmpsb					; compare a byte of the strings
0110++ 06DA C7 E5 06    	jne strcmp_ret
0111++ 06DD FB FF FF    	lea d, [si +- 1]
0112++ 06E0 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 06E2 C7 D9 06    	jne strcmp_loop				; equal chars but not at end
0114++ 06E5             strcmp_ret:
0115++ 06E5 EF          	pop si
0116++ 06E6 F0          	pop di
0117++ 06E7 E7          	pop d
0118++ 06E8 E8          	pop al
0119++ 06E9 09          	ret
0120++ 06EA             
0121++ 06EA             
0122++ 06EA             ; STRCPY
0123++ 06EA             ; copy null terminated string from SI to DI
0124++ 06EA             ; source in SI
0125++ 06EA             ; destination in DI
0126++ 06EA             strcpy:
0127++ 06EA E2          	push si
0128++ 06EB E3          	push di
0129++ 06EC DB          	push al
0130++ 06ED             strcpy_L1:
0131++ 06ED F6          	lodsb
0132++ 06EE F7          	stosb
0133++ 06EF B9 00       	cmp al, 0
0134++ 06F1 C7 ED 06    	jne strcpy_L1
0135++ 06F4             strcpy_end:
0136++ 06F4 E8          	pop al
0137++ 06F5 F0          	pop di
0138++ 06F6 EF          	pop si
0139++ 06F7 09          	ret
0140++ 06F8             
0141++ 06F8             ; STRCAT
0142++ 06F8             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 06F8             ; source in SI
0144++ 06F8             ; destination in DI
0145++ 06F8             strcat:
0146++ 06F8 E2          	push si
0147++ 06F9 E3          	push di
0148++ 06FA D7          	push a
0149++ 06FB DA          	push d
0150++ 06FC 50          	mov a, di
0151++ 06FD 3C          	mov d, a
0152++ 06FE             strcat_goto_end_L1:
0153++ 06FE BD 00       	cmp byte[d], 0
0154++ 0700 C6 07 07    	je strcat_start
0155++ 0703 79          	inc d
0156++ 0704 0A FE 06    	jmp strcat_goto_end_L1
0157++ 0707             strcat_start:
0158++ 0707 FD 50       	mov di, d
0159++ 0709             strcat_L1:
0160++ 0709 F6          	lodsb
0161++ 070A F7          	stosb
0162++ 070B B9 00       	cmp al, 0
0163++ 070D C7 09 07    	jne strcat_L1
0164++ 0710             strcat_end:
0165++ 0710 E7          	pop d
0166++ 0711 E4          	pop a
0167++ 0712 F0          	pop di
0168++ 0713 EF          	pop si
0169++ 0714 09          	ret
0005+  0715             
0006+  0715 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  0719 34 35 36 37 
0006+  071D 38 39 41 42 
0006+  0721 43 44 45 46 
0007+  0725 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  0729 1B 5B 48 00 
0008+  072D             
0009+  072D 01 00       table_power:.dw 1
0010+  072F 0A 00       			.dw 10
0011+  0731 64 00       			.dw 100
0012+  0733 E8 03       			.dw 1000
0013+  0735 10 27       			.dw 10000
0014+  0737             
0015+  0737             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  0737             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  0737             ; ASCII in BL
0018+  0737             ; result in AL
0019+  0737             ; ascii for F = 0100 0110
0020+  0737             ; ascii for 9 = 0011 1001
0021+  0737             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  0737             hex_ascii_encode:
0023+  0737 1B          	mov al, bl
0024+  0738 93 40       	test al, $40				; test if letter or number
0025+  073A C7 40 07    	jnz hex_letter
0026+  073D 87 0F       	and al, $0F				; get number
0027+  073F 09          	ret
0028+  0740             hex_letter:
0029+  0740 87 0F       	and al, $0F				; get letter
0030+  0742 6A 09       	add al, 9
0031+  0744 09          	ret
0032+  0745             
0033+  0745             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  0745             ; ATOI
0035+  0745             ; 2 letter hex string in B
0036+  0745             ; 8bit integer returned in AL
0037+  0745             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0745             atoi:
0039+  0745 D8          	push b
0040+  0746 07 37 07    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  0749 30          	mov bl, bh
0042+  074A DB          	push al					; save a
0043+  074B 07 37 07    	call hex_ascii_encode
0044+  074E EA          	pop bl	
0045+  074F FD 9E 04    	shl al, 4
0046+  0752 8C          	or al, bl
0047+  0753 E5          	pop b
0048+  0754 09          	ret	
0049+  0755             
0050+  0755             
0051+  0755             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  0755             ; printf
0053+  0755             ; no need for explanations!
0054+  0755             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0755             printf:
0056+  0755 09          	ret
0057+  0756             
0058+  0756             
0059+  0756             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  0756             ; scanf
0061+  0756             ; no need for explanations!
0062+  0756             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  0756             scanf:
0064+  0756 09          	ret
0065+  0757             
0066+  0757             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  0757             ; ITOA
0068+  0757             ; 8bit value in BL
0069+  0757             ; 2 byte ASCII result in A
0070+  0757             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  0757             itoa:
0072+  0757 DA          	push d
0073+  0758 D8          	push b
0074+  0759 A7 00       	mov bh, 0
0075+  075B FD A4 04    	shr bl, 4	
0076+  075E 74          	mov d, b
0077+  075F 1F 15 07    	mov al, [d + s_hex_digits]
0078+  0762 23          	mov ah, al
0079+  0763             	
0080+  0763 E5          	pop b
0081+  0764 D8          	push b
0082+  0765 A7 00       	mov bh, 0
0083+  0767 FD 87 0F    	and bl, $0F
0084+  076A 74          	mov d, b
0085+  076B 1F 15 07    	mov al, [d + s_hex_digits]
0086+  076E E5          	pop b
0087+  076F E7          	pop d
0088+  0770 09          	ret
0089+  0771             
0090+  0771             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  0771             ; HEX STRING TO BINARY
0092+  0771             ; di = destination address
0093+  0771             ; si = source
0094+  0771             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  0771             hex_to_int:
0096+  0771             hex_to_int_L1:
0097+  0771 F6          	lodsb					; load from [SI] to AL
0098+  0772 B9 00       	cmp al, 0				; check if ASCII 0
0099+  0774 C6 81 07    	jz hex_to_int_ret
0100+  0777 36          	mov bh, al
0101+  0778 F6          	lodsb
0102+  0779 2F          	mov bl, al
0103+  077A 07 45 07    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  077D F7          	stosb					; store AL to [DI]
0105+  077E 0A 71 07    	jmp hex_to_int_L1
0106+  0781             hex_to_int_ret:
0107+  0781 09          	ret		
0108+  0782             
0109+  0782             
0110+  0782             
0111+  0782             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  0782             ; GETCHAR
0113+  0782             ; char in ah
0114+  0782             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  0782             getchar:
0116+  0782 DB          	push al
0117+  0783             getchar_retry:
0118+  0783 FD 0C       	sti
0119+  0785 19 01       	mov al, 1
0120+  0787 05 03       	syscall sys_io			; receive in AH
0121+  0789 B9 00       	cmp al, 0			; check if any char was receive
0122+  078B C6 83 07    	je getchar_retry
0123+  078E E8          	pop al
0124+  078F 09          	ret
0125+  0790             
0126+  0790             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  0790             ; PUTCHAR
0128+  0790             ; char in ah
0129+  0790             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0790             putchar:
0131+  0790 D7          	push a
0132+  0791 19 00       	mov al, 0
0133+  0793 05 03       	syscall sys_io			; char in AH
0134+  0795 E4          	pop a
0135+  0796 09          	ret
0136+  0797             
0137+  0797             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  0797             ;; INPUT A STRING
0139+  0797             ;; terminates with null
0140+  0797             ;; pointer in D
0141+  0797             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  0797             gets:
0143+  0797 D7          	push a
0144+  0798 DA          	push d
0145+  0799             gets_loop:
0146+  0799 FD 0C       	sti
0147+  079B 19 01       	mov al, 1
0148+  079D 05 03       	syscall sys_io			; receive in AH
0149+  079F B9 00       	cmp al, 0				; check error code (AL)
0150+  07A1 C6 99 07    	je gets_loop			; if no char received, retry
0151+  07A4             
0152+  07A4 76 1B       	cmp ah, 27
0153+  07A6 C6 C7 07    	je gets_telnet_escape
0154+  07A9 76 0A       	cmp ah, $0A				; LF
0155+  07AB C6 20 08    	je gets_end
0156+  07AE 76 0D       	cmp ah, $0D				; CR
0157+  07B0 C6 20 08    	je gets_end
0158+  07B3 76 5C       	cmp ah, $5C				; '\\'
0159+  07B5 C6 F7 07    	je gets_escape
0160+  07B8             	
0161+  07B8 76 08       	cmp ah, $08			; check for backspace
0162+  07BA C6 C3 07    	je gets_backspace
0163+  07BD             
0164+  07BD 1A          	mov al, ah
0165+  07BE 3E          	mov [d], al
0166+  07BF 79          	inc d
0167+  07C0 0A 99 07    	jmp gets_loop
0168+  07C3             gets_backspace:
0169+  07C3 7F          	dec d
0170+  07C4 0A 99 07    	jmp gets_loop
0171+  07C7             gets_telnet_escape:
0172+  07C7 FD 0C       	sti
0173+  07C9 19 01       	mov al, 1
0174+  07CB 05 03       	syscall sys_io				; receive in AH without echo
0175+  07CD B9 00       	cmp al, 0					; check error code (AL)
0176+  07CF C6 C7 07    	je gets_telnet_escape		; if no char received, retry
0177+  07D2 76 5B       	cmp ah, '['
0178+  07D4 C7 99 07    	jne gets_loop
0179+  07D7             gets_telnet_escape_phase2:
0180+  07D7 FD 0C       	sti
0181+  07D9 19 01       	mov al, 1
0182+  07DB 05 03       	syscall sys_io					; receive in AH without echo
0183+  07DD B9 00       	cmp al, 0						; check error code (AL)
0184+  07DF C6 D7 07    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  07E2 76 44       	cmp ah, 'D'
0186+  07E4 C6 EF 07    	je gets_left_arrow
0187+  07E7 76 43       	cmp ah, 'C'
0188+  07E9 C6 F3 07    	je gets_right_arrow
0189+  07EC 0A 99 07    	jmp gets_loop
0190+  07EF             gets_left_arrow:
0191+  07EF 7F          	dec d
0192+  07F0 0A 99 07    	jmp gets_loop
0193+  07F3             gets_right_arrow:
0194+  07F3 79          	inc d
0195+  07F4 0A 99 07    	jmp gets_loop
0196+  07F7             gets_escape:
0197+  07F7 FD 0C       	sti
0198+  07F9 19 01       	mov al, 1
0199+  07FB 05 03       	syscall sys_io			; receive in AH
0200+  07FD B9 00       	cmp al, 0				; check error code (AL)
0201+  07FF C6 F7 07    	je gets_escape			; if no char received, retry
0202+  0802 76 6E       	cmp ah, 'n'
0203+  0804 C6 12 08    	je gets_LF
0204+  0807 76 72       	cmp ah, 'r'
0205+  0809 C6 19 08    	je gets_CR
0206+  080C 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  080D 3E          	mov [d], al
0208+  080E 79          	inc d
0209+  080F 0A 99 07    	jmp gets_loop
0210+  0812             gets_LF:
0211+  0812 19 0A       	mov al, $0A
0212+  0814 3E          	mov [d], al
0213+  0815 79          	inc d
0214+  0816 0A 99 07    	jmp gets_loop
0215+  0819             gets_CR:
0216+  0819 19 0D       	mov al, $0D
0217+  081B 3E          	mov [d], al
0218+  081C 79          	inc d
0219+  081D 0A 99 07    	jmp gets_loop
0220+  0820             gets_end:
0221+  0820 19 00       	mov al, 0
0222+  0822 3E          	mov [d], al				; terminate string
0223+  0823 E7          	pop d
0224+  0824 E4          	pop a
0225+  0825 09          	ret
0226+  0826             
0227+  0826             
0228+  0826             
0229+  0826             
0230+  0826             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  0826             ;; INPUT TEXT
0232+  0826             ;; terminated with CTRL+D
0233+  0826             ;; pointer in D
0234+  0826             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  0826             gettxt:
0236+  0826 D7          	push a
0237+  0827 DA          	push d
0238+  0828             gettxt_loop:
0239+  0828 19 01       	mov al, 1
0240+  082A 05 03       	syscall sys_io			; receive in AH
0241+  082C B9 00       	cmp al, 0				; check error code (AL)
0242+  082E C6 28 08    	je gettxt_loop		; if no char received, retry
0243+  0831 76 04       	cmp ah, 4			; EOT
0244+  0833 C6 71 08    	je gettxt_end
0245+  0836 76 08       	cmp ah, $08			; check for backspace
0246+  0838 C6 6D 08    	je gettxt_backspace
0247+  083B 76 5C       	cmp ah, $5C				; '\\'
0248+  083D C6 46 08    	je gettxt_escape
0249+  0840 1A          	mov al, ah
0250+  0841 3E          	mov [d], al
0251+  0842 79          	inc d
0252+  0843 0A 28 08    	jmp gettxt_loop
0253+  0846             gettxt_escape:
0254+  0846 19 01       	mov al, 1
0255+  0848 05 03       	syscall sys_io			; receive in AH
0256+  084A B9 00       	cmp al, 0				; check error code (AL)
0257+  084C C6 46 08    	je gettxt_escape		; if no char received, retry
0258+  084F 76 6E       	cmp ah, 'n'
0259+  0851 C6 5F 08    	je gettxt_LF
0260+  0854 76 72       	cmp ah, 'r'
0261+  0856 C6 66 08    	je gettxt_CR
0262+  0859 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  085A 3E          	mov [d], al
0264+  085B 79          	inc d
0265+  085C 0A 28 08    	jmp gettxt_loop
0266+  085F             gettxt_LF:
0267+  085F 19 0A       	mov al, $0A
0268+  0861 3E          	mov [d], al
0269+  0862 79          	inc d
0270+  0863 0A 28 08    	jmp gettxt_loop
0271+  0866             gettxt_CR:
0272+  0866 19 0D       	mov al, $0D
0273+  0868 3E          	mov [d], al
0274+  0869 79          	inc d
0275+  086A 0A 28 08    	jmp gettxt_loop
0276+  086D             gettxt_backspace:
0277+  086D 7F          	dec d
0278+  086E 0A 28 08    	jmp gettxt_loop
0279+  0871             gettxt_end:
0280+  0871 19 00       	mov al, 0
0281+  0873 3E          	mov [d], al				; terminate string
0282+  0874 E7          	pop d
0283+  0875 E4          	pop a
0284+  0876 09          	ret
0285+  0877             
0286+  0877             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  0877             ; PRINT NEW LINE
0288+  0877             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  0877             printnl:
0290+  0877 D7          	push a
0291+  0878 10 00 0A    	mov a, $0A00
0292+  087B 05 03       	syscall sys_io
0293+  087D 10 00 0D    	mov a, $0D00
0294+  0880 05 03       	syscall sys_io
0295+  0882 E4          	pop a
0296+  0883 09          	ret
0297+  0884             
0298+  0884             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  0884             ; strtoint
0300+  0884             ; 4 digit hex string number in d
0301+  0884             ; integer returned in A
0302+  0884             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  0884             strtointx:
0304+  0884 D8          	push b
0305+  0885 32          	mov bl, [d]
0306+  0886 37          	mov bh, bl
0307+  0887 33 01 00    	mov bl, [d + 1]
0308+  088A 07 45 07    	call atoi				; convert to int in AL
0309+  088D 23          	mov ah, al				; move to AH
0310+  088E 33 02 00    	mov bl, [d + 2]
0311+  0891 37          	mov bh, bl
0312+  0892 33 03 00    	mov bl, [d + 3]
0313+  0895 07 45 07    	call atoi				; convert to int in AL
0314+  0898 E5          	pop b
0315+  0899 09          	ret
0316+  089A             
0317+  089A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  089A             ; strtoint
0319+  089A             ; 5 digit base10 string number in d
0320+  089A             ; integer returned in A
0321+  089A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  089A             strtoint:
0323+  089A E2          	push si
0324+  089B D8          	push b
0325+  089C D9          	push c
0326+  089D DA          	push d
0327+  089E 07 C5 06    	call strlen			; get string length in C
0328+  08A1 7E          	dec c
0329+  08A2 FD 4E       	mov si, d
0330+  08A4 12          	mov a, c
0331+  08A5 FD 99       	shl a
0332+  08A7 3B 2D 07    	mov d, table_power
0333+  08AA 59          	add d, a
0334+  08AB 38 00 00    	mov c, 0
0335+  08AE             strtoint_L0:
0336+  08AE F6          	lodsb			; load ASCII to al
0337+  08AF B9 00       	cmp al, 0
0338+  08B1 C6 C4 08    	je strtoint_end
0339+  08B4 6F 30       	sub al, $30		; make into integer
0340+  08B6 22 00       	mov ah, 0
0341+  08B8 2A          	mov b, [d]
0342+  08B9 AC          	mul a, b			; result in B since it fits in 16bits
0343+  08BA 11          	mov a, b
0344+  08BB 28          	mov b, c
0345+  08BC 54          	add a, b
0346+  08BD 39          	mov c, a
0347+  08BE 63 02 00    	sub d, 2
0348+  08C1 0A AE 08    	jmp strtoint_L0
0349+  08C4             strtoint_end:
0350+  08C4 12          	mov a, c
0351+  08C5 E7          	pop d
0352+  08C6 E6          	pop c
0353+  08C7 E5          	pop b
0354+  08C8 EF          	pop si
0355+  08C9 09          	ret
0356+  08CA             
0357+  08CA             
0358+  08CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  08CA             ; PRINT NULL TERMINATED STRING
0360+  08CA             ; pointer in D
0361+  08CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  08CA             puts:
0363+  08CA D7          	push a
0364+  08CB DA          	push d
0365+  08CC             puts_L1:
0366+  08CC 1E          	mov al, [d]
0367+  08CD B9 00       	cmp al, 0
0368+  08CF C6 DB 08    	jz puts_END
0369+  08D2 23          	mov ah, al
0370+  08D3 19 00       	mov al, 0
0371+  08D5 05 03       	syscall sys_io
0372+  08D7 79          	inc d
0373+  08D8 0A CC 08    	jmp puts_L1
0374+  08DB             puts_END:
0375+  08DB E7          	pop d
0376+  08DC E4          	pop a
0377+  08DD 09          	ret
0378+  08DE             
0379+  08DE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  08DE             ; PRINT N SIZE STRING
0381+  08DE             ; pointer in D
0382+  08DE             ; size in C
0383+  08DE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  08DE             putsn:
0385+  08DE DB          	push al
0386+  08DF DA          	push d
0387+  08E0 D9          	push c
0388+  08E1             putsn_L0:
0389+  08E1 1E          	mov al, [d]
0390+  08E2 23          	mov ah, al
0391+  08E3 19 00       	mov al, 0
0392+  08E5 05 03       	syscall sys_io
0393+  08E7 79          	inc d
0394+  08E8 7E          	dec c	
0395+  08E9 C2 00 00    	cmp c, 0
0396+  08EC C7 E1 08    	jne putsn_L0
0397+  08EF             putsn_end:
0398+  08EF E6          	pop c
0399+  08F0 E7          	pop d
0400+  08F1 E8          	pop al
0401+  08F2 09          	ret
0402+  08F3             
0403+  08F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  08F3             ; print 16bit decimal number
0405+  08F3             ; input number in A
0406+  08F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  08F3             print_u16d:
0408+  08F3 D7          	push a
0409+  08F4 D8          	push b
0410+  08F5 26 10 27    	mov b, 10000
0411+  08F8 AE          	div a, b			; get 10000 coeff.
0412+  08F9 07 1F 09    	call print_number
0413+  08FC 11          	mov a, b
0414+  08FD 26 E8 03    	mov b, 1000
0415+  0900 AE          	div a, b			; get 10000 coeff.
0416+  0901 07 1F 09    	call print_number
0417+  0904 11          	mov a, b
0418+  0905 26 64 00    	mov b, 100
0419+  0908 AE          	div a, b
0420+  0909 07 1F 09    	call print_number
0421+  090C 11          	mov a, b
0422+  090D 26 0A 00    	mov b, 10
0423+  0910 AE          	div a, b
0424+  0911 07 1F 09    	call print_number
0425+  0914 11          	mov a, b
0426+  0915 6A 30       	add al, $30
0427+  0917 23          	mov ah, al
0428+  0918 19 00       	mov al, 0
0429+  091A 05 03       	syscall sys_io	; print coeff
0430+  091C E5          	pop b
0431+  091D E4          	pop a
0432+  091E 09          	ret
0433+  091F             
0434+  091F             
0435+  091F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  091F             ; if A == 0, print space
0437+  091F             ; else print A
0438+  091F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0439+  091F             print_number:
0440+  091F 6A 30       	add al, $30
0441+  0921 23          	mov ah, al
0442+  0922 07 90 07    	call putchar
0443+  0925 09          	ret
0444+  0926             
0445+  0926             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0446+  0926             ; PRINT 16BIT HEX INTEGER
0447+  0926             ; integer value in reg B
0448+  0926             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  0926             print_u16x:
0450+  0926 D7          	push a
0451+  0927 D8          	push b
0452+  0928 DD          	push bl
0453+  0929 30          	mov bl, bh
0454+  092A 07 57 07    	call itoa				; convert bh to char in A
0455+  092D 2F          	mov bl, al				; save al
0456+  092E 19 00       	mov al, 0
0457+  0930 05 03       	syscall sys_io				; display AH
0458+  0932 24          	mov ah, bl				; retrieve al
0459+  0933 19 00       	mov al, 0
0460+  0935 05 03       	syscall sys_io				; display AL
0461+  0937             
0462+  0937 EA          	pop bl
0463+  0938 07 57 07    	call itoa				; convert bh to char in A
0464+  093B 2F          	mov bl, al				; save al
0465+  093C 19 00       	mov al, 0
0466+  093E 05 03       	syscall sys_io				; display AH
0467+  0940 24          	mov ah, bl				; retrieve al
0468+  0941 19 00       	mov al, 0
0469+  0943 05 03       	syscall sys_io				; display AL
0470+  0945             
0471+  0945 E5          	pop b
0472+  0946 E4          	pop a
0473+  0947 09          	ret
0474+  0948             
0475+  0948             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  0948             ; INPUT 16BIT HEX INTEGER
0477+  0948             ; read 16bit integer into A
0478+  0948             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  0948             scan_u16x:
0480+  0948 F8 10 00    	enter 16
0481+  094B D8          	push b
0482+  094C DA          	push d
0483+  094D             
0484+  094D FA F1 FF    	lea d, [bp + -15]
0485+  0950 07 97 07    	call gets				; get number
0486+  0953             
0487+  0953 32          	mov bl, [d]
0488+  0954 37          	mov bh, bl
0489+  0955 33 01 00    	mov bl, [d + 1]
0490+  0958 07 45 07    	call atoi				; convert to int in AL
0491+  095B 23          	mov ah, al				; move to AH
0492+  095C             
0493+  095C 33 02 00    	mov bl, [d + 2]
0494+  095F 37          	mov bh, bl
0495+  0960 33 03 00    	mov bl, [d + 3]
0496+  0963 07 45 07    	call atoi				; convert to int in AL
0497+  0966             
0498+  0966 E7          	pop d
0499+  0967 E5          	pop b
0500+  0968 F9          	leave
0501+  0969 09          	ret
0502+  096A             
0503+  096A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0504+  096A             ; PRINT 8bit HEX INTEGER
0505+  096A             ; integer value in reg bl
0506+  096A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  096A             print_u8x:
0508+  096A D7          	push a
0509+  096B DD          	push bl
0510+  096C             
0511+  096C 07 57 07    	call itoa				; convert bl to char in A
0512+  096F 2F          	mov bl, al				; save al
0513+  0970 19 00       	mov al, 0
0514+  0972 05 03       	syscall sys_io				; display AH
0515+  0974 24          	mov ah, bl				; retrieve al
0516+  0975 19 00       	mov al, 0
0517+  0977 05 03       	syscall sys_io				; display AL
0518+  0979             
0519+  0979 EA          	pop bl
0520+  097A E4          	pop a
0521+  097B 09          	ret
0522+  097C             
0523+  097C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0524+  097C             ; print 8bit decimal unsigned number
0525+  097C             ; input number in AL
0526+  097C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  097C             print_u8d:
0528+  097C D7          	push a
0529+  097D D8          	push b
0530+  097E             
0531+  097E 22 00       	mov ah, 0
0532+  0980 26 64 00    	mov b, 100
0533+  0983 AE          	div a, b
0534+  0984 D8          	push b			; save remainder
0535+  0985 B9 00       	cmp al, 0
0536+  0987 C6 91 09    	je skip100
0537+  098A 6A 30       	add al, $30
0538+  098C 23          	mov ah, al
0539+  098D 19 00       	mov al, 0
0540+  098F 05 03       	syscall sys_io	; print coeff
0541+  0991             skip100:
0542+  0991 E4          	pop a
0543+  0992 22 00       	mov ah, 0
0544+  0994 26 0A 00    	mov b, 10
0545+  0997 AE          	div a, b
0546+  0998 D8          	push b			; save remainder
0547+  0999 B9 00       	cmp al, 0
0548+  099B C6 A5 09    	je skip10
0549+  099E 6A 30       	add al, $30
0550+  09A0 23          	mov ah, al
0551+  09A1 19 00       	mov al, 0
0552+  09A3 05 03       	syscall sys_io	; print coeff
0553+  09A5             skip10:
0554+  09A5 E4          	pop a
0555+  09A6 1B          	mov al, bl
0556+  09A7 6A 30       	add al, $30
0557+  09A9 23          	mov ah, al
0558+  09AA 19 00       	mov al, 0
0559+  09AC 05 03       	syscall sys_io	; print coeff
0560+  09AE E5          	pop b
0561+  09AF E4          	pop a
0562+  09B0 09          	ret
0563+  09B1             
0564+  09B1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0565+  09B1             ; INPUT 8BIT HEX INTEGER
0566+  09B1             ; read 8bit integer into AL
0567+  09B1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  09B1             scan_u8x:
0569+  09B1 F8 04 00    	enter 4
0570+  09B4 D8          	push b
0571+  09B5 DA          	push d
0572+  09B6             
0573+  09B6 FA FD FF    	lea d, [bp + -3]
0574+  09B9 07 97 07    	call gets				; get number
0575+  09BC             
0576+  09BC 32          	mov bl, [d]
0577+  09BD 37          	mov bh, bl
0578+  09BE 33 01 00    	mov bl, [d + 1]
0579+  09C1 07 45 07    	call atoi				; convert to int in AL
0580+  09C4             
0581+  09C4 E7          	pop d
0582+  09C5 E5          	pop b
0583+  09C6 F9          	leave
0584+  09C7 09          	ret
0585+  09C8             
0586+  09C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  09C8             ; input decimal number
0588+  09C8             ; result in A
0589+  09C8             ; 655'\0'
0590+  09C8             ; low--------high
0591+  09C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0592+  09C8             scan_u16d:
0593+  09C8 F8 08 00    	enter 8
0594+  09CB E2          	push si
0595+  09CC D8          	push b
0596+  09CD D9          	push c
0597+  09CE DA          	push d
0598+  09CF FA F9 FF    	lea d, [bp +- 7]
0599+  09D2 07 97 07    	call gets
0600+  09D5 07 C5 06    	call strlen			; get string length in C
0601+  09D8 7E          	dec c
0602+  09D9 FD 4E       	mov si, d
0603+  09DB 12          	mov a, c
0604+  09DC FD 99       	shl a
0605+  09DE 3B 2D 07    	mov d, table_power
0606+  09E1 59          	add d, a
0607+  09E2 38 00 00    	mov c, 0
0608+  09E5             mul_loop:
0609+  09E5 F6          	lodsb			; load ASCII to al
0610+  09E6 B9 00       	cmp al, 0
0611+  09E8 C6 FB 09    	je mul_exit
0612+  09EB 6F 30       	sub al, $30		; make into integer
0613+  09ED 22 00       	mov ah, 0
0614+  09EF 2A          	mov b, [d]
0615+  09F0 AC          	mul a, b			; result in B since it fits in 16bits
0616+  09F1 11          	mov a, b
0617+  09F2 28          	mov b, c
0618+  09F3 54          	add a, b
0619+  09F4 39          	mov c, a
0620+  09F5 63 02 00    	sub d, 2
0621+  09F8 0A E5 09    	jmp mul_loop
0622+  09FB             mul_exit:
0623+  09FB 12          	mov a, c
0624+  09FC E7          	pop d
0625+  09FD E6          	pop c
0626+  09FE E5          	pop b
0627+  09FF EF          	pop si
0628+  0A00 F9          	leave
0629+  0A01 09          	ret
0312   0A02             ; --- END INCLUDE BLOCK
0313   0A02             
0314   0A02             
0315   0A02             .end
tasm: Number of errors = 0
