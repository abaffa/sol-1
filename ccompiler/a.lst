0001   0000             ; --- FILENAME: auto.c
0002   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0400             .org PROC_TEXT_ORG
0004   0400             
0005   0400             ; --- BEGIN TEXT BLOCK
0006   0400             main:
0007   0400 D2            push bp
0008   0401 9B            mov bp, sp
0009   0402 52 02 00      sub sp, 2 ; i
0010   0405             _while1_cond:
0011   0405 26 01 00      mov b, 1
0012   0408 C0 00 00      cmp b, 0
0013   040B C6 50 04      je _while1_exit
0014   040E             _while1_block:
0015   040E 07 5E 04      call initialize
0016   0411             _for2_init:
0017   0411 26 00 00      mov b, 0
0018   0414 D7            push a
0019   0415 11            mov a, b
0020   0416 45 FF FF      mov [bp + -1], a ; i
0021   0419 E4            pop a
0022   041A             _for2_cond:
0023   041A 2C FF FF      mov b, [bp + -1] ; i
0024   041D D7            push a
0025   041E 11            mov a, b
0026   041F 29 A5 06      mov b, [SIZE]
0027   0422 B0            cmp a, b
0028   0423 0E            lodflgs
0029   0424 87 02         and al, %00000010 ; <
0030   0426 B9 00         cmp al, 0
0031   0428 0E            lodflgs
0032   0429 96            not al
0033   042A 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0034   042C 22 00         mov ah, 0
0035   042E 27            mov b, a
0036   042F E4            pop a
0037   0430 C0 00 00      cmp b, 0
0038   0433 C6 4D 04      je _for2_exit
0039   0436             _for2_block:
0040   0436 07 83 04      call compute_next
0041   0439 07 BA 05      call update_current
0042   043C 07 17 06      call display
0043   043F             _for2_update:
0044   043F 2C FF FF      mov b, [bp + -1] ; i
0045   0442 FD 77         inc b
0046   0444 D7            push a
0047   0445 11            mov a, b
0048   0446 45 FF FF      mov [bp + -1], a ; i
0049   0449 E4            pop a
0050   044A 0A 1A 04      jmp _for2_cond
0051   044D             _for2_exit:
0052   044D 0A 05 04      jmp _while1_cond
0053   0450             _while1_exit:
0054   0450 F9            leave
0055   0451 05 0B         syscall sys_terminate_proc
0056   0453             print:
0057   0453 D2            push bp
0058   0454 9B            mov bp, sp
0059   0455             
0060   0455             ; --- BEGIN INLINE ASM BLOCK
0061   0455 17 05 00      mov a, [bp + 5]
0062   0458 3C            mov d, a
0063   0459 07 8D 0A      call puts
0064   045C             ; --- END INLINE ASM BLOCK
0065   045C             
0066   045C F9            leave
0067   045D 09            ret
0068   045E             initialize:
0069   045E D2            push bp
0070   045F 9B            mov bp, sp
0071   0460 29 6F 07      mov b, [current]
0072   0463 74            mov d, b
0073   0464 DA            push d
0074   0465 29 A5 06      mov b, [SIZE]
0075   0468 D7            push a
0076   0469 11            mov a, b
0077   046A 26 02 00      mov b, 2
0078   046D AE            div a, b
0079   046E FD 78         mov g, a
0080   0470 11            mov a, b
0081   0471 FD 27         mov b, g
0082   0473 E4            pop a
0083   0474 E7            pop d
0084   0475 10 02 00      mov a, 2
0085   0478 AC            mul a, b
0086   0479 5A            add d, b
0087   047A DA            push d
0088   047B 26 01 00      mov b, 1
0089   047E E7            pop d
0090   047F 11            mov a, b
0091   0480 43            mov [d], a
0092   0481 F9            leave
0093   0482 09            ret
0094   0483             compute_next:
0095   0483 D2            push bp
0096   0484 9B            mov bp, sp
0097   0485 52 02 00      sub sp, 2 ; left
0098   0488 52 02 00      sub sp, 2 ; right
0099   048B 52 02 00      sub sp, 2 ; i
0100   048E             _for3_init:
0101   048E 26 00 00      mov b, 0
0102   0491 D7            push a
0103   0492 11            mov a, b
0104   0493 45 FB FF      mov [bp + -5], a ; i
0105   0496 E4            pop a
0106   0497             _for3_cond:
0107   0497 2C FB FF      mov b, [bp + -5] ; i
0108   049A D7            push a
0109   049B 11            mov a, b
0110   049C 29 A5 06      mov b, [SIZE]
0111   049F B0            cmp a, b
0112   04A0 0E            lodflgs
0113   04A1 87 02         and al, %00000010 ; <
0114   04A3 B9 00         cmp al, 0
0115   04A5 0E            lodflgs
0116   04A6 96            not al
0117   04A7 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0118   04A9 22 00         mov ah, 0
0119   04AB 27            mov b, a
0120   04AC E4            pop a
0121   04AD C0 00 00      cmp b, 0
0122   04B0 C6 B8 05      je _for3_exit
0123   04B3             _for3_block:
0124   04B3             _ternary4_cond:
0125   04B3 2C FB FF      mov b, [bp + -5] ; i
0126   04B6 D7            push a
0127   04B7 11            mov a, b
0128   04B8 26 00 00      mov b, 0
0129   04BB B0            cmp a, b
0130   04BC 0E            lodflgs
0131   04BD 87 01         and al, %00000001 ; ==
0132   04BF B9 00         cmp al, 0
0133   04C1 0E            lodflgs
0134   04C2 96            not al
0135   04C3 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0136   04C5 22 00         mov ah, 0
0137   04C7 27            mov b, a
0138   04C8 E4            pop a
0139   04C9 C0 00 00      cmp b, 0
0140   04CC C6 EB 04      je _ternary4_false
0141   04CF             _ternary4_true:
0142   04CF 29 6F 07      mov b, [current]
0143   04D2 D7            push a
0144   04D3 74            mov d, b
0145   04D4 DA            push d
0146   04D5 29 A5 06      mov b, [SIZE]
0147   04D8 D7            push a
0148   04D9 11            mov a, b
0149   04DA 26 01 00      mov b, 1
0150   04DD 60            sub a, b
0151   04DE 27            mov b, a
0152   04DF E4            pop a
0153   04E0 E7            pop d
0154   04E1 10 02 00      mov a, 2
0155   04E4 AC            mul a, b
0156   04E5 5A            add d, b
0157   04E6 2A            mov b, [d]
0158   04E7 E4            pop a
0159   04E8 0A 04 05      jmp _ternary4_exit
0160   04EB             _ternary4_false:
0161   04EB 29 6F 07      mov b, [current]
0162   04EE D7            push a
0163   04EF 74            mov d, b
0164   04F0 DA            push d
0165   04F1 2C FB FF      mov b, [bp + -5] ; i
0166   04F4 D7            push a
0167   04F5 11            mov a, b
0168   04F6 26 01 00      mov b, 1
0169   04F9 60            sub a, b
0170   04FA 27            mov b, a
0171   04FB E4            pop a
0172   04FC E7            pop d
0173   04FD 10 02 00      mov a, 2
0174   0500 AC            mul a, b
0175   0501 5A            add d, b
0176   0502 2A            mov b, [d]
0177   0503 E4            pop a
0178   0504             _ternary4_exit:
0179   0504 D7            push a
0180   0505 11            mov a, b
0181   0506 45 FF FF      mov [bp + -1], a ; left
0182   0509 E4            pop a
0183   050A             _ternary5_cond:
0184   050A 2C FB FF      mov b, [bp + -5] ; i
0185   050D D7            push a
0186   050E 11            mov a, b
0187   050F 29 A5 06      mov b, [SIZE]
0188   0512 D7            push a
0189   0513 11            mov a, b
0190   0514 26 01 00      mov b, 1
0191   0517 60            sub a, b
0192   0518 27            mov b, a
0193   0519 E4            pop a
0194   051A B0            cmp a, b
0195   051B 0E            lodflgs
0196   051C 87 01         and al, %00000001 ; ==
0197   051E B9 00         cmp al, 0
0198   0520 0E            lodflgs
0199   0521 96            not al
0200   0522 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0201   0524 22 00         mov ah, 0
0202   0526 27            mov b, a
0203   0527 E4            pop a
0204   0528 C0 00 00      cmp b, 0
0205   052B C6 42 05      je _ternary5_false
0206   052E             _ternary5_true:
0207   052E 29 6F 07      mov b, [current]
0208   0531 D7            push a
0209   0532 74            mov d, b
0210   0533 DA            push d
0211   0534 26 00 00      mov b, 0
0212   0537 E7            pop d
0213   0538 10 02 00      mov a, 2
0214   053B AC            mul a, b
0215   053C 5A            add d, b
0216   053D 2A            mov b, [d]
0217   053E E4            pop a
0218   053F 0A 5B 05      jmp _ternary5_exit
0219   0542             _ternary5_false:
0220   0542 29 6F 07      mov b, [current]
0221   0545 D7            push a
0222   0546 74            mov d, b
0223   0547 DA            push d
0224   0548 2C FB FF      mov b, [bp + -5] ; i
0225   054B D7            push a
0226   054C 11            mov a, b
0227   054D 26 01 00      mov b, 1
0228   0550 54            add a, b
0229   0551 27            mov b, a
0230   0552 E4            pop a
0231   0553 E7            pop d
0232   0554 10 02 00      mov a, 2
0233   0557 AC            mul a, b
0234   0558 5A            add d, b
0235   0559 2A            mov b, [d]
0236   055A E4            pop a
0237   055B             _ternary5_exit:
0238   055B D7            push a
0239   055C 11            mov a, b
0240   055D 45 FD FF      mov [bp + -3], a ; right
0241   0560 E4            pop a
0242   0561             _if6_cond:
0243   0561 2C FF FF      mov b, [bp + -1] ; left
0244   0564 D7            push a
0245   0565 11            mov a, b
0246   0566 2C FD FF      mov b, [bp + -3] ; right
0247   0569 B0            cmp a, b
0248   056A 0E            lodflgs
0249   056B 87 01         and al, %00000001 ; ==
0250   056D B9 00         cmp al, 0
0251   056F 0E            lodflgs
0252   0570 96            not al
0253   0571 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0254   0573 22 00         mov ah, 0
0255   0575 27            mov b, a
0256   0576 E4            pop a
0257   0577 C0 00 00      cmp b, 0
0258   057A C6 95 05      je _if6_else
0259   057D             _if6_true:
0260   057D 29 39 08      mov b, [next]
0261   0580 74            mov d, b
0262   0581 DA            push d
0263   0582 2C FB FF      mov b, [bp + -5] ; i
0264   0585 E7            pop d
0265   0586 10 02 00      mov a, 2
0266   0589 AC            mul a, b
0267   058A 5A            add d, b
0268   058B DA            push d
0269   058C 26 00 00      mov b, 0
0270   058F E7            pop d
0271   0590 11            mov a, b
0272   0591 43            mov [d], a
0273   0592 0A AA 05      jmp _if6_exit
0274   0595             _if6_else:
0275   0595 29 39 08      mov b, [next]
0276   0598 74            mov d, b
0277   0599 DA            push d
0278   059A 2C FB FF      mov b, [bp + -5] ; i
0279   059D E7            pop d
0280   059E 10 02 00      mov a, 2
0281   05A1 AC            mul a, b
0282   05A2 5A            add d, b
0283   05A3 DA            push d
0284   05A4 26 01 00      mov b, 1
0285   05A7 E7            pop d
0286   05A8 11            mov a, b
0287   05A9 43            mov [d], a
0288   05AA             _if6_exit:
0289   05AA             _for3_update:
0290   05AA 2C FB FF      mov b, [bp + -5] ; i
0291   05AD FD 77         inc b
0292   05AF D7            push a
0293   05B0 11            mov a, b
0294   05B1 45 FB FF      mov [bp + -5], a ; i
0295   05B4 E4            pop a
0296   05B5 0A 97 04      jmp _for3_cond
0297   05B8             _for3_exit:
0298   05B8 F9            leave
0299   05B9 09            ret
0300   05BA             update_current:
0301   05BA D2            push bp
0302   05BB 9B            mov bp, sp
0303   05BC 52 02 00      sub sp, 2 ; i
0304   05BF             _for7_init:
0305   05BF 26 00 00      mov b, 0
0306   05C2 D7            push a
0307   05C3 11            mov a, b
0308   05C4 45 FF FF      mov [bp + -1], a ; i
0309   05C7 E4            pop a
0310   05C8             _for7_cond:
0311   05C8 2C FF FF      mov b, [bp + -1] ; i
0312   05CB D7            push a
0313   05CC 11            mov a, b
0314   05CD 29 A5 06      mov b, [SIZE]
0315   05D0 B0            cmp a, b
0316   05D1 0E            lodflgs
0317   05D2 87 02         and al, %00000010 ; <
0318   05D4 B9 00         cmp al, 0
0319   05D6 0E            lodflgs
0320   05D7 96            not al
0321   05D8 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0322   05DA 22 00         mov ah, 0
0323   05DC 27            mov b, a
0324   05DD E4            pop a
0325   05DE C0 00 00      cmp b, 0
0326   05E1 C6 15 06      je _for7_exit
0327   05E4             _for7_block:
0328   05E4 29 6F 07      mov b, [current]
0329   05E7 74            mov d, b
0330   05E8 DA            push d
0331   05E9 2C FF FF      mov b, [bp + -1] ; i
0332   05EC E7            pop d
0333   05ED 10 02 00      mov a, 2
0334   05F0 AC            mul a, b
0335   05F1 5A            add d, b
0336   05F2 DA            push d
0337   05F3 29 39 08      mov b, [next]
0338   05F6 D7            push a
0339   05F7 74            mov d, b
0340   05F8 DA            push d
0341   05F9 2C FF FF      mov b, [bp + -1] ; i
0342   05FC E7            pop d
0343   05FD 10 02 00      mov a, 2
0344   0600 AC            mul a, b
0345   0601 5A            add d, b
0346   0602 2A            mov b, [d]
0347   0603 E4            pop a
0348   0604 E7            pop d
0349   0605 11            mov a, b
0350   0606 43            mov [d], a
0351   0607             _for7_update:
0352   0607 2C FF FF      mov b, [bp + -1] ; i
0353   060A FD 77         inc b
0354   060C D7            push a
0355   060D 11            mov a, b
0356   060E 45 FF FF      mov [bp + -1], a ; i
0357   0611 E4            pop a
0358   0612 0A C8 05      jmp _for7_cond
0359   0615             _for7_exit:
0360   0615 F9            leave
0361   0616 09            ret
0362   0617             display:
0363   0617 D2            push bp
0364   0618 9B            mov bp, sp
0365   0619 52 01 00      sub sp, 1 ; c
0366   061C 52 02 00      sub sp, 2 ; i
0367   061F             _for8_init:
0368   061F 26 00 00      mov b, 0
0369   0622 D7            push a
0370   0623 11            mov a, b
0371   0624 45 FE FF      mov [bp + -2], a ; i
0372   0627 E4            pop a
0373   0628             _for8_cond:
0374   0628 2C FE FF      mov b, [bp + -2] ; i
0375   062B D7            push a
0376   062C 11            mov a, b
0377   062D 29 A5 06      mov b, [SIZE]
0378   0630 B0            cmp a, b
0379   0631 0E            lodflgs
0380   0632 87 02         and al, %00000010 ; <
0381   0634 B9 00         cmp al, 0
0382   0636 0E            lodflgs
0383   0637 96            not al
0384   0638 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0385   063A 22 00         mov ah, 0
0386   063C 27            mov b, a
0387   063D E4            pop a
0388   063E C0 00 00      cmp b, 0
0389   0641 C6 97 06      je _for8_exit
0390   0644             _for8_block:
0391   0644             _if9_cond:
0392   0644 29 6F 07      mov b, [current]
0393   0647 D7            push a
0394   0648 74            mov d, b
0395   0649 DA            push d
0396   064A 2C FE FF      mov b, [bp + -2] ; i
0397   064D E7            pop d
0398   064E 10 02 00      mov a, 2
0399   0651 AC            mul a, b
0400   0652 5A            add d, b
0401   0653 2A            mov b, [d]
0402   0654 11            mov a, b
0403   0655 26 00 00      mov b, 0
0404   0658 B0            cmp a, b
0405   0659 0E            lodflgs
0406   065A 87 01         and al, %00000001
0407   065C 8F 01         xor al, %00000001 ; !=
0408   065E B9 00         cmp al, 0
0409   0660 0E            lodflgs
0410   0661 96            not al
0411   0662 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0412   0664 22 00         mov ah, 0
0413   0666 27            mov b, a
0414   0667 E4            pop a
0415   0668 C0 00 00      cmp b, 0
0416   066B C6 7D 06      je _if9_else
0417   066E             _if9_true:
0418   066E 26 3B 08      mov b, _string_0
0419   0671 FD AB         swp b
0420   0673 D8            push b
0421   0674 07 53 04      call print
0422   0677 51 02 00      add sp, 2
0423   067A 0A 89 06      jmp _if9_exit
0424   067D             _if9_else:
0425   067D 26 3D 08      mov b, _string_1
0426   0680 FD AB         swp b
0427   0682 D8            push b
0428   0683 07 53 04      call print
0429   0686 51 02 00      add sp, 2
0430   0689             _if9_exit:
0431   0689             _for8_update:
0432   0689 2C FE FF      mov b, [bp + -2] ; i
0433   068C FD 77         inc b
0434   068E D7            push a
0435   068F 11            mov a, b
0436   0690 45 FE FF      mov [bp + -2], a ; i
0437   0693 E4            pop a
0438   0694 0A 28 06      jmp _for8_cond
0439   0697             _for8_exit:
0440   0697 26 3F 08      mov b, _string_2
0441   069A FD AB         swp b
0442   069C D8            push b
0443   069D 07 53 04      call print
0444   06A0 51 02 00      add sp, 2
0445   06A3 F9            leave
0446   06A4 09            ret
0447   06A5             ; --- END TEXT BLOCK
0448   06A5             
0449   06A5             ; --- BEGIN DATA BLOCK
0450   06A5 64 00       SIZE: .dw 100
0451   06A7             current_data: 
0452   06A7 00 00 00 00 .dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0452   06AB 00 00 00 00 
0452   06AF 00 00 00 00 
0452   06B3 00 00 00 00 
0452   06B7 00 00 00 00 
0452   06BB 00 00 00 00 
0452   06BF 00 00 00 00 
0452   06C3 00 00 00 00 
0452   06C7 00 00 00 00 
0452   06CB 00 00 00 00 
0452   06CF 00 00 00 00 
0452   06D3 00 00 00 00 
0452   06D7 00 00 00 00 
0452   06DB 00 00 00 00 
0452   06DF 00 00 00 00 
0453   06E3 00 00 00 00 .dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0453   06E7 00 00 00 00 
0453   06EB 00 00 00 00 
0453   06EF 00 00 00 00 
0453   06F3 00 00 00 00 
0453   06F7 00 00 00 00 
0453   06FB 00 00 00 00 
0453   06FF 00 00 00 00 
0453   0703 00 00 00 00 
0453   0707 00 00 00 00 
0453   070B 00 00 00 00 
0453   070F 00 00 00 00 
0453   0713 00 00 00 00 
0453   0717 00 00 00 00 
0453   071B 00 00 00 00 
0454   071F 00 00 00 00 .dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0454   0723 00 00 00 00 
0454   0727 00 00 00 00 
0454   072B 00 00 00 00 
0454   072F 00 00 00 00 
0454   0733 00 00 00 00 
0454   0737 00 00 00 00 
0454   073B 00 00 00 00 
0454   073F 00 00 00 00 
0454   0743 00 00 00 00 
0454   0747 00 00 00 00 
0454   074B 00 00 00 00 
0454   074F 00 00 00 00 
0454   0753 00 00 00 00 
0454   0757 00 00 00 00 
0455   075B 00 00 00 00 .dw 0,0,0,0,0,0,0,0,0,0,
0455   075F 00 00 00 00 
0455   0763 00 00 00 00 
0455   0767 00 00 00 00 
0455   076B 00 00 00 00 
0456   076F             .fill 0, 0
0457   076F A7 06       current: .dw current_data
0458   0771             next_data: 
0459   0771 00 00 00 00 .dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0459   0775 00 00 00 00 
0459   0779 00 00 00 00 
0459   077D 00 00 00 00 
0459   0781 00 00 00 00 
0459   0785 00 00 00 00 
0459   0789 00 00 00 00 
0459   078D 00 00 00 00 
0459   0791 00 00 00 00 
0459   0795 00 00 00 00 
0459   0799 00 00 00 00 
0459   079D 00 00 00 00 
0459   07A1 00 00 00 00 
0459   07A5 00 00 00 00 
0459   07A9 00 00 00 00 
0460   07AD 00 00 00 00 .dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0460   07B1 00 00 00 00 
0460   07B5 00 00 00 00 
0460   07B9 00 00 00 00 
0460   07BD 00 00 00 00 
0460   07C1 00 00 00 00 
0460   07C5 00 00 00 00 
0460   07C9 00 00 00 00 
0460   07CD 00 00 00 00 
0460   07D1 00 00 00 00 
0460   07D5 00 00 00 00 
0460   07D9 00 00 00 00 
0460   07DD 00 00 00 00 
0460   07E1 00 00 00 00 
0460   07E5 00 00 00 00 
0461   07E9 00 00 00 00 .dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0461   07ED 00 00 00 00 
0461   07F1 00 00 00 00 
0461   07F5 00 00 00 00 
0461   07F9 00 00 00 00 
0461   07FD 00 00 00 00 
0461   0801 00 00 00 00 
0461   0805 00 00 00 00 
0461   0809 00 00 00 00 
0461   080D 00 00 00 00 
0461   0811 00 00 00 00 
0461   0815 00 00 00 00 
0461   0819 00 00 00 00 
0461   081D 00 00 00 00 
0461   0821 00 00 00 00 
0462   0825 00 00 00 00 .dw 0,0,0,0,0,0,0,0,0,0,
0462   0829 00 00 00 00 
0462   082D 00 00 00 00 
0462   0831 00 00 00 00 
0462   0835 00 00 00 00 
0463   0839             .fill 0, 0
0464   0839 71 07       next: .dw next_data
0465   083B 2A 00       _string_0: .db "*", 0
0466   083D 20 00       _string_1: .db " ", 0
0467   083F 0A 00       _string_2: .db "\n", 0
0468   0841             ; --- END DATA BLOCK
0469   0841             
0470   0841             ; --- BEGIN INCLUDE BLOCK
0471   0841             .include "lib/stdio.asm"
0001+  0841             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0841             ; stdio.s
0003+  0841             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0841             .include "lib/string.asm"
0001++ 0841             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0841             ; string.s
0003++ 0841             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0841             
0005++ 0841             
0006++ 0841             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0841             ; strrev
0008++ 0841             ; reverse a string
0009++ 0841             ; D = string address
0010++ 0841             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0841             ; 01234
0012++ 0841             strrev:
0013++ 0841 4B          	pusha
0014++ 0842 07 88 08    	call strlen	; length in C
0015++ 0845 12          	mov a, c
0016++ 0846 AF 01 00    	cmp a, 1
0017++ 0849 D0 63 08    	jleu strrev_end	; check string length. string len must be > 1
0018++ 084C 7D          	dec a
0019++ 084D FD 4E       	mov si, d	; beginning of string
0020++ 084F FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0851 59          	add d, a	; end of string
0022++ 0852 12          	mov a, c
0023++ 0853 FD 9B       	shr a		; divide by 2
0024++ 0855 39          	mov c, a	; C now counts the steps
0025++ 0856             strrev_L0:
0026++ 0856 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0857 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0858 3E          	mov [d], al	; store left char into right side
0029++ 0859 1B          	mov al, bl
0030++ 085A F7          	stosb		; store right-side char into left-side; increase DI
0031++ 085B 7E          	dec c
0032++ 085C 7F          	dec d
0033++ 085D C2 00 00    	cmp c, 0
0034++ 0860 C7 56 08    	jne strrev_L0
0035++ 0863             strrev_end:
0036++ 0863 4C          	popa
0037++ 0864 09          	ret
0038++ 0865             	
0039++ 0865             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0865             ; strchr
0041++ 0865             ; search string in D for char in AL
0042++ 0865             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0865             strchr:
0044++ 0865             strchr_L0:
0045++ 0865 32          	mov bl, [d]
0046++ 0866 C1 00       	cmp bl, 0
0047++ 0868 C6 73 08    	je strchr_end
0048++ 086B BA          	cmp al, bl
0049++ 086C C6 73 08    	je strchr_end
0050++ 086F 79          	inc d
0051++ 0870 0A 65 08    	jmp strchr_L0
0052++ 0873             strchr_end:
0053++ 0873 1B          	mov al, bl
0054++ 0874 09          	ret
0055++ 0875             
0056++ 0875             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0875             ; strstr
0058++ 0875             ; find sub-string
0059++ 0875             ; str1 in SI
0060++ 0875             ; str2 in DI
0061++ 0875             ; SI points to end of source string
0062++ 0875             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0875             strstr:
0064++ 0875 DB          	push al
0065++ 0876 DA          	push d
0066++ 0877 E3          	push di
0067++ 0878             strstr_loop:
0068++ 0878 F3          	cmpsb					; compare a byte of the strings
0069++ 0879 C7 84 08    	jne strstr_ret
0070++ 087C FC 00 00    	lea d, [di + 0]
0071++ 087F BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0881 C7 78 08    	jne strstr_loop				; equal chars but not at end
0073++ 0884             strstr_ret:
0074++ 0884 F0          	pop di
0075++ 0885 E7          	pop d
0076++ 0886 E8          	pop al
0077++ 0887 09          	ret
0078++ 0888             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0888             ; length of null terminated string
0080++ 0888             ; result in C
0081++ 0888             ; pointer in D
0082++ 0888             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0888             strlen:
0084++ 0888 DA          	push d
0085++ 0889 38 00 00    	mov c, 0
0086++ 088C             strlen_L1:
0087++ 088C BD 00       	cmp byte [d], 0
0088++ 088E C6 96 08    	je strlen_ret
0089++ 0891 79          	inc d
0090++ 0892 78          	inc c
0091++ 0893 0A 8C 08    	jmp strlen_L1
0092++ 0896             strlen_ret:
0093++ 0896 E7          	pop d
0094++ 0897 09          	ret
0095++ 0898             
0096++ 0898             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0898             ; STRCMP
0098++ 0898             ; compare two strings
0099++ 0898             ; str1 in SI
0100++ 0898             ; str2 in DI
0101++ 0898             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0898             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0898             strcmp:
0104++ 0898 DB          	push al
0105++ 0899 DA          	push d
0106++ 089A E3          	push di
0107++ 089B E2          	push si
0108++ 089C             strcmp_loop:
0109++ 089C F3          	cmpsb					; compare a byte of the strings
0110++ 089D C7 A8 08    	jne strcmp_ret
0111++ 08A0 FB FF FF    	lea d, [si +- 1]
0112++ 08A3 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 08A5 C7 9C 08    	jne strcmp_loop				; equal chars but not at end
0114++ 08A8             strcmp_ret:
0115++ 08A8 EF          	pop si
0116++ 08A9 F0          	pop di
0117++ 08AA E7          	pop d
0118++ 08AB E8          	pop al
0119++ 08AC 09          	ret
0120++ 08AD             
0121++ 08AD             
0122++ 08AD             ; STRCPY
0123++ 08AD             ; copy null terminated string from SI to DI
0124++ 08AD             ; source in SI
0125++ 08AD             ; destination in DI
0126++ 08AD             strcpy:
0127++ 08AD E2          	push si
0128++ 08AE E3          	push di
0129++ 08AF DB          	push al
0130++ 08B0             strcpy_L1:
0131++ 08B0 F6          	lodsb
0132++ 08B1 F7          	stosb
0133++ 08B2 B9 00       	cmp al, 0
0134++ 08B4 C7 B0 08    	jne strcpy_L1
0135++ 08B7             strcpy_end:
0136++ 08B7 E8          	pop al
0137++ 08B8 F0          	pop di
0138++ 08B9 EF          	pop si
0139++ 08BA 09          	ret
0140++ 08BB             
0141++ 08BB             ; STRCAT
0142++ 08BB             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 08BB             ; source in SI
0144++ 08BB             ; destination in DI
0145++ 08BB             strcat:
0146++ 08BB E2          	push si
0147++ 08BC E3          	push di
0148++ 08BD D7          	push a
0149++ 08BE DA          	push d
0150++ 08BF 50          	mov a, di
0151++ 08C0 3C          	mov d, a
0152++ 08C1             strcat_goto_end_L1:
0153++ 08C1 BD 00       	cmp byte[d], 0
0154++ 08C3 C6 CA 08    	je strcat_start
0155++ 08C6 79          	inc d
0156++ 08C7 0A C1 08    	jmp strcat_goto_end_L1
0157++ 08CA             strcat_start:
0158++ 08CA FD 50       	mov di, d
0159++ 08CC             strcat_L1:
0160++ 08CC F6          	lodsb
0161++ 08CD F7          	stosb
0162++ 08CE B9 00       	cmp al, 0
0163++ 08D0 C7 CC 08    	jne strcat_L1
0164++ 08D3             strcat_end:
0165++ 08D3 E7          	pop d
0166++ 08D4 E4          	pop a
0167++ 08D5 F0          	pop di
0168++ 08D6 EF          	pop si
0169++ 08D7 09          	ret
0005+  08D8             
0006+  08D8 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  08DC 34 35 36 37 
0006+  08E0 38 39 41 42 
0006+  08E4 43 44 45 46 
0007+  08E8 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  08EC 1B 5B 48 00 
0008+  08F0             
0009+  08F0 01 00       table_power:.dw 1
0010+  08F2 0A 00       			.dw 10
0011+  08F4 64 00       			.dw 100
0012+  08F6 E8 03       			.dw 1000
0013+  08F8 10 27       			.dw 10000
0014+  08FA             
0015+  08FA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  08FA             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  08FA             ; ASCII in BL
0018+  08FA             ; result in AL
0019+  08FA             ; ascii for F = 0100 0110
0020+  08FA             ; ascii for 9 = 0011 1001
0021+  08FA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  08FA             hex_ascii_encode:
0023+  08FA 1B          	mov al, bl
0024+  08FB 93 40       	test al, $40				; test if letter or number
0025+  08FD C7 03 09    	jnz hex_letter
0026+  0900 87 0F       	and al, $0F				; get number
0027+  0902 09          	ret
0028+  0903             hex_letter:
0029+  0903 87 0F       	and al, $0F				; get letter
0030+  0905 6A 09       	add al, 9
0031+  0907 09          	ret
0032+  0908             
0033+  0908             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  0908             ; ATOI
0035+  0908             ; 2 letter hex string in B
0036+  0908             ; 8bit integer returned in AL
0037+  0908             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0908             atoi:
0039+  0908 D8          	push b
0040+  0909 07 FA 08    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  090C 30          	mov bl, bh
0042+  090D DB          	push al					; save a
0043+  090E 07 FA 08    	call hex_ascii_encode
0044+  0911 EA          	pop bl	
0045+  0912 FD 9E 04    	shl al, 4
0046+  0915 8C          	or al, bl
0047+  0916 E5          	pop b
0048+  0917 09          	ret	
0049+  0918             
0050+  0918             
0051+  0918             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  0918             ; printf
0053+  0918             ; no need for explanations!
0054+  0918             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0918             printf:
0056+  0918 09          	ret
0057+  0919             
0058+  0919             
0059+  0919             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  0919             ; scanf
0061+  0919             ; no need for explanations!
0062+  0919             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  0919             scanf:
0064+  0919 09          	ret
0065+  091A             
0066+  091A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  091A             ; ITOA
0068+  091A             ; 8bit value in BL
0069+  091A             ; 2 byte ASCII result in A
0070+  091A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  091A             itoa:
0072+  091A DA          	push d
0073+  091B D8          	push b
0074+  091C A7 00       	mov bh, 0
0075+  091E FD A4 04    	shr bl, 4	
0076+  0921 74          	mov d, b
0077+  0922 1F D8 08    	mov al, [d + s_hex_digits]
0078+  0925 23          	mov ah, al
0079+  0926             	
0080+  0926 E5          	pop b
0081+  0927 D8          	push b
0082+  0928 A7 00       	mov bh, 0
0083+  092A FD 87 0F    	and bl, $0F
0084+  092D 74          	mov d, b
0085+  092E 1F D8 08    	mov al, [d + s_hex_digits]
0086+  0931 E5          	pop b
0087+  0932 E7          	pop d
0088+  0933 09          	ret
0089+  0934             
0090+  0934             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  0934             ; HEX STRING TO BINARY
0092+  0934             ; di = destination address
0093+  0934             ; si = source
0094+  0934             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  0934             hex_to_int:
0096+  0934             hex_to_int_L1:
0097+  0934 F6          	lodsb					; load from [SI] to AL
0098+  0935 B9 00       	cmp al, 0				; check if ASCII 0
0099+  0937 C6 44 09    	jz hex_to_int_ret
0100+  093A 36          	mov bh, al
0101+  093B F6          	lodsb
0102+  093C 2F          	mov bl, al
0103+  093D 07 08 09    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  0940 F7          	stosb					; store AL to [DI]
0105+  0941 0A 34 09    	jmp hex_to_int_L1
0106+  0944             hex_to_int_ret:
0107+  0944 09          	ret		
0108+  0945             
0109+  0945             
0110+  0945             
0111+  0945             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  0945             ; GETCHAR
0113+  0945             ; char in ah
0114+  0945             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  0945             getchar:
0116+  0945 DB          	push al
0117+  0946             getchar_retry:
0118+  0946 FD 0C       	sti
0119+  0948 19 01       	mov al, 1
0120+  094A 05 03       	syscall sys_io			; receive in AH
0121+  094C B9 00       	cmp al, 0			; check if any char was receive
0122+  094E C6 46 09    	je getchar_retry
0123+  0951 E8          	pop al
0124+  0952 09          	ret
0125+  0953             
0126+  0953             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  0953             ; PUTCHAR
0128+  0953             ; char in ah
0129+  0953             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0953             putchar:
0131+  0953 D7          	push a
0132+  0954 19 00       	mov al, 0
0133+  0956 05 03       	syscall sys_io			; char in AH
0134+  0958 E4          	pop a
0135+  0959 09          	ret
0136+  095A             
0137+  095A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  095A             ;; INPUT A STRING
0139+  095A             ;; terminates with null
0140+  095A             ;; pointer in D
0141+  095A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  095A             gets:
0143+  095A D7          	push a
0144+  095B DA          	push d
0145+  095C             gets_loop:
0146+  095C FD 0C       	sti
0147+  095E 19 01       	mov al, 1
0148+  0960 05 03       	syscall sys_io			; receive in AH
0149+  0962 B9 00       	cmp al, 0				; check error code (AL)
0150+  0964 C6 5C 09    	je gets_loop			; if no char received, retry
0151+  0967             
0152+  0967 76 1B       	cmp ah, 27
0153+  0969 C6 8A 09    	je gets_telnet_escape
0154+  096C 76 0A       	cmp ah, $0A				; LF
0155+  096E C6 E3 09    	je gets_end
0156+  0971 76 0D       	cmp ah, $0D				; CR
0157+  0973 C6 E3 09    	je gets_end
0158+  0976 76 5C       	cmp ah, $5C				; '\\'
0159+  0978 C6 BA 09    	je gets_escape
0160+  097B             	
0161+  097B 76 08       	cmp ah, $08			; check for backspace
0162+  097D C6 86 09    	je gets_backspace
0163+  0980             
0164+  0980 1A          	mov al, ah
0165+  0981 3E          	mov [d], al
0166+  0982 79          	inc d
0167+  0983 0A 5C 09    	jmp gets_loop
0168+  0986             gets_backspace:
0169+  0986 7F          	dec d
0170+  0987 0A 5C 09    	jmp gets_loop
0171+  098A             gets_telnet_escape:
0172+  098A FD 0C       	sti
0173+  098C 19 01       	mov al, 1
0174+  098E 05 03       	syscall sys_io				; receive in AH without echo
0175+  0990 B9 00       	cmp al, 0					; check error code (AL)
0176+  0992 C6 8A 09    	je gets_telnet_escape		; if no char received, retry
0177+  0995 76 5B       	cmp ah, '['
0178+  0997 C7 5C 09    	jne gets_loop
0179+  099A             gets_telnet_escape_phase2:
0180+  099A FD 0C       	sti
0181+  099C 19 01       	mov al, 1
0182+  099E 05 03       	syscall sys_io					; receive in AH without echo
0183+  09A0 B9 00       	cmp al, 0						; check error code (AL)
0184+  09A2 C6 9A 09    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  09A5 76 44       	cmp ah, 'D'
0186+  09A7 C6 B2 09    	je gets_left_arrow
0187+  09AA 76 43       	cmp ah, 'C'
0188+  09AC C6 B6 09    	je gets_right_arrow
0189+  09AF 0A 5C 09    	jmp gets_loop
0190+  09B2             gets_left_arrow:
0191+  09B2 7F          	dec d
0192+  09B3 0A 5C 09    	jmp gets_loop
0193+  09B6             gets_right_arrow:
0194+  09B6 79          	inc d
0195+  09B7 0A 5C 09    	jmp gets_loop
0196+  09BA             gets_escape:
0197+  09BA FD 0C       	sti
0198+  09BC 19 01       	mov al, 1
0199+  09BE 05 03       	syscall sys_io			; receive in AH
0200+  09C0 B9 00       	cmp al, 0				; check error code (AL)
0201+  09C2 C6 BA 09    	je gets_escape			; if no char received, retry
0202+  09C5 76 6E       	cmp ah, 'n'
0203+  09C7 C6 D5 09    	je gets_LF
0204+  09CA 76 72       	cmp ah, 'r'
0205+  09CC C6 DC 09    	je gets_CR
0206+  09CF 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  09D0 3E          	mov [d], al
0208+  09D1 79          	inc d
0209+  09D2 0A 5C 09    	jmp gets_loop
0210+  09D5             gets_LF:
0211+  09D5 19 0A       	mov al, $0A
0212+  09D7 3E          	mov [d], al
0213+  09D8 79          	inc d
0214+  09D9 0A 5C 09    	jmp gets_loop
0215+  09DC             gets_CR:
0216+  09DC 19 0D       	mov al, $0D
0217+  09DE 3E          	mov [d], al
0218+  09DF 79          	inc d
0219+  09E0 0A 5C 09    	jmp gets_loop
0220+  09E3             gets_end:
0221+  09E3 19 00       	mov al, 0
0222+  09E5 3E          	mov [d], al				; terminate string
0223+  09E6 E7          	pop d
0224+  09E7 E4          	pop a
0225+  09E8 09          	ret
0226+  09E9             
0227+  09E9             
0228+  09E9             
0229+  09E9             
0230+  09E9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  09E9             ;; INPUT TEXT
0232+  09E9             ;; terminated with CTRL+D
0233+  09E9             ;; pointer in D
0234+  09E9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  09E9             gettxt:
0236+  09E9 D7          	push a
0237+  09EA DA          	push d
0238+  09EB             gettxt_loop:
0239+  09EB 19 01       	mov al, 1
0240+  09ED 05 03       	syscall sys_io			; receive in AH
0241+  09EF B9 00       	cmp al, 0				; check error code (AL)
0242+  09F1 C6 EB 09    	je gettxt_loop		; if no char received, retry
0243+  09F4 76 04       	cmp ah, 4			; EOT
0244+  09F6 C6 34 0A    	je gettxt_end
0245+  09F9 76 08       	cmp ah, $08			; check for backspace
0246+  09FB C6 30 0A    	je gettxt_backspace
0247+  09FE 76 5C       	cmp ah, $5C				; '\\'
0248+  0A00 C6 09 0A    	je gettxt_escape
0249+  0A03 1A          	mov al, ah
0250+  0A04 3E          	mov [d], al
0251+  0A05 79          	inc d
0252+  0A06 0A EB 09    	jmp gettxt_loop
0253+  0A09             gettxt_escape:
0254+  0A09 19 01       	mov al, 1
0255+  0A0B 05 03       	syscall sys_io			; receive in AH
0256+  0A0D B9 00       	cmp al, 0				; check error code (AL)
0257+  0A0F C6 09 0A    	je gettxt_escape		; if no char received, retry
0258+  0A12 76 6E       	cmp ah, 'n'
0259+  0A14 C6 22 0A    	je gettxt_LF
0260+  0A17 76 72       	cmp ah, 'r'
0261+  0A19 C6 29 0A    	je gettxt_CR
0262+  0A1C 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  0A1D 3E          	mov [d], al
0264+  0A1E 79          	inc d
0265+  0A1F 0A EB 09    	jmp gettxt_loop
0266+  0A22             gettxt_LF:
0267+  0A22 19 0A       	mov al, $0A
0268+  0A24 3E          	mov [d], al
0269+  0A25 79          	inc d
0270+  0A26 0A EB 09    	jmp gettxt_loop
0271+  0A29             gettxt_CR:
0272+  0A29 19 0D       	mov al, $0D
0273+  0A2B 3E          	mov [d], al
0274+  0A2C 79          	inc d
0275+  0A2D 0A EB 09    	jmp gettxt_loop
0276+  0A30             gettxt_backspace:
0277+  0A30 7F          	dec d
0278+  0A31 0A EB 09    	jmp gettxt_loop
0279+  0A34             gettxt_end:
0280+  0A34 19 00       	mov al, 0
0281+  0A36 3E          	mov [d], al				; terminate string
0282+  0A37 E7          	pop d
0283+  0A38 E4          	pop a
0284+  0A39 09          	ret
0285+  0A3A             
0286+  0A3A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  0A3A             ; PRINT NEW LINE
0288+  0A3A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  0A3A             printnl:
0290+  0A3A D7          	push a
0291+  0A3B 10 00 0A    	mov a, $0A00
0292+  0A3E 05 03       	syscall sys_io
0293+  0A40 10 00 0D    	mov a, $0D00
0294+  0A43 05 03       	syscall sys_io
0295+  0A45 E4          	pop a
0296+  0A46 09          	ret
0297+  0A47             
0298+  0A47             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  0A47             ; strtoint
0300+  0A47             ; 4 digit hex string number in d
0301+  0A47             ; integer returned in A
0302+  0A47             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  0A47             strtointx:
0304+  0A47 D8          	push b
0305+  0A48 32          	mov bl, [d]
0306+  0A49 37          	mov bh, bl
0307+  0A4A 33 01 00    	mov bl, [d + 1]
0308+  0A4D 07 08 09    	call atoi				; convert to int in AL
0309+  0A50 23          	mov ah, al				; move to AH
0310+  0A51 33 02 00    	mov bl, [d + 2]
0311+  0A54 37          	mov bh, bl
0312+  0A55 33 03 00    	mov bl, [d + 3]
0313+  0A58 07 08 09    	call atoi				; convert to int in AL
0314+  0A5B E5          	pop b
0315+  0A5C 09          	ret
0316+  0A5D             
0317+  0A5D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  0A5D             ; strtoint
0319+  0A5D             ; 5 digit base10 string number in d
0320+  0A5D             ; integer returned in A
0321+  0A5D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  0A5D             strtoint:
0323+  0A5D E2          	push si
0324+  0A5E D8          	push b
0325+  0A5F D9          	push c
0326+  0A60 DA          	push d
0327+  0A61 07 88 08    	call strlen			; get string length in C
0328+  0A64 7E          	dec c
0329+  0A65 FD 4E       	mov si, d
0330+  0A67 12          	mov a, c
0331+  0A68 FD 99       	shl a
0332+  0A6A 3B F0 08    	mov d, table_power
0333+  0A6D 59          	add d, a
0334+  0A6E 38 00 00    	mov c, 0
0335+  0A71             strtoint_L0:
0336+  0A71 F6          	lodsb			; load ASCII to al
0337+  0A72 B9 00       	cmp al, 0
0338+  0A74 C6 87 0A    	je strtoint_end
0339+  0A77 6F 30       	sub al, $30		; make into integer
0340+  0A79 22 00       	mov ah, 0
0341+  0A7B 2A          	mov b, [d]
0342+  0A7C AC          	mul a, b			; result in B since it fits in 16bits
0343+  0A7D 11          	mov a, b
0344+  0A7E 28          	mov b, c
0345+  0A7F 54          	add a, b
0346+  0A80 39          	mov c, a
0347+  0A81 63 02 00    	sub d, 2
0348+  0A84 0A 71 0A    	jmp strtoint_L0
0349+  0A87             strtoint_end:
0350+  0A87 12          	mov a, c
0351+  0A88 E7          	pop d
0352+  0A89 E6          	pop c
0353+  0A8A E5          	pop b
0354+  0A8B EF          	pop si
0355+  0A8C 09          	ret
0356+  0A8D             
0357+  0A8D             
0358+  0A8D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  0A8D             ; PRINT NULL TERMINATED STRING
0360+  0A8D             ; pointer in D
0361+  0A8D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  0A8D             puts:
0363+  0A8D D7          	push a
0364+  0A8E DA          	push d
0365+  0A8F             puts_L1:
0366+  0A8F 1E          	mov al, [d]
0367+  0A90 B9 00       	cmp al, 0
0368+  0A92 C6 9E 0A    	jz puts_END
0369+  0A95 23          	mov ah, al
0370+  0A96 19 00       	mov al, 0
0371+  0A98 05 03       	syscall sys_io
0372+  0A9A 79          	inc d
0373+  0A9B 0A 8F 0A    	jmp puts_L1
0374+  0A9E             puts_END:
0375+  0A9E E7          	pop d
0376+  0A9F E4          	pop a
0377+  0AA0 09          	ret
0378+  0AA1             
0379+  0AA1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  0AA1             ; PRINT N SIZE STRING
0381+  0AA1             ; pointer in D
0382+  0AA1             ; size in C
0383+  0AA1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  0AA1             putsn:
0385+  0AA1 DB          	push al
0386+  0AA2 DA          	push d
0387+  0AA3 D9          	push c
0388+  0AA4             putsn_L0:
0389+  0AA4 1E          	mov al, [d]
0390+  0AA5 23          	mov ah, al
0391+  0AA6 19 00       	mov al, 0
0392+  0AA8 05 03       	syscall sys_io
0393+  0AAA 79          	inc d
0394+  0AAB 7E          	dec c	
0395+  0AAC C2 00 00    	cmp c, 0
0396+  0AAF C7 A4 0A    	jne putsn_L0
0397+  0AB2             putsn_end:
0398+  0AB2 E6          	pop c
0399+  0AB3 E7          	pop d
0400+  0AB4 E8          	pop al
0401+  0AB5 09          	ret
0402+  0AB6             
0403+  0AB6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  0AB6             ; print 16bit decimal number
0405+  0AB6             ; input number in A
0406+  0AB6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  0AB6             print_u16d:
0408+  0AB6 D7          	push a
0409+  0AB7 D8          	push b
0410+  0AB8 26 10 27    	mov b, 10000
0411+  0ABB AE          	div a, b			; get 10000 coeff.
0412+  0ABC 07 E2 0A    	call print_number
0413+  0ABF 11          	mov a, b
0414+  0AC0 26 E8 03    	mov b, 1000
0415+  0AC3 AE          	div a, b			; get 10000 coeff.
0416+  0AC4 07 E2 0A    	call print_number
0417+  0AC7 11          	mov a, b
0418+  0AC8 26 64 00    	mov b, 100
0419+  0ACB AE          	div a, b
0420+  0ACC 07 E2 0A    	call print_number
0421+  0ACF 11          	mov a, b
0422+  0AD0 26 0A 00    	mov b, 10
0423+  0AD3 AE          	div a, b
0424+  0AD4 07 E2 0A    	call print_number
0425+  0AD7 11          	mov a, b
0426+  0AD8 6A 30       	add al, $30
0427+  0ADA 23          	mov ah, al
0428+  0ADB 19 00       	mov al, 0
0429+  0ADD 05 03       	syscall sys_io	; print coeff
0430+  0ADF E5          	pop b
0431+  0AE0 E4          	pop a
0432+  0AE1 09          	ret
0433+  0AE2             
0434+  0AE2             
0435+  0AE2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  0AE2             ; if A == 0, print space
0437+  0AE2             ; else print A
0438+  0AE2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0439+  0AE2             print_number:
0440+  0AE2 6A 30       	add al, $30
0441+  0AE4 23          	mov ah, al
0442+  0AE5 07 53 09    	call putchar
0443+  0AE8 09          	ret
0444+  0AE9             
0445+  0AE9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0446+  0AE9             ; PRINT 16BIT HEX INTEGER
0447+  0AE9             ; integer value in reg B
0448+  0AE9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  0AE9             print_u16x:
0450+  0AE9 D7          	push a
0451+  0AEA D8          	push b
0452+  0AEB DD          	push bl
0453+  0AEC 30          	mov bl, bh
0454+  0AED 07 1A 09    	call itoa				; convert bh to char in A
0455+  0AF0 2F          	mov bl, al				; save al
0456+  0AF1 19 00       	mov al, 0
0457+  0AF3 05 03       	syscall sys_io				; display AH
0458+  0AF5 24          	mov ah, bl				; retrieve al
0459+  0AF6 19 00       	mov al, 0
0460+  0AF8 05 03       	syscall sys_io				; display AL
0461+  0AFA             
0462+  0AFA EA          	pop bl
0463+  0AFB 07 1A 09    	call itoa				; convert bh to char in A
0464+  0AFE 2F          	mov bl, al				; save al
0465+  0AFF 19 00       	mov al, 0
0466+  0B01 05 03       	syscall sys_io				; display AH
0467+  0B03 24          	mov ah, bl				; retrieve al
0468+  0B04 19 00       	mov al, 0
0469+  0B06 05 03       	syscall sys_io				; display AL
0470+  0B08             
0471+  0B08 E5          	pop b
0472+  0B09 E4          	pop a
0473+  0B0A 09          	ret
0474+  0B0B             
0475+  0B0B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  0B0B             ; INPUT 16BIT HEX INTEGER
0477+  0B0B             ; read 16bit integer into A
0478+  0B0B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  0B0B             scan_u16x:
0480+  0B0B F8 10 00    	enter 16
0481+  0B0E D8          	push b
0482+  0B0F DA          	push d
0483+  0B10             
0484+  0B10 FA F1 FF    	lea d, [bp + -15]
0485+  0B13 07 5A 09    	call gets				; get number
0486+  0B16             
0487+  0B16 32          	mov bl, [d]
0488+  0B17 37          	mov bh, bl
0489+  0B18 33 01 00    	mov bl, [d + 1]
0490+  0B1B 07 08 09    	call atoi				; convert to int in AL
0491+  0B1E 23          	mov ah, al				; move to AH
0492+  0B1F             
0493+  0B1F 33 02 00    	mov bl, [d + 2]
0494+  0B22 37          	mov bh, bl
0495+  0B23 33 03 00    	mov bl, [d + 3]
0496+  0B26 07 08 09    	call atoi				; convert to int in AL
0497+  0B29             
0498+  0B29 E7          	pop d
0499+  0B2A E5          	pop b
0500+  0B2B F9          	leave
0501+  0B2C 09          	ret
0502+  0B2D             
0503+  0B2D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0504+  0B2D             ; PRINT 8bit HEX INTEGER
0505+  0B2D             ; integer value in reg bl
0506+  0B2D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  0B2D             print_u8x:
0508+  0B2D D7          	push a
0509+  0B2E DD          	push bl
0510+  0B2F             
0511+  0B2F 07 1A 09    	call itoa				; convert bl to char in A
0512+  0B32 2F          	mov bl, al				; save al
0513+  0B33 19 00       	mov al, 0
0514+  0B35 05 03       	syscall sys_io				; display AH
0515+  0B37 24          	mov ah, bl				; retrieve al
0516+  0B38 19 00       	mov al, 0
0517+  0B3A 05 03       	syscall sys_io				; display AL
0518+  0B3C             
0519+  0B3C EA          	pop bl
0520+  0B3D E4          	pop a
0521+  0B3E 09          	ret
0522+  0B3F             
0523+  0B3F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0524+  0B3F             ; print 8bit decimal unsigned number
0525+  0B3F             ; input number in AL
0526+  0B3F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  0B3F             print_u8d:
0528+  0B3F D7          	push a
0529+  0B40 D8          	push b
0530+  0B41             
0531+  0B41 22 00       	mov ah, 0
0532+  0B43 26 64 00    	mov b, 100
0533+  0B46 AE          	div a, b
0534+  0B47 D8          	push b			; save remainder
0535+  0B48 B9 00       	cmp al, 0
0536+  0B4A C6 54 0B    	je skip100
0537+  0B4D 6A 30       	add al, $30
0538+  0B4F 23          	mov ah, al
0539+  0B50 19 00       	mov al, 0
0540+  0B52 05 03       	syscall sys_io	; print coeff
0541+  0B54             skip100:
0542+  0B54 E4          	pop a
0543+  0B55 22 00       	mov ah, 0
0544+  0B57 26 0A 00    	mov b, 10
0545+  0B5A AE          	div a, b
0546+  0B5B D8          	push b			; save remainder
0547+  0B5C B9 00       	cmp al, 0
0548+  0B5E C6 68 0B    	je skip10
0549+  0B61 6A 30       	add al, $30
0550+  0B63 23          	mov ah, al
0551+  0B64 19 00       	mov al, 0
0552+  0B66 05 03       	syscall sys_io	; print coeff
0553+  0B68             skip10:
0554+  0B68 E4          	pop a
0555+  0B69 1B          	mov al, bl
0556+  0B6A 6A 30       	add al, $30
0557+  0B6C 23          	mov ah, al
0558+  0B6D 19 00       	mov al, 0
0559+  0B6F 05 03       	syscall sys_io	; print coeff
0560+  0B71 E5          	pop b
0561+  0B72 E4          	pop a
0562+  0B73 09          	ret
0563+  0B74             
0564+  0B74             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0565+  0B74             ; INPUT 8BIT HEX INTEGER
0566+  0B74             ; read 8bit integer into AL
0567+  0B74             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  0B74             scan_u8x:
0569+  0B74 F8 04 00    	enter 4
0570+  0B77 D8          	push b
0571+  0B78 DA          	push d
0572+  0B79             
0573+  0B79 FA FD FF    	lea d, [bp + -3]
0574+  0B7C 07 5A 09    	call gets				; get number
0575+  0B7F             
0576+  0B7F 32          	mov bl, [d]
0577+  0B80 37          	mov bh, bl
0578+  0B81 33 01 00    	mov bl, [d + 1]
0579+  0B84 07 08 09    	call atoi				; convert to int in AL
0580+  0B87             
0581+  0B87 E7          	pop d
0582+  0B88 E5          	pop b
0583+  0B89 F9          	leave
0584+  0B8A 09          	ret
0585+  0B8B             
0586+  0B8B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  0B8B             ; input decimal number
0588+  0B8B             ; result in A
0589+  0B8B             ; 655'\0'
0590+  0B8B             ; low--------high
0591+  0B8B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0592+  0B8B             scan_u16d:
0593+  0B8B F8 08 00    	enter 8
0594+  0B8E E2          	push si
0595+  0B8F D8          	push b
0596+  0B90 D9          	push c
0597+  0B91 DA          	push d
0598+  0B92 FA F9 FF    	lea d, [bp +- 7]
0599+  0B95 07 5A 09    	call gets
0600+  0B98 07 88 08    	call strlen			; get string length in C
0601+  0B9B 7E          	dec c
0602+  0B9C FD 4E       	mov si, d
0603+  0B9E 12          	mov a, c
0604+  0B9F FD 99       	shl a
0605+  0BA1 3B F0 08    	mov d, table_power
0606+  0BA4 59          	add d, a
0607+  0BA5 38 00 00    	mov c, 0
0608+  0BA8             mul_loop:
0609+  0BA8 F6          	lodsb			; load ASCII to al
0610+  0BA9 B9 00       	cmp al, 0
0611+  0BAB C6 BE 0B    	je mul_exit
0612+  0BAE 6F 30       	sub al, $30		; make into integer
0613+  0BB0 22 00       	mov ah, 0
0614+  0BB2 2A          	mov b, [d]
0615+  0BB3 AC          	mul a, b			; result in B since it fits in 16bits
0616+  0BB4 11          	mov a, b
0617+  0BB5 28          	mov b, c
0618+  0BB6 54          	add a, b
0619+  0BB7 39          	mov c, a
0620+  0BB8 63 02 00    	sub d, 2
0621+  0BBB 0A A8 0B    	jmp mul_loop
0622+  0BBE             mul_exit:
0623+  0BBE 12          	mov a, c
0624+  0BBF E7          	pop d
0625+  0BC0 E6          	pop c
0626+  0BC1 E5          	pop b
0627+  0BC2 EF          	pop si
0628+  0BC3 F9          	leave
0629+  0BC4 09          	ret
0472   0BC5             ; --- END INCLUDE BLOCK
0473   0BC5             
0474   0BC5             
0475   0BC5             .end
tasm: Number of errors = 0
