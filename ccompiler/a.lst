0001   0000             ; --- FILENAME: auto.c
0002   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0400             .org PROC_TEXT_ORG
0004   0400             
0005   0400             ; --- BEGIN TEXT BLOCK
0006   0400             main:
0007   0400 D2            push bp
0008   0401 9B            mov bp, sp
0009   0402 52 02 00      sub sp, 2 ; i
0010   0405 07 4C 04      call initialize
0011   0408             _for1_init:
0012   0408 26 00 00      mov b, 0
0013   040B D7            push a
0014   040C 11            mov a, b
0015   040D 45 FF FF      mov [bp + -1], a ; i
0016   0410 E4            pop a
0017   0411             _for1_cond:
0018   0411 2C FF FF      mov b, [bp + -1] ; i
0019   0414 D7            push a
0020   0415 11            mov a, b
0021   0416 26 64 00      mov b, 100
0022   0419 B0            cmp a, b
0023   041A 0E            lodflgs
0024   041B 87 02         and al, %00000010
0025   041D 22 00         mov ah, 0
0026   041F 27            mov b, a
0027   0420 E4            pop a
0028   0421 C0 00 00      cmp b, 0
0029   0424 C6 3E 04      je _for1_exit
0030   0427             _for1_block:
0031   0427 07 63 04      call compute_next
0032   042A 07 6E 05      call update_current
0033   042D 07 BF 05      call display
0034   0430             _for1_update:
0035   0430 2C FF FF      mov b, [bp + -1] ; i
0036   0433 FD 77         inc b
0037   0435 D7            push a
0038   0436 11            mov a, b
0039   0437 45 FF FF      mov [bp + -1], a ; i
0040   043A E4            pop a
0041   043B 0A 11 04      jmp _for1_cond
0042   043E             _for1_exit:
0043   043E F9            leave
0044   043F 05 0B         syscall sys_terminate_proc
0045   0441             print:
0046   0441 D2            push bp
0047   0442 9B            mov bp, sp
0048   0443             
0049   0443             ; --- BEGIN INLINE ASM BLOCK
0050   0443 17 05 00      mov a, [bp + 5]
0051   0446 3C            mov d, a
0052   0447 07 59 09      call puts
0053   044A             ; --- END INLINE ASM BLOCK
0054   044A             
0055   044A F9            leave
0056   044B 09            ret
0057   044C             initialize:
0058   044C D2            push bp
0059   044D 9B            mov bp, sp
0060   044E 26 4D 06      mov b, current
0061   0451 74            mov d, b
0062   0452 26 19 00      mov b, 25
0063   0455 10 02 00      mov a, 2
0064   0458 AC            mul a, b
0065   0459 5A            add d, b
0066   045A DA            push d
0067   045B 26 01 00      mov b, 1
0068   045E E7            pop d
0069   045F 11            mov a, b
0070   0460 43            mov [d], a
0071   0461 F9            leave
0072   0462 09            ret
0073   0463             compute_next:
0074   0463 D2            push bp
0075   0464 9B            mov bp, sp
0076   0465 52 02 00      sub sp, 2 ; left
0077   0468 52 02 00      sub sp, 2 ; right
0078   046B 52 02 00      sub sp, 2 ; i
0079   046E             _for2_init:
0080   046E 26 00 00      mov b, 0
0081   0471 D7            push a
0082   0472 11            mov a, b
0083   0473 45 FB FF      mov [bp + -5], a ; i
0084   0476 E4            pop a
0085   0477             _for2_cond:
0086   0477 2C FB FF      mov b, [bp + -5] ; i
0087   047A D7            push a
0088   047B 11            mov a, b
0089   047C 29 3F 06      mov b, [SIZE]
0090   047F B0            cmp a, b
0091   0480 0E            lodflgs
0092   0481 87 02         and al, %00000010
0093   0483 22 00         mov ah, 0
0094   0485 27            mov b, a
0095   0486 E4            pop a
0096   0487 C0 00 00      cmp b, 0
0097   048A C6 6C 05      je _for2_exit
0098   048D             _for2_block:
0099   048D             _ternary3_cond:
0100   048D 2C FB FF      mov b, [bp + -5] ; i
0101   0490 D7            push a
0102   0491 11            mov a, b
0103   0492 26 00 00      mov b, 0
0104   0495 B0            cmp a, b
0105   0496 0E            lodflgs
0106   0497 87 01         and al, %00000001
0107   0499 22 00         mov ah, 0
0108   049B 27            mov b, a
0109   049C E4            pop a
0110   049D C0 00 00      cmp b, 0
0111   04A0 C6 BB 04      je _ternary3_false
0112   04A3             _ternary3_true:
0113   04A3 26 4D 06      mov b, current
0114   04A6 74            mov d, b
0115   04A7 29 3F 06      mov b, [SIZE]
0116   04AA D7            push a
0117   04AB 11            mov a, b
0118   04AC 26 01 00      mov b, 1
0119   04AF 60            sub a, b
0120   04B0 27            mov b, a
0121   04B1 E4            pop a
0122   04B2 10 02 00      mov a, 2
0123   04B5 AC            mul a, b
0124   04B6 5A            add d, b
0125   04B7 2A            mov b, [d]
0126   04B8 0A D0 04      jmp _ternary3_exit
0127   04BB             _ternary3_false:
0128   04BB 26 4D 06      mov b, current
0129   04BE 74            mov d, b
0130   04BF 2C FB FF      mov b, [bp + -5] ; i
0131   04C2 D7            push a
0132   04C3 11            mov a, b
0133   04C4 26 01 00      mov b, 1
0134   04C7 60            sub a, b
0135   04C8 27            mov b, a
0136   04C9 E4            pop a
0137   04CA 10 02 00      mov a, 2
0138   04CD AC            mul a, b
0139   04CE 5A            add d, b
0140   04CF 2A            mov b, [d]
0141   04D0             _ternary3_exit:
0142   04D0 D7            push a
0143   04D1 11            mov a, b
0144   04D2 45 FF FF      mov [bp + -1], a ; left
0145   04D5 E4            pop a
0146   04D6             _ternary4_cond:
0147   04D6 2C FB FF      mov b, [bp + -5] ; i
0148   04D9 D7            push a
0149   04DA 11            mov a, b
0150   04DB 29 3F 06      mov b, [SIZE]
0151   04DE D7            push a
0152   04DF 11            mov a, b
0153   04E0 26 01 00      mov b, 1
0154   04E3 60            sub a, b
0155   04E4 27            mov b, a
0156   04E5 E4            pop a
0157   04E6 B0            cmp a, b
0158   04E7 0E            lodflgs
0159   04E8 87 01         and al, %00000001
0160   04EA 22 00         mov ah, 0
0161   04EC 27            mov b, a
0162   04ED E4            pop a
0163   04EE C0 00 00      cmp b, 0
0164   04F1 C6 04 05      je _ternary4_false
0165   04F4             _ternary4_true:
0166   04F4 26 4D 06      mov b, current
0167   04F7 74            mov d, b
0168   04F8 26 00 00      mov b, 0
0169   04FB 10 02 00      mov a, 2
0170   04FE AC            mul a, b
0171   04FF 5A            add d, b
0172   0500 2A            mov b, [d]
0173   0501 0A 19 05      jmp _ternary4_exit
0174   0504             _ternary4_false:
0175   0504 26 4D 06      mov b, current
0176   0507 74            mov d, b
0177   0508 2C FB FF      mov b, [bp + -5] ; i
0178   050B D7            push a
0179   050C 11            mov a, b
0180   050D 26 01 00      mov b, 1
0181   0510 54            add a, b
0182   0511 27            mov b, a
0183   0512 E4            pop a
0184   0513 10 02 00      mov a, 2
0185   0516 AC            mul a, b
0186   0517 5A            add d, b
0187   0518 2A            mov b, [d]
0188   0519             _ternary4_exit:
0189   0519 D7            push a
0190   051A 11            mov a, b
0191   051B 45 FD FF      mov [bp + -3], a ; right
0192   051E E4            pop a
0193   051F             _if5_cond:
0194   051F 2C FF FF      mov b, [bp + -1] ; left
0195   0522 D7            push a
0196   0523 11            mov a, b
0197   0524 2C FD FF      mov b, [bp + -3] ; right
0198   0527 B0            cmp a, b
0199   0528 0E            lodflgs
0200   0529 87 01         and al, %00000001
0201   052B 22 00         mov ah, 0
0202   052D 27            mov b, a
0203   052E E4            pop a
0204   052F C0 00 00      cmp b, 0
0205   0532 C6 4B 05      je _if5_else
0206   0535             _if5_true:
0207   0535 26 B1 06      mov b, next
0208   0538 74            mov d, b
0209   0539 2C FB FF      mov b, [bp + -5] ; i
0210   053C 10 02 00      mov a, 2
0211   053F AC            mul a, b
0212   0540 5A            add d, b
0213   0541 DA            push d
0214   0542 26 00 00      mov b, 0
0215   0545 E7            pop d
0216   0546 11            mov a, b
0217   0547 43            mov [d], a
0218   0548 0A 5E 05      jmp _if5_exit
0219   054B             _if5_else:
0220   054B 26 B1 06      mov b, next
0221   054E 74            mov d, b
0222   054F 2C FB FF      mov b, [bp + -5] ; i
0223   0552 10 02 00      mov a, 2
0224   0555 AC            mul a, b
0225   0556 5A            add d, b
0226   0557 DA            push d
0227   0558 26 01 00      mov b, 1
0228   055B E7            pop d
0229   055C 11            mov a, b
0230   055D 43            mov [d], a
0231   055E             _if5_exit:
0232   055E             _for2_update:
0233   055E 2C FB FF      mov b, [bp + -5] ; i
0234   0561 FD 77         inc b
0235   0563 D7            push a
0236   0564 11            mov a, b
0237   0565 45 FB FF      mov [bp + -5], a ; i
0238   0568 E4            pop a
0239   0569 0A 77 04      jmp _for2_cond
0240   056C             _for2_exit:
0241   056C F9            leave
0242   056D 09            ret
0243   056E             update_current:
0244   056E D2            push bp
0245   056F 9B            mov bp, sp
0246   0570 52 02 00      sub sp, 2 ; i
0247   0573             _for6_init:
0248   0573 26 00 00      mov b, 0
0249   0576 D7            push a
0250   0577 11            mov a, b
0251   0578 45 FF FF      mov [bp + -1], a ; i
0252   057B E4            pop a
0253   057C             _for6_cond:
0254   057C 2C FF FF      mov b, [bp + -1] ; i
0255   057F D7            push a
0256   0580 11            mov a, b
0257   0581 29 3F 06      mov b, [SIZE]
0258   0584 B0            cmp a, b
0259   0585 0E            lodflgs
0260   0586 87 02         and al, %00000010
0261   0588 22 00         mov ah, 0
0262   058A 27            mov b, a
0263   058B E4            pop a
0264   058C C0 00 00      cmp b, 0
0265   058F C6 BD 05      je _for6_exit
0266   0592             _for6_block:
0267   0592 26 4D 06      mov b, current
0268   0595 74            mov d, b
0269   0596 2C FF FF      mov b, [bp + -1] ; i
0270   0599 10 02 00      mov a, 2
0271   059C AC            mul a, b
0272   059D 5A            add d, b
0273   059E DA            push d
0274   059F 26 B1 06      mov b, next
0275   05A2 74            mov d, b
0276   05A3 2C FF FF      mov b, [bp + -1] ; i
0277   05A6 10 02 00      mov a, 2
0278   05A9 AC            mul a, b
0279   05AA 5A            add d, b
0280   05AB 2A            mov b, [d]
0281   05AC E7            pop d
0282   05AD 11            mov a, b
0283   05AE 43            mov [d], a
0284   05AF             _for6_update:
0285   05AF 2C FF FF      mov b, [bp + -1] ; i
0286   05B2 FD 77         inc b
0287   05B4 D7            push a
0288   05B5 11            mov a, b
0289   05B6 45 FF FF      mov [bp + -1], a ; i
0290   05B9 E4            pop a
0291   05BA 0A 7C 05      jmp _for6_cond
0292   05BD             _for6_exit:
0293   05BD F9            leave
0294   05BE 09            ret
0295   05BF             display:
0296   05BF D2            push bp
0297   05C0 9B            mov bp, sp
0298   05C1 52 01 00      sub sp, 1 ; c
0299   05C4 52 02 00      sub sp, 2 ; i
0300   05C7             _for7_init:
0301   05C7 26 00 00      mov b, 0
0302   05CA D7            push a
0303   05CB 11            mov a, b
0304   05CC 45 FE FF      mov [bp + -2], a ; i
0305   05CF E4            pop a
0306   05D0             _for7_cond:
0307   05D0 2C FE FF      mov b, [bp + -2] ; i
0308   05D3 D7            push a
0309   05D4 11            mov a, b
0310   05D5 29 3F 06      mov b, [SIZE]
0311   05D8 B0            cmp a, b
0312   05D9 0E            lodflgs
0313   05DA 87 02         and al, %00000010
0314   05DC 22 00         mov ah, 0
0315   05DE 27            mov b, a
0316   05DF E4            pop a
0317   05E0 C0 00 00      cmp b, 0
0318   05E3 C6 31 06      je _for7_exit
0319   05E6             _for7_block:
0320   05E6             _if8_cond:
0321   05E6 26 4D 06      mov b, current
0322   05E9 74            mov d, b
0323   05EA 2C FE FF      mov b, [bp + -2] ; i
0324   05ED 10 02 00      mov a, 2
0325   05F0 AC            mul a, b
0326   05F1 5A            add d, b
0327   05F2 2A            mov b, [d]
0328   05F3 D7            push a
0329   05F4 11            mov a, b
0330   05F5 26 00 00      mov b, 0
0331   05F8 B0            cmp a, b
0332   05F9 0E            lodflgs
0333   05FA 87 01         and al, %00000001
0334   05FC 8F 01         xor al, %00000001
0335   05FE 22 00         mov ah, 0
0336   0600 27            mov b, a
0337   0601 E4            pop a
0338   0602 C0 00 00      cmp b, 0
0339   0605 C6 17 06      je _if8_else
0340   0608             _if8_true:
0341   0608 26 47 06      mov b, ast
0342   060B FD AB         swp b
0343   060D D8            push b
0344   060E 07 41 04      call print
0345   0611 51 02 00      add sp, 2
0346   0614 0A 23 06      jmp _if8_exit
0347   0617             _if8_else:
0348   0617 26 4B 06      mov b, space
0349   061A FD AB         swp b
0350   061C D8            push b
0351   061D 07 41 04      call print
0352   0620 51 02 00      add sp, 2
0353   0623             _if8_exit:
0354   0623             _for7_update:
0355   0623 2C FE FF      mov b, [bp + -2] ; i
0356   0626 FD 77         inc b
0357   0628 D7            push a
0358   0629 11            mov a, b
0359   062A 45 FE FF      mov [bp + -2], a ; i
0360   062D E4            pop a
0361   062E 0A D0 05      jmp _for7_cond
0362   0631             _for7_exit:
0363   0631 26 43 06      mov b, line
0364   0634 FD AB         swp b
0365   0636 D8            push b
0366   0637 07 41 04      call print
0367   063A 51 02 00      add sp, 2
0368   063D F9            leave
0369   063E 09            ret
0370   063F             ; --- END TEXT BLOCK
0371   063F             
0372   063F             ; --- BEGIN DATA BLOCK
0373   063F 32 00       SIZE: .dw 50
0374   0641 0A 00       line_data: .db "\n", 0
0375   0643 41 06       line: .dw line_data
0376   0645 2A 00       ast_data: .db "*", 0
0377   0647 45 06       ast: .dw ast_data
0378   0649 20 00       space_data: .db " ", 0
0379   064B 49 06       space: .dw space_data
0380   064D 00 00 00 00 current: .dw 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
0380   0651 00 00 00 00 
0380   0655 00 00 00 00 
0380   0659 00 00 00 00 
0380   065D 00 00 00 00 
0380   0661 00 00 00 00 
0380   0665 00 00 00 00 
0380   0669 00 00 00 00 
0380   066D 00 00 00 00 
0380   0671 00 00 00 00 
0380   0675 00 00 00 00 
0380   0679 00 00 00 00 
0380   067D 00 00 00 00 
0380   0681 00 00 00 00 
0380   0685 00 00 00 00 
0380   0689 00 00 00 00 
0380   068D 00 00 00 00 
0380   0691 00 00 00 00 
0380   0695 00 00 00 00 
0380   0699 00 00 00 00 
0380   069D 00 00 00 00 
0380   06A1 00 00 00 00 
0380   06A5 00 00 00 00 
0380   06A9 00 00 00 00 
0380   06AD 00 00 00 00 
0381   06B1 00 00 00 00 next: .dw 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
0381   06B5 00 00 00 00 
0381   06B9 00 00 00 00 
0381   06BD 00 00 00 00 
0381   06C1 00 00 00 00 
0381   06C5 00 00 00 00 
0381   06C9 00 00 00 00 
0381   06CD 00 00 00 00 
0381   06D1 00 00 00 00 
0381   06D5 00 00 00 00 
0381   06D9 00 00 00 00 
0381   06DD 00 00 00 00 
0381   06E1 00 00 00 00 
0381   06E5 00 00 00 00 
0381   06E9 00 00 00 00 
0381   06ED 00 00 00 00 
0381   06F1 00 00 00 00 
0381   06F5 00 00 00 00 
0381   06F9 00 00 00 00 
0381   06FD 00 00 00 00 
0381   0701 00 00 00 00 
0381   0705 00 00 00 00 
0381   0709 00 00 00 00 
0381   070D 00 00 00 00 
0381   0711 00 00 00 00 
0382   0715             ; --- END DATA BLOCK
0383   0715             
0384   0715             ; --- BEGIN INCLUDE BLOCK
0385   0715             .include "lib/stdio.asm"
0001+  0715             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0715             ; stdio.s
0003+  0715             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0715             .include "lib/string.asm"
0001++ 0715             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0715             ; string.s
0003++ 0715             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0715             
0005++ 0715             
0006++ 0715             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0715             ; strrev
0008++ 0715             ; reverse a string
0009++ 0715             ; D = string address
0010++ 0715             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0715             ; 01234
0012++ 0715             strrev:
0013++ 0715 4B          	pusha
0014++ 0716 07 5C 07    	call strlen	; length in C
0015++ 0719 12          	mov a, c
0016++ 071A AF 01 00    	cmp a, 1
0017++ 071D D0 37 07    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0720 7D          	dec a
0019++ 0721 FD 4E       	mov si, d	; beginning of string
0020++ 0723 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0725 59          	add d, a	; end of string
0022++ 0726 12          	mov a, c
0023++ 0727 FD 9B       	shr a		; divide by 2
0024++ 0729 39          	mov c, a	; C now counts the steps
0025++ 072A             strrev_L0:
0026++ 072A 32          	mov bl, [d]	; save load right-side char into BL
0027++ 072B F6          	lodsb		; load left-side char into AL; increase SI
0028++ 072C 3E          	mov [d], al	; store left char into right side
0029++ 072D 1B          	mov al, bl
0030++ 072E F7          	stosb		; store right-side char into left-side; increase DI
0031++ 072F 7E          	dec c
0032++ 0730 7F          	dec d
0033++ 0731 C2 00 00    	cmp c, 0
0034++ 0734 C7 2A 07    	jne strrev_L0
0035++ 0737             strrev_end:
0036++ 0737 4C          	popa
0037++ 0738 09          	ret
0038++ 0739             	
0039++ 0739             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0739             ; strchr
0041++ 0739             ; search string in D for char in AL
0042++ 0739             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0739             strchr:
0044++ 0739             strchr_L0:
0045++ 0739 32          	mov bl, [d]
0046++ 073A C1 00       	cmp bl, 0
0047++ 073C C6 47 07    	je strchr_end
0048++ 073F BA          	cmp al, bl
0049++ 0740 C6 47 07    	je strchr_end
0050++ 0743 79          	inc d
0051++ 0744 0A 39 07    	jmp strchr_L0
0052++ 0747             strchr_end:
0053++ 0747 1B          	mov al, bl
0054++ 0748 09          	ret
0055++ 0749             
0056++ 0749             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0749             ; strstr
0058++ 0749             ; find sub-string
0059++ 0749             ; str1 in SI
0060++ 0749             ; str2 in DI
0061++ 0749             ; SI points to end of source string
0062++ 0749             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0749             strstr:
0064++ 0749 DB          	push al
0065++ 074A DA          	push d
0066++ 074B E3          	push di
0067++ 074C             strstr_loop:
0068++ 074C F3          	cmpsb					; compare a byte of the strings
0069++ 074D C7 58 07    	jne strstr_ret
0070++ 0750 FC 00 00    	lea d, [di + 0]
0071++ 0753 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0755 C7 4C 07    	jne strstr_loop				; equal chars but not at end
0073++ 0758             strstr_ret:
0074++ 0758 F0          	pop di
0075++ 0759 E7          	pop d
0076++ 075A E8          	pop al
0077++ 075B 09          	ret
0078++ 075C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 075C             ; length of null terminated string
0080++ 075C             ; result in C
0081++ 075C             ; pointer in D
0082++ 075C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 075C             strlen:
0084++ 075C DA          	push d
0085++ 075D 38 00 00    	mov c, 0
0086++ 0760             strlen_L1:
0087++ 0760 BD 00       	cmp byte [d], 0
0088++ 0762 C6 6A 07    	je strlen_ret
0089++ 0765 79          	inc d
0090++ 0766 78          	inc c
0091++ 0767 0A 60 07    	jmp strlen_L1
0092++ 076A             strlen_ret:
0093++ 076A E7          	pop d
0094++ 076B 09          	ret
0095++ 076C             
0096++ 076C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 076C             ; STRCMP
0098++ 076C             ; compare two strings
0099++ 076C             ; str1 in SI
0100++ 076C             ; str2 in DI
0101++ 076C             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 076C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 076C             strcmp:
0104++ 076C DB          	push al
0105++ 076D DA          	push d
0106++ 076E E3          	push di
0107++ 076F E2          	push si
0108++ 0770             strcmp_loop:
0109++ 0770 F3          	cmpsb					; compare a byte of the strings
0110++ 0771 C7 7C 07    	jne strcmp_ret
0111++ 0774 FB FF FF    	lea d, [si +- 1]
0112++ 0777 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0779 C7 70 07    	jne strcmp_loop				; equal chars but not at end
0114++ 077C             strcmp_ret:
0115++ 077C EF          	pop si
0116++ 077D F0          	pop di
0117++ 077E E7          	pop d
0118++ 077F E8          	pop al
0119++ 0780 09          	ret
0120++ 0781             
0121++ 0781             
0122++ 0781             ; STRCPY
0123++ 0781             ; copy null terminated string from SI to DI
0124++ 0781             ; source in SI
0125++ 0781             ; destination in DI
0126++ 0781             strcpy:
0127++ 0781 E2          	push si
0128++ 0782 E3          	push di
0129++ 0783 DB          	push al
0130++ 0784             strcpy_L1:
0131++ 0784 F6          	lodsb
0132++ 0785 F7          	stosb
0133++ 0786 B9 00       	cmp al, 0
0134++ 0788 C7 84 07    	jne strcpy_L1
0135++ 078B             strcpy_end:
0136++ 078B E8          	pop al
0137++ 078C F0          	pop di
0138++ 078D EF          	pop si
0139++ 078E 09          	ret
0140++ 078F             
0141++ 078F             ; STRCAT
0142++ 078F             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 078F             ; source in SI
0144++ 078F             ; destination in DI
0145++ 078F             strcat:
0146++ 078F E2          	push si
0147++ 0790 E3          	push di
0148++ 0791 D7          	push a
0149++ 0792 DA          	push d
0150++ 0793 50          	mov a, di
0151++ 0794 3C          	mov d, a
0152++ 0795             strcat_goto_end_L1:
0153++ 0795 BD 00       	cmp byte[d], 0
0154++ 0797 C6 9E 07    	je strcat_start
0155++ 079A 79          	inc d
0156++ 079B 0A 95 07    	jmp strcat_goto_end_L1
0157++ 079E             strcat_start:
0158++ 079E FD 50       	mov di, d
0159++ 07A0             strcat_L1:
0160++ 07A0 F6          	lodsb
0161++ 07A1 F7          	stosb
0162++ 07A2 B9 00       	cmp al, 0
0163++ 07A4 C7 A0 07    	jne strcat_L1
0164++ 07A7             strcat_end:
0165++ 07A7 E7          	pop d
0166++ 07A8 E4          	pop a
0167++ 07A9 F0          	pop di
0168++ 07AA EF          	pop si
0169++ 07AB 09          	ret
0005+  07AC             
0006+  07AC 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  07B0 34 35 36 37 
0006+  07B4 38 39 41 42 
0006+  07B8 43 44 45 46 
0007+  07BC             
0008+  07BC 01 00       table_power:.dw 1
0009+  07BE 0A 00       			.dw 10
0010+  07C0 64 00       			.dw 100
0011+  07C2 E8 03       			.dw 1000
0012+  07C4 10 27       			.dw 10000
0013+  07C6             
0014+  07C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0015+  07C6             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0016+  07C6             ; ASCII in BL
0017+  07C6             ; result in AL
0018+  07C6             ; ascii for F = 0100 0110
0019+  07C6             ; ascii for 9 = 0011 1001
0020+  07C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0021+  07C6             hex_ascii_encode:
0022+  07C6 1B          	mov al, bl
0023+  07C7 93 40       	test al, $40				; test if letter or number
0024+  07C9 C7 CF 07    	jnz hex_letter
0025+  07CC 87 0F       	and al, $0F				; get number
0026+  07CE 09          	ret
0027+  07CF             hex_letter:
0028+  07CF 87 0F       	and al, $0F				; get letter
0029+  07D1 6A 09       	add al, 9
0030+  07D3 09          	ret
0031+  07D4             
0032+  07D4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0033+  07D4             ; ATOI
0034+  07D4             ; 2 letter hex string in B
0035+  07D4             ; 8bit integer returned in AL
0036+  07D4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0037+  07D4             atoi:
0038+  07D4 D8          	push b
0039+  07D5 07 C6 07    	call hex_ascii_encode			; convert BL to 4bit code in AL
0040+  07D8 30          	mov bl, bh
0041+  07D9 DB          	push al					; save a
0042+  07DA 07 C6 07    	call hex_ascii_encode
0043+  07DD EA          	pop bl	
0044+  07DE FD 9E 04    	shl al, 4
0045+  07E1 8C          	or al, bl
0046+  07E2 E5          	pop b
0047+  07E3 09          	ret	
0048+  07E4             
0049+  07E4             
0050+  07E4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  07E4             ; printf
0052+  07E4             ; no need for explanations!
0053+  07E4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0054+  07E4             printf:
0055+  07E4 09          	ret
0056+  07E5             
0057+  07E5             
0058+  07E5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  07E5             ; scanf
0060+  07E5             ; no need for explanations!
0061+  07E5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  07E5             scanf:
0063+  07E5 09          	ret
0064+  07E6             
0065+  07E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  07E6             ; ITOA
0067+  07E6             ; 8bit value in BL
0068+  07E6             ; 2 byte ASCII result in A
0069+  07E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0070+  07E6             itoa:
0071+  07E6 DA          	push d
0072+  07E7 D8          	push b
0073+  07E8 A7 00       	mov bh, 0
0074+  07EA FD A4 04    	shr bl, 4	
0075+  07ED 74          	mov d, b
0076+  07EE 1F AC 07    	mov al, [d + s_hex_digits]
0077+  07F1 23          	mov ah, al
0078+  07F2             	
0079+  07F2 E5          	pop b
0080+  07F3 D8          	push b
0081+  07F4 A7 00       	mov bh, 0
0082+  07F6 FD 87 0F    	and bl, $0F
0083+  07F9 74          	mov d, b
0084+  07FA 1F AC 07    	mov al, [d + s_hex_digits]
0085+  07FD E5          	pop b
0086+  07FE E7          	pop d
0087+  07FF 09          	ret
0088+  0800             
0089+  0800             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0090+  0800             ; HEX STRING TO BINARY
0091+  0800             ; di = destination address
0092+  0800             ; si = source
0093+  0800             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0094+  0800             hex_to_int:
0095+  0800             hex_to_int_L1:
0096+  0800 F6          	lodsb					; load from [SI] to AL
0097+  0801 B9 00       	cmp al, 0				; check if ASCII 0
0098+  0803 C6 10 08    	jz hex_to_int_ret
0099+  0806 36          	mov bh, al
0100+  0807 F6          	lodsb
0101+  0808 2F          	mov bl, al
0102+  0809 07 D4 07    	call atoi				; convert ASCII byte in B to int (to AL)
0103+  080C F7          	stosb					; store AL to [DI]
0104+  080D 0A 00 08    	jmp hex_to_int_L1
0105+  0810             hex_to_int_ret:
0106+  0810 09          	ret		
0107+  0811             
0108+  0811             
0109+  0811             
0110+  0811             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  0811             ; GETCHAR
0112+  0811             ; char in ah
0113+  0811             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0114+  0811             getchar:
0115+  0811 DB          	push al
0116+  0812             getchar_retry:
0117+  0812 FD 0C       	sti
0118+  0814 19 01       	mov al, 1
0119+  0816 05 03       	syscall sys_io			; receive in AH
0120+  0818 B9 00       	cmp al, 0			; check if any char was receive
0121+  081A C6 12 08    	je getchar_retry
0122+  081D E8          	pop al
0123+  081E 09          	ret
0124+  081F             
0125+  081F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0126+  081F             ; PUTCHAR
0127+  081F             ; char in ah
0128+  081F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  081F             putchar:
0130+  081F D7          	push a
0131+  0820 19 00       	mov al, 0
0132+  0822 05 03       	syscall sys_io			; char in AH
0133+  0824 E4          	pop a
0134+  0825 09          	ret
0135+  0826             
0136+  0826             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0137+  0826             ;; INPUT A STRING
0138+  0826             ;; terminates with null
0139+  0826             ;; pointer in D
0140+  0826             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  0826             gets:
0142+  0826 D7          	push a
0143+  0827 DA          	push d
0144+  0828             gets_loop:
0145+  0828 FD 0C       	sti
0146+  082A 19 01       	mov al, 1
0147+  082C 05 03       	syscall sys_io			; receive in AH
0148+  082E B9 00       	cmp al, 0				; check error code (AL)
0149+  0830 C6 28 08    	je gets_loop			; if no char received, retry
0150+  0833             
0151+  0833 76 1B       	cmp ah, 27
0152+  0835 C6 56 08    	je gets_telnet_escape
0153+  0838 76 0A       	cmp ah, $0A				; LF
0154+  083A C6 AF 08    	je gets_end
0155+  083D 76 0D       	cmp ah, $0D				; CR
0156+  083F C6 AF 08    	je gets_end
0157+  0842 76 5C       	cmp ah, $5C				; '\\'
0158+  0844 C6 86 08    	je gets_escape
0159+  0847             	
0160+  0847 76 08       	cmp ah, $08			; check for backspace
0161+  0849 C6 52 08    	je gets_backspace
0162+  084C             
0163+  084C 1A          	mov al, ah
0164+  084D 3E          	mov [d], al
0165+  084E 79          	inc d
0166+  084F 0A 28 08    	jmp gets_loop
0167+  0852             gets_backspace:
0168+  0852 7F          	dec d
0169+  0853 0A 28 08    	jmp gets_loop
0170+  0856             gets_telnet_escape:
0171+  0856 FD 0C       	sti
0172+  0858 19 01       	mov al, 1
0173+  085A 05 03       	syscall sys_io				; receive in AH without echo
0174+  085C B9 00       	cmp al, 0					; check error code (AL)
0175+  085E C6 56 08    	je gets_telnet_escape		; if no char received, retry
0176+  0861 76 5B       	cmp ah, '['
0177+  0863 C7 28 08    	jne gets_loop
0178+  0866             gets_telnet_escape_phase2:
0179+  0866 FD 0C       	sti
0180+  0868 19 01       	mov al, 1
0181+  086A 05 03       	syscall sys_io					; receive in AH without echo
0182+  086C B9 00       	cmp al, 0						; check error code (AL)
0183+  086E C6 66 08    	je gets_telnet_escape_phase2	; if no char received, retry
0184+  0871 76 44       	cmp ah, 'D'
0185+  0873 C6 7E 08    	je gets_left_arrow
0186+  0876 76 43       	cmp ah, 'C'
0187+  0878 C6 82 08    	je gets_right_arrow
0188+  087B 0A 28 08    	jmp gets_loop
0189+  087E             gets_left_arrow:
0190+  087E 7F          	dec d
0191+  087F 0A 28 08    	jmp gets_loop
0192+  0882             gets_right_arrow:
0193+  0882 79          	inc d
0194+  0883 0A 28 08    	jmp gets_loop
0195+  0886             gets_escape:
0196+  0886 FD 0C       	sti
0197+  0888 19 01       	mov al, 1
0198+  088A 05 03       	syscall sys_io			; receive in AH
0199+  088C B9 00       	cmp al, 0				; check error code (AL)
0200+  088E C6 86 08    	je gets_escape			; if no char received, retry
0201+  0891 76 6E       	cmp ah, 'n'
0202+  0893 C6 A1 08    	je gets_LF
0203+  0896 76 72       	cmp ah, 'r'
0204+  0898 C6 A8 08    	je gets_CR
0205+  089B 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0206+  089C 3E          	mov [d], al
0207+  089D 79          	inc d
0208+  089E 0A 28 08    	jmp gets_loop
0209+  08A1             gets_LF:
0210+  08A1 19 0A       	mov al, $0A
0211+  08A3 3E          	mov [d], al
0212+  08A4 79          	inc d
0213+  08A5 0A 28 08    	jmp gets_loop
0214+  08A8             gets_CR:
0215+  08A8 19 0D       	mov al, $0D
0216+  08AA 3E          	mov [d], al
0217+  08AB 79          	inc d
0218+  08AC 0A 28 08    	jmp gets_loop
0219+  08AF             gets_end:
0220+  08AF 19 00       	mov al, 0
0221+  08B1 3E          	mov [d], al				; terminate string
0222+  08B2 E7          	pop d
0223+  08B3 E4          	pop a
0224+  08B4 09          	ret
0225+  08B5             
0226+  08B5             
0227+  08B5             
0228+  08B5             
0229+  08B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0230+  08B5             ;; INPUT TEXT
0231+  08B5             ;; terminated with CTRL+D
0232+  08B5             ;; pointer in D
0233+  08B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0234+  08B5             gettxt:
0235+  08B5 D7          	push a
0236+  08B6 DA          	push d
0237+  08B7             gettxt_loop:
0238+  08B7 19 01       	mov al, 1
0239+  08B9 05 03       	syscall sys_io			; receive in AH
0240+  08BB B9 00       	cmp al, 0				; check error code (AL)
0241+  08BD C6 B7 08    	je gettxt_loop		; if no char received, retry
0242+  08C0 76 04       	cmp ah, 4			; EOT
0243+  08C2 C6 00 09    	je gettxt_end
0244+  08C5 76 08       	cmp ah, $08			; check for backspace
0245+  08C7 C6 FC 08    	je gettxt_backspace
0246+  08CA 76 5C       	cmp ah, $5C				; '\\'
0247+  08CC C6 D5 08    	je gettxt_escape
0248+  08CF 1A          	mov al, ah
0249+  08D0 3E          	mov [d], al
0250+  08D1 79          	inc d
0251+  08D2 0A B7 08    	jmp gettxt_loop
0252+  08D5             gettxt_escape:
0253+  08D5 19 01       	mov al, 1
0254+  08D7 05 03       	syscall sys_io			; receive in AH
0255+  08D9 B9 00       	cmp al, 0				; check error code (AL)
0256+  08DB C6 D5 08    	je gettxt_escape		; if no char received, retry
0257+  08DE 76 6E       	cmp ah, 'n'
0258+  08E0 C6 EE 08    	je gettxt_LF
0259+  08E3 76 72       	cmp ah, 'r'
0260+  08E5 C6 F5 08    	je gettxt_CR
0261+  08E8 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0262+  08E9 3E          	mov [d], al
0263+  08EA 79          	inc d
0264+  08EB 0A B7 08    	jmp gettxt_loop
0265+  08EE             gettxt_LF:
0266+  08EE 19 0A       	mov al, $0A
0267+  08F0 3E          	mov [d], al
0268+  08F1 79          	inc d
0269+  08F2 0A B7 08    	jmp gettxt_loop
0270+  08F5             gettxt_CR:
0271+  08F5 19 0D       	mov al, $0D
0272+  08F7 3E          	mov [d], al
0273+  08F8 79          	inc d
0274+  08F9 0A B7 08    	jmp gettxt_loop
0275+  08FC             gettxt_backspace:
0276+  08FC 7F          	dec d
0277+  08FD 0A B7 08    	jmp gettxt_loop
0278+  0900             gettxt_end:
0279+  0900 19 00       	mov al, 0
0280+  0902 3E          	mov [d], al				; terminate string
0281+  0903 E7          	pop d
0282+  0904 E4          	pop a
0283+  0905 09          	ret
0284+  0906             
0285+  0906             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0286+  0906             ; PRINT NEW LINE
0287+  0906             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  0906             printnl:
0289+  0906 D7          	push a
0290+  0907 10 00 0A    	mov a, $0A00
0291+  090A 05 03       	syscall sys_io
0292+  090C 10 00 0D    	mov a, $0D00
0293+  090F 05 03       	syscall sys_io
0294+  0911 E4          	pop a
0295+  0912 09          	ret
0296+  0913             
0297+  0913             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0298+  0913             ; strtoint
0299+  0913             ; 4 digit hex string number in d
0300+  0913             ; integer returned in A
0301+  0913             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0302+  0913             strtointx:
0303+  0913 D8          	push b
0304+  0914 32          	mov bl, [d]
0305+  0915 37          	mov bh, bl
0306+  0916 33 01 00    	mov bl, [d + 1]
0307+  0919 07 D4 07    	call atoi				; convert to int in AL
0308+  091C 23          	mov ah, al				; move to AH
0309+  091D 33 02 00    	mov bl, [d + 2]
0310+  0920 37          	mov bh, bl
0311+  0921 33 03 00    	mov bl, [d + 3]
0312+  0924 07 D4 07    	call atoi				; convert to int in AL
0313+  0927 E5          	pop b
0314+  0928 09          	ret
0315+  0929             
0316+  0929             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0317+  0929             ; strtoint
0318+  0929             ; 5 digit base10 string number in d
0319+  0929             ; integer returned in A
0320+  0929             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0321+  0929             strtoint:
0322+  0929 E2          	push si
0323+  092A D8          	push b
0324+  092B D9          	push c
0325+  092C DA          	push d
0326+  092D 07 5C 07    	call strlen			; get string length in C
0327+  0930 7E          	dec c
0328+  0931 FD 4E       	mov si, d
0329+  0933 12          	mov a, c
0330+  0934 FD 99       	shl a
0331+  0936 3B BC 07    	mov d, table_power
0332+  0939 59          	add d, a
0333+  093A 38 00 00    	mov c, 0
0334+  093D             strtoint_L0:
0335+  093D F6          	lodsb			; load ASCII to al
0336+  093E B9 00       	cmp al, 0
0337+  0940 C6 53 09    	je strtoint_end
0338+  0943 6F 30       	sub al, $30		; make into integer
0339+  0945 22 00       	mov ah, 0
0340+  0947 2A          	mov b, [d]
0341+  0948 AC          	mul a, b			; result in B since it fits in 16bits
0342+  0949 11          	mov a, b
0343+  094A 28          	mov b, c
0344+  094B 54          	add a, b
0345+  094C 39          	mov c, a
0346+  094D 63 02 00    	sub d, 2
0347+  0950 0A 3D 09    	jmp strtoint_L0
0348+  0953             strtoint_end:
0349+  0953 12          	mov a, c
0350+  0954 E7          	pop d
0351+  0955 E6          	pop c
0352+  0956 E5          	pop b
0353+  0957 EF          	pop si
0354+  0958 09          	ret
0355+  0959             
0356+  0959             
0357+  0959             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0358+  0959             ; PRINT NULL TERMINATED STRING
0359+  0959             ; pointer in D
0360+  0959             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0361+  0959             puts:
0362+  0959 D7          	push a
0363+  095A DA          	push d
0364+  095B             puts_L1:
0365+  095B 1E          	mov al, [d]
0366+  095C B9 00       	cmp al, 0
0367+  095E C6 6A 09    	jz puts_END
0368+  0961 23          	mov ah, al
0369+  0962 19 00       	mov al, 0
0370+  0964 05 03       	syscall sys_io
0371+  0966 79          	inc d
0372+  0967 0A 5B 09    	jmp puts_L1
0373+  096A             puts_END:
0374+  096A E7          	pop d
0375+  096B E4          	pop a
0376+  096C 09          	ret
0377+  096D             
0378+  096D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  096D             ; PRINT N SIZE STRING
0380+  096D             ; pointer in D
0381+  096D             ; size in C
0382+  096D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0383+  096D             putsn:
0384+  096D DB          	push al
0385+  096E DA          	push d
0386+  096F D9          	push c
0387+  0970             putsn_L0:
0388+  0970 1E          	mov al, [d]
0389+  0971 23          	mov ah, al
0390+  0972 19 00       	mov al, 0
0391+  0974 05 03       	syscall sys_io
0392+  0976 79          	inc d
0393+  0977 7E          	dec c	
0394+  0978 C2 00 00    	cmp c, 0
0395+  097B C7 70 09    	jne putsn_L0
0396+  097E             putsn_end:
0397+  097E E6          	pop c
0398+  097F E7          	pop d
0399+  0980 E8          	pop al
0400+  0981 09          	ret
0401+  0982             
0402+  0982             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0403+  0982             ; print 16bit decimal number
0404+  0982             ; input number in A
0405+  0982             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  0982             print_u16d:
0407+  0982 D7          	push a
0408+  0983 D8          	push b
0409+  0984 26 10 27    	mov b, 10000
0410+  0987 AE          	div a, b			; get 10000 coeff.
0411+  0988 07 AE 09    	call print_number
0412+  098B 11          	mov a, b
0413+  098C 26 E8 03    	mov b, 1000
0414+  098F AE          	div a, b			; get 10000 coeff.
0415+  0990 07 AE 09    	call print_number
0416+  0993 11          	mov a, b
0417+  0994 26 64 00    	mov b, 100
0418+  0997 AE          	div a, b
0419+  0998 07 AE 09    	call print_number
0420+  099B 11          	mov a, b
0421+  099C 26 0A 00    	mov b, 10
0422+  099F AE          	div a, b
0423+  09A0 07 AE 09    	call print_number
0424+  09A3 11          	mov a, b
0425+  09A4 6A 30       	add al, $30
0426+  09A6 23          	mov ah, al
0427+  09A7 19 00       	mov al, 0
0428+  09A9 05 03       	syscall sys_io	; print coeff
0429+  09AB E5          	pop b
0430+  09AC E4          	pop a
0431+  09AD 09          	ret
0432+  09AE             
0433+  09AE             
0434+  09AE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0435+  09AE             ; if A == 0, print space
0436+  09AE             ; else print A
0437+  09AE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0438+  09AE             print_number:
0439+  09AE 6A 30       	add al, $30
0440+  09B0 23          	mov ah, al
0441+  09B1 07 1F 08    	call putchar
0442+  09B4 09          	ret
0443+  09B5             
0444+  09B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  09B5             ; PRINT 16BIT HEX INTEGER
0446+  09B5             ; integer value in reg B
0447+  09B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  09B5             print_u16x:
0449+  09B5 D7          	push a
0450+  09B6 D8          	push b
0451+  09B7 DD          	push bl
0452+  09B8 30          	mov bl, bh
0453+  09B9 07 E6 07    	call itoa				; convert bh to char in A
0454+  09BC 2F          	mov bl, al				; save al
0455+  09BD 19 00       	mov al, 0
0456+  09BF 05 03       	syscall sys_io				; display AH
0457+  09C1 24          	mov ah, bl				; retrieve al
0458+  09C2 19 00       	mov al, 0
0459+  09C4 05 03       	syscall sys_io				; display AL
0460+  09C6             
0461+  09C6 EA          	pop bl
0462+  09C7 07 E6 07    	call itoa				; convert bh to char in A
0463+  09CA 2F          	mov bl, al				; save al
0464+  09CB 19 00       	mov al, 0
0465+  09CD 05 03       	syscall sys_io				; display AH
0466+  09CF 24          	mov ah, bl				; retrieve al
0467+  09D0 19 00       	mov al, 0
0468+  09D2 05 03       	syscall sys_io				; display AL
0469+  09D4             
0470+  09D4 E5          	pop b
0471+  09D5 E4          	pop a
0472+  09D6 09          	ret
0473+  09D7             
0474+  09D7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0475+  09D7             ; INPUT 16BIT HEX INTEGER
0476+  09D7             ; read 16bit integer into A
0477+  09D7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0478+  09D7             scan_u16x:
0479+  09D7 F8 10 00    	enter 16
0480+  09DA D8          	push b
0481+  09DB DA          	push d
0482+  09DC             
0483+  09DC FA F1 FF    	lea d, [bp + -15]
0484+  09DF 07 26 08    	call gets				; get number
0485+  09E2             
0486+  09E2 32          	mov bl, [d]
0487+  09E3 37          	mov bh, bl
0488+  09E4 33 01 00    	mov bl, [d + 1]
0489+  09E7 07 D4 07    	call atoi				; convert to int in AL
0490+  09EA 23          	mov ah, al				; move to AH
0491+  09EB             
0492+  09EB 33 02 00    	mov bl, [d + 2]
0493+  09EE 37          	mov bh, bl
0494+  09EF 33 03 00    	mov bl, [d + 3]
0495+  09F2 07 D4 07    	call atoi				; convert to int in AL
0496+  09F5             
0497+  09F5 E7          	pop d
0498+  09F6 E5          	pop b
0499+  09F7 F9          	leave
0500+  09F8 09          	ret
0501+  09F9             
0502+  09F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0503+  09F9             ; PRINT 8bit HEX INTEGER
0504+  09F9             ; integer value in reg bl
0505+  09F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0506+  09F9             print_u8x:
0507+  09F9 D7          	push a
0508+  09FA DD          	push bl
0509+  09FB             
0510+  09FB 07 E6 07    	call itoa				; convert bl to char in A
0511+  09FE 2F          	mov bl, al				; save al
0512+  09FF 19 00       	mov al, 0
0513+  0A01 05 03       	syscall sys_io				; display AH
0514+  0A03 24          	mov ah, bl				; retrieve al
0515+  0A04 19 00       	mov al, 0
0516+  0A06 05 03       	syscall sys_io				; display AL
0517+  0A08             
0518+  0A08 EA          	pop bl
0519+  0A09 E4          	pop a
0520+  0A0A 09          	ret
0521+  0A0B             
0522+  0A0B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0523+  0A0B             ; print 8bit decimal unsigned number
0524+  0A0B             ; input number in AL
0525+  0A0B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0526+  0A0B             print_u8d:
0527+  0A0B D7          	push a
0528+  0A0C D8          	push b
0529+  0A0D             
0530+  0A0D 22 00       	mov ah, 0
0531+  0A0F 26 64 00    	mov b, 100
0532+  0A12 AE          	div a, b
0533+  0A13 D8          	push b			; save remainder
0534+  0A14 B9 00       	cmp al, 0
0535+  0A16 C6 20 0A    	je skip100
0536+  0A19 6A 30       	add al, $30
0537+  0A1B 23          	mov ah, al
0538+  0A1C 19 00       	mov al, 0
0539+  0A1E 05 03       	syscall sys_io	; print coeff
0540+  0A20             skip100:
0541+  0A20 E4          	pop a
0542+  0A21 22 00       	mov ah, 0
0543+  0A23 26 0A 00    	mov b, 10
0544+  0A26 AE          	div a, b
0545+  0A27 D8          	push b			; save remainder
0546+  0A28 B9 00       	cmp al, 0
0547+  0A2A C6 34 0A    	je skip10
0548+  0A2D 6A 30       	add al, $30
0549+  0A2F 23          	mov ah, al
0550+  0A30 19 00       	mov al, 0
0551+  0A32 05 03       	syscall sys_io	; print coeff
0552+  0A34             skip10:
0553+  0A34 E4          	pop a
0554+  0A35 1B          	mov al, bl
0555+  0A36 6A 30       	add al, $30
0556+  0A38 23          	mov ah, al
0557+  0A39 19 00       	mov al, 0
0558+  0A3B 05 03       	syscall sys_io	; print coeff
0559+  0A3D E5          	pop b
0560+  0A3E E4          	pop a
0561+  0A3F 09          	ret
0562+  0A40             
0563+  0A40             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0564+  0A40             ; INPUT 8BIT HEX INTEGER
0565+  0A40             ; read 8bit integer into AL
0566+  0A40             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0567+  0A40             scan_u8x:
0568+  0A40 F8 04 00    	enter 4
0569+  0A43 D8          	push b
0570+  0A44 DA          	push d
0571+  0A45             
0572+  0A45 FA FD FF    	lea d, [bp + -3]
0573+  0A48 07 26 08    	call gets				; get number
0574+  0A4B             
0575+  0A4B 32          	mov bl, [d]
0576+  0A4C 37          	mov bh, bl
0577+  0A4D 33 01 00    	mov bl, [d + 1]
0578+  0A50 07 D4 07    	call atoi				; convert to int in AL
0579+  0A53             
0580+  0A53 E7          	pop d
0581+  0A54 E5          	pop b
0582+  0A55 F9          	leave
0583+  0A56 09          	ret
0584+  0A57             
0585+  0A57             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0586+  0A57             ; input decimal number
0587+  0A57             ; result in A
0588+  0A57             ; 655'\0'
0589+  0A57             ; low--------high
0590+  0A57             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0591+  0A57             scan_u16d:
0592+  0A57 F8 08 00    	enter 8
0593+  0A5A E2          	push si
0594+  0A5B D8          	push b
0595+  0A5C D9          	push c
0596+  0A5D DA          	push d
0597+  0A5E FA F9 FF    	lea d, [bp +- 7]
0598+  0A61 07 26 08    	call gets
0599+  0A64 07 5C 07    	call strlen			; get string length in C
0600+  0A67 7E          	dec c
0601+  0A68 FD 4E       	mov si, d
0602+  0A6A 12          	mov a, c
0603+  0A6B FD 99       	shl a
0604+  0A6D 3B BC 07    	mov d, table_power
0605+  0A70 59          	add d, a
0606+  0A71 38 00 00    	mov c, 0
0607+  0A74             mul_loop:
0608+  0A74 F6          	lodsb			; load ASCII to al
0609+  0A75 B9 00       	cmp al, 0
0610+  0A77 C6 8A 0A    	je mul_exit
0611+  0A7A 6F 30       	sub al, $30		; make into integer
0612+  0A7C 22 00       	mov ah, 0
0613+  0A7E 2A          	mov b, [d]
0614+  0A7F AC          	mul a, b			; result in B since it fits in 16bits
0615+  0A80 11          	mov a, b
0616+  0A81 28          	mov b, c
0617+  0A82 54          	add a, b
0618+  0A83 39          	mov c, a
0619+  0A84 63 02 00    	sub d, 2
0620+  0A87 0A 74 0A    	jmp mul_loop
0621+  0A8A             mul_exit:
0622+  0A8A 12          	mov a, c
0623+  0A8B E7          	pop d
0624+  0A8C E6          	pop c
0625+  0A8D E5          	pop b
0626+  0A8E EF          	pop si
0627+  0A8F F9          	leave
0628+  0A90 09          	ret
0386   0A91             ; --- END INCLUDE BLOCK
0387   0A91             
0388   0A91             
0389   0A91             .end
tasm: Number of errors = 0
