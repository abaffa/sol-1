0001   0000             ; --- Filename: pascal.c
0002   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0400             .org PROC_TEXT_ORG
0004   0400             
0005   0400             ; --- begin text block
0006   0400             main:
0007   0400 D2            push bp
0008   0401 9B            mov bp, sp
0009   0402 26 01 00      mov b, 1
0010   0405 FD 42 76 05   mov [coef], b
0011   0409             ; --- begin inline asm block
0012   0409 14 6C 05        mov a, [s]
0013   040C 3C              mov d, a
0014   040D 07 C9 07        call puts
0015   0410 07 C7 08        call scan_u16d
0016   0413 42 78 05        mov [rows], a
0017   0416               ; --- end inline asm block
0018   0416             _for1_init:
0019   0416 26 00 00      mov b, 0
0020   0419 FD 42 7C 05   mov [i], b
0021   041D             _for1_cond:
0022   041D 29 7C 05      mov b, [i]
0023   0420 D7            push a
0024   0421 11            mov a, b
0025   0422 29 78 05      mov b, [rows]
0026   0425 B0            cmp a, b
0027   0426 0E            lodflgs
0028   0427 87 02         and al, %00000010
0029   0429 22 00         mov ah, 0
0030   042B 27            mov b, a
0031   042C E4            pop a
0032   042D C0 00 00      cmp b, 0
0033   0430 C6 39 05      je _for1_exit
0034   0433             _for1_block:
0035   0433             _for2_init:
0036   0433 26 01 00      mov b, 1
0037   0436 FD 42 7A 05   mov [space], b
0038   043A             _for2_cond:
0039   043A 29 7A 05      mov b, [space]
0040   043D D7            push a
0041   043E 11            mov a, b
0042   043F 29 78 05      mov b, [rows]
0043   0442 D7            push a
0044   0443 11            mov a, b
0045   0444 29 7C 05      mov b, [i]
0046   0447 60            sub a, b
0047   0448 27            mov b, a
0048   0449 E4            pop a
0049   044A B0            cmp a, b
0050   044B 0E            lodflgs
0051   044C 87 03         and al, %00000011
0052   044E 22 00         mov ah, 0
0053   0450 27            mov b, a
0054   0451 E4            pop a
0055   0452 C0 00 00      cmp b, 0
0056   0455 C6 6D 04      je _for2_exit
0057   0458             _for2_block:
0058   0458 07 46 05      call print
0059   045B             _for2_update:
0060   045B 29 7A 05      mov b, [space]
0061   045E D7            push a
0062   045F 11            mov a, b
0063   0460 26 01 00      mov b, 1
0064   0463 54            add a, b
0065   0464 27            mov b, a
0066   0465 E4            pop a
0067   0466 FD 42 7A 05   mov [space], b
0068   046A 0A 3A 04      jmp _for2_cond
0069   046D             _for2_exit:
0070   046D             _for3_init:
0071   046D 26 00 00      mov b, 0
0072   0470 FD 42 7E 05   mov [j], b
0073   0474             _for3_cond:
0074   0474 29 7E 05      mov b, [j]
0075   0477 D7            push a
0076   0478 11            mov a, b
0077   0479 29 7C 05      mov b, [i]
0078   047C B0            cmp a, b
0079   047D 0E            lodflgs
0080   047E 87 03         and al, %00000011
0081   0480 22 00         mov ah, 0
0082   0482 27            mov b, a
0083   0483 E4            pop a
0084   0484 C0 00 00      cmp b, 0
0085   0487 C6 20 05      je _for3_exit
0086   048A             _for3_block:
0087   048A             _if4_cond:
0088   048A 29 7E 05      mov b, [j]
0089   048D D7            push a
0090   048E 11            mov a, b
0091   048F 26 00 00      mov b, 0
0092   0492 B0            cmp a, b
0093   0493 0E            lodflgs
0094   0494 87 01         and al, %00000001
0095   0496 22 00         mov ah, 0
0096   0498 27            mov b, a
0097   0499 E4            pop a
0098   049A D7            push a
0099   049B 11            mov a, b
0100   049C 29 7C 05      mov b, [i]
0101   049F D7            push a
0102   04A0 11            mov a, b
0103   04A1 26 00 00      mov b, 0
0104   04A4 B0            cmp a, b
0105   04A5 0E            lodflgs
0106   04A6 87 01         and al, %00000001
0107   04A8 22 00         mov ah, 0
0108   04AA 27            mov b, a
0109   04AB E4            pop a
0110   04AC C0 00 00      cmp b, 0
0111   04AF D7            push a
0112   04B0 0E            lodflgs
0113   04B1 27            mov b, a
0114   04B2 E4            pop a
0115   04B3 98            not bl
0116   04B4 FD 87 01      and bl, %00000001
0117   04B7 A7 00         mov bh, 0
0118   04B9 AF 00 00      cmp a, 0
0119   04BC 0E            lodflgs
0120   04BD 96            not al
0121   04BE 87 01         and al, %00000001
0122   04C0 22 00         mov ah, 0
0123   04C2 86            and a, b
0124   04C3 27            mov b, a
0125   04C4 E4            pop a
0126   04C5 C0 00 00      cmp b, 0
0127   04C8 C6 D5 04      je _if4_else
0128   04CB             _if4_true:
0129   04CB 26 01 00      mov b, 1
0130   04CE FD 42 76 05   mov [coef], b
0131   04D2 0A FF 04      jmp _if4_exit
0132   04D5             _if4_else:
0133   04D5 29 76 05      mov b, [coef]
0134   04D8 D7            push a
0135   04D9 11            mov a, b
0136   04DA 29 7C 05      mov b, [i]
0137   04DD D7            push a
0138   04DE 11            mov a, b
0139   04DF 29 7E 05      mov b, [j]
0140   04E2 60            sub a, b
0141   04E3 27            mov b, a
0142   04E4 E4            pop a
0143   04E5 D7            push a
0144   04E6 11            mov a, b
0145   04E7 26 01 00      mov b, 1
0146   04EA 54            add a, b
0147   04EB 27            mov b, a
0148   04EC E4            pop a
0149   04ED AC            mul a, b
0150   04EE E4            pop a
0151   04EF D7            push a
0152   04F0 11            mov a, b
0153   04F1 29 7E 05      mov b, [j]
0154   04F4 AE            div a, b
0155   04F5 FD 78         mov g, a
0156   04F7 11            mov a, b
0157   04F8 FD 27         mov b, g
0158   04FA E4            pop a
0159   04FB FD 42 76 05   mov [coef], b
0160   04FF             _if4_exit:
0161   04FF 07 46 05      call print
0162   0502 29 76 05      mov b, [coef]
0163   0505 FD AB         swp b
0164   0507 D8            push b
0165   0508 07 3C 05      call print_nbr
0166   050B 51 02 00      add sp, 2
0167   050E             _for3_update:
0168   050E 29 7E 05      mov b, [j]
0169   0511 D7            push a
0170   0512 11            mov a, b
0171   0513 26 01 00      mov b, 1
0172   0516 54            add a, b
0173   0517 27            mov b, a
0174   0518 E4            pop a
0175   0519 FD 42 7E 05   mov [j], b
0176   051D 0A 74 04      jmp _for3_cond
0177   0520             _for3_exit:
0178   0520             ; --- begin inline asm block
0179   0520 14 83 05          mov a, [nl]
0180   0523 3C                mov d, a
0181   0524 07 C9 07          call puts
0182   0527                 ; --- end inline asm block
0183   0527             _for1_update:
0184   0527 29 7C 05      mov b, [i]
0185   052A D7            push a
0186   052B 11            mov a, b
0187   052C 26 01 00      mov b, 1
0188   052F 54            add a, b
0189   0530 27            mov b, a
0190   0531 E4            pop a
0191   0532 FD 42 7C 05   mov [i], b
0192   0536 0A 1D 04      jmp _for1_cond
0193   0539             _for1_exit:
0194   0539 F9            leave
0195   053A 05 0B         syscall sys_terminate_proc
0196   053C             print_nbr:
0197   053C D2            push bp
0198   053D 9B            mov bp, sp
0199   053E             ; --- begin inline asm block
0200   053E 17 05 00        mov a, [bp + 5]
0201   0541 07 F2 07        call print_u16d
0202   0544               ; --- end inline asm block
0203   0544 F9            leave
0204   0545 09            ret
0205   0546             print:
0206   0546 D2            push bp
0207   0547 9B            mov bp, sp
0208   0548             ; --- begin inline asm block
0209   0548 14 74 05        mov a, [ss]
0210   054B 3C              mov d, a
0211   054C 07 C9 07        call puts
0212   054F               ; --- end inline asm block
0213   054F F9            leave
0214   0550 09            ret
0215   0551             ; --- end text block
0216   0551             
0217   0551             ; --- begin data block
0218   0551 45 6E 74 65 s_data: .db "Enter the number of rows: ", 0
0218   0555 72 20 74 68 
0218   0559 65 20 6E 75 
0218   055D 6D 62 65 72 
0218   0561 20 6F 66 20 
0218   0565 72 6F 77 73 
0218   0569 3A 20 00 
0219   056C 51 05       s: .dw s_data
0220   056E 20 20 20 20 ss_data: .db "     ", 0
0220   0572 20 00 
0221   0574 6E 05       ss: .dw ss_data
0222   0576 00 00       coef: .fill 2, 00
0223   0578 00 00       rows: .fill 2, 00
0224   057A 00 00       space: .fill 2, 00
0225   057C 00 00       i: .fill 2, 00
0226   057E 00 00       j: .fill 2, 00
0227   0580 0A 0D 00    nl_data: .db "\n\r", 0
0228   0583 80 05       nl: .dw nl_data
0229   0585             ; --- end data block
0230   0585             ; --- begin include block
0231   0585             .include "lib/stdio.asm"
0001+  0585             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0585             ; stdio.s
0003+  0585             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0585             .include "lib/string.asm"
0001++ 0585             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0585             ; string.s
0003++ 0585             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0585             
0005++ 0585             
0006++ 0585             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0585             ; strrev
0008++ 0585             ; reverse a string
0009++ 0585             ; D = string address
0010++ 0585             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0585             ; 01234
0012++ 0585             strrev:
0013++ 0585 4B          	pusha
0014++ 0586 07 CC 05    	call strlen	; length in C
0015++ 0589 12          	mov a, c
0016++ 058A AF 01 00    	cmp a, 1
0017++ 058D D0 A7 05    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0590 7D          	dec a
0019++ 0591 FD 4E       	mov si, d	; beginning of string
0020++ 0593 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0595 59          	add d, a	; end of string
0022++ 0596 12          	mov a, c
0023++ 0597 FD 9B       	shr a		; divide by 2
0024++ 0599 39          	mov c, a	; C now counts the steps
0025++ 059A             strrev_L0:
0026++ 059A 32          	mov bl, [d]	; save load right-side char into BL
0027++ 059B F6          	lodsb		; load left-side char into AL; increase SI
0028++ 059C 3E          	mov [d], al	; store left char into right side
0029++ 059D 1B          	mov al, bl
0030++ 059E F7          	stosb		; store right-side char into left-side; increase DI
0031++ 059F 7E          	dec c
0032++ 05A0 7F          	dec d
0033++ 05A1 C2 00 00    	cmp c, 0
0034++ 05A4 C7 9A 05    	jne strrev_L0
0035++ 05A7             strrev_end:
0036++ 05A7 4C          	popa
0037++ 05A8 09          	ret
0038++ 05A9             	
0039++ 05A9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 05A9             ; strchr
0041++ 05A9             ; search string in D for char in AL
0042++ 05A9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 05A9             strchr:
0044++ 05A9             strchr_L0:
0045++ 05A9 32          	mov bl, [d]
0046++ 05AA C1 00       	cmp bl, 0
0047++ 05AC C6 B7 05    	je strchr_end
0048++ 05AF BA          	cmp al, bl
0049++ 05B0 C6 B7 05    	je strchr_end
0050++ 05B3 79          	inc d
0051++ 05B4 0A A9 05    	jmp strchr_L0
0052++ 05B7             strchr_end:
0053++ 05B7 1B          	mov al, bl
0054++ 05B8 09          	ret
0055++ 05B9             
0056++ 05B9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 05B9             ; strstr
0058++ 05B9             ; find sub-string
0059++ 05B9             ; str1 in SI
0060++ 05B9             ; str2 in DI
0061++ 05B9             ; SI points to end of source string
0062++ 05B9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 05B9             strstr:
0064++ 05B9 DB          	push al
0065++ 05BA DA          	push d
0066++ 05BB E3          	push di
0067++ 05BC             strstr_loop:
0068++ 05BC F3          	cmpsb					; compare a byte of the strings
0069++ 05BD C7 C8 05    	jne strstr_ret
0070++ 05C0 FC 00 00    	lea d, [di + 0]
0071++ 05C3 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 05C5 C7 BC 05    	jne strstr_loop				; equal chars but not at end
0073++ 05C8             strstr_ret:
0074++ 05C8 F0          	pop di
0075++ 05C9 E7          	pop d
0076++ 05CA E8          	pop al
0077++ 05CB 09          	ret
0078++ 05CC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 05CC             ; length of null terminated string
0080++ 05CC             ; result in C
0081++ 05CC             ; pointer in D
0082++ 05CC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 05CC             strlen:
0084++ 05CC DA          	push d
0085++ 05CD 38 00 00    	mov c, 0
0086++ 05D0             strlen_L1:
0087++ 05D0 BD 00       	cmp byte [d], 0
0088++ 05D2 C6 DA 05    	je strlen_ret
0089++ 05D5 79          	inc d
0090++ 05D6 78          	inc c
0091++ 05D7 0A D0 05    	jmp strlen_L1
0092++ 05DA             strlen_ret:
0093++ 05DA E7          	pop d
0094++ 05DB 09          	ret
0095++ 05DC             
0096++ 05DC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 05DC             ; STRCMP
0098++ 05DC             ; compare two strings
0099++ 05DC             ; str1 in SI
0100++ 05DC             ; str2 in DI
0101++ 05DC             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 05DC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 05DC             strcmp:
0104++ 05DC DB          	push al
0105++ 05DD DA          	push d
0106++ 05DE E3          	push di
0107++ 05DF E2          	push si
0108++ 05E0             strcmp_loop:
0109++ 05E0 F3          	cmpsb					; compare a byte of the strings
0110++ 05E1 C7 EC 05    	jne strcmp_ret
0111++ 05E4 FB FF FF    	lea d, [si +- 1]
0112++ 05E7 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 05E9 C7 E0 05    	jne strcmp_loop				; equal chars but not at end
0114++ 05EC             strcmp_ret:
0115++ 05EC EF          	pop si
0116++ 05ED F0          	pop di
0117++ 05EE E7          	pop d
0118++ 05EF E8          	pop al
0119++ 05F0 09          	ret
0120++ 05F1             
0121++ 05F1             
0122++ 05F1             ; STRCPY
0123++ 05F1             ; copy null terminated string from SI to DI
0124++ 05F1             ; source in SI
0125++ 05F1             ; destination in DI
0126++ 05F1             strcpy:
0127++ 05F1 E2          	push si
0128++ 05F2 E3          	push di
0129++ 05F3 DB          	push al
0130++ 05F4             strcpy_L1:
0131++ 05F4 F6          	lodsb
0132++ 05F5 F7          	stosb
0133++ 05F6 B9 00       	cmp al, 0
0134++ 05F8 C7 F4 05    	jne strcpy_L1
0135++ 05FB             strcpy_end:
0136++ 05FB E8          	pop al
0137++ 05FC F0          	pop di
0138++ 05FD EF          	pop si
0139++ 05FE 09          	ret
0140++ 05FF             
0141++ 05FF             ; STRCAT
0142++ 05FF             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 05FF             ; source in SI
0144++ 05FF             ; destination in DI
0145++ 05FF             strcat:
0146++ 05FF E2          	push si
0147++ 0600 E3          	push di
0148++ 0601 D7          	push a
0149++ 0602 DA          	push d
0150++ 0603 50          	mov a, di
0151++ 0604 3C          	mov d, a
0152++ 0605             strcat_goto_end_L1:
0153++ 0605 BD 00       	cmp byte[d], 0
0154++ 0607 C6 0E 06    	je strcat_start
0155++ 060A 79          	inc d
0156++ 060B 0A 05 06    	jmp strcat_goto_end_L1
0157++ 060E             strcat_start:
0158++ 060E FD 50       	mov di, d
0159++ 0610             strcat_L1:
0160++ 0610 F6          	lodsb
0161++ 0611 F7          	stosb
0162++ 0612 B9 00       	cmp al, 0
0163++ 0614 C7 10 06    	jne strcat_L1
0164++ 0617             strcat_end:
0165++ 0617 E7          	pop d
0166++ 0618 E4          	pop a
0167++ 0619 F0          	pop di
0168++ 061A EF          	pop si
0169++ 061B 09          	ret
0005+  061C             
0006+  061C 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  0620 34 35 36 37 
0006+  0624 38 39 41 42 
0006+  0628 43 44 45 46 
0007+  062C             
0008+  062C 01 00       table_power:.dw 1
0009+  062E 0A 00       			.dw 10
0010+  0630 64 00       			.dw 100
0011+  0632 E8 03       			.dw 1000
0012+  0634 10 27       			.dw 10000
0013+  0636             
0014+  0636             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0015+  0636             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0016+  0636             ; ASCII in BL
0017+  0636             ; result in AL
0018+  0636             ; ascii for F = 0100 0110
0019+  0636             ; ascii for 9 = 0011 1001
0020+  0636             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0021+  0636             hex_ascii_encode:
0022+  0636 1B          	mov al, bl
0023+  0637 93 40       	test al, $40				; test if letter or number
0024+  0639 C7 3F 06    	jnz hex_letter
0025+  063C 87 0F       	and al, $0F				; get number
0026+  063E 09          	ret
0027+  063F             hex_letter:
0028+  063F 87 0F       	and al, $0F				; get letter
0029+  0641 6A 09       	add al, 9
0030+  0643 09          	ret
0031+  0644             
0032+  0644             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0033+  0644             ; ATOI
0034+  0644             ; 2 letter hex string in B
0035+  0644             ; 8bit integer returned in AL
0036+  0644             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0037+  0644             atoi:
0038+  0644 D8          	push b
0039+  0645 07 36 06    	call hex_ascii_encode			; convert BL to 4bit code in AL
0040+  0648 30          	mov bl, bh
0041+  0649 DB          	push al					; save a
0042+  064A 07 36 06    	call hex_ascii_encode
0043+  064D EA          	pop bl	
0044+  064E FD 9E 04    	shl al, 4
0045+  0651 8C          	or al, bl
0046+  0652 E5          	pop b
0047+  0653 09          	ret	
0048+  0654             
0049+  0654             
0050+  0654             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  0654             ; printf
0052+  0654             ; no need for explanations!
0053+  0654             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0054+  0654             printf:
0055+  0654 09          	ret
0056+  0655             
0057+  0655             
0058+  0655             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  0655             ; scanf
0060+  0655             ; no need for explanations!
0061+  0655             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  0655             scanf:
0063+  0655 09          	ret
0064+  0656             
0065+  0656             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  0656             ; ITOA
0067+  0656             ; 8bit value in BL
0068+  0656             ; 2 byte ASCII result in A
0069+  0656             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0070+  0656             itoa:
0071+  0656 DA          	push d
0072+  0657 D8          	push b
0073+  0658 A7 00       	mov bh, 0
0074+  065A FD A4 04    	shr bl, 4	
0075+  065D 74          	mov d, b
0076+  065E 1F 1C 06    	mov al, [d + s_hex_digits]
0077+  0661 23          	mov ah, al
0078+  0662             	
0079+  0662 E5          	pop b
0080+  0663 D8          	push b
0081+  0664 A7 00       	mov bh, 0
0082+  0666 FD 87 0F    	and bl, $0F
0083+  0669 74          	mov d, b
0084+  066A 1F 1C 06    	mov al, [d + s_hex_digits]
0085+  066D E5          	pop b
0086+  066E E7          	pop d
0087+  066F 09          	ret
0088+  0670             
0089+  0670             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0090+  0670             ; HEX STRING TO BINARY
0091+  0670             ; di = destination address
0092+  0670             ; si = source
0093+  0670             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0094+  0670             hex_to_int:
0095+  0670             hex_to_int_L1:
0096+  0670 F6          	lodsb					; load from [SI] to AL
0097+  0671 B9 00       	cmp al, 0				; check if ASCII 0
0098+  0673 C6 80 06    	jz hex_to_int_ret
0099+  0676 36          	mov bh, al
0100+  0677 F6          	lodsb
0101+  0678 2F          	mov bl, al
0102+  0679 07 44 06    	call atoi				; convert ASCII byte in B to int (to AL)
0103+  067C F7          	stosb					; store AL to [DI]
0104+  067D 0A 70 06    	jmp hex_to_int_L1
0105+  0680             hex_to_int_ret:
0106+  0680 09          	ret		
0107+  0681             
0108+  0681             
0109+  0681             
0110+  0681             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  0681             ; GETCHAR
0112+  0681             ; char in ah
0113+  0681             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0114+  0681             getchar:
0115+  0681 DB          	push al
0116+  0682             getchar_retry:
0117+  0682 FD 0C       	sti
0118+  0684 19 01       	mov al, 1
0119+  0686 05 03       	syscall sys_io			; receive in AH
0120+  0688 B9 00       	cmp al, 0			; check if any char was receive
0121+  068A C6 82 06    	je getchar_retry
0122+  068D E8          	pop al
0123+  068E 09          	ret
0124+  068F             
0125+  068F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0126+  068F             ; PUTCHAR
0127+  068F             ; char in ah
0128+  068F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  068F             putchar:
0130+  068F D7          	push a
0131+  0690 19 00       	mov al, 0
0132+  0692 05 03       	syscall sys_io			; char in AH
0133+  0694 E4          	pop a
0134+  0695 09          	ret
0135+  0696             
0136+  0696             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0137+  0696             ;; INPUT A STRING
0138+  0696             ;; terminates with null
0139+  0696             ;; pointer in D
0140+  0696             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  0696             gets:
0142+  0696 D7          	push a
0143+  0697 DA          	push d
0144+  0698             gets_loop:
0145+  0698 FD 0C       	sti
0146+  069A 19 01       	mov al, 1
0147+  069C 05 03       	syscall sys_io			; receive in AH
0148+  069E B9 00       	cmp al, 0				; check error code (AL)
0149+  06A0 C6 98 06    	je gets_loop			; if no char received, retry
0150+  06A3             
0151+  06A3 76 1B       	cmp ah, 27
0152+  06A5 C6 C6 06    	je gets_telnet_escape
0153+  06A8 76 0A       	cmp ah, $0A				; LF
0154+  06AA C6 1F 07    	je gets_end
0155+  06AD 76 0D       	cmp ah, $0D				; CR
0156+  06AF C6 1F 07    	je gets_end
0157+  06B2 76 5C       	cmp ah, $5C				; '\\'
0158+  06B4 C6 F6 06    	je gets_escape
0159+  06B7             	
0160+  06B7 76 08       	cmp ah, $08			; check for backspace
0161+  06B9 C6 C2 06    	je gets_backspace
0162+  06BC             
0163+  06BC 1A          	mov al, ah
0164+  06BD 3E          	mov [d], al
0165+  06BE 79          	inc d
0166+  06BF 0A 98 06    	jmp gets_loop
0167+  06C2             gets_backspace:
0168+  06C2 7F          	dec d
0169+  06C3 0A 98 06    	jmp gets_loop
0170+  06C6             gets_telnet_escape:
0171+  06C6 FD 0C       	sti
0172+  06C8 19 01       	mov al, 1
0173+  06CA 05 03       	syscall sys_io				; receive in AH without echo
0174+  06CC B9 00       	cmp al, 0					; check error code (AL)
0175+  06CE C6 C6 06    	je gets_telnet_escape		; if no char received, retry
0176+  06D1 76 5B       	cmp ah, '['
0177+  06D3 C7 98 06    	jne gets_loop
0178+  06D6             gets_telnet_escape_phase2:
0179+  06D6 FD 0C       	sti
0180+  06D8 19 01       	mov al, 1
0181+  06DA 05 03       	syscall sys_io					; receive in AH without echo
0182+  06DC B9 00       	cmp al, 0						; check error code (AL)
0183+  06DE C6 D6 06    	je gets_telnet_escape_phase2	; if no char received, retry
0184+  06E1 76 44       	cmp ah, 'D'
0185+  06E3 C6 EE 06    	je gets_left_arrow
0186+  06E6 76 43       	cmp ah, 'C'
0187+  06E8 C6 F2 06    	je gets_right_arrow
0188+  06EB 0A 98 06    	jmp gets_loop
0189+  06EE             gets_left_arrow:
0190+  06EE 7F          	dec d
0191+  06EF 0A 98 06    	jmp gets_loop
0192+  06F2             gets_right_arrow:
0193+  06F2 79          	inc d
0194+  06F3 0A 98 06    	jmp gets_loop
0195+  06F6             gets_escape:
0196+  06F6 FD 0C       	sti
0197+  06F8 19 01       	mov al, 1
0198+  06FA 05 03       	syscall sys_io			; receive in AH
0199+  06FC B9 00       	cmp al, 0				; check error code (AL)
0200+  06FE C6 F6 06    	je gets_escape			; if no char received, retry
0201+  0701 76 6E       	cmp ah, 'n'
0202+  0703 C6 11 07    	je gets_LF
0203+  0706 76 72       	cmp ah, 'r'
0204+  0708 C6 18 07    	je gets_CR
0205+  070B 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0206+  070C 3E          	mov [d], al
0207+  070D 79          	inc d
0208+  070E 0A 98 06    	jmp gets_loop
0209+  0711             gets_LF:
0210+  0711 19 0A       	mov al, $0A
0211+  0713 3E          	mov [d], al
0212+  0714 79          	inc d
0213+  0715 0A 98 06    	jmp gets_loop
0214+  0718             gets_CR:
0215+  0718 19 0D       	mov al, $0D
0216+  071A 3E          	mov [d], al
0217+  071B 79          	inc d
0218+  071C 0A 98 06    	jmp gets_loop
0219+  071F             gets_end:
0220+  071F 19 00       	mov al, 0
0221+  0721 3E          	mov [d], al				; terminate string
0222+  0722 E7          	pop d
0223+  0723 E4          	pop a
0224+  0724 09          	ret
0225+  0725             
0226+  0725             
0227+  0725             
0228+  0725             
0229+  0725             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0230+  0725             ;; INPUT TEXT
0231+  0725             ;; terminated with CTRL+D
0232+  0725             ;; pointer in D
0233+  0725             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0234+  0725             gettxt:
0235+  0725 D7          	push a
0236+  0726 DA          	push d
0237+  0727             gettxt_loop:
0238+  0727 19 01       	mov al, 1
0239+  0729 05 03       	syscall sys_io			; receive in AH
0240+  072B B9 00       	cmp al, 0				; check error code (AL)
0241+  072D C6 27 07    	je gettxt_loop		; if no char received, retry
0242+  0730 76 04       	cmp ah, 4			; EOT
0243+  0732 C6 70 07    	je gettxt_end
0244+  0735 76 08       	cmp ah, $08			; check for backspace
0245+  0737 C6 6C 07    	je gettxt_backspace
0246+  073A 76 5C       	cmp ah, $5C				; '\\'
0247+  073C C6 45 07    	je gettxt_escape
0248+  073F 1A          	mov al, ah
0249+  0740 3E          	mov [d], al
0250+  0741 79          	inc d
0251+  0742 0A 27 07    	jmp gettxt_loop
0252+  0745             gettxt_escape:
0253+  0745 19 01       	mov al, 1
0254+  0747 05 03       	syscall sys_io			; receive in AH
0255+  0749 B9 00       	cmp al, 0				; check error code (AL)
0256+  074B C6 45 07    	je gettxt_escape		; if no char received, retry
0257+  074E 76 6E       	cmp ah, 'n'
0258+  0750 C6 5E 07    	je gettxt_LF
0259+  0753 76 72       	cmp ah, 'r'
0260+  0755 C6 65 07    	je gettxt_CR
0261+  0758 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0262+  0759 3E          	mov [d], al
0263+  075A 79          	inc d
0264+  075B 0A 27 07    	jmp gettxt_loop
0265+  075E             gettxt_LF:
0266+  075E 19 0A       	mov al, $0A
0267+  0760 3E          	mov [d], al
0268+  0761 79          	inc d
0269+  0762 0A 27 07    	jmp gettxt_loop
0270+  0765             gettxt_CR:
0271+  0765 19 0D       	mov al, $0D
0272+  0767 3E          	mov [d], al
0273+  0768 79          	inc d
0274+  0769 0A 27 07    	jmp gettxt_loop
0275+  076C             gettxt_backspace:
0276+  076C 7F          	dec d
0277+  076D 0A 27 07    	jmp gettxt_loop
0278+  0770             gettxt_end:
0279+  0770 19 00       	mov al, 0
0280+  0772 3E          	mov [d], al				; terminate string
0281+  0773 E7          	pop d
0282+  0774 E4          	pop a
0283+  0775 09          	ret
0284+  0776             
0285+  0776             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0286+  0776             ; PRINT NEW LINE
0287+  0776             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  0776             printnl:
0289+  0776 D7          	push a
0290+  0777 10 00 0A    	mov a, $0A00
0291+  077A 05 03       	syscall sys_io
0292+  077C 10 00 0D    	mov a, $0D00
0293+  077F 05 03       	syscall sys_io
0294+  0781 E4          	pop a
0295+  0782 09          	ret
0296+  0783             
0297+  0783             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0298+  0783             ; strtoint
0299+  0783             ; 4 digit hex string number in d
0300+  0783             ; integer returned in A
0301+  0783             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0302+  0783             strtointx:
0303+  0783 D8          	push b
0304+  0784 32          	mov bl, [d]
0305+  0785 37          	mov bh, bl
0306+  0786 33 01 00    	mov bl, [d + 1]
0307+  0789 07 44 06    	call atoi				; convert to int in AL
0308+  078C 23          	mov ah, al				; move to AH
0309+  078D 33 02 00    	mov bl, [d + 2]
0310+  0790 37          	mov bh, bl
0311+  0791 33 03 00    	mov bl, [d + 3]
0312+  0794 07 44 06    	call atoi				; convert to int in AL
0313+  0797 E5          	pop b
0314+  0798 09          	ret
0315+  0799             
0316+  0799             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0317+  0799             ; strtoint
0318+  0799             ; 5 digit base10 string number in d
0319+  0799             ; integer returned in A
0320+  0799             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0321+  0799             strtoint:
0322+  0799 E2          	push si
0323+  079A D8          	push b
0324+  079B D9          	push c
0325+  079C DA          	push d
0326+  079D 07 CC 05    	call strlen			; get string length in C
0327+  07A0 7E          	dec c
0328+  07A1 FD 4E       	mov si, d
0329+  07A3 12          	mov a, c
0330+  07A4 FD 99       	shl a
0331+  07A6 3B 2C 06    	mov d, table_power
0332+  07A9 59          	add d, a
0333+  07AA 38 00 00    	mov c, 0
0334+  07AD             strtoint_L0:
0335+  07AD F6          	lodsb			; load ASCII to al
0336+  07AE B9 00       	cmp al, 0
0337+  07B0 C6 C3 07    	je strtoint_end
0338+  07B3 6F 30       	sub al, $30		; make into integer
0339+  07B5 22 00       	mov ah, 0
0340+  07B7 2A          	mov b, [d]
0341+  07B8 AC          	mul a, b			; result in B since it fits in 16bits
0342+  07B9 11          	mov a, b
0343+  07BA 28          	mov b, c
0344+  07BB 54          	add a, b
0345+  07BC 39          	mov c, a
0346+  07BD 63 02 00    	sub d, 2
0347+  07C0 0A AD 07    	jmp strtoint_L0
0348+  07C3             strtoint_end:
0349+  07C3 12          	mov a, c
0350+  07C4 E7          	pop d
0351+  07C5 E6          	pop c
0352+  07C6 E5          	pop b
0353+  07C7 EF          	pop si
0354+  07C8 09          	ret
0355+  07C9             
0356+  07C9             
0357+  07C9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0358+  07C9             ; PRINT NULL TERMINATED STRING
0359+  07C9             ; pointer in D
0360+  07C9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0361+  07C9             puts:
0362+  07C9 D7          	push a
0363+  07CA DA          	push d
0364+  07CB             puts_L1:
0365+  07CB 1E          	mov al, [d]
0366+  07CC B9 00       	cmp al, 0
0367+  07CE C6 DA 07    	jz puts_END
0368+  07D1 23          	mov ah, al
0369+  07D2 19 00       	mov al, 0
0370+  07D4 05 03       	syscall sys_io
0371+  07D6 79          	inc d
0372+  07D7 0A CB 07    	jmp puts_L1
0373+  07DA             puts_END:
0374+  07DA E7          	pop d
0375+  07DB E4          	pop a
0376+  07DC 09          	ret
0377+  07DD             
0378+  07DD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  07DD             ; PRINT N SIZE STRING
0380+  07DD             ; pointer in D
0381+  07DD             ; size in C
0382+  07DD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0383+  07DD             putsn:
0384+  07DD DB          	push al
0385+  07DE DA          	push d
0386+  07DF D9          	push c
0387+  07E0             putsn_L0:
0388+  07E0 1E          	mov al, [d]
0389+  07E1 23          	mov ah, al
0390+  07E2 19 00       	mov al, 0
0391+  07E4 05 03       	syscall sys_io
0392+  07E6 79          	inc d
0393+  07E7 7E          	dec c	
0394+  07E8 C2 00 00    	cmp c, 0
0395+  07EB C7 E0 07    	jne putsn_L0
0396+  07EE             putsn_end:
0397+  07EE E6          	pop c
0398+  07EF E7          	pop d
0399+  07F0 E8          	pop al
0400+  07F1 09          	ret
0401+  07F2             
0402+  07F2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0403+  07F2             ; print 16bit decimal number
0404+  07F2             ; input number in A
0405+  07F2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  07F2             print_u16d:
0407+  07F2 D7          	push a
0408+  07F3 D8          	push b
0409+  07F4 26 10 27    	mov b, 10000
0410+  07F7 AE          	div a, b			; get 10000 coeff.
0411+  07F8 07 1E 08    	call print_number
0412+  07FB 11          	mov a, b
0413+  07FC 26 E8 03    	mov b, 1000
0414+  07FF AE          	div a, b			; get 10000 coeff.
0415+  0800 07 1E 08    	call print_number
0416+  0803 11          	mov a, b
0417+  0804 26 64 00    	mov b, 100
0418+  0807 AE          	div a, b
0419+  0808 07 1E 08    	call print_number
0420+  080B 11          	mov a, b
0421+  080C 26 0A 00    	mov b, 10
0422+  080F AE          	div a, b
0423+  0810 07 1E 08    	call print_number
0424+  0813 11          	mov a, b
0425+  0814 6A 30       	add al, $30
0426+  0816 23          	mov ah, al
0427+  0817 19 00       	mov al, 0
0428+  0819 05 03       	syscall sys_io	; print coeff
0429+  081B E5          	pop b
0430+  081C E4          	pop a
0431+  081D 09          	ret
0432+  081E             
0433+  081E             
0434+  081E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0435+  081E             ; if A == 0, print space
0436+  081E             ; else print A
0437+  081E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0438+  081E             print_number:
0439+  081E 6A 30       	add al, $30
0440+  0820 23          	mov ah, al
0441+  0821 07 8F 06    	call putchar
0442+  0824 09          	ret
0443+  0825             
0444+  0825             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  0825             ; PRINT 16BIT HEX INTEGER
0446+  0825             ; integer value in reg B
0447+  0825             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  0825             print_u16x:
0449+  0825 D7          	push a
0450+  0826 D8          	push b
0451+  0827 DD          	push bl
0452+  0828 30          	mov bl, bh
0453+  0829 07 56 06    	call itoa				; convert bh to char in A
0454+  082C 2F          	mov bl, al				; save al
0455+  082D 19 00       	mov al, 0
0456+  082F 05 03       	syscall sys_io				; display AH
0457+  0831 24          	mov ah, bl				; retrieve al
0458+  0832 19 00       	mov al, 0
0459+  0834 05 03       	syscall sys_io				; display AL
0460+  0836             
0461+  0836 EA          	pop bl
0462+  0837 07 56 06    	call itoa				; convert bh to char in A
0463+  083A 2F          	mov bl, al				; save al
0464+  083B 19 00       	mov al, 0
0465+  083D 05 03       	syscall sys_io				; display AH
0466+  083F 24          	mov ah, bl				; retrieve al
0467+  0840 19 00       	mov al, 0
0468+  0842 05 03       	syscall sys_io				; display AL
0469+  0844             
0470+  0844 E5          	pop b
0471+  0845 E4          	pop a
0472+  0846 09          	ret
0473+  0847             
0474+  0847             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0475+  0847             ; INPUT 16BIT HEX INTEGER
0476+  0847             ; read 16bit integer into A
0477+  0847             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0478+  0847             scan_u16x:
0479+  0847 F8 10 00    	enter 16
0480+  084A D8          	push b
0481+  084B DA          	push d
0482+  084C             
0483+  084C FA F1 FF    	lea d, [bp + -15]
0484+  084F 07 96 06    	call gets				; get number
0485+  0852             
0486+  0852 32          	mov bl, [d]
0487+  0853 37          	mov bh, bl
0488+  0854 33 01 00    	mov bl, [d + 1]
0489+  0857 07 44 06    	call atoi				; convert to int in AL
0490+  085A 23          	mov ah, al				; move to AH
0491+  085B             
0492+  085B 33 02 00    	mov bl, [d + 2]
0493+  085E 37          	mov bh, bl
0494+  085F 33 03 00    	mov bl, [d + 3]
0495+  0862 07 44 06    	call atoi				; convert to int in AL
0496+  0865             
0497+  0865 E7          	pop d
0498+  0866 E5          	pop b
0499+  0867 F9          	leave
0500+  0868 09          	ret
0501+  0869             
0502+  0869             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0503+  0869             ; PRINT 8bit HEX INTEGER
0504+  0869             ; integer value in reg bl
0505+  0869             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0506+  0869             print_u8x:
0507+  0869 D7          	push a
0508+  086A DD          	push bl
0509+  086B             
0510+  086B 07 56 06    	call itoa				; convert bl to char in A
0511+  086E 2F          	mov bl, al				; save al
0512+  086F 19 00       	mov al, 0
0513+  0871 05 03       	syscall sys_io				; display AH
0514+  0873 24          	mov ah, bl				; retrieve al
0515+  0874 19 00       	mov al, 0
0516+  0876 05 03       	syscall sys_io				; display AL
0517+  0878             
0518+  0878 EA          	pop bl
0519+  0879 E4          	pop a
0520+  087A 09          	ret
0521+  087B             
0522+  087B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0523+  087B             ; print 8bit decimal unsigned number
0524+  087B             ; input number in AL
0525+  087B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0526+  087B             print_u8d:
0527+  087B D7          	push a
0528+  087C D8          	push b
0529+  087D             
0530+  087D 22 00       	mov ah, 0
0531+  087F 26 64 00    	mov b, 100
0532+  0882 AE          	div a, b
0533+  0883 D8          	push b			; save remainder
0534+  0884 B9 00       	cmp al, 0
0535+  0886 C6 90 08    	je skip100
0536+  0889 6A 30       	add al, $30
0537+  088B 23          	mov ah, al
0538+  088C 19 00       	mov al, 0
0539+  088E 05 03       	syscall sys_io	; print coeff
0540+  0890             skip100:
0541+  0890 E4          	pop a
0542+  0891 22 00       	mov ah, 0
0543+  0893 26 0A 00    	mov b, 10
0544+  0896 AE          	div a, b
0545+  0897 D8          	push b			; save remainder
0546+  0898 B9 00       	cmp al, 0
0547+  089A C6 A4 08    	je skip10
0548+  089D 6A 30       	add al, $30
0549+  089F 23          	mov ah, al
0550+  08A0 19 00       	mov al, 0
0551+  08A2 05 03       	syscall sys_io	; print coeff
0552+  08A4             skip10:
0553+  08A4 E4          	pop a
0554+  08A5 1B          	mov al, bl
0555+  08A6 6A 30       	add al, $30
0556+  08A8 23          	mov ah, al
0557+  08A9 19 00       	mov al, 0
0558+  08AB 05 03       	syscall sys_io	; print coeff
0559+  08AD E5          	pop b
0560+  08AE E4          	pop a
0561+  08AF 09          	ret
0562+  08B0             
0563+  08B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0564+  08B0             ; INPUT 8BIT HEX INTEGER
0565+  08B0             ; read 8bit integer into AL
0566+  08B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0567+  08B0             scan_u8x:
0568+  08B0 F8 04 00    	enter 4
0569+  08B3 D8          	push b
0570+  08B4 DA          	push d
0571+  08B5             
0572+  08B5 FA FD FF    	lea d, [bp + -3]
0573+  08B8 07 96 06    	call gets				; get number
0574+  08BB             
0575+  08BB 32          	mov bl, [d]
0576+  08BC 37          	mov bh, bl
0577+  08BD 33 01 00    	mov bl, [d + 1]
0578+  08C0 07 44 06    	call atoi				; convert to int in AL
0579+  08C3             
0580+  08C3 E7          	pop d
0581+  08C4 E5          	pop b
0582+  08C5 F9          	leave
0583+  08C6 09          	ret
0584+  08C7             
0585+  08C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0586+  08C7             ; input decimal number
0587+  08C7             ; result in A
0588+  08C7             ; 655'\0'
0589+  08C7             ; low--------high
0590+  08C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0591+  08C7             scan_u16d:
0592+  08C7 F8 08 00    	enter 8
0593+  08CA E2          	push si
0594+  08CB D8          	push b
0595+  08CC D9          	push c
0596+  08CD DA          	push d
0597+  08CE FA F9 FF    	lea d, [bp +- 7]
0598+  08D1 07 96 06    	call gets
0599+  08D4 07 CC 05    	call strlen			; get string length in C
0600+  08D7 7E          	dec c
0601+  08D8 FD 4E       	mov si, d
0602+  08DA 12          	mov a, c
0603+  08DB FD 99       	shl a
0604+  08DD 3B 2C 06    	mov d, table_power
0605+  08E0 59          	add d, a
0606+  08E1 38 00 00    	mov c, 0
0607+  08E4             mul_loop:
0608+  08E4 F6          	lodsb			; load ASCII to al
0609+  08E5 B9 00       	cmp al, 0
0610+  08E7 C6 FA 08    	je mul_exit
0611+  08EA 6F 30       	sub al, $30		; make into integer
0612+  08EC 22 00       	mov ah, 0
0613+  08EE 2A          	mov b, [d]
0614+  08EF AC          	mul a, b			; result in B since it fits in 16bits
0615+  08F0 11          	mov a, b
0616+  08F1 28          	mov b, c
0617+  08F2 54          	add a, b
0618+  08F3 39          	mov c, a
0619+  08F4 63 02 00    	sub d, 2
0620+  08F7 0A E4 08    	jmp mul_loop
0621+  08FA             mul_exit:
0622+  08FA 12          	mov a, c
0623+  08FB E7          	pop d
0624+  08FC E6          	pop c
0625+  08FD E5          	pop b
0626+  08FE EF          	pop si
0627+  08FF F9          	leave
0628+  0900 09          	ret
0232   0901             ; --- end include block
0233   0901             
0234   0901             .end
tasm: Number of errors = 0
