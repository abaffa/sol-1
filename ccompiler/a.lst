0001   0000             ; --- FILENAME: strcat.c
0002   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0400             .org PROC_TEXT_ORG
0004   0400             
0005   0400             ; --- BEGIN TEXT BLOCK
0006   0400             main:
0007   0400 D2            push bp
0008   0401 9B            mov bp, sp
0009   0402 29 90 05      mov b, [s1]
0010   0405 FD AB         swp b
0011   0407 D8            push b
0012   0408 07 14 04      call _strlen
0013   040B 51 02 00      add sp, 2
0014   040E 26 00 00      mov b, 0
0015   0411 F9            leave
0016   0412 05 0B         syscall sys_terminate_proc
0017   0414             _strlen:
0018   0414 D2            push bp
0019   0415 9B            mov bp, sp
0020   0416 52 02 00      sub sp, 2 ; length
0021   0419 26 00 00      mov b, 0
0022   041C D7            push a
0023   041D 11            mov a, b
0024   041E 45 FF FF      mov [bp + -1], a ; length
0025   0421 E4            pop a
0026   0422             _while1_cond:
0027   0422 FA 05 00      lea d, [bp + 5] ; str
0028   0425 2A            mov b, [d]
0029   0426 D7            push a
0030   0427 11            mov a, b
0031   0428 2C FF FF      mov b, [bp + -1] ; length
0032   042B 54            add a, b
0033   042C 27            mov b, a
0034   042D E4            pop a
0035   042E 74            mov d, b
0036   042F 32            mov bl, [d]
0037   0430 A7 00         mov bh, 0
0038   0432 D7            push a
0039   0433 11            mov a, b
0040   0434 26 00 00      mov b, 0
0041   0437 B0            cmp a, b
0042   0438 0E            lodflgs
0043   0439 87 01         and al, %00000001
0044   043B 8F 01         xor al, %00000001 ; !=
0045   043D B9 00         cmp al, 0
0046   043F 0E            lodflgs
0047   0440 96            not al
0048   0441 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0049   0443 22 00         mov ah, 0
0050   0445 27            mov b, a
0051   0446 E4            pop a
0052   0447 C0 00 00      cmp b, 0
0053   044A C6 5B 04      je _while1_exit
0054   044D             _while1_block:
0055   044D 2C FF FF      mov b, [bp + -1] ; length
0056   0450 FD 77         inc b
0057   0452 D7            push a
0058   0453 11            mov a, b
0059   0454 45 FF FF      mov [bp + -1], a ; length
0060   0457 E4            pop a
0061   0458 0A 22 04      jmp _while1_cond
0062   045B             _while1_exit:
0063   045B 2C FF FF      mov b, [bp + -1] ; length
0064   045E F9            leave
0065   045F 09            ret
0066   0460             _strcat:
0067   0460 D2            push bp
0068   0461 9B            mov bp, sp
0069   0462 52 02 00      sub sp, 2 ; dest_len
0070   0465 52 02 00      sub sp, 2 ; i
0071   0468 FA 07 00      lea d, [bp + 7] ; dest
0072   046B 2A            mov b, [d]
0073   046C FD AB         swp b
0074   046E D8            push b
0075   046F 07 14 04      call _strlen
0076   0472 51 02 00      add sp, 2
0077   0475 D7            push a
0078   0476 11            mov a, b
0079   0477 45 FF FF      mov [bp + -1], a ; dest_len
0080   047A E4            pop a
0081   047B             _for2_init:
0082   047B 26 00 00      mov b, 0
0083   047E D7            push a
0084   047F 11            mov a, b
0085   0480 45 FD FF      mov [bp + -3], a ; i
0086   0483 E4            pop a
0087   0484             _for2_cond:
0088   0484 FA 05 00      lea d, [bp + 5] ; src
0089   0487 2A            mov b, [d]
0090   0488 D7            push a
0091   0489 11            mov a, b
0092   048A 2C FD FF      mov b, [bp + -3] ; i
0093   048D 54            add a, b
0094   048E 27            mov b, a
0095   048F E4            pop a
0096   0490 74            mov d, b
0097   0491 32            mov bl, [d]
0098   0492 A7 00         mov bh, 0
0099   0494 D7            push a
0100   0495 11            mov a, b
0101   0496 26 00 00      mov b, 0
0102   0499 B0            cmp a, b
0103   049A 0E            lodflgs
0104   049B 87 01         and al, %00000001
0105   049D 8F 01         xor al, %00000001 ; !=
0106   049F B9 00         cmp al, 0
0107   04A1 0E            lodflgs
0108   04A2 96            not al
0109   04A3 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0110   04A5 22 00         mov ah, 0
0111   04A7 27            mov b, a
0112   04A8 E4            pop a
0113   04A9 C0 00 00      cmp b, 0
0114   04AC C6 E2 04      je _for2_exit
0115   04AF             _for2_block:
0116   04AF FA 07 00      lea d, [bp + 7] ; dest
0117   04B2 2A            mov b, [d]
0118   04B3 D7            push a
0119   04B4 11            mov a, b
0120   04B5 2C FF FF      mov b, [bp + -1] ; dest_len
0121   04B8 54            add a, b
0122   04B9 27            mov b, a
0123   04BA 11            mov a, b
0124   04BB 2C FD FF      mov b, [bp + -3] ; i
0125   04BE 54            add a, b
0126   04BF 27            mov b, a
0127   04C0 E4            pop a
0128   04C1 74            mov d, b
0129   04C2 FA 05 00      lea d, [bp + 5] ; src
0130   04C5 2A            mov b, [d]
0131   04C6 D7            push a
0132   04C7 11            mov a, b
0133   04C8 2C FD FF      mov b, [bp + -3] ; i
0134   04CB 54            add a, b
0135   04CC 27            mov b, a
0136   04CD E4            pop a
0137   04CE 74            mov d, b
0138   04CF 32            mov bl, [d]
0139   04D0 A7 00         mov bh, 0
0140   04D2 11            mov a, b
0141   04D3 43            mov [d], a
0142   04D4             _for2_update:
0143   04D4 2C FD FF      mov b, [bp + -3] ; i
0144   04D7 FD 77         inc b
0145   04D9 D7            push a
0146   04DA 11            mov a, b
0147   04DB 45 FD FF      mov [bp + -3], a ; i
0148   04DE E4            pop a
0149   04DF 0A 84 04      jmp _for2_cond
0150   04E2             _for2_exit:
0151   04E2 FA 07 00      lea d, [bp + 7] ; dest
0152   04E5 2A            mov b, [d]
0153   04E6 D7            push a
0154   04E7 11            mov a, b
0155   04E8 2C FF FF      mov b, [bp + -1] ; dest_len
0156   04EB 54            add a, b
0157   04EC 27            mov b, a
0158   04ED 11            mov a, b
0159   04EE 2C FD FF      mov b, [bp + -3] ; i
0160   04F1 54            add a, b
0161   04F2 27            mov b, a
0162   04F3 E4            pop a
0163   04F4 74            mov d, b
0164   04F5 26 00 00      mov b, 0
0165   04F8 11            mov a, b
0166   04F9 43            mov [d], a
0167   04FA FA 07 00      lea d, [bp + 7] ; dest
0168   04FD 2A            mov b, [d]
0169   04FE F9            leave
0170   04FF 09            ret
0171   0500             scann:
0172   0500 D2            push bp
0173   0501 9B            mov bp, sp
0174   0502 52 02 00      sub sp, 2 ; m
0175   0505             
0176   0505             ; --- BEGIN INLINE ASM BLOCK
0177   0505 07 F2 08      call scan_u16d
0178   0508 45 FF FF      mov [bp + -1], a
0179   050B             ; --- END INLINE ASM BLOCK
0180   050B             
0181   050B FA 05 00      lea d, [bp + 5] ; n
0182   050E 2A            mov b, [d]
0183   050F 74            mov d, b
0184   0510 2C FF FF      mov b, [bp + -1] ; m
0185   0513 11            mov a, b
0186   0514 43            mov [d], a
0187   0515 F9            leave
0188   0516 09            ret
0189   0517             printn:
0190   0517 D2            push bp
0191   0518 9B            mov bp, sp
0192   0519             
0193   0519             ; --- BEGIN INLINE ASM BLOCK
0194   0519 17 05 00      mov a, [bp + 5]
0195   051C 07 1D 08      call print_u16d
0196   051F             ; --- END INLINE ASM BLOCK
0197   051F             
0198   051F F9            leave
0199   0520 09            ret
0200   0521             print:
0201   0521 D2            push bp
0202   0522 9B            mov bp, sp
0203   0523             
0204   0523             ; --- BEGIN INLINE ASM BLOCK
0205   0523 17 05 00      mov a, [bp + 5]
0206   0526 3C            mov d, a
0207   0527 07 F4 07      call puts
0208   052A             ; --- END INLINE ASM BLOCK
0209   052A             
0210   052A F9            leave
0211   052B 09            ret
0212   052C             ; --- END TEXT BLOCK
0213   052C             
0214   052C             ; --- BEGIN DATA BLOCK
0215   052C             s1_data: 
0216   052C 48 00 65 00 .dw 'H', 'e', 'l', 'l', 'o', 0,
0216   0530 6C 00 6C 00 
0216   0534 6F 00 00 00 
0217   0538 00 00 00 00 .fill 88, 0
0217   053C 00 00 00 00 
0217   0540 00 00 00 00 
0217   0544 00 00 00 00 
0217   0548 00 00 00 00 
0217   054C 00 00 00 00 
0217   0550 00 00 00 00 
0217   0554 00 00 00 00 
0217   0558 00 00 00 00 
0217   055C 00 00 00 00 
0217   0560 00 00 00 00 
0217   0564 00 00 00 00 
0217   0568 00 00 00 00 
0217   056C 00 00 00 00 
0217   0570 00 00 00 00 
0217   0574 00 00 00 00 
0217   0578 00 00 00 00 
0217   057C 00 00 00 00 
0217   0580 00 00 00 00 
0217   0584 00 00 00 00 
0217   0588 00 00 00 00 
0217   058C 00 00 00 00 
0218   0590 2C 05       s1: .dw s1_data
0219   0592 2E 20 4D 79 s2_data: .db ". My name is Sol-1.", 0
0219   0596 20 6E 61 6D 
0219   059A 65 20 69 73 
0219   059E 20 53 6F 6C 
0219   05A2 2D 31 2E 00 
0220   05A6 92 05       s2: .dw s2_data
0221   05A8             ; --- END DATA BLOCK
0222   05A8             
0223   05A8             ; --- BEGIN INCLUDE BLOCK
0224   05A8             .include "lib/stdio.asm"
0001+  05A8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  05A8             ; stdio.s
0003+  05A8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  05A8             .include "lib/string.asm"
0001++ 05A8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 05A8             ; string.s
0003++ 05A8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 05A8             
0005++ 05A8             
0006++ 05A8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 05A8             ; strrev
0008++ 05A8             ; reverse a string
0009++ 05A8             ; D = string address
0010++ 05A8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 05A8             ; 01234
0012++ 05A8             strrev:
0013++ 05A8 4B          	pusha
0014++ 05A9 07 EF 05    	call strlen	; length in C
0015++ 05AC 12          	mov a, c
0016++ 05AD AF 01 00    	cmp a, 1
0017++ 05B0 D0 CA 05    	jleu strrev_end	; check string length. string len must be > 1
0018++ 05B3 7D          	dec a
0019++ 05B4 FD 4E       	mov si, d	; beginning of string
0020++ 05B6 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 05B8 59          	add d, a	; end of string
0022++ 05B9 12          	mov a, c
0023++ 05BA FD 9B       	shr a		; divide by 2
0024++ 05BC 39          	mov c, a	; C now counts the steps
0025++ 05BD             strrev_L0:
0026++ 05BD 32          	mov bl, [d]	; save load right-side char into BL
0027++ 05BE F6          	lodsb		; load left-side char into AL; increase SI
0028++ 05BF 3E          	mov [d], al	; store left char into right side
0029++ 05C0 1B          	mov al, bl
0030++ 05C1 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 05C2 7E          	dec c
0032++ 05C3 7F          	dec d
0033++ 05C4 C2 00 00    	cmp c, 0
0034++ 05C7 C7 BD 05    	jne strrev_L0
0035++ 05CA             strrev_end:
0036++ 05CA 4C          	popa
0037++ 05CB 09          	ret
0038++ 05CC             	
0039++ 05CC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 05CC             ; strchr
0041++ 05CC             ; search string in D for char in AL
0042++ 05CC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 05CC             strchr:
0044++ 05CC             strchr_L0:
0045++ 05CC 32          	mov bl, [d]
0046++ 05CD C1 00       	cmp bl, 0
0047++ 05CF C6 DA 05    	je strchr_end
0048++ 05D2 BA          	cmp al, bl
0049++ 05D3 C6 DA 05    	je strchr_end
0050++ 05D6 79          	inc d
0051++ 05D7 0A CC 05    	jmp strchr_L0
0052++ 05DA             strchr_end:
0053++ 05DA 1B          	mov al, bl
0054++ 05DB 09          	ret
0055++ 05DC             
0056++ 05DC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 05DC             ; strstr
0058++ 05DC             ; find sub-string
0059++ 05DC             ; str1 in SI
0060++ 05DC             ; str2 in DI
0061++ 05DC             ; SI points to end of source string
0062++ 05DC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 05DC             strstr:
0064++ 05DC DB          	push al
0065++ 05DD DA          	push d
0066++ 05DE E3          	push di
0067++ 05DF             strstr_loop:
0068++ 05DF F3          	cmpsb					; compare a byte of the strings
0069++ 05E0 C7 EB 05    	jne strstr_ret
0070++ 05E3 FC 00 00    	lea d, [di + 0]
0071++ 05E6 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 05E8 C7 DF 05    	jne strstr_loop				; equal chars but not at end
0073++ 05EB             strstr_ret:
0074++ 05EB F0          	pop di
0075++ 05EC E7          	pop d
0076++ 05ED E8          	pop al
0077++ 05EE 09          	ret
0078++ 05EF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 05EF             ; length of null terminated string
0080++ 05EF             ; result in C
0081++ 05EF             ; pointer in D
0082++ 05EF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 05EF             strlen:
0084++ 05EF DA          	push d
0085++ 05F0 38 00 00    	mov c, 0
0086++ 05F3             strlen_L1:
0087++ 05F3 BD 00       	cmp byte [d], 0
0088++ 05F5 C6 FD 05    	je strlen_ret
0089++ 05F8 79          	inc d
0090++ 05F9 78          	inc c
0091++ 05FA 0A F3 05    	jmp strlen_L1
0092++ 05FD             strlen_ret:
0093++ 05FD E7          	pop d
0094++ 05FE 09          	ret
0095++ 05FF             
0096++ 05FF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 05FF             ; STRCMP
0098++ 05FF             ; compare two strings
0099++ 05FF             ; str1 in SI
0100++ 05FF             ; str2 in DI
0101++ 05FF             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 05FF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 05FF             strcmp:
0104++ 05FF DB          	push al
0105++ 0600 DA          	push d
0106++ 0601 E3          	push di
0107++ 0602 E2          	push si
0108++ 0603             strcmp_loop:
0109++ 0603 F3          	cmpsb					; compare a byte of the strings
0110++ 0604 C7 0F 06    	jne strcmp_ret
0111++ 0607 FB FF FF    	lea d, [si +- 1]
0112++ 060A BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 060C C7 03 06    	jne strcmp_loop				; equal chars but not at end
0114++ 060F             strcmp_ret:
0115++ 060F EF          	pop si
0116++ 0610 F0          	pop di
0117++ 0611 E7          	pop d
0118++ 0612 E8          	pop al
0119++ 0613 09          	ret
0120++ 0614             
0121++ 0614             
0122++ 0614             ; STRCPY
0123++ 0614             ; copy null terminated string from SI to DI
0124++ 0614             ; source in SI
0125++ 0614             ; destination in DI
0126++ 0614             strcpy:
0127++ 0614 E2          	push si
0128++ 0615 E3          	push di
0129++ 0616 DB          	push al
0130++ 0617             strcpy_L1:
0131++ 0617 F6          	lodsb
0132++ 0618 F7          	stosb
0133++ 0619 B9 00       	cmp al, 0
0134++ 061B C7 17 06    	jne strcpy_L1
0135++ 061E             strcpy_end:
0136++ 061E E8          	pop al
0137++ 061F F0          	pop di
0138++ 0620 EF          	pop si
0139++ 0621 09          	ret
0140++ 0622             
0141++ 0622             ; STRCAT
0142++ 0622             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0622             ; source in SI
0144++ 0622             ; destination in DI
0145++ 0622             strcat:
0146++ 0622 E2          	push si
0147++ 0623 E3          	push di
0148++ 0624 D7          	push a
0149++ 0625 DA          	push d
0150++ 0626 50          	mov a, di
0151++ 0627 3C          	mov d, a
0152++ 0628             strcat_goto_end_L1:
0153++ 0628 BD 00       	cmp byte[d], 0
0154++ 062A C6 31 06    	je strcat_start
0155++ 062D 79          	inc d
0156++ 062E 0A 28 06    	jmp strcat_goto_end_L1
0157++ 0631             strcat_start:
0158++ 0631 FD 50       	mov di, d
0159++ 0633             strcat_L1:
0160++ 0633 F6          	lodsb
0161++ 0634 F7          	stosb
0162++ 0635 B9 00       	cmp al, 0
0163++ 0637 C7 33 06    	jne strcat_L1
0164++ 063A             strcat_end:
0165++ 063A E7          	pop d
0166++ 063B E4          	pop a
0167++ 063C F0          	pop di
0168++ 063D EF          	pop si
0169++ 063E 09          	ret
0005+  063F             
0006+  063F 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  0643 34 35 36 37 
0006+  0647 38 39 41 42 
0006+  064B 43 44 45 46 
0007+  064F 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  0653 1B 5B 48 00 
0008+  0657             
0009+  0657 01 00       table_power:.dw 1
0010+  0659 0A 00       			.dw 10
0011+  065B 64 00       			.dw 100
0012+  065D E8 03       			.dw 1000
0013+  065F 10 27       			.dw 10000
0014+  0661             
0015+  0661             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  0661             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  0661             ; ASCII in BL
0018+  0661             ; result in AL
0019+  0661             ; ascii for F = 0100 0110
0020+  0661             ; ascii for 9 = 0011 1001
0021+  0661             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  0661             hex_ascii_encode:
0023+  0661 1B          	mov al, bl
0024+  0662 93 40       	test al, $40				; test if letter or number
0025+  0664 C7 6A 06    	jnz hex_letter
0026+  0667 87 0F       	and al, $0F				; get number
0027+  0669 09          	ret
0028+  066A             hex_letter:
0029+  066A 87 0F       	and al, $0F				; get letter
0030+  066C 6A 09       	add al, 9
0031+  066E 09          	ret
0032+  066F             
0033+  066F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  066F             ; ATOI
0035+  066F             ; 2 letter hex string in B
0036+  066F             ; 8bit integer returned in AL
0037+  066F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  066F             atoi:
0039+  066F D8          	push b
0040+  0670 07 61 06    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  0673 30          	mov bl, bh
0042+  0674 DB          	push al					; save a
0043+  0675 07 61 06    	call hex_ascii_encode
0044+  0678 EA          	pop bl	
0045+  0679 FD 9E 04    	shl al, 4
0046+  067C 8C          	or al, bl
0047+  067D E5          	pop b
0048+  067E 09          	ret	
0049+  067F             
0050+  067F             
0051+  067F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  067F             ; printf
0053+  067F             ; no need for explanations!
0054+  067F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  067F             printf:
0056+  067F 09          	ret
0057+  0680             
0058+  0680             
0059+  0680             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  0680             ; scanf
0061+  0680             ; no need for explanations!
0062+  0680             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  0680             scanf:
0064+  0680 09          	ret
0065+  0681             
0066+  0681             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  0681             ; ITOA
0068+  0681             ; 8bit value in BL
0069+  0681             ; 2 byte ASCII result in A
0070+  0681             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  0681             itoa:
0072+  0681 DA          	push d
0073+  0682 D8          	push b
0074+  0683 A7 00       	mov bh, 0
0075+  0685 FD A4 04    	shr bl, 4	
0076+  0688 74          	mov d, b
0077+  0689 1F 3F 06    	mov al, [d + s_hex_digits]
0078+  068C 23          	mov ah, al
0079+  068D             	
0080+  068D E5          	pop b
0081+  068E D8          	push b
0082+  068F A7 00       	mov bh, 0
0083+  0691 FD 87 0F    	and bl, $0F
0084+  0694 74          	mov d, b
0085+  0695 1F 3F 06    	mov al, [d + s_hex_digits]
0086+  0698 E5          	pop b
0087+  0699 E7          	pop d
0088+  069A 09          	ret
0089+  069B             
0090+  069B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  069B             ; HEX STRING TO BINARY
0092+  069B             ; di = destination address
0093+  069B             ; si = source
0094+  069B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  069B             hex_to_int:
0096+  069B             hex_to_int_L1:
0097+  069B F6          	lodsb					; load from [SI] to AL
0098+  069C B9 00       	cmp al, 0				; check if ASCII 0
0099+  069E C6 AB 06    	jz hex_to_int_ret
0100+  06A1 36          	mov bh, al
0101+  06A2 F6          	lodsb
0102+  06A3 2F          	mov bl, al
0103+  06A4 07 6F 06    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  06A7 F7          	stosb					; store AL to [DI]
0105+  06A8 0A 9B 06    	jmp hex_to_int_L1
0106+  06AB             hex_to_int_ret:
0107+  06AB 09          	ret		
0108+  06AC             
0109+  06AC             
0110+  06AC             
0111+  06AC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  06AC             ; GETCHAR
0113+  06AC             ; char in ah
0114+  06AC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  06AC             getchar:
0116+  06AC DB          	push al
0117+  06AD             getchar_retry:
0118+  06AD FD 0C       	sti
0119+  06AF 19 01       	mov al, 1
0120+  06B1 05 03       	syscall sys_io			; receive in AH
0121+  06B3 B9 00       	cmp al, 0			; check if any char was receive
0122+  06B5 C6 AD 06    	je getchar_retry
0123+  06B8 E8          	pop al
0124+  06B9 09          	ret
0125+  06BA             
0126+  06BA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  06BA             ; PUTCHAR
0128+  06BA             ; char in ah
0129+  06BA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  06BA             putchar:
0131+  06BA D7          	push a
0132+  06BB 19 00       	mov al, 0
0133+  06BD 05 03       	syscall sys_io			; char in AH
0134+  06BF E4          	pop a
0135+  06C0 09          	ret
0136+  06C1             
0137+  06C1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  06C1             ;; INPUT A STRING
0139+  06C1             ;; terminates with null
0140+  06C1             ;; pointer in D
0141+  06C1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  06C1             gets:
0143+  06C1 D7          	push a
0144+  06C2 DA          	push d
0145+  06C3             gets_loop:
0146+  06C3 FD 0C       	sti
0147+  06C5 19 01       	mov al, 1
0148+  06C7 05 03       	syscall sys_io			; receive in AH
0149+  06C9 B9 00       	cmp al, 0				; check error code (AL)
0150+  06CB C6 C3 06    	je gets_loop			; if no char received, retry
0151+  06CE             
0152+  06CE 76 1B       	cmp ah, 27
0153+  06D0 C6 F1 06    	je gets_telnet_escape
0154+  06D3 76 0A       	cmp ah, $0A				; LF
0155+  06D5 C6 4A 07    	je gets_end
0156+  06D8 76 0D       	cmp ah, $0D				; CR
0157+  06DA C6 4A 07    	je gets_end
0158+  06DD 76 5C       	cmp ah, $5C				; '\\'
0159+  06DF C6 21 07    	je gets_escape
0160+  06E2             	
0161+  06E2 76 08       	cmp ah, $08			; check for backspace
0162+  06E4 C6 ED 06    	je gets_backspace
0163+  06E7             
0164+  06E7 1A          	mov al, ah
0165+  06E8 3E          	mov [d], al
0166+  06E9 79          	inc d
0167+  06EA 0A C3 06    	jmp gets_loop
0168+  06ED             gets_backspace:
0169+  06ED 7F          	dec d
0170+  06EE 0A C3 06    	jmp gets_loop
0171+  06F1             gets_telnet_escape:
0172+  06F1 FD 0C       	sti
0173+  06F3 19 01       	mov al, 1
0174+  06F5 05 03       	syscall sys_io				; receive in AH without echo
0175+  06F7 B9 00       	cmp al, 0					; check error code (AL)
0176+  06F9 C6 F1 06    	je gets_telnet_escape		; if no char received, retry
0177+  06FC 76 5B       	cmp ah, '['
0178+  06FE C7 C3 06    	jne gets_loop
0179+  0701             gets_telnet_escape_phase2:
0180+  0701 FD 0C       	sti
0181+  0703 19 01       	mov al, 1
0182+  0705 05 03       	syscall sys_io					; receive in AH without echo
0183+  0707 B9 00       	cmp al, 0						; check error code (AL)
0184+  0709 C6 01 07    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  070C 76 44       	cmp ah, 'D'
0186+  070E C6 19 07    	je gets_left_arrow
0187+  0711 76 43       	cmp ah, 'C'
0188+  0713 C6 1D 07    	je gets_right_arrow
0189+  0716 0A C3 06    	jmp gets_loop
0190+  0719             gets_left_arrow:
0191+  0719 7F          	dec d
0192+  071A 0A C3 06    	jmp gets_loop
0193+  071D             gets_right_arrow:
0194+  071D 79          	inc d
0195+  071E 0A C3 06    	jmp gets_loop
0196+  0721             gets_escape:
0197+  0721 FD 0C       	sti
0198+  0723 19 01       	mov al, 1
0199+  0725 05 03       	syscall sys_io			; receive in AH
0200+  0727 B9 00       	cmp al, 0				; check error code (AL)
0201+  0729 C6 21 07    	je gets_escape			; if no char received, retry
0202+  072C 76 6E       	cmp ah, 'n'
0203+  072E C6 3C 07    	je gets_LF
0204+  0731 76 72       	cmp ah, 'r'
0205+  0733 C6 43 07    	je gets_CR
0206+  0736 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  0737 3E          	mov [d], al
0208+  0738 79          	inc d
0209+  0739 0A C3 06    	jmp gets_loop
0210+  073C             gets_LF:
0211+  073C 19 0A       	mov al, $0A
0212+  073E 3E          	mov [d], al
0213+  073F 79          	inc d
0214+  0740 0A C3 06    	jmp gets_loop
0215+  0743             gets_CR:
0216+  0743 19 0D       	mov al, $0D
0217+  0745 3E          	mov [d], al
0218+  0746 79          	inc d
0219+  0747 0A C3 06    	jmp gets_loop
0220+  074A             gets_end:
0221+  074A 19 00       	mov al, 0
0222+  074C 3E          	mov [d], al				; terminate string
0223+  074D E7          	pop d
0224+  074E E4          	pop a
0225+  074F 09          	ret
0226+  0750             
0227+  0750             
0228+  0750             
0229+  0750             
0230+  0750             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  0750             ;; INPUT TEXT
0232+  0750             ;; terminated with CTRL+D
0233+  0750             ;; pointer in D
0234+  0750             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  0750             gettxt:
0236+  0750 D7          	push a
0237+  0751 DA          	push d
0238+  0752             gettxt_loop:
0239+  0752 19 01       	mov al, 1
0240+  0754 05 03       	syscall sys_io			; receive in AH
0241+  0756 B9 00       	cmp al, 0				; check error code (AL)
0242+  0758 C6 52 07    	je gettxt_loop		; if no char received, retry
0243+  075B 76 04       	cmp ah, 4			; EOT
0244+  075D C6 9B 07    	je gettxt_end
0245+  0760 76 08       	cmp ah, $08			; check for backspace
0246+  0762 C6 97 07    	je gettxt_backspace
0247+  0765 76 5C       	cmp ah, $5C				; '\\'
0248+  0767 C6 70 07    	je gettxt_escape
0249+  076A 1A          	mov al, ah
0250+  076B 3E          	mov [d], al
0251+  076C 79          	inc d
0252+  076D 0A 52 07    	jmp gettxt_loop
0253+  0770             gettxt_escape:
0254+  0770 19 01       	mov al, 1
0255+  0772 05 03       	syscall sys_io			; receive in AH
0256+  0774 B9 00       	cmp al, 0				; check error code (AL)
0257+  0776 C6 70 07    	je gettxt_escape		; if no char received, retry
0258+  0779 76 6E       	cmp ah, 'n'
0259+  077B C6 89 07    	je gettxt_LF
0260+  077E 76 72       	cmp ah, 'r'
0261+  0780 C6 90 07    	je gettxt_CR
0262+  0783 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  0784 3E          	mov [d], al
0264+  0785 79          	inc d
0265+  0786 0A 52 07    	jmp gettxt_loop
0266+  0789             gettxt_LF:
0267+  0789 19 0A       	mov al, $0A
0268+  078B 3E          	mov [d], al
0269+  078C 79          	inc d
0270+  078D 0A 52 07    	jmp gettxt_loop
0271+  0790             gettxt_CR:
0272+  0790 19 0D       	mov al, $0D
0273+  0792 3E          	mov [d], al
0274+  0793 79          	inc d
0275+  0794 0A 52 07    	jmp gettxt_loop
0276+  0797             gettxt_backspace:
0277+  0797 7F          	dec d
0278+  0798 0A 52 07    	jmp gettxt_loop
0279+  079B             gettxt_end:
0280+  079B 19 00       	mov al, 0
0281+  079D 3E          	mov [d], al				; terminate string
0282+  079E E7          	pop d
0283+  079F E4          	pop a
0284+  07A0 09          	ret
0285+  07A1             
0286+  07A1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  07A1             ; PRINT NEW LINE
0288+  07A1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  07A1             printnl:
0290+  07A1 D7          	push a
0291+  07A2 10 00 0A    	mov a, $0A00
0292+  07A5 05 03       	syscall sys_io
0293+  07A7 10 00 0D    	mov a, $0D00
0294+  07AA 05 03       	syscall sys_io
0295+  07AC E4          	pop a
0296+  07AD 09          	ret
0297+  07AE             
0298+  07AE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  07AE             ; strtoint
0300+  07AE             ; 4 digit hex string number in d
0301+  07AE             ; integer returned in A
0302+  07AE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  07AE             strtointx:
0304+  07AE D8          	push b
0305+  07AF 32          	mov bl, [d]
0306+  07B0 37          	mov bh, bl
0307+  07B1 33 01 00    	mov bl, [d + 1]
0308+  07B4 07 6F 06    	call atoi				; convert to int in AL
0309+  07B7 23          	mov ah, al				; move to AH
0310+  07B8 33 02 00    	mov bl, [d + 2]
0311+  07BB 37          	mov bh, bl
0312+  07BC 33 03 00    	mov bl, [d + 3]
0313+  07BF 07 6F 06    	call atoi				; convert to int in AL
0314+  07C2 E5          	pop b
0315+  07C3 09          	ret
0316+  07C4             
0317+  07C4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  07C4             ; strtoint
0319+  07C4             ; 5 digit base10 string number in d
0320+  07C4             ; integer returned in A
0321+  07C4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  07C4             strtoint:
0323+  07C4 E2          	push si
0324+  07C5 D8          	push b
0325+  07C6 D9          	push c
0326+  07C7 DA          	push d
0327+  07C8 07 EF 05    	call strlen			; get string length in C
0328+  07CB 7E          	dec c
0329+  07CC FD 4E       	mov si, d
0330+  07CE 12          	mov a, c
0331+  07CF FD 99       	shl a
0332+  07D1 3B 57 06    	mov d, table_power
0333+  07D4 59          	add d, a
0334+  07D5 38 00 00    	mov c, 0
0335+  07D8             strtoint_L0:
0336+  07D8 F6          	lodsb			; load ASCII to al
0337+  07D9 B9 00       	cmp al, 0
0338+  07DB C6 EE 07    	je strtoint_end
0339+  07DE 6F 30       	sub al, $30		; make into integer
0340+  07E0 22 00       	mov ah, 0
0341+  07E2 2A          	mov b, [d]
0342+  07E3 AC          	mul a, b			; result in B since it fits in 16bits
0343+  07E4 11          	mov a, b
0344+  07E5 28          	mov b, c
0345+  07E6 54          	add a, b
0346+  07E7 39          	mov c, a
0347+  07E8 63 02 00    	sub d, 2
0348+  07EB 0A D8 07    	jmp strtoint_L0
0349+  07EE             strtoint_end:
0350+  07EE 12          	mov a, c
0351+  07EF E7          	pop d
0352+  07F0 E6          	pop c
0353+  07F1 E5          	pop b
0354+  07F2 EF          	pop si
0355+  07F3 09          	ret
0356+  07F4             
0357+  07F4             
0358+  07F4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  07F4             ; PRINT NULL TERMINATED STRING
0360+  07F4             ; pointer in D
0361+  07F4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  07F4             puts:
0363+  07F4 D7          	push a
0364+  07F5 DA          	push d
0365+  07F6             puts_L1:
0366+  07F6 1E          	mov al, [d]
0367+  07F7 B9 00       	cmp al, 0
0368+  07F9 C6 05 08    	jz puts_END
0369+  07FC 23          	mov ah, al
0370+  07FD 19 00       	mov al, 0
0371+  07FF 05 03       	syscall sys_io
0372+  0801 79          	inc d
0373+  0802 0A F6 07    	jmp puts_L1
0374+  0805             puts_END:
0375+  0805 E7          	pop d
0376+  0806 E4          	pop a
0377+  0807 09          	ret
0378+  0808             
0379+  0808             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  0808             ; PRINT N SIZE STRING
0381+  0808             ; pointer in D
0382+  0808             ; size in C
0383+  0808             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  0808             putsn:
0385+  0808 DB          	push al
0386+  0809 DA          	push d
0387+  080A D9          	push c
0388+  080B             putsn_L0:
0389+  080B 1E          	mov al, [d]
0390+  080C 23          	mov ah, al
0391+  080D 19 00       	mov al, 0
0392+  080F 05 03       	syscall sys_io
0393+  0811 79          	inc d
0394+  0812 7E          	dec c	
0395+  0813 C2 00 00    	cmp c, 0
0396+  0816 C7 0B 08    	jne putsn_L0
0397+  0819             putsn_end:
0398+  0819 E6          	pop c
0399+  081A E7          	pop d
0400+  081B E8          	pop al
0401+  081C 09          	ret
0402+  081D             
0403+  081D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  081D             ; print 16bit decimal number
0405+  081D             ; input number in A
0406+  081D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  081D             print_u16d:
0408+  081D D7          	push a
0409+  081E D8          	push b
0410+  081F 26 10 27    	mov b, 10000
0411+  0822 AE          	div a, b			; get 10000 coeff.
0412+  0823 07 49 08    	call print_number
0413+  0826 11          	mov a, b
0414+  0827 26 E8 03    	mov b, 1000
0415+  082A AE          	div a, b			; get 10000 coeff.
0416+  082B 07 49 08    	call print_number
0417+  082E 11          	mov a, b
0418+  082F 26 64 00    	mov b, 100
0419+  0832 AE          	div a, b
0420+  0833 07 49 08    	call print_number
0421+  0836 11          	mov a, b
0422+  0837 26 0A 00    	mov b, 10
0423+  083A AE          	div a, b
0424+  083B 07 49 08    	call print_number
0425+  083E 11          	mov a, b
0426+  083F 6A 30       	add al, $30
0427+  0841 23          	mov ah, al
0428+  0842 19 00       	mov al, 0
0429+  0844 05 03       	syscall sys_io	; print coeff
0430+  0846 E5          	pop b
0431+  0847 E4          	pop a
0432+  0848 09          	ret
0433+  0849             
0434+  0849             
0435+  0849             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  0849             ; if A == 0, print space
0437+  0849             ; else print A
0438+  0849             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0439+  0849             print_number:
0440+  0849 6A 30       	add al, $30
0441+  084B 23          	mov ah, al
0442+  084C 07 BA 06    	call putchar
0443+  084F 09          	ret
0444+  0850             
0445+  0850             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0446+  0850             ; PRINT 16BIT HEX INTEGER
0447+  0850             ; integer value in reg B
0448+  0850             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  0850             print_u16x:
0450+  0850 D7          	push a
0451+  0851 D8          	push b
0452+  0852 DD          	push bl
0453+  0853 30          	mov bl, bh
0454+  0854 07 81 06    	call itoa				; convert bh to char in A
0455+  0857 2F          	mov bl, al				; save al
0456+  0858 19 00       	mov al, 0
0457+  085A 05 03       	syscall sys_io				; display AH
0458+  085C 24          	mov ah, bl				; retrieve al
0459+  085D 19 00       	mov al, 0
0460+  085F 05 03       	syscall sys_io				; display AL
0461+  0861             
0462+  0861 EA          	pop bl
0463+  0862 07 81 06    	call itoa				; convert bh to char in A
0464+  0865 2F          	mov bl, al				; save al
0465+  0866 19 00       	mov al, 0
0466+  0868 05 03       	syscall sys_io				; display AH
0467+  086A 24          	mov ah, bl				; retrieve al
0468+  086B 19 00       	mov al, 0
0469+  086D 05 03       	syscall sys_io				; display AL
0470+  086F             
0471+  086F E5          	pop b
0472+  0870 E4          	pop a
0473+  0871 09          	ret
0474+  0872             
0475+  0872             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  0872             ; INPUT 16BIT HEX INTEGER
0477+  0872             ; read 16bit integer into A
0478+  0872             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  0872             scan_u16x:
0480+  0872 F8 10 00    	enter 16
0481+  0875 D8          	push b
0482+  0876 DA          	push d
0483+  0877             
0484+  0877 FA F1 FF    	lea d, [bp + -15]
0485+  087A 07 C1 06    	call gets				; get number
0486+  087D             
0487+  087D 32          	mov bl, [d]
0488+  087E 37          	mov bh, bl
0489+  087F 33 01 00    	mov bl, [d + 1]
0490+  0882 07 6F 06    	call atoi				; convert to int in AL
0491+  0885 23          	mov ah, al				; move to AH
0492+  0886             
0493+  0886 33 02 00    	mov bl, [d + 2]
0494+  0889 37          	mov bh, bl
0495+  088A 33 03 00    	mov bl, [d + 3]
0496+  088D 07 6F 06    	call atoi				; convert to int in AL
0497+  0890             
0498+  0890 E7          	pop d
0499+  0891 E5          	pop b
0500+  0892 F9          	leave
0501+  0893 09          	ret
0502+  0894             
0503+  0894             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0504+  0894             ; PRINT 8bit HEX INTEGER
0505+  0894             ; integer value in reg bl
0506+  0894             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  0894             print_u8x:
0508+  0894 D7          	push a
0509+  0895 DD          	push bl
0510+  0896             
0511+  0896 07 81 06    	call itoa				; convert bl to char in A
0512+  0899 2F          	mov bl, al				; save al
0513+  089A 19 00       	mov al, 0
0514+  089C 05 03       	syscall sys_io				; display AH
0515+  089E 24          	mov ah, bl				; retrieve al
0516+  089F 19 00       	mov al, 0
0517+  08A1 05 03       	syscall sys_io				; display AL
0518+  08A3             
0519+  08A3 EA          	pop bl
0520+  08A4 E4          	pop a
0521+  08A5 09          	ret
0522+  08A6             
0523+  08A6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0524+  08A6             ; print 8bit decimal unsigned number
0525+  08A6             ; input number in AL
0526+  08A6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  08A6             print_u8d:
0528+  08A6 D7          	push a
0529+  08A7 D8          	push b
0530+  08A8             
0531+  08A8 22 00       	mov ah, 0
0532+  08AA 26 64 00    	mov b, 100
0533+  08AD AE          	div a, b
0534+  08AE D8          	push b			; save remainder
0535+  08AF B9 00       	cmp al, 0
0536+  08B1 C6 BB 08    	je skip100
0537+  08B4 6A 30       	add al, $30
0538+  08B6 23          	mov ah, al
0539+  08B7 19 00       	mov al, 0
0540+  08B9 05 03       	syscall sys_io	; print coeff
0541+  08BB             skip100:
0542+  08BB E4          	pop a
0543+  08BC 22 00       	mov ah, 0
0544+  08BE 26 0A 00    	mov b, 10
0545+  08C1 AE          	div a, b
0546+  08C2 D8          	push b			; save remainder
0547+  08C3 B9 00       	cmp al, 0
0548+  08C5 C6 CF 08    	je skip10
0549+  08C8 6A 30       	add al, $30
0550+  08CA 23          	mov ah, al
0551+  08CB 19 00       	mov al, 0
0552+  08CD 05 03       	syscall sys_io	; print coeff
0553+  08CF             skip10:
0554+  08CF E4          	pop a
0555+  08D0 1B          	mov al, bl
0556+  08D1 6A 30       	add al, $30
0557+  08D3 23          	mov ah, al
0558+  08D4 19 00       	mov al, 0
0559+  08D6 05 03       	syscall sys_io	; print coeff
0560+  08D8 E5          	pop b
0561+  08D9 E4          	pop a
0562+  08DA 09          	ret
0563+  08DB             
0564+  08DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0565+  08DB             ; INPUT 8BIT HEX INTEGER
0566+  08DB             ; read 8bit integer into AL
0567+  08DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  08DB             scan_u8x:
0569+  08DB F8 04 00    	enter 4
0570+  08DE D8          	push b
0571+  08DF DA          	push d
0572+  08E0             
0573+  08E0 FA FD FF    	lea d, [bp + -3]
0574+  08E3 07 C1 06    	call gets				; get number
0575+  08E6             
0576+  08E6 32          	mov bl, [d]
0577+  08E7 37          	mov bh, bl
0578+  08E8 33 01 00    	mov bl, [d + 1]
0579+  08EB 07 6F 06    	call atoi				; convert to int in AL
0580+  08EE             
0581+  08EE E7          	pop d
0582+  08EF E5          	pop b
0583+  08F0 F9          	leave
0584+  08F1 09          	ret
0585+  08F2             
0586+  08F2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  08F2             ; input decimal number
0588+  08F2             ; result in A
0589+  08F2             ; 655'\0'
0590+  08F2             ; low--------high
0591+  08F2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0592+  08F2             scan_u16d:
0593+  08F2 F8 08 00    	enter 8
0594+  08F5 E2          	push si
0595+  08F6 D8          	push b
0596+  08F7 D9          	push c
0597+  08F8 DA          	push d
0598+  08F9 FA F9 FF    	lea d, [bp +- 7]
0599+  08FC 07 C1 06    	call gets
0600+  08FF 07 EF 05    	call strlen			; get string length in C
0601+  0902 7E          	dec c
0602+  0903 FD 4E       	mov si, d
0603+  0905 12          	mov a, c
0604+  0906 FD 99       	shl a
0605+  0908 3B 57 06    	mov d, table_power
0606+  090B 59          	add d, a
0607+  090C 38 00 00    	mov c, 0
0608+  090F             mul_loop:
0609+  090F F6          	lodsb			; load ASCII to al
0610+  0910 B9 00       	cmp al, 0
0611+  0912 C6 25 09    	je mul_exit
0612+  0915 6F 30       	sub al, $30		; make into integer
0613+  0917 22 00       	mov ah, 0
0614+  0919 2A          	mov b, [d]
0615+  091A AC          	mul a, b			; result in B since it fits in 16bits
0616+  091B 11          	mov a, b
0617+  091C 28          	mov b, c
0618+  091D 54          	add a, b
0619+  091E 39          	mov c, a
0620+  091F 63 02 00    	sub d, 2
0621+  0922 0A 0F 09    	jmp mul_loop
0622+  0925             mul_exit:
0623+  0925 12          	mov a, c
0624+  0926 E7          	pop d
0625+  0927 E6          	pop c
0626+  0928 E5          	pop b
0627+  0929 EF          	pop si
0628+  092A F9          	leave
0629+  092B 09          	ret
0225   092C             ; --- END INCLUDE BLOCK
0226   092C             
0227   092C             
0228   092C             .end
tasm: Number of errors = 0
