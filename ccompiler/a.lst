0001   0000             ; --- FILENAME: test.c
0002   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0400             .org PROC_TEXT_ORG
0004   0400             
0005   0400             ; --- BEGIN TEXT BLOCK
0006   0400             
0007   0400             main:
0008   0400 D2            push bp
0009   0401 9B            mov bp, sp
0010   0402 52 02 00      sub sp, 2 ; swappos
0011   0405             _for1_init:
0012   0405 26 00 00      mov b, 0
0013   0408 D7            push a
0014   0409 11            mov a, b
0015   040A 45 FF FF      mov [bp + -1], a ; swappos
0016   040D E4            pop a
0017   040E             _for1_cond:
0018   040E 2C FF FF      mov b, [bp + -1] ; swappos
0019   0411 D7            push a
0020   0412 11            mov a, b
0021   0413 26 0A 00      mov b, 10
0022   0416 B0            cmp a, b
0023   0417 0E            lodflgs
0024   0418 87 02         and al, %00000010 ; <
0025   041A FD 9C         shr al
0026   041C 22 00         mov ah, 0
0027   041E 27            mov b, a
0028   041F E4            pop a
0029   0420 C0 00 00      cmp b, 0
0030   0423 C6 E9 04      je _for1_exit
0031   0426             _for1_block:
0032   0426 29 AC 05      mov b, [__anarr]
0033   0429 D7            push a
0034   042A 74            mov d, b
0035   042B DA            push d
0036   042C 2C FF FF      mov b, [bp + -1] ; swappos
0037   042F E7            pop d
0038   0430 10 02 00      mov a, 2
0039   0433 AC            mul a, b
0040   0434 5A            add d, b
0041   0435 E4            pop a
0042   0436 DA            push d
0043   0437 29 AC 05      mov b, [__anarr]
0044   043A D7            push a
0045   043B 74            mov d, b
0046   043C DA            push d
0047   043D 2C FF FF      mov b, [bp + -1] ; swappos
0048   0440 E7            pop d
0049   0441 10 02 00      mov a, 2
0050   0444 AC            mul a, b
0051   0445 5A            add d, b
0052   0446 2A            mov b, [d]
0053   0447 E4            pop a
0054   0448 D7            push a
0055   0449 11            mov a, b
0056   044A 29 C2 05      mov b, [__bnarr]
0057   044D D7            push a
0058   044E 74            mov d, b
0059   044F DA            push d
0060   0450 2C FF FF      mov b, [bp + -1] ; swappos
0061   0453 E7            pop d
0062   0454 10 02 00      mov a, 2
0063   0457 AC            mul a, b
0064   0458 5A            add d, b
0065   0459 2A            mov b, [d]
0066   045A E4            pop a
0067   045B 54            add a, b
0068   045C 27            mov b, a
0069   045D E4            pop a
0070   045E E7            pop d
0071   045F FD 43         mov [d], b
0072   0461 29 C2 05      mov b, [__bnarr]
0073   0464 D7            push a
0074   0465 74            mov d, b
0075   0466 DA            push d
0076   0467 2C FF FF      mov b, [bp + -1] ; swappos
0077   046A E7            pop d
0078   046B 10 02 00      mov a, 2
0079   046E AC            mul a, b
0080   046F 5A            add d, b
0081   0470 E4            pop a
0082   0471 DA            push d
0083   0472 29 AC 05      mov b, [__anarr]
0084   0475 D7            push a
0085   0476 74            mov d, b
0086   0477 DA            push d
0087   0478 2C FF FF      mov b, [bp + -1] ; swappos
0088   047B E7            pop d
0089   047C 10 02 00      mov a, 2
0090   047F AC            mul a, b
0091   0480 5A            add d, b
0092   0481 2A            mov b, [d]
0093   0482 E4            pop a
0094   0483 D7            push a
0095   0484 11            mov a, b
0096   0485 29 C2 05      mov b, [__bnarr]
0097   0488 D7            push a
0098   0489 74            mov d, b
0099   048A DA            push d
0100   048B 2C FF FF      mov b, [bp + -1] ; swappos
0101   048E E7            pop d
0102   048F 10 02 00      mov a, 2
0103   0492 AC            mul a, b
0104   0493 5A            add d, b
0105   0494 2A            mov b, [d]
0106   0495 E4            pop a
0107   0496 60            sub a, b
0108   0497 27            mov b, a
0109   0498 E4            pop a
0110   0499 E7            pop d
0111   049A FD 43         mov [d], b
0112   049C 29 AC 05      mov b, [__anarr]
0113   049F D7            push a
0114   04A0 74            mov d, b
0115   04A1 DA            push d
0116   04A2 2C FF FF      mov b, [bp + -1] ; swappos
0117   04A5 E7            pop d
0118   04A6 10 02 00      mov a, 2
0119   04A9 AC            mul a, b
0120   04AA 5A            add d, b
0121   04AB E4            pop a
0122   04AC DA            push d
0123   04AD 29 AC 05      mov b, [__anarr]
0124   04B0 D7            push a
0125   04B1 74            mov d, b
0126   04B2 DA            push d
0127   04B3 2C FF FF      mov b, [bp + -1] ; swappos
0128   04B6 E7            pop d
0129   04B7 10 02 00      mov a, 2
0130   04BA AC            mul a, b
0131   04BB 5A            add d, b
0132   04BC 2A            mov b, [d]
0133   04BD E4            pop a
0134   04BE D7            push a
0135   04BF 11            mov a, b
0136   04C0 29 C2 05      mov b, [__bnarr]
0137   04C3 D7            push a
0138   04C4 74            mov d, b
0139   04C5 DA            push d
0140   04C6 2C FF FF      mov b, [bp + -1] ; swappos
0141   04C9 E7            pop d
0142   04CA 10 02 00      mov a, 2
0143   04CD AC            mul a, b
0144   04CE 5A            add d, b
0145   04CF 2A            mov b, [d]
0146   04D0 E4            pop a
0147   04D1 60            sub a, b
0148   04D2 27            mov b, a
0149   04D3 E4            pop a
0150   04D4 E7            pop d
0151   04D5 FD 43         mov [d], b
0152   04D7             _for1_update:
0153   04D7 2C FF FF      mov b, [bp + -1] ; swappos
0154   04DA D7            push a
0155   04DB 11            mov a, b
0156   04DC FD 77         inc b
0157   04DE D7            push a
0158   04DF 11            mov a, b
0159   04E0 45 FF FF      mov [bp + -1], a ; swappos
0160   04E3 E4            pop a
0161   04E4 27            mov b, a
0162   04E5 E4            pop a
0163   04E6 0A 0E 04      jmp _for1_cond
0164   04E9             _for1_exit:
0165   04E9             _for2_init:
0166   04E9 26 00 00      mov b, 0
0167   04EC D7            push a
0168   04ED 11            mov a, b
0169   04EE 45 FF FF      mov [bp + -1], a ; swappos
0170   04F1 E4            pop a
0171   04F2             _for2_cond:
0172   04F2 2C FF FF      mov b, [bp + -1] ; swappos
0173   04F5 D7            push a
0174   04F6 11            mov a, b
0175   04F7 26 0A 00      mov b, 10
0176   04FA B0            cmp a, b
0177   04FB 0E            lodflgs
0178   04FC 87 02         and al, %00000010 ; <
0179   04FE FD 9C         shr al
0180   0500 22 00         mov ah, 0
0181   0502 27            mov b, a
0182   0503 E4            pop a
0183   0504 C0 00 00      cmp b, 0
0184   0507 C6 68 05      je _for2_exit
0185   050A             _for2_block:
0186   050A 29 AC 05      mov b, [__anarr]
0187   050D D7            push a
0188   050E 74            mov d, b
0189   050F DA            push d
0190   0510 2C FF FF      mov b, [bp + -1] ; swappos
0191   0513 E7            pop d
0192   0514 10 02 00      mov a, 2
0193   0517 AC            mul a, b
0194   0518 5A            add d, b
0195   0519 2A            mov b, [d]
0196   051A E4            pop a
0197   051B FD AB         swp b
0198   051D D8            push b
0199   051E 07 83 05      call printn
0200   0521 51 02 00      add sp, 2
0201   0524 26 C4 05      mov b, __string_0 ; " : "
0202   0527 FD AB         swp b
0203   0529 D8            push b
0204   052A 07 8D 05      call print
0205   052D 51 02 00      add sp, 2
0206   0530 29 C2 05      mov b, [__bnarr]
0207   0533 D7            push a
0208   0534 74            mov d, b
0209   0535 DA            push d
0210   0536 2C FF FF      mov b, [bp + -1] ; swappos
0211   0539 E7            pop d
0212   053A 10 02 00      mov a, 2
0213   053D AC            mul a, b
0214   053E 5A            add d, b
0215   053F 2A            mov b, [d]
0216   0540 E4            pop a
0217   0541 FD AB         swp b
0218   0543 D8            push b
0219   0544 07 83 05      call printn
0220   0547 51 02 00      add sp, 2
0221   054A 26 C8 05      mov b, __string_1 ; "\n"
0222   054D FD AB         swp b
0223   054F D8            push b
0224   0550 07 8D 05      call print
0225   0553 51 02 00      add sp, 2
0226   0556             _for2_update:
0227   0556 2C FF FF      mov b, [bp + -1] ; swappos
0228   0559 D7            push a
0229   055A 11            mov a, b
0230   055B FD 77         inc b
0231   055D D7            push a
0232   055E 11            mov a, b
0233   055F 45 FF FF      mov [bp + -1], a ; swappos
0234   0562 E4            pop a
0235   0563 27            mov b, a
0236   0564 E4            pop a
0237   0565 0A F2 04      jmp _for2_cond
0238   0568             _for2_exit:
0239   0568 F9            leave
0240   0569 05 0B         syscall sys_terminate_proc
0241   056B             
0242   056B             scann:
0243   056B D2            push bp
0244   056C 9B            mov bp, sp
0245   056D 52 02 00      sub sp, 2 ; m
0246   0570             
0247   0570             ; --- BEGIN INLINE ASM BLOCK
0248   0570 07 14 09      call scan_u16d
0249   0573 45 FF FF      mov [bp + -1], a
0250   0576             ; --- END INLINE ASM BLOCK
0251   0576             
0252   0576 FA 05 00      lea d, [bp + 5] ; n
0253   0579 2A            mov b, [d]
0254   057A D8            push b
0255   057B 2C FF FF      mov b, [bp + -1] ; m
0256   057E E7            pop d
0257   057F 11            mov a, b
0258   0580 43            mov [d], a
0259   0581 F9            leave
0260   0582 09            ret
0261   0583             
0262   0583             printn:
0263   0583 D2            push bp
0264   0584 9B            mov bp, sp
0265   0585             
0266   0585             ; --- BEGIN INLINE ASM BLOCK
0267   0585 17 05 00      mov a, [bp + 5]
0268   0588 07 3F 08      call print_u16d
0269   058B             ; --- END INLINE ASM BLOCK
0270   058B             
0271   058B F9            leave
0272   058C 09            ret
0273   058D             
0274   058D             print:
0275   058D D2            push bp
0276   058E 9B            mov bp, sp
0277   058F             
0278   058F             ; --- BEGIN INLINE ASM BLOCK
0279   058F 17 05 00      mov a, [bp + 5]
0280   0592 3C            mov d, a
0281   0593 07 16 08      call puts
0282   0596             ; --- END INLINE ASM BLOCK
0283   0596             
0284   0596 F9            leave
0285   0597 09            ret
0286   0598             ; --- END TEXT BLOCK
0287   0598             
0288   0598             ; --- BEGIN DATA BLOCK
0289   0598             __anarr_data: 
0290   0598 01 00 01 00 .dw 1,1,1,1,1,1,1,1,1,1,
0290   059C 01 00 01 00 
0290   05A0 01 00 01 00 
0290   05A4 01 00 01 00 
0290   05A8 01 00 01 00 
0291   05AC             .fill 0, 0
0292   05AC 98 05       __anarr: .dw __anarr_data
0293   05AE             __bnarr_data: 
0294   05AE 02 00 02 00 .dw 2,2,2,2,2,2,2,2,2,2,
0294   05B2 02 00 02 00 
0294   05B6 02 00 02 00 
0294   05BA 02 00 02 00 
0294   05BE 02 00 02 00 
0295   05C2             .fill 0, 0
0296   05C2 AE 05       __bnarr: .dw __bnarr_data
0297   05C4 20 3A 20 00 __string_0: .db " : ", 0
0298   05C8 0A 00       __string_1: .db "\n", 0
0299   05CA             ; --- END DATA BLOCK
0300   05CA             
0301   05CA             ; --- BEGIN INCLUDE BLOCK
0302   05CA             .include "lib/stdio.asm"
0001+  05CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  05CA             ; stdio.s
0003+  05CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  05CA             .include "lib/string.asm"
0001++ 05CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 05CA             ; string.s
0003++ 05CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 05CA             
0005++ 05CA             
0006++ 05CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 05CA             ; strrev
0008++ 05CA             ; reverse a string
0009++ 05CA             ; D = string address
0010++ 05CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 05CA             ; 01234
0012++ 05CA             strrev:
0013++ 05CA 4B          	pusha
0014++ 05CB 07 11 06    	call strlen	; length in C
0015++ 05CE 12          	mov a, c
0016++ 05CF AF 01 00    	cmp a, 1
0017++ 05D2 D0 EC 05    	jleu strrev_end	; check string length. string len must be > 1
0018++ 05D5 7D          	dec a
0019++ 05D6 FD 4E       	mov si, d	; beginning of string
0020++ 05D8 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 05DA 59          	add d, a	; end of string
0022++ 05DB 12          	mov a, c
0023++ 05DC FD 9B       	shr a		; divide by 2
0024++ 05DE 39          	mov c, a	; C now counts the steps
0025++ 05DF             strrev_L0:
0026++ 05DF 32          	mov bl, [d]	; save load right-side char into BL
0027++ 05E0 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 05E1 3E          	mov [d], al	; store left char into right side
0029++ 05E2 1B          	mov al, bl
0030++ 05E3 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 05E4 7E          	dec c
0032++ 05E5 7F          	dec d
0033++ 05E6 C2 00 00    	cmp c, 0
0034++ 05E9 C7 DF 05    	jne strrev_L0
0035++ 05EC             strrev_end:
0036++ 05EC 4C          	popa
0037++ 05ED 09          	ret
0038++ 05EE             	
0039++ 05EE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 05EE             ; strchr
0041++ 05EE             ; search string in D for char in AL
0042++ 05EE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 05EE             strchr:
0044++ 05EE             strchr_L0:
0045++ 05EE 32          	mov bl, [d]
0046++ 05EF C1 00       	cmp bl, 0
0047++ 05F1 C6 FC 05    	je strchr_end
0048++ 05F4 BA          	cmp al, bl
0049++ 05F5 C6 FC 05    	je strchr_end
0050++ 05F8 79          	inc d
0051++ 05F9 0A EE 05    	jmp strchr_L0
0052++ 05FC             strchr_end:
0053++ 05FC 1B          	mov al, bl
0054++ 05FD 09          	ret
0055++ 05FE             
0056++ 05FE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 05FE             ; strstr
0058++ 05FE             ; find sub-string
0059++ 05FE             ; str1 in SI
0060++ 05FE             ; str2 in DI
0061++ 05FE             ; SI points to end of source string
0062++ 05FE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 05FE             strstr:
0064++ 05FE DB          	push al
0065++ 05FF DA          	push d
0066++ 0600 E3          	push di
0067++ 0601             strstr_loop:
0068++ 0601 F3          	cmpsb					; compare a byte of the strings
0069++ 0602 C7 0D 06    	jne strstr_ret
0070++ 0605 FC 00 00    	lea d, [di + 0]
0071++ 0608 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 060A C7 01 06    	jne strstr_loop				; equal chars but not at end
0073++ 060D             strstr_ret:
0074++ 060D F0          	pop di
0075++ 060E E7          	pop d
0076++ 060F E8          	pop al
0077++ 0610 09          	ret
0078++ 0611             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0611             ; length of null terminated string
0080++ 0611             ; result in C
0081++ 0611             ; pointer in D
0082++ 0611             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0611             strlen:
0084++ 0611 DA          	push d
0085++ 0612 38 00 00    	mov c, 0
0086++ 0615             strlen_L1:
0087++ 0615 BD 00       	cmp byte [d], 0
0088++ 0617 C6 1F 06    	je strlen_ret
0089++ 061A 79          	inc d
0090++ 061B 78          	inc c
0091++ 061C 0A 15 06    	jmp strlen_L1
0092++ 061F             strlen_ret:
0093++ 061F E7          	pop d
0094++ 0620 09          	ret
0095++ 0621             
0096++ 0621             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0621             ; STRCMP
0098++ 0621             ; compare two strings
0099++ 0621             ; str1 in SI
0100++ 0621             ; str2 in DI
0101++ 0621             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0621             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0621             strcmp:
0104++ 0621 DB          	push al
0105++ 0622 DA          	push d
0106++ 0623 E3          	push di
0107++ 0624 E2          	push si
0108++ 0625             strcmp_loop:
0109++ 0625 F3          	cmpsb					; compare a byte of the strings
0110++ 0626 C7 31 06    	jne strcmp_ret
0111++ 0629 FB FF FF    	lea d, [si +- 1]
0112++ 062C BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 062E C7 25 06    	jne strcmp_loop				; equal chars but not at end
0114++ 0631             strcmp_ret:
0115++ 0631 EF          	pop si
0116++ 0632 F0          	pop di
0117++ 0633 E7          	pop d
0118++ 0634 E8          	pop al
0119++ 0635 09          	ret
0120++ 0636             
0121++ 0636             
0122++ 0636             ; STRCPY
0123++ 0636             ; copy null terminated string from SI to DI
0124++ 0636             ; source in SI
0125++ 0636             ; destination in DI
0126++ 0636             strcpy:
0127++ 0636 E2          	push si
0128++ 0637 E3          	push di
0129++ 0638 DB          	push al
0130++ 0639             strcpy_L1:
0131++ 0639 F6          	lodsb
0132++ 063A F7          	stosb
0133++ 063B B9 00       	cmp al, 0
0134++ 063D C7 39 06    	jne strcpy_L1
0135++ 0640             strcpy_end:
0136++ 0640 E8          	pop al
0137++ 0641 F0          	pop di
0138++ 0642 EF          	pop si
0139++ 0643 09          	ret
0140++ 0644             
0141++ 0644             ; STRCAT
0142++ 0644             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0644             ; source in SI
0144++ 0644             ; destination in DI
0145++ 0644             strcat:
0146++ 0644 E2          	push si
0147++ 0645 E3          	push di
0148++ 0646 D7          	push a
0149++ 0647 DA          	push d
0150++ 0648 50          	mov a, di
0151++ 0649 3C          	mov d, a
0152++ 064A             strcat_goto_end_L1:
0153++ 064A BD 00       	cmp byte[d], 0
0154++ 064C C6 53 06    	je strcat_start
0155++ 064F 79          	inc d
0156++ 0650 0A 4A 06    	jmp strcat_goto_end_L1
0157++ 0653             strcat_start:
0158++ 0653 FD 50       	mov di, d
0159++ 0655             strcat_L1:
0160++ 0655 F6          	lodsb
0161++ 0656 F7          	stosb
0162++ 0657 B9 00       	cmp al, 0
0163++ 0659 C7 55 06    	jne strcat_L1
0164++ 065C             strcat_end:
0165++ 065C E7          	pop d
0166++ 065D E4          	pop a
0167++ 065E F0          	pop di
0168++ 065F EF          	pop si
0169++ 0660 09          	ret
0005+  0661             
0006+  0661 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  0665 34 35 36 37 
0006+  0669 38 39 41 42 
0006+  066D 43 44 45 46 
0007+  0671 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  0675 1B 5B 48 00 
0008+  0679             
0009+  0679 01 00       table_power:.dw 1
0010+  067B 0A 00       			.dw 10
0011+  067D 64 00       			.dw 100
0012+  067F E8 03       			.dw 1000
0013+  0681 10 27       			.dw 10000
0014+  0683             
0015+  0683             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  0683             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  0683             ; ASCII in BL
0018+  0683             ; result in AL
0019+  0683             ; ascii for F = 0100 0110
0020+  0683             ; ascii for 9 = 0011 1001
0021+  0683             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  0683             hex_ascii_encode:
0023+  0683 1B          	mov al, bl
0024+  0684 93 40       	test al, $40				; test if letter or number
0025+  0686 C7 8C 06    	jnz hex_letter
0026+  0689 87 0F       	and al, $0F				; get number
0027+  068B 09          	ret
0028+  068C             hex_letter:
0029+  068C 87 0F       	and al, $0F				; get letter
0030+  068E 6A 09       	add al, 9
0031+  0690 09          	ret
0032+  0691             
0033+  0691             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  0691             ; ATOI
0035+  0691             ; 2 letter hex string in B
0036+  0691             ; 8bit integer returned in AL
0037+  0691             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0691             atoi:
0039+  0691 D8          	push b
0040+  0692 07 83 06    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  0695 30          	mov bl, bh
0042+  0696 DB          	push al					; save a
0043+  0697 07 83 06    	call hex_ascii_encode
0044+  069A EA          	pop bl	
0045+  069B FD 9E 04    	shl al, 4
0046+  069E 8C          	or al, bl
0047+  069F E5          	pop b
0048+  06A0 09          	ret	
0049+  06A1             
0050+  06A1             
0051+  06A1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  06A1             ; printf
0053+  06A1             ; no need for explanations!
0054+  06A1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  06A1             printf:
0056+  06A1 09          	ret
0057+  06A2             
0058+  06A2             
0059+  06A2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  06A2             ; scanf
0061+  06A2             ; no need for explanations!
0062+  06A2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  06A2             scanf:
0064+  06A2 09          	ret
0065+  06A3             
0066+  06A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  06A3             ; ITOA
0068+  06A3             ; 8bit value in BL
0069+  06A3             ; 2 byte ASCII result in A
0070+  06A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  06A3             itoa:
0072+  06A3 DA          	push d
0073+  06A4 D8          	push b
0074+  06A5 A7 00       	mov bh, 0
0075+  06A7 FD A4 04    	shr bl, 4	
0076+  06AA 74          	mov d, b
0077+  06AB 1F 61 06    	mov al, [d + s_hex_digits]
0078+  06AE 23          	mov ah, al
0079+  06AF             	
0080+  06AF E5          	pop b
0081+  06B0 D8          	push b
0082+  06B1 A7 00       	mov bh, 0
0083+  06B3 FD 87 0F    	and bl, $0F
0084+  06B6 74          	mov d, b
0085+  06B7 1F 61 06    	mov al, [d + s_hex_digits]
0086+  06BA E5          	pop b
0087+  06BB E7          	pop d
0088+  06BC 09          	ret
0089+  06BD             
0090+  06BD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  06BD             ; HEX STRING TO BINARY
0092+  06BD             ; di = destination address
0093+  06BD             ; si = source
0094+  06BD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  06BD             hex_to_int:
0096+  06BD             hex_to_int_L1:
0097+  06BD F6          	lodsb					; load from [SI] to AL
0098+  06BE B9 00       	cmp al, 0				; check if ASCII 0
0099+  06C0 C6 CD 06    	jz hex_to_int_ret
0100+  06C3 36          	mov bh, al
0101+  06C4 F6          	lodsb
0102+  06C5 2F          	mov bl, al
0103+  06C6 07 91 06    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  06C9 F7          	stosb					; store AL to [DI]
0105+  06CA 0A BD 06    	jmp hex_to_int_L1
0106+  06CD             hex_to_int_ret:
0107+  06CD 09          	ret		
0108+  06CE             
0109+  06CE             
0110+  06CE             
0111+  06CE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  06CE             ; GETCHAR
0113+  06CE             ; char in ah
0114+  06CE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  06CE             getchar:
0116+  06CE DB          	push al
0117+  06CF             getchar_retry:
0118+  06CF FD 0C       	sti
0119+  06D1 19 01       	mov al, 1
0120+  06D3 05 03       	syscall sys_io			; receive in AH
0121+  06D5 B9 00       	cmp al, 0			; check if any char was receive
0122+  06D7 C6 CF 06    	je getchar_retry
0123+  06DA E8          	pop al
0124+  06DB 09          	ret
0125+  06DC             
0126+  06DC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  06DC             ; PUTCHAR
0128+  06DC             ; char in ah
0129+  06DC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  06DC             putchar:
0131+  06DC D7          	push a
0132+  06DD 19 00       	mov al, 0
0133+  06DF 05 03       	syscall sys_io			; char in AH
0134+  06E1 E4          	pop a
0135+  06E2 09          	ret
0136+  06E3             
0137+  06E3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  06E3             ;; INPUT A STRING
0139+  06E3             ;; terminates with null
0140+  06E3             ;; pointer in D
0141+  06E3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  06E3             gets:
0143+  06E3 D7          	push a
0144+  06E4 DA          	push d
0145+  06E5             gets_loop:
0146+  06E5 FD 0C       	sti
0147+  06E7 19 01       	mov al, 1
0148+  06E9 05 03       	syscall sys_io			; receive in AH
0149+  06EB B9 00       	cmp al, 0				; check error code (AL)
0150+  06ED C6 E5 06    	je gets_loop			; if no char received, retry
0151+  06F0             
0152+  06F0 76 1B       	cmp ah, 27
0153+  06F2 C6 13 07    	je gets_telnet_escape
0154+  06F5 76 0A       	cmp ah, $0A				; LF
0155+  06F7 C6 6C 07    	je gets_end
0156+  06FA 76 0D       	cmp ah, $0D				; CR
0157+  06FC C6 6C 07    	je gets_end
0158+  06FF 76 5C       	cmp ah, $5C				; '\\'
0159+  0701 C6 43 07    	je gets_escape
0160+  0704             	
0161+  0704 76 08       	cmp ah, $08			; check for backspace
0162+  0706 C6 0F 07    	je gets_backspace
0163+  0709             
0164+  0709 1A          	mov al, ah
0165+  070A 3E          	mov [d], al
0166+  070B 79          	inc d
0167+  070C 0A E5 06    	jmp gets_loop
0168+  070F             gets_backspace:
0169+  070F 7F          	dec d
0170+  0710 0A E5 06    	jmp gets_loop
0171+  0713             gets_telnet_escape:
0172+  0713 FD 0C       	sti
0173+  0715 19 01       	mov al, 1
0174+  0717 05 03       	syscall sys_io				; receive in AH without echo
0175+  0719 B9 00       	cmp al, 0					; check error code (AL)
0176+  071B C6 13 07    	je gets_telnet_escape		; if no char received, retry
0177+  071E 76 5B       	cmp ah, '['
0178+  0720 C7 E5 06    	jne gets_loop
0179+  0723             gets_telnet_escape_phase2:
0180+  0723 FD 0C       	sti
0181+  0725 19 01       	mov al, 1
0182+  0727 05 03       	syscall sys_io					; receive in AH without echo
0183+  0729 B9 00       	cmp al, 0						; check error code (AL)
0184+  072B C6 23 07    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  072E 76 44       	cmp ah, 'D'
0186+  0730 C6 3B 07    	je gets_left_arrow
0187+  0733 76 43       	cmp ah, 'C'
0188+  0735 C6 3F 07    	je gets_right_arrow
0189+  0738 0A E5 06    	jmp gets_loop
0190+  073B             gets_left_arrow:
0191+  073B 7F          	dec d
0192+  073C 0A E5 06    	jmp gets_loop
0193+  073F             gets_right_arrow:
0194+  073F 79          	inc d
0195+  0740 0A E5 06    	jmp gets_loop
0196+  0743             gets_escape:
0197+  0743 FD 0C       	sti
0198+  0745 19 01       	mov al, 1
0199+  0747 05 03       	syscall sys_io			; receive in AH
0200+  0749 B9 00       	cmp al, 0				; check error code (AL)
0201+  074B C6 43 07    	je gets_escape			; if no char received, retry
0202+  074E 76 6E       	cmp ah, 'n'
0203+  0750 C6 5E 07    	je gets_LF
0204+  0753 76 72       	cmp ah, 'r'
0205+  0755 C6 65 07    	je gets_CR
0206+  0758 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  0759 3E          	mov [d], al
0208+  075A 79          	inc d
0209+  075B 0A E5 06    	jmp gets_loop
0210+  075E             gets_LF:
0211+  075E 19 0A       	mov al, $0A
0212+  0760 3E          	mov [d], al
0213+  0761 79          	inc d
0214+  0762 0A E5 06    	jmp gets_loop
0215+  0765             gets_CR:
0216+  0765 19 0D       	mov al, $0D
0217+  0767 3E          	mov [d], al
0218+  0768 79          	inc d
0219+  0769 0A E5 06    	jmp gets_loop
0220+  076C             gets_end:
0221+  076C 19 00       	mov al, 0
0222+  076E 3E          	mov [d], al				; terminate string
0223+  076F E7          	pop d
0224+  0770 E4          	pop a
0225+  0771 09          	ret
0226+  0772             
0227+  0772             
0228+  0772             
0229+  0772             
0230+  0772             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  0772             ;; INPUT TEXT
0232+  0772             ;; terminated with CTRL+D
0233+  0772             ;; pointer in D
0234+  0772             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  0772             gettxt:
0236+  0772 D7          	push a
0237+  0773 DA          	push d
0238+  0774             gettxt_loop:
0239+  0774 19 01       	mov al, 1
0240+  0776 05 03       	syscall sys_io			; receive in AH
0241+  0778 B9 00       	cmp al, 0				; check error code (AL)
0242+  077A C6 74 07    	je gettxt_loop		; if no char received, retry
0243+  077D 76 04       	cmp ah, 4			; EOT
0244+  077F C6 BD 07    	je gettxt_end
0245+  0782 76 08       	cmp ah, $08			; check for backspace
0246+  0784 C6 B9 07    	je gettxt_backspace
0247+  0787 76 5C       	cmp ah, $5C				; '\\'
0248+  0789 C6 92 07    	je gettxt_escape
0249+  078C 1A          	mov al, ah
0250+  078D 3E          	mov [d], al
0251+  078E 79          	inc d
0252+  078F 0A 74 07    	jmp gettxt_loop
0253+  0792             gettxt_escape:
0254+  0792 19 01       	mov al, 1
0255+  0794 05 03       	syscall sys_io			; receive in AH
0256+  0796 B9 00       	cmp al, 0				; check error code (AL)
0257+  0798 C6 92 07    	je gettxt_escape		; if no char received, retry
0258+  079B 76 6E       	cmp ah, 'n'
0259+  079D C6 AB 07    	je gettxt_LF
0260+  07A0 76 72       	cmp ah, 'r'
0261+  07A2 C6 B2 07    	je gettxt_CR
0262+  07A5 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  07A6 3E          	mov [d], al
0264+  07A7 79          	inc d
0265+  07A8 0A 74 07    	jmp gettxt_loop
0266+  07AB             gettxt_LF:
0267+  07AB 19 0A       	mov al, $0A
0268+  07AD 3E          	mov [d], al
0269+  07AE 79          	inc d
0270+  07AF 0A 74 07    	jmp gettxt_loop
0271+  07B2             gettxt_CR:
0272+  07B2 19 0D       	mov al, $0D
0273+  07B4 3E          	mov [d], al
0274+  07B5 79          	inc d
0275+  07B6 0A 74 07    	jmp gettxt_loop
0276+  07B9             gettxt_backspace:
0277+  07B9 7F          	dec d
0278+  07BA 0A 74 07    	jmp gettxt_loop
0279+  07BD             gettxt_end:
0280+  07BD 19 00       	mov al, 0
0281+  07BF 3E          	mov [d], al				; terminate string
0282+  07C0 E7          	pop d
0283+  07C1 E4          	pop a
0284+  07C2 09          	ret
0285+  07C3             
0286+  07C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  07C3             ; PRINT NEW LINE
0288+  07C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  07C3             printnl:
0290+  07C3 D7          	push a
0291+  07C4 10 00 0A    	mov a, $0A00
0292+  07C7 05 03       	syscall sys_io
0293+  07C9 10 00 0D    	mov a, $0D00
0294+  07CC 05 03       	syscall sys_io
0295+  07CE E4          	pop a
0296+  07CF 09          	ret
0297+  07D0             
0298+  07D0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  07D0             ; strtoint
0300+  07D0             ; 4 digit hex string number in d
0301+  07D0             ; integer returned in A
0302+  07D0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  07D0             strtointx:
0304+  07D0 D8          	push b
0305+  07D1 32          	mov bl, [d]
0306+  07D2 37          	mov bh, bl
0307+  07D3 33 01 00    	mov bl, [d + 1]
0308+  07D6 07 91 06    	call atoi				; convert to int in AL
0309+  07D9 23          	mov ah, al				; move to AH
0310+  07DA 33 02 00    	mov bl, [d + 2]
0311+  07DD 37          	mov bh, bl
0312+  07DE 33 03 00    	mov bl, [d + 3]
0313+  07E1 07 91 06    	call atoi				; convert to int in AL
0314+  07E4 E5          	pop b
0315+  07E5 09          	ret
0316+  07E6             
0317+  07E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  07E6             ; strtoint
0319+  07E6             ; 5 digit base10 string number in d
0320+  07E6             ; integer returned in A
0321+  07E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  07E6             strtoint:
0323+  07E6 E2          	push si
0324+  07E7 D8          	push b
0325+  07E8 D9          	push c
0326+  07E9 DA          	push d
0327+  07EA 07 11 06    	call strlen			; get string length in C
0328+  07ED 7E          	dec c
0329+  07EE FD 4E       	mov si, d
0330+  07F0 12          	mov a, c
0331+  07F1 FD 99       	shl a
0332+  07F3 3B 79 06    	mov d, table_power
0333+  07F6 59          	add d, a
0334+  07F7 38 00 00    	mov c, 0
0335+  07FA             strtoint_L0:
0336+  07FA F6          	lodsb			; load ASCII to al
0337+  07FB B9 00       	cmp al, 0
0338+  07FD C6 10 08    	je strtoint_end
0339+  0800 6F 30       	sub al, $30		; make into integer
0340+  0802 22 00       	mov ah, 0
0341+  0804 2A          	mov b, [d]
0342+  0805 AC          	mul a, b			; result in B since it fits in 16bits
0343+  0806 11          	mov a, b
0344+  0807 28          	mov b, c
0345+  0808 54          	add a, b
0346+  0809 39          	mov c, a
0347+  080A 63 02 00    	sub d, 2
0348+  080D 0A FA 07    	jmp strtoint_L0
0349+  0810             strtoint_end:
0350+  0810 12          	mov a, c
0351+  0811 E7          	pop d
0352+  0812 E6          	pop c
0353+  0813 E5          	pop b
0354+  0814 EF          	pop si
0355+  0815 09          	ret
0356+  0816             
0357+  0816             
0358+  0816             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  0816             ; PRINT NULL TERMINATED STRING
0360+  0816             ; pointer in D
0361+  0816             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  0816             puts:
0363+  0816 D7          	push a
0364+  0817 DA          	push d
0365+  0818             puts_L1:
0366+  0818 1E          	mov al, [d]
0367+  0819 B9 00       	cmp al, 0
0368+  081B C6 27 08    	jz puts_END
0369+  081E 23          	mov ah, al
0370+  081F 19 00       	mov al, 0
0371+  0821 05 03       	syscall sys_io
0372+  0823 79          	inc d
0373+  0824 0A 18 08    	jmp puts_L1
0374+  0827             puts_END:
0375+  0827 E7          	pop d
0376+  0828 E4          	pop a
0377+  0829 09          	ret
0378+  082A             
0379+  082A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  082A             ; PRINT N SIZE STRING
0381+  082A             ; pointer in D
0382+  082A             ; size in C
0383+  082A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  082A             putsn:
0385+  082A DB          	push al
0386+  082B DA          	push d
0387+  082C D9          	push c
0388+  082D             putsn_L0:
0389+  082D 1E          	mov al, [d]
0390+  082E 23          	mov ah, al
0391+  082F 19 00       	mov al, 0
0392+  0831 05 03       	syscall sys_io
0393+  0833 79          	inc d
0394+  0834 7E          	dec c	
0395+  0835 C2 00 00    	cmp c, 0
0396+  0838 C7 2D 08    	jne putsn_L0
0397+  083B             putsn_end:
0398+  083B E6          	pop c
0399+  083C E7          	pop d
0400+  083D E8          	pop al
0401+  083E 09          	ret
0402+  083F             
0403+  083F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  083F             ; print 16bit decimal number
0405+  083F             ; input number in A
0406+  083F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  083F             print_u16d:
0408+  083F D7          	push a
0409+  0840 D8          	push b
0410+  0841 26 10 27    	mov b, 10000
0411+  0844 AE          	div a, b			; get 10000 coeff.
0412+  0845 07 6B 08    	call print_number
0413+  0848 11          	mov a, b
0414+  0849 26 E8 03    	mov b, 1000
0415+  084C AE          	div a, b			; get 10000 coeff.
0416+  084D 07 6B 08    	call print_number
0417+  0850 11          	mov a, b
0418+  0851 26 64 00    	mov b, 100
0419+  0854 AE          	div a, b
0420+  0855 07 6B 08    	call print_number
0421+  0858 11          	mov a, b
0422+  0859 26 0A 00    	mov b, 10
0423+  085C AE          	div a, b
0424+  085D 07 6B 08    	call print_number
0425+  0860 11          	mov a, b
0426+  0861 6A 30       	add al, $30
0427+  0863 23          	mov ah, al
0428+  0864 19 00       	mov al, 0
0429+  0866 05 03       	syscall sys_io	; print coeff
0430+  0868 E5          	pop b
0431+  0869 E4          	pop a
0432+  086A 09          	ret
0433+  086B             
0434+  086B             
0435+  086B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  086B             ; if A == 0, print space
0437+  086B             ; else print A
0438+  086B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0439+  086B             print_number:
0440+  086B 6A 30       	add al, $30
0441+  086D 23          	mov ah, al
0442+  086E 07 DC 06    	call putchar
0443+  0871 09          	ret
0444+  0872             
0445+  0872             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0446+  0872             ; PRINT 16BIT HEX INTEGER
0447+  0872             ; integer value in reg B
0448+  0872             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  0872             print_u16x:
0450+  0872 D7          	push a
0451+  0873 D8          	push b
0452+  0874 DD          	push bl
0453+  0875 30          	mov bl, bh
0454+  0876 07 A3 06    	call itoa				; convert bh to char in A
0455+  0879 2F          	mov bl, al				; save al
0456+  087A 19 00       	mov al, 0
0457+  087C 05 03       	syscall sys_io				; display AH
0458+  087E 24          	mov ah, bl				; retrieve al
0459+  087F 19 00       	mov al, 0
0460+  0881 05 03       	syscall sys_io				; display AL
0461+  0883             
0462+  0883 EA          	pop bl
0463+  0884 07 A3 06    	call itoa				; convert bh to char in A
0464+  0887 2F          	mov bl, al				; save al
0465+  0888 19 00       	mov al, 0
0466+  088A 05 03       	syscall sys_io				; display AH
0467+  088C 24          	mov ah, bl				; retrieve al
0468+  088D 19 00       	mov al, 0
0469+  088F 05 03       	syscall sys_io				; display AL
0470+  0891             
0471+  0891 E5          	pop b
0472+  0892 E4          	pop a
0473+  0893 09          	ret
0474+  0894             
0475+  0894             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  0894             ; INPUT 16BIT HEX INTEGER
0477+  0894             ; read 16bit integer into A
0478+  0894             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  0894             scan_u16x:
0480+  0894 F8 10 00    	enter 16
0481+  0897 D8          	push b
0482+  0898 DA          	push d
0483+  0899             
0484+  0899 FA F1 FF    	lea d, [bp + -15]
0485+  089C 07 E3 06    	call gets				; get number
0486+  089F             
0487+  089F 32          	mov bl, [d]
0488+  08A0 37          	mov bh, bl
0489+  08A1 33 01 00    	mov bl, [d + 1]
0490+  08A4 07 91 06    	call atoi				; convert to int in AL
0491+  08A7 23          	mov ah, al				; move to AH
0492+  08A8             
0493+  08A8 33 02 00    	mov bl, [d + 2]
0494+  08AB 37          	mov bh, bl
0495+  08AC 33 03 00    	mov bl, [d + 3]
0496+  08AF 07 91 06    	call atoi				; convert to int in AL
0497+  08B2             
0498+  08B2 E7          	pop d
0499+  08B3 E5          	pop b
0500+  08B4 F9          	leave
0501+  08B5 09          	ret
0502+  08B6             
0503+  08B6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0504+  08B6             ; PRINT 8bit HEX INTEGER
0505+  08B6             ; integer value in reg bl
0506+  08B6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  08B6             print_u8x:
0508+  08B6 D7          	push a
0509+  08B7 DD          	push bl
0510+  08B8             
0511+  08B8 07 A3 06    	call itoa				; convert bl to char in A
0512+  08BB 2F          	mov bl, al				; save al
0513+  08BC 19 00       	mov al, 0
0514+  08BE 05 03       	syscall sys_io				; display AH
0515+  08C0 24          	mov ah, bl				; retrieve al
0516+  08C1 19 00       	mov al, 0
0517+  08C3 05 03       	syscall sys_io				; display AL
0518+  08C5             
0519+  08C5 EA          	pop bl
0520+  08C6 E4          	pop a
0521+  08C7 09          	ret
0522+  08C8             
0523+  08C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0524+  08C8             ; print 8bit decimal unsigned number
0525+  08C8             ; input number in AL
0526+  08C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  08C8             print_u8d:
0528+  08C8 D7          	push a
0529+  08C9 D8          	push b
0530+  08CA             
0531+  08CA 22 00       	mov ah, 0
0532+  08CC 26 64 00    	mov b, 100
0533+  08CF AE          	div a, b
0534+  08D0 D8          	push b			; save remainder
0535+  08D1 B9 00       	cmp al, 0
0536+  08D3 C6 DD 08    	je skip100
0537+  08D6 6A 30       	add al, $30
0538+  08D8 23          	mov ah, al
0539+  08D9 19 00       	mov al, 0
0540+  08DB 05 03       	syscall sys_io	; print coeff
0541+  08DD             skip100:
0542+  08DD E4          	pop a
0543+  08DE 22 00       	mov ah, 0
0544+  08E0 26 0A 00    	mov b, 10
0545+  08E3 AE          	div a, b
0546+  08E4 D8          	push b			; save remainder
0547+  08E5 B9 00       	cmp al, 0
0548+  08E7 C6 F1 08    	je skip10
0549+  08EA 6A 30       	add al, $30
0550+  08EC 23          	mov ah, al
0551+  08ED 19 00       	mov al, 0
0552+  08EF 05 03       	syscall sys_io	; print coeff
0553+  08F1             skip10:
0554+  08F1 E4          	pop a
0555+  08F2 1B          	mov al, bl
0556+  08F3 6A 30       	add al, $30
0557+  08F5 23          	mov ah, al
0558+  08F6 19 00       	mov al, 0
0559+  08F8 05 03       	syscall sys_io	; print coeff
0560+  08FA E5          	pop b
0561+  08FB E4          	pop a
0562+  08FC 09          	ret
0563+  08FD             
0564+  08FD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0565+  08FD             ; INPUT 8BIT HEX INTEGER
0566+  08FD             ; read 8bit integer into AL
0567+  08FD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  08FD             scan_u8x:
0569+  08FD F8 04 00    	enter 4
0570+  0900 D8          	push b
0571+  0901 DA          	push d
0572+  0902             
0573+  0902 FA FD FF    	lea d, [bp + -3]
0574+  0905 07 E3 06    	call gets				; get number
0575+  0908             
0576+  0908 32          	mov bl, [d]
0577+  0909 37          	mov bh, bl
0578+  090A 33 01 00    	mov bl, [d + 1]
0579+  090D 07 91 06    	call atoi				; convert to int in AL
0580+  0910             
0581+  0910 E7          	pop d
0582+  0911 E5          	pop b
0583+  0912 F9          	leave
0584+  0913 09          	ret
0585+  0914             
0586+  0914             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  0914             ; input decimal number
0588+  0914             ; result in A
0589+  0914             ; 655'\0'
0590+  0914             ; low--------high
0591+  0914             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0592+  0914             scan_u16d:
0593+  0914 F8 08 00    	enter 8
0594+  0917 E2          	push si
0595+  0918 D8          	push b
0596+  0919 D9          	push c
0597+  091A DA          	push d
0598+  091B FA F9 FF    	lea d, [bp +- 7]
0599+  091E 07 E3 06    	call gets
0600+  0921 07 11 06    	call strlen			; get string length in C
0601+  0924 7E          	dec c
0602+  0925 FD 4E       	mov si, d
0603+  0927 12          	mov a, c
0604+  0928 FD 99       	shl a
0605+  092A 3B 79 06    	mov d, table_power
0606+  092D 59          	add d, a
0607+  092E 38 00 00    	mov c, 0
0608+  0931             mul_loop:
0609+  0931 F6          	lodsb			; load ASCII to al
0610+  0932 B9 00       	cmp al, 0
0611+  0934 C6 47 09    	je mul_exit
0612+  0937 6F 30       	sub al, $30		; make into integer
0613+  0939 22 00       	mov ah, 0
0614+  093B 2A          	mov b, [d]
0615+  093C AC          	mul a, b			; result in B since it fits in 16bits
0616+  093D 11          	mov a, b
0617+  093E 28          	mov b, c
0618+  093F 54          	add a, b
0619+  0940 39          	mov c, a
0620+  0941 63 02 00    	sub d, 2
0621+  0944 0A 31 09    	jmp mul_loop
0622+  0947             mul_exit:
0623+  0947 12          	mov a, c
0624+  0948 E7          	pop d
0625+  0949 E6          	pop c
0626+  094A E5          	pop b
0627+  094B EF          	pop si
0628+  094C F9          	leave
0629+  094D 09          	ret
0303   094E             ; --- END INCLUDE BLOCK
0304   094E             
0305   094E             
0306   094E             .end
tasm: Number of errors = 0
