0001   0000             ; --- FILENAME: strcat.c
0002   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0400             .org PROC_TEXT_ORG
0004   0400             
0005   0400             ; --- BEGIN TEXT BLOCK
0006   0400             main:
0007   0400 D2            push bp
0008   0401 9B            mov bp, sp
0009   0402 29 64 05      mov b, [s1]
0010   0405 FD AB         swp b
0011   0407 D8            push b
0012   0408 07 1D 04      call _strlen
0013   040B 51 02 00      add sp, 2
0014   040E FD AB         swp b
0015   0410 D8            push b
0016   0411 07 17 05      call printn
0017   0414 51 02 00      add sp, 2
0018   0417 26 00 00      mov b, 0
0019   041A F9            leave
0020   041B 05 0B         syscall sys_terminate_proc
0021   041D             _strlen:
0022   041D D2            push bp
0023   041E 9B            mov bp, sp
0024   041F 52 01 00      sub sp, 1 ; length
0025   0422 26 00 00      mov b, 0
0026   0425 DB            push al
0027   0426 1B            mov al, bl
0028   0427 40 00 00      mov [bp + 0], al ; length
0029   042A E8            pop al
0030   042B             _while1_cond:
0031   042B FA 05 00      lea d, [bp + 5] ; str
0032   042E 2A            mov b, [d]
0033   042F D7            push a
0034   0430 11            mov a, b
0035   0431 34 00 00      mov bl, [bp + 0] ; length
0036   0434 54            add a, b
0037   0435 27            mov b, a
0038   0436 E4            pop a
0039   0437 74            mov d, b
0040   0438 D7            push a
0041   0439 11            mov a, b
0042   043A 26 00 00      mov b, 0
0043   043D B0            cmp a, b
0044   043E 0E            lodflgs
0045   043F 87 01         and al, %00000001
0046   0441 8F 01         xor al, %00000001 ; !=
0047   0443 B9 00         cmp al, 0
0048   0445 0E            lodflgs
0049   0446 96            not al
0050   0447 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0051   0449 22 00         mov ah, 0
0052   044B 27            mov b, a
0053   044C E4            pop a
0054   044D C0 00 00      cmp b, 0
0055   0450 C6 61 04      je _while1_exit
0056   0453             _while1_block:
0057   0453 34 00 00      mov bl, [bp + 0] ; length
0058   0456 6C 01         add bl, 1
0059   0458 DB            push al
0060   0459 1B            mov al, bl
0061   045A 40 00 00      mov [bp + 0], al ; length
0062   045D E8            pop al
0063   045E 0A 2B 04      jmp _while1_cond
0064   0461             _while1_exit:
0065   0461 34 00 00      mov bl, [bp + 0] ; length
0066   0464 F9            leave
0067   0465 09            ret
0068   0466             _strcat:
0069   0466 D2            push bp
0070   0467 9B            mov bp, sp
0071   0468 52 02 00      sub sp, 2 ; dest_len
0072   046B 52 02 00      sub sp, 2 ; i
0073   046E FA 07 00      lea d, [bp + 7] ; dest
0074   0471 2A            mov b, [d]
0075   0472 FD AB         swp b
0076   0474 D8            push b
0077   0475 07 1D 04      call _strlen
0078   0478 51 02 00      add sp, 2
0079   047B D7            push a
0080   047C 11            mov a, b
0081   047D 45 FF FF      mov [bp + -1], a ; dest_len
0082   0480 E4            pop a
0083   0481             _for2_init:
0084   0481 26 00 00      mov b, 0
0085   0484 D7            push a
0086   0485 11            mov a, b
0087   0486 45 FD FF      mov [bp + -3], a ; i
0088   0489 E4            pop a
0089   048A             _for2_cond:
0090   048A FA 05 00      lea d, [bp + 5] ; src
0091   048D 2A            mov b, [d]
0092   048E D7            push a
0093   048F 11            mov a, b
0094   0490 2C FD FF      mov b, [bp + -3] ; i
0095   0493 54            add a, b
0096   0494 27            mov b, a
0097   0495 E4            pop a
0098   0496 74            mov d, b
0099   0497 D7            push a
0100   0498 11            mov a, b
0101   0499 26 00 00      mov b, 0
0102   049C B0            cmp a, b
0103   049D 0E            lodflgs
0104   049E 87 01         and al, %00000001
0105   04A0 8F 01         xor al, %00000001 ; !=
0106   04A2 B9 00         cmp al, 0
0107   04A4 0E            lodflgs
0108   04A5 96            not al
0109   04A6 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0110   04A8 22 00         mov ah, 0
0111   04AA 27            mov b, a
0112   04AB E4            pop a
0113   04AC C0 00 00      cmp b, 0
0114   04AF C6 E2 04      je _for2_exit
0115   04B2             _for2_block:
0116   04B2 FA 07 00      lea d, [bp + 7] ; dest
0117   04B5 2A            mov b, [d]
0118   04B6 D7            push a
0119   04B7 11            mov a, b
0120   04B8 2C FF FF      mov b, [bp + -1] ; dest_len
0121   04BB 54            add a, b
0122   04BC 27            mov b, a
0123   04BD 11            mov a, b
0124   04BE 2C FD FF      mov b, [bp + -3] ; i
0125   04C1 54            add a, b
0126   04C2 27            mov b, a
0127   04C3 E4            pop a
0128   04C4 74            mov d, b
0129   04C5 FA 05 00      lea d, [bp + 5] ; src
0130   04C8 2A            mov b, [d]
0131   04C9 D7            push a
0132   04CA 11            mov a, b
0133   04CB 2C FD FF      mov b, [bp + -3] ; i
0134   04CE 54            add a, b
0135   04CF 27            mov b, a
0136   04D0 E4            pop a
0137   04D1 74            mov d, b
0138   04D2 11            mov a, b
0139   04D3 43            mov [d], a
0140   04D4             _for2_update:
0141   04D4 2C FD FF      mov b, [bp + -3] ; i
0142   04D7 FD 77         inc b
0143   04D9 D7            push a
0144   04DA 11            mov a, b
0145   04DB 45 FD FF      mov [bp + -3], a ; i
0146   04DE E4            pop a
0147   04DF 0A 8A 04      jmp _for2_cond
0148   04E2             _for2_exit:
0149   04E2 FA 07 00      lea d, [bp + 7] ; dest
0150   04E5 2A            mov b, [d]
0151   04E6 D7            push a
0152   04E7 11            mov a, b
0153   04E8 2C FF FF      mov b, [bp + -1] ; dest_len
0154   04EB 54            add a, b
0155   04EC 27            mov b, a
0156   04ED 11            mov a, b
0157   04EE 2C FD FF      mov b, [bp + -3] ; i
0158   04F1 54            add a, b
0159   04F2 27            mov b, a
0160   04F3 E4            pop a
0161   04F4 74            mov d, b
0162   04F5 26 00 00      mov b, 0
0163   04F8 11            mov a, b
0164   04F9 43            mov [d], a
0165   04FA FA 07 00      lea d, [bp + 7] ; dest
0166   04FD 2A            mov b, [d]
0167   04FE F9            leave
0168   04FF 09            ret
0169   0500             scann:
0170   0500 D2            push bp
0171   0501 9B            mov bp, sp
0172   0502 52 02 00      sub sp, 2 ; m
0173   0505             
0174   0505             ; --- BEGIN INLINE ASM BLOCK
0175   0505 07 C6 08      call scan_u16d
0176   0508 45 FF FF      mov [bp + -1], a
0177   050B             ; --- END INLINE ASM BLOCK
0178   050B             
0179   050B FA 05 00      lea d, [bp + 5] ; n
0180   050E 2A            mov b, [d]
0181   050F 74            mov d, b
0182   0510 2C FF FF      mov b, [bp + -1] ; m
0183   0513 11            mov a, b
0184   0514 43            mov [d], a
0185   0515 F9            leave
0186   0516 09            ret
0187   0517             printn:
0188   0517 D2            push bp
0189   0518 9B            mov bp, sp
0190   0519             
0191   0519             ; --- BEGIN INLINE ASM BLOCK
0192   0519 17 05 00      mov a, [bp + 5]
0193   051C 07 F1 07      call print_u16d
0194   051F             ; --- END INLINE ASM BLOCK
0195   051F             
0196   051F F9            leave
0197   0520 09            ret
0198   0521             print:
0199   0521 D2            push bp
0200   0522 9B            mov bp, sp
0201   0523             
0202   0523             ; --- BEGIN INLINE ASM BLOCK
0203   0523 17 05 00      mov a, [bp + 5]
0204   0526 3C            mov d, a
0205   0527 07 C8 07      call puts
0206   052A             ; --- END INLINE ASM BLOCK
0207   052A             
0208   052A F9            leave
0209   052B 09            ret
0210   052C             ; --- END TEXT BLOCK
0211   052C             
0212   052C             ; --- BEGIN DATA BLOCK
0213   052C             s1_data: 
0214   052C 48 00 65 00 .dw 'H', 'e', 'l', 'l', 'o', 0,
0214   0530 6C 00 6C 00 
0214   0534 6F 00 00 00 
0215   0538 00 00 00 00 .fill 44, 0
0215   053C 00 00 00 00 
0215   0540 00 00 00 00 
0215   0544 00 00 00 00 
0215   0548 00 00 00 00 
0215   054C 00 00 00 00 
0215   0550 00 00 00 00 
0215   0554 00 00 00 00 
0215   0558 00 00 00 00 
0215   055C 00 00 00 00 
0215   0560 00 00 00 00 
0216   0564 2C 05       s1: .dw s1_data
0217   0566 2E 20 4D 79 s2_data: .db ". My name is Sol-1.", 0
0217   056A 20 6E 61 6D 
0217   056E 65 20 69 73 
0217   0572 20 53 6F 6C 
0217   0576 2D 31 2E 00 
0218   057A 66 05       s2: .dw s2_data
0219   057C             ; --- END DATA BLOCK
0220   057C             
0221   057C             ; --- BEGIN INCLUDE BLOCK
0222   057C             .include "lib/stdio.asm"
0001+  057C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  057C             ; stdio.s
0003+  057C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  057C             .include "lib/string.asm"
0001++ 057C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 057C             ; string.s
0003++ 057C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 057C             
0005++ 057C             
0006++ 057C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 057C             ; strrev
0008++ 057C             ; reverse a string
0009++ 057C             ; D = string address
0010++ 057C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 057C             ; 01234
0012++ 057C             strrev:
0013++ 057C 4B          	pusha
0014++ 057D 07 C3 05    	call strlen	; length in C
0015++ 0580 12          	mov a, c
0016++ 0581 AF 01 00    	cmp a, 1
0017++ 0584 D0 9E 05    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0587 7D          	dec a
0019++ 0588 FD 4E       	mov si, d	; beginning of string
0020++ 058A FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 058C 59          	add d, a	; end of string
0022++ 058D 12          	mov a, c
0023++ 058E FD 9B       	shr a		; divide by 2
0024++ 0590 39          	mov c, a	; C now counts the steps
0025++ 0591             strrev_L0:
0026++ 0591 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0592 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0593 3E          	mov [d], al	; store left char into right side
0029++ 0594 1B          	mov al, bl
0030++ 0595 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0596 7E          	dec c
0032++ 0597 7F          	dec d
0033++ 0598 C2 00 00    	cmp c, 0
0034++ 059B C7 91 05    	jne strrev_L0
0035++ 059E             strrev_end:
0036++ 059E 4C          	popa
0037++ 059F 09          	ret
0038++ 05A0             	
0039++ 05A0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 05A0             ; strchr
0041++ 05A0             ; search string in D for char in AL
0042++ 05A0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 05A0             strchr:
0044++ 05A0             strchr_L0:
0045++ 05A0 32          	mov bl, [d]
0046++ 05A1 C1 00       	cmp bl, 0
0047++ 05A3 C6 AE 05    	je strchr_end
0048++ 05A6 BA          	cmp al, bl
0049++ 05A7 C6 AE 05    	je strchr_end
0050++ 05AA 79          	inc d
0051++ 05AB 0A A0 05    	jmp strchr_L0
0052++ 05AE             strchr_end:
0053++ 05AE 1B          	mov al, bl
0054++ 05AF 09          	ret
0055++ 05B0             
0056++ 05B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 05B0             ; strstr
0058++ 05B0             ; find sub-string
0059++ 05B0             ; str1 in SI
0060++ 05B0             ; str2 in DI
0061++ 05B0             ; SI points to end of source string
0062++ 05B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 05B0             strstr:
0064++ 05B0 DB          	push al
0065++ 05B1 DA          	push d
0066++ 05B2 E3          	push di
0067++ 05B3             strstr_loop:
0068++ 05B3 F3          	cmpsb					; compare a byte of the strings
0069++ 05B4 C7 BF 05    	jne strstr_ret
0070++ 05B7 FC 00 00    	lea d, [di + 0]
0071++ 05BA BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 05BC C7 B3 05    	jne strstr_loop				; equal chars but not at end
0073++ 05BF             strstr_ret:
0074++ 05BF F0          	pop di
0075++ 05C0 E7          	pop d
0076++ 05C1 E8          	pop al
0077++ 05C2 09          	ret
0078++ 05C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 05C3             ; length of null terminated string
0080++ 05C3             ; result in C
0081++ 05C3             ; pointer in D
0082++ 05C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 05C3             strlen:
0084++ 05C3 DA          	push d
0085++ 05C4 38 00 00    	mov c, 0
0086++ 05C7             strlen_L1:
0087++ 05C7 BD 00       	cmp byte [d], 0
0088++ 05C9 C6 D1 05    	je strlen_ret
0089++ 05CC 79          	inc d
0090++ 05CD 78          	inc c
0091++ 05CE 0A C7 05    	jmp strlen_L1
0092++ 05D1             strlen_ret:
0093++ 05D1 E7          	pop d
0094++ 05D2 09          	ret
0095++ 05D3             
0096++ 05D3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 05D3             ; STRCMP
0098++ 05D3             ; compare two strings
0099++ 05D3             ; str1 in SI
0100++ 05D3             ; str2 in DI
0101++ 05D3             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 05D3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 05D3             strcmp:
0104++ 05D3 DB          	push al
0105++ 05D4 DA          	push d
0106++ 05D5 E3          	push di
0107++ 05D6 E2          	push si
0108++ 05D7             strcmp_loop:
0109++ 05D7 F3          	cmpsb					; compare a byte of the strings
0110++ 05D8 C7 E3 05    	jne strcmp_ret
0111++ 05DB FB FF FF    	lea d, [si +- 1]
0112++ 05DE BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 05E0 C7 D7 05    	jne strcmp_loop				; equal chars but not at end
0114++ 05E3             strcmp_ret:
0115++ 05E3 EF          	pop si
0116++ 05E4 F0          	pop di
0117++ 05E5 E7          	pop d
0118++ 05E6 E8          	pop al
0119++ 05E7 09          	ret
0120++ 05E8             
0121++ 05E8             
0122++ 05E8             ; STRCPY
0123++ 05E8             ; copy null terminated string from SI to DI
0124++ 05E8             ; source in SI
0125++ 05E8             ; destination in DI
0126++ 05E8             strcpy:
0127++ 05E8 E2          	push si
0128++ 05E9 E3          	push di
0129++ 05EA DB          	push al
0130++ 05EB             strcpy_L1:
0131++ 05EB F6          	lodsb
0132++ 05EC F7          	stosb
0133++ 05ED B9 00       	cmp al, 0
0134++ 05EF C7 EB 05    	jne strcpy_L1
0135++ 05F2             strcpy_end:
0136++ 05F2 E8          	pop al
0137++ 05F3 F0          	pop di
0138++ 05F4 EF          	pop si
0139++ 05F5 09          	ret
0140++ 05F6             
0141++ 05F6             ; STRCAT
0142++ 05F6             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 05F6             ; source in SI
0144++ 05F6             ; destination in DI
0145++ 05F6             strcat:
0146++ 05F6 E2          	push si
0147++ 05F7 E3          	push di
0148++ 05F8 D7          	push a
0149++ 05F9 DA          	push d
0150++ 05FA 50          	mov a, di
0151++ 05FB 3C          	mov d, a
0152++ 05FC             strcat_goto_end_L1:
0153++ 05FC BD 00       	cmp byte[d], 0
0154++ 05FE C6 05 06    	je strcat_start
0155++ 0601 79          	inc d
0156++ 0602 0A FC 05    	jmp strcat_goto_end_L1
0157++ 0605             strcat_start:
0158++ 0605 FD 50       	mov di, d
0159++ 0607             strcat_L1:
0160++ 0607 F6          	lodsb
0161++ 0608 F7          	stosb
0162++ 0609 B9 00       	cmp al, 0
0163++ 060B C7 07 06    	jne strcat_L1
0164++ 060E             strcat_end:
0165++ 060E E7          	pop d
0166++ 060F E4          	pop a
0167++ 0610 F0          	pop di
0168++ 0611 EF          	pop si
0169++ 0612 09          	ret
0005+  0613             
0006+  0613 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  0617 34 35 36 37 
0006+  061B 38 39 41 42 
0006+  061F 43 44 45 46 
0007+  0623 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  0627 1B 5B 48 00 
0008+  062B             
0009+  062B 01 00       table_power:.dw 1
0010+  062D 0A 00       			.dw 10
0011+  062F 64 00       			.dw 100
0012+  0631 E8 03       			.dw 1000
0013+  0633 10 27       			.dw 10000
0014+  0635             
0015+  0635             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  0635             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  0635             ; ASCII in BL
0018+  0635             ; result in AL
0019+  0635             ; ascii for F = 0100 0110
0020+  0635             ; ascii for 9 = 0011 1001
0021+  0635             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  0635             hex_ascii_encode:
0023+  0635 1B          	mov al, bl
0024+  0636 93 40       	test al, $40				; test if letter or number
0025+  0638 C7 3E 06    	jnz hex_letter
0026+  063B 87 0F       	and al, $0F				; get number
0027+  063D 09          	ret
0028+  063E             hex_letter:
0029+  063E 87 0F       	and al, $0F				; get letter
0030+  0640 6A 09       	add al, 9
0031+  0642 09          	ret
0032+  0643             
0033+  0643             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  0643             ; ATOI
0035+  0643             ; 2 letter hex string in B
0036+  0643             ; 8bit integer returned in AL
0037+  0643             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0643             atoi:
0039+  0643 D8          	push b
0040+  0644 07 35 06    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  0647 30          	mov bl, bh
0042+  0648 DB          	push al					; save a
0043+  0649 07 35 06    	call hex_ascii_encode
0044+  064C EA          	pop bl	
0045+  064D FD 9E 04    	shl al, 4
0046+  0650 8C          	or al, bl
0047+  0651 E5          	pop b
0048+  0652 09          	ret	
0049+  0653             
0050+  0653             
0051+  0653             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  0653             ; printf
0053+  0653             ; no need for explanations!
0054+  0653             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0653             printf:
0056+  0653 09          	ret
0057+  0654             
0058+  0654             
0059+  0654             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  0654             ; scanf
0061+  0654             ; no need for explanations!
0062+  0654             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  0654             scanf:
0064+  0654 09          	ret
0065+  0655             
0066+  0655             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  0655             ; ITOA
0068+  0655             ; 8bit value in BL
0069+  0655             ; 2 byte ASCII result in A
0070+  0655             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  0655             itoa:
0072+  0655 DA          	push d
0073+  0656 D8          	push b
0074+  0657 A7 00       	mov bh, 0
0075+  0659 FD A4 04    	shr bl, 4	
0076+  065C 74          	mov d, b
0077+  065D 1F 13 06    	mov al, [d + s_hex_digits]
0078+  0660 23          	mov ah, al
0079+  0661             	
0080+  0661 E5          	pop b
0081+  0662 D8          	push b
0082+  0663 A7 00       	mov bh, 0
0083+  0665 FD 87 0F    	and bl, $0F
0084+  0668 74          	mov d, b
0085+  0669 1F 13 06    	mov al, [d + s_hex_digits]
0086+  066C E5          	pop b
0087+  066D E7          	pop d
0088+  066E 09          	ret
0089+  066F             
0090+  066F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  066F             ; HEX STRING TO BINARY
0092+  066F             ; di = destination address
0093+  066F             ; si = source
0094+  066F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  066F             hex_to_int:
0096+  066F             hex_to_int_L1:
0097+  066F F6          	lodsb					; load from [SI] to AL
0098+  0670 B9 00       	cmp al, 0				; check if ASCII 0
0099+  0672 C6 7F 06    	jz hex_to_int_ret
0100+  0675 36          	mov bh, al
0101+  0676 F6          	lodsb
0102+  0677 2F          	mov bl, al
0103+  0678 07 43 06    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  067B F7          	stosb					; store AL to [DI]
0105+  067C 0A 6F 06    	jmp hex_to_int_L1
0106+  067F             hex_to_int_ret:
0107+  067F 09          	ret		
0108+  0680             
0109+  0680             
0110+  0680             
0111+  0680             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  0680             ; GETCHAR
0113+  0680             ; char in ah
0114+  0680             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  0680             getchar:
0116+  0680 DB          	push al
0117+  0681             getchar_retry:
0118+  0681 FD 0C       	sti
0119+  0683 19 01       	mov al, 1
0120+  0685 05 03       	syscall sys_io			; receive in AH
0121+  0687 B9 00       	cmp al, 0			; check if any char was receive
0122+  0689 C6 81 06    	je getchar_retry
0123+  068C E8          	pop al
0124+  068D 09          	ret
0125+  068E             
0126+  068E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  068E             ; PUTCHAR
0128+  068E             ; char in ah
0129+  068E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  068E             putchar:
0131+  068E D7          	push a
0132+  068F 19 00       	mov al, 0
0133+  0691 05 03       	syscall sys_io			; char in AH
0134+  0693 E4          	pop a
0135+  0694 09          	ret
0136+  0695             
0137+  0695             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  0695             ;; INPUT A STRING
0139+  0695             ;; terminates with null
0140+  0695             ;; pointer in D
0141+  0695             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  0695             gets:
0143+  0695 D7          	push a
0144+  0696 DA          	push d
0145+  0697             gets_loop:
0146+  0697 FD 0C       	sti
0147+  0699 19 01       	mov al, 1
0148+  069B 05 03       	syscall sys_io			; receive in AH
0149+  069D B9 00       	cmp al, 0				; check error code (AL)
0150+  069F C6 97 06    	je gets_loop			; if no char received, retry
0151+  06A2             
0152+  06A2 76 1B       	cmp ah, 27
0153+  06A4 C6 C5 06    	je gets_telnet_escape
0154+  06A7 76 0A       	cmp ah, $0A				; LF
0155+  06A9 C6 1E 07    	je gets_end
0156+  06AC 76 0D       	cmp ah, $0D				; CR
0157+  06AE C6 1E 07    	je gets_end
0158+  06B1 76 5C       	cmp ah, $5C				; '\\'
0159+  06B3 C6 F5 06    	je gets_escape
0160+  06B6             	
0161+  06B6 76 08       	cmp ah, $08			; check for backspace
0162+  06B8 C6 C1 06    	je gets_backspace
0163+  06BB             
0164+  06BB 1A          	mov al, ah
0165+  06BC 3E          	mov [d], al
0166+  06BD 79          	inc d
0167+  06BE 0A 97 06    	jmp gets_loop
0168+  06C1             gets_backspace:
0169+  06C1 7F          	dec d
0170+  06C2 0A 97 06    	jmp gets_loop
0171+  06C5             gets_telnet_escape:
0172+  06C5 FD 0C       	sti
0173+  06C7 19 01       	mov al, 1
0174+  06C9 05 03       	syscall sys_io				; receive in AH without echo
0175+  06CB B9 00       	cmp al, 0					; check error code (AL)
0176+  06CD C6 C5 06    	je gets_telnet_escape		; if no char received, retry
0177+  06D0 76 5B       	cmp ah, '['
0178+  06D2 C7 97 06    	jne gets_loop
0179+  06D5             gets_telnet_escape_phase2:
0180+  06D5 FD 0C       	sti
0181+  06D7 19 01       	mov al, 1
0182+  06D9 05 03       	syscall sys_io					; receive in AH without echo
0183+  06DB B9 00       	cmp al, 0						; check error code (AL)
0184+  06DD C6 D5 06    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  06E0 76 44       	cmp ah, 'D'
0186+  06E2 C6 ED 06    	je gets_left_arrow
0187+  06E5 76 43       	cmp ah, 'C'
0188+  06E7 C6 F1 06    	je gets_right_arrow
0189+  06EA 0A 97 06    	jmp gets_loop
0190+  06ED             gets_left_arrow:
0191+  06ED 7F          	dec d
0192+  06EE 0A 97 06    	jmp gets_loop
0193+  06F1             gets_right_arrow:
0194+  06F1 79          	inc d
0195+  06F2 0A 97 06    	jmp gets_loop
0196+  06F5             gets_escape:
0197+  06F5 FD 0C       	sti
0198+  06F7 19 01       	mov al, 1
0199+  06F9 05 03       	syscall sys_io			; receive in AH
0200+  06FB B9 00       	cmp al, 0				; check error code (AL)
0201+  06FD C6 F5 06    	je gets_escape			; if no char received, retry
0202+  0700 76 6E       	cmp ah, 'n'
0203+  0702 C6 10 07    	je gets_LF
0204+  0705 76 72       	cmp ah, 'r'
0205+  0707 C6 17 07    	je gets_CR
0206+  070A 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  070B 3E          	mov [d], al
0208+  070C 79          	inc d
0209+  070D 0A 97 06    	jmp gets_loop
0210+  0710             gets_LF:
0211+  0710 19 0A       	mov al, $0A
0212+  0712 3E          	mov [d], al
0213+  0713 79          	inc d
0214+  0714 0A 97 06    	jmp gets_loop
0215+  0717             gets_CR:
0216+  0717 19 0D       	mov al, $0D
0217+  0719 3E          	mov [d], al
0218+  071A 79          	inc d
0219+  071B 0A 97 06    	jmp gets_loop
0220+  071E             gets_end:
0221+  071E 19 00       	mov al, 0
0222+  0720 3E          	mov [d], al				; terminate string
0223+  0721 E7          	pop d
0224+  0722 E4          	pop a
0225+  0723 09          	ret
0226+  0724             
0227+  0724             
0228+  0724             
0229+  0724             
0230+  0724             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  0724             ;; INPUT TEXT
0232+  0724             ;; terminated with CTRL+D
0233+  0724             ;; pointer in D
0234+  0724             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  0724             gettxt:
0236+  0724 D7          	push a
0237+  0725 DA          	push d
0238+  0726             gettxt_loop:
0239+  0726 19 01       	mov al, 1
0240+  0728 05 03       	syscall sys_io			; receive in AH
0241+  072A B9 00       	cmp al, 0				; check error code (AL)
0242+  072C C6 26 07    	je gettxt_loop		; if no char received, retry
0243+  072F 76 04       	cmp ah, 4			; EOT
0244+  0731 C6 6F 07    	je gettxt_end
0245+  0734 76 08       	cmp ah, $08			; check for backspace
0246+  0736 C6 6B 07    	je gettxt_backspace
0247+  0739 76 5C       	cmp ah, $5C				; '\\'
0248+  073B C6 44 07    	je gettxt_escape
0249+  073E 1A          	mov al, ah
0250+  073F 3E          	mov [d], al
0251+  0740 79          	inc d
0252+  0741 0A 26 07    	jmp gettxt_loop
0253+  0744             gettxt_escape:
0254+  0744 19 01       	mov al, 1
0255+  0746 05 03       	syscall sys_io			; receive in AH
0256+  0748 B9 00       	cmp al, 0				; check error code (AL)
0257+  074A C6 44 07    	je gettxt_escape		; if no char received, retry
0258+  074D 76 6E       	cmp ah, 'n'
0259+  074F C6 5D 07    	je gettxt_LF
0260+  0752 76 72       	cmp ah, 'r'
0261+  0754 C6 64 07    	je gettxt_CR
0262+  0757 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  0758 3E          	mov [d], al
0264+  0759 79          	inc d
0265+  075A 0A 26 07    	jmp gettxt_loop
0266+  075D             gettxt_LF:
0267+  075D 19 0A       	mov al, $0A
0268+  075F 3E          	mov [d], al
0269+  0760 79          	inc d
0270+  0761 0A 26 07    	jmp gettxt_loop
0271+  0764             gettxt_CR:
0272+  0764 19 0D       	mov al, $0D
0273+  0766 3E          	mov [d], al
0274+  0767 79          	inc d
0275+  0768 0A 26 07    	jmp gettxt_loop
0276+  076B             gettxt_backspace:
0277+  076B 7F          	dec d
0278+  076C 0A 26 07    	jmp gettxt_loop
0279+  076F             gettxt_end:
0280+  076F 19 00       	mov al, 0
0281+  0771 3E          	mov [d], al				; terminate string
0282+  0772 E7          	pop d
0283+  0773 E4          	pop a
0284+  0774 09          	ret
0285+  0775             
0286+  0775             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  0775             ; PRINT NEW LINE
0288+  0775             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  0775             printnl:
0290+  0775 D7          	push a
0291+  0776 10 00 0A    	mov a, $0A00
0292+  0779 05 03       	syscall sys_io
0293+  077B 10 00 0D    	mov a, $0D00
0294+  077E 05 03       	syscall sys_io
0295+  0780 E4          	pop a
0296+  0781 09          	ret
0297+  0782             
0298+  0782             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  0782             ; strtoint
0300+  0782             ; 4 digit hex string number in d
0301+  0782             ; integer returned in A
0302+  0782             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  0782             strtointx:
0304+  0782 D8          	push b
0305+  0783 32          	mov bl, [d]
0306+  0784 37          	mov bh, bl
0307+  0785 33 01 00    	mov bl, [d + 1]
0308+  0788 07 43 06    	call atoi				; convert to int in AL
0309+  078B 23          	mov ah, al				; move to AH
0310+  078C 33 02 00    	mov bl, [d + 2]
0311+  078F 37          	mov bh, bl
0312+  0790 33 03 00    	mov bl, [d + 3]
0313+  0793 07 43 06    	call atoi				; convert to int in AL
0314+  0796 E5          	pop b
0315+  0797 09          	ret
0316+  0798             
0317+  0798             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  0798             ; strtoint
0319+  0798             ; 5 digit base10 string number in d
0320+  0798             ; integer returned in A
0321+  0798             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  0798             strtoint:
0323+  0798 E2          	push si
0324+  0799 D8          	push b
0325+  079A D9          	push c
0326+  079B DA          	push d
0327+  079C 07 C3 05    	call strlen			; get string length in C
0328+  079F 7E          	dec c
0329+  07A0 FD 4E       	mov si, d
0330+  07A2 12          	mov a, c
0331+  07A3 FD 99       	shl a
0332+  07A5 3B 2B 06    	mov d, table_power
0333+  07A8 59          	add d, a
0334+  07A9 38 00 00    	mov c, 0
0335+  07AC             strtoint_L0:
0336+  07AC F6          	lodsb			; load ASCII to al
0337+  07AD B9 00       	cmp al, 0
0338+  07AF C6 C2 07    	je strtoint_end
0339+  07B2 6F 30       	sub al, $30		; make into integer
0340+  07B4 22 00       	mov ah, 0
0341+  07B6 2A          	mov b, [d]
0342+  07B7 AC          	mul a, b			; result in B since it fits in 16bits
0343+  07B8 11          	mov a, b
0344+  07B9 28          	mov b, c
0345+  07BA 54          	add a, b
0346+  07BB 39          	mov c, a
0347+  07BC 63 02 00    	sub d, 2
0348+  07BF 0A AC 07    	jmp strtoint_L0
0349+  07C2             strtoint_end:
0350+  07C2 12          	mov a, c
0351+  07C3 E7          	pop d
0352+  07C4 E6          	pop c
0353+  07C5 E5          	pop b
0354+  07C6 EF          	pop si
0355+  07C7 09          	ret
0356+  07C8             
0357+  07C8             
0358+  07C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  07C8             ; PRINT NULL TERMINATED STRING
0360+  07C8             ; pointer in D
0361+  07C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  07C8             puts:
0363+  07C8 D7          	push a
0364+  07C9 DA          	push d
0365+  07CA             puts_L1:
0366+  07CA 1E          	mov al, [d]
0367+  07CB B9 00       	cmp al, 0
0368+  07CD C6 D9 07    	jz puts_END
0369+  07D0 23          	mov ah, al
0370+  07D1 19 00       	mov al, 0
0371+  07D3 05 03       	syscall sys_io
0372+  07D5 79          	inc d
0373+  07D6 0A CA 07    	jmp puts_L1
0374+  07D9             puts_END:
0375+  07D9 E7          	pop d
0376+  07DA E4          	pop a
0377+  07DB 09          	ret
0378+  07DC             
0379+  07DC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  07DC             ; PRINT N SIZE STRING
0381+  07DC             ; pointer in D
0382+  07DC             ; size in C
0383+  07DC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  07DC             putsn:
0385+  07DC DB          	push al
0386+  07DD DA          	push d
0387+  07DE D9          	push c
0388+  07DF             putsn_L0:
0389+  07DF 1E          	mov al, [d]
0390+  07E0 23          	mov ah, al
0391+  07E1 19 00       	mov al, 0
0392+  07E3 05 03       	syscall sys_io
0393+  07E5 79          	inc d
0394+  07E6 7E          	dec c	
0395+  07E7 C2 00 00    	cmp c, 0
0396+  07EA C7 DF 07    	jne putsn_L0
0397+  07ED             putsn_end:
0398+  07ED E6          	pop c
0399+  07EE E7          	pop d
0400+  07EF E8          	pop al
0401+  07F0 09          	ret
0402+  07F1             
0403+  07F1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  07F1             ; print 16bit decimal number
0405+  07F1             ; input number in A
0406+  07F1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  07F1             print_u16d:
0408+  07F1 D7          	push a
0409+  07F2 D8          	push b
0410+  07F3 26 10 27    	mov b, 10000
0411+  07F6 AE          	div a, b			; get 10000 coeff.
0412+  07F7 07 1D 08    	call print_number
0413+  07FA 11          	mov a, b
0414+  07FB 26 E8 03    	mov b, 1000
0415+  07FE AE          	div a, b			; get 10000 coeff.
0416+  07FF 07 1D 08    	call print_number
0417+  0802 11          	mov a, b
0418+  0803 26 64 00    	mov b, 100
0419+  0806 AE          	div a, b
0420+  0807 07 1D 08    	call print_number
0421+  080A 11          	mov a, b
0422+  080B 26 0A 00    	mov b, 10
0423+  080E AE          	div a, b
0424+  080F 07 1D 08    	call print_number
0425+  0812 11          	mov a, b
0426+  0813 6A 30       	add al, $30
0427+  0815 23          	mov ah, al
0428+  0816 19 00       	mov al, 0
0429+  0818 05 03       	syscall sys_io	; print coeff
0430+  081A E5          	pop b
0431+  081B E4          	pop a
0432+  081C 09          	ret
0433+  081D             
0434+  081D             
0435+  081D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  081D             ; if A == 0, print space
0437+  081D             ; else print A
0438+  081D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0439+  081D             print_number:
0440+  081D 6A 30       	add al, $30
0441+  081F 23          	mov ah, al
0442+  0820 07 8E 06    	call putchar
0443+  0823 09          	ret
0444+  0824             
0445+  0824             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0446+  0824             ; PRINT 16BIT HEX INTEGER
0447+  0824             ; integer value in reg B
0448+  0824             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  0824             print_u16x:
0450+  0824 D7          	push a
0451+  0825 D8          	push b
0452+  0826 DD          	push bl
0453+  0827 30          	mov bl, bh
0454+  0828 07 55 06    	call itoa				; convert bh to char in A
0455+  082B 2F          	mov bl, al				; save al
0456+  082C 19 00       	mov al, 0
0457+  082E 05 03       	syscall sys_io				; display AH
0458+  0830 24          	mov ah, bl				; retrieve al
0459+  0831 19 00       	mov al, 0
0460+  0833 05 03       	syscall sys_io				; display AL
0461+  0835             
0462+  0835 EA          	pop bl
0463+  0836 07 55 06    	call itoa				; convert bh to char in A
0464+  0839 2F          	mov bl, al				; save al
0465+  083A 19 00       	mov al, 0
0466+  083C 05 03       	syscall sys_io				; display AH
0467+  083E 24          	mov ah, bl				; retrieve al
0468+  083F 19 00       	mov al, 0
0469+  0841 05 03       	syscall sys_io				; display AL
0470+  0843             
0471+  0843 E5          	pop b
0472+  0844 E4          	pop a
0473+  0845 09          	ret
0474+  0846             
0475+  0846             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  0846             ; INPUT 16BIT HEX INTEGER
0477+  0846             ; read 16bit integer into A
0478+  0846             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  0846             scan_u16x:
0480+  0846 F8 10 00    	enter 16
0481+  0849 D8          	push b
0482+  084A DA          	push d
0483+  084B             
0484+  084B FA F1 FF    	lea d, [bp + -15]
0485+  084E 07 95 06    	call gets				; get number
0486+  0851             
0487+  0851 32          	mov bl, [d]
0488+  0852 37          	mov bh, bl
0489+  0853 33 01 00    	mov bl, [d + 1]
0490+  0856 07 43 06    	call atoi				; convert to int in AL
0491+  0859 23          	mov ah, al				; move to AH
0492+  085A             
0493+  085A 33 02 00    	mov bl, [d + 2]
0494+  085D 37          	mov bh, bl
0495+  085E 33 03 00    	mov bl, [d + 3]
0496+  0861 07 43 06    	call atoi				; convert to int in AL
0497+  0864             
0498+  0864 E7          	pop d
0499+  0865 E5          	pop b
0500+  0866 F9          	leave
0501+  0867 09          	ret
0502+  0868             
0503+  0868             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0504+  0868             ; PRINT 8bit HEX INTEGER
0505+  0868             ; integer value in reg bl
0506+  0868             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  0868             print_u8x:
0508+  0868 D7          	push a
0509+  0869 DD          	push bl
0510+  086A             
0511+  086A 07 55 06    	call itoa				; convert bl to char in A
0512+  086D 2F          	mov bl, al				; save al
0513+  086E 19 00       	mov al, 0
0514+  0870 05 03       	syscall sys_io				; display AH
0515+  0872 24          	mov ah, bl				; retrieve al
0516+  0873 19 00       	mov al, 0
0517+  0875 05 03       	syscall sys_io				; display AL
0518+  0877             
0519+  0877 EA          	pop bl
0520+  0878 E4          	pop a
0521+  0879 09          	ret
0522+  087A             
0523+  087A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0524+  087A             ; print 8bit decimal unsigned number
0525+  087A             ; input number in AL
0526+  087A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  087A             print_u8d:
0528+  087A D7          	push a
0529+  087B D8          	push b
0530+  087C             
0531+  087C 22 00       	mov ah, 0
0532+  087E 26 64 00    	mov b, 100
0533+  0881 AE          	div a, b
0534+  0882 D8          	push b			; save remainder
0535+  0883 B9 00       	cmp al, 0
0536+  0885 C6 8F 08    	je skip100
0537+  0888 6A 30       	add al, $30
0538+  088A 23          	mov ah, al
0539+  088B 19 00       	mov al, 0
0540+  088D 05 03       	syscall sys_io	; print coeff
0541+  088F             skip100:
0542+  088F E4          	pop a
0543+  0890 22 00       	mov ah, 0
0544+  0892 26 0A 00    	mov b, 10
0545+  0895 AE          	div a, b
0546+  0896 D8          	push b			; save remainder
0547+  0897 B9 00       	cmp al, 0
0548+  0899 C6 A3 08    	je skip10
0549+  089C 6A 30       	add al, $30
0550+  089E 23          	mov ah, al
0551+  089F 19 00       	mov al, 0
0552+  08A1 05 03       	syscall sys_io	; print coeff
0553+  08A3             skip10:
0554+  08A3 E4          	pop a
0555+  08A4 1B          	mov al, bl
0556+  08A5 6A 30       	add al, $30
0557+  08A7 23          	mov ah, al
0558+  08A8 19 00       	mov al, 0
0559+  08AA 05 03       	syscall sys_io	; print coeff
0560+  08AC E5          	pop b
0561+  08AD E4          	pop a
0562+  08AE 09          	ret
0563+  08AF             
0564+  08AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0565+  08AF             ; INPUT 8BIT HEX INTEGER
0566+  08AF             ; read 8bit integer into AL
0567+  08AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  08AF             scan_u8x:
0569+  08AF F8 04 00    	enter 4
0570+  08B2 D8          	push b
0571+  08B3 DA          	push d
0572+  08B4             
0573+  08B4 FA FD FF    	lea d, [bp + -3]
0574+  08B7 07 95 06    	call gets				; get number
0575+  08BA             
0576+  08BA 32          	mov bl, [d]
0577+  08BB 37          	mov bh, bl
0578+  08BC 33 01 00    	mov bl, [d + 1]
0579+  08BF 07 43 06    	call atoi				; convert to int in AL
0580+  08C2             
0581+  08C2 E7          	pop d
0582+  08C3 E5          	pop b
0583+  08C4 F9          	leave
0584+  08C5 09          	ret
0585+  08C6             
0586+  08C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  08C6             ; input decimal number
0588+  08C6             ; result in A
0589+  08C6             ; 655'\0'
0590+  08C6             ; low--------high
0591+  08C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0592+  08C6             scan_u16d:
0593+  08C6 F8 08 00    	enter 8
0594+  08C9 E2          	push si
0595+  08CA D8          	push b
0596+  08CB D9          	push c
0597+  08CC DA          	push d
0598+  08CD FA F9 FF    	lea d, [bp +- 7]
0599+  08D0 07 95 06    	call gets
0600+  08D3 07 C3 05    	call strlen			; get string length in C
0601+  08D6 7E          	dec c
0602+  08D7 FD 4E       	mov si, d
0603+  08D9 12          	mov a, c
0604+  08DA FD 99       	shl a
0605+  08DC 3B 2B 06    	mov d, table_power
0606+  08DF 59          	add d, a
0607+  08E0 38 00 00    	mov c, 0
0608+  08E3             mul_loop:
0609+  08E3 F6          	lodsb			; load ASCII to al
0610+  08E4 B9 00       	cmp al, 0
0611+  08E6 C6 F9 08    	je mul_exit
0612+  08E9 6F 30       	sub al, $30		; make into integer
0613+  08EB 22 00       	mov ah, 0
0614+  08ED 2A          	mov b, [d]
0615+  08EE AC          	mul a, b			; result in B since it fits in 16bits
0616+  08EF 11          	mov a, b
0617+  08F0 28          	mov b, c
0618+  08F1 54          	add a, b
0619+  08F2 39          	mov c, a
0620+  08F3 63 02 00    	sub d, 2
0621+  08F6 0A E3 08    	jmp mul_loop
0622+  08F9             mul_exit:
0623+  08F9 12          	mov a, c
0624+  08FA E7          	pop d
0625+  08FB E6          	pop c
0626+  08FC E5          	pop b
0627+  08FD EF          	pop si
0628+  08FE F9          	leave
0629+  08FF 09          	ret
0223   0900             ; --- END INCLUDE BLOCK
0224   0900             
0225   0900             
0226   0900             .end
tasm: Number of errors = 0
