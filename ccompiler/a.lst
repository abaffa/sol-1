0001   0000             ; --- FILENAME: strcat.c
0002   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0400             .org PROC_TEXT_ORG
0004   0400             
0005   0400             ; --- BEGIN TEXT BLOCK
0006   0400             main:
0007   0400 D2            push bp
0008   0401 9B            mov bp, sp
0009   0402 26 F4 05      mov b, _string_0
0010   0405 FD AB         swp b
0011   0407 D8            push b
0012   0408 07 9F 05      call print
0013   040B 51 02 00      add sp, 2
0014   040E 29 DC 05      mov b, [s1]
0015   0411 FD AB         swp b
0016   0413 D8            push b
0017   0414 07 9F 05      call print
0018   0417 51 02 00      add sp, 2
0019   041A 26 02 06      mov b, _string_1
0020   041D FD AB         swp b
0021   041F D8            push b
0022   0420 07 9F 05      call print
0023   0423 51 02 00      add sp, 2
0024   0426 26 04 06      mov b, _string_2
0025   0429 FD AB         swp b
0026   042B D8            push b
0027   042C 07 9F 05      call print
0028   042F 51 02 00      add sp, 2
0029   0432 29 F2 05      mov b, [s2]
0030   0435 FD AB         swp b
0031   0437 D8            push b
0032   0438 07 9F 05      call print
0033   043B 51 02 00      add sp, 2
0034   043E 26 02 06      mov b, _string_1
0035   0441 FD AB         swp b
0036   0443 D8            push b
0037   0444 07 9F 05      call print
0038   0447 51 02 00      add sp, 2
0039   044A 26 0D 06      mov b, _string_3
0040   044D FD AB         swp b
0041   044F D8            push b
0042   0450 07 9F 05      call print
0043   0453 51 02 00      add sp, 2
0044   0456 29 DC 05      mov b, [s1]
0045   0459 FD AB         swp b
0046   045B D8            push b
0047   045C 29 F2 05      mov b, [s2]
0048   045F FD AB         swp b
0049   0461 D8            push b
0050   0462 07 D2 04      call _strcat
0051   0465 51 04 00      add sp, 4
0052   0468 29 DC 05      mov b, [s1]
0053   046B FD AB         swp b
0054   046D D8            push b
0055   046E 07 9F 05      call print
0056   0471 51 02 00      add sp, 2
0057   0474 26 02 06      mov b, _string_1
0058   0477 FD AB         swp b
0059   0479 D8            push b
0060   047A 07 9F 05      call print
0061   047D 51 02 00      add sp, 2
0062   0480 26 00 00      mov b, 0
0063   0483 F9            leave
0064   0484 05 0B         syscall sys_terminate_proc
0065   0486             _strlen:
0066   0486 D2            push bp
0067   0487 9B            mov bp, sp
0068   0488 52 02 00      sub sp, 2 ; length
0069   048B 26 00 00      mov b, 0
0070   048E D7            push a
0071   048F 11            mov a, b
0072   0490 45 FF FF      mov [bp + -1], a ; length
0073   0493 E4            pop a
0074   0494             _while1_cond:
0075   0494 FA 05 00      lea d, [bp + 5] ; str
0076   0497 2A            mov b, [d]
0077   0498 D7            push a
0078   0499 74            mov d, b
0079   049A 2C FF FF      mov b, [bp + -1] ; length
0080   049D 10 01 00      mov a, 1
0081   04A0 AC            mul a, b
0082   04A1 5A            add d, b
0083   04A2 32            mov bl, [d]
0084   04A3 A7 00         mov bh, 0
0085   04A5 11            mov a, b
0086   04A6 26 00 00      mov b, 0
0087   04A9 B0            cmp a, b
0088   04AA 0E            lodflgs
0089   04AB 87 01         and al, %00000001
0090   04AD 8F 01         xor al, %00000001 ; !=
0091   04AF B9 00         cmp al, 0
0092   04B1 0E            lodflgs
0093   04B2 96            not al
0094   04B3 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0095   04B5 22 00         mov ah, 0
0096   04B7 27            mov b, a
0097   04B8 E4            pop a
0098   04B9 C0 00 00      cmp b, 0
0099   04BC C6 CD 04      je _while1_exit
0100   04BF             _while1_block:
0101   04BF 2C FF FF      mov b, [bp + -1] ; length
0102   04C2 FD 77         inc b
0103   04C4 D7            push a
0104   04C5 11            mov a, b
0105   04C6 45 FF FF      mov [bp + -1], a ; length
0106   04C9 E4            pop a
0107   04CA 0A 94 04      jmp _while1_cond
0108   04CD             _while1_exit:
0109   04CD 2C FF FF      mov b, [bp + -1] ; length
0110   04D0 F9            leave
0111   04D1 09            ret
0112   04D2             _strcat:
0113   04D2 D2            push bp
0114   04D3 9B            mov bp, sp
0115   04D4 52 02 00      sub sp, 2 ; dest_len
0116   04D7 52 02 00      sub sp, 2 ; i
0117   04DA FA 07 00      lea d, [bp + 7] ; dest
0118   04DD 2A            mov b, [d]
0119   04DE FD AB         swp b
0120   04E0 D8            push b
0121   04E1 07 86 04      call _strlen
0122   04E4 51 02 00      add sp, 2
0123   04E7 D7            push a
0124   04E8 11            mov a, b
0125   04E9 45 FF FF      mov [bp + -1], a ; dest_len
0126   04EC E4            pop a
0127   04ED             _for2_init:
0128   04ED 26 00 00      mov b, 0
0129   04F0 D7            push a
0130   04F1 11            mov a, b
0131   04F2 45 FD FF      mov [bp + -3], a ; i
0132   04F5 E4            pop a
0133   04F6             _for2_cond:
0134   04F6 FA 05 00      lea d, [bp + 5] ; src
0135   04F9 2A            mov b, [d]
0136   04FA D7            push a
0137   04FB 74            mov d, b
0138   04FC 2C FD FF      mov b, [bp + -3] ; i
0139   04FF 10 01 00      mov a, 1
0140   0502 AC            mul a, b
0141   0503 5A            add d, b
0142   0504 32            mov bl, [d]
0143   0505 A7 00         mov bh, 0
0144   0507 11            mov a, b
0145   0508 26 00 00      mov b, 0
0146   050B B0            cmp a, b
0147   050C 0E            lodflgs
0148   050D 87 01         and al, %00000001
0149   050F 8F 01         xor al, %00000001 ; !=
0150   0511 B9 00         cmp al, 0
0151   0513 0E            lodflgs
0152   0514 96            not al
0153   0515 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0154   0517 22 00         mov ah, 0
0155   0519 27            mov b, a
0156   051A E4            pop a
0157   051B C0 00 00      cmp b, 0
0158   051E C6 5A 05      je _for2_exit
0159   0521             _for2_block:
0160   0521 FA 07 00      lea d, [bp + 7] ; dest
0161   0524 2A            mov b, [d]
0162   0525 74            mov d, b
0163   0526 2C FF FF      mov b, [bp + -1] ; dest_len
0164   0529 D7            push a
0165   052A 11            mov a, b
0166   052B 2C FD FF      mov b, [bp + -3] ; i
0167   052E 54            add a, b
0168   052F 27            mov b, a
0169   0530 E4            pop a
0170   0531 10 01 00      mov a, 1
0171   0534 AC            mul a, b
0172   0535 5A            add d, b
0173   0536 DA            push d
0174   0537 FA 05 00      lea d, [bp + 5] ; src
0175   053A 2A            mov b, [d]
0176   053B D7            push a
0177   053C 74            mov d, b
0178   053D 2C FD FF      mov b, [bp + -3] ; i
0179   0540 10 01 00      mov a, 1
0180   0543 AC            mul a, b
0181   0544 5A            add d, b
0182   0545 32            mov bl, [d]
0183   0546 A7 00         mov bh, 0
0184   0548 E4            pop a
0185   0549 E7            pop d
0186   054A 1B            mov al, bl
0187   054B 3E            mov [d], al
0188   054C             _for2_update:
0189   054C 2C FD FF      mov b, [bp + -3] ; i
0190   054F FD 77         inc b
0191   0551 D7            push a
0192   0552 11            mov a, b
0193   0553 45 FD FF      mov [bp + -3], a ; i
0194   0556 E4            pop a
0195   0557 0A F6 04      jmp _for2_cond
0196   055A             _for2_exit:
0197   055A FA 07 00      lea d, [bp + 7] ; dest
0198   055D 2A            mov b, [d]
0199   055E 74            mov d, b
0200   055F 2C FF FF      mov b, [bp + -1] ; dest_len
0201   0562 D7            push a
0202   0563 11            mov a, b
0203   0564 2C FD FF      mov b, [bp + -3] ; i
0204   0567 54            add a, b
0205   0568 27            mov b, a
0206   0569 E4            pop a
0207   056A 10 01 00      mov a, 1
0208   056D AC            mul a, b
0209   056E 5A            add d, b
0210   056F DA            push d
0211   0570 26 00 00      mov b, 0
0212   0573 E7            pop d
0213   0574 1B            mov al, bl
0214   0575 3E            mov [d], al
0215   0576 FA 07 00      lea d, [bp + 7] ; dest
0216   0579 2A            mov b, [d]
0217   057A F9            leave
0218   057B 09            ret
0219   057C             scann:
0220   057C D2            push bp
0221   057D 9B            mov bp, sp
0222   057E 52 02 00      sub sp, 2 ; m
0223   0581             
0224   0581             ; --- BEGIN INLINE ASM BLOCK
0225   0581 07 67 09      call scan_u16d
0226   0584 45 FF FF      mov [bp + -1], a
0227   0587             ; --- END INLINE ASM BLOCK
0228   0587             
0229   0587 FA 05 00      lea d, [bp + 5] ; n
0230   058A 2A            mov b, [d]
0231   058B 74            mov d, b
0232   058C DA            push d
0233   058D 2C FF FF      mov b, [bp + -1] ; m
0234   0590 E7            pop d
0235   0591 11            mov a, b
0236   0592 43            mov [d], a
0237   0593 F9            leave
0238   0594 09            ret
0239   0595             printn:
0240   0595 D2            push bp
0241   0596 9B            mov bp, sp
0242   0597             
0243   0597             ; --- BEGIN INLINE ASM BLOCK
0244   0597 17 05 00      mov a, [bp + 5]
0245   059A 07 92 08      call print_u16d
0246   059D             ; --- END INLINE ASM BLOCK
0247   059D             
0248   059D F9            leave
0249   059E 09            ret
0250   059F             print:
0251   059F D2            push bp
0252   05A0 9B            mov bp, sp
0253   05A1             
0254   05A1             ; --- BEGIN INLINE ASM BLOCK
0255   05A1 17 05 00      mov a, [bp + 5]
0256   05A4 3C            mov d, a
0257   05A5 07 69 08      call puts
0258   05A8             ; --- END INLINE ASM BLOCK
0259   05A8             
0260   05A8 F9            leave
0261   05A9 09            ret
0262   05AA             ; --- END TEXT BLOCK
0263   05AA             
0264   05AA             ; --- BEGIN DATA BLOCK
0265   05AA             s1_data: 
0266   05AA 48 65 6C 6C .db 'H', 'e', 'l', 'l', 'o', 0,
0266   05AE 6F 00 
0267   05B0 00 00 00 00 .fill 44, 0
0267   05B4 00 00 00 00 
0267   05B8 00 00 00 00 
0267   05BC 00 00 00 00 
0267   05C0 00 00 00 00 
0267   05C4 00 00 00 00 
0267   05C8 00 00 00 00 
0267   05CC 00 00 00 00 
0267   05D0 00 00 00 00 
0267   05D4 00 00 00 00 
0267   05D8 00 00 00 00 
0268   05DC AA 05       s1: .dw s1_data
0269   05DE 2E 20 4D 79 s2_data: .db ". My name is Sol-1.", 0
0269   05E2 20 6E 61 6D 
0269   05E6 65 20 69 73 
0269   05EA 20 53 6F 6C 
0269   05EE 2D 31 2E 00 
0270   05F2 DE 05       s2: .dw s2_data
0271   05F4 44 65 73 74 _string_0: .db "Destination: ", 0
0271   05F8 69 6E 61 74 
0271   05FC 69 6F 6E 3A 
0271   0600 20 00 
0272   0602 0A 00       _string_1: .db "\n", 0
0273   0604 53 6F 75 72 _string_2: .db "Source: ", 0
0273   0608 63 65 3A 20 
0273   060C 00 
0274   060D 43 6F 6E 63 _string_3: .db "Concatenation: ", 0
0274   0611 61 74 65 6E 
0274   0615 61 74 69 6F 
0274   0619 6E 3A 20 00 
0275   061D             ; --- END DATA BLOCK
0276   061D             
0277   061D             ; --- BEGIN INCLUDE BLOCK
0278   061D             .include "lib/stdio.asm"
0001+  061D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  061D             ; stdio.s
0003+  061D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  061D             .include "lib/string.asm"
0001++ 061D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 061D             ; string.s
0003++ 061D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 061D             
0005++ 061D             
0006++ 061D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 061D             ; strrev
0008++ 061D             ; reverse a string
0009++ 061D             ; D = string address
0010++ 061D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 061D             ; 01234
0012++ 061D             strrev:
0013++ 061D 4B          	pusha
0014++ 061E 07 64 06    	call strlen	; length in C
0015++ 0621 12          	mov a, c
0016++ 0622 AF 01 00    	cmp a, 1
0017++ 0625 D0 3F 06    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0628 7D          	dec a
0019++ 0629 FD 4E       	mov si, d	; beginning of string
0020++ 062B FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 062D 59          	add d, a	; end of string
0022++ 062E 12          	mov a, c
0023++ 062F FD 9B       	shr a		; divide by 2
0024++ 0631 39          	mov c, a	; C now counts the steps
0025++ 0632             strrev_L0:
0026++ 0632 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0633 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0634 3E          	mov [d], al	; store left char into right side
0029++ 0635 1B          	mov al, bl
0030++ 0636 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0637 7E          	dec c
0032++ 0638 7F          	dec d
0033++ 0639 C2 00 00    	cmp c, 0
0034++ 063C C7 32 06    	jne strrev_L0
0035++ 063F             strrev_end:
0036++ 063F 4C          	popa
0037++ 0640 09          	ret
0038++ 0641             	
0039++ 0641             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0641             ; strchr
0041++ 0641             ; search string in D for char in AL
0042++ 0641             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0641             strchr:
0044++ 0641             strchr_L0:
0045++ 0641 32          	mov bl, [d]
0046++ 0642 C1 00       	cmp bl, 0
0047++ 0644 C6 4F 06    	je strchr_end
0048++ 0647 BA          	cmp al, bl
0049++ 0648 C6 4F 06    	je strchr_end
0050++ 064B 79          	inc d
0051++ 064C 0A 41 06    	jmp strchr_L0
0052++ 064F             strchr_end:
0053++ 064F 1B          	mov al, bl
0054++ 0650 09          	ret
0055++ 0651             
0056++ 0651             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0651             ; strstr
0058++ 0651             ; find sub-string
0059++ 0651             ; str1 in SI
0060++ 0651             ; str2 in DI
0061++ 0651             ; SI points to end of source string
0062++ 0651             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0651             strstr:
0064++ 0651 DB          	push al
0065++ 0652 DA          	push d
0066++ 0653 E3          	push di
0067++ 0654             strstr_loop:
0068++ 0654 F3          	cmpsb					; compare a byte of the strings
0069++ 0655 C7 60 06    	jne strstr_ret
0070++ 0658 FC 00 00    	lea d, [di + 0]
0071++ 065B BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 065D C7 54 06    	jne strstr_loop				; equal chars but not at end
0073++ 0660             strstr_ret:
0074++ 0660 F0          	pop di
0075++ 0661 E7          	pop d
0076++ 0662 E8          	pop al
0077++ 0663 09          	ret
0078++ 0664             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0664             ; length of null terminated string
0080++ 0664             ; result in C
0081++ 0664             ; pointer in D
0082++ 0664             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0664             strlen:
0084++ 0664 DA          	push d
0085++ 0665 38 00 00    	mov c, 0
0086++ 0668             strlen_L1:
0087++ 0668 BD 00       	cmp byte [d], 0
0088++ 066A C6 72 06    	je strlen_ret
0089++ 066D 79          	inc d
0090++ 066E 78          	inc c
0091++ 066F 0A 68 06    	jmp strlen_L1
0092++ 0672             strlen_ret:
0093++ 0672 E7          	pop d
0094++ 0673 09          	ret
0095++ 0674             
0096++ 0674             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0674             ; STRCMP
0098++ 0674             ; compare two strings
0099++ 0674             ; str1 in SI
0100++ 0674             ; str2 in DI
0101++ 0674             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0674             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0674             strcmp:
0104++ 0674 DB          	push al
0105++ 0675 DA          	push d
0106++ 0676 E3          	push di
0107++ 0677 E2          	push si
0108++ 0678             strcmp_loop:
0109++ 0678 F3          	cmpsb					; compare a byte of the strings
0110++ 0679 C7 84 06    	jne strcmp_ret
0111++ 067C FB FF FF    	lea d, [si +- 1]
0112++ 067F BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0681 C7 78 06    	jne strcmp_loop				; equal chars but not at end
0114++ 0684             strcmp_ret:
0115++ 0684 EF          	pop si
0116++ 0685 F0          	pop di
0117++ 0686 E7          	pop d
0118++ 0687 E8          	pop al
0119++ 0688 09          	ret
0120++ 0689             
0121++ 0689             
0122++ 0689             ; STRCPY
0123++ 0689             ; copy null terminated string from SI to DI
0124++ 0689             ; source in SI
0125++ 0689             ; destination in DI
0126++ 0689             strcpy:
0127++ 0689 E2          	push si
0128++ 068A E3          	push di
0129++ 068B DB          	push al
0130++ 068C             strcpy_L1:
0131++ 068C F6          	lodsb
0132++ 068D F7          	stosb
0133++ 068E B9 00       	cmp al, 0
0134++ 0690 C7 8C 06    	jne strcpy_L1
0135++ 0693             strcpy_end:
0136++ 0693 E8          	pop al
0137++ 0694 F0          	pop di
0138++ 0695 EF          	pop si
0139++ 0696 09          	ret
0140++ 0697             
0141++ 0697             ; STRCAT
0142++ 0697             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0697             ; source in SI
0144++ 0697             ; destination in DI
0145++ 0697             strcat:
0146++ 0697 E2          	push si
0147++ 0698 E3          	push di
0148++ 0699 D7          	push a
0149++ 069A DA          	push d
0150++ 069B 50          	mov a, di
0151++ 069C 3C          	mov d, a
0152++ 069D             strcat_goto_end_L1:
0153++ 069D BD 00       	cmp byte[d], 0
0154++ 069F C6 A6 06    	je strcat_start
0155++ 06A2 79          	inc d
0156++ 06A3 0A 9D 06    	jmp strcat_goto_end_L1
0157++ 06A6             strcat_start:
0158++ 06A6 FD 50       	mov di, d
0159++ 06A8             strcat_L1:
0160++ 06A8 F6          	lodsb
0161++ 06A9 F7          	stosb
0162++ 06AA B9 00       	cmp al, 0
0163++ 06AC C7 A8 06    	jne strcat_L1
0164++ 06AF             strcat_end:
0165++ 06AF E7          	pop d
0166++ 06B0 E4          	pop a
0167++ 06B1 F0          	pop di
0168++ 06B2 EF          	pop si
0169++ 06B3 09          	ret
0005+  06B4             
0006+  06B4 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  06B8 34 35 36 37 
0006+  06BC 38 39 41 42 
0006+  06C0 43 44 45 46 
0007+  06C4 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  06C8 1B 5B 48 00 
0008+  06CC             
0009+  06CC 01 00       table_power:.dw 1
0010+  06CE 0A 00       			.dw 10
0011+  06D0 64 00       			.dw 100
0012+  06D2 E8 03       			.dw 1000
0013+  06D4 10 27       			.dw 10000
0014+  06D6             
0015+  06D6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  06D6             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  06D6             ; ASCII in BL
0018+  06D6             ; result in AL
0019+  06D6             ; ascii for F = 0100 0110
0020+  06D6             ; ascii for 9 = 0011 1001
0021+  06D6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  06D6             hex_ascii_encode:
0023+  06D6 1B          	mov al, bl
0024+  06D7 93 40       	test al, $40				; test if letter or number
0025+  06D9 C7 DF 06    	jnz hex_letter
0026+  06DC 87 0F       	and al, $0F				; get number
0027+  06DE 09          	ret
0028+  06DF             hex_letter:
0029+  06DF 87 0F       	and al, $0F				; get letter
0030+  06E1 6A 09       	add al, 9
0031+  06E3 09          	ret
0032+  06E4             
0033+  06E4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  06E4             ; ATOI
0035+  06E4             ; 2 letter hex string in B
0036+  06E4             ; 8bit integer returned in AL
0037+  06E4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  06E4             atoi:
0039+  06E4 D8          	push b
0040+  06E5 07 D6 06    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  06E8 30          	mov bl, bh
0042+  06E9 DB          	push al					; save a
0043+  06EA 07 D6 06    	call hex_ascii_encode
0044+  06ED EA          	pop bl	
0045+  06EE FD 9E 04    	shl al, 4
0046+  06F1 8C          	or al, bl
0047+  06F2 E5          	pop b
0048+  06F3 09          	ret	
0049+  06F4             
0050+  06F4             
0051+  06F4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  06F4             ; printf
0053+  06F4             ; no need for explanations!
0054+  06F4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  06F4             printf:
0056+  06F4 09          	ret
0057+  06F5             
0058+  06F5             
0059+  06F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  06F5             ; scanf
0061+  06F5             ; no need for explanations!
0062+  06F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  06F5             scanf:
0064+  06F5 09          	ret
0065+  06F6             
0066+  06F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  06F6             ; ITOA
0068+  06F6             ; 8bit value in BL
0069+  06F6             ; 2 byte ASCII result in A
0070+  06F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  06F6             itoa:
0072+  06F6 DA          	push d
0073+  06F7 D8          	push b
0074+  06F8 A7 00       	mov bh, 0
0075+  06FA FD A4 04    	shr bl, 4	
0076+  06FD 74          	mov d, b
0077+  06FE 1F B4 06    	mov al, [d + s_hex_digits]
0078+  0701 23          	mov ah, al
0079+  0702             	
0080+  0702 E5          	pop b
0081+  0703 D8          	push b
0082+  0704 A7 00       	mov bh, 0
0083+  0706 FD 87 0F    	and bl, $0F
0084+  0709 74          	mov d, b
0085+  070A 1F B4 06    	mov al, [d + s_hex_digits]
0086+  070D E5          	pop b
0087+  070E E7          	pop d
0088+  070F 09          	ret
0089+  0710             
0090+  0710             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  0710             ; HEX STRING TO BINARY
0092+  0710             ; di = destination address
0093+  0710             ; si = source
0094+  0710             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  0710             hex_to_int:
0096+  0710             hex_to_int_L1:
0097+  0710 F6          	lodsb					; load from [SI] to AL
0098+  0711 B9 00       	cmp al, 0				; check if ASCII 0
0099+  0713 C6 20 07    	jz hex_to_int_ret
0100+  0716 36          	mov bh, al
0101+  0717 F6          	lodsb
0102+  0718 2F          	mov bl, al
0103+  0719 07 E4 06    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  071C F7          	stosb					; store AL to [DI]
0105+  071D 0A 10 07    	jmp hex_to_int_L1
0106+  0720             hex_to_int_ret:
0107+  0720 09          	ret		
0108+  0721             
0109+  0721             
0110+  0721             
0111+  0721             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  0721             ; GETCHAR
0113+  0721             ; char in ah
0114+  0721             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  0721             getchar:
0116+  0721 DB          	push al
0117+  0722             getchar_retry:
0118+  0722 FD 0C       	sti
0119+  0724 19 01       	mov al, 1
0120+  0726 05 03       	syscall sys_io			; receive in AH
0121+  0728 B9 00       	cmp al, 0			; check if any char was receive
0122+  072A C6 22 07    	je getchar_retry
0123+  072D E8          	pop al
0124+  072E 09          	ret
0125+  072F             
0126+  072F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  072F             ; PUTCHAR
0128+  072F             ; char in ah
0129+  072F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  072F             putchar:
0131+  072F D7          	push a
0132+  0730 19 00       	mov al, 0
0133+  0732 05 03       	syscall sys_io			; char in AH
0134+  0734 E4          	pop a
0135+  0735 09          	ret
0136+  0736             
0137+  0736             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  0736             ;; INPUT A STRING
0139+  0736             ;; terminates with null
0140+  0736             ;; pointer in D
0141+  0736             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  0736             gets:
0143+  0736 D7          	push a
0144+  0737 DA          	push d
0145+  0738             gets_loop:
0146+  0738 FD 0C       	sti
0147+  073A 19 01       	mov al, 1
0148+  073C 05 03       	syscall sys_io			; receive in AH
0149+  073E B9 00       	cmp al, 0				; check error code (AL)
0150+  0740 C6 38 07    	je gets_loop			; if no char received, retry
0151+  0743             
0152+  0743 76 1B       	cmp ah, 27
0153+  0745 C6 66 07    	je gets_telnet_escape
0154+  0748 76 0A       	cmp ah, $0A				; LF
0155+  074A C6 BF 07    	je gets_end
0156+  074D 76 0D       	cmp ah, $0D				; CR
0157+  074F C6 BF 07    	je gets_end
0158+  0752 76 5C       	cmp ah, $5C				; '\\'
0159+  0754 C6 96 07    	je gets_escape
0160+  0757             	
0161+  0757 76 08       	cmp ah, $08			; check for backspace
0162+  0759 C6 62 07    	je gets_backspace
0163+  075C             
0164+  075C 1A          	mov al, ah
0165+  075D 3E          	mov [d], al
0166+  075E 79          	inc d
0167+  075F 0A 38 07    	jmp gets_loop
0168+  0762             gets_backspace:
0169+  0762 7F          	dec d
0170+  0763 0A 38 07    	jmp gets_loop
0171+  0766             gets_telnet_escape:
0172+  0766 FD 0C       	sti
0173+  0768 19 01       	mov al, 1
0174+  076A 05 03       	syscall sys_io				; receive in AH without echo
0175+  076C B9 00       	cmp al, 0					; check error code (AL)
0176+  076E C6 66 07    	je gets_telnet_escape		; if no char received, retry
0177+  0771 76 5B       	cmp ah, '['
0178+  0773 C7 38 07    	jne gets_loop
0179+  0776             gets_telnet_escape_phase2:
0180+  0776 FD 0C       	sti
0181+  0778 19 01       	mov al, 1
0182+  077A 05 03       	syscall sys_io					; receive in AH without echo
0183+  077C B9 00       	cmp al, 0						; check error code (AL)
0184+  077E C6 76 07    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  0781 76 44       	cmp ah, 'D'
0186+  0783 C6 8E 07    	je gets_left_arrow
0187+  0786 76 43       	cmp ah, 'C'
0188+  0788 C6 92 07    	je gets_right_arrow
0189+  078B 0A 38 07    	jmp gets_loop
0190+  078E             gets_left_arrow:
0191+  078E 7F          	dec d
0192+  078F 0A 38 07    	jmp gets_loop
0193+  0792             gets_right_arrow:
0194+  0792 79          	inc d
0195+  0793 0A 38 07    	jmp gets_loop
0196+  0796             gets_escape:
0197+  0796 FD 0C       	sti
0198+  0798 19 01       	mov al, 1
0199+  079A 05 03       	syscall sys_io			; receive in AH
0200+  079C B9 00       	cmp al, 0				; check error code (AL)
0201+  079E C6 96 07    	je gets_escape			; if no char received, retry
0202+  07A1 76 6E       	cmp ah, 'n'
0203+  07A3 C6 B1 07    	je gets_LF
0204+  07A6 76 72       	cmp ah, 'r'
0205+  07A8 C6 B8 07    	je gets_CR
0206+  07AB 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  07AC 3E          	mov [d], al
0208+  07AD 79          	inc d
0209+  07AE 0A 38 07    	jmp gets_loop
0210+  07B1             gets_LF:
0211+  07B1 19 0A       	mov al, $0A
0212+  07B3 3E          	mov [d], al
0213+  07B4 79          	inc d
0214+  07B5 0A 38 07    	jmp gets_loop
0215+  07B8             gets_CR:
0216+  07B8 19 0D       	mov al, $0D
0217+  07BA 3E          	mov [d], al
0218+  07BB 79          	inc d
0219+  07BC 0A 38 07    	jmp gets_loop
0220+  07BF             gets_end:
0221+  07BF 19 00       	mov al, 0
0222+  07C1 3E          	mov [d], al				; terminate string
0223+  07C2 E7          	pop d
0224+  07C3 E4          	pop a
0225+  07C4 09          	ret
0226+  07C5             
0227+  07C5             
0228+  07C5             
0229+  07C5             
0230+  07C5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  07C5             ;; INPUT TEXT
0232+  07C5             ;; terminated with CTRL+D
0233+  07C5             ;; pointer in D
0234+  07C5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  07C5             gettxt:
0236+  07C5 D7          	push a
0237+  07C6 DA          	push d
0238+  07C7             gettxt_loop:
0239+  07C7 19 01       	mov al, 1
0240+  07C9 05 03       	syscall sys_io			; receive in AH
0241+  07CB B9 00       	cmp al, 0				; check error code (AL)
0242+  07CD C6 C7 07    	je gettxt_loop		; if no char received, retry
0243+  07D0 76 04       	cmp ah, 4			; EOT
0244+  07D2 C6 10 08    	je gettxt_end
0245+  07D5 76 08       	cmp ah, $08			; check for backspace
0246+  07D7 C6 0C 08    	je gettxt_backspace
0247+  07DA 76 5C       	cmp ah, $5C				; '\\'
0248+  07DC C6 E5 07    	je gettxt_escape
0249+  07DF 1A          	mov al, ah
0250+  07E0 3E          	mov [d], al
0251+  07E1 79          	inc d
0252+  07E2 0A C7 07    	jmp gettxt_loop
0253+  07E5             gettxt_escape:
0254+  07E5 19 01       	mov al, 1
0255+  07E7 05 03       	syscall sys_io			; receive in AH
0256+  07E9 B9 00       	cmp al, 0				; check error code (AL)
0257+  07EB C6 E5 07    	je gettxt_escape		; if no char received, retry
0258+  07EE 76 6E       	cmp ah, 'n'
0259+  07F0 C6 FE 07    	je gettxt_LF
0260+  07F3 76 72       	cmp ah, 'r'
0261+  07F5 C6 05 08    	je gettxt_CR
0262+  07F8 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  07F9 3E          	mov [d], al
0264+  07FA 79          	inc d
0265+  07FB 0A C7 07    	jmp gettxt_loop
0266+  07FE             gettxt_LF:
0267+  07FE 19 0A       	mov al, $0A
0268+  0800 3E          	mov [d], al
0269+  0801 79          	inc d
0270+  0802 0A C7 07    	jmp gettxt_loop
0271+  0805             gettxt_CR:
0272+  0805 19 0D       	mov al, $0D
0273+  0807 3E          	mov [d], al
0274+  0808 79          	inc d
0275+  0809 0A C7 07    	jmp gettxt_loop
0276+  080C             gettxt_backspace:
0277+  080C 7F          	dec d
0278+  080D 0A C7 07    	jmp gettxt_loop
0279+  0810             gettxt_end:
0280+  0810 19 00       	mov al, 0
0281+  0812 3E          	mov [d], al				; terminate string
0282+  0813 E7          	pop d
0283+  0814 E4          	pop a
0284+  0815 09          	ret
0285+  0816             
0286+  0816             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  0816             ; PRINT NEW LINE
0288+  0816             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  0816             printnl:
0290+  0816 D7          	push a
0291+  0817 10 00 0A    	mov a, $0A00
0292+  081A 05 03       	syscall sys_io
0293+  081C 10 00 0D    	mov a, $0D00
0294+  081F 05 03       	syscall sys_io
0295+  0821 E4          	pop a
0296+  0822 09          	ret
0297+  0823             
0298+  0823             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  0823             ; strtoint
0300+  0823             ; 4 digit hex string number in d
0301+  0823             ; integer returned in A
0302+  0823             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  0823             strtointx:
0304+  0823 D8          	push b
0305+  0824 32          	mov bl, [d]
0306+  0825 37          	mov bh, bl
0307+  0826 33 01 00    	mov bl, [d + 1]
0308+  0829 07 E4 06    	call atoi				; convert to int in AL
0309+  082C 23          	mov ah, al				; move to AH
0310+  082D 33 02 00    	mov bl, [d + 2]
0311+  0830 37          	mov bh, bl
0312+  0831 33 03 00    	mov bl, [d + 3]
0313+  0834 07 E4 06    	call atoi				; convert to int in AL
0314+  0837 E5          	pop b
0315+  0838 09          	ret
0316+  0839             
0317+  0839             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  0839             ; strtoint
0319+  0839             ; 5 digit base10 string number in d
0320+  0839             ; integer returned in A
0321+  0839             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  0839             strtoint:
0323+  0839 E2          	push si
0324+  083A D8          	push b
0325+  083B D9          	push c
0326+  083C DA          	push d
0327+  083D 07 64 06    	call strlen			; get string length in C
0328+  0840 7E          	dec c
0329+  0841 FD 4E       	mov si, d
0330+  0843 12          	mov a, c
0331+  0844 FD 99       	shl a
0332+  0846 3B CC 06    	mov d, table_power
0333+  0849 59          	add d, a
0334+  084A 38 00 00    	mov c, 0
0335+  084D             strtoint_L0:
0336+  084D F6          	lodsb			; load ASCII to al
0337+  084E B9 00       	cmp al, 0
0338+  0850 C6 63 08    	je strtoint_end
0339+  0853 6F 30       	sub al, $30		; make into integer
0340+  0855 22 00       	mov ah, 0
0341+  0857 2A          	mov b, [d]
0342+  0858 AC          	mul a, b			; result in B since it fits in 16bits
0343+  0859 11          	mov a, b
0344+  085A 28          	mov b, c
0345+  085B 54          	add a, b
0346+  085C 39          	mov c, a
0347+  085D 63 02 00    	sub d, 2
0348+  0860 0A 4D 08    	jmp strtoint_L0
0349+  0863             strtoint_end:
0350+  0863 12          	mov a, c
0351+  0864 E7          	pop d
0352+  0865 E6          	pop c
0353+  0866 E5          	pop b
0354+  0867 EF          	pop si
0355+  0868 09          	ret
0356+  0869             
0357+  0869             
0358+  0869             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  0869             ; PRINT NULL TERMINATED STRING
0360+  0869             ; pointer in D
0361+  0869             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  0869             puts:
0363+  0869 D7          	push a
0364+  086A DA          	push d
0365+  086B             puts_L1:
0366+  086B 1E          	mov al, [d]
0367+  086C B9 00       	cmp al, 0
0368+  086E C6 7A 08    	jz puts_END
0369+  0871 23          	mov ah, al
0370+  0872 19 00       	mov al, 0
0371+  0874 05 03       	syscall sys_io
0372+  0876 79          	inc d
0373+  0877 0A 6B 08    	jmp puts_L1
0374+  087A             puts_END:
0375+  087A E7          	pop d
0376+  087B E4          	pop a
0377+  087C 09          	ret
0378+  087D             
0379+  087D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  087D             ; PRINT N SIZE STRING
0381+  087D             ; pointer in D
0382+  087D             ; size in C
0383+  087D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  087D             putsn:
0385+  087D DB          	push al
0386+  087E DA          	push d
0387+  087F D9          	push c
0388+  0880             putsn_L0:
0389+  0880 1E          	mov al, [d]
0390+  0881 23          	mov ah, al
0391+  0882 19 00       	mov al, 0
0392+  0884 05 03       	syscall sys_io
0393+  0886 79          	inc d
0394+  0887 7E          	dec c	
0395+  0888 C2 00 00    	cmp c, 0
0396+  088B C7 80 08    	jne putsn_L0
0397+  088E             putsn_end:
0398+  088E E6          	pop c
0399+  088F E7          	pop d
0400+  0890 E8          	pop al
0401+  0891 09          	ret
0402+  0892             
0403+  0892             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  0892             ; print 16bit decimal number
0405+  0892             ; input number in A
0406+  0892             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  0892             print_u16d:
0408+  0892 D7          	push a
0409+  0893 D8          	push b
0410+  0894 26 10 27    	mov b, 10000
0411+  0897 AE          	div a, b			; get 10000 coeff.
0412+  0898 07 BE 08    	call print_number
0413+  089B 11          	mov a, b
0414+  089C 26 E8 03    	mov b, 1000
0415+  089F AE          	div a, b			; get 10000 coeff.
0416+  08A0 07 BE 08    	call print_number
0417+  08A3 11          	mov a, b
0418+  08A4 26 64 00    	mov b, 100
0419+  08A7 AE          	div a, b
0420+  08A8 07 BE 08    	call print_number
0421+  08AB 11          	mov a, b
0422+  08AC 26 0A 00    	mov b, 10
0423+  08AF AE          	div a, b
0424+  08B0 07 BE 08    	call print_number
0425+  08B3 11          	mov a, b
0426+  08B4 6A 30       	add al, $30
0427+  08B6 23          	mov ah, al
0428+  08B7 19 00       	mov al, 0
0429+  08B9 05 03       	syscall sys_io	; print coeff
0430+  08BB E5          	pop b
0431+  08BC E4          	pop a
0432+  08BD 09          	ret
0433+  08BE             
0434+  08BE             
0435+  08BE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  08BE             ; if A == 0, print space
0437+  08BE             ; else print A
0438+  08BE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0439+  08BE             print_number:
0440+  08BE 6A 30       	add al, $30
0441+  08C0 23          	mov ah, al
0442+  08C1 07 2F 07    	call putchar
0443+  08C4 09          	ret
0444+  08C5             
0445+  08C5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0446+  08C5             ; PRINT 16BIT HEX INTEGER
0447+  08C5             ; integer value in reg B
0448+  08C5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  08C5             print_u16x:
0450+  08C5 D7          	push a
0451+  08C6 D8          	push b
0452+  08C7 DD          	push bl
0453+  08C8 30          	mov bl, bh
0454+  08C9 07 F6 06    	call itoa				; convert bh to char in A
0455+  08CC 2F          	mov bl, al				; save al
0456+  08CD 19 00       	mov al, 0
0457+  08CF 05 03       	syscall sys_io				; display AH
0458+  08D1 24          	mov ah, bl				; retrieve al
0459+  08D2 19 00       	mov al, 0
0460+  08D4 05 03       	syscall sys_io				; display AL
0461+  08D6             
0462+  08D6 EA          	pop bl
0463+  08D7 07 F6 06    	call itoa				; convert bh to char in A
0464+  08DA 2F          	mov bl, al				; save al
0465+  08DB 19 00       	mov al, 0
0466+  08DD 05 03       	syscall sys_io				; display AH
0467+  08DF 24          	mov ah, bl				; retrieve al
0468+  08E0 19 00       	mov al, 0
0469+  08E2 05 03       	syscall sys_io				; display AL
0470+  08E4             
0471+  08E4 E5          	pop b
0472+  08E5 E4          	pop a
0473+  08E6 09          	ret
0474+  08E7             
0475+  08E7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  08E7             ; INPUT 16BIT HEX INTEGER
0477+  08E7             ; read 16bit integer into A
0478+  08E7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  08E7             scan_u16x:
0480+  08E7 F8 10 00    	enter 16
0481+  08EA D8          	push b
0482+  08EB DA          	push d
0483+  08EC             
0484+  08EC FA F1 FF    	lea d, [bp + -15]
0485+  08EF 07 36 07    	call gets				; get number
0486+  08F2             
0487+  08F2 32          	mov bl, [d]
0488+  08F3 37          	mov bh, bl
0489+  08F4 33 01 00    	mov bl, [d + 1]
0490+  08F7 07 E4 06    	call atoi				; convert to int in AL
0491+  08FA 23          	mov ah, al				; move to AH
0492+  08FB             
0493+  08FB 33 02 00    	mov bl, [d + 2]
0494+  08FE 37          	mov bh, bl
0495+  08FF 33 03 00    	mov bl, [d + 3]
0496+  0902 07 E4 06    	call atoi				; convert to int in AL
0497+  0905             
0498+  0905 E7          	pop d
0499+  0906 E5          	pop b
0500+  0907 F9          	leave
0501+  0908 09          	ret
0502+  0909             
0503+  0909             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0504+  0909             ; PRINT 8bit HEX INTEGER
0505+  0909             ; integer value in reg bl
0506+  0909             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  0909             print_u8x:
0508+  0909 D7          	push a
0509+  090A DD          	push bl
0510+  090B             
0511+  090B 07 F6 06    	call itoa				; convert bl to char in A
0512+  090E 2F          	mov bl, al				; save al
0513+  090F 19 00       	mov al, 0
0514+  0911 05 03       	syscall sys_io				; display AH
0515+  0913 24          	mov ah, bl				; retrieve al
0516+  0914 19 00       	mov al, 0
0517+  0916 05 03       	syscall sys_io				; display AL
0518+  0918             
0519+  0918 EA          	pop bl
0520+  0919 E4          	pop a
0521+  091A 09          	ret
0522+  091B             
0523+  091B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0524+  091B             ; print 8bit decimal unsigned number
0525+  091B             ; input number in AL
0526+  091B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  091B             print_u8d:
0528+  091B D7          	push a
0529+  091C D8          	push b
0530+  091D             
0531+  091D 22 00       	mov ah, 0
0532+  091F 26 64 00    	mov b, 100
0533+  0922 AE          	div a, b
0534+  0923 D8          	push b			; save remainder
0535+  0924 B9 00       	cmp al, 0
0536+  0926 C6 30 09    	je skip100
0537+  0929 6A 30       	add al, $30
0538+  092B 23          	mov ah, al
0539+  092C 19 00       	mov al, 0
0540+  092E 05 03       	syscall sys_io	; print coeff
0541+  0930             skip100:
0542+  0930 E4          	pop a
0543+  0931 22 00       	mov ah, 0
0544+  0933 26 0A 00    	mov b, 10
0545+  0936 AE          	div a, b
0546+  0937 D8          	push b			; save remainder
0547+  0938 B9 00       	cmp al, 0
0548+  093A C6 44 09    	je skip10
0549+  093D 6A 30       	add al, $30
0550+  093F 23          	mov ah, al
0551+  0940 19 00       	mov al, 0
0552+  0942 05 03       	syscall sys_io	; print coeff
0553+  0944             skip10:
0554+  0944 E4          	pop a
0555+  0945 1B          	mov al, bl
0556+  0946 6A 30       	add al, $30
0557+  0948 23          	mov ah, al
0558+  0949 19 00       	mov al, 0
0559+  094B 05 03       	syscall sys_io	; print coeff
0560+  094D E5          	pop b
0561+  094E E4          	pop a
0562+  094F 09          	ret
0563+  0950             
0564+  0950             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0565+  0950             ; INPUT 8BIT HEX INTEGER
0566+  0950             ; read 8bit integer into AL
0567+  0950             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  0950             scan_u8x:
0569+  0950 F8 04 00    	enter 4
0570+  0953 D8          	push b
0571+  0954 DA          	push d
0572+  0955             
0573+  0955 FA FD FF    	lea d, [bp + -3]
0574+  0958 07 36 07    	call gets				; get number
0575+  095B             
0576+  095B 32          	mov bl, [d]
0577+  095C 37          	mov bh, bl
0578+  095D 33 01 00    	mov bl, [d + 1]
0579+  0960 07 E4 06    	call atoi				; convert to int in AL
0580+  0963             
0581+  0963 E7          	pop d
0582+  0964 E5          	pop b
0583+  0965 F9          	leave
0584+  0966 09          	ret
0585+  0967             
0586+  0967             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  0967             ; input decimal number
0588+  0967             ; result in A
0589+  0967             ; 655'\0'
0590+  0967             ; low--------high
0591+  0967             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0592+  0967             scan_u16d:
0593+  0967 F8 08 00    	enter 8
0594+  096A E2          	push si
0595+  096B D8          	push b
0596+  096C D9          	push c
0597+  096D DA          	push d
0598+  096E FA F9 FF    	lea d, [bp +- 7]
0599+  0971 07 36 07    	call gets
0600+  0974 07 64 06    	call strlen			; get string length in C
0601+  0977 7E          	dec c
0602+  0978 FD 4E       	mov si, d
0603+  097A 12          	mov a, c
0604+  097B FD 99       	shl a
0605+  097D 3B CC 06    	mov d, table_power
0606+  0980 59          	add d, a
0607+  0981 38 00 00    	mov c, 0
0608+  0984             mul_loop:
0609+  0984 F6          	lodsb			; load ASCII to al
0610+  0985 B9 00       	cmp al, 0
0611+  0987 C6 9A 09    	je mul_exit
0612+  098A 6F 30       	sub al, $30		; make into integer
0613+  098C 22 00       	mov ah, 0
0614+  098E 2A          	mov b, [d]
0615+  098F AC          	mul a, b			; result in B since it fits in 16bits
0616+  0990 11          	mov a, b
0617+  0991 28          	mov b, c
0618+  0992 54          	add a, b
0619+  0993 39          	mov c, a
0620+  0994 63 02 00    	sub d, 2
0621+  0997 0A 84 09    	jmp mul_loop
0622+  099A             mul_exit:
0623+  099A 12          	mov a, c
0624+  099B E7          	pop d
0625+  099C E6          	pop c
0626+  099D E5          	pop b
0627+  099E EF          	pop si
0628+  099F F9          	leave
0629+  09A0 09          	ret
0279   09A1             ; --- END INCLUDE BLOCK
0280   09A1             
0281   09A1             
0282   09A1             .end
tasm: Number of errors = 0
