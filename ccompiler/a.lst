0001   0000             ; --- FILENAME: polish.c
0002   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0400             .org PROC_TEXT_ORG
0004   0400             
0005   0400             ; --- BEGIN TEXT BLOCK
0006   0400             
0007   0400             main:
0008   0400 D2            push bp
0009   0401 9B            mov bp, sp
0010   0402 52 02 00      sub sp, 2 ; type
0011   0405 52 02 00      sub sp, 2 ; op2
0012   0408 52 64 00      sub sp, 100 ; s
0013   040B             _while1_cond:
0014   040B FA 99 FF      lea d, [bp + -103] ; s_data
0015   040E 2D            mov b, d
0016   040F FD AB         swp b
0017   0411 D8            push b
0018   0412 07 0F 06      call getop
0019   0415 51 02 00      add sp, 2
0020   0418 D7            push a
0021   0419 11            mov a, b
0022   041A 45 FF FF      mov [bp + -1], a ; type
0023   041D E4            pop a
0024   041E D7            push a
0025   041F 11            mov a, b
0026   0420 26 24 00      mov b, '$'
0027   0423 B0            cmp a, b
0028   0424 0E            lodflgs
0029   0425 87 01         and al, %00000001
0030   0427 8F 01         xor al, %00000001 ; !=
0031   0429 22 00         mov ah, 0
0032   042B 27            mov b, a
0033   042C E4            pop a
0034   042D C0 00 00      cmp b, 0
0035   0430 C6 50 05      je _while1_exit
0036   0433             _while1_block:
0037   0433             _switch2_expr:
0038   0433 2C FF FF      mov b, [bp + -1] ; type
0039   0436             _switch2_comparisons:
0040   0436 C0 E7 03      cmp b, 999
0041   0439 C6 59 04      je _switch2_case0
0042   043C C1 2B         cmp bl, '+'
0043   043E C6 72 04      je _switch2_case1
0044   0441 C1 2A         cmp bl, '*'
0045   0443 C6 89 04      je _switch2_case2
0046   0446 C1 2D         cmp bl, '-'
0047   0448 C6 9F 04      je _switch2_case3
0048   044B C1 2F         cmp bl, '/'
0049   044D C6 BF 04      je _switch2_case4
0050   0450 C0 0A 00      cmp b, 10
0051   0453 C6 0A 05      je _switch2_case5
0052   0456 0A 25 05      jmp _switch2_default
0053   0459             _switch2_case0:
0054   0459 FA 99 FF      lea d, [bp + -103] ; s_data
0055   045C 2D            mov b, d
0056   045D FD AB         swp b
0057   045F D8            push b
0058   0460 07 56 05      call _atoi
0059   0463 51 02 00      add sp, 2
0060   0466 FD AB         swp b
0061   0468 D8            push b
0062   0469 07 6B 05      call _push
0063   046C 51 02 00      add sp, 2
0064   046F 0A 4D 05      jmp _switch2_exit ; case break
0065   0472             _switch2_case1:
0066   0472 07 C2 05      call _pop
0067   0475 D7            push a
0068   0476 11            mov a, b
0069   0477 07 C2 05      call _pop
0070   047A 54            add a, b
0071   047B 27            mov b, a
0072   047C E4            pop a
0073   047D FD AB         swp b
0074   047F D8            push b
0075   0480 07 6B 05      call _push
0076   0483 51 02 00      add sp, 2
0077   0486 0A 4D 05      jmp _switch2_exit ; case break
0078   0489             _switch2_case2:
0079   0489 07 C2 05      call _pop
0080   048C D7            push a
0081   048D 11            mov a, b
0082   048E 07 C2 05      call _pop
0083   0491 AC            mul a, b
0084   0492 E4            pop a
0085   0493 FD AB         swp b
0086   0495 D8            push b
0087   0496 07 6B 05      call _push
0088   0499 51 02 00      add sp, 2
0089   049C 0A 4D 05      jmp _switch2_exit ; case break
0090   049F             _switch2_case3:
0091   049F 07 C2 05      call _pop
0092   04A2 D7            push a
0093   04A3 11            mov a, b
0094   04A4 45 FD FF      mov [bp + -3], a ; op2
0095   04A7 E4            pop a
0096   04A8 07 C2 05      call _pop
0097   04AB D7            push a
0098   04AC 11            mov a, b
0099   04AD 2C FD FF      mov b, [bp + -3] ; op2
0100   04B0 60            sub a, b
0101   04B1 27            mov b, a
0102   04B2 E4            pop a
0103   04B3 FD AB         swp b
0104   04B5 D8            push b
0105   04B6 07 6B 05      call _push
0106   04B9 51 02 00      add sp, 2
0107   04BC 0A 4D 05      jmp _switch2_exit ; case break
0108   04BF             _switch2_case4:
0109   04BF 07 C2 05      call _pop
0110   04C2 D7            push a
0111   04C3 11            mov a, b
0112   04C4 45 FD FF      mov [bp + -3], a ; op2
0113   04C7 E4            pop a
0114   04C8             _if3_cond:
0115   04C8 2C FD FF      mov b, [bp + -3] ; op2
0116   04CB D7            push a
0117   04CC 11            mov a, b
0118   04CD 26 00 00      mov b, 0
0119   04D0 B0            cmp a, b
0120   04D1 0E            lodflgs
0121   04D2 87 01         and al, %00000001
0122   04D4 8F 01         xor al, %00000001 ; !=
0123   04D6 22 00         mov ah, 0
0124   04D8 27            mov b, a
0125   04D9 E4            pop a
0126   04DA C0 00 00      cmp b, 0
0127   04DD C6 FB 04      je _if3_else
0128   04E0             _if3_true:
0129   04E0 07 C2 05      call _pop
0130   04E3 D7            push a
0131   04E4 11            mov a, b
0132   04E5 2C FD FF      mov b, [bp + -3] ; op2
0133   04E8 AE            div a, b
0134   04E9 FD 78         mov g, a
0135   04EB 11            mov a, b
0136   04EC FD 27         mov b, g
0137   04EE E4            pop a
0138   04EF FD AB         swp b
0139   04F1 D8            push b
0140   04F2 07 6B 05      call _push
0141   04F5 51 02 00      add sp, 2
0142   04F8 0A 07 05      jmp _if3_exit
0143   04FB             _if3_else:
0144   04FB 26 85 09      mov b, _string_0 ; "Divide by zero error\n"
0145   04FE FD AB         swp b
0146   0500 D8            push b
0147   0501 07 46 08      call print
0148   0504 51 02 00      add sp, 2
0149   0507             _if3_exit:
0150   0507 0A 4D 05      jmp _switch2_exit ; case break
0151   050A             _switch2_case5:
0152   050A 07 C2 05      call _pop
0153   050D FD AB         swp b
0154   050F D8            push b
0155   0510 07 3C 08      call printn
0156   0513 51 02 00      add sp, 2
0157   0516 26 9B 09      mov b, _string_1 ; "\n"
0158   0519 FD AB         swp b
0159   051B D8            push b
0160   051C 07 46 08      call print
0161   051F 51 02 00      add sp, 2
0162   0522 0A 4D 05      jmp _switch2_exit ; case break
0163   0525             _switch2_default:
0164   0525 26 9D 09      mov b, _string_2 ; "Unknown input: "
0165   0528 FD AB         swp b
0166   052A D8            push b
0167   052B 07 46 08      call print
0168   052E 51 02 00      add sp, 2
0169   0531 FA 99 FF      lea d, [bp + -103] ; s_data
0170   0534 2D            mov b, d
0171   0535 FD AB         swp b
0172   0537 D8            push b
0173   0538 07 46 08      call print
0174   053B 51 02 00      add sp, 2
0175   053E 26 9B 09      mov b, _string_1 ; "\n"
0176   0541 FD AB         swp b
0177   0543 D8            push b
0178   0544 07 46 08      call print
0179   0547 51 02 00      add sp, 2
0180   054A 0A 4D 05      jmp _switch2_exit ; case break
0181   054D             _switch2_exit:
0182   054D 0A 0B 04      jmp _while1_cond
0183   0550             _while1_exit:
0184   0550 26 00 00      mov b, 0
0185   0553 F9            leave
0186   0554 05 0B         syscall sys_terminate_proc
0187   0556             
0188   0556             _atoi:
0189   0556 D2            push bp
0190   0557 9B            mov bp, sp
0191   0558 52 02 00      sub sp, 2 ; n
0192   055B             
0193   055B             ; --- BEGIN INLINE ASM BLOCK
0194   055B FA 05 00      lea d, [bp + 5]
0195   055E 15            mov a, [d]
0196   055F 3C            mov d, a
0197   0560 07 1B 0C      call strtoint
0198   0563 45 FF FF      mov [bp + -1], a
0199   0566             ; --- END INLINE ASM BLOCK
0200   0566             
0201   0566 2C FF FF      mov b, [bp + -1] ; n
0202   0569 F9            leave
0203   056A 09            ret
0204   056B             
0205   056B             _push:
0206   056B D2            push bp
0207   056C 9B            mov bp, sp
0208   056D             _if4_cond:
0209   056D 29 51 08      mov b, [_sp] ; _sp
0210   0570 D7            push a
0211   0571 11            mov a, b
0212   0572 26 64 00      mov b, 100
0213   0575 B0            cmp a, b
0214   0576 0E            lodflgs
0215   0577 87 02         and al, %00000010 ; <
0216   0579 FD 9C         shr al
0217   057B 22 00         mov ah, 0
0218   057D 27            mov b, a
0219   057E E4            pop a
0220   057F C0 00 00      cmp b, 0
0221   0582 C6 A8 05      je _if4_else
0222   0585             _if4_true:
0223   0585 29 1B 09      mov b, [val]
0224   0588 74            mov d, b
0225   0589 DA            push d
0226   058A 29 51 08      mov b, [_sp] ; _sp
0227   058D E7            pop d
0228   058E 10 02 00      mov a, 2
0229   0591 AC            mul a, b
0230   0592 5A            add d, b
0231   0593 DA            push d
0232   0594 2C 05 00      mov b, [bp + 5] ; f
0233   0597 E7            pop d
0234   0598 11            mov a, b
0235   0599 43            mov [d], a
0236   059A 29 51 08      mov b, [_sp] ; _sp
0237   059D 11            mov a, b
0238   059E FD 77         inc b
0239   05A0 FD 42 51 08   mov [_sp], b
0240   05A4 27            mov b, a
0241   05A5 0A C0 05      jmp _if4_exit
0242   05A8             _if4_else:
0243   05A8 26 AD 09      mov b, _string_3 ; "Error: stack full, can't _push: "
0244   05AB FD AB         swp b
0245   05AD D8            push b
0246   05AE 07 46 08      call print
0247   05B1 51 02 00      add sp, 2
0248   05B4 2C 05 00      mov b, [bp + 5] ; f
0249   05B7 FD AB         swp b
0250   05B9 D8            push b
0251   05BA 07 3C 08      call printn
0252   05BD 51 02 00      add sp, 2
0253   05C0             _if4_exit:
0254   05C0 F9            leave
0255   05C1 09            ret
0256   05C2             
0257   05C2             _pop:
0258   05C2 D2            push bp
0259   05C3 9B            mov bp, sp
0260   05C4             _if5_cond:
0261   05C4 29 51 08      mov b, [_sp] ; _sp
0262   05C7 D7            push a
0263   05C8 11            mov a, b
0264   05C9 26 00 00      mov b, 0
0265   05CC B0            cmp a, b
0266   05CD 0E            lodflgs
0267   05CE 87 03         and al, %00000011
0268   05D0 B9 00         cmp al, %00000000
0269   05D2 0E            lodflgs
0270   05D3 22 00         mov ah, 0
0271   05D5 27            mov b, a
0272   05D6 E4            pop a
0273   05D7 C0 00 00      cmp b, 0
0274   05DA C6 FE 05      je _if5_else
0275   05DD             _if5_true:
0276   05DD 29 51 08      mov b, [_sp] ; _sp
0277   05E0 11            mov a, b
0278   05E1 FD 7D         dec b
0279   05E3 FD 42 51 08   mov [_sp], b
0280   05E7 27            mov b, a
0281   05E8 29 1B 09      mov b, [val]
0282   05EB D7            push a
0283   05EC 74            mov d, b
0284   05ED DA            push d
0285   05EE 29 51 08      mov b, [_sp] ; _sp
0286   05F1 E7            pop d
0287   05F2 10 02 00      mov a, 2
0288   05F5 AC            mul a, b
0289   05F6 5A            add d, b
0290   05F7 2A            mov b, [d]
0291   05F8 E4            pop a
0292   05F9 F9            leave
0293   05FA 09            ret
0294   05FB 0A 0F 06      jmp _if5_exit
0295   05FE             _if5_else:
0296   05FE 26 CD 09      mov b, _string_4 ; "Error: stack empty.\n"
0297   0601 FD AB         swp b
0298   0603 D8            push b
0299   0604 07 46 08      call print
0300   0607 51 02 00      add sp, 2
0301   060A 26 00 00      mov b, 0
0302   060D F9            leave
0303   060E 09            ret
0304   060F             _if5_exit:
0305   060F             
0306   060F             getop:
0307   060F D2            push bp
0308   0610 9B            mov bp, sp
0309   0611 52 02 00      sub sp, 2 ; i
0310   0614 52 01 00      sub sp, 1 ; c
0311   0617             _while6_cond:
0312   0617 FA 05 00      lea d, [bp + 5] ; s
0313   061A 2A            mov b, [d]
0314   061B 74            mov d, b
0315   061C DA            push d
0316   061D 26 00 00      mov b, 0
0317   0620 E7            pop d
0318   0621 10 01 00      mov a, 1
0319   0624 AC            mul a, b
0320   0625 5A            add d, b
0321   0626 DA            push d
0322   0627 07 1E 07      call getch
0323   062A DB            push al
0324   062B 1B            mov al, bl
0325   062C 40 FE FF      mov [bp + -2], al ; c
0326   062F E8            pop al
0327   0630 E7            pop d
0328   0631 1B            mov al, bl
0329   0632 3E            mov [d], al
0330   0633 D7            push a
0331   0634 11            mov a, b
0332   0635 26 20 00      mov b, ' '
0333   0638 B0            cmp a, b
0334   0639 0E            lodflgs
0335   063A 87 01         and al, %00000001 ; ==
0336   063C 22 00         mov ah, 0
0337   063E 27            mov b, a
0338   063F E4            pop a
0339   0640 C0 00 00      cmp b, 0
0340   0643 C6 49 06      je _while6_exit
0341   0646             _while6_block:
0342   0646 0A 17 06      jmp _while6_cond
0343   0649             _while6_exit:
0344   0649 FA 05 00      lea d, [bp + 5] ; s
0345   064C 2A            mov b, [d]
0346   064D 74            mov d, b
0347   064E DA            push d
0348   064F 26 01 00      mov b, 1
0349   0652 E7            pop d
0350   0653 10 01 00      mov a, 1
0351   0656 AC            mul a, b
0352   0657 5A            add d, b
0353   0658 DA            push d
0354   0659 26 00 00      mov b, 0
0355   065C E7            pop d
0356   065D 1B            mov al, bl
0357   065E 3E            mov [d], al
0358   065F             _if7_cond:
0359   065F 34 FE FF      mov bl, [bp + -2] ; c
0360   0662 A7 00         mov bh, 0
0361   0664 DD            push bl
0362   0665 07 B3 07      call isdigit
0363   0668 51 01 00      add sp, 1
0364   066B DB            push al
0365   066C C0 00 00      cmp b, 0
0366   066F 0E            lodflgs
0367   0670 87 01         and al, %00000001 ; transform logical not condition result into a single bit
0368   0672 2F            mov bl, al
0369   0673 A7 00         mov bh, 0
0370   0675 E8            pop al
0371   0676 C0 00 00      cmp b, 0
0372   0679 C6 86 06      je _if7_exit
0373   067C             _if7_true:
0374   067C 34 FE FF      mov bl, [bp + -2] ; c
0375   067F A7 00         mov bh, 0
0376   0681 F9            leave
0377   0682 09            ret
0378   0683 0A 86 06      jmp _if7_exit
0379   0686             _if7_exit:
0380   0686 26 00 00      mov b, 0
0381   0689 D7            push a
0382   068A 11            mov a, b
0383   068B 45 FF FF      mov [bp + -1], a ; i
0384   068E E4            pop a
0385   068F             _if8_cond:
0386   068F 34 FE FF      mov bl, [bp + -2] ; c
0387   0692 A7 00         mov bh, 0
0388   0694 DD            push bl
0389   0695 07 B3 07      call isdigit
0390   0698 51 01 00      add sp, 1
0391   069B C0 00 00      cmp b, 0
0392   069E C6 DA 06      je _if8_exit
0393   06A1             _if8_true:
0394   06A1             _while9_cond:
0395   06A1 FA 05 00      lea d, [bp + 5] ; s
0396   06A4 2A            mov b, [d]
0397   06A5 74            mov d, b
0398   06A6 DA            push d
0399   06A7 2C FF FF      mov b, [bp + -1] ; i
0400   06AA 11            mov a, b
0401   06AB FD 77         inc b
0402   06AD D7            push a
0403   06AE 11            mov a, b
0404   06AF 45 FF FF      mov [bp + -1], a ; i
0405   06B2 E4            pop a
0406   06B3 27            mov b, a
0407   06B4 E7            pop d
0408   06B5 10 01 00      mov a, 1
0409   06B8 AC            mul a, b
0410   06B9 5A            add d, b
0411   06BA DA            push d
0412   06BB 07 1E 07      call getch
0413   06BE DB            push al
0414   06BF 1B            mov al, bl
0415   06C0 40 FE FF      mov [bp + -2], al ; c
0416   06C3 E8            pop al
0417   06C4 E7            pop d
0418   06C5 1B            mov al, bl
0419   06C6 3E            mov [d], al
0420   06C7 DD            push bl
0421   06C8 07 B3 07      call isdigit
0422   06CB 51 01 00      add sp, 1
0423   06CE C0 00 00      cmp b, 0
0424   06D1 C6 D7 06      je _while9_exit
0425   06D4             _while9_block:
0426   06D4 0A A1 06      jmp _while9_cond
0427   06D7             _while9_exit:
0428   06D7 0A DA 06      jmp _if8_exit
0429   06DA             _if8_exit:
0430   06DA FA 05 00      lea d, [bp + 5] ; s
0431   06DD 2A            mov b, [d]
0432   06DE 74            mov d, b
0433   06DF DA            push d
0434   06E0 2C FF FF      mov b, [bp + -1] ; i
0435   06E3 E7            pop d
0436   06E4 10 01 00      mov a, 1
0437   06E7 AC            mul a, b
0438   06E8 5A            add d, b
0439   06E9 DA            push d
0440   06EA 26 00 00      mov b, 0
0441   06ED E7            pop d
0442   06EE 1B            mov al, bl
0443   06EF 3E            mov [d], al
0444   06F0             _if10_cond:
0445   06F0 34 FE FF      mov bl, [bp + -2] ; c
0446   06F3 A7 00         mov bh, 0
0447   06F5 D7            push a
0448   06F6 11            mov a, b
0449   06F7 26 24 00      mov b, '$'
0450   06FA B0            cmp a, b
0451   06FB 0E            lodflgs
0452   06FC 87 01         and al, %00000001
0453   06FE 8F 01         xor al, %00000001 ; !=
0454   0700 22 00         mov ah, 0
0455   0702 27            mov b, a
0456   0703 E4            pop a
0457   0704 C0 00 00      cmp b, 0
0458   0707 C6 19 07      je _if10_exit
0459   070A             _if10_true:
0460   070A 34 FE FF      mov bl, [bp + -2] ; c
0461   070D A7 00         mov bh, 0
0462   070F DD            push bl
0463   0710 07 61 07      call ungetch
0464   0713 51 01 00      add sp, 1
0465   0716 0A 19 07      jmp _if10_exit
0466   0719             _if10_exit:
0467   0719 26 E7 03      mov b, 999
0468   071C F9            leave
0469   071D 09            ret
0470   071E             
0471   071E             getch:
0472   071E D2            push bp
0473   071F 9B            mov bp, sp
0474   0720             _if11_cond:
0475   0720 29 83 09      mov b, [bufp] ; bufp
0476   0723 D7            push a
0477   0724 11            mov a, b
0478   0725 26 00 00      mov b, 0
0479   0728 B0            cmp a, b
0480   0729 0E            lodflgs
0481   072A 87 03         and al, %00000011
0482   072C B9 00         cmp al, %00000000
0483   072E 0E            lodflgs
0484   072F 22 00         mov ah, 0
0485   0731 27            mov b, a
0486   0732 E4            pop a
0487   0733 C0 00 00      cmp b, 0
0488   0736 C6 5C 07      je _if11_else
0489   0739             _if11_true:
0490   0739 29 83 09      mov b, [bufp] ; bufp
0491   073C 11            mov a, b
0492   073D FD 7D         dec b
0493   073F FD 42 83 09   mov [bufp], b
0494   0743 27            mov b, a
0495   0744 29 81 09      mov b, [buf]
0496   0747 D7            push a
0497   0748 74            mov d, b
0498   0749 DA            push d
0499   074A 29 83 09      mov b, [bufp] ; bufp
0500   074D E7            pop d
0501   074E 10 01 00      mov a, 1
0502   0751 AC            mul a, b
0503   0752 5A            add d, b
0504   0753 32            mov bl, [d]
0505   0754 A7 00         mov bh, 0
0506   0756 E4            pop a
0507   0757 F9            leave
0508   0758 09            ret
0509   0759 0A 61 07      jmp _if11_exit
0510   075C             _if11_else:
0511   075C 07 11 08      call _getchar
0512   075F F9            leave
0513   0760 09            ret
0514   0761             _if11_exit:
0515   0761             
0516   0761             ungetch:
0517   0761 D2            push bp
0518   0762 9B            mov bp, sp
0519   0763             _if12_cond:
0520   0763 29 83 09      mov b, [bufp] ; bufp
0521   0766 D7            push a
0522   0767 11            mov a, b
0523   0768 26 64 00      mov b, 100
0524   076B B0            cmp a, b
0525   076C 0E            lodflgs
0526   076D 87 03         and al, %00000011
0527   076F 8F 02         xor al, %00000010 ; >=
0528   0771 B9 00         cmp al, 0
0529   0773 0E            lodflgs
0530   0774 8F 01         xor al, %00000001
0531   0776 22 00         mov ah, 0
0532   0778 27            mov b, a
0533   0779 E4            pop a
0534   077A C0 00 00      cmp b, 0
0535   077D C6 8F 07      je _if12_else
0536   0780             _if12_true:
0537   0780 26 E2 09      mov b, _string_5 ; "Error: too many characters.\n"
0538   0783 FD AB         swp b
0539   0785 D8            push b
0540   0786 07 46 08      call print
0541   0789 51 02 00      add sp, 2
0542   078C 0A B1 07      jmp _if12_exit
0543   078F             _if12_else:
0544   078F 29 81 09      mov b, [buf]
0545   0792 74            mov d, b
0546   0793 DA            push d
0547   0794 29 83 09      mov b, [bufp] ; bufp
0548   0797 E7            pop d
0549   0798 10 01 00      mov a, 1
0550   079B AC            mul a, b
0551   079C 5A            add d, b
0552   079D DA            push d
0553   079E 34 05 00      mov bl, [bp + 5] ; c
0554   07A1 A7 00         mov bh, 0
0555   07A3 E7            pop d
0556   07A4 1B            mov al, bl
0557   07A5 3E            mov [d], al
0558   07A6 29 83 09      mov b, [bufp] ; bufp
0559   07A9 11            mov a, b
0560   07AA FD 77         inc b
0561   07AC FD 42 83 09   mov [bufp], b
0562   07B0 27            mov b, a
0563   07B1             _if12_exit:
0564   07B1 F9            leave
0565   07B2 09            ret
0566   07B3             
0567   07B3             isdigit:
0568   07B3 D2            push bp
0569   07B4 9B            mov bp, sp
0570   07B5             _if13_cond:
0571   07B5 34 05 00      mov bl, [bp + 5] ; c
0572   07B8 A7 00         mov bh, 0
0573   07BA D7            push a
0574   07BB 11            mov a, b
0575   07BC 26 30 00      mov b, '0'
0576   07BF B0            cmp a, b
0577   07C0 0E            lodflgs
0578   07C1 87 03         and al, %00000011
0579   07C3 8F 02         xor al, %00000010 ; >=
0580   07C5 B9 00         cmp al, 0
0581   07C7 0E            lodflgs
0582   07C8 8F 01         xor al, %00000001
0583   07CA 22 00         mov ah, 0
0584   07CC 27            mov b, a
0585   07CD E4            pop a
0586   07CE D7            push a
0587   07CF 11            mov a, b
0588   07D0 AF 00 00      cmp a, 0
0589   07D3 0E            lodflgs
0590   07D4 96            not al
0591   07D5 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
0592   07D7 34 05 00      mov bl, [bp + 5] ; c
0593   07DA A7 00         mov bh, 0
0594   07DC D7            push a
0595   07DD 11            mov a, b
0596   07DE 26 39 00      mov b, '9'
0597   07E1 B0            cmp a, b
0598   07E2 0E            lodflgs
0599   07E3 87 03         and al, %00000011 ; <=
0600   07E5 B9 00         cmp al, 0
0601   07E7 0E            lodflgs
0602   07E8 8F 01         xor al, %00000001
0603   07EA 22 00         mov ah, 0
0604   07EC 22 00         mov ah, 0
0605   07EE 27            mov b, a
0606   07EF E4            pop a
0607   07F0 DB            push al
0608   07F1 C0 00 00      cmp b, 0
0609   07F4 0E            lodflgs
0610   07F5 96            not al
0611   07F6 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
0612   07F8 EA            pop bl
0613   07F9 88            and al, bl
0614   07FA 2F            mov bl, al
0615   07FB A7 00         mov bh, 0
0616   07FD E4            pop a
0617   07FE C0 00 00      cmp b, 0
0618   0801 C6 0C 08      je _if13_else
0619   0804             _if13_true:
0620   0804 26 01 00      mov b, 1
0621   0807 F9            leave
0622   0808 09            ret
0623   0809 0A 11 08      jmp _if13_exit
0624   080C             _if13_else:
0625   080C 26 00 00      mov b, 0
0626   080F F9            leave
0627   0810 09            ret
0628   0811             _if13_exit:
0629   0811             
0630   0811             _getchar:
0631   0811 D2            push bp
0632   0812 9B            mov bp, sp
0633   0813 52 01 00      sub sp, 1 ; c
0634   0816             
0635   0816             ; --- BEGIN INLINE ASM BLOCK
0636   0816 07 03 0B      call getchar
0637   0819 1A            mov al, ah
0638   081A 40 00 00      mov [bp + 0], al
0639   081D             ; --- END INLINE ASM BLOCK
0640   081D             
0641   081D 34 00 00      mov bl, [bp + 0] ; c
0642   0820 A7 00         mov bh, 0
0643   0822 F9            leave
0644   0823 09            ret
0645   0824             
0646   0824             scann:
0647   0824 D2            push bp
0648   0825 9B            mov bp, sp
0649   0826 52 02 00      sub sp, 2 ; m
0650   0829             
0651   0829             ; --- BEGIN INLINE ASM BLOCK
0652   0829 07 49 0D      call scan_u16d
0653   082C 45 FF FF      mov [bp + -1], a
0654   082F             ; --- END INLINE ASM BLOCK
0655   082F             
0656   082F FA 05 00      lea d, [bp + 5] ; n
0657   0832 2A            mov b, [d]
0658   0833 D8            push b
0659   0834 2C FF FF      mov b, [bp + -1] ; m
0660   0837 E7            pop d
0661   0838 11            mov a, b
0662   0839 43            mov [d], a
0663   083A F9            leave
0664   083B 09            ret
0665   083C             
0666   083C             printn:
0667   083C D2            push bp
0668   083D 9B            mov bp, sp
0669   083E             
0670   083E             ; --- BEGIN INLINE ASM BLOCK
0671   083E 17 05 00      mov a, [bp + 5]
0672   0841 07 74 0C      call print_u16d
0673   0844             ; --- END INLINE ASM BLOCK
0674   0844             
0675   0844 F9            leave
0676   0845 09            ret
0677   0846             
0678   0846             print:
0679   0846 D2            push bp
0680   0847 9B            mov bp, sp
0681   0848             
0682   0848             ; --- BEGIN INLINE ASM BLOCK
0683   0848 17 05 00      mov a, [bp + 5]
0684   084B 3C            mov d, a
0685   084C 07 4B 0C      call puts
0686   084F             ; --- END INLINE ASM BLOCK
0687   084F             
0688   084F F9            leave
0689   0850 09            ret
0690   0851             ; --- END TEXT BLOCK
0691   0851             
0692   0851             ; --- BEGIN DATA BLOCK
0693   0851 00 00       _sp: .dw 0
0694   0853 00 00 00 00 val_data: .fill 200, 0
0694   0857 00 00 00 00 
0694   085B 00 00 00 00 
0694   085F 00 00 00 00 
0694   0863 00 00 00 00 
0694   0867 00 00 00 00 
0694   086B 00 00 00 00 
0694   086F 00 00 00 00 
0694   0873 00 00 00 00 
0694   0877 00 00 00 00 
0694   087B 00 00 00 00 
0694   087F 00 00 00 00 
0694   0883 00 00 00 00 
0694   0887 00 00 00 00 
0694   088B 00 00 00 00 
0694   088F 00 00 00 00 
0694   0893 00 00 00 00 
0694   0897 00 00 00 00 
0694   089B 00 00 00 00 
0694   089F 00 00 00 00 
0694   08A3 00 00 00 00 
0694   08A7 00 00 00 00 
0694   08AB 00 00 00 00 
0694   08AF 00 00 00 00 
0694   08B3 00 00 00 00 
0694   08B7 00 00 00 00 
0694   08BB 00 00 00 00 
0694   08BF 00 00 00 00 
0694   08C3 00 00 00 00 
0694   08C7 00 00 00 00 
0694   08CB 00 00 00 00 
0694   08CF 00 00 00 00 
0694   08D3 00 00 00 00 
0694   08D7 00 00 00 00 
0694   08DB 00 00 00 00 
0694   08DF 00 00 00 00 
0694   08E3 00 00 00 00 
0694   08E7 00 00 00 00 
0694   08EB 00 00 00 00 
0694   08EF 00 00 00 00 
0694   08F3 00 00 00 00 
0694   08F7 00 00 00 00 
0694   08FB 00 00 00 00 
0694   08FF 00 00 00 00 
0694   0903 00 00 00 00 
0694   0907 00 00 00 00 
0694   090B 00 00 00 00 
0694   090F 00 00 00 00 
0694   0913 00 00 00 00 
0694   0917 00 00 00 00 
0695   091B 53 08       val: .dw val_data
0696   091D 00 00 00 00 buf_data: .fill 100, 0
0696   0921 00 00 00 00 
0696   0925 00 00 00 00 
0696   0929 00 00 00 00 
0696   092D 00 00 00 00 
0696   0931 00 00 00 00 
0696   0935 00 00 00 00 
0696   0939 00 00 00 00 
0696   093D 00 00 00 00 
0696   0941 00 00 00 00 
0696   0945 00 00 00 00 
0696   0949 00 00 00 00 
0696   094D 00 00 00 00 
0696   0951 00 00 00 00 
0696   0955 00 00 00 00 
0696   0959 00 00 00 00 
0696   095D 00 00 00 00 
0696   0961 00 00 00 00 
0696   0965 00 00 00 00 
0696   0969 00 00 00 00 
0696   096D 00 00 00 00 
0696   0971 00 00 00 00 
0696   0975 00 00 00 00 
0696   0979 00 00 00 00 
0696   097D 00 00 00 00 
0697   0981 1D 09       buf: .dw buf_data
0698   0983 00 00       bufp: .dw 0
0699   0985 44 69 76 69 _string_0: .db "Divide by zero error\n", 0
0699   0989 64 65 20 62 
0699   098D 79 20 7A 65 
0699   0991 72 6F 20 65 
0699   0995 72 72 6F 72 
0699   0999 0A 00 
0700   099B 0A 00       _string_1: .db "\n", 0
0701   099D 55 6E 6B 6E _string_2: .db "Unknown input: ", 0
0701   09A1 6F 77 6E 20 
0701   09A5 69 6E 70 75 
0701   09A9 74 3A 20 00 
0702   09AD 45 72 72 6F _string_3: .db "Error: stack full, can't _push: ", 0
0702   09B1 72 3A 20 73 
0702   09B5 74 61 63 6B 
0702   09B9 20 66 75 6C 
0702   09BD 6C 2C 20 63 
0702   09C1 61 6E 27 74 
0702   09C5 20 5F 70 75 
0702   09C9 73 68 3A 20 
0703   09CD 45 72 72 6F _string_4: .db "Error: stack empty.\n", 0
0703   09D1 72 3A 20 73 
0703   09D5 74 61 63 6B 
0703   09D9 20 65 6D 70 
0703   09DD 74 79 2E 0A 
0703   09E1 00 
0704   09E2 45 72 72 6F _string_5: .db "Error: too many characters.\n", 0
0704   09E6 72 3A 20 74 
0704   09EA 6F 6F 20 6D 
0704   09EE 61 6E 79 20 
0704   09F2 63 68 61 72 
0704   09F6 61 63 74 65 
0704   09FA 72 73 2E 0A 
0704   09FE 00 
0705   09FF             ; --- END DATA BLOCK
0706   09FF             
0707   09FF             ; --- BEGIN INCLUDE BLOCK
0708   09FF             .include "lib/stdio.asm"
0001+  09FF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  09FF             ; stdio.s
0003+  09FF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  09FF             .include "lib/string.asm"
0001++ 09FF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 09FF             ; string.s
0003++ 09FF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 09FF             
0005++ 09FF             
0006++ 09FF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 09FF             ; strrev
0008++ 09FF             ; reverse a string
0009++ 09FF             ; D = string address
0010++ 09FF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 09FF             ; 01234
0012++ 09FF             strrev:
0013++ 09FF 4B          	pusha
0014++ 0A00 07 46 0A    	call strlen	; length in C
0015++ 0A03 12          	mov a, c
0016++ 0A04 AF 01 00    	cmp a, 1
0017++ 0A07 D0 21 0A    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0A0A 7D          	dec a
0019++ 0A0B FD 4E       	mov si, d	; beginning of string
0020++ 0A0D FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0A0F 59          	add d, a	; end of string
0022++ 0A10 12          	mov a, c
0023++ 0A11 FD 9B       	shr a		; divide by 2
0024++ 0A13 39          	mov c, a	; C now counts the steps
0025++ 0A14             strrev_L0:
0026++ 0A14 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0A15 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0A16 3E          	mov [d], al	; store left char into right side
0029++ 0A17 1B          	mov al, bl
0030++ 0A18 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0A19 7E          	dec c
0032++ 0A1A 7F          	dec d
0033++ 0A1B C2 00 00    	cmp c, 0
0034++ 0A1E C7 14 0A    	jne strrev_L0
0035++ 0A21             strrev_end:
0036++ 0A21 4C          	popa
0037++ 0A22 09          	ret
0038++ 0A23             	
0039++ 0A23             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0A23             ; strchr
0041++ 0A23             ; search string in D for char in AL
0042++ 0A23             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0A23             strchr:
0044++ 0A23             strchr_L0:
0045++ 0A23 32          	mov bl, [d]
0046++ 0A24 C1 00       	cmp bl, 0
0047++ 0A26 C6 31 0A    	je strchr_end
0048++ 0A29 BA          	cmp al, bl
0049++ 0A2A C6 31 0A    	je strchr_end
0050++ 0A2D 79          	inc d
0051++ 0A2E 0A 23 0A    	jmp strchr_L0
0052++ 0A31             strchr_end:
0053++ 0A31 1B          	mov al, bl
0054++ 0A32 09          	ret
0055++ 0A33             
0056++ 0A33             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0A33             ; strstr
0058++ 0A33             ; find sub-string
0059++ 0A33             ; str1 in SI
0060++ 0A33             ; str2 in DI
0061++ 0A33             ; SI points to end of source string
0062++ 0A33             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0A33             strstr:
0064++ 0A33 DB          	push al
0065++ 0A34 DA          	push d
0066++ 0A35 E3          	push di
0067++ 0A36             strstr_loop:
0068++ 0A36 F3          	cmpsb					; compare a byte of the strings
0069++ 0A37 C7 42 0A    	jne strstr_ret
0070++ 0A3A FC 00 00    	lea d, [di + 0]
0071++ 0A3D BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0A3F C7 36 0A    	jne strstr_loop				; equal chars but not at end
0073++ 0A42             strstr_ret:
0074++ 0A42 F0          	pop di
0075++ 0A43 E7          	pop d
0076++ 0A44 E8          	pop al
0077++ 0A45 09          	ret
0078++ 0A46             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0A46             ; length of null terminated string
0080++ 0A46             ; result in C
0081++ 0A46             ; pointer in D
0082++ 0A46             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0A46             strlen:
0084++ 0A46 DA          	push d
0085++ 0A47 38 00 00    	mov c, 0
0086++ 0A4A             strlen_L1:
0087++ 0A4A BD 00       	cmp byte [d], 0
0088++ 0A4C C6 54 0A    	je strlen_ret
0089++ 0A4F 79          	inc d
0090++ 0A50 78          	inc c
0091++ 0A51 0A 4A 0A    	jmp strlen_L1
0092++ 0A54             strlen_ret:
0093++ 0A54 E7          	pop d
0094++ 0A55 09          	ret
0095++ 0A56             
0096++ 0A56             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0A56             ; STRCMP
0098++ 0A56             ; compare two strings
0099++ 0A56             ; str1 in SI
0100++ 0A56             ; str2 in DI
0101++ 0A56             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0A56             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0A56             strcmp:
0104++ 0A56 DB          	push al
0105++ 0A57 DA          	push d
0106++ 0A58 E3          	push di
0107++ 0A59 E2          	push si
0108++ 0A5A             strcmp_loop:
0109++ 0A5A F3          	cmpsb					; compare a byte of the strings
0110++ 0A5B C7 66 0A    	jne strcmp_ret
0111++ 0A5E FB FF FF    	lea d, [si +- 1]
0112++ 0A61 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0A63 C7 5A 0A    	jne strcmp_loop				; equal chars but not at end
0114++ 0A66             strcmp_ret:
0115++ 0A66 EF          	pop si
0116++ 0A67 F0          	pop di
0117++ 0A68 E7          	pop d
0118++ 0A69 E8          	pop al
0119++ 0A6A 09          	ret
0120++ 0A6B             
0121++ 0A6B             
0122++ 0A6B             ; STRCPY
0123++ 0A6B             ; copy null terminated string from SI to DI
0124++ 0A6B             ; source in SI
0125++ 0A6B             ; destination in DI
0126++ 0A6B             strcpy:
0127++ 0A6B E2          	push si
0128++ 0A6C E3          	push di
0129++ 0A6D DB          	push al
0130++ 0A6E             strcpy_L1:
0131++ 0A6E F6          	lodsb
0132++ 0A6F F7          	stosb
0133++ 0A70 B9 00       	cmp al, 0
0134++ 0A72 C7 6E 0A    	jne strcpy_L1
0135++ 0A75             strcpy_end:
0136++ 0A75 E8          	pop al
0137++ 0A76 F0          	pop di
0138++ 0A77 EF          	pop si
0139++ 0A78 09          	ret
0140++ 0A79             
0141++ 0A79             ; STRCAT
0142++ 0A79             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0A79             ; source in SI
0144++ 0A79             ; destination in DI
0145++ 0A79             strcat:
0146++ 0A79 E2          	push si
0147++ 0A7A E3          	push di
0148++ 0A7B D7          	push a
0149++ 0A7C DA          	push d
0150++ 0A7D 50          	mov a, di
0151++ 0A7E 3C          	mov d, a
0152++ 0A7F             strcat_goto_end_L1:
0153++ 0A7F BD 00       	cmp byte[d], 0
0154++ 0A81 C6 88 0A    	je strcat_start
0155++ 0A84 79          	inc d
0156++ 0A85 0A 7F 0A    	jmp strcat_goto_end_L1
0157++ 0A88             strcat_start:
0158++ 0A88 FD 50       	mov di, d
0159++ 0A8A             strcat_L1:
0160++ 0A8A F6          	lodsb
0161++ 0A8B F7          	stosb
0162++ 0A8C B9 00       	cmp al, 0
0163++ 0A8E C7 8A 0A    	jne strcat_L1
0164++ 0A91             strcat_end:
0165++ 0A91 E7          	pop d
0166++ 0A92 E4          	pop a
0167++ 0A93 F0          	pop di
0168++ 0A94 EF          	pop si
0169++ 0A95 09          	ret
0005+  0A96             
0006+  0A96 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  0A9A 34 35 36 37 
0006+  0A9E 38 39 41 42 
0006+  0AA2 43 44 45 46 
0007+  0AA6 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  0AAA 1B 5B 48 00 
0008+  0AAE             
0009+  0AAE 01 00       table_power:.dw 1
0010+  0AB0 0A 00       			.dw 10
0011+  0AB2 64 00       			.dw 100
0012+  0AB4 E8 03       			.dw 1000
0013+  0AB6 10 27       			.dw 10000
0014+  0AB8             
0015+  0AB8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  0AB8             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  0AB8             ; ASCII in BL
0018+  0AB8             ; result in AL
0019+  0AB8             ; ascii for F = 0100 0110
0020+  0AB8             ; ascii for 9 = 0011 1001
0021+  0AB8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  0AB8             hex_ascii_encode:
0023+  0AB8 1B          	mov al, bl
0024+  0AB9 93 40       	test al, $40				; test if letter or number
0025+  0ABB C7 C1 0A    	jnz hex_letter
0026+  0ABE 87 0F       	and al, $0F				; get number
0027+  0AC0 09          	ret
0028+  0AC1             hex_letter:
0029+  0AC1 87 0F       	and al, $0F				; get letter
0030+  0AC3 6A 09       	add al, 9
0031+  0AC5 09          	ret
0032+  0AC6             
0033+  0AC6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  0AC6             ; ATOI
0035+  0AC6             ; 2 letter hex string in B
0036+  0AC6             ; 8bit integer returned in AL
0037+  0AC6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0AC6             atoi:
0039+  0AC6 D8          	push b
0040+  0AC7 07 B8 0A    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  0ACA 30          	mov bl, bh
0042+  0ACB DB          	push al					; save a
0043+  0ACC 07 B8 0A    	call hex_ascii_encode
0044+  0ACF EA          	pop bl	
0045+  0AD0 FD 9E 04    	shl al, 4
0046+  0AD3 8C          	or al, bl
0047+  0AD4 E5          	pop b
0048+  0AD5 09          	ret	
0049+  0AD6             
0050+  0AD6             
0051+  0AD6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  0AD6             ; printf
0053+  0AD6             ; no need for explanations!
0054+  0AD6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0AD6             printf:
0056+  0AD6 09          	ret
0057+  0AD7             
0058+  0AD7             
0059+  0AD7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  0AD7             ; scanf
0061+  0AD7             ; no need for explanations!
0062+  0AD7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  0AD7             scanf:
0064+  0AD7 09          	ret
0065+  0AD8             
0066+  0AD8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  0AD8             ; ITOA
0068+  0AD8             ; 8bit value in BL
0069+  0AD8             ; 2 byte ASCII result in A
0070+  0AD8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  0AD8             itoa:
0072+  0AD8 DA          	push d
0073+  0AD9 D8          	push b
0074+  0ADA A7 00       	mov bh, 0
0075+  0ADC FD A4 04    	shr bl, 4	
0076+  0ADF 74          	mov d, b
0077+  0AE0 1F 96 0A    	mov al, [d + s_hex_digits]
0078+  0AE3 23          	mov ah, al
0079+  0AE4             	
0080+  0AE4 E5          	pop b
0081+  0AE5 D8          	push b
0082+  0AE6 A7 00       	mov bh, 0
0083+  0AE8 FD 87 0F    	and bl, $0F
0084+  0AEB 74          	mov d, b
0085+  0AEC 1F 96 0A    	mov al, [d + s_hex_digits]
0086+  0AEF E5          	pop b
0087+  0AF0 E7          	pop d
0088+  0AF1 09          	ret
0089+  0AF2             
0090+  0AF2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  0AF2             ; HEX STRING TO BINARY
0092+  0AF2             ; di = destination address
0093+  0AF2             ; si = source
0094+  0AF2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  0AF2             hex_to_int:
0096+  0AF2             hex_to_int_L1:
0097+  0AF2 F6          	lodsb					; load from [SI] to AL
0098+  0AF3 B9 00       	cmp al, 0				; check if ASCII 0
0099+  0AF5 C6 02 0B    	jz hex_to_int_ret
0100+  0AF8 36          	mov bh, al
0101+  0AF9 F6          	lodsb
0102+  0AFA 2F          	mov bl, al
0103+  0AFB 07 C6 0A    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  0AFE F7          	stosb					; store AL to [DI]
0105+  0AFF 0A F2 0A    	jmp hex_to_int_L1
0106+  0B02             hex_to_int_ret:
0107+  0B02 09          	ret		
0108+  0B03             
0109+  0B03             
0110+  0B03             
0111+  0B03             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  0B03             ; GETCHAR
0113+  0B03             ; char in ah
0114+  0B03             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  0B03             getchar:
0116+  0B03 DB          	push al
0117+  0B04             getchar_retry:
0118+  0B04 FD 0C       	sti
0119+  0B06 19 01       	mov al, 1
0120+  0B08 05 03       	syscall sys_io			; receive in AH
0121+  0B0A B9 00       	cmp al, 0			; check if any char was receive
0122+  0B0C C6 04 0B    	je getchar_retry
0123+  0B0F E8          	pop al
0124+  0B10 09          	ret
0125+  0B11             
0126+  0B11             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  0B11             ; PUTCHAR
0128+  0B11             ; char in ah
0129+  0B11             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0B11             putchar:
0131+  0B11 D7          	push a
0132+  0B12 19 00       	mov al, 0
0133+  0B14 05 03       	syscall sys_io			; char in AH
0134+  0B16 E4          	pop a
0135+  0B17 09          	ret
0136+  0B18             
0137+  0B18             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  0B18             ;; INPUT A STRING
0139+  0B18             ;; terminates with null
0140+  0B18             ;; pointer in D
0141+  0B18             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  0B18             gets:
0143+  0B18 D7          	push a
0144+  0B19 DA          	push d
0145+  0B1A             gets_loop:
0146+  0B1A FD 0C       	sti
0147+  0B1C 19 01       	mov al, 1
0148+  0B1E 05 03       	syscall sys_io			; receive in AH
0149+  0B20 B9 00       	cmp al, 0				; check error code (AL)
0150+  0B22 C6 1A 0B    	je gets_loop			; if no char received, retry
0151+  0B25             
0152+  0B25 76 1B       	cmp ah, 27
0153+  0B27 C6 48 0B    	je gets_telnet_escape
0154+  0B2A 76 0A       	cmp ah, $0A				; LF
0155+  0B2C C6 A1 0B    	je gets_end
0156+  0B2F 76 0D       	cmp ah, $0D				; CR
0157+  0B31 C6 A1 0B    	je gets_end
0158+  0B34 76 5C       	cmp ah, $5C				; '\\'
0159+  0B36 C6 78 0B    	je gets_escape
0160+  0B39             	
0161+  0B39 76 08       	cmp ah, $08			; check for backspace
0162+  0B3B C6 44 0B    	je gets_backspace
0163+  0B3E             
0164+  0B3E 1A          	mov al, ah
0165+  0B3F 3E          	mov [d], al
0166+  0B40 79          	inc d
0167+  0B41 0A 1A 0B    	jmp gets_loop
0168+  0B44             gets_backspace:
0169+  0B44 7F          	dec d
0170+  0B45 0A 1A 0B    	jmp gets_loop
0171+  0B48             gets_telnet_escape:
0172+  0B48 FD 0C       	sti
0173+  0B4A 19 01       	mov al, 1
0174+  0B4C 05 03       	syscall sys_io				; receive in AH without echo
0175+  0B4E B9 00       	cmp al, 0					; check error code (AL)
0176+  0B50 C6 48 0B    	je gets_telnet_escape		; if no char received, retry
0177+  0B53 76 5B       	cmp ah, '['
0178+  0B55 C7 1A 0B    	jne gets_loop
0179+  0B58             gets_telnet_escape_phase2:
0180+  0B58 FD 0C       	sti
0181+  0B5A 19 01       	mov al, 1
0182+  0B5C 05 03       	syscall sys_io					; receive in AH without echo
0183+  0B5E B9 00       	cmp al, 0						; check error code (AL)
0184+  0B60 C6 58 0B    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  0B63 76 44       	cmp ah, 'D'
0186+  0B65 C6 70 0B    	je gets_left_arrow
0187+  0B68 76 43       	cmp ah, 'C'
0188+  0B6A C6 74 0B    	je gets_right_arrow
0189+  0B6D 0A 1A 0B    	jmp gets_loop
0190+  0B70             gets_left_arrow:
0191+  0B70 7F          	dec d
0192+  0B71 0A 1A 0B    	jmp gets_loop
0193+  0B74             gets_right_arrow:
0194+  0B74 79          	inc d
0195+  0B75 0A 1A 0B    	jmp gets_loop
0196+  0B78             gets_escape:
0197+  0B78 FD 0C       	sti
0198+  0B7A 19 01       	mov al, 1
0199+  0B7C 05 03       	syscall sys_io			; receive in AH
0200+  0B7E B9 00       	cmp al, 0				; check error code (AL)
0201+  0B80 C6 78 0B    	je gets_escape			; if no char received, retry
0202+  0B83 76 6E       	cmp ah, 'n'
0203+  0B85 C6 93 0B    	je gets_LF
0204+  0B88 76 72       	cmp ah, 'r'
0205+  0B8A C6 9A 0B    	je gets_CR
0206+  0B8D 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  0B8E 3E          	mov [d], al
0208+  0B8F 79          	inc d
0209+  0B90 0A 1A 0B    	jmp gets_loop
0210+  0B93             gets_LF:
0211+  0B93 19 0A       	mov al, $0A
0212+  0B95 3E          	mov [d], al
0213+  0B96 79          	inc d
0214+  0B97 0A 1A 0B    	jmp gets_loop
0215+  0B9A             gets_CR:
0216+  0B9A 19 0D       	mov al, $0D
0217+  0B9C 3E          	mov [d], al
0218+  0B9D 79          	inc d
0219+  0B9E 0A 1A 0B    	jmp gets_loop
0220+  0BA1             gets_end:
0221+  0BA1 19 00       	mov al, 0
0222+  0BA3 3E          	mov [d], al				; terminate string
0223+  0BA4 E7          	pop d
0224+  0BA5 E4          	pop a
0225+  0BA6 09          	ret
0226+  0BA7             
0227+  0BA7             
0228+  0BA7             
0229+  0BA7             
0230+  0BA7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  0BA7             ;; INPUT TEXT
0232+  0BA7             ;; terminated with CTRL+D
0233+  0BA7             ;; pointer in D
0234+  0BA7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  0BA7             gettxt:
0236+  0BA7 D7          	push a
0237+  0BA8 DA          	push d
0238+  0BA9             gettxt_loop:
0239+  0BA9 19 01       	mov al, 1
0240+  0BAB 05 03       	syscall sys_io			; receive in AH
0241+  0BAD B9 00       	cmp al, 0				; check error code (AL)
0242+  0BAF C6 A9 0B    	je gettxt_loop		; if no char received, retry
0243+  0BB2 76 04       	cmp ah, 4			; EOT
0244+  0BB4 C6 F2 0B    	je gettxt_end
0245+  0BB7 76 08       	cmp ah, $08			; check for backspace
0246+  0BB9 C6 EE 0B    	je gettxt_backspace
0247+  0BBC 76 5C       	cmp ah, $5C				; '\\'
0248+  0BBE C6 C7 0B    	je gettxt_escape
0249+  0BC1 1A          	mov al, ah
0250+  0BC2 3E          	mov [d], al
0251+  0BC3 79          	inc d
0252+  0BC4 0A A9 0B    	jmp gettxt_loop
0253+  0BC7             gettxt_escape:
0254+  0BC7 19 01       	mov al, 1
0255+  0BC9 05 03       	syscall sys_io			; receive in AH
0256+  0BCB B9 00       	cmp al, 0				; check error code (AL)
0257+  0BCD C6 C7 0B    	je gettxt_escape		; if no char received, retry
0258+  0BD0 76 6E       	cmp ah, 'n'
0259+  0BD2 C6 E0 0B    	je gettxt_LF
0260+  0BD5 76 72       	cmp ah, 'r'
0261+  0BD7 C6 E7 0B    	je gettxt_CR
0262+  0BDA 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  0BDB 3E          	mov [d], al
0264+  0BDC 79          	inc d
0265+  0BDD 0A A9 0B    	jmp gettxt_loop
0266+  0BE0             gettxt_LF:
0267+  0BE0 19 0A       	mov al, $0A
0268+  0BE2 3E          	mov [d], al
0269+  0BE3 79          	inc d
0270+  0BE4 0A A9 0B    	jmp gettxt_loop
0271+  0BE7             gettxt_CR:
0272+  0BE7 19 0D       	mov al, $0D
0273+  0BE9 3E          	mov [d], al
0274+  0BEA 79          	inc d
0275+  0BEB 0A A9 0B    	jmp gettxt_loop
0276+  0BEE             gettxt_backspace:
0277+  0BEE 7F          	dec d
0278+  0BEF 0A A9 0B    	jmp gettxt_loop
0279+  0BF2             gettxt_end:
0280+  0BF2 19 00       	mov al, 0
0281+  0BF4 3E          	mov [d], al				; terminate string
0282+  0BF5 E7          	pop d
0283+  0BF6 E4          	pop a
0284+  0BF7 09          	ret
0285+  0BF8             
0286+  0BF8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  0BF8             ; PRINT NEW LINE
0288+  0BF8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  0BF8             printnl:
0290+  0BF8 D7          	push a
0291+  0BF9 10 00 0A    	mov a, $0A00
0292+  0BFC 05 03       	syscall sys_io
0293+  0BFE 10 00 0D    	mov a, $0D00
0294+  0C01 05 03       	syscall sys_io
0295+  0C03 E4          	pop a
0296+  0C04 09          	ret
0297+  0C05             
0298+  0C05             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  0C05             ; strtoint
0300+  0C05             ; 4 digit hex string number in d
0301+  0C05             ; integer returned in A
0302+  0C05             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  0C05             strtointx:
0304+  0C05 D8          	push b
0305+  0C06 32          	mov bl, [d]
0306+  0C07 37          	mov bh, bl
0307+  0C08 33 01 00    	mov bl, [d + 1]
0308+  0C0B 07 C6 0A    	call atoi				; convert to int in AL
0309+  0C0E 23          	mov ah, al				; move to AH
0310+  0C0F 33 02 00    	mov bl, [d + 2]
0311+  0C12 37          	mov bh, bl
0312+  0C13 33 03 00    	mov bl, [d + 3]
0313+  0C16 07 C6 0A    	call atoi				; convert to int in AL
0314+  0C19 E5          	pop b
0315+  0C1A 09          	ret
0316+  0C1B             
0317+  0C1B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  0C1B             ; strtoint
0319+  0C1B             ; 5 digit base10 string number in d
0320+  0C1B             ; integer returned in A
0321+  0C1B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  0C1B             strtoint:
0323+  0C1B E2          	push si
0324+  0C1C D8          	push b
0325+  0C1D D9          	push c
0326+  0C1E DA          	push d
0327+  0C1F 07 46 0A    	call strlen			; get string length in C
0328+  0C22 7E          	dec c
0329+  0C23 FD 4E       	mov si, d
0330+  0C25 12          	mov a, c
0331+  0C26 FD 99       	shl a
0332+  0C28 3B AE 0A    	mov d, table_power
0333+  0C2B 59          	add d, a
0334+  0C2C 38 00 00    	mov c, 0
0335+  0C2F             strtoint_L0:
0336+  0C2F F6          	lodsb			; load ASCII to al
0337+  0C30 B9 00       	cmp al, 0
0338+  0C32 C6 45 0C    	je strtoint_end
0339+  0C35 6F 30       	sub al, $30		; make into integer
0340+  0C37 22 00       	mov ah, 0
0341+  0C39 2A          	mov b, [d]
0342+  0C3A AC          	mul a, b			; result in B since it fits in 16bits
0343+  0C3B 11          	mov a, b
0344+  0C3C 28          	mov b, c
0345+  0C3D 54          	add a, b
0346+  0C3E 39          	mov c, a
0347+  0C3F 63 02 00    	sub d, 2
0348+  0C42 0A 2F 0C    	jmp strtoint_L0
0349+  0C45             strtoint_end:
0350+  0C45 12          	mov a, c
0351+  0C46 E7          	pop d
0352+  0C47 E6          	pop c
0353+  0C48 E5          	pop b
0354+  0C49 EF          	pop si
0355+  0C4A 09          	ret
0356+  0C4B             
0357+  0C4B             
0358+  0C4B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  0C4B             ; PRINT NULL TERMINATED STRING
0360+  0C4B             ; pointer in D
0361+  0C4B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  0C4B             puts:
0363+  0C4B D7          	push a
0364+  0C4C DA          	push d
0365+  0C4D             puts_L1:
0366+  0C4D 1E          	mov al, [d]
0367+  0C4E B9 00       	cmp al, 0
0368+  0C50 C6 5C 0C    	jz puts_END
0369+  0C53 23          	mov ah, al
0370+  0C54 19 00       	mov al, 0
0371+  0C56 05 03       	syscall sys_io
0372+  0C58 79          	inc d
0373+  0C59 0A 4D 0C    	jmp puts_L1
0374+  0C5C             puts_END:
0375+  0C5C E7          	pop d
0376+  0C5D E4          	pop a
0377+  0C5E 09          	ret
0378+  0C5F             
0379+  0C5F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  0C5F             ; PRINT N SIZE STRING
0381+  0C5F             ; pointer in D
0382+  0C5F             ; size in C
0383+  0C5F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  0C5F             putsn:
0385+  0C5F DB          	push al
0386+  0C60 DA          	push d
0387+  0C61 D9          	push c
0388+  0C62             putsn_L0:
0389+  0C62 1E          	mov al, [d]
0390+  0C63 23          	mov ah, al
0391+  0C64 19 00       	mov al, 0
0392+  0C66 05 03       	syscall sys_io
0393+  0C68 79          	inc d
0394+  0C69 7E          	dec c	
0395+  0C6A C2 00 00    	cmp c, 0
0396+  0C6D C7 62 0C    	jne putsn_L0
0397+  0C70             putsn_end:
0398+  0C70 E6          	pop c
0399+  0C71 E7          	pop d
0400+  0C72 E8          	pop al
0401+  0C73 09          	ret
0402+  0C74             
0403+  0C74             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  0C74             ; print 16bit decimal number
0405+  0C74             ; input number in A
0406+  0C74             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  0C74             print_u16d:
0408+  0C74 D7          	push a
0409+  0C75 D8          	push b
0410+  0C76 26 10 27    	mov b, 10000
0411+  0C79 AE          	div a, b			; get 10000 coeff.
0412+  0C7A 07 A0 0C    	call print_number
0413+  0C7D 11          	mov a, b
0414+  0C7E 26 E8 03    	mov b, 1000
0415+  0C81 AE          	div a, b			; get 10000 coeff.
0416+  0C82 07 A0 0C    	call print_number
0417+  0C85 11          	mov a, b
0418+  0C86 26 64 00    	mov b, 100
0419+  0C89 AE          	div a, b
0420+  0C8A 07 A0 0C    	call print_number
0421+  0C8D 11          	mov a, b
0422+  0C8E 26 0A 00    	mov b, 10
0423+  0C91 AE          	div a, b
0424+  0C92 07 A0 0C    	call print_number
0425+  0C95 11          	mov a, b
0426+  0C96 6A 30       	add al, $30
0427+  0C98 23          	mov ah, al
0428+  0C99 19 00       	mov al, 0
0429+  0C9B 05 03       	syscall sys_io	; print coeff
0430+  0C9D E5          	pop b
0431+  0C9E E4          	pop a
0432+  0C9F 09          	ret
0433+  0CA0             
0434+  0CA0             
0435+  0CA0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  0CA0             ; if A == 0, print space
0437+  0CA0             ; else print A
0438+  0CA0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0439+  0CA0             print_number:
0440+  0CA0 6A 30       	add al, $30
0441+  0CA2 23          	mov ah, al
0442+  0CA3 07 11 0B    	call putchar
0443+  0CA6 09          	ret
0444+  0CA7             
0445+  0CA7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0446+  0CA7             ; PRINT 16BIT HEX INTEGER
0447+  0CA7             ; integer value in reg B
0448+  0CA7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  0CA7             print_u16x:
0450+  0CA7 D7          	push a
0451+  0CA8 D8          	push b
0452+  0CA9 DD          	push bl
0453+  0CAA 30          	mov bl, bh
0454+  0CAB 07 D8 0A    	call itoa				; convert bh to char in A
0455+  0CAE 2F          	mov bl, al				; save al
0456+  0CAF 19 00       	mov al, 0
0457+  0CB1 05 03       	syscall sys_io				; display AH
0458+  0CB3 24          	mov ah, bl				; retrieve al
0459+  0CB4 19 00       	mov al, 0
0460+  0CB6 05 03       	syscall sys_io				; display AL
0461+  0CB8             
0462+  0CB8 EA          	pop bl
0463+  0CB9 07 D8 0A    	call itoa				; convert bh to char in A
0464+  0CBC 2F          	mov bl, al				; save al
0465+  0CBD 19 00       	mov al, 0
0466+  0CBF 05 03       	syscall sys_io				; display AH
0467+  0CC1 24          	mov ah, bl				; retrieve al
0468+  0CC2 19 00       	mov al, 0
0469+  0CC4 05 03       	syscall sys_io				; display AL
0470+  0CC6             
0471+  0CC6 E5          	pop b
0472+  0CC7 E4          	pop a
0473+  0CC8 09          	ret
0474+  0CC9             
0475+  0CC9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  0CC9             ; INPUT 16BIT HEX INTEGER
0477+  0CC9             ; read 16bit integer into A
0478+  0CC9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  0CC9             scan_u16x:
0480+  0CC9 F8 10 00    	enter 16
0481+  0CCC D8          	push b
0482+  0CCD DA          	push d
0483+  0CCE             
0484+  0CCE FA F1 FF    	lea d, [bp + -15]
0485+  0CD1 07 18 0B    	call gets				; get number
0486+  0CD4             
0487+  0CD4 32          	mov bl, [d]
0488+  0CD5 37          	mov bh, bl
0489+  0CD6 33 01 00    	mov bl, [d + 1]
0490+  0CD9 07 C6 0A    	call atoi				; convert to int in AL
0491+  0CDC 23          	mov ah, al				; move to AH
0492+  0CDD             
0493+  0CDD 33 02 00    	mov bl, [d + 2]
0494+  0CE0 37          	mov bh, bl
0495+  0CE1 33 03 00    	mov bl, [d + 3]
0496+  0CE4 07 C6 0A    	call atoi				; convert to int in AL
0497+  0CE7             
0498+  0CE7 E7          	pop d
0499+  0CE8 E5          	pop b
0500+  0CE9 F9          	leave
0501+  0CEA 09          	ret
0502+  0CEB             
0503+  0CEB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0504+  0CEB             ; PRINT 8bit HEX INTEGER
0505+  0CEB             ; integer value in reg bl
0506+  0CEB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  0CEB             print_u8x:
0508+  0CEB D7          	push a
0509+  0CEC DD          	push bl
0510+  0CED             
0511+  0CED 07 D8 0A    	call itoa				; convert bl to char in A
0512+  0CF0 2F          	mov bl, al				; save al
0513+  0CF1 19 00       	mov al, 0
0514+  0CF3 05 03       	syscall sys_io				; display AH
0515+  0CF5 24          	mov ah, bl				; retrieve al
0516+  0CF6 19 00       	mov al, 0
0517+  0CF8 05 03       	syscall sys_io				; display AL
0518+  0CFA             
0519+  0CFA EA          	pop bl
0520+  0CFB E4          	pop a
0521+  0CFC 09          	ret
0522+  0CFD             
0523+  0CFD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0524+  0CFD             ; print 8bit decimal unsigned number
0525+  0CFD             ; input number in AL
0526+  0CFD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  0CFD             print_u8d:
0528+  0CFD D7          	push a
0529+  0CFE D8          	push b
0530+  0CFF             
0531+  0CFF 22 00       	mov ah, 0
0532+  0D01 26 64 00    	mov b, 100
0533+  0D04 AE          	div a, b
0534+  0D05 D8          	push b			; save remainder
0535+  0D06 B9 00       	cmp al, 0
0536+  0D08 C6 12 0D    	je skip100
0537+  0D0B 6A 30       	add al, $30
0538+  0D0D 23          	mov ah, al
0539+  0D0E 19 00       	mov al, 0
0540+  0D10 05 03       	syscall sys_io	; print coeff
0541+  0D12             skip100:
0542+  0D12 E4          	pop a
0543+  0D13 22 00       	mov ah, 0
0544+  0D15 26 0A 00    	mov b, 10
0545+  0D18 AE          	div a, b
0546+  0D19 D8          	push b			; save remainder
0547+  0D1A B9 00       	cmp al, 0
0548+  0D1C C6 26 0D    	je skip10
0549+  0D1F 6A 30       	add al, $30
0550+  0D21 23          	mov ah, al
0551+  0D22 19 00       	mov al, 0
0552+  0D24 05 03       	syscall sys_io	; print coeff
0553+  0D26             skip10:
0554+  0D26 E4          	pop a
0555+  0D27 1B          	mov al, bl
0556+  0D28 6A 30       	add al, $30
0557+  0D2A 23          	mov ah, al
0558+  0D2B 19 00       	mov al, 0
0559+  0D2D 05 03       	syscall sys_io	; print coeff
0560+  0D2F E5          	pop b
0561+  0D30 E4          	pop a
0562+  0D31 09          	ret
0563+  0D32             
0564+  0D32             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0565+  0D32             ; INPUT 8BIT HEX INTEGER
0566+  0D32             ; read 8bit integer into AL
0567+  0D32             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  0D32             scan_u8x:
0569+  0D32 F8 04 00    	enter 4
0570+  0D35 D8          	push b
0571+  0D36 DA          	push d
0572+  0D37             
0573+  0D37 FA FD FF    	lea d, [bp + -3]
0574+  0D3A 07 18 0B    	call gets				; get number
0575+  0D3D             
0576+  0D3D 32          	mov bl, [d]
0577+  0D3E 37          	mov bh, bl
0578+  0D3F 33 01 00    	mov bl, [d + 1]
0579+  0D42 07 C6 0A    	call atoi				; convert to int in AL
0580+  0D45             
0581+  0D45 E7          	pop d
0582+  0D46 E5          	pop b
0583+  0D47 F9          	leave
0584+  0D48 09          	ret
0585+  0D49             
0586+  0D49             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  0D49             ; input decimal number
0588+  0D49             ; result in A
0589+  0D49             ; 655'\0'
0590+  0D49             ; low--------high
0591+  0D49             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0592+  0D49             scan_u16d:
0593+  0D49 F8 08 00    	enter 8
0594+  0D4C E2          	push si
0595+  0D4D D8          	push b
0596+  0D4E D9          	push c
0597+  0D4F DA          	push d
0598+  0D50 FA F9 FF    	lea d, [bp +- 7]
0599+  0D53 07 18 0B    	call gets
0600+  0D56 07 46 0A    	call strlen			; get string length in C
0601+  0D59 7E          	dec c
0602+  0D5A FD 4E       	mov si, d
0603+  0D5C 12          	mov a, c
0604+  0D5D FD 99       	shl a
0605+  0D5F 3B AE 0A    	mov d, table_power
0606+  0D62 59          	add d, a
0607+  0D63 38 00 00    	mov c, 0
0608+  0D66             mul_loop:
0609+  0D66 F6          	lodsb			; load ASCII to al
0610+  0D67 B9 00       	cmp al, 0
0611+  0D69 C6 7C 0D    	je mul_exit
0612+  0D6C 6F 30       	sub al, $30		; make into integer
0613+  0D6E 22 00       	mov ah, 0
0614+  0D70 2A          	mov b, [d]
0615+  0D71 AC          	mul a, b			; result in B since it fits in 16bits
0616+  0D72 11          	mov a, b
0617+  0D73 28          	mov b, c
0618+  0D74 54          	add a, b
0619+  0D75 39          	mov c, a
0620+  0D76 63 02 00    	sub d, 2
0621+  0D79 0A 66 0D    	jmp mul_loop
0622+  0D7C             mul_exit:
0623+  0D7C 12          	mov a, c
0624+  0D7D E7          	pop d
0625+  0D7E E6          	pop c
0626+  0D7F E5          	pop b
0627+  0D80 EF          	pop si
0628+  0D81 F9          	leave
0629+  0D82 09          	ret
0709   0D83             ; --- END INCLUDE BLOCK
0710   0D83             
0711   0D83             
0712   0D83             .end
tasm: Number of errors = 0
