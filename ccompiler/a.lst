0001   0000             ; --- FILENAME: ivosol1a.c
0002   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0400             .org PROC_TEXT_ORG
0004   0400             
0005   0400             ; --- BEGIN TEXT BLOCK
0006   0400             main:
0007   0400 D2            push bp
0008   0401 9B            mov bp, sp
0009   0402             _while1_cond:
0010   0402 26 01 00      mov b, 1
0011   0405 C0 00 00      cmp b, 0
0012   0408 C6 F5 0E      je _while1_exit
0013   040B             _while1_block:
0014   040B 26 10 0E      mov b, 3600
0015   040E FD 42 1C 11   mov [runlimit], b
0016   0412             _while2_cond:
0017   0412 26 01 00      mov b, 1
0018   0415 C0 00 00      cmp b, 0
0019   0418 C6 7D 07      je _while2_exit
0020   041B             _while2_block:
0021   041B 26 00 00      mov b, 0
0022   041E FD 42 0E 11   mov [pc], b
0023   0422 26 18 30      mov b, 12312
0024   0425 FD AB         swp b
0025   0427 D8            push b
0026   0428 07 05 0F      call displaynumber
0027   042B 51 02 00      add sp, 2
0028   042E 07 F5 0E      call readint
0029   0431 FD 42 04 11   mov [cmdadr], b
0030   0435             _if3_cond:
0031   0435 29 04 11      mov b, [cmdadr]
0032   0438 D7            push a
0033   0439 11            mov a, b
0034   043A 26 1E 00      mov b, 30
0035   043D B0            cmp a, b
0036   043E 0E            lodflgs
0037   043F 87 03         and al, %00000011 ; <=
0038   0441 B9 00         cmp al, 0
0039   0443 0E            lodflgs
0040   0444 96            not al
0041   0445 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0042   0447 22 00         mov ah, 0
0043   0449 27            mov b, a
0044   044A E4            pop a
0045   044B C0 00 00      cmp b, 0
0046   044E C6 48 05      je _if3_else
0047   0451             _if3_true:
0048   0451 07 F5 0E      call readint
0049   0454 FD 42 06 11   mov [opr], b
0050   0458 07 F5 0E      call readint
0051   045B FD 42 08 11   mov [datadr1], b
0052   045F 07 F5 0E      call readint
0053   0462 FD 42 0A 11   mov [datadr2], b
0054   0466 07 F5 0E      call readint
0055   0469 FD 42 0C 11   mov [datadr3], b
0056   046D 29 02 11      mov b, [instruction]
0057   0470 74            mov d, b
0058   0471 29 04 11      mov b, [cmdadr]
0059   0474 D7            push a
0060   0475 11            mov a, b
0061   0476 26 04 00      mov b, 4
0062   0479 AC            mul a, b
0063   047A E4            pop a
0064   047B 10 02 00      mov a, 2
0065   047E AC            mul a, b
0066   047F 5A            add d, b
0067   0480 DA            push d
0068   0481 29 06 11      mov b, [opr]
0069   0484 E7            pop d
0070   0485 11            mov a, b
0071   0486 43            mov [d], a
0072   0487 29 02 11      mov b, [instruction]
0073   048A 74            mov d, b
0074   048B 29 04 11      mov b, [cmdadr]
0075   048E D7            push a
0076   048F 11            mov a, b
0077   0490 26 04 00      mov b, 4
0078   0493 AC            mul a, b
0079   0494 11            mov a, b
0080   0495 26 01 00      mov b, 1
0081   0498 54            add a, b
0082   0499 27            mov b, a
0083   049A E4            pop a
0084   049B 10 02 00      mov a, 2
0085   049E AC            mul a, b
0086   049F 5A            add d, b
0087   04A0 DA            push d
0088   04A1 29 08 11      mov b, [datadr1]
0089   04A4 E7            pop d
0090   04A5 11            mov a, b
0091   04A6 43            mov [d], a
0092   04A7 29 02 11      mov b, [instruction]
0093   04AA 74            mov d, b
0094   04AB 29 04 11      mov b, [cmdadr]
0095   04AE D7            push a
0096   04AF 11            mov a, b
0097   04B0 26 04 00      mov b, 4
0098   04B3 AC            mul a, b
0099   04B4 11            mov a, b
0100   04B5 26 02 00      mov b, 2
0101   04B8 54            add a, b
0102   04B9 27            mov b, a
0103   04BA E4            pop a
0104   04BB 10 02 00      mov a, 2
0105   04BE AC            mul a, b
0106   04BF 5A            add d, b
0107   04C0 DA            push d
0108   04C1 29 0A 11      mov b, [datadr2]
0109   04C4 E7            pop d
0110   04C5 11            mov a, b
0111   04C6 43            mov [d], a
0112   04C7 29 02 11      mov b, [instruction]
0113   04CA 74            mov d, b
0114   04CB 29 04 11      mov b, [cmdadr]
0115   04CE D7            push a
0116   04CF 11            mov a, b
0117   04D0 26 04 00      mov b, 4
0118   04D3 AC            mul a, b
0119   04D4 11            mov a, b
0120   04D5 26 03 00      mov b, 3
0121   04D8 54            add a, b
0122   04D9 27            mov b, a
0123   04DA E4            pop a
0124   04DB 10 02 00      mov a, 2
0125   04DE AC            mul a, b
0126   04DF 5A            add d, b
0127   04E0 DA            push d
0128   04E1 29 0C 11      mov b, [datadr3]
0129   04E4 E7            pop d
0130   04E5 11            mov a, b
0131   04E6 43            mov [d], a
0132   04E7 29 04 11      mov b, [cmdadr]
0133   04EA FD AB         swp b
0134   04EC D8            push b
0135   04ED 07 05 0F      call displaynumber
0136   04F0 51 02 00      add sp, 2
0137   04F3 29 06 11      mov b, [opr]
0138   04F6 FD AB         swp b
0139   04F8 D8            push b
0140   04F9 07 05 0F      call displaynumber
0141   04FC 51 02 00      add sp, 2
0142   04FF 29 08 11      mov b, [datadr1]
0143   0502 FD AB         swp b
0144   0504 D8            push b
0145   0505 07 05 0F      call displaynumber
0146   0508 51 02 00      add sp, 2
0147   050B 29 0A 11      mov b, [datadr2]
0148   050E FD AB         swp b
0149   0510 D8            push b
0150   0511 07 05 0F      call displaynumber
0151   0514 51 02 00      add sp, 2
0152   0517 29 0C 11      mov b, [datadr3]
0153   051A FD AB         swp b
0154   051C D8            push b
0155   051D 07 05 0F      call displaynumber
0156   0520 51 02 00      add sp, 2
0157   0523             _if4_cond:
0158   0523 29 04 11      mov b, [cmdadr]
0159   0526 D7            push a
0160   0527 11            mov a, b
0161   0528 26 00 00      mov b, 0
0162   052B B0            cmp a, b
0163   052C 0E            lodflgs
0164   052D 87 01         and al, %00000001 ; ==
0165   052F B9 00         cmp al, 0
0166   0531 0E            lodflgs
0167   0532 96            not al
0168   0533 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0169   0535 22 00         mov ah, 0
0170   0537 27            mov b, a
0171   0538 E4            pop a
0172   0539 C0 00 00      cmp b, 0
0173   053C C6 45 05      je _if4_exit
0174   053F             _if4_true:
0175   053F 0A 7D 07      jmp _while2_exit ; while break
0176   0542 0A 45 05      jmp _if4_exit
0177   0545             _if4_exit:
0178   0545 0A 7A 07      jmp _if3_exit
0179   0548             _if3_else:
0180   0548             _if5_cond:
0181   0548 29 04 11      mov b, [cmdadr]
0182   054B D7            push a
0183   054C 11            mov a, b
0184   054D 26 57 04      mov b, 1111
0185   0550 B0            cmp a, b
0186   0551 0E            lodflgs
0187   0552 87 01         and al, %00000001 ; ==
0188   0554 B9 00         cmp al, 0
0189   0556 0E            lodflgs
0190   0557 96            not al
0191   0558 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0192   055A 22 00         mov ah, 0
0193   055C 27            mov b, a
0194   055D E4            pop a
0195   055E C0 00 00      cmp b, 0
0196   0561 C6 FC 05      je _if5_else
0197   0564             _if5_true:
0198   0564 07 F5 0E      call readint
0199   0567 FD 42 12 11   mov [i], b
0200   056B 29 02 11      mov b, [instruction]
0201   056E D7            push a
0202   056F 74            mov d, b
0203   0570 29 12 11      mov b, [i]
0204   0573 D7            push a
0205   0574 11            mov a, b
0206   0575 26 04 00      mov b, 4
0207   0578 AC            mul a, b
0208   0579 E4            pop a
0209   057A 10 02 00      mov a, 2
0210   057D AC            mul a, b
0211   057E 5A            add d, b
0212   057F 2A            mov b, [d]
0213   0580 E4            pop a
0214   0581 FD AB         swp b
0215   0583 D8            push b
0216   0584 07 05 0F      call displaynumber
0217   0587 51 02 00      add sp, 2
0218   058A 29 02 11      mov b, [instruction]
0219   058D D7            push a
0220   058E 74            mov d, b
0221   058F 29 12 11      mov b, [i]
0222   0592 D7            push a
0223   0593 11            mov a, b
0224   0594 26 04 00      mov b, 4
0225   0597 AC            mul a, b
0226   0598 11            mov a, b
0227   0599 26 01 00      mov b, 1
0228   059C 54            add a, b
0229   059D 27            mov b, a
0230   059E E4            pop a
0231   059F 10 02 00      mov a, 2
0232   05A2 AC            mul a, b
0233   05A3 5A            add d, b
0234   05A4 2A            mov b, [d]
0235   05A5 E4            pop a
0236   05A6 FD AB         swp b
0237   05A8 D8            push b
0238   05A9 07 05 0F      call displaynumber
0239   05AC 51 02 00      add sp, 2
0240   05AF 29 02 11      mov b, [instruction]
0241   05B2 D7            push a
0242   05B3 74            mov d, b
0243   05B4 29 12 11      mov b, [i]
0244   05B7 D7            push a
0245   05B8 11            mov a, b
0246   05B9 26 04 00      mov b, 4
0247   05BC AC            mul a, b
0248   05BD 11            mov a, b
0249   05BE 26 02 00      mov b, 2
0250   05C1 54            add a, b
0251   05C2 27            mov b, a
0252   05C3 E4            pop a
0253   05C4 10 02 00      mov a, 2
0254   05C7 AC            mul a, b
0255   05C8 5A            add d, b
0256   05C9 2A            mov b, [d]
0257   05CA E4            pop a
0258   05CB FD AB         swp b
0259   05CD D8            push b
0260   05CE 07 05 0F      call displaynumber
0261   05D1 51 02 00      add sp, 2
0262   05D4 29 02 11      mov b, [instruction]
0263   05D7 D7            push a
0264   05D8 74            mov d, b
0265   05D9 29 12 11      mov b, [i]
0266   05DC D7            push a
0267   05DD 11            mov a, b
0268   05DE 26 04 00      mov b, 4
0269   05E1 AC            mul a, b
0270   05E2 11            mov a, b
0271   05E3 26 03 00      mov b, 3
0272   05E6 54            add a, b
0273   05E7 27            mov b, a
0274   05E8 E4            pop a
0275   05E9 10 02 00      mov a, 2
0276   05EC AC            mul a, b
0277   05ED 5A            add d, b
0278   05EE 2A            mov b, [d]
0279   05EF E4            pop a
0280   05F0 FD AB         swp b
0281   05F2 D8            push b
0282   05F3 07 05 0F      call displaynumber
0283   05F6 51 02 00      add sp, 2
0284   05F9 0A 7A 07      jmp _if5_exit
0285   05FC             _if5_else:
0286   05FC             _if6_cond:
0287   05FC 29 04 11      mov b, [cmdadr]
0288   05FF D7            push a
0289   0600 11            mov a, b
0290   0601 26 AE 08      mov b, 2222
0291   0604 B0            cmp a, b
0292   0605 0E            lodflgs
0293   0606 87 01         and al, %00000001 ; ==
0294   0608 B9 00         cmp al, 0
0295   060A 0E            lodflgs
0296   060B 96            not al
0297   060C 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0298   060E 22 00         mov ah, 0
0299   0610 27            mov b, a
0300   0611 E4            pop a
0301   0612 C0 00 00      cmp b, 0
0302   0615 C6 3A 06      je _if6_else
0303   0618             _if6_true:
0304   0618 07 F5 0E      call readint
0305   061B FD 42 12 11   mov [i], b
0306   061F 29 10 10      mov b, [datum]
0307   0622 D7            push a
0308   0623 74            mov d, b
0309   0624 29 12 11      mov b, [i]
0310   0627 10 02 00      mov a, 2
0311   062A AC            mul a, b
0312   062B 5A            add d, b
0313   062C 2A            mov b, [d]
0314   062D E4            pop a
0315   062E FD AB         swp b
0316   0630 D8            push b
0317   0631 07 05 0F      call displaynumber
0318   0634 51 02 00      add sp, 2
0319   0637 0A 7A 07      jmp _if6_exit
0320   063A             _if6_else:
0321   063A             _if7_cond:
0322   063A 29 04 11      mov b, [cmdadr]
0323   063D D7            push a
0324   063E 11            mov a, b
0325   063F 26 5C 11      mov b, 4444
0326   0642 B0            cmp a, b
0327   0643 0E            lodflgs
0328   0644 87 01         and al, %00000001 ; ==
0329   0646 B9 00         cmp al, 0
0330   0648 0E            lodflgs
0331   0649 96            not al
0332   064A 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0333   064C 22 00         mov ah, 0
0334   064E 27            mov b, a
0335   064F E4            pop a
0336   0650 C0 00 00      cmp b, 0
0337   0653 C6 6C 06      je _if7_else
0338   0656             _if7_true:
0339   0656 29 10 10      mov b, [datum]
0340   0659 74            mov d, b
0341   065A 07 F5 0E      call readint
0342   065D 10 02 00      mov a, 2
0343   0660 AC            mul a, b
0344   0661 5A            add d, b
0345   0662 DA            push d
0346   0663 07 F5 0E      call readint
0347   0666 E7            pop d
0348   0667 11            mov a, b
0349   0668 43            mov [d], a
0350   0669 0A 7A 07      jmp _if7_exit
0351   066C             _if7_else:
0352   066C             _if8_cond:
0353   066C 29 04 11      mov b, [cmdadr]
0354   066F D7            push a
0355   0670 11            mov a, b
0356   0671 26 B3 15      mov b, 5555
0357   0674 B0            cmp a, b
0358   0675 0E            lodflgs
0359   0676 87 01         and al, %00000001 ; ==
0360   0678 B9 00         cmp al, 0
0361   067A 0E            lodflgs
0362   067B 96            not al
0363   067C 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0364   067E 22 00         mov ah, 0
0365   0680 27            mov b, a
0366   0681 E4            pop a
0367   0682 C0 00 00      cmp b, 0
0368   0685 C6 CD 06      je _if8_else
0369   0688             _if8_true:
0370   0688             _for9_init:
0371   0688 26 00 00      mov b, 0
0372   068B FD 42 12 11   mov [i], b
0373   068F             _for9_cond:
0374   068F 29 12 11      mov b, [i]
0375   0692 D7            push a
0376   0693 11            mov a, b
0377   0694 26 1E 00      mov b, 30
0378   0697 B0            cmp a, b
0379   0698 0E            lodflgs
0380   0699 87 02         and al, %00000010 ; <
0381   069B B9 00         cmp al, 0
0382   069D 0E            lodflgs
0383   069E 96            not al
0384   069F 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0385   06A1 22 00         mov ah, 0
0386   06A3 27            mov b, a
0387   06A4 E4            pop a
0388   06A5 C0 00 00      cmp b, 0
0389   06A8 C6 CA 06      je _for9_exit
0390   06AB             _for9_block:
0391   06AB 29 02 11      mov b, [instruction]
0392   06AE 74            mov d, b
0393   06AF 29 12 11      mov b, [i]
0394   06B2 10 02 00      mov a, 2
0395   06B5 AC            mul a, b
0396   06B6 5A            add d, b
0397   06B7 DA            push d
0398   06B8 26 00 00      mov b, 0
0399   06BB E7            pop d
0400   06BC 11            mov a, b
0401   06BD 43            mov [d], a
0402   06BE             _for9_update:
0403   06BE 29 12 11      mov b, [i]
0404   06C1 FD 77         inc b
0405   06C3 FD 42 12 11   mov [i], b
0406   06C7 0A 8F 06      jmp _for9_cond
0407   06CA             _for9_exit:
0408   06CA 0A 7A 07      jmp _if8_exit
0409   06CD             _if8_else:
0410   06CD             _if10_cond:
0411   06CD 29 04 11      mov b, [cmdadr]
0412   06D0 D7            push a
0413   06D1 11            mov a, b
0414   06D2 26 0A 1A      mov b, 6666
0415   06D5 B0            cmp a, b
0416   06D6 0E            lodflgs
0417   06D7 87 01         and al, %00000001 ; ==
0418   06D9 B9 00         cmp al, 0
0419   06DB 0E            lodflgs
0420   06DC 96            not al
0421   06DD 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0422   06DF 22 00         mov ah, 0
0423   06E1 27            mov b, a
0424   06E2 E4            pop a
0425   06E3 C0 00 00      cmp b, 0
0426   06E6 C6 2E 07      je _if10_else
0427   06E9             _if10_true:
0428   06E9             _for11_init:
0429   06E9 29 08 11      mov b, [datadr1]
0430   06EC FD 42 12 11   mov [i], b
0431   06F0             _for11_cond:
0432   06F0 29 12 11      mov b, [i]
0433   06F3 D7            push a
0434   06F4 11            mov a, b
0435   06F5 26 7B 00      mov b, 123
0436   06F8 B0            cmp a, b
0437   06F9 0E            lodflgs
0438   06FA 87 02         and al, %00000010 ; <
0439   06FC B9 00         cmp al, 0
0440   06FE 0E            lodflgs
0441   06FF 96            not al
0442   0700 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0443   0702 22 00         mov ah, 0
0444   0704 27            mov b, a
0445   0705 E4            pop a
0446   0706 C0 00 00      cmp b, 0
0447   0709 C6 2B 07      je _for11_exit
0448   070C             _for11_block:
0449   070C 29 10 10      mov b, [datum]
0450   070F 74            mov d, b
0451   0710 29 12 11      mov b, [i]
0452   0713 10 02 00      mov a, 2
0453   0716 AC            mul a, b
0454   0717 5A            add d, b
0455   0718 DA            push d
0456   0719 26 00 00      mov b, 0
0457   071C E7            pop d
0458   071D 11            mov a, b
0459   071E 43            mov [d], a
0460   071F             _for11_update:
0461   071F 29 12 11      mov b, [i]
0462   0722 FD 77         inc b
0463   0724 FD 42 12 11   mov [i], b
0464   0728 0A F0 06      jmp _for11_cond
0465   072B             _for11_exit:
0466   072B 0A 7A 07      jmp _if10_exit
0467   072E             _if10_else:
0468   072E             _if12_cond:
0469   072E 29 04 11      mov b, [cmdadr]
0470   0731 D7            push a
0471   0732 11            mov a, b
0472   0733 26 0F 27      mov b, 9999
0473   0736 B0            cmp a, b
0474   0737 0E            lodflgs
0475   0738 87 01         and al, %00000001 ; ==
0476   073A B9 00         cmp al, 0
0477   073C 0E            lodflgs
0478   073D 96            not al
0479   073E 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0480   0740 22 00         mov ah, 0
0481   0742 27            mov b, a
0482   0743 E4            pop a
0483   0744 C0 00 00      cmp b, 0
0484   0747 C6 54 07      je _if12_else
0485   074A             _if12_true:
0486   074A 07 F5 0E      call readint
0487   074D FD 42 1C 11   mov [runlimit], b
0488   0751 0A 7A 07      jmp _if12_exit
0489   0754             _if12_else:
0490   0754             _if13_cond:
0491   0754 29 04 11      mov b, [cmdadr]
0492   0757 D7            push a
0493   0758 11            mov a, b
0494   0759 26 B8 22      mov b, 8888
0495   075C B0            cmp a, b
0496   075D 0E            lodflgs
0497   075E 87 01         and al, %00000001 ; ==
0498   0760 B9 00         cmp al, 0
0499   0762 0E            lodflgs
0500   0763 96            not al
0501   0764 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0502   0766 22 00         mov ah, 0
0503   0768 27            mov b, a
0504   0769 E4            pop a
0505   076A C0 00 00      cmp b, 0
0506   076D C6 7A 07      je _if13_exit
0507   0770             _if13_true:
0508   0770 26 01 00      mov b, 1
0509   0773 FD 42 1E 11   mov [exitflag], b
0510   0777 0A 7A 07      jmp _if13_exit
0511   077A             _if13_exit:
0512   077A             _if12_exit:
0513   077A             _if10_exit:
0514   077A             _if8_exit:
0515   077A             _if7_exit:
0516   077A             _if6_exit:
0517   077A             _if5_exit:
0518   077A             _if3_exit:
0519   077A 0A 12 04      jmp _while2_cond
0520   077D             _while2_exit:
0521   077D             _if14_cond:
0522   077D 29 1E 11      mov b, [exitflag]
0523   0780 D7            push a
0524   0781 11            mov a, b
0525   0782 26 01 00      mov b, 1
0526   0785 B0            cmp a, b
0527   0786 0E            lodflgs
0528   0787 87 01         and al, %00000001 ; ==
0529   0789 B9 00         cmp al, 0
0530   078B 0E            lodflgs
0531   078C 96            not al
0532   078D 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0533   078F 22 00         mov ah, 0
0534   0791 27            mov b, a
0535   0792 E4            pop a
0536   0793 C0 00 00      cmp b, 0
0537   0796 C6 9F 07      je _if14_exit
0538   0799             _if14_true:
0539   0799 0A F5 0E      jmp _while1_exit ; while break
0540   079C 0A 9F 07      jmp _if14_exit
0541   079F             _if14_exit:
0542   079F             _while15_cond:
0543   079F 29 0E 11      mov b, [pc]
0544   07A2 D7            push a
0545   07A3 11            mov a, b
0546   07A4 26 1E 00      mov b, 30
0547   07A7 B0            cmp a, b
0548   07A8 0E            lodflgs
0549   07A9 87 02         and al, %00000010 ; <
0550   07AB B9 00         cmp al, 0
0551   07AD 0E            lodflgs
0552   07AE 96            not al
0553   07AF 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0554   07B1 22 00         mov ah, 0
0555   07B3 27            mov b, a
0556   07B4 E4            pop a
0557   07B5 C0 00 00      cmp b, 0
0558   07B8 C6 F2 0E      je _while15_exit
0559   07BB             _while15_block:
0560   07BB             _if16_cond:
0561   07BB 29 1C 11      mov b, [runlimit]
0562   07BE D7            push a
0563   07BF 11            mov a, b
0564   07C0 26 01 00      mov b, 1
0565   07C3 B0            cmp a, b
0566   07C4 0E            lodflgs
0567   07C5 87 01         and al, %00000001 ; ==
0568   07C7 B9 00         cmp al, 0
0569   07C9 0E            lodflgs
0570   07CA 96            not al
0571   07CB 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0572   07CD 22 00         mov ah, 0
0573   07CF 27            mov b, a
0574   07D0 E4            pop a
0575   07D1 C0 00 00      cmp b, 0
0576   07D4 C6 DD 07      je _if16_else
0577   07D7             _if16_true:
0578   07D7 0A F2 0E      jmp _while15_exit ; while break
0579   07DA 0A 0A 08      jmp _if16_exit
0580   07DD             _if16_else:
0581   07DD             _if17_cond:
0582   07DD 29 1C 11      mov b, [runlimit]
0583   07E0 D7            push a
0584   07E1 11            mov a, b
0585   07E2 26 01 00      mov b, 1
0586   07E5 B0            cmp a, b
0587   07E6 0E            lodflgs
0588   07E7 87 03         and al, %00000011
0589   07E9 B9 00         cmp al, %00000000
0590   07EB 0E            lodflgs
0591   07EC 87 01         and al, %00000001 ; >
0592   07EE B9 00         cmp al, 0
0593   07F0 0E            lodflgs
0594   07F1 96            not al
0595   07F2 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0596   07F4 22 00         mov ah, 0
0597   07F6 27            mov b, a
0598   07F7 E4            pop a
0599   07F8 C0 00 00      cmp b, 0
0600   07FB C6 0A 08      je _if17_exit
0601   07FE             _if17_true:
0602   07FE 29 1C 11      mov b, [runlimit]
0603   0801 FD 7D         dec b
0604   0803 FD 42 1C 11   mov [runlimit], b
0605   0807 0A 0A 08      jmp _if17_exit
0606   080A             _if17_exit:
0607   080A             _if16_exit:
0608   080A 29 10 10      mov b, [datum]
0609   080D 74            mov d, b
0610   080E 26 00 00      mov b, 0
0611   0811 10 02 00      mov a, 2
0612   0814 AC            mul a, b
0613   0815 5A            add d, b
0614   0816 DA            push d
0615   0817 26 00 00      mov b, 0
0616   081A E7            pop d
0617   081B 11            mov a, b
0618   081C 43            mov [d], a
0619   081D 29 02 11      mov b, [instruction]
0620   0820 D7            push a
0621   0821 74            mov d, b
0622   0822 29 0E 11      mov b, [pc]
0623   0825 D7            push a
0624   0826 11            mov a, b
0625   0827 26 04 00      mov b, 4
0626   082A AC            mul a, b
0627   082B E4            pop a
0628   082C 10 02 00      mov a, 2
0629   082F AC            mul a, b
0630   0830 5A            add d, b
0631   0831 2A            mov b, [d]
0632   0832 E4            pop a
0633   0833 FD 42 06 11   mov [opr], b
0634   0837 29 02 11      mov b, [instruction]
0635   083A D7            push a
0636   083B 74            mov d, b
0637   083C 29 0E 11      mov b, [pc]
0638   083F D7            push a
0639   0840 11            mov a, b
0640   0841 26 04 00      mov b, 4
0641   0844 AC            mul a, b
0642   0845 11            mov a, b
0643   0846 26 01 00      mov b, 1
0644   0849 54            add a, b
0645   084A 27            mov b, a
0646   084B E4            pop a
0647   084C 10 02 00      mov a, 2
0648   084F AC            mul a, b
0649   0850 5A            add d, b
0650   0851 2A            mov b, [d]
0651   0852 E4            pop a
0652   0853 FD 42 08 11   mov [datadr1], b
0653   0857 29 02 11      mov b, [instruction]
0654   085A D7            push a
0655   085B 74            mov d, b
0656   085C 29 0E 11      mov b, [pc]
0657   085F D7            push a
0658   0860 11            mov a, b
0659   0861 26 04 00      mov b, 4
0660   0864 AC            mul a, b
0661   0865 11            mov a, b
0662   0866 26 02 00      mov b, 2
0663   0869 54            add a, b
0664   086A 27            mov b, a
0665   086B E4            pop a
0666   086C 10 02 00      mov a, 2
0667   086F AC            mul a, b
0668   0870 5A            add d, b
0669   0871 2A            mov b, [d]
0670   0872 E4            pop a
0671   0873 FD 42 0A 11   mov [datadr2], b
0672   0877 29 02 11      mov b, [instruction]
0673   087A D7            push a
0674   087B 74            mov d, b
0675   087C 29 0E 11      mov b, [pc]
0676   087F D7            push a
0677   0880 11            mov a, b
0678   0881 26 04 00      mov b, 4
0679   0884 AC            mul a, b
0680   0885 11            mov a, b
0681   0886 26 03 00      mov b, 3
0682   0889 54            add a, b
0683   088A 27            mov b, a
0684   088B E4            pop a
0685   088C 10 02 00      mov a, 2
0686   088F AC            mul a, b
0687   0890 5A            add d, b
0688   0891 2A            mov b, [d]
0689   0892 E4            pop a
0690   0893 FD 42 0C 11   mov [datadr3], b
0691   0897             _if18_cond:
0692   0897 29 10 11      mov b, [h]
0693   089A D7            push a
0694   089B 11            mov a, b
0695   089C 26 00 00      mov b, 0
0696   089F B0            cmp a, b
0697   08A0 0E            lodflgs
0698   08A1 87 03         and al, %00000011
0699   08A3 B9 00         cmp al, %00000000
0700   08A5 0E            lodflgs
0701   08A6 87 01         and al, %00000001 ; >
0702   08A8 B9 00         cmp al, 0
0703   08AA 0E            lodflgs
0704   08AB 96            not al
0705   08AC 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0706   08AE 22 00         mov ah, 0
0707   08B0 27            mov b, a
0708   08B1 11            mov a, b
0709   08B2 29 16 11      mov b, [k]
0710   08B5 D7            push a
0711   08B6 11            mov a, b
0712   08B7 26 00 00      mov b, 0
0713   08BA B0            cmp a, b
0714   08BB 0E            lodflgs
0715   08BC 87 03         and al, %00000011
0716   08BE B9 00         cmp al, %00000000
0717   08C0 0E            lodflgs
0718   08C1 87 01         and al, %00000001 ; >
0719   08C3 B9 00         cmp al, 0
0720   08C5 0E            lodflgs
0721   08C6 96            not al
0722   08C7 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0723   08C9 22 00         mov ah, 0
0724   08CB 27            mov b, a
0725   08CC E4            pop a
0726   08CD 8A            or a, b
0727   08CE 27            mov b, a
0728   08CF 11            mov a, b
0729   08D0 29 18 11      mov b, [l]
0730   08D3 D7            push a
0731   08D4 11            mov a, b
0732   08D5 26 00 00      mov b, 0
0733   08D8 B0            cmp a, b
0734   08D9 0E            lodflgs
0735   08DA 87 03         and al, %00000011
0736   08DC B9 00         cmp al, %00000000
0737   08DE 0E            lodflgs
0738   08DF 87 01         and al, %00000001 ; >
0739   08E1 B9 00         cmp al, 0
0740   08E3 0E            lodflgs
0741   08E4 96            not al
0742   08E5 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0743   08E7 22 00         mov ah, 0
0744   08E9 27            mov b, a
0745   08EA E4            pop a
0746   08EB 8A            or a, b
0747   08EC 27            mov b, a
0748   08ED E4            pop a
0749   08EE C0 00 00      cmp b, 0
0750   08F1 C6 21 09      je _if18_exit
0751   08F4             _if18_true:
0752   08F4 29 10 11      mov b, [h]
0753   08F7 FD 42 08 11   mov [datadr1], b
0754   08FB 29 16 11      mov b, [k]
0755   08FE FD 42 0A 11   mov [datadr2], b
0756   0902 29 18 11      mov b, [l]
0757   0905 FD 42 0C 11   mov [datadr3], b
0758   0909 26 00 00      mov b, 0
0759   090C FD 42 10 11   mov [h], b
0760   0910 26 00 00      mov b, 0
0761   0913 FD 42 16 11   mov [k], b
0762   0917 26 00 00      mov b, 0
0763   091A FD 42 18 11   mov [l], b
0764   091E 0A 21 09      jmp _if18_exit
0765   0921             _if18_exit:
0766   0921 29 0E 11      mov b, [pc]
0767   0924 D7            push a
0768   0925 11            mov a, b
0769   0926 26 64 00      mov b, 100
0770   0929 AC            mul a, b
0771   092A 11            mov a, b
0772   092B 29 06 11      mov b, [opr]
0773   092E 54            add a, b
0774   092F 27            mov b, a
0775   0930 E4            pop a
0776   0931 FD AB         swp b
0777   0933 D8            push b
0778   0934 07 05 0F      call displaynumber
0779   0937 51 02 00      add sp, 2
0780   093A             _if19_cond:
0781   093A 29 06 11      mov b, [opr]
0782   093D D7            push a
0783   093E 11            mov a, b
0784   093F 26 00 00      mov b, 0
0785   0942 B0            cmp a, b
0786   0943 0E            lodflgs
0787   0944 87 01         and al, %00000001 ; ==
0788   0946 B9 00         cmp al, 0
0789   0948 0E            lodflgs
0790   0949 96            not al
0791   094A 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0792   094C 22 00         mov ah, 0
0793   094E 27            mov b, a
0794   094F E4            pop a
0795   0950 C0 00 00      cmp b, 0
0796   0953 C6 59 09      je _if19_else
0797   0956             _if19_true:
0798   0956 0A 7F 0E      jmp _if19_exit
0799   0959             _if19_else:
0800   0959             _if20_cond:
0801   0959 29 06 11      mov b, [opr]
0802   095C D7            push a
0803   095D 11            mov a, b
0804   095E 26 01 00      mov b, 1
0805   0961 B0            cmp a, b
0806   0962 0E            lodflgs
0807   0963 87 01         and al, %00000001 ; ==
0808   0965 B9 00         cmp al, 0
0809   0967 0E            lodflgs
0810   0968 96            not al
0811   0969 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0812   096B 22 00         mov ah, 0
0813   096D 27            mov b, a
0814   096E E4            pop a
0815   096F C0 00 00      cmp b, 0
0816   0972 C6 D5 0B      je _if20_else
0817   0975             _if20_true:
0818   0975 26 00 00      mov b, 0
0819   0978 FD 42 16 11   mov [k], b
0820   097C             _if21_cond:
0821   097C 29 0C 11      mov b, [datadr3]
0822   097F D7            push a
0823   0980 11            mov a, b
0824   0981 26 06 00      mov b, 6
0825   0984 B0            cmp a, b
0826   0985 0E            lodflgs
0827   0986 87 03         and al, %00000011
0828   0988 B9 00         cmp al, %00000000
0829   098A 0E            lodflgs
0830   098B 87 01         and al, %00000001 ; >
0831   098D B9 00         cmp al, 0
0832   098F 0E            lodflgs
0833   0990 96            not al
0834   0991 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0835   0993 22 00         mov ah, 0
0836   0995 27            mov b, a
0837   0996 E4            pop a
0838   0997 C0 00 00      cmp b, 0
0839   099A C6 B6 09      je _if21_exit
0840   099D             _if21_true:
0841   099D 29 0C 11      mov b, [datadr3]
0842   09A0 D7            push a
0843   09A1 11            mov a, b
0844   09A2 26 07 00      mov b, 7
0845   09A5 60            sub a, b
0846   09A6 27            mov b, a
0847   09A7 E4            pop a
0848   09A8 FD 42 0C 11   mov [datadr3], b
0849   09AC 26 40 00      mov b, 64
0850   09AF FD 42 16 11   mov [k], b
0851   09B3 0A B6 09      jmp _if21_exit
0852   09B6             _if21_exit:
0853   09B6             _if22_cond:
0854   09B6 29 10 10      mov b, [datum]
0855   09B9 D7            push a
0856   09BA 74            mov d, b
0857   09BB 29 08 11      mov b, [datadr1]
0858   09BE 10 02 00      mov a, 2
0859   09C1 AC            mul a, b
0860   09C2 5A            add d, b
0861   09C3 2A            mov b, [d]
0862   09C4 11            mov a, b
0863   09C5 26 00 00      mov b, 0
0864   09C8 B0            cmp a, b
0865   09C9 0E            lodflgs
0866   09CA 87 01         and al, %00000001 ; ==
0867   09CC B9 00         cmp al, 0
0868   09CE 0E            lodflgs
0869   09CF 96            not al
0870   09D0 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0871   09D2 22 00         mov ah, 0
0872   09D4 27            mov b, a
0873   09D5 11            mov a, b
0874   09D6 AF 00 00      cmp a, 0
0875   09D9 0E            lodflgs
0876   09DA 96            not al
0877   09DB 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
0878   09DD 29 0C 11      mov b, [datadr3]
0879   09E0 D7            push a
0880   09E1 11            mov a, b
0881   09E2 26 00 00      mov b, 0
0882   09E5 B0            cmp a, b
0883   09E6 0E            lodflgs
0884   09E7 87 01         and al, %00000001 ; ==
0885   09E9 B9 00         cmp al, 0
0886   09EB 0E            lodflgs
0887   09EC 96            not al
0888   09ED 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0889   09EF 22 00         mov ah, 0
0890   09F1 27            mov b, a
0891   09F2 C0 00 00      cmp b, 0
0892   09F5 0E            lodflgs
0893   09F6 96            not al
0894   09F7 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
0895   09F9 22 00         mov ah, 0
0896   09FB 27            mov b, a
0897   09FC E4            pop a
0898   09FD 86            and a, b
0899   09FE 27            mov b, a
0900   09FF 11            mov a, b
0901   0A00 29 10 10      mov b, [datum]
0902   0A03 D7            push a
0903   0A04 74            mov d, b
0904   0A05 29 08 11      mov b, [datadr1]
0905   0A08 10 02 00      mov a, 2
0906   0A0B AC            mul a, b
0907   0A0C 5A            add d, b
0908   0A0D 2A            mov b, [d]
0909   0A0E 11            mov a, b
0910   0A0F 26 87 93      mov b, 37767
0911   0A12 B0            cmp a, b
0912   0A13 0E            lodflgs
0913   0A14 87 03         and al, %00000011
0914   0A16 B9 00         cmp al, %00000000
0915   0A18 0E            lodflgs
0916   0A19 87 01         and al, %00000001 ; >
0917   0A1B B9 00         cmp al, 0
0918   0A1D 0E            lodflgs
0919   0A1E 96            not al
0920   0A1F 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0921   0A21 22 00         mov ah, 0
0922   0A23 27            mov b, a
0923   0A24 11            mov a, b
0924   0A25 AF 00 00      cmp a, 0
0925   0A28 0E            lodflgs
0926   0A29 96            not al
0927   0A2A 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
0928   0A2C 29 0C 11      mov b, [datadr3]
0929   0A2F D7            push a
0930   0A30 11            mov a, b
0931   0A31 26 02 00      mov b, 2
0932   0A34 B0            cmp a, b
0933   0A35 0E            lodflgs
0934   0A36 87 01         and al, %00000001 ; ==
0935   0A38 B9 00         cmp al, 0
0936   0A3A 0E            lodflgs
0937   0A3B 96            not al
0938   0A3C 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0939   0A3E 22 00         mov ah, 0
0940   0A40 27            mov b, a
0941   0A41 C0 00 00      cmp b, 0
0942   0A44 0E            lodflgs
0943   0A45 96            not al
0944   0A46 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
0945   0A48 22 00         mov ah, 0
0946   0A4A 27            mov b, a
0947   0A4B E4            pop a
0948   0A4C 86            and a, b
0949   0A4D 27            mov b, a
0950   0A4E E4            pop a
0951   0A4F 8A            or a, b
0952   0A50 27            mov b, a
0953   0A51 11            mov a, b
0954   0A52 29 10 10      mov b, [datum]
0955   0A55 D7            push a
0956   0A56 74            mov d, b
0957   0A57 29 08 11      mov b, [datadr1]
0958   0A5A 10 02 00      mov a, 2
0959   0A5D AC            mul a, b
0960   0A5E 5A            add d, b
0961   0A5F 2A            mov b, [d]
0962   0A60 11            mov a, b
0963   0A61 26 FF 7F      mov b, 32767
0964   0A64 B0            cmp a, b
0965   0A65 0E            lodflgs
0966   0A66 87 03         and al, %00000011
0967   0A68 8F 02         xor al, %00000010 ; >=
0968   0A6A B9 00         cmp al, 0
0969   0A6C 0E            lodflgs
0970   0A6D 96            not al
0971   0A6E 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0972   0A70 22 00         mov ah, 0
0973   0A72 27            mov b, a
0974   0A73 11            mov a, b
0975   0A74 AF 00 00      cmp a, 0
0976   0A77 0E            lodflgs
0977   0A78 96            not al
0978   0A79 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
0979   0A7B 29 0C 11      mov b, [datadr3]
0980   0A7E D7            push a
0981   0A7F 11            mov a, b
0982   0A80 26 04 00      mov b, 4
0983   0A83 B0            cmp a, b
0984   0A84 0E            lodflgs
0985   0A85 87 01         and al, %00000001 ; ==
0986   0A87 B9 00         cmp al, 0
0987   0A89 0E            lodflgs
0988   0A8A 96            not al
0989   0A8B 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0990   0A8D 22 00         mov ah, 0
0991   0A8F 27            mov b, a
0992   0A90 C0 00 00      cmp b, 0
0993   0A93 0E            lodflgs
0994   0A94 96            not al
0995   0A95 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
0996   0A97 22 00         mov ah, 0
0997   0A99 27            mov b, a
0998   0A9A E4            pop a
0999   0A9B 86            and a, b
1000   0A9C 27            mov b, a
1001   0A9D E4            pop a
1002   0A9E 8A            or a, b
1003   0A9F 27            mov b, a
1004   0AA0 11            mov a, b
1005   0AA1 29 10 10      mov b, [datum]
1006   0AA4 D7            push a
1007   0AA5 74            mov d, b
1008   0AA6 29 08 11      mov b, [datadr1]
1009   0AA9 10 02 00      mov a, 2
1010   0AAC AC            mul a, b
1011   0AAD 5A            add d, b
1012   0AAE 2A            mov b, [d]
1013   0AAF 11            mov a, b
1014   0AB0 26 00 00      mov b, 0
1015   0AB3 B0            cmp a, b
1016   0AB4 0E            lodflgs
1017   0AB5 87 03         and al, %00000011
1018   0AB7 B9 00         cmp al, %00000000
1019   0AB9 0E            lodflgs
1020   0ABA 87 01         and al, %00000001 ; >
1021   0ABC B9 00         cmp al, 0
1022   0ABE 0E            lodflgs
1023   0ABF 96            not al
1024   0AC0 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1025   0AC2 22 00         mov ah, 0
1026   0AC4 27            mov b, a
1027   0AC5 11            mov a, b
1028   0AC6 AF 00 00      cmp a, 0
1029   0AC9 0E            lodflgs
1030   0ACA 96            not al
1031   0ACB 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
1032   0ACD 29 0C 11      mov b, [datadr3]
1033   0AD0 D7            push a
1034   0AD1 11            mov a, b
1035   0AD2 26 01 00      mov b, 1
1036   0AD5 B0            cmp a, b
1037   0AD6 0E            lodflgs
1038   0AD7 87 01         and al, %00000001 ; ==
1039   0AD9 B9 00         cmp al, 0
1040   0ADB 0E            lodflgs
1041   0ADC 96            not al
1042   0ADD 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1043   0ADF 22 00         mov ah, 0
1044   0AE1 27            mov b, a
1045   0AE2 C0 00 00      cmp b, 0
1046   0AE5 0E            lodflgs
1047   0AE6 96            not al
1048   0AE7 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
1049   0AE9 22 00         mov ah, 0
1050   0AEB 27            mov b, a
1051   0AEC E4            pop a
1052   0AED 86            and a, b
1053   0AEE 27            mov b, a
1054   0AEF E4            pop a
1055   0AF0 8A            or a, b
1056   0AF1 27            mov b, a
1057   0AF2 11            mov a, b
1058   0AF3 29 10 10      mov b, [datum]
1059   0AF6 D7            push a
1060   0AF7 74            mov d, b
1061   0AF8 29 08 11      mov b, [datadr1]
1062   0AFB 10 02 00      mov a, 2
1063   0AFE AC            mul a, b
1064   0AFF 5A            add d, b
1065   0B00 2A            mov b, [d]
1066   0B01 11            mov a, b
1067   0B02 26 00 00      mov b, 0
1068   0B05 B0            cmp a, b
1069   0B06 0E            lodflgs
1070   0B07 87 03         and al, %00000011
1071   0B09 8F 02         xor al, %00000010 ; >=
1072   0B0B B9 00         cmp al, 0
1073   0B0D 0E            lodflgs
1074   0B0E 96            not al
1075   0B0F 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1076   0B11 22 00         mov ah, 0
1077   0B13 27            mov b, a
1078   0B14 11            mov a, b
1079   0B15 AF 00 00      cmp a, 0
1080   0B18 0E            lodflgs
1081   0B19 96            not al
1082   0B1A 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
1083   0B1C 29 0C 11      mov b, [datadr3]
1084   0B1F D7            push a
1085   0B20 11            mov a, b
1086   0B21 26 03 00      mov b, 3
1087   0B24 B0            cmp a, b
1088   0B25 0E            lodflgs
1089   0B26 87 01         and al, %00000001 ; ==
1090   0B28 B9 00         cmp al, 0
1091   0B2A 0E            lodflgs
1092   0B2B 96            not al
1093   0B2C 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1094   0B2E 22 00         mov ah, 0
1095   0B30 27            mov b, a
1096   0B31 C0 00 00      cmp b, 0
1097   0B34 0E            lodflgs
1098   0B35 96            not al
1099   0B36 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
1100   0B38 22 00         mov ah, 0
1101   0B3A 27            mov b, a
1102   0B3B E4            pop a
1103   0B3C 86            and a, b
1104   0B3D 27            mov b, a
1105   0B3E E4            pop a
1106   0B3F 8A            or a, b
1107   0B40 27            mov b, a
1108   0B41 11            mov a, b
1109   0B42 29 10 10      mov b, [datum]
1110   0B45 D7            push a
1111   0B46 74            mov d, b
1112   0B47 29 08 11      mov b, [datadr1]
1113   0B4A 10 02 00      mov a, 2
1114   0B4D AC            mul a, b
1115   0B4E 5A            add d, b
1116   0B4F 2A            mov b, [d]
1117   0B50 11            mov a, b
1118   0B51 26 00 00      mov b, 0
1119   0B54 B0            cmp a, b
1120   0B55 0E            lodflgs
1121   0B56 87 01         and al, %00000001
1122   0B58 8F 01         xor al, %00000001 ; !=
1123   0B5A B9 00         cmp al, 0
1124   0B5C 0E            lodflgs
1125   0B5D 96            not al
1126   0B5E 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1127   0B60 22 00         mov ah, 0
1128   0B62 27            mov b, a
1129   0B63 11            mov a, b
1130   0B64 AF 00 00      cmp a, 0
1131   0B67 0E            lodflgs
1132   0B68 96            not al
1133   0B69 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
1134   0B6B 29 0C 11      mov b, [datadr3]
1135   0B6E D7            push a
1136   0B6F 11            mov a, b
1137   0B70 26 05 00      mov b, 5
1138   0B73 B0            cmp a, b
1139   0B74 0E            lodflgs
1140   0B75 87 01         and al, %00000001 ; ==
1141   0B77 B9 00         cmp al, 0
1142   0B79 0E            lodflgs
1143   0B7A 96            not al
1144   0B7B 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1145   0B7D 22 00         mov ah, 0
1146   0B7F 27            mov b, a
1147   0B80 C0 00 00      cmp b, 0
1148   0B83 0E            lodflgs
1149   0B84 96            not al
1150   0B85 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
1151   0B87 22 00         mov ah, 0
1152   0B89 27            mov b, a
1153   0B8A E4            pop a
1154   0B8B 86            and a, b
1155   0B8C 27            mov b, a
1156   0B8D E4            pop a
1157   0B8E 8A            or a, b
1158   0B8F 27            mov b, a
1159   0B90 11            mov a, b
1160   0B91 29 0C 11      mov b, [datadr3]
1161   0B94 D7            push a
1162   0B95 11            mov a, b
1163   0B96 26 06 00      mov b, 6
1164   0B99 B0            cmp a, b
1165   0B9A 0E            lodflgs
1166   0B9B 87 01         and al, %00000001 ; ==
1167   0B9D B9 00         cmp al, 0
1168   0B9F 0E            lodflgs
1169   0BA0 96            not al
1170   0BA1 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1171   0BA3 22 00         mov ah, 0
1172   0BA5 27            mov b, a
1173   0BA6 E4            pop a
1174   0BA7 8A            or a, b
1175   0BA8 27            mov b, a
1176   0BA9 E4            pop a
1177   0BAA C0 00 00      cmp b, 0
1178   0BAD C6 C9 0B      je _if22_else
1179   0BB0             _if22_true:
1180   0BB0 29 0A 11      mov b, [datadr2]
1181   0BB3 D7            push a
1182   0BB4 11            mov a, b
1183   0BB5 29 16 11      mov b, [k]
1184   0BB8 54            add a, b
1185   0BB9 27            mov b, a
1186   0BBA E4            pop a
1187   0BBB FD 42 0E 11   mov [pc], b
1188   0BBF 26 00 00      mov b, 0
1189   0BC2 FD 42 16 11   mov [k], b
1190   0BC6 0A D2 0B      jmp _if22_exit
1191   0BC9             _if22_else:
1192   0BC9 29 0E 11      mov b, [pc]
1193   0BCC FD 77         inc b
1194   0BCE FD 42 0E 11   mov [pc], b
1195   0BD2             _if22_exit:
1196   0BD2 0A 7F 0E      jmp _if20_exit
1197   0BD5             _if20_else:
1198   0BD5             _if23_cond:
1199   0BD5 29 06 11      mov b, [opr]
1200   0BD8 D7            push a
1201   0BD9 11            mov a, b
1202   0BDA 26 02 00      mov b, 2
1203   0BDD B0            cmp a, b
1204   0BDE 0E            lodflgs
1205   0BDF 87 01         and al, %00000001 ; ==
1206   0BE1 B9 00         cmp al, 0
1207   0BE3 0E            lodflgs
1208   0BE4 96            not al
1209   0BE5 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1210   0BE7 22 00         mov ah, 0
1211   0BE9 27            mov b, a
1212   0BEA E4            pop a
1213   0BEB C0 00 00      cmp b, 0
1214   0BEE C6 2D 0C      je _if23_else
1215   0BF1             _if23_true:
1216   0BF1 29 10 10      mov b, [datum]
1217   0BF4 D7            push a
1218   0BF5 74            mov d, b
1219   0BF6 29 08 11      mov b, [datadr1]
1220   0BF9 10 02 00      mov a, 2
1221   0BFC AC            mul a, b
1222   0BFD 5A            add d, b
1223   0BFE 2A            mov b, [d]
1224   0BFF E4            pop a
1225   0C00 FD 42 10 11   mov [h], b
1226   0C04 29 10 10      mov b, [datum]
1227   0C07 D7            push a
1228   0C08 74            mov d, b
1229   0C09 29 0A 11      mov b, [datadr2]
1230   0C0C 10 02 00      mov a, 2
1231   0C0F AC            mul a, b
1232   0C10 5A            add d, b
1233   0C11 2A            mov b, [d]
1234   0C12 E4            pop a
1235   0C13 FD 42 16 11   mov [k], b
1236   0C17 29 10 10      mov b, [datum]
1237   0C1A D7            push a
1238   0C1B 74            mov d, b
1239   0C1C 29 0C 11      mov b, [datadr3]
1240   0C1F 10 02 00      mov a, 2
1241   0C22 AC            mul a, b
1242   0C23 5A            add d, b
1243   0C24 2A            mov b, [d]
1244   0C25 E4            pop a
1245   0C26 FD 42 18 11   mov [l], b
1246   0C2A 0A 7F 0E      jmp _if23_exit
1247   0C2D             _if23_else:
1248   0C2D             _if24_cond:
1249   0C2D 29 06 11      mov b, [opr]
1250   0C30 D7            push a
1251   0C31 11            mov a, b
1252   0C32 26 05 00      mov b, 5
1253   0C35 B0            cmp a, b
1254   0C36 0E            lodflgs
1255   0C37 87 01         and al, %00000001 ; ==
1256   0C39 B9 00         cmp al, 0
1257   0C3B 0E            lodflgs
1258   0C3C 96            not al
1259   0C3D 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1260   0C3F 22 00         mov ah, 0
1261   0C41 27            mov b, a
1262   0C42 E4            pop a
1263   0C43 C0 00 00      cmp b, 0
1264   0C46 C6 67 0C      je _if24_else
1265   0C49             _if24_true:
1266   0C49 29 10 10      mov b, [datum]
1267   0C4C 74            mov d, b
1268   0C4D 29 0C 11      mov b, [datadr3]
1269   0C50 10 02 00      mov a, 2
1270   0C53 AC            mul a, b
1271   0C54 5A            add d, b
1272   0C55 DA            push d
1273   0C56 29 0A 11      mov b, [datadr2]
1274   0C59 D7            push a
1275   0C5A 11            mov a, b
1276   0C5B 29 08 11      mov b, [datadr1]
1277   0C5E 54            add a, b
1278   0C5F 27            mov b, a
1279   0C60 E4            pop a
1280   0C61 E7            pop d
1281   0C62 11            mov a, b
1282   0C63 43            mov [d], a
1283   0C64 0A 7F 0E      jmp _if24_exit
1284   0C67             _if24_else:
1285   0C67             _if25_cond:
1286   0C67 29 06 11      mov b, [opr]
1287   0C6A D7            push a
1288   0C6B 11            mov a, b
1289   0C6C 26 06 00      mov b, 6
1290   0C6F B0            cmp a, b
1291   0C70 0E            lodflgs
1292   0C71 87 01         and al, %00000001 ; ==
1293   0C73 B9 00         cmp al, 0
1294   0C75 0E            lodflgs
1295   0C76 96            not al
1296   0C77 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1297   0C79 22 00         mov ah, 0
1298   0C7B 27            mov b, a
1299   0C7C E4            pop a
1300   0C7D C0 00 00      cmp b, 0
1301   0C80 C6 A5 0C      je _if25_else
1302   0C83             _if25_true:
1303   0C83 29 10 10      mov b, [datum]
1304   0C86 74            mov d, b
1305   0C87 29 0C 11      mov b, [datadr3]
1306   0C8A 10 02 00      mov a, 2
1307   0C8D AC            mul a, b
1308   0C8E 5A            add d, b
1309   0C8F DA            push d
1310   0C90 29 10 10      mov b, [datum]
1311   0C93 D7            push a
1312   0C94 74            mov d, b
1313   0C95 29 0A 11      mov b, [datadr2]
1314   0C98 10 02 00      mov a, 2
1315   0C9B AC            mul a, b
1316   0C9C 5A            add d, b
1317   0C9D 2A            mov b, [d]
1318   0C9E E4            pop a
1319   0C9F E7            pop d
1320   0CA0 11            mov a, b
1321   0CA1 43            mov [d], a
1322   0CA2 0A 7F 0E      jmp _if25_exit
1323   0CA5             _if25_else:
1324   0CA5             _if26_cond:
1325   0CA5 29 06 11      mov b, [opr]
1326   0CA8 D7            push a
1327   0CA9 11            mov a, b
1328   0CAA 26 08 00      mov b, 8
1329   0CAD B0            cmp a, b
1330   0CAE 0E            lodflgs
1331   0CAF 87 01         and al, %00000001 ; ==
1332   0CB1 B9 00         cmp al, 0
1333   0CB3 0E            lodflgs
1334   0CB4 96            not al
1335   0CB5 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1336   0CB7 22 00         mov ah, 0
1337   0CB9 27            mov b, a
1338   0CBA E4            pop a
1339   0CBB C0 00 00      cmp b, 0
1340   0CBE C6 EF 0C      je _if26_else
1341   0CC1             _if26_true:
1342   0CC1 29 10 10      mov b, [datum]
1343   0CC4 74            mov d, b
1344   0CC5 29 10 10      mov b, [datum]
1345   0CC8 D7            push a
1346   0CC9 74            mov d, b
1347   0CCA 29 0C 11      mov b, [datadr3]
1348   0CCD 10 02 00      mov a, 2
1349   0CD0 AC            mul a, b
1350   0CD1 5A            add d, b
1351   0CD2 2A            mov b, [d]
1352   0CD3 E4            pop a
1353   0CD4 10 02 00      mov a, 2
1354   0CD7 AC            mul a, b
1355   0CD8 5A            add d, b
1356   0CD9 DA            push d
1357   0CDA 29 10 10      mov b, [datum]
1358   0CDD D7            push a
1359   0CDE 74            mov d, b
1360   0CDF 29 0A 11      mov b, [datadr2]
1361   0CE2 10 02 00      mov a, 2
1362   0CE5 AC            mul a, b
1363   0CE6 5A            add d, b
1364   0CE7 2A            mov b, [d]
1365   0CE8 E4            pop a
1366   0CE9 E7            pop d
1367   0CEA 11            mov a, b
1368   0CEB 43            mov [d], a
1369   0CEC 0A 7F 0E      jmp _if26_exit
1370   0CEF             _if26_else:
1371   0CEF             _if27_cond:
1372   0CEF 29 06 11      mov b, [opr]
1373   0CF2 D7            push a
1374   0CF3 11            mov a, b
1375   0CF4 26 09 00      mov b, 9
1376   0CF7 B0            cmp a, b
1377   0CF8 0E            lodflgs
1378   0CF9 87 01         and al, %00000001 ; ==
1379   0CFB B9 00         cmp al, 0
1380   0CFD 0E            lodflgs
1381   0CFE 96            not al
1382   0CFF 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1383   0D01 22 00         mov ah, 0
1384   0D03 27            mov b, a
1385   0D04 E4            pop a
1386   0D05 C0 00 00      cmp b, 0
1387   0D08 C6 3F 0D      je _if27_else
1388   0D0B             _if27_true:
1389   0D0B 29 10 10      mov b, [datum]
1390   0D0E 74            mov d, b
1391   0D0F 29 0C 11      mov b, [datadr3]
1392   0D12 10 02 00      mov a, 2
1393   0D15 AC            mul a, b
1394   0D16 5A            add d, b
1395   0D17 DA            push d
1396   0D18 29 10 10      mov b, [datum]
1397   0D1B D7            push a
1398   0D1C 74            mov d, b
1399   0D1D 29 08 11      mov b, [datadr1]
1400   0D20 10 02 00      mov a, 2
1401   0D23 AC            mul a, b
1402   0D24 5A            add d, b
1403   0D25 2A            mov b, [d]
1404   0D26 11            mov a, b
1405   0D27 29 10 10      mov b, [datum]
1406   0D2A D7            push a
1407   0D2B 74            mov d, b
1408   0D2C 29 0A 11      mov b, [datadr2]
1409   0D2F 10 02 00      mov a, 2
1410   0D32 AC            mul a, b
1411   0D33 5A            add d, b
1412   0D34 2A            mov b, [d]
1413   0D35 E4            pop a
1414   0D36 54            add a, b
1415   0D37 27            mov b, a
1416   0D38 E4            pop a
1417   0D39 E7            pop d
1418   0D3A 11            mov a, b
1419   0D3B 43            mov [d], a
1420   0D3C 0A 7F 0E      jmp _if27_exit
1421   0D3F             _if27_else:
1422   0D3F             _if28_cond:
1423   0D3F 29 06 11      mov b, [opr]
1424   0D42 D7            push a
1425   0D43 11            mov a, b
1426   0D44 26 0A 00      mov b, 10
1427   0D47 B0            cmp a, b
1428   0D48 0E            lodflgs
1429   0D49 87 01         and al, %00000001 ; ==
1430   0D4B B9 00         cmp al, 0
1431   0D4D 0E            lodflgs
1432   0D4E 96            not al
1433   0D4F 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1434   0D51 22 00         mov ah, 0
1435   0D53 27            mov b, a
1436   0D54 E4            pop a
1437   0D55 C0 00 00      cmp b, 0
1438   0D58 C6 8F 0D      je _if28_else
1439   0D5B             _if28_true:
1440   0D5B 29 10 10      mov b, [datum]
1441   0D5E 74            mov d, b
1442   0D5F 29 0C 11      mov b, [datadr3]
1443   0D62 10 02 00      mov a, 2
1444   0D65 AC            mul a, b
1445   0D66 5A            add d, b
1446   0D67 DA            push d
1447   0D68 29 10 10      mov b, [datum]
1448   0D6B D7            push a
1449   0D6C 74            mov d, b
1450   0D6D 29 08 11      mov b, [datadr1]
1451   0D70 10 02 00      mov a, 2
1452   0D73 AC            mul a, b
1453   0D74 5A            add d, b
1454   0D75 2A            mov b, [d]
1455   0D76 11            mov a, b
1456   0D77 29 10 10      mov b, [datum]
1457   0D7A D7            push a
1458   0D7B 74            mov d, b
1459   0D7C 29 0A 11      mov b, [datadr2]
1460   0D7F 10 02 00      mov a, 2
1461   0D82 AC            mul a, b
1462   0D83 5A            add d, b
1463   0D84 2A            mov b, [d]
1464   0D85 E4            pop a
1465   0D86 60            sub a, b
1466   0D87 27            mov b, a
1467   0D88 E4            pop a
1468   0D89 E7            pop d
1469   0D8A 11            mov a, b
1470   0D8B 43            mov [d], a
1471   0D8C 0A 7F 0E      jmp _if28_exit
1472   0D8F             _if28_else:
1473   0D8F             _if29_cond:
1474   0D8F 29 06 11      mov b, [opr]
1475   0D92 D7            push a
1476   0D93 11            mov a, b
1477   0D94 26 0B 00      mov b, 11
1478   0D97 B0            cmp a, b
1479   0D98 0E            lodflgs
1480   0D99 87 01         and al, %00000001 ; ==
1481   0D9B B9 00         cmp al, 0
1482   0D9D 0E            lodflgs
1483   0D9E 96            not al
1484   0D9F 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1485   0DA1 22 00         mov ah, 0
1486   0DA3 27            mov b, a
1487   0DA4 E4            pop a
1488   0DA5 C0 00 00      cmp b, 0
1489   0DA8 C6 E8 0D      je _if29_else
1490   0DAB             _if29_true:
1491   0DAB 29 10 10      mov b, [datum]
1492   0DAE 74            mov d, b
1493   0DAF 29 0C 11      mov b, [datadr3]
1494   0DB2 10 02 00      mov a, 2
1495   0DB5 AC            mul a, b
1496   0DB6 5A            add d, b
1497   0DB7 DA            push d
1498   0DB8 29 10 10      mov b, [datum]
1499   0DBB D7            push a
1500   0DBC 74            mov d, b
1501   0DBD 29 08 11      mov b, [datadr1]
1502   0DC0 10 02 00      mov a, 2
1503   0DC3 AC            mul a, b
1504   0DC4 5A            add d, b
1505   0DC5 2A            mov b, [d]
1506   0DC6 11            mov a, b
1507   0DC7 29 10 10      mov b, [datum]
1508   0DCA D7            push a
1509   0DCB 74            mov d, b
1510   0DCC 29 0A 11      mov b, [datadr2]
1511   0DCF 10 02 00      mov a, 2
1512   0DD2 AC            mul a, b
1513   0DD3 5A            add d, b
1514   0DD4 2A            mov b, [d]
1515   0DD5 E4            pop a
1516   0DD6 AC            mul a, b
1517   0DD7 11            mov a, b
1518   0DD8 26 64 00      mov b, 100
1519   0DDB AE            div a, b
1520   0DDC FD 78         mov g, a
1521   0DDE 11            mov a, b
1522   0DDF FD 27         mov b, g
1523   0DE1 E4            pop a
1524   0DE2 E7            pop d
1525   0DE3 11            mov a, b
1526   0DE4 43            mov [d], a
1527   0DE5 0A 7F 0E      jmp _if29_exit
1528   0DE8             _if29_else:
1529   0DE8             _if30_cond:
1530   0DE8 29 06 11      mov b, [opr]
1531   0DEB D7            push a
1532   0DEC 11            mov a, b
1533   0DED 26 0C 00      mov b, 12
1534   0DF0 B0            cmp a, b
1535   0DF1 0E            lodflgs
1536   0DF2 87 01         and al, %00000001 ; ==
1537   0DF4 B9 00         cmp al, 0
1538   0DF6 0E            lodflgs
1539   0DF7 96            not al
1540   0DF8 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1541   0DFA 22 00         mov ah, 0
1542   0DFC 27            mov b, a
1543   0DFD E4            pop a
1544   0DFE C0 00 00      cmp b, 0
1545   0E01 C6 7F 0E      je _if30_exit
1546   0E04             _if30_true:
1547   0E04             _if31_cond:
1548   0E04 29 10 10      mov b, [datum]
1549   0E07 D7            push a
1550   0E08 74            mov d, b
1551   0E09 29 0A 11      mov b, [datadr2]
1552   0E0C 10 02 00      mov a, 2
1553   0E0F AC            mul a, b
1554   0E10 5A            add d, b
1555   0E11 2A            mov b, [d]
1556   0E12 11            mov a, b
1557   0E13 26 00 00      mov b, 0
1558   0E16 B0            cmp a, b
1559   0E17 0E            lodflgs
1560   0E18 87 01         and al, %00000001
1561   0E1A 8F 01         xor al, %00000001 ; !=
1562   0E1C B9 00         cmp al, 0
1563   0E1E 0E            lodflgs
1564   0E1F 96            not al
1565   0E20 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1566   0E22 22 00         mov ah, 0
1567   0E24 27            mov b, a
1568   0E25 E4            pop a
1569   0E26 C0 00 00      cmp b, 0
1570   0E29 C6 69 0E      je _if31_else
1571   0E2C             _if31_true:
1572   0E2C 29 10 10      mov b, [datum]
1573   0E2F 74            mov d, b
1574   0E30 29 0C 11      mov b, [datadr3]
1575   0E33 10 02 00      mov a, 2
1576   0E36 AC            mul a, b
1577   0E37 5A            add d, b
1578   0E38 DA            push d
1579   0E39 29 10 10      mov b, [datum]
1580   0E3C D7            push a
1581   0E3D 74            mov d, b
1582   0E3E 29 08 11      mov b, [datadr1]
1583   0E41 10 02 00      mov a, 2
1584   0E44 AC            mul a, b
1585   0E45 5A            add d, b
1586   0E46 2A            mov b, [d]
1587   0E47 11            mov a, b
1588   0E48 26 64 00      mov b, 100
1589   0E4B AC            mul a, b
1590   0E4C 11            mov a, b
1591   0E4D 29 10 10      mov b, [datum]
1592   0E50 D7            push a
1593   0E51 74            mov d, b
1594   0E52 29 0A 11      mov b, [datadr2]
1595   0E55 10 02 00      mov a, 2
1596   0E58 AC            mul a, b
1597   0E59 5A            add d, b
1598   0E5A 2A            mov b, [d]
1599   0E5B E4            pop a
1600   0E5C AE            div a, b
1601   0E5D FD 78         mov g, a
1602   0E5F 11            mov a, b
1603   0E60 FD 27         mov b, g
1604   0E62 E4            pop a
1605   0E63 E7            pop d
1606   0E64 11            mov a, b
1607   0E65 43            mov [d], a
1608   0E66 0A 7C 0E      jmp _if31_exit
1609   0E69             _if31_else:
1610   0E69 29 10 10      mov b, [datum]
1611   0E6C 74            mov d, b
1612   0E6D 29 0C 11      mov b, [datadr3]
1613   0E70 10 02 00      mov a, 2
1614   0E73 AC            mul a, b
1615   0E74 5A            add d, b
1616   0E75 DA            push d
1617   0E76 26 00 00      mov b, 0
1618   0E79 E7            pop d
1619   0E7A 11            mov a, b
1620   0E7B 43            mov [d], a
1621   0E7C             _if31_exit:
1622   0E7C 0A 7F 0E      jmp _if30_exit
1623   0E7F             _if30_exit:
1624   0E7F             _if29_exit:
1625   0E7F             _if28_exit:
1626   0E7F             _if27_exit:
1627   0E7F             _if26_exit:
1628   0E7F             _if25_exit:
1629   0E7F             _if24_exit:
1630   0E7F             _if23_exit:
1631   0E7F             _if20_exit:
1632   0E7F             _if19_exit:
1633   0E7F             _if32_cond:
1634   0E7F 29 06 11      mov b, [opr]
1635   0E82 D7            push a
1636   0E83 11            mov a, b
1637   0E84 26 01 00      mov b, 1
1638   0E87 B0            cmp a, b
1639   0E88 0E            lodflgs
1640   0E89 87 01         and al, %00000001
1641   0E8B 8F 01         xor al, %00000001 ; !=
1642   0E8D B9 00         cmp al, 0
1643   0E8F 0E            lodflgs
1644   0E90 96            not al
1645   0E91 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1646   0E93 22 00         mov ah, 0
1647   0E95 27            mov b, a
1648   0E96 E4            pop a
1649   0E97 C0 00 00      cmp b, 0
1650   0E9A C6 EF 0E      je _if32_exit
1651   0E9D             _if32_true:
1652   0E9D             _if33_cond:
1653   0E9D 29 0E 11      mov b, [pc]
1654   0EA0 D7            push a
1655   0EA1 11            mov a, b
1656   0EA2 26 00 00      mov b, 0
1657   0EA5 B0            cmp a, b
1658   0EA6 0E            lodflgs
1659   0EA7 87 03         and al, %00000011
1660   0EA9 B9 00         cmp al, %00000000
1661   0EAB 0E            lodflgs
1662   0EAC 87 01         and al, %00000001 ; >
1663   0EAE B9 00         cmp al, 0
1664   0EB0 0E            lodflgs
1665   0EB1 96            not al
1666   0EB2 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1667   0EB4 22 00         mov ah, 0
1668   0EB6 27            mov b, a
1669   0EB7 E4            pop a
1670   0EB8 C0 00 00      cmp b, 0
1671   0EBB C6 CA 0E      je _if33_else
1672   0EBE             _if33_true:
1673   0EBE 29 0E 11      mov b, [pc]
1674   0EC1 FD 77         inc b
1675   0EC3 FD 42 0E 11   mov [pc], b
1676   0EC7 0A EC 0E      jmp _if33_exit
1677   0ECA             _if33_else:
1678   0ECA             _if34_cond:
1679   0ECA 29 0E 11      mov b, [pc]
1680   0ECD D7            push a
1681   0ECE 11            mov a, b
1682   0ECF 26 00 00      mov b, 0
1683   0ED2 B0            cmp a, b
1684   0ED3 0E            lodflgs
1685   0ED4 87 01         and al, %00000001 ; ==
1686   0ED6 B9 00         cmp al, 0
1687   0ED8 0E            lodflgs
1688   0ED9 96            not al
1689   0EDA 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1690   0EDC 22 00         mov ah, 0
1691   0EDE 27            mov b, a
1692   0EDF E4            pop a
1693   0EE0 C0 00 00      cmp b, 0
1694   0EE3 C6 EC 0E      je _if34_exit
1695   0EE6             _if34_true:
1696   0EE6 0A F2 0E      jmp _while15_exit ; while break
1697   0EE9 0A EC 0E      jmp _if34_exit
1698   0EEC             _if34_exit:
1699   0EEC             _if33_exit:
1700   0EEC 0A EF 0E      jmp _if32_exit
1701   0EEF             _if32_exit:
1702   0EEF 0A 9F 07      jmp _while15_cond
1703   0EF2             _while15_exit:
1704   0EF2 0A 02 04      jmp _while1_cond
1705   0EF5             _while1_exit:
1706   0EF5             readint:
1707   0EF5 D2            push bp
1708   0EF6 9B            mov bp, sp
1709   0EF7 52 02 00      sub sp, 2 ; n
1710   0EFA             
1711   0EFA             ; --- BEGIN INLINE ASM BLOCK
1712   0EFA 07 6A 14      call scan_u16d
1713   0EFD 45 FF FF      mov [bp + -1], a
1714   0F00             ; --- END INLINE ASM BLOCK
1715   0F00             
1716   0F00 2C FF FF      mov b, [bp + -1] ; n
1717   0F03 F9            leave
1718   0F04 09            ret
1719   0F05             displaynumber:
1720   0F05 D2            push bp
1721   0F06 9B            mov bp, sp
1722   0F07             
1723   0F07             ; --- BEGIN INLINE ASM BLOCK
1724   0F07 17 05 00      mov a, [bp + 5]
1725   0F0A 07 95 13      call print_u16d
1726   0F0D 14 18 0F      mov a, [ss]
1727   0F10 3C            mov d, a
1728   0F11 07 6C 13      call puts
1729   0F14             ; --- END INLINE ASM BLOCK
1730   0F14             
1731   0F14 F9            leave
1732   0F15 09            ret
1733   0F16             ; --- END TEXT BLOCK
1734   0F16             
1735   0F16             ; --- BEGIN DATA BLOCK
1736   0F16 0A 00       ss_data: .db "\n", 0
1737   0F18 16 0F       ss: .dw ss_data
1738   0F1A 00 00 00 00 datum_data: .fill 246, 0
1738   0F1E 00 00 00 00 
1738   0F22 00 00 00 00 
1738   0F26 00 00 00 00 
1738   0F2A 00 00 00 00 
1738   0F2E 00 00 00 00 
1738   0F32 00 00 00 00 
1738   0F36 00 00 00 00 
1738   0F3A 00 00 00 00 
1738   0F3E 00 00 00 00 
1738   0F42 00 00 00 00 
1738   0F46 00 00 00 00 
1738   0F4A 00 00 00 00 
1738   0F4E 00 00 00 00 
1738   0F52 00 00 00 00 
1738   0F56 00 00 00 00 
1738   0F5A 00 00 00 00 
1738   0F5E 00 00 00 00 
1738   0F62 00 00 00 00 
1738   0F66 00 00 00 00 
1738   0F6A 00 00 00 00 
1738   0F6E 00 00 00 00 
1738   0F72 00 00 00 00 
1738   0F76 00 00 00 00 
1738   0F7A 00 00 00 00 
1738   0F7E 00 00 00 00 
1738   0F82 00 00 00 00 
1738   0F86 00 00 00 00 
1738   0F8A 00 00 00 00 
1738   0F8E 00 00 00 00 
1738   0F92 00 00 00 00 
1738   0F96 00 00 00 00 
1738   0F9A 00 00 00 00 
1738   0F9E 00 00 00 00 
1738   0FA2 00 00 00 00 
1738   0FA6 00 00 00 00 
1738   0FAA 00 00 00 00 
1738   0FAE 00 00 00 00 
1738   0FB2 00 00 00 00 
1738   0FB6 00 00 00 00 
1738   0FBA 00 00 00 00 
1738   0FBE 00 00 00 00 
1738   0FC2 00 00 00 00 
1738   0FC6 00 00 00 00 
1738   0FCA 00 00 00 00 
1738   0FCE 00 00 00 00 
1738   0FD2 00 00 00 00 
1738   0FD6 00 00 00 00 
1738   0FDA 00 00 00 00 
1738   0FDE 00 00 00 00 
1738   0FE2 00 00 00 00 
1738   0FE6 00 00 00 00 
1738   0FEA 00 00 00 00 
1738   0FEE 00 00 00 00 
1738   0FF2 00 00 00 00 
1738   0FF6 00 00 00 00 
1738   0FFA 00 00 00 00 
1738   0FFE 00 00 00 00 
1738   1002 00 00 00 00 
1738   1006 00 00 00 00 
1738   100A 00 00 00 00 
1738   100E 00 00 
1739   1010 1A 0F       datum: .dw datum_data
1740   1012 00 00 00 00 instruction_data: .fill 240, 0
1740   1016 00 00 00 00 
1740   101A 00 00 00 00 
1740   101E 00 00 00 00 
1740   1022 00 00 00 00 
1740   1026 00 00 00 00 
1740   102A 00 00 00 00 
1740   102E 00 00 00 00 
1740   1032 00 00 00 00 
1740   1036 00 00 00 00 
1740   103A 00 00 00 00 
1740   103E 00 00 00 00 
1740   1042 00 00 00 00 
1740   1046 00 00 00 00 
1740   104A 00 00 00 00 
1740   104E 00 00 00 00 
1740   1052 00 00 00 00 
1740   1056 00 00 00 00 
1740   105A 00 00 00 00 
1740   105E 00 00 00 00 
1740   1062 00 00 00 00 
1740   1066 00 00 00 00 
1740   106A 00 00 00 00 
1740   106E 00 00 00 00 
1740   1072 00 00 00 00 
1740   1076 00 00 00 00 
1740   107A 00 00 00 00 
1740   107E 00 00 00 00 
1740   1082 00 00 00 00 
1740   1086 00 00 00 00 
1740   108A 00 00 00 00 
1740   108E 00 00 00 00 
1740   1092 00 00 00 00 
1740   1096 00 00 00 00 
1740   109A 00 00 00 00 
1740   109E 00 00 00 00 
1740   10A2 00 00 00 00 
1740   10A6 00 00 00 00 
1740   10AA 00 00 00 00 
1740   10AE 00 00 00 00 
1740   10B2 00 00 00 00 
1740   10B6 00 00 00 00 
1740   10BA 00 00 00 00 
1740   10BE 00 00 00 00 
1740   10C2 00 00 00 00 
1740   10C6 00 00 00 00 
1740   10CA 00 00 00 00 
1740   10CE 00 00 00 00 
1740   10D2 00 00 00 00 
1740   10D6 00 00 00 00 
1740   10DA 00 00 00 00 
1740   10DE 00 00 00 00 
1740   10E2 00 00 00 00 
1740   10E6 00 00 00 00 
1740   10EA 00 00 00 00 
1740   10EE 00 00 00 00 
1740   10F2 00 00 00 00 
1740   10F6 00 00 00 00 
1740   10FA 00 00 00 00 
1740   10FE 00 00 00 00 
1741   1102 12 10       instruction: .dw instruction_data
1742   1104 00 00       cmdadr: .dw 0
1743   1106 00 00       opr: .dw 0
1744   1108 00 00       datadr1: .dw 0
1745   110A 00 00       datadr2: .dw 0
1746   110C 00 00       datadr3: .dw 0
1747   110E 00 00       pc: .dw 0
1748   1110 00 00       h: .dw 0
1749   1112 00 00       i: .dw 0
1750   1114 00 00       j: .dw 0
1751   1116 00 00       k: .dw 0
1752   1118 00 00       l: .dw 0
1753   111A 00 00       p: .dw 0
1754   111C 00 00       runlimit: .dw 0
1755   111E 00 00       exitflag: .dw 0
1756   1120             ; --- END DATA BLOCK
1757   1120             
1758   1120             ; --- BEGIN INCLUDE BLOCK
1759   1120             .include "lib/stdio.asm"
0001+  1120             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  1120             ; stdio.s
0003+  1120             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  1120             .include "lib/string.asm"
0001++ 1120             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 1120             ; string.s
0003++ 1120             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 1120             
0005++ 1120             
0006++ 1120             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 1120             ; strrev
0008++ 1120             ; reverse a string
0009++ 1120             ; D = string address
0010++ 1120             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 1120             ; 01234
0012++ 1120             strrev:
0013++ 1120 4B          	pusha
0014++ 1121 07 67 11    	call strlen	; length in C
0015++ 1124 12          	mov a, c
0016++ 1125 AF 01 00    	cmp a, 1
0017++ 1128 D0 42 11    	jleu strrev_end	; check string length. string len must be > 1
0018++ 112B 7D          	dec a
0019++ 112C FD 4E       	mov si, d	; beginning of string
0020++ 112E FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 1130 59          	add d, a	; end of string
0022++ 1131 12          	mov a, c
0023++ 1132 FD 9B       	shr a		; divide by 2
0024++ 1134 39          	mov c, a	; C now counts the steps
0025++ 1135             strrev_L0:
0026++ 1135 32          	mov bl, [d]	; save load right-side char into BL
0027++ 1136 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 1137 3E          	mov [d], al	; store left char into right side
0029++ 1138 1B          	mov al, bl
0030++ 1139 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 113A 7E          	dec c
0032++ 113B 7F          	dec d
0033++ 113C C2 00 00    	cmp c, 0
0034++ 113F C7 35 11    	jne strrev_L0
0035++ 1142             strrev_end:
0036++ 1142 4C          	popa
0037++ 1143 09          	ret
0038++ 1144             	
0039++ 1144             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 1144             ; strchr
0041++ 1144             ; search string in D for char in AL
0042++ 1144             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 1144             strchr:
0044++ 1144             strchr_L0:
0045++ 1144 32          	mov bl, [d]
0046++ 1145 C1 00       	cmp bl, 0
0047++ 1147 C6 52 11    	je strchr_end
0048++ 114A BA          	cmp al, bl
0049++ 114B C6 52 11    	je strchr_end
0050++ 114E 79          	inc d
0051++ 114F 0A 44 11    	jmp strchr_L0
0052++ 1152             strchr_end:
0053++ 1152 1B          	mov al, bl
0054++ 1153 09          	ret
0055++ 1154             
0056++ 1154             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 1154             ; strstr
0058++ 1154             ; find sub-string
0059++ 1154             ; str1 in SI
0060++ 1154             ; str2 in DI
0061++ 1154             ; SI points to end of source string
0062++ 1154             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 1154             strstr:
0064++ 1154 DB          	push al
0065++ 1155 DA          	push d
0066++ 1156 E3          	push di
0067++ 1157             strstr_loop:
0068++ 1157 F3          	cmpsb					; compare a byte of the strings
0069++ 1158 C7 63 11    	jne strstr_ret
0070++ 115B FC 00 00    	lea d, [di + 0]
0071++ 115E BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 1160 C7 57 11    	jne strstr_loop				; equal chars but not at end
0073++ 1163             strstr_ret:
0074++ 1163 F0          	pop di
0075++ 1164 E7          	pop d
0076++ 1165 E8          	pop al
0077++ 1166 09          	ret
0078++ 1167             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 1167             ; length of null terminated string
0080++ 1167             ; result in C
0081++ 1167             ; pointer in D
0082++ 1167             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 1167             strlen:
0084++ 1167 DA          	push d
0085++ 1168 38 00 00    	mov c, 0
0086++ 116B             strlen_L1:
0087++ 116B BD 00       	cmp byte [d], 0
0088++ 116D C6 75 11    	je strlen_ret
0089++ 1170 79          	inc d
0090++ 1171 78          	inc c
0091++ 1172 0A 6B 11    	jmp strlen_L1
0092++ 1175             strlen_ret:
0093++ 1175 E7          	pop d
0094++ 1176 09          	ret
0095++ 1177             
0096++ 1177             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 1177             ; STRCMP
0098++ 1177             ; compare two strings
0099++ 1177             ; str1 in SI
0100++ 1177             ; str2 in DI
0101++ 1177             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 1177             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 1177             strcmp:
0104++ 1177 DB          	push al
0105++ 1178 DA          	push d
0106++ 1179 E3          	push di
0107++ 117A E2          	push si
0108++ 117B             strcmp_loop:
0109++ 117B F3          	cmpsb					; compare a byte of the strings
0110++ 117C C7 87 11    	jne strcmp_ret
0111++ 117F FB FF FF    	lea d, [si +- 1]
0112++ 1182 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 1184 C7 7B 11    	jne strcmp_loop				; equal chars but not at end
0114++ 1187             strcmp_ret:
0115++ 1187 EF          	pop si
0116++ 1188 F0          	pop di
0117++ 1189 E7          	pop d
0118++ 118A E8          	pop al
0119++ 118B 09          	ret
0120++ 118C             
0121++ 118C             
0122++ 118C             ; STRCPY
0123++ 118C             ; copy null terminated string from SI to DI
0124++ 118C             ; source in SI
0125++ 118C             ; destination in DI
0126++ 118C             strcpy:
0127++ 118C E2          	push si
0128++ 118D E3          	push di
0129++ 118E DB          	push al
0130++ 118F             strcpy_L1:
0131++ 118F F6          	lodsb
0132++ 1190 F7          	stosb
0133++ 1191 B9 00       	cmp al, 0
0134++ 1193 C7 8F 11    	jne strcpy_L1
0135++ 1196             strcpy_end:
0136++ 1196 E8          	pop al
0137++ 1197 F0          	pop di
0138++ 1198 EF          	pop si
0139++ 1199 09          	ret
0140++ 119A             
0141++ 119A             ; STRCAT
0142++ 119A             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 119A             ; source in SI
0144++ 119A             ; destination in DI
0145++ 119A             strcat:
0146++ 119A E2          	push si
0147++ 119B E3          	push di
0148++ 119C D7          	push a
0149++ 119D DA          	push d
0150++ 119E 50          	mov a, di
0151++ 119F 3C          	mov d, a
0152++ 11A0             strcat_goto_end_L1:
0153++ 11A0 BD 00       	cmp byte[d], 0
0154++ 11A2 C6 A9 11    	je strcat_start
0155++ 11A5 79          	inc d
0156++ 11A6 0A A0 11    	jmp strcat_goto_end_L1
0157++ 11A9             strcat_start:
0158++ 11A9 FD 50       	mov di, d
0159++ 11AB             strcat_L1:
0160++ 11AB F6          	lodsb
0161++ 11AC F7          	stosb
0162++ 11AD B9 00       	cmp al, 0
0163++ 11AF C7 AB 11    	jne strcat_L1
0164++ 11B2             strcat_end:
0165++ 11B2 E7          	pop d
0166++ 11B3 E4          	pop a
0167++ 11B4 F0          	pop di
0168++ 11B5 EF          	pop si
0169++ 11B6 09          	ret
0005+  11B7             
0006+  11B7 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  11BB 34 35 36 37 
0006+  11BF 38 39 41 42 
0006+  11C3 43 44 45 46 
0007+  11C7 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  11CB 1B 5B 48 00 
0008+  11CF             
0009+  11CF 01 00       table_power:.dw 1
0010+  11D1 0A 00       			.dw 10
0011+  11D3 64 00       			.dw 100
0012+  11D5 E8 03       			.dw 1000
0013+  11D7 10 27       			.dw 10000
0014+  11D9             
0015+  11D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  11D9             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  11D9             ; ASCII in BL
0018+  11D9             ; result in AL
0019+  11D9             ; ascii for F = 0100 0110
0020+  11D9             ; ascii for 9 = 0011 1001
0021+  11D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  11D9             hex_ascii_encode:
0023+  11D9 1B          	mov al, bl
0024+  11DA 93 40       	test al, $40				; test if letter or number
0025+  11DC C7 E2 11    	jnz hex_letter
0026+  11DF 87 0F       	and al, $0F				; get number
0027+  11E1 09          	ret
0028+  11E2             hex_letter:
0029+  11E2 87 0F       	and al, $0F				; get letter
0030+  11E4 6A 09       	add al, 9
0031+  11E6 09          	ret
0032+  11E7             
0033+  11E7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  11E7             ; ATOI
0035+  11E7             ; 2 letter hex string in B
0036+  11E7             ; 8bit integer returned in AL
0037+  11E7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  11E7             atoi:
0039+  11E7 D8          	push b
0040+  11E8 07 D9 11    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  11EB 30          	mov bl, bh
0042+  11EC DB          	push al					; save a
0043+  11ED 07 D9 11    	call hex_ascii_encode
0044+  11F0 EA          	pop bl	
0045+  11F1 FD 9E 04    	shl al, 4
0046+  11F4 8C          	or al, bl
0047+  11F5 E5          	pop b
0048+  11F6 09          	ret	
0049+  11F7             
0050+  11F7             
0051+  11F7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  11F7             ; printf
0053+  11F7             ; no need for explanations!
0054+  11F7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  11F7             printf:
0056+  11F7 09          	ret
0057+  11F8             
0058+  11F8             
0059+  11F8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  11F8             ; scanf
0061+  11F8             ; no need for explanations!
0062+  11F8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  11F8             scanf:
0064+  11F8 09          	ret
0065+  11F9             
0066+  11F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  11F9             ; ITOA
0068+  11F9             ; 8bit value in BL
0069+  11F9             ; 2 byte ASCII result in A
0070+  11F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  11F9             itoa:
0072+  11F9 DA          	push d
0073+  11FA D8          	push b
0074+  11FB A7 00       	mov bh, 0
0075+  11FD FD A4 04    	shr bl, 4	
0076+  1200 74          	mov d, b
0077+  1201 1F B7 11    	mov al, [d + s_hex_digits]
0078+  1204 23          	mov ah, al
0079+  1205             	
0080+  1205 E5          	pop b
0081+  1206 D8          	push b
0082+  1207 A7 00       	mov bh, 0
0083+  1209 FD 87 0F    	and bl, $0F
0084+  120C 74          	mov d, b
0085+  120D 1F B7 11    	mov al, [d + s_hex_digits]
0086+  1210 E5          	pop b
0087+  1211 E7          	pop d
0088+  1212 09          	ret
0089+  1213             
0090+  1213             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  1213             ; HEX STRING TO BINARY
0092+  1213             ; di = destination address
0093+  1213             ; si = source
0094+  1213             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  1213             hex_to_int:
0096+  1213             hex_to_int_L1:
0097+  1213 F6          	lodsb					; load from [SI] to AL
0098+  1214 B9 00       	cmp al, 0				; check if ASCII 0
0099+  1216 C6 23 12    	jz hex_to_int_ret
0100+  1219 36          	mov bh, al
0101+  121A F6          	lodsb
0102+  121B 2F          	mov bl, al
0103+  121C 07 E7 11    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  121F F7          	stosb					; store AL to [DI]
0105+  1220 0A 13 12    	jmp hex_to_int_L1
0106+  1223             hex_to_int_ret:
0107+  1223 09          	ret		
0108+  1224             
0109+  1224             
0110+  1224             
0111+  1224             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  1224             ; GETCHAR
0113+  1224             ; char in ah
0114+  1224             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  1224             getchar:
0116+  1224 DB          	push al
0117+  1225             getchar_retry:
0118+  1225 FD 0C       	sti
0119+  1227 19 01       	mov al, 1
0120+  1229 05 03       	syscall sys_io			; receive in AH
0121+  122B B9 00       	cmp al, 0			; check if any char was receive
0122+  122D C6 25 12    	je getchar_retry
0123+  1230 E8          	pop al
0124+  1231 09          	ret
0125+  1232             
0126+  1232             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  1232             ; PUTCHAR
0128+  1232             ; char in ah
0129+  1232             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  1232             putchar:
0131+  1232 D7          	push a
0132+  1233 19 00       	mov al, 0
0133+  1235 05 03       	syscall sys_io			; char in AH
0134+  1237 E4          	pop a
0135+  1238 09          	ret
0136+  1239             
0137+  1239             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  1239             ;; INPUT A STRING
0139+  1239             ;; terminates with null
0140+  1239             ;; pointer in D
0141+  1239             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  1239             gets:
0143+  1239 D7          	push a
0144+  123A DA          	push d
0145+  123B             gets_loop:
0146+  123B FD 0C       	sti
0147+  123D 19 01       	mov al, 1
0148+  123F 05 03       	syscall sys_io			; receive in AH
0149+  1241 B9 00       	cmp al, 0				; check error code (AL)
0150+  1243 C6 3B 12    	je gets_loop			; if no char received, retry
0151+  1246             
0152+  1246 76 1B       	cmp ah, 27
0153+  1248 C6 69 12    	je gets_telnet_escape
0154+  124B 76 0A       	cmp ah, $0A				; LF
0155+  124D C6 C2 12    	je gets_end
0156+  1250 76 0D       	cmp ah, $0D				; CR
0157+  1252 C6 C2 12    	je gets_end
0158+  1255 76 5C       	cmp ah, $5C				; '\\'
0159+  1257 C6 99 12    	je gets_escape
0160+  125A             	
0161+  125A 76 08       	cmp ah, $08			; check for backspace
0162+  125C C6 65 12    	je gets_backspace
0163+  125F             
0164+  125F 1A          	mov al, ah
0165+  1260 3E          	mov [d], al
0166+  1261 79          	inc d
0167+  1262 0A 3B 12    	jmp gets_loop
0168+  1265             gets_backspace:
0169+  1265 7F          	dec d
0170+  1266 0A 3B 12    	jmp gets_loop
0171+  1269             gets_telnet_escape:
0172+  1269 FD 0C       	sti
0173+  126B 19 01       	mov al, 1
0174+  126D 05 03       	syscall sys_io				; receive in AH without echo
0175+  126F B9 00       	cmp al, 0					; check error code (AL)
0176+  1271 C6 69 12    	je gets_telnet_escape		; if no char received, retry
0177+  1274 76 5B       	cmp ah, '['
0178+  1276 C7 3B 12    	jne gets_loop
0179+  1279             gets_telnet_escape_phase2:
0180+  1279 FD 0C       	sti
0181+  127B 19 01       	mov al, 1
0182+  127D 05 03       	syscall sys_io					; receive in AH without echo
0183+  127F B9 00       	cmp al, 0						; check error code (AL)
0184+  1281 C6 79 12    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  1284 76 44       	cmp ah, 'D'
0186+  1286 C6 91 12    	je gets_left_arrow
0187+  1289 76 43       	cmp ah, 'C'
0188+  128B C6 95 12    	je gets_right_arrow
0189+  128E 0A 3B 12    	jmp gets_loop
0190+  1291             gets_left_arrow:
0191+  1291 7F          	dec d
0192+  1292 0A 3B 12    	jmp gets_loop
0193+  1295             gets_right_arrow:
0194+  1295 79          	inc d
0195+  1296 0A 3B 12    	jmp gets_loop
0196+  1299             gets_escape:
0197+  1299 FD 0C       	sti
0198+  129B 19 01       	mov al, 1
0199+  129D 05 03       	syscall sys_io			; receive in AH
0200+  129F B9 00       	cmp al, 0				; check error code (AL)
0201+  12A1 C6 99 12    	je gets_escape			; if no char received, retry
0202+  12A4 76 6E       	cmp ah, 'n'
0203+  12A6 C6 B4 12    	je gets_LF
0204+  12A9 76 72       	cmp ah, 'r'
0205+  12AB C6 BB 12    	je gets_CR
0206+  12AE 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  12AF 3E          	mov [d], al
0208+  12B0 79          	inc d
0209+  12B1 0A 3B 12    	jmp gets_loop
0210+  12B4             gets_LF:
0211+  12B4 19 0A       	mov al, $0A
0212+  12B6 3E          	mov [d], al
0213+  12B7 79          	inc d
0214+  12B8 0A 3B 12    	jmp gets_loop
0215+  12BB             gets_CR:
0216+  12BB 19 0D       	mov al, $0D
0217+  12BD 3E          	mov [d], al
0218+  12BE 79          	inc d
0219+  12BF 0A 3B 12    	jmp gets_loop
0220+  12C2             gets_end:
0221+  12C2 19 00       	mov al, 0
0222+  12C4 3E          	mov [d], al				; terminate string
0223+  12C5 E7          	pop d
0224+  12C6 E4          	pop a
0225+  12C7 09          	ret
0226+  12C8             
0227+  12C8             
0228+  12C8             
0229+  12C8             
0230+  12C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  12C8             ;; INPUT TEXT
0232+  12C8             ;; terminated with CTRL+D
0233+  12C8             ;; pointer in D
0234+  12C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  12C8             gettxt:
0236+  12C8 D7          	push a
0237+  12C9 DA          	push d
0238+  12CA             gettxt_loop:
0239+  12CA 19 01       	mov al, 1
0240+  12CC 05 03       	syscall sys_io			; receive in AH
0241+  12CE B9 00       	cmp al, 0				; check error code (AL)
0242+  12D0 C6 CA 12    	je gettxt_loop		; if no char received, retry
0243+  12D3 76 04       	cmp ah, 4			; EOT
0244+  12D5 C6 13 13    	je gettxt_end
0245+  12D8 76 08       	cmp ah, $08			; check for backspace
0246+  12DA C6 0F 13    	je gettxt_backspace
0247+  12DD 76 5C       	cmp ah, $5C				; '\\'
0248+  12DF C6 E8 12    	je gettxt_escape
0249+  12E2 1A          	mov al, ah
0250+  12E3 3E          	mov [d], al
0251+  12E4 79          	inc d
0252+  12E5 0A CA 12    	jmp gettxt_loop
0253+  12E8             gettxt_escape:
0254+  12E8 19 01       	mov al, 1
0255+  12EA 05 03       	syscall sys_io			; receive in AH
0256+  12EC B9 00       	cmp al, 0				; check error code (AL)
0257+  12EE C6 E8 12    	je gettxt_escape		; if no char received, retry
0258+  12F1 76 6E       	cmp ah, 'n'
0259+  12F3 C6 01 13    	je gettxt_LF
0260+  12F6 76 72       	cmp ah, 'r'
0261+  12F8 C6 08 13    	je gettxt_CR
0262+  12FB 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  12FC 3E          	mov [d], al
0264+  12FD 79          	inc d
0265+  12FE 0A CA 12    	jmp gettxt_loop
0266+  1301             gettxt_LF:
0267+  1301 19 0A       	mov al, $0A
0268+  1303 3E          	mov [d], al
0269+  1304 79          	inc d
0270+  1305 0A CA 12    	jmp gettxt_loop
0271+  1308             gettxt_CR:
0272+  1308 19 0D       	mov al, $0D
0273+  130A 3E          	mov [d], al
0274+  130B 79          	inc d
0275+  130C 0A CA 12    	jmp gettxt_loop
0276+  130F             gettxt_backspace:
0277+  130F 7F          	dec d
0278+  1310 0A CA 12    	jmp gettxt_loop
0279+  1313             gettxt_end:
0280+  1313 19 00       	mov al, 0
0281+  1315 3E          	mov [d], al				; terminate string
0282+  1316 E7          	pop d
0283+  1317 E4          	pop a
0284+  1318 09          	ret
0285+  1319             
0286+  1319             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  1319             ; PRINT NEW LINE
0288+  1319             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  1319             printnl:
0290+  1319 D7          	push a
0291+  131A 10 00 0A    	mov a, $0A00
0292+  131D 05 03       	syscall sys_io
0293+  131F 10 00 0D    	mov a, $0D00
0294+  1322 05 03       	syscall sys_io
0295+  1324 E4          	pop a
0296+  1325 09          	ret
0297+  1326             
0298+  1326             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  1326             ; strtoint
0300+  1326             ; 4 digit hex string number in d
0301+  1326             ; integer returned in A
0302+  1326             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  1326             strtointx:
0304+  1326 D8          	push b
0305+  1327 32          	mov bl, [d]
0306+  1328 37          	mov bh, bl
0307+  1329 33 01 00    	mov bl, [d + 1]
0308+  132C 07 E7 11    	call atoi				; convert to int in AL
0309+  132F 23          	mov ah, al				; move to AH
0310+  1330 33 02 00    	mov bl, [d + 2]
0311+  1333 37          	mov bh, bl
0312+  1334 33 03 00    	mov bl, [d + 3]
0313+  1337 07 E7 11    	call atoi				; convert to int in AL
0314+  133A E5          	pop b
0315+  133B 09          	ret
0316+  133C             
0317+  133C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  133C             ; strtoint
0319+  133C             ; 5 digit base10 string number in d
0320+  133C             ; integer returned in A
0321+  133C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  133C             strtoint:
0323+  133C E2          	push si
0324+  133D D8          	push b
0325+  133E D9          	push c
0326+  133F DA          	push d
0327+  1340 07 67 11    	call strlen			; get string length in C
0328+  1343 7E          	dec c
0329+  1344 FD 4E       	mov si, d
0330+  1346 12          	mov a, c
0331+  1347 FD 99       	shl a
0332+  1349 3B CF 11    	mov d, table_power
0333+  134C 59          	add d, a
0334+  134D 38 00 00    	mov c, 0
0335+  1350             strtoint_L0:
0336+  1350 F6          	lodsb			; load ASCII to al
0337+  1351 B9 00       	cmp al, 0
0338+  1353 C6 66 13    	je strtoint_end
0339+  1356 6F 30       	sub al, $30		; make into integer
0340+  1358 22 00       	mov ah, 0
0341+  135A 2A          	mov b, [d]
0342+  135B AC          	mul a, b			; result in B since it fits in 16bits
0343+  135C 11          	mov a, b
0344+  135D 28          	mov b, c
0345+  135E 54          	add a, b
0346+  135F 39          	mov c, a
0347+  1360 63 02 00    	sub d, 2
0348+  1363 0A 50 13    	jmp strtoint_L0
0349+  1366             strtoint_end:
0350+  1366 12          	mov a, c
0351+  1367 E7          	pop d
0352+  1368 E6          	pop c
0353+  1369 E5          	pop b
0354+  136A EF          	pop si
0355+  136B 09          	ret
0356+  136C             
0357+  136C             
0358+  136C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  136C             ; PRINT NULL TERMINATED STRING
0360+  136C             ; pointer in D
0361+  136C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  136C             puts:
0363+  136C D7          	push a
0364+  136D DA          	push d
0365+  136E             puts_L1:
0366+  136E 1E          	mov al, [d]
0367+  136F B9 00       	cmp al, 0
0368+  1371 C6 7D 13    	jz puts_END
0369+  1374 23          	mov ah, al
0370+  1375 19 00       	mov al, 0
0371+  1377 05 03       	syscall sys_io
0372+  1379 79          	inc d
0373+  137A 0A 6E 13    	jmp puts_L1
0374+  137D             puts_END:
0375+  137D E7          	pop d
0376+  137E E4          	pop a
0377+  137F 09          	ret
0378+  1380             
0379+  1380             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  1380             ; PRINT N SIZE STRING
0381+  1380             ; pointer in D
0382+  1380             ; size in C
0383+  1380             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  1380             putsn:
0385+  1380 DB          	push al
0386+  1381 DA          	push d
0387+  1382 D9          	push c
0388+  1383             putsn_L0:
0389+  1383 1E          	mov al, [d]
0390+  1384 23          	mov ah, al
0391+  1385 19 00       	mov al, 0
0392+  1387 05 03       	syscall sys_io
0393+  1389 79          	inc d
0394+  138A 7E          	dec c	
0395+  138B C2 00 00    	cmp c, 0
0396+  138E C7 83 13    	jne putsn_L0
0397+  1391             putsn_end:
0398+  1391 E6          	pop c
0399+  1392 E7          	pop d
0400+  1393 E8          	pop al
0401+  1394 09          	ret
0402+  1395             
0403+  1395             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  1395             ; print 16bit decimal number
0405+  1395             ; input number in A
0406+  1395             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  1395             print_u16d:
0408+  1395 D7          	push a
0409+  1396 D8          	push b
0410+  1397 26 10 27    	mov b, 10000
0411+  139A AE          	div a, b			; get 10000 coeff.
0412+  139B 07 C1 13    	call print_number
0413+  139E 11          	mov a, b
0414+  139F 26 E8 03    	mov b, 1000
0415+  13A2 AE          	div a, b			; get 10000 coeff.
0416+  13A3 07 C1 13    	call print_number
0417+  13A6 11          	mov a, b
0418+  13A7 26 64 00    	mov b, 100
0419+  13AA AE          	div a, b
0420+  13AB 07 C1 13    	call print_number
0421+  13AE 11          	mov a, b
0422+  13AF 26 0A 00    	mov b, 10
0423+  13B2 AE          	div a, b
0424+  13B3 07 C1 13    	call print_number
0425+  13B6 11          	mov a, b
0426+  13B7 6A 30       	add al, $30
0427+  13B9 23          	mov ah, al
0428+  13BA 19 00       	mov al, 0
0429+  13BC 05 03       	syscall sys_io	; print coeff
0430+  13BE E5          	pop b
0431+  13BF E4          	pop a
0432+  13C0 09          	ret
0433+  13C1             
0434+  13C1             
0435+  13C1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  13C1             ; if A == 0, print space
0437+  13C1             ; else print A
0438+  13C1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0439+  13C1             print_number:
0440+  13C1 6A 30       	add al, $30
0441+  13C3 23          	mov ah, al
0442+  13C4 07 32 12    	call putchar
0443+  13C7 09          	ret
0444+  13C8             
0445+  13C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0446+  13C8             ; PRINT 16BIT HEX INTEGER
0447+  13C8             ; integer value in reg B
0448+  13C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  13C8             print_u16x:
0450+  13C8 D7          	push a
0451+  13C9 D8          	push b
0452+  13CA DD          	push bl
0453+  13CB 30          	mov bl, bh
0454+  13CC 07 F9 11    	call itoa				; convert bh to char in A
0455+  13CF 2F          	mov bl, al				; save al
0456+  13D0 19 00       	mov al, 0
0457+  13D2 05 03       	syscall sys_io				; display AH
0458+  13D4 24          	mov ah, bl				; retrieve al
0459+  13D5 19 00       	mov al, 0
0460+  13D7 05 03       	syscall sys_io				; display AL
0461+  13D9             
0462+  13D9 EA          	pop bl
0463+  13DA 07 F9 11    	call itoa				; convert bh to char in A
0464+  13DD 2F          	mov bl, al				; save al
0465+  13DE 19 00       	mov al, 0
0466+  13E0 05 03       	syscall sys_io				; display AH
0467+  13E2 24          	mov ah, bl				; retrieve al
0468+  13E3 19 00       	mov al, 0
0469+  13E5 05 03       	syscall sys_io				; display AL
0470+  13E7             
0471+  13E7 E5          	pop b
0472+  13E8 E4          	pop a
0473+  13E9 09          	ret
0474+  13EA             
0475+  13EA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  13EA             ; INPUT 16BIT HEX INTEGER
0477+  13EA             ; read 16bit integer into A
0478+  13EA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  13EA             scan_u16x:
0480+  13EA F8 10 00    	enter 16
0481+  13ED D8          	push b
0482+  13EE DA          	push d
0483+  13EF             
0484+  13EF FA F1 FF    	lea d, [bp + -15]
0485+  13F2 07 39 12    	call gets				; get number
0486+  13F5             
0487+  13F5 32          	mov bl, [d]
0488+  13F6 37          	mov bh, bl
0489+  13F7 33 01 00    	mov bl, [d + 1]
0490+  13FA 07 E7 11    	call atoi				; convert to int in AL
0491+  13FD 23          	mov ah, al				; move to AH
0492+  13FE             
0493+  13FE 33 02 00    	mov bl, [d + 2]
0494+  1401 37          	mov bh, bl
0495+  1402 33 03 00    	mov bl, [d + 3]
0496+  1405 07 E7 11    	call atoi				; convert to int in AL
0497+  1408             
0498+  1408 E7          	pop d
0499+  1409 E5          	pop b
0500+  140A F9          	leave
0501+  140B 09          	ret
0502+  140C             
0503+  140C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0504+  140C             ; PRINT 8bit HEX INTEGER
0505+  140C             ; integer value in reg bl
0506+  140C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  140C             print_u8x:
0508+  140C D7          	push a
0509+  140D DD          	push bl
0510+  140E             
0511+  140E 07 F9 11    	call itoa				; convert bl to char in A
0512+  1411 2F          	mov bl, al				; save al
0513+  1412 19 00       	mov al, 0
0514+  1414 05 03       	syscall sys_io				; display AH
0515+  1416 24          	mov ah, bl				; retrieve al
0516+  1417 19 00       	mov al, 0
0517+  1419 05 03       	syscall sys_io				; display AL
0518+  141B             
0519+  141B EA          	pop bl
0520+  141C E4          	pop a
0521+  141D 09          	ret
0522+  141E             
0523+  141E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0524+  141E             ; print 8bit decimal unsigned number
0525+  141E             ; input number in AL
0526+  141E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  141E             print_u8d:
0528+  141E D7          	push a
0529+  141F D8          	push b
0530+  1420             
0531+  1420 22 00       	mov ah, 0
0532+  1422 26 64 00    	mov b, 100
0533+  1425 AE          	div a, b
0534+  1426 D8          	push b			; save remainder
0535+  1427 B9 00       	cmp al, 0
0536+  1429 C6 33 14    	je skip100
0537+  142C 6A 30       	add al, $30
0538+  142E 23          	mov ah, al
0539+  142F 19 00       	mov al, 0
0540+  1431 05 03       	syscall sys_io	; print coeff
0541+  1433             skip100:
0542+  1433 E4          	pop a
0543+  1434 22 00       	mov ah, 0
0544+  1436 26 0A 00    	mov b, 10
0545+  1439 AE          	div a, b
0546+  143A D8          	push b			; save remainder
0547+  143B B9 00       	cmp al, 0
0548+  143D C6 47 14    	je skip10
0549+  1440 6A 30       	add al, $30
0550+  1442 23          	mov ah, al
0551+  1443 19 00       	mov al, 0
0552+  1445 05 03       	syscall sys_io	; print coeff
0553+  1447             skip10:
0554+  1447 E4          	pop a
0555+  1448 1B          	mov al, bl
0556+  1449 6A 30       	add al, $30
0557+  144B 23          	mov ah, al
0558+  144C 19 00       	mov al, 0
0559+  144E 05 03       	syscall sys_io	; print coeff
0560+  1450 E5          	pop b
0561+  1451 E4          	pop a
0562+  1452 09          	ret
0563+  1453             
0564+  1453             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0565+  1453             ; INPUT 8BIT HEX INTEGER
0566+  1453             ; read 8bit integer into AL
0567+  1453             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  1453             scan_u8x:
0569+  1453 F8 04 00    	enter 4
0570+  1456 D8          	push b
0571+  1457 DA          	push d
0572+  1458             
0573+  1458 FA FD FF    	lea d, [bp + -3]
0574+  145B 07 39 12    	call gets				; get number
0575+  145E             
0576+  145E 32          	mov bl, [d]
0577+  145F 37          	mov bh, bl
0578+  1460 33 01 00    	mov bl, [d + 1]
0579+  1463 07 E7 11    	call atoi				; convert to int in AL
0580+  1466             
0581+  1466 E7          	pop d
0582+  1467 E5          	pop b
0583+  1468 F9          	leave
0584+  1469 09          	ret
0585+  146A             
0586+  146A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  146A             ; input decimal number
0588+  146A             ; result in A
0589+  146A             ; 655'\0'
0590+  146A             ; low--------high
0591+  146A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0592+  146A             scan_u16d:
0593+  146A F8 08 00    	enter 8
0594+  146D E2          	push si
0595+  146E D8          	push b
0596+  146F D9          	push c
0597+  1470 DA          	push d
0598+  1471 FA F9 FF    	lea d, [bp +- 7]
0599+  1474 07 39 12    	call gets
0600+  1477 07 67 11    	call strlen			; get string length in C
0601+  147A 7E          	dec c
0602+  147B FD 4E       	mov si, d
0603+  147D 12          	mov a, c
0604+  147E FD 99       	shl a
0605+  1480 3B CF 11    	mov d, table_power
0606+  1483 59          	add d, a
0607+  1484 38 00 00    	mov c, 0
0608+  1487             mul_loop:
0609+  1487 F6          	lodsb			; load ASCII to al
0610+  1488 B9 00       	cmp al, 0
0611+  148A C6 9D 14    	je mul_exit
0612+  148D 6F 30       	sub al, $30		; make into integer
0613+  148F 22 00       	mov ah, 0
0614+  1491 2A          	mov b, [d]
0615+  1492 AC          	mul a, b			; result in B since it fits in 16bits
0616+  1493 11          	mov a, b
0617+  1494 28          	mov b, c
0618+  1495 54          	add a, b
0619+  1496 39          	mov c, a
0620+  1497 63 02 00    	sub d, 2
0621+  149A 0A 87 14    	jmp mul_loop
0622+  149D             mul_exit:
0623+  149D 12          	mov a, c
0624+  149E E7          	pop d
0625+  149F E6          	pop c
0626+  14A0 E5          	pop b
0627+  14A1 EF          	pop si
0628+  14A2 F9          	leave
0629+  14A3 09          	ret
1760   14A4             ; --- END INCLUDE BLOCK
1761   14A4             
1762   14A4             
1763   14A4             .end
tasm: Number of errors = 0
