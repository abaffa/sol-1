0001   0000             ; --- FILENAME: ivosol1d.c
0002   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0400             .org PROC_TEXT_ORG
0004   0400             
0005   0400             ; --- BEGIN TEXT BLOCK
0006   0400             main:
0007   0400 D2            push bp
0008   0401 9B            mov bp, sp
0009   0402             _while1_cond:
0010   0402 29 5B 12      mov b, [exitflag]
0011   0405 D7            push a
0012   0406 11            mov a, b
0013   0407 26 00 00      mov b, 0
0014   040A B0            cmp a, b
0015   040B 0E            lodflgs
0016   040C 87 01         and al, %00000001 ; ==
0017   040E B9 00         cmp al, 0
0018   0410 0E            lodflgs
0019   0411 96            not al
0020   0412 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0021   0414 22 00         mov ah, 0
0022   0416 27            mov b, a
0023   0417 E4            pop a
0024   0418 C0 00 00      cmp b, 0
0025   041B C6 32 10      je _while1_exit
0026   041E             _while1_block:
0027   041E 26 10 0E      mov b, 3600
0028   0421 FD 42 59 12   mov [runlimit], b
0029   0425             _while2_cond:
0030   0425 26 01 00      mov b, 1
0031   0428 C0 00 00      cmp b, 0
0032   042B C6 B4 07      je _while2_exit
0033   042E             _while2_block:
0034   042E 26 00 00      mov b, 0
0035   0431 FD 42 4B 12   mov [pc], b
0036   0435 26 18 30      mov b, 12312
0037   0438 FD AB         swp b
0038   043A D8            push b
0039   043B 07 42 10      call displaynumber
0040   043E 51 02 00      add sp, 2
0041   0441 07 32 10      call readint
0042   0444 FD 42 41 12   mov [cmdadr], b
0043   0448             _if3_cond:
0044   0448 29 41 12      mov b, [cmdadr]
0045   044B D7            push a
0046   044C 11            mov a, b
0047   044D 26 1E 00      mov b, 30
0048   0450 B0            cmp a, b
0049   0451 0E            lodflgs
0050   0452 87 03         and al, %00000011 ; <=
0051   0454 B9 00         cmp al, 0
0052   0456 0E            lodflgs
0053   0457 96            not al
0054   0458 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0055   045A 22 00         mov ah, 0
0056   045C 27            mov b, a
0057   045D E4            pop a
0058   045E C0 00 00      cmp b, 0
0059   0461 C6 69 05      je _if3_else
0060   0464             _if3_true:
0061   0464 07 32 10      call readint
0062   0467 FD 42 43 12   mov [opr], b
0063   046B 07 32 10      call readint
0064   046E FD 42 45 12   mov [datadr1], b
0065   0472 07 32 10      call readint
0066   0475 FD 42 47 12   mov [datadr2], b
0067   0479 07 32 10      call readint
0068   047C FD 42 49 12   mov [datadr3], b
0069   0480 29 3F 12      mov b, [instruction]
0070   0483 74            mov d, b
0071   0484 DA            push d
0072   0485 29 41 12      mov b, [cmdadr]
0073   0488 D7            push a
0074   0489 11            mov a, b
0075   048A 26 04 00      mov b, 4
0076   048D AC            mul a, b
0077   048E E4            pop a
0078   048F E7            pop d
0079   0490 10 02 00      mov a, 2
0080   0493 AC            mul a, b
0081   0494 5A            add d, b
0082   0495 DA            push d
0083   0496 29 43 12      mov b, [opr]
0084   0499 E7            pop d
0085   049A 11            mov a, b
0086   049B 43            mov [d], a
0087   049C 29 3F 12      mov b, [instruction]
0088   049F 74            mov d, b
0089   04A0 DA            push d
0090   04A1 29 41 12      mov b, [cmdadr]
0091   04A4 D7            push a
0092   04A5 11            mov a, b
0093   04A6 26 04 00      mov b, 4
0094   04A9 AC            mul a, b
0095   04AA E4            pop a
0096   04AB D7            push a
0097   04AC 11            mov a, b
0098   04AD 26 01 00      mov b, 1
0099   04B0 54            add a, b
0100   04B1 27            mov b, a
0101   04B2 E4            pop a
0102   04B3 E7            pop d
0103   04B4 10 02 00      mov a, 2
0104   04B7 AC            mul a, b
0105   04B8 5A            add d, b
0106   04B9 DA            push d
0107   04BA 29 45 12      mov b, [datadr1]
0108   04BD E7            pop d
0109   04BE 11            mov a, b
0110   04BF 43            mov [d], a
0111   04C0 29 3F 12      mov b, [instruction]
0112   04C3 74            mov d, b
0113   04C4 DA            push d
0114   04C5 29 41 12      mov b, [cmdadr]
0115   04C8 D7            push a
0116   04C9 11            mov a, b
0117   04CA 26 04 00      mov b, 4
0118   04CD AC            mul a, b
0119   04CE E4            pop a
0120   04CF D7            push a
0121   04D0 11            mov a, b
0122   04D1 26 02 00      mov b, 2
0123   04D4 54            add a, b
0124   04D5 27            mov b, a
0125   04D6 E4            pop a
0126   04D7 E7            pop d
0127   04D8 10 02 00      mov a, 2
0128   04DB AC            mul a, b
0129   04DC 5A            add d, b
0130   04DD DA            push d
0131   04DE 29 47 12      mov b, [datadr2]
0132   04E1 E7            pop d
0133   04E2 11            mov a, b
0134   04E3 43            mov [d], a
0135   04E4 29 3F 12      mov b, [instruction]
0136   04E7 74            mov d, b
0137   04E8 DA            push d
0138   04E9 29 41 12      mov b, [cmdadr]
0139   04EC D7            push a
0140   04ED 11            mov a, b
0141   04EE 26 04 00      mov b, 4
0142   04F1 AC            mul a, b
0143   04F2 E4            pop a
0144   04F3 D7            push a
0145   04F4 11            mov a, b
0146   04F5 26 03 00      mov b, 3
0147   04F8 54            add a, b
0148   04F9 27            mov b, a
0149   04FA E4            pop a
0150   04FB E7            pop d
0151   04FC 10 02 00      mov a, 2
0152   04FF AC            mul a, b
0153   0500 5A            add d, b
0154   0501 DA            push d
0155   0502 29 49 12      mov b, [datadr3]
0156   0505 E7            pop d
0157   0506 11            mov a, b
0158   0507 43            mov [d], a
0159   0508 29 41 12      mov b, [cmdadr]
0160   050B FD AB         swp b
0161   050D D8            push b
0162   050E 07 42 10      call displaynumber
0163   0511 51 02 00      add sp, 2
0164   0514 29 43 12      mov b, [opr]
0165   0517 FD AB         swp b
0166   0519 D8            push b
0167   051A 07 42 10      call displaynumber
0168   051D 51 02 00      add sp, 2
0169   0520 29 45 12      mov b, [datadr1]
0170   0523 FD AB         swp b
0171   0525 D8            push b
0172   0526 07 42 10      call displaynumber
0173   0529 51 02 00      add sp, 2
0174   052C 29 47 12      mov b, [datadr2]
0175   052F FD AB         swp b
0176   0531 D8            push b
0177   0532 07 42 10      call displaynumber
0178   0535 51 02 00      add sp, 2
0179   0538 29 49 12      mov b, [datadr3]
0180   053B FD AB         swp b
0181   053D D8            push b
0182   053E 07 42 10      call displaynumber
0183   0541 51 02 00      add sp, 2
0184   0544             _if4_cond:
0185   0544 29 41 12      mov b, [cmdadr]
0186   0547 D7            push a
0187   0548 11            mov a, b
0188   0549 26 00 00      mov b, 0
0189   054C B0            cmp a, b
0190   054D 0E            lodflgs
0191   054E 87 01         and al, %00000001 ; ==
0192   0550 B9 00         cmp al, 0
0193   0552 0E            lodflgs
0194   0553 96            not al
0195   0554 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0196   0556 22 00         mov ah, 0
0197   0558 27            mov b, a
0198   0559 E4            pop a
0199   055A C0 00 00      cmp b, 0
0200   055D C6 66 05      je _if4_exit
0201   0560             _if4_true:
0202   0560 0A B4 07      jmp _while2_exit ; while break
0203   0563 0A 66 05      jmp _if4_exit
0204   0566             _if4_exit:
0205   0566 0A B1 07      jmp _if3_exit
0206   0569             _if3_else:
0207   0569             _if5_cond:
0208   0569 29 41 12      mov b, [cmdadr]
0209   056C D7            push a
0210   056D 11            mov a, b
0211   056E 26 57 04      mov b, 1111
0212   0571 B0            cmp a, b
0213   0572 0E            lodflgs
0214   0573 87 01         and al, %00000001 ; ==
0215   0575 B9 00         cmp al, 0
0216   0577 0E            lodflgs
0217   0578 96            not al
0218   0579 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0219   057B 22 00         mov ah, 0
0220   057D 27            mov b, a
0221   057E E4            pop a
0222   057F C0 00 00      cmp b, 0
0223   0582 C6 2B 06      je _if5_else
0224   0585             _if5_true:
0225   0585 07 32 10      call readint
0226   0588 FD 42 4F 12   mov [i], b
0227   058C 29 3F 12      mov b, [instruction]
0228   058F D7            push a
0229   0590 74            mov d, b
0230   0591 DA            push d
0231   0592 29 4F 12      mov b, [i]
0232   0595 D7            push a
0233   0596 11            mov a, b
0234   0597 26 04 00      mov b, 4
0235   059A AC            mul a, b
0236   059B E4            pop a
0237   059C E7            pop d
0238   059D 10 02 00      mov a, 2
0239   05A0 AC            mul a, b
0240   05A1 5A            add d, b
0241   05A2 2A            mov b, [d]
0242   05A3 E4            pop a
0243   05A4 FD AB         swp b
0244   05A6 D8            push b
0245   05A7 07 42 10      call displaynumber
0246   05AA 51 02 00      add sp, 2
0247   05AD 29 3F 12      mov b, [instruction]
0248   05B0 D7            push a
0249   05B1 74            mov d, b
0250   05B2 DA            push d
0251   05B3 29 4F 12      mov b, [i]
0252   05B6 D7            push a
0253   05B7 11            mov a, b
0254   05B8 26 04 00      mov b, 4
0255   05BB AC            mul a, b
0256   05BC E4            pop a
0257   05BD D7            push a
0258   05BE 11            mov a, b
0259   05BF 26 01 00      mov b, 1
0260   05C2 54            add a, b
0261   05C3 27            mov b, a
0262   05C4 E4            pop a
0263   05C5 E7            pop d
0264   05C6 10 02 00      mov a, 2
0265   05C9 AC            mul a, b
0266   05CA 5A            add d, b
0267   05CB 2A            mov b, [d]
0268   05CC E4            pop a
0269   05CD FD AB         swp b
0270   05CF D8            push b
0271   05D0 07 42 10      call displaynumber
0272   05D3 51 02 00      add sp, 2
0273   05D6 29 3F 12      mov b, [instruction]
0274   05D9 D7            push a
0275   05DA 74            mov d, b
0276   05DB DA            push d
0277   05DC 29 4F 12      mov b, [i]
0278   05DF D7            push a
0279   05E0 11            mov a, b
0280   05E1 26 04 00      mov b, 4
0281   05E4 AC            mul a, b
0282   05E5 E4            pop a
0283   05E6 D7            push a
0284   05E7 11            mov a, b
0285   05E8 26 02 00      mov b, 2
0286   05EB 54            add a, b
0287   05EC 27            mov b, a
0288   05ED E4            pop a
0289   05EE E7            pop d
0290   05EF 10 02 00      mov a, 2
0291   05F2 AC            mul a, b
0292   05F3 5A            add d, b
0293   05F4 2A            mov b, [d]
0294   05F5 E4            pop a
0295   05F6 FD AB         swp b
0296   05F8 D8            push b
0297   05F9 07 42 10      call displaynumber
0298   05FC 51 02 00      add sp, 2
0299   05FF 29 3F 12      mov b, [instruction]
0300   0602 D7            push a
0301   0603 74            mov d, b
0302   0604 DA            push d
0303   0605 29 4F 12      mov b, [i]
0304   0608 D7            push a
0305   0609 11            mov a, b
0306   060A 26 04 00      mov b, 4
0307   060D AC            mul a, b
0308   060E E4            pop a
0309   060F D7            push a
0310   0610 11            mov a, b
0311   0611 26 03 00      mov b, 3
0312   0614 54            add a, b
0313   0615 27            mov b, a
0314   0616 E4            pop a
0315   0617 E7            pop d
0316   0618 10 02 00      mov a, 2
0317   061B AC            mul a, b
0318   061C 5A            add d, b
0319   061D 2A            mov b, [d]
0320   061E E4            pop a
0321   061F FD AB         swp b
0322   0621 D8            push b
0323   0622 07 42 10      call displaynumber
0324   0625 51 02 00      add sp, 2
0325   0628 0A B1 07      jmp _if5_exit
0326   062B             _if5_else:
0327   062B             _if6_cond:
0328   062B 29 41 12      mov b, [cmdadr]
0329   062E D7            push a
0330   062F 11            mov a, b
0331   0630 26 AE 08      mov b, 2222
0332   0633 B0            cmp a, b
0333   0634 0E            lodflgs
0334   0635 87 01         and al, %00000001 ; ==
0335   0637 B9 00         cmp al, 0
0336   0639 0E            lodflgs
0337   063A 96            not al
0338   063B 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0339   063D 22 00         mov ah, 0
0340   063F 27            mov b, a
0341   0640 E4            pop a
0342   0641 C0 00 00      cmp b, 0
0343   0644 C6 6B 06      je _if6_else
0344   0647             _if6_true:
0345   0647 07 32 10      call readint
0346   064A FD 42 4F 12   mov [i], b
0347   064E 29 4D 11      mov b, [datum]
0348   0651 D7            push a
0349   0652 74            mov d, b
0350   0653 DA            push d
0351   0654 29 4F 12      mov b, [i]
0352   0657 E7            pop d
0353   0658 10 02 00      mov a, 2
0354   065B AC            mul a, b
0355   065C 5A            add d, b
0356   065D 2A            mov b, [d]
0357   065E E4            pop a
0358   065F FD AB         swp b
0359   0661 D8            push b
0360   0662 07 42 10      call displaynumber
0361   0665 51 02 00      add sp, 2
0362   0668 0A B1 07      jmp _if6_exit
0363   066B             _if6_else:
0364   066B             _if7_cond:
0365   066B 29 41 12      mov b, [cmdadr]
0366   066E D7            push a
0367   066F 11            mov a, b
0368   0670 26 5C 11      mov b, 4444
0369   0673 B0            cmp a, b
0370   0674 0E            lodflgs
0371   0675 87 01         and al, %00000001 ; ==
0372   0677 B9 00         cmp al, 0
0373   0679 0E            lodflgs
0374   067A 96            not al
0375   067B 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0376   067D 22 00         mov ah, 0
0377   067F 27            mov b, a
0378   0680 E4            pop a
0379   0681 C0 00 00      cmp b, 0
0380   0684 C6 9F 06      je _if7_else
0381   0687             _if7_true:
0382   0687 29 4D 11      mov b, [datum]
0383   068A 74            mov d, b
0384   068B DA            push d
0385   068C 07 32 10      call readint
0386   068F E7            pop d
0387   0690 10 02 00      mov a, 2
0388   0693 AC            mul a, b
0389   0694 5A            add d, b
0390   0695 DA            push d
0391   0696 07 32 10      call readint
0392   0699 E7            pop d
0393   069A 11            mov a, b
0394   069B 43            mov [d], a
0395   069C 0A B1 07      jmp _if7_exit
0396   069F             _if7_else:
0397   069F             _if8_cond:
0398   069F 29 41 12      mov b, [cmdadr]
0399   06A2 D7            push a
0400   06A3 11            mov a, b
0401   06A4 26 B3 15      mov b, 5555
0402   06A7 B0            cmp a, b
0403   06A8 0E            lodflgs
0404   06A9 87 01         and al, %00000001 ; ==
0405   06AB B9 00         cmp al, 0
0406   06AD 0E            lodflgs
0407   06AE 96            not al
0408   06AF 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0409   06B1 22 00         mov ah, 0
0410   06B3 27            mov b, a
0411   06B4 E4            pop a
0412   06B5 C0 00 00      cmp b, 0
0413   06B8 C6 02 07      je _if8_else
0414   06BB             _if8_true:
0415   06BB             _for9_init:
0416   06BB 26 00 00      mov b, 0
0417   06BE FD 42 4F 12   mov [i], b
0418   06C2             _for9_cond:
0419   06C2 29 4F 12      mov b, [i]
0420   06C5 D7            push a
0421   06C6 11            mov a, b
0422   06C7 26 1E 00      mov b, 30
0423   06CA B0            cmp a, b
0424   06CB 0E            lodflgs
0425   06CC 87 02         and al, %00000010 ; <
0426   06CE B9 00         cmp al, 0
0427   06D0 0E            lodflgs
0428   06D1 96            not al
0429   06D2 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0430   06D4 22 00         mov ah, 0
0431   06D6 27            mov b, a
0432   06D7 E4            pop a
0433   06D8 C0 00 00      cmp b, 0
0434   06DB C6 FF 06      je _for9_exit
0435   06DE             _for9_block:
0436   06DE 29 3F 12      mov b, [instruction]
0437   06E1 74            mov d, b
0438   06E2 DA            push d
0439   06E3 29 4F 12      mov b, [i]
0440   06E6 E7            pop d
0441   06E7 10 02 00      mov a, 2
0442   06EA AC            mul a, b
0443   06EB 5A            add d, b
0444   06EC DA            push d
0445   06ED 26 00 00      mov b, 0
0446   06F0 E7            pop d
0447   06F1 11            mov a, b
0448   06F2 43            mov [d], a
0449   06F3             _for9_update:
0450   06F3 29 4F 12      mov b, [i]
0451   06F6 FD 77         inc b
0452   06F8 FD 42 4F 12   mov [i], b
0453   06FC 0A C2 06      jmp _for9_cond
0454   06FF             _for9_exit:
0455   06FF 0A B1 07      jmp _if8_exit
0456   0702             _if8_else:
0457   0702             _if10_cond:
0458   0702 29 41 12      mov b, [cmdadr]
0459   0705 D7            push a
0460   0706 11            mov a, b
0461   0707 26 0A 1A      mov b, 6666
0462   070A B0            cmp a, b
0463   070B 0E            lodflgs
0464   070C 87 01         and al, %00000001 ; ==
0465   070E B9 00         cmp al, 0
0466   0710 0E            lodflgs
0467   0711 96            not al
0468   0712 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0469   0714 22 00         mov ah, 0
0470   0716 27            mov b, a
0471   0717 E4            pop a
0472   0718 C0 00 00      cmp b, 0
0473   071B C6 65 07      je _if10_else
0474   071E             _if10_true:
0475   071E             _for11_init:
0476   071E 29 45 12      mov b, [datadr1]
0477   0721 FD 42 4F 12   mov [i], b
0478   0725             _for11_cond:
0479   0725 29 4F 12      mov b, [i]
0480   0728 D7            push a
0481   0729 11            mov a, b
0482   072A 26 7B 00      mov b, 123
0483   072D B0            cmp a, b
0484   072E 0E            lodflgs
0485   072F 87 02         and al, %00000010 ; <
0486   0731 B9 00         cmp al, 0
0487   0733 0E            lodflgs
0488   0734 96            not al
0489   0735 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0490   0737 22 00         mov ah, 0
0491   0739 27            mov b, a
0492   073A E4            pop a
0493   073B C0 00 00      cmp b, 0
0494   073E C6 62 07      je _for11_exit
0495   0741             _for11_block:
0496   0741 29 4D 11      mov b, [datum]
0497   0744 74            mov d, b
0498   0745 DA            push d
0499   0746 29 4F 12      mov b, [i]
0500   0749 E7            pop d
0501   074A 10 02 00      mov a, 2
0502   074D AC            mul a, b
0503   074E 5A            add d, b
0504   074F DA            push d
0505   0750 26 00 00      mov b, 0
0506   0753 E7            pop d
0507   0754 11            mov a, b
0508   0755 43            mov [d], a
0509   0756             _for11_update:
0510   0756 29 4F 12      mov b, [i]
0511   0759 FD 77         inc b
0512   075B FD 42 4F 12   mov [i], b
0513   075F 0A 25 07      jmp _for11_cond
0514   0762             _for11_exit:
0515   0762 0A B1 07      jmp _if10_exit
0516   0765             _if10_else:
0517   0765             _if12_cond:
0518   0765 29 41 12      mov b, [cmdadr]
0519   0768 D7            push a
0520   0769 11            mov a, b
0521   076A 26 0F 27      mov b, 9999
0522   076D B0            cmp a, b
0523   076E 0E            lodflgs
0524   076F 87 01         and al, %00000001 ; ==
0525   0771 B9 00         cmp al, 0
0526   0773 0E            lodflgs
0527   0774 96            not al
0528   0775 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0529   0777 22 00         mov ah, 0
0530   0779 27            mov b, a
0531   077A E4            pop a
0532   077B C0 00 00      cmp b, 0
0533   077E C6 8B 07      je _if12_else
0534   0781             _if12_true:
0535   0781 07 32 10      call readint
0536   0784 FD 42 59 12   mov [runlimit], b
0537   0788 0A B1 07      jmp _if12_exit
0538   078B             _if12_else:
0539   078B             _if13_cond:
0540   078B 29 41 12      mov b, [cmdadr]
0541   078E D7            push a
0542   078F 11            mov a, b
0543   0790 26 B8 22      mov b, 8888
0544   0793 B0            cmp a, b
0545   0794 0E            lodflgs
0546   0795 87 01         and al, %00000001 ; ==
0547   0797 B9 00         cmp al, 0
0548   0799 0E            lodflgs
0549   079A 96            not al
0550   079B 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0551   079D 22 00         mov ah, 0
0552   079F 27            mov b, a
0553   07A0 E4            pop a
0554   07A1 C0 00 00      cmp b, 0
0555   07A4 C6 B1 07      je _if13_exit
0556   07A7             _if13_true:
0557   07A7 26 01 00      mov b, 1
0558   07AA FD 42 5B 12   mov [exitflag], b
0559   07AE 0A B1 07      jmp _if13_exit
0560   07B1             _if13_exit:
0561   07B1             _if12_exit:
0562   07B1             _if10_exit:
0563   07B1             _if8_exit:
0564   07B1             _if7_exit:
0565   07B1             _if6_exit:
0566   07B1             _if5_exit:
0567   07B1             _if3_exit:
0568   07B1 0A 25 04      jmp _while2_cond
0569   07B4             _while2_exit:
0570   07B4 26 00 00      mov b, 0
0571   07B7 FD 42 5D 12   mov [exitexec], b
0572   07BB             _if14_cond:
0573   07BB 29 5B 12      mov b, [exitflag]
0574   07BE D7            push a
0575   07BF 11            mov a, b
0576   07C0 26 00 00      mov b, 0
0577   07C3 B0            cmp a, b
0578   07C4 0E            lodflgs
0579   07C5 87 01         and al, %00000001 ; ==
0580   07C7 B9 00         cmp al, 0
0581   07C9 0E            lodflgs
0582   07CA 96            not al
0583   07CB 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0584   07CD 22 00         mov ah, 0
0585   07CF 27            mov b, a
0586   07D0 E4            pop a
0587   07D1 C0 00 00      cmp b, 0
0588   07D4 C6 2F 10      je _if14_exit
0589   07D7             _if14_true:
0590   07D7             _while15_cond:
0591   07D7 29 4B 12      mov b, [pc]
0592   07DA D7            push a
0593   07DB 11            mov a, b
0594   07DC 26 1E 00      mov b, 30
0595   07DF B0            cmp a, b
0596   07E0 0E            lodflgs
0597   07E1 87 02         and al, %00000010 ; <
0598   07E3 B9 00         cmp al, 0
0599   07E5 0E            lodflgs
0600   07E6 96            not al
0601   07E7 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0602   07E9 22 00         mov ah, 0
0603   07EB 27            mov b, a
0604   07EC E4            pop a
0605   07ED C0 00 00      cmp b, 0
0606   07F0 C6 2C 10      je _while15_exit
0607   07F3             _while15_block:
0608   07F3             _if16_cond:
0609   07F3 29 59 12      mov b, [runlimit]
0610   07F6 D7            push a
0611   07F7 11            mov a, b
0612   07F8 26 01 00      mov b, 1
0613   07FB B0            cmp a, b
0614   07FC 0E            lodflgs
0615   07FD 87 01         and al, %00000001 ; ==
0616   07FF B9 00         cmp al, 0
0617   0801 0E            lodflgs
0618   0802 96            not al
0619   0803 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0620   0805 22 00         mov ah, 0
0621   0807 27            mov b, a
0622   0808 E4            pop a
0623   0809 C0 00 00      cmp b, 0
0624   080C C6 15 08      je _if16_else
0625   080F             _if16_true:
0626   080F 0A 2C 10      jmp _while15_exit ; while break
0627   0812 0A 42 08      jmp _if16_exit
0628   0815             _if16_else:
0629   0815             _if17_cond:
0630   0815 29 59 12      mov b, [runlimit]
0631   0818 D7            push a
0632   0819 11            mov a, b
0633   081A 26 01 00      mov b, 1
0634   081D B0            cmp a, b
0635   081E 0E            lodflgs
0636   081F 87 03         and al, %00000011
0637   0821 B9 00         cmp al, %00000000
0638   0823 0E            lodflgs
0639   0824 87 01         and al, %00000001 ; >
0640   0826 B9 00         cmp al, 0
0641   0828 0E            lodflgs
0642   0829 96            not al
0643   082A 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0644   082C 22 00         mov ah, 0
0645   082E 27            mov b, a
0646   082F E4            pop a
0647   0830 C0 00 00      cmp b, 0
0648   0833 C6 42 08      je _if17_exit
0649   0836             _if17_true:
0650   0836 29 59 12      mov b, [runlimit]
0651   0839 FD 7D         dec b
0652   083B FD 42 59 12   mov [runlimit], b
0653   083F 0A 42 08      jmp _if17_exit
0654   0842             _if17_exit:
0655   0842             _if16_exit:
0656   0842 29 4D 11      mov b, [datum]
0657   0845 74            mov d, b
0658   0846 DA            push d
0659   0847 26 00 00      mov b, 0
0660   084A E7            pop d
0661   084B 10 02 00      mov a, 2
0662   084E AC            mul a, b
0663   084F 5A            add d, b
0664   0850 DA            push d
0665   0851 26 00 00      mov b, 0
0666   0854 E7            pop d
0667   0855 11            mov a, b
0668   0856 43            mov [d], a
0669   0857 29 3F 12      mov b, [instruction]
0670   085A D7            push a
0671   085B 74            mov d, b
0672   085C DA            push d
0673   085D 29 4B 12      mov b, [pc]
0674   0860 D7            push a
0675   0861 11            mov a, b
0676   0862 26 04 00      mov b, 4
0677   0865 AC            mul a, b
0678   0866 E4            pop a
0679   0867 E7            pop d
0680   0868 10 02 00      mov a, 2
0681   086B AC            mul a, b
0682   086C 5A            add d, b
0683   086D 2A            mov b, [d]
0684   086E E4            pop a
0685   086F FD 42 43 12   mov [opr], b
0686   0873 29 3F 12      mov b, [instruction]
0687   0876 D7            push a
0688   0877 74            mov d, b
0689   0878 DA            push d
0690   0879 29 4B 12      mov b, [pc]
0691   087C D7            push a
0692   087D 11            mov a, b
0693   087E 26 04 00      mov b, 4
0694   0881 AC            mul a, b
0695   0882 E4            pop a
0696   0883 D7            push a
0697   0884 11            mov a, b
0698   0885 26 01 00      mov b, 1
0699   0888 54            add a, b
0700   0889 27            mov b, a
0701   088A E4            pop a
0702   088B E7            pop d
0703   088C 10 02 00      mov a, 2
0704   088F AC            mul a, b
0705   0890 5A            add d, b
0706   0891 2A            mov b, [d]
0707   0892 E4            pop a
0708   0893 FD 42 45 12   mov [datadr1], b
0709   0897 29 3F 12      mov b, [instruction]
0710   089A D7            push a
0711   089B 74            mov d, b
0712   089C DA            push d
0713   089D 29 4B 12      mov b, [pc]
0714   08A0 D7            push a
0715   08A1 11            mov a, b
0716   08A2 26 04 00      mov b, 4
0717   08A5 AC            mul a, b
0718   08A6 E4            pop a
0719   08A7 D7            push a
0720   08A8 11            mov a, b
0721   08A9 26 02 00      mov b, 2
0722   08AC 54            add a, b
0723   08AD 27            mov b, a
0724   08AE E4            pop a
0725   08AF E7            pop d
0726   08B0 10 02 00      mov a, 2
0727   08B3 AC            mul a, b
0728   08B4 5A            add d, b
0729   08B5 2A            mov b, [d]
0730   08B6 E4            pop a
0731   08B7 FD 42 47 12   mov [datadr2], b
0732   08BB 29 3F 12      mov b, [instruction]
0733   08BE D7            push a
0734   08BF 74            mov d, b
0735   08C0 DA            push d
0736   08C1 29 4B 12      mov b, [pc]
0737   08C4 D7            push a
0738   08C5 11            mov a, b
0739   08C6 26 04 00      mov b, 4
0740   08C9 AC            mul a, b
0741   08CA E4            pop a
0742   08CB D7            push a
0743   08CC 11            mov a, b
0744   08CD 26 03 00      mov b, 3
0745   08D0 54            add a, b
0746   08D1 27            mov b, a
0747   08D2 E4            pop a
0748   08D3 E7            pop d
0749   08D4 10 02 00      mov a, 2
0750   08D7 AC            mul a, b
0751   08D8 5A            add d, b
0752   08D9 2A            mov b, [d]
0753   08DA E4            pop a
0754   08DB FD 42 49 12   mov [datadr3], b
0755   08DF             _if18_cond:
0756   08DF 29 4D 12      mov b, [h]
0757   08E2 D7            push a
0758   08E3 11            mov a, b
0759   08E4 26 00 00      mov b, 0
0760   08E7 B0            cmp a, b
0761   08E8 0E            lodflgs
0762   08E9 87 03         and al, %00000011
0763   08EB B9 00         cmp al, %00000000
0764   08ED 0E            lodflgs
0765   08EE 87 01         and al, %00000001 ; >
0766   08F0 B9 00         cmp al, 0
0767   08F2 0E            lodflgs
0768   08F3 96            not al
0769   08F4 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0770   08F6 22 00         mov ah, 0
0771   08F8 27            mov b, a
0772   08F9 E4            pop a
0773   08FA D7            push a
0774   08FB 11            mov a, b
0775   08FC 29 53 12      mov b, [k]
0776   08FF D7            push a
0777   0900 11            mov a, b
0778   0901 26 00 00      mov b, 0
0779   0904 B0            cmp a, b
0780   0905 0E            lodflgs
0781   0906 87 03         and al, %00000011
0782   0908 B9 00         cmp al, %00000000
0783   090A 0E            lodflgs
0784   090B 87 01         and al, %00000001 ; >
0785   090D B9 00         cmp al, 0
0786   090F 0E            lodflgs
0787   0910 96            not al
0788   0911 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0789   0913 22 00         mov ah, 0
0790   0915 27            mov b, a
0791   0916 E4            pop a
0792   0917 8A            or a, b
0793   0918 27            mov b, a
0794   0919 E4            pop a
0795   091A D7            push a
0796   091B 11            mov a, b
0797   091C 29 55 12      mov b, [l]
0798   091F D7            push a
0799   0920 11            mov a, b
0800   0921 26 00 00      mov b, 0
0801   0924 B0            cmp a, b
0802   0925 0E            lodflgs
0803   0926 87 03         and al, %00000011
0804   0928 B9 00         cmp al, %00000000
0805   092A 0E            lodflgs
0806   092B 87 01         and al, %00000001 ; >
0807   092D B9 00         cmp al, 0
0808   092F 0E            lodflgs
0809   0930 96            not al
0810   0931 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0811   0933 22 00         mov ah, 0
0812   0935 27            mov b, a
0813   0936 E4            pop a
0814   0937 8A            or a, b
0815   0938 27            mov b, a
0816   0939 E4            pop a
0817   093A C0 00 00      cmp b, 0
0818   093D C6 6D 09      je _if18_exit
0819   0940             _if18_true:
0820   0940 29 4D 12      mov b, [h]
0821   0943 FD 42 45 12   mov [datadr1], b
0822   0947 29 53 12      mov b, [k]
0823   094A FD 42 47 12   mov [datadr2], b
0824   094E 29 55 12      mov b, [l]
0825   0951 FD 42 49 12   mov [datadr3], b
0826   0955 26 00 00      mov b, 0
0827   0958 FD 42 4D 12   mov [h], b
0828   095C 26 00 00      mov b, 0
0829   095F FD 42 53 12   mov [k], b
0830   0963 26 00 00      mov b, 0
0831   0966 FD 42 55 12   mov [l], b
0832   096A 0A 6D 09      jmp _if18_exit
0833   096D             _if18_exit:
0834   096D 29 4B 12      mov b, [pc]
0835   0970 D7            push a
0836   0971 11            mov a, b
0837   0972 26 64 00      mov b, 100
0838   0975 AC            mul a, b
0839   0976 E4            pop a
0840   0977 D7            push a
0841   0978 11            mov a, b
0842   0979 29 43 12      mov b, [opr]
0843   097C 54            add a, b
0844   097D 27            mov b, a
0845   097E E4            pop a
0846   097F FD AB         swp b
0847   0981 D8            push b
0848   0982 07 42 10      call displaynumber
0849   0985 51 02 00      add sp, 2
0850   0988             _if19_cond:
0851   0988 29 43 12      mov b, [opr]
0852   098B D7            push a
0853   098C 11            mov a, b
0854   098D 26 00 00      mov b, 0
0855   0990 B0            cmp a, b
0856   0991 0E            lodflgs
0857   0992 87 01         and al, %00000001 ; ==
0858   0994 B9 00         cmp al, 0
0859   0996 0E            lodflgs
0860   0997 96            not al
0861   0998 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0862   099A 22 00         mov ah, 0
0863   099C 27            mov b, a
0864   099D E4            pop a
0865   099E C0 00 00      cmp b, 0
0866   09A1 C6 A7 09      je _if19_else
0867   09A4             _if19_true:
0868   09A4 0A B5 0F      jmp _if19_exit
0869   09A7             _if19_else:
0870   09A7             _if20_cond:
0871   09A7 29 43 12      mov b, [opr]
0872   09AA D7            push a
0873   09AB 11            mov a, b
0874   09AC 26 01 00      mov b, 1
0875   09AF B0            cmp a, b
0876   09B0 0E            lodflgs
0877   09B1 87 01         and al, %00000001 ; ==
0878   09B3 B9 00         cmp al, 0
0879   09B5 0E            lodflgs
0880   09B6 96            not al
0881   09B7 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0882   09B9 22 00         mov ah, 0
0883   09BB 27            mov b, a
0884   09BC E4            pop a
0885   09BD C0 00 00      cmp b, 0
0886   09C0 C6 CF 0C      je _if20_else
0887   09C3             _if20_true:
0888   09C3 26 00 00      mov b, 0
0889   09C6 FD 42 53 12   mov [k], b
0890   09CA             _if21_cond:
0891   09CA 29 49 12      mov b, [datadr3]
0892   09CD D7            push a
0893   09CE 11            mov a, b
0894   09CF 26 06 00      mov b, 6
0895   09D2 B0            cmp a, b
0896   09D3 0E            lodflgs
0897   09D4 87 03         and al, %00000011
0898   09D6 B9 00         cmp al, %00000000
0899   09D8 0E            lodflgs
0900   09D9 87 01         and al, %00000001 ; >
0901   09DB B9 00         cmp al, 0
0902   09DD 0E            lodflgs
0903   09DE 96            not al
0904   09DF 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0905   09E1 22 00         mov ah, 0
0906   09E3 27            mov b, a
0907   09E4 E4            pop a
0908   09E5 C0 00 00      cmp b, 0
0909   09E8 C6 04 0A      je _if21_exit
0910   09EB             _if21_true:
0911   09EB 29 49 12      mov b, [datadr3]
0912   09EE D7            push a
0913   09EF 11            mov a, b
0914   09F0 26 07 00      mov b, 7
0915   09F3 60            sub a, b
0916   09F4 27            mov b, a
0917   09F5 E4            pop a
0918   09F6 FD 42 49 12   mov [datadr3], b
0919   09FA 26 40 00      mov b, 64
0920   09FD FD 42 53 12   mov [k], b
0921   0A01 0A 04 0A      jmp _if21_exit
0922   0A04             _if21_exit:
0923   0A04             _if22_cond:
0924   0A04 29 4D 11      mov b, [datum]
0925   0A07 D7            push a
0926   0A08 74            mov d, b
0927   0A09 DA            push d
0928   0A0A 29 45 12      mov b, [datadr1]
0929   0A0D E7            pop d
0930   0A0E 10 02 00      mov a, 2
0931   0A11 AC            mul a, b
0932   0A12 5A            add d, b
0933   0A13 2A            mov b, [d]
0934   0A14 E4            pop a
0935   0A15 D7            push a
0936   0A16 11            mov a, b
0937   0A17 26 00 00      mov b, 0
0938   0A1A B0            cmp a, b
0939   0A1B 0E            lodflgs
0940   0A1C 87 01         and al, %00000001 ; ==
0941   0A1E B9 00         cmp al, 0
0942   0A20 0E            lodflgs
0943   0A21 96            not al
0944   0A22 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0945   0A24 22 00         mov ah, 0
0946   0A26 27            mov b, a
0947   0A27 E4            pop a
0948   0A28 D7            push a
0949   0A29 11            mov a, b
0950   0A2A AF 00 00      cmp a, 0
0951   0A2D 0E            lodflgs
0952   0A2E 96            not al
0953   0A2F 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
0954   0A31 29 49 12      mov b, [datadr3]
0955   0A34 D7            push a
0956   0A35 11            mov a, b
0957   0A36 26 00 00      mov b, 0
0958   0A39 B0            cmp a, b
0959   0A3A 0E            lodflgs
0960   0A3B 87 01         and al, %00000001 ; ==
0961   0A3D B9 00         cmp al, 0
0962   0A3F 0E            lodflgs
0963   0A40 96            not al
0964   0A41 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0965   0A43 22 00         mov ah, 0
0966   0A45 27            mov b, a
0967   0A46 E4            pop a
0968   0A47 DB            push al
0969   0A48 C0 00 00      cmp b, 0
0970   0A4B 0E            lodflgs
0971   0A4C 96            not al
0972   0A4D 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
0973   0A4F EA            pop bl
0974   0A50 88            and al, bl
0975   0A51 2F            mov bl, al
0976   0A52 A7 00         mov bh, 0
0977   0A54 E4            pop a
0978   0A55 D7            push a
0979   0A56 11            mov a, b
0980   0A57 29 4D 11      mov b, [datum]
0981   0A5A D7            push a
0982   0A5B 74            mov d, b
0983   0A5C DA            push d
0984   0A5D 29 45 12      mov b, [datadr1]
0985   0A60 E7            pop d
0986   0A61 10 02 00      mov a, 2
0987   0A64 AC            mul a, b
0988   0A65 5A            add d, b
0989   0A66 2A            mov b, [d]
0990   0A67 E4            pop a
0991   0A68 D7            push a
0992   0A69 11            mov a, b
0993   0A6A 26 FF 7F      mov b, 32767
0994   0A6D B0            cmp a, b
0995   0A6E 0E            lodflgs
0996   0A6F 87 03         and al, %00000011
0997   0A71 B9 00         cmp al, %00000000
0998   0A73 0E            lodflgs
0999   0A74 87 01         and al, %00000001 ; >
1000   0A76 B9 00         cmp al, 0
1001   0A78 0E            lodflgs
1002   0A79 96            not al
1003   0A7A 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1004   0A7C 22 00         mov ah, 0
1005   0A7E 27            mov b, a
1006   0A7F E4            pop a
1007   0A80 D7            push a
1008   0A81 11            mov a, b
1009   0A82 AF 00 00      cmp a, 0
1010   0A85 0E            lodflgs
1011   0A86 96            not al
1012   0A87 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
1013   0A89 29 49 12      mov b, [datadr3]
1014   0A8C D7            push a
1015   0A8D 11            mov a, b
1016   0A8E 26 02 00      mov b, 2
1017   0A91 B0            cmp a, b
1018   0A92 0E            lodflgs
1019   0A93 87 01         and al, %00000001 ; ==
1020   0A95 B9 00         cmp al, 0
1021   0A97 0E            lodflgs
1022   0A98 96            not al
1023   0A99 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1024   0A9B 22 00         mov ah, 0
1025   0A9D 27            mov b, a
1026   0A9E E4            pop a
1027   0A9F DB            push al
1028   0AA0 C0 00 00      cmp b, 0
1029   0AA3 0E            lodflgs
1030   0AA4 96            not al
1031   0AA5 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
1032   0AA7 EA            pop bl
1033   0AA8 88            and al, bl
1034   0AA9 2F            mov bl, al
1035   0AAA A7 00         mov bh, 0
1036   0AAC E4            pop a
1037   0AAD 8A            or a, b
1038   0AAE 27            mov b, a
1039   0AAF E4            pop a
1040   0AB0 D7            push a
1041   0AB1 11            mov a, b
1042   0AB2 29 4D 11      mov b, [datum]
1043   0AB5 D7            push a
1044   0AB6 74            mov d, b
1045   0AB7 DA            push d
1046   0AB8 29 45 12      mov b, [datadr1]
1047   0ABB E7            pop d
1048   0ABC 10 02 00      mov a, 2
1049   0ABF AC            mul a, b
1050   0AC0 5A            add d, b
1051   0AC1 2A            mov b, [d]
1052   0AC2 E4            pop a
1053   0AC3 D7            push a
1054   0AC4 11            mov a, b
1055   0AC5 26 FF 7F      mov b, 32767
1056   0AC8 B0            cmp a, b
1057   0AC9 0E            lodflgs
1058   0ACA 87 03         and al, %00000011
1059   0ACC 8F 02         xor al, %00000010 ; >=
1060   0ACE B9 00         cmp al, 0
1061   0AD0 0E            lodflgs
1062   0AD1 96            not al
1063   0AD2 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1064   0AD4 22 00         mov ah, 0
1065   0AD6 27            mov b, a
1066   0AD7 E4            pop a
1067   0AD8 D7            push a
1068   0AD9 11            mov a, b
1069   0ADA AF 00 00      cmp a, 0
1070   0ADD 0E            lodflgs
1071   0ADE 96            not al
1072   0ADF 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
1073   0AE1 29 49 12      mov b, [datadr3]
1074   0AE4 D7            push a
1075   0AE5 11            mov a, b
1076   0AE6 26 04 00      mov b, 4
1077   0AE9 B0            cmp a, b
1078   0AEA 0E            lodflgs
1079   0AEB 87 01         and al, %00000001 ; ==
1080   0AED B9 00         cmp al, 0
1081   0AEF 0E            lodflgs
1082   0AF0 96            not al
1083   0AF1 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1084   0AF3 22 00         mov ah, 0
1085   0AF5 27            mov b, a
1086   0AF6 E4            pop a
1087   0AF7 DB            push al
1088   0AF8 C0 00 00      cmp b, 0
1089   0AFB 0E            lodflgs
1090   0AFC 96            not al
1091   0AFD 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
1092   0AFF EA            pop bl
1093   0B00 88            and al, bl
1094   0B01 2F            mov bl, al
1095   0B02 A7 00         mov bh, 0
1096   0B04 E4            pop a
1097   0B05 8A            or a, b
1098   0B06 27            mov b, a
1099   0B07 E4            pop a
1100   0B08 D7            push a
1101   0B09 11            mov a, b
1102   0B0A 29 4D 11      mov b, [datum]
1103   0B0D D7            push a
1104   0B0E 74            mov d, b
1105   0B0F DA            push d
1106   0B10 29 45 12      mov b, [datadr1]
1107   0B13 E7            pop d
1108   0B14 10 02 00      mov a, 2
1109   0B17 AC            mul a, b
1110   0B18 5A            add d, b
1111   0B19 2A            mov b, [d]
1112   0B1A E4            pop a
1113   0B1B D7            push a
1114   0B1C 11            mov a, b
1115   0B1D 26 00 00      mov b, 0
1116   0B20 B0            cmp a, b
1117   0B21 0E            lodflgs
1118   0B22 87 03         and al, %00000011
1119   0B24 B9 00         cmp al, %00000000
1120   0B26 0E            lodflgs
1121   0B27 87 01         and al, %00000001 ; >
1122   0B29 B9 00         cmp al, 0
1123   0B2B 0E            lodflgs
1124   0B2C 96            not al
1125   0B2D 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1126   0B2F 22 00         mov ah, 0
1127   0B31 27            mov b, a
1128   0B32 E4            pop a
1129   0B33 D7            push a
1130   0B34 11            mov a, b
1131   0B35 AF 00 00      cmp a, 0
1132   0B38 0E            lodflgs
1133   0B39 96            not al
1134   0B3A 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
1135   0B3C 29 4D 11      mov b, [datum]
1136   0B3F D7            push a
1137   0B40 74            mov d, b
1138   0B41 DA            push d
1139   0B42 29 45 12      mov b, [datadr1]
1140   0B45 E7            pop d
1141   0B46 10 02 00      mov a, 2
1142   0B49 AC            mul a, b
1143   0B4A 5A            add d, b
1144   0B4B 2A            mov b, [d]
1145   0B4C E4            pop a
1146   0B4D D7            push a
1147   0B4E 11            mov a, b
1148   0B4F 26 FF 7F      mov b, 32767
1149   0B52 B0            cmp a, b
1150   0B53 0E            lodflgs
1151   0B54 87 03         and al, %00000011 ; <=
1152   0B56 B9 00         cmp al, 0
1153   0B58 0E            lodflgs
1154   0B59 96            not al
1155   0B5A 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1156   0B5C 22 00         mov ah, 0
1157   0B5E 27            mov b, a
1158   0B5F E4            pop a
1159   0B60 DB            push al
1160   0B61 C0 00 00      cmp b, 0
1161   0B64 0E            lodflgs
1162   0B65 96            not al
1163   0B66 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
1164   0B68 EA            pop bl
1165   0B69 88            and al, bl
1166   0B6A 2F            mov bl, al
1167   0B6B A7 00         mov bh, 0
1168   0B6D E4            pop a
1169   0B6E D7            push a
1170   0B6F 11            mov a, b
1171   0B70 AF 00 00      cmp a, 0
1172   0B73 0E            lodflgs
1173   0B74 96            not al
1174   0B75 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
1175   0B77 29 49 12      mov b, [datadr3]
1176   0B7A D7            push a
1177   0B7B 11            mov a, b
1178   0B7C 26 01 00      mov b, 1
1179   0B7F B0            cmp a, b
1180   0B80 0E            lodflgs
1181   0B81 87 01         and al, %00000001 ; ==
1182   0B83 B9 00         cmp al, 0
1183   0B85 0E            lodflgs
1184   0B86 96            not al
1185   0B87 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1186   0B89 22 00         mov ah, 0
1187   0B8B 27            mov b, a
1188   0B8C E4            pop a
1189   0B8D DB            push al
1190   0B8E C0 00 00      cmp b, 0
1191   0B91 0E            lodflgs
1192   0B92 96            not al
1193   0B93 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
1194   0B95 EA            pop bl
1195   0B96 88            and al, bl
1196   0B97 2F            mov bl, al
1197   0B98 A7 00         mov bh, 0
1198   0B9A E4            pop a
1199   0B9B 8A            or a, b
1200   0B9C 27            mov b, a
1201   0B9D E4            pop a
1202   0B9E D7            push a
1203   0B9F 11            mov a, b
1204   0BA0 29 4D 11      mov b, [datum]
1205   0BA3 D7            push a
1206   0BA4 74            mov d, b
1207   0BA5 DA            push d
1208   0BA6 29 45 12      mov b, [datadr1]
1209   0BA9 E7            pop d
1210   0BAA 10 02 00      mov a, 2
1211   0BAD AC            mul a, b
1212   0BAE 5A            add d, b
1213   0BAF 2A            mov b, [d]
1214   0BB0 E4            pop a
1215   0BB1 D7            push a
1216   0BB2 11            mov a, b
1217   0BB3 26 00 00      mov b, 0
1218   0BB6 B0            cmp a, b
1219   0BB7 0E            lodflgs
1220   0BB8 87 03         and al, %00000011
1221   0BBA 8F 02         xor al, %00000010 ; >=
1222   0BBC B9 00         cmp al, 0
1223   0BBE 0E            lodflgs
1224   0BBF 96            not al
1225   0BC0 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1226   0BC2 22 00         mov ah, 0
1227   0BC4 27            mov b, a
1228   0BC5 E4            pop a
1229   0BC6 D7            push a
1230   0BC7 11            mov a, b
1231   0BC8 AF 00 00      cmp a, 0
1232   0BCB 0E            lodflgs
1233   0BCC 96            not al
1234   0BCD 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
1235   0BCF 29 4D 11      mov b, [datum]
1236   0BD2 D7            push a
1237   0BD3 74            mov d, b
1238   0BD4 DA            push d
1239   0BD5 29 45 12      mov b, [datadr1]
1240   0BD8 E7            pop d
1241   0BD9 10 02 00      mov a, 2
1242   0BDC AC            mul a, b
1243   0BDD 5A            add d, b
1244   0BDE 2A            mov b, [d]
1245   0BDF E4            pop a
1246   0BE0 D7            push a
1247   0BE1 11            mov a, b
1248   0BE2 26 FF 7F      mov b, 32767
1249   0BE5 B0            cmp a, b
1250   0BE6 0E            lodflgs
1251   0BE7 87 03         and al, %00000011 ; <=
1252   0BE9 B9 00         cmp al, 0
1253   0BEB 0E            lodflgs
1254   0BEC 96            not al
1255   0BED 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1256   0BEF 22 00         mov ah, 0
1257   0BF1 27            mov b, a
1258   0BF2 E4            pop a
1259   0BF3 DB            push al
1260   0BF4 C0 00 00      cmp b, 0
1261   0BF7 0E            lodflgs
1262   0BF8 96            not al
1263   0BF9 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
1264   0BFB EA            pop bl
1265   0BFC 88            and al, bl
1266   0BFD 2F            mov bl, al
1267   0BFE A7 00         mov bh, 0
1268   0C00 E4            pop a
1269   0C01 D7            push a
1270   0C02 11            mov a, b
1271   0C03 AF 00 00      cmp a, 0
1272   0C06 0E            lodflgs
1273   0C07 96            not al
1274   0C08 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
1275   0C0A 29 49 12      mov b, [datadr3]
1276   0C0D D7            push a
1277   0C0E 11            mov a, b
1278   0C0F 26 03 00      mov b, 3
1279   0C12 B0            cmp a, b
1280   0C13 0E            lodflgs
1281   0C14 87 01         and al, %00000001 ; ==
1282   0C16 B9 00         cmp al, 0
1283   0C18 0E            lodflgs
1284   0C19 96            not al
1285   0C1A 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1286   0C1C 22 00         mov ah, 0
1287   0C1E 27            mov b, a
1288   0C1F E4            pop a
1289   0C20 DB            push al
1290   0C21 C0 00 00      cmp b, 0
1291   0C24 0E            lodflgs
1292   0C25 96            not al
1293   0C26 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
1294   0C28 EA            pop bl
1295   0C29 88            and al, bl
1296   0C2A 2F            mov bl, al
1297   0C2B A7 00         mov bh, 0
1298   0C2D E4            pop a
1299   0C2E 8A            or a, b
1300   0C2F 27            mov b, a
1301   0C30 E4            pop a
1302   0C31 D7            push a
1303   0C32 11            mov a, b
1304   0C33 29 4D 11      mov b, [datum]
1305   0C36 D7            push a
1306   0C37 74            mov d, b
1307   0C38 DA            push d
1308   0C39 29 45 12      mov b, [datadr1]
1309   0C3C E7            pop d
1310   0C3D 10 02 00      mov a, 2
1311   0C40 AC            mul a, b
1312   0C41 5A            add d, b
1313   0C42 2A            mov b, [d]
1314   0C43 E4            pop a
1315   0C44 D7            push a
1316   0C45 11            mov a, b
1317   0C46 26 00 00      mov b, 0
1318   0C49 B0            cmp a, b
1319   0C4A 0E            lodflgs
1320   0C4B 87 01         and al, %00000001
1321   0C4D 8F 01         xor al, %00000001 ; !=
1322   0C4F B9 00         cmp al, 0
1323   0C51 0E            lodflgs
1324   0C52 96            not al
1325   0C53 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1326   0C55 22 00         mov ah, 0
1327   0C57 27            mov b, a
1328   0C58 E4            pop a
1329   0C59 D7            push a
1330   0C5A 11            mov a, b
1331   0C5B AF 00 00      cmp a, 0
1332   0C5E 0E            lodflgs
1333   0C5F 96            not al
1334   0C60 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
1335   0C62 29 49 12      mov b, [datadr3]
1336   0C65 D7            push a
1337   0C66 11            mov a, b
1338   0C67 26 05 00      mov b, 5
1339   0C6A B0            cmp a, b
1340   0C6B 0E            lodflgs
1341   0C6C 87 01         and al, %00000001 ; ==
1342   0C6E B9 00         cmp al, 0
1343   0C70 0E            lodflgs
1344   0C71 96            not al
1345   0C72 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1346   0C74 22 00         mov ah, 0
1347   0C76 27            mov b, a
1348   0C77 E4            pop a
1349   0C78 DB            push al
1350   0C79 C0 00 00      cmp b, 0
1351   0C7C 0E            lodflgs
1352   0C7D 96            not al
1353   0C7E 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
1354   0C80 EA            pop bl
1355   0C81 88            and al, bl
1356   0C82 2F            mov bl, al
1357   0C83 A7 00         mov bh, 0
1358   0C85 E4            pop a
1359   0C86 8A            or a, b
1360   0C87 27            mov b, a
1361   0C88 E4            pop a
1362   0C89 D7            push a
1363   0C8A 11            mov a, b
1364   0C8B 29 49 12      mov b, [datadr3]
1365   0C8E D7            push a
1366   0C8F 11            mov a, b
1367   0C90 26 06 00      mov b, 6
1368   0C93 B0            cmp a, b
1369   0C94 0E            lodflgs
1370   0C95 87 01         and al, %00000001 ; ==
1371   0C97 B9 00         cmp al, 0
1372   0C99 0E            lodflgs
1373   0C9A 96            not al
1374   0C9B 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1375   0C9D 22 00         mov ah, 0
1376   0C9F 27            mov b, a
1377   0CA0 E4            pop a
1378   0CA1 8A            or a, b
1379   0CA2 27            mov b, a
1380   0CA3 E4            pop a
1381   0CA4 C0 00 00      cmp b, 0
1382   0CA7 C6 C3 0C      je _if22_else
1383   0CAA             _if22_true:
1384   0CAA 29 47 12      mov b, [datadr2]
1385   0CAD D7            push a
1386   0CAE 11            mov a, b
1387   0CAF 29 53 12      mov b, [k]
1388   0CB2 54            add a, b
1389   0CB3 27            mov b, a
1390   0CB4 E4            pop a
1391   0CB5 FD 42 4B 12   mov [pc], b
1392   0CB9 26 00 00      mov b, 0
1393   0CBC FD 42 53 12   mov [k], b
1394   0CC0 0A CC 0C      jmp _if22_exit
1395   0CC3             _if22_else:
1396   0CC3 29 4B 12      mov b, [pc]
1397   0CC6 FD 77         inc b
1398   0CC8 FD 42 4B 12   mov [pc], b
1399   0CCC             _if22_exit:
1400   0CCC 0A B5 0F      jmp _if20_exit
1401   0CCF             _if20_else:
1402   0CCF             _if23_cond:
1403   0CCF 29 43 12      mov b, [opr]
1404   0CD2 D7            push a
1405   0CD3 11            mov a, b
1406   0CD4 26 02 00      mov b, 2
1407   0CD7 B0            cmp a, b
1408   0CD8 0E            lodflgs
1409   0CD9 87 01         and al, %00000001 ; ==
1410   0CDB B9 00         cmp al, 0
1411   0CDD 0E            lodflgs
1412   0CDE 96            not al
1413   0CDF 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1414   0CE1 22 00         mov ah, 0
1415   0CE3 27            mov b, a
1416   0CE4 E4            pop a
1417   0CE5 C0 00 00      cmp b, 0
1418   0CE8 C6 2D 0D      je _if23_else
1419   0CEB             _if23_true:
1420   0CEB 29 4D 11      mov b, [datum]
1421   0CEE D7            push a
1422   0CEF 74            mov d, b
1423   0CF0 DA            push d
1424   0CF1 29 45 12      mov b, [datadr1]
1425   0CF4 E7            pop d
1426   0CF5 10 02 00      mov a, 2
1427   0CF8 AC            mul a, b
1428   0CF9 5A            add d, b
1429   0CFA 2A            mov b, [d]
1430   0CFB E4            pop a
1431   0CFC FD 42 4D 12   mov [h], b
1432   0D00 29 4D 11      mov b, [datum]
1433   0D03 D7            push a
1434   0D04 74            mov d, b
1435   0D05 DA            push d
1436   0D06 29 47 12      mov b, [datadr2]
1437   0D09 E7            pop d
1438   0D0A 10 02 00      mov a, 2
1439   0D0D AC            mul a, b
1440   0D0E 5A            add d, b
1441   0D0F 2A            mov b, [d]
1442   0D10 E4            pop a
1443   0D11 FD 42 53 12   mov [k], b
1444   0D15 29 4D 11      mov b, [datum]
1445   0D18 D7            push a
1446   0D19 74            mov d, b
1447   0D1A DA            push d
1448   0D1B 29 49 12      mov b, [datadr3]
1449   0D1E E7            pop d
1450   0D1F 10 02 00      mov a, 2
1451   0D22 AC            mul a, b
1452   0D23 5A            add d, b
1453   0D24 2A            mov b, [d]
1454   0D25 E4            pop a
1455   0D26 FD 42 55 12   mov [l], b
1456   0D2A 0A B5 0F      jmp _if23_exit
1457   0D2D             _if23_else:
1458   0D2D             _if24_cond:
1459   0D2D 29 43 12      mov b, [opr]
1460   0D30 D7            push a
1461   0D31 11            mov a, b
1462   0D32 26 05 00      mov b, 5
1463   0D35 B0            cmp a, b
1464   0D36 0E            lodflgs
1465   0D37 87 01         and al, %00000001 ; ==
1466   0D39 B9 00         cmp al, 0
1467   0D3B 0E            lodflgs
1468   0D3C 96            not al
1469   0D3D 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1470   0D3F 22 00         mov ah, 0
1471   0D41 27            mov b, a
1472   0D42 E4            pop a
1473   0D43 C0 00 00      cmp b, 0
1474   0D46 C6 69 0D      je _if24_else
1475   0D49             _if24_true:
1476   0D49 29 4D 11      mov b, [datum]
1477   0D4C 74            mov d, b
1478   0D4D DA            push d
1479   0D4E 29 49 12      mov b, [datadr3]
1480   0D51 E7            pop d
1481   0D52 10 02 00      mov a, 2
1482   0D55 AC            mul a, b
1483   0D56 5A            add d, b
1484   0D57 DA            push d
1485   0D58 29 47 12      mov b, [datadr2]
1486   0D5B D7            push a
1487   0D5C 11            mov a, b
1488   0D5D 29 45 12      mov b, [datadr1]
1489   0D60 54            add a, b
1490   0D61 27            mov b, a
1491   0D62 E4            pop a
1492   0D63 E7            pop d
1493   0D64 11            mov a, b
1494   0D65 43            mov [d], a
1495   0D66 0A B5 0F      jmp _if24_exit
1496   0D69             _if24_else:
1497   0D69             _if25_cond:
1498   0D69 29 43 12      mov b, [opr]
1499   0D6C D7            push a
1500   0D6D 11            mov a, b
1501   0D6E 26 06 00      mov b, 6
1502   0D71 B0            cmp a, b
1503   0D72 0E            lodflgs
1504   0D73 87 01         and al, %00000001 ; ==
1505   0D75 B9 00         cmp al, 0
1506   0D77 0E            lodflgs
1507   0D78 96            not al
1508   0D79 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1509   0D7B 22 00         mov ah, 0
1510   0D7D 27            mov b, a
1511   0D7E E4            pop a
1512   0D7F C0 00 00      cmp b, 0
1513   0D82 C6 AB 0D      je _if25_else
1514   0D85             _if25_true:
1515   0D85 29 4D 11      mov b, [datum]
1516   0D88 74            mov d, b
1517   0D89 DA            push d
1518   0D8A 29 49 12      mov b, [datadr3]
1519   0D8D E7            pop d
1520   0D8E 10 02 00      mov a, 2
1521   0D91 AC            mul a, b
1522   0D92 5A            add d, b
1523   0D93 DA            push d
1524   0D94 29 4D 11      mov b, [datum]
1525   0D97 D7            push a
1526   0D98 74            mov d, b
1527   0D99 DA            push d
1528   0D9A 29 47 12      mov b, [datadr2]
1529   0D9D E7            pop d
1530   0D9E 10 02 00      mov a, 2
1531   0DA1 AC            mul a, b
1532   0DA2 5A            add d, b
1533   0DA3 2A            mov b, [d]
1534   0DA4 E4            pop a
1535   0DA5 E7            pop d
1536   0DA6 11            mov a, b
1537   0DA7 43            mov [d], a
1538   0DA8 0A B5 0F      jmp _if25_exit
1539   0DAB             _if25_else:
1540   0DAB             _if26_cond:
1541   0DAB 29 43 12      mov b, [opr]
1542   0DAE D7            push a
1543   0DAF 11            mov a, b
1544   0DB0 26 08 00      mov b, 8
1545   0DB3 B0            cmp a, b
1546   0DB4 0E            lodflgs
1547   0DB5 87 01         and al, %00000001 ; ==
1548   0DB7 B9 00         cmp al, 0
1549   0DB9 0E            lodflgs
1550   0DBA 96            not al
1551   0DBB 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1552   0DBD 22 00         mov ah, 0
1553   0DBF 27            mov b, a
1554   0DC0 E4            pop a
1555   0DC1 C0 00 00      cmp b, 0
1556   0DC4 C6 FB 0D      je _if26_else
1557   0DC7             _if26_true:
1558   0DC7 29 4D 11      mov b, [datum]
1559   0DCA 74            mov d, b
1560   0DCB DA            push d
1561   0DCC 29 4D 11      mov b, [datum]
1562   0DCF D7            push a
1563   0DD0 74            mov d, b
1564   0DD1 DA            push d
1565   0DD2 29 49 12      mov b, [datadr3]
1566   0DD5 E7            pop d
1567   0DD6 10 02 00      mov a, 2
1568   0DD9 AC            mul a, b
1569   0DDA 5A            add d, b
1570   0DDB 2A            mov b, [d]
1571   0DDC E4            pop a
1572   0DDD E7            pop d
1573   0DDE 10 02 00      mov a, 2
1574   0DE1 AC            mul a, b
1575   0DE2 5A            add d, b
1576   0DE3 DA            push d
1577   0DE4 29 4D 11      mov b, [datum]
1578   0DE7 D7            push a
1579   0DE8 74            mov d, b
1580   0DE9 DA            push d
1581   0DEA 29 47 12      mov b, [datadr2]
1582   0DED E7            pop d
1583   0DEE 10 02 00      mov a, 2
1584   0DF1 AC            mul a, b
1585   0DF2 5A            add d, b
1586   0DF3 2A            mov b, [d]
1587   0DF4 E4            pop a
1588   0DF5 E7            pop d
1589   0DF6 11            mov a, b
1590   0DF7 43            mov [d], a
1591   0DF8 0A B5 0F      jmp _if26_exit
1592   0DFB             _if26_else:
1593   0DFB             _if27_cond:
1594   0DFB 29 43 12      mov b, [opr]
1595   0DFE D7            push a
1596   0DFF 11            mov a, b
1597   0E00 26 09 00      mov b, 9
1598   0E03 B0            cmp a, b
1599   0E04 0E            lodflgs
1600   0E05 87 01         and al, %00000001 ; ==
1601   0E07 B9 00         cmp al, 0
1602   0E09 0E            lodflgs
1603   0E0A 96            not al
1604   0E0B 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1605   0E0D 22 00         mov ah, 0
1606   0E0F 27            mov b, a
1607   0E10 E4            pop a
1608   0E11 C0 00 00      cmp b, 0
1609   0E14 C6 53 0E      je _if27_else
1610   0E17             _if27_true:
1611   0E17 29 4D 11      mov b, [datum]
1612   0E1A 74            mov d, b
1613   0E1B DA            push d
1614   0E1C 29 49 12      mov b, [datadr3]
1615   0E1F E7            pop d
1616   0E20 10 02 00      mov a, 2
1617   0E23 AC            mul a, b
1618   0E24 5A            add d, b
1619   0E25 DA            push d
1620   0E26 29 4D 11      mov b, [datum]
1621   0E29 D7            push a
1622   0E2A 74            mov d, b
1623   0E2B DA            push d
1624   0E2C 29 45 12      mov b, [datadr1]
1625   0E2F E7            pop d
1626   0E30 10 02 00      mov a, 2
1627   0E33 AC            mul a, b
1628   0E34 5A            add d, b
1629   0E35 2A            mov b, [d]
1630   0E36 E4            pop a
1631   0E37 D7            push a
1632   0E38 11            mov a, b
1633   0E39 29 4D 11      mov b, [datum]
1634   0E3C D7            push a
1635   0E3D 74            mov d, b
1636   0E3E DA            push d
1637   0E3F 29 47 12      mov b, [datadr2]
1638   0E42 E7            pop d
1639   0E43 10 02 00      mov a, 2
1640   0E46 AC            mul a, b
1641   0E47 5A            add d, b
1642   0E48 2A            mov b, [d]
1643   0E49 E4            pop a
1644   0E4A 54            add a, b
1645   0E4B 27            mov b, a
1646   0E4C E4            pop a
1647   0E4D E7            pop d
1648   0E4E 11            mov a, b
1649   0E4F 43            mov [d], a
1650   0E50 0A B5 0F      jmp _if27_exit
1651   0E53             _if27_else:
1652   0E53             _if28_cond:
1653   0E53 29 43 12      mov b, [opr]
1654   0E56 D7            push a
1655   0E57 11            mov a, b
1656   0E58 26 0A 00      mov b, 10
1657   0E5B B0            cmp a, b
1658   0E5C 0E            lodflgs
1659   0E5D 87 01         and al, %00000001 ; ==
1660   0E5F B9 00         cmp al, 0
1661   0E61 0E            lodflgs
1662   0E62 96            not al
1663   0E63 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1664   0E65 22 00         mov ah, 0
1665   0E67 27            mov b, a
1666   0E68 E4            pop a
1667   0E69 C0 00 00      cmp b, 0
1668   0E6C C6 AB 0E      je _if28_else
1669   0E6F             _if28_true:
1670   0E6F 29 4D 11      mov b, [datum]
1671   0E72 74            mov d, b
1672   0E73 DA            push d
1673   0E74 29 49 12      mov b, [datadr3]
1674   0E77 E7            pop d
1675   0E78 10 02 00      mov a, 2
1676   0E7B AC            mul a, b
1677   0E7C 5A            add d, b
1678   0E7D DA            push d
1679   0E7E 29 4D 11      mov b, [datum]
1680   0E81 D7            push a
1681   0E82 74            mov d, b
1682   0E83 DA            push d
1683   0E84 29 45 12      mov b, [datadr1]
1684   0E87 E7            pop d
1685   0E88 10 02 00      mov a, 2
1686   0E8B AC            mul a, b
1687   0E8C 5A            add d, b
1688   0E8D 2A            mov b, [d]
1689   0E8E E4            pop a
1690   0E8F D7            push a
1691   0E90 11            mov a, b
1692   0E91 29 4D 11      mov b, [datum]
1693   0E94 D7            push a
1694   0E95 74            mov d, b
1695   0E96 DA            push d
1696   0E97 29 47 12      mov b, [datadr2]
1697   0E9A E7            pop d
1698   0E9B 10 02 00      mov a, 2
1699   0E9E AC            mul a, b
1700   0E9F 5A            add d, b
1701   0EA0 2A            mov b, [d]
1702   0EA1 E4            pop a
1703   0EA2 60            sub a, b
1704   0EA3 27            mov b, a
1705   0EA4 E4            pop a
1706   0EA5 E7            pop d
1707   0EA6 11            mov a, b
1708   0EA7 43            mov [d], a
1709   0EA8 0A B5 0F      jmp _if28_exit
1710   0EAB             _if28_else:
1711   0EAB             _if29_cond:
1712   0EAB 29 43 12      mov b, [opr]
1713   0EAE D7            push a
1714   0EAF 11            mov a, b
1715   0EB0 26 0B 00      mov b, 11
1716   0EB3 B0            cmp a, b
1717   0EB4 0E            lodflgs
1718   0EB5 87 01         and al, %00000001 ; ==
1719   0EB7 B9 00         cmp al, 0
1720   0EB9 0E            lodflgs
1721   0EBA 96            not al
1722   0EBB 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1723   0EBD 22 00         mov ah, 0
1724   0EBF 27            mov b, a
1725   0EC0 E4            pop a
1726   0EC1 C0 00 00      cmp b, 0
1727   0EC4 C6 0E 0F      je _if29_else
1728   0EC7             _if29_true:
1729   0EC7 29 4D 11      mov b, [datum]
1730   0ECA 74            mov d, b
1731   0ECB DA            push d
1732   0ECC 29 49 12      mov b, [datadr3]
1733   0ECF E7            pop d
1734   0ED0 10 02 00      mov a, 2
1735   0ED3 AC            mul a, b
1736   0ED4 5A            add d, b
1737   0ED5 DA            push d
1738   0ED6 29 4D 11      mov b, [datum]
1739   0ED9 D7            push a
1740   0EDA 74            mov d, b
1741   0EDB DA            push d
1742   0EDC 29 45 12      mov b, [datadr1]
1743   0EDF E7            pop d
1744   0EE0 10 02 00      mov a, 2
1745   0EE3 AC            mul a, b
1746   0EE4 5A            add d, b
1747   0EE5 2A            mov b, [d]
1748   0EE6 E4            pop a
1749   0EE7 D7            push a
1750   0EE8 11            mov a, b
1751   0EE9 29 4D 11      mov b, [datum]
1752   0EEC D7            push a
1753   0EED 74            mov d, b
1754   0EEE DA            push d
1755   0EEF 29 47 12      mov b, [datadr2]
1756   0EF2 E7            pop d
1757   0EF3 10 02 00      mov a, 2
1758   0EF6 AC            mul a, b
1759   0EF7 5A            add d, b
1760   0EF8 2A            mov b, [d]
1761   0EF9 E4            pop a
1762   0EFA AC            mul a, b
1763   0EFB E4            pop a
1764   0EFC D7            push a
1765   0EFD 11            mov a, b
1766   0EFE 26 64 00      mov b, 100
1767   0F01 AE            div a, b
1768   0F02 FD 78         mov g, a
1769   0F04 11            mov a, b
1770   0F05 FD 27         mov b, g
1771   0F07 E4            pop a
1772   0F08 E7            pop d
1773   0F09 11            mov a, b
1774   0F0A 43            mov [d], a
1775   0F0B 0A B5 0F      jmp _if29_exit
1776   0F0E             _if29_else:
1777   0F0E             _if30_cond:
1778   0F0E 29 43 12      mov b, [opr]
1779   0F11 D7            push a
1780   0F12 11            mov a, b
1781   0F13 26 0C 00      mov b, 12
1782   0F16 B0            cmp a, b
1783   0F17 0E            lodflgs
1784   0F18 87 01         and al, %00000001 ; ==
1785   0F1A B9 00         cmp al, 0
1786   0F1C 0E            lodflgs
1787   0F1D 96            not al
1788   0F1E 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1789   0F20 22 00         mov ah, 0
1790   0F22 27            mov b, a
1791   0F23 E4            pop a
1792   0F24 C0 00 00      cmp b, 0
1793   0F27 C6 B5 0F      je _if30_exit
1794   0F2A             _if30_true:
1795   0F2A             _if31_cond:
1796   0F2A 29 4D 11      mov b, [datum]
1797   0F2D D7            push a
1798   0F2E 74            mov d, b
1799   0F2F DA            push d
1800   0F30 29 47 12      mov b, [datadr2]
1801   0F33 E7            pop d
1802   0F34 10 02 00      mov a, 2
1803   0F37 AC            mul a, b
1804   0F38 5A            add d, b
1805   0F39 2A            mov b, [d]
1806   0F3A E4            pop a
1807   0F3B D7            push a
1808   0F3C 11            mov a, b
1809   0F3D 26 00 00      mov b, 0
1810   0F40 B0            cmp a, b
1811   0F41 0E            lodflgs
1812   0F42 87 01         and al, %00000001
1813   0F44 8F 01         xor al, %00000001 ; !=
1814   0F46 B9 00         cmp al, 0
1815   0F48 0E            lodflgs
1816   0F49 96            not al
1817   0F4A 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1818   0F4C 22 00         mov ah, 0
1819   0F4E 27            mov b, a
1820   0F4F E4            pop a
1821   0F50 C0 00 00      cmp b, 0
1822   0F53 C6 9D 0F      je _if31_else
1823   0F56             _if31_true:
1824   0F56 29 4D 11      mov b, [datum]
1825   0F59 74            mov d, b
1826   0F5A DA            push d
1827   0F5B 29 49 12      mov b, [datadr3]
1828   0F5E E7            pop d
1829   0F5F 10 02 00      mov a, 2
1830   0F62 AC            mul a, b
1831   0F63 5A            add d, b
1832   0F64 DA            push d
1833   0F65 29 4D 11      mov b, [datum]
1834   0F68 D7            push a
1835   0F69 74            mov d, b
1836   0F6A DA            push d
1837   0F6B 29 45 12      mov b, [datadr1]
1838   0F6E E7            pop d
1839   0F6F 10 02 00      mov a, 2
1840   0F72 AC            mul a, b
1841   0F73 5A            add d, b
1842   0F74 2A            mov b, [d]
1843   0F75 E4            pop a
1844   0F76 D7            push a
1845   0F77 11            mov a, b
1846   0F78 26 64 00      mov b, 100
1847   0F7B AC            mul a, b
1848   0F7C E4            pop a
1849   0F7D D7            push a
1850   0F7E 11            mov a, b
1851   0F7F 29 4D 11      mov b, [datum]
1852   0F82 D7            push a
1853   0F83 74            mov d, b
1854   0F84 DA            push d
1855   0F85 29 47 12      mov b, [datadr2]
1856   0F88 E7            pop d
1857   0F89 10 02 00      mov a, 2
1858   0F8C AC            mul a, b
1859   0F8D 5A            add d, b
1860   0F8E 2A            mov b, [d]
1861   0F8F E4            pop a
1862   0F90 AE            div a, b
1863   0F91 FD 78         mov g, a
1864   0F93 11            mov a, b
1865   0F94 FD 27         mov b, g
1866   0F96 E4            pop a
1867   0F97 E7            pop d
1868   0F98 11            mov a, b
1869   0F99 43            mov [d], a
1870   0F9A 0A B2 0F      jmp _if31_exit
1871   0F9D             _if31_else:
1872   0F9D 29 4D 11      mov b, [datum]
1873   0FA0 74            mov d, b
1874   0FA1 DA            push d
1875   0FA2 29 49 12      mov b, [datadr3]
1876   0FA5 E7            pop d
1877   0FA6 10 02 00      mov a, 2
1878   0FA9 AC            mul a, b
1879   0FAA 5A            add d, b
1880   0FAB DA            push d
1881   0FAC 26 00 00      mov b, 0
1882   0FAF E7            pop d
1883   0FB0 11            mov a, b
1884   0FB1 43            mov [d], a
1885   0FB2             _if31_exit:
1886   0FB2 0A B5 0F      jmp _if30_exit
1887   0FB5             _if30_exit:
1888   0FB5             _if29_exit:
1889   0FB5             _if28_exit:
1890   0FB5             _if27_exit:
1891   0FB5             _if26_exit:
1892   0FB5             _if25_exit:
1893   0FB5             _if24_exit:
1894   0FB5             _if23_exit:
1895   0FB5             _if20_exit:
1896   0FB5             _if19_exit:
1897   0FB5             _if32_cond:
1898   0FB5 29 43 12      mov b, [opr]
1899   0FB8 D7            push a
1900   0FB9 11            mov a, b
1901   0FBA 26 01 00      mov b, 1
1902   0FBD B0            cmp a, b
1903   0FBE 0E            lodflgs
1904   0FBF 87 01         and al, %00000001
1905   0FC1 8F 01         xor al, %00000001 ; !=
1906   0FC3 B9 00         cmp al, 0
1907   0FC5 0E            lodflgs
1908   0FC6 96            not al
1909   0FC7 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1910   0FC9 22 00         mov ah, 0
1911   0FCB 27            mov b, a
1912   0FCC E4            pop a
1913   0FCD C0 00 00      cmp b, 0
1914   0FD0 C6 29 10      je _if32_exit
1915   0FD3             _if32_true:
1916   0FD3             _if33_cond:
1917   0FD3 29 4B 12      mov b, [pc]
1918   0FD6 D7            push a
1919   0FD7 11            mov a, b
1920   0FD8 26 00 00      mov b, 0
1921   0FDB B0            cmp a, b
1922   0FDC 0E            lodflgs
1923   0FDD 87 03         and al, %00000011
1924   0FDF B9 00         cmp al, %00000000
1925   0FE1 0E            lodflgs
1926   0FE2 87 01         and al, %00000001 ; >
1927   0FE4 B9 00         cmp al, 0
1928   0FE6 0E            lodflgs
1929   0FE7 96            not al
1930   0FE8 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1931   0FEA 22 00         mov ah, 0
1932   0FEC 27            mov b, a
1933   0FED E4            pop a
1934   0FEE C0 00 00      cmp b, 0
1935   0FF1 C6 00 10      je _if33_else
1936   0FF4             _if33_true:
1937   0FF4 29 4B 12      mov b, [pc]
1938   0FF7 FD 77         inc b
1939   0FF9 FD 42 4B 12   mov [pc], b
1940   0FFD 0A 26 10      jmp _if33_exit
1941   1000             _if33_else:
1942   1000             _if34_cond:
1943   1000 29 4B 12      mov b, [pc]
1944   1003 D7            push a
1945   1004 11            mov a, b
1946   1005 26 00 00      mov b, 0
1947   1008 B0            cmp a, b
1948   1009 0E            lodflgs
1949   100A 87 01         and al, %00000001 ; ==
1950   100C B9 00         cmp al, 0
1951   100E 0E            lodflgs
1952   100F 96            not al
1953   1010 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1954   1012 22 00         mov ah, 0
1955   1014 27            mov b, a
1956   1015 E4            pop a
1957   1016 C0 00 00      cmp b, 0
1958   1019 C6 26 10      je _if34_exit
1959   101C             _if34_true:
1960   101C 26 1E 00      mov b, 30
1961   101F FD 42 4B 12   mov [pc], b
1962   1023 0A 26 10      jmp _if34_exit
1963   1026             _if34_exit:
1964   1026             _if33_exit:
1965   1026 0A 29 10      jmp _if32_exit
1966   1029             _if32_exit:
1967   1029 0A D7 07      jmp _while15_cond
1968   102C             _while15_exit:
1969   102C 0A 2F 10      jmp _if14_exit
1970   102F             _if14_exit:
1971   102F 0A 02 04      jmp _while1_cond
1972   1032             _while1_exit:
1973   1032             readint:
1974   1032 D2            push bp
1975   1033 9B            mov bp, sp
1976   1034 52 02 00      sub sp, 2 ; n
1977   1037             
1978   1037             ; --- BEGIN INLINE ASM BLOCK
1979   1037 07 A9 15      call scan_u16d
1980   103A 45 FF FF      mov [bp + -1], a
1981   103D             ; --- END INLINE ASM BLOCK
1982   103D             
1983   103D 2C FF FF      mov b, [bp + -1] ; n
1984   1040 F9            leave
1985   1041 09            ret
1986   1042             displaynumber:
1987   1042 D2            push bp
1988   1043 9B            mov bp, sp
1989   1044             
1990   1044             ; --- BEGIN INLINE ASM BLOCK
1991   1044 17 05 00      mov a, [bp + 5]
1992   1047 07 D4 14      call print_u16d
1993   104A 14 55 10      mov a, [ss]
1994   104D 3C            mov d, a
1995   104E 07 AB 14      call puts
1996   1051             ; --- END INLINE ASM BLOCK
1997   1051             
1998   1051 F9            leave
1999   1052 09            ret
2000   1053             ; --- END TEXT BLOCK
2001   1053             
2002   1053             ; --- BEGIN DATA BLOCK
2003   1053 0A 00       ss_data: .db "\n", 0
2004   1055 53 10       ss: .dw ss_data
2005   1057 00 00 00 00 datum_data: .fill 246, 0
2005   105B 00 00 00 00 
2005   105F 00 00 00 00 
2005   1063 00 00 00 00 
2005   1067 00 00 00 00 
2005   106B 00 00 00 00 
2005   106F 00 00 00 00 
2005   1073 00 00 00 00 
2005   1077 00 00 00 00 
2005   107B 00 00 00 00 
2005   107F 00 00 00 00 
2005   1083 00 00 00 00 
2005   1087 00 00 00 00 
2005   108B 00 00 00 00 
2005   108F 00 00 00 00 
2005   1093 00 00 00 00 
2005   1097 00 00 00 00 
2005   109B 00 00 00 00 
2005   109F 00 00 00 00 
2005   10A3 00 00 00 00 
2005   10A7 00 00 00 00 
2005   10AB 00 00 00 00 
2005   10AF 00 00 00 00 
2005   10B3 00 00 00 00 
2005   10B7 00 00 00 00 
2005   10BB 00 00 00 00 
2005   10BF 00 00 00 00 
2005   10C3 00 00 00 00 
2005   10C7 00 00 00 00 
2005   10CB 00 00 00 00 
2005   10CF 00 00 00 00 
2005   10D3 00 00 00 00 
2005   10D7 00 00 00 00 
2005   10DB 00 00 00 00 
2005   10DF 00 00 00 00 
2005   10E3 00 00 00 00 
2005   10E7 00 00 00 00 
2005   10EB 00 00 00 00 
2005   10EF 00 00 00 00 
2005   10F3 00 00 00 00 
2005   10F7 00 00 00 00 
2005   10FB 00 00 00 00 
2005   10FF 00 00 00 00 
2005   1103 00 00 00 00 
2005   1107 00 00 00 00 
2005   110B 00 00 00 00 
2005   110F 00 00 00 00 
2005   1113 00 00 00 00 
2005   1117 00 00 00 00 
2005   111B 00 00 00 00 
2005   111F 00 00 00 00 
2005   1123 00 00 00 00 
2005   1127 00 00 00 00 
2005   112B 00 00 00 00 
2005   112F 00 00 00 00 
2005   1133 00 00 00 00 
2005   1137 00 00 00 00 
2005   113B 00 00 00 00 
2005   113F 00 00 00 00 
2005   1143 00 00 00 00 
2005   1147 00 00 00 00 
2005   114B 00 00 
2006   114D 57 10       datum: .dw datum_data
2007   114F 00 00 00 00 instruction_data: .fill 240, 0
2007   1153 00 00 00 00 
2007   1157 00 00 00 00 
2007   115B 00 00 00 00 
2007   115F 00 00 00 00 
2007   1163 00 00 00 00 
2007   1167 00 00 00 00 
2007   116B 00 00 00 00 
2007   116F 00 00 00 00 
2007   1173 00 00 00 00 
2007   1177 00 00 00 00 
2007   117B 00 00 00 00 
2007   117F 00 00 00 00 
2007   1183 00 00 00 00 
2007   1187 00 00 00 00 
2007   118B 00 00 00 00 
2007   118F 00 00 00 00 
2007   1193 00 00 00 00 
2007   1197 00 00 00 00 
2007   119B 00 00 00 00 
2007   119F 00 00 00 00 
2007   11A3 00 00 00 00 
2007   11A7 00 00 00 00 
2007   11AB 00 00 00 00 
2007   11AF 00 00 00 00 
2007   11B3 00 00 00 00 
2007   11B7 00 00 00 00 
2007   11BB 00 00 00 00 
2007   11BF 00 00 00 00 
2007   11C3 00 00 00 00 
2007   11C7 00 00 00 00 
2007   11CB 00 00 00 00 
2007   11CF 00 00 00 00 
2007   11D3 00 00 00 00 
2007   11D7 00 00 00 00 
2007   11DB 00 00 00 00 
2007   11DF 00 00 00 00 
2007   11E3 00 00 00 00 
2007   11E7 00 00 00 00 
2007   11EB 00 00 00 00 
2007   11EF 00 00 00 00 
2007   11F3 00 00 00 00 
2007   11F7 00 00 00 00 
2007   11FB 00 00 00 00 
2007   11FF 00 00 00 00 
2007   1203 00 00 00 00 
2007   1207 00 00 00 00 
2007   120B 00 00 00 00 
2007   120F 00 00 00 00 
2007   1213 00 00 00 00 
2007   1217 00 00 00 00 
2007   121B 00 00 00 00 
2007   121F 00 00 00 00 
2007   1223 00 00 00 00 
2007   1227 00 00 00 00 
2007   122B 00 00 00 00 
2007   122F 00 00 00 00 
2007   1233 00 00 00 00 
2007   1237 00 00 00 00 
2007   123B 00 00 00 00 
2008   123F 4F 11       instruction: .dw instruction_data
2009   1241 00 00       cmdadr: .dw 0
2010   1243 00 00       opr: .dw 0
2011   1245 00 00       datadr1: .dw 0
2012   1247 00 00       datadr2: .dw 0
2013   1249 00 00       datadr3: .dw 0
2014   124B 00 00       pc: .dw 0
2015   124D 00 00       h: .dw 0
2016   124F 00 00       i: .dw 0
2017   1251 00 00       j: .dw 0
2018   1253 00 00       k: .dw 0
2019   1255 00 00       l: .dw 0
2020   1257 00 00       p: .dw 0
2021   1259 00 00       runlimit: .dw 0
2022   125B 00 00       exitflag: .dw 0
2023   125D 00 00       exitexec: .dw 0
2024   125F             ; --- END DATA BLOCK
2025   125F             
2026   125F             ; --- BEGIN INCLUDE BLOCK
2027   125F             .include "lib/stdio.asm"
0001+  125F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  125F             ; stdio.s
0003+  125F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  125F             .include "lib/string.asm"
0001++ 125F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 125F             ; string.s
0003++ 125F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 125F             
0005++ 125F             
0006++ 125F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 125F             ; strrev
0008++ 125F             ; reverse a string
0009++ 125F             ; D = string address
0010++ 125F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 125F             ; 01234
0012++ 125F             strrev:
0013++ 125F 4B          	pusha
0014++ 1260 07 A6 12    	call strlen	; length in C
0015++ 1263 12          	mov a, c
0016++ 1264 AF 01 00    	cmp a, 1
0017++ 1267 D0 81 12    	jleu strrev_end	; check string length. string len must be > 1
0018++ 126A 7D          	dec a
0019++ 126B FD 4E       	mov si, d	; beginning of string
0020++ 126D FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 126F 59          	add d, a	; end of string
0022++ 1270 12          	mov a, c
0023++ 1271 FD 9B       	shr a		; divide by 2
0024++ 1273 39          	mov c, a	; C now counts the steps
0025++ 1274             strrev_L0:
0026++ 1274 32          	mov bl, [d]	; save load right-side char into BL
0027++ 1275 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 1276 3E          	mov [d], al	; store left char into right side
0029++ 1277 1B          	mov al, bl
0030++ 1278 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 1279 7E          	dec c
0032++ 127A 7F          	dec d
0033++ 127B C2 00 00    	cmp c, 0
0034++ 127E C7 74 12    	jne strrev_L0
0035++ 1281             strrev_end:
0036++ 1281 4C          	popa
0037++ 1282 09          	ret
0038++ 1283             	
0039++ 1283             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 1283             ; strchr
0041++ 1283             ; search string in D for char in AL
0042++ 1283             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 1283             strchr:
0044++ 1283             strchr_L0:
0045++ 1283 32          	mov bl, [d]
0046++ 1284 C1 00       	cmp bl, 0
0047++ 1286 C6 91 12    	je strchr_end
0048++ 1289 BA          	cmp al, bl
0049++ 128A C6 91 12    	je strchr_end
0050++ 128D 79          	inc d
0051++ 128E 0A 83 12    	jmp strchr_L0
0052++ 1291             strchr_end:
0053++ 1291 1B          	mov al, bl
0054++ 1292 09          	ret
0055++ 1293             
0056++ 1293             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 1293             ; strstr
0058++ 1293             ; find sub-string
0059++ 1293             ; str1 in SI
0060++ 1293             ; str2 in DI
0061++ 1293             ; SI points to end of source string
0062++ 1293             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 1293             strstr:
0064++ 1293 DB          	push al
0065++ 1294 DA          	push d
0066++ 1295 E3          	push di
0067++ 1296             strstr_loop:
0068++ 1296 F3          	cmpsb					; compare a byte of the strings
0069++ 1297 C7 A2 12    	jne strstr_ret
0070++ 129A FC 00 00    	lea d, [di + 0]
0071++ 129D BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 129F C7 96 12    	jne strstr_loop				; equal chars but not at end
0073++ 12A2             strstr_ret:
0074++ 12A2 F0          	pop di
0075++ 12A3 E7          	pop d
0076++ 12A4 E8          	pop al
0077++ 12A5 09          	ret
0078++ 12A6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 12A6             ; length of null terminated string
0080++ 12A6             ; result in C
0081++ 12A6             ; pointer in D
0082++ 12A6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 12A6             strlen:
0084++ 12A6 DA          	push d
0085++ 12A7 38 00 00    	mov c, 0
0086++ 12AA             strlen_L1:
0087++ 12AA BD 00       	cmp byte [d], 0
0088++ 12AC C6 B4 12    	je strlen_ret
0089++ 12AF 79          	inc d
0090++ 12B0 78          	inc c
0091++ 12B1 0A AA 12    	jmp strlen_L1
0092++ 12B4             strlen_ret:
0093++ 12B4 E7          	pop d
0094++ 12B5 09          	ret
0095++ 12B6             
0096++ 12B6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 12B6             ; STRCMP
0098++ 12B6             ; compare two strings
0099++ 12B6             ; str1 in SI
0100++ 12B6             ; str2 in DI
0101++ 12B6             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 12B6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 12B6             strcmp:
0104++ 12B6 DB          	push al
0105++ 12B7 DA          	push d
0106++ 12B8 E3          	push di
0107++ 12B9 E2          	push si
0108++ 12BA             strcmp_loop:
0109++ 12BA F3          	cmpsb					; compare a byte of the strings
0110++ 12BB C7 C6 12    	jne strcmp_ret
0111++ 12BE FB FF FF    	lea d, [si +- 1]
0112++ 12C1 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 12C3 C7 BA 12    	jne strcmp_loop				; equal chars but not at end
0114++ 12C6             strcmp_ret:
0115++ 12C6 EF          	pop si
0116++ 12C7 F0          	pop di
0117++ 12C8 E7          	pop d
0118++ 12C9 E8          	pop al
0119++ 12CA 09          	ret
0120++ 12CB             
0121++ 12CB             
0122++ 12CB             ; STRCPY
0123++ 12CB             ; copy null terminated string from SI to DI
0124++ 12CB             ; source in SI
0125++ 12CB             ; destination in DI
0126++ 12CB             strcpy:
0127++ 12CB E2          	push si
0128++ 12CC E3          	push di
0129++ 12CD DB          	push al
0130++ 12CE             strcpy_L1:
0131++ 12CE F6          	lodsb
0132++ 12CF F7          	stosb
0133++ 12D0 B9 00       	cmp al, 0
0134++ 12D2 C7 CE 12    	jne strcpy_L1
0135++ 12D5             strcpy_end:
0136++ 12D5 E8          	pop al
0137++ 12D6 F0          	pop di
0138++ 12D7 EF          	pop si
0139++ 12D8 09          	ret
0140++ 12D9             
0141++ 12D9             ; STRCAT
0142++ 12D9             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 12D9             ; source in SI
0144++ 12D9             ; destination in DI
0145++ 12D9             strcat:
0146++ 12D9 E2          	push si
0147++ 12DA E3          	push di
0148++ 12DB D7          	push a
0149++ 12DC DA          	push d
0150++ 12DD 50          	mov a, di
0151++ 12DE 3C          	mov d, a
0152++ 12DF             strcat_goto_end_L1:
0153++ 12DF BD 00       	cmp byte[d], 0
0154++ 12E1 C6 E8 12    	je strcat_start
0155++ 12E4 79          	inc d
0156++ 12E5 0A DF 12    	jmp strcat_goto_end_L1
0157++ 12E8             strcat_start:
0158++ 12E8 FD 50       	mov di, d
0159++ 12EA             strcat_L1:
0160++ 12EA F6          	lodsb
0161++ 12EB F7          	stosb
0162++ 12EC B9 00       	cmp al, 0
0163++ 12EE C7 EA 12    	jne strcat_L1
0164++ 12F1             strcat_end:
0165++ 12F1 E7          	pop d
0166++ 12F2 E4          	pop a
0167++ 12F3 F0          	pop di
0168++ 12F4 EF          	pop si
0169++ 12F5 09          	ret
0005+  12F6             
0006+  12F6 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  12FA 34 35 36 37 
0006+  12FE 38 39 41 42 
0006+  1302 43 44 45 46 
0007+  1306 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  130A 1B 5B 48 00 
0008+  130E             
0009+  130E 01 00       table_power:.dw 1
0010+  1310 0A 00       			.dw 10
0011+  1312 64 00       			.dw 100
0012+  1314 E8 03       			.dw 1000
0013+  1316 10 27       			.dw 10000
0014+  1318             
0015+  1318             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  1318             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  1318             ; ASCII in BL
0018+  1318             ; result in AL
0019+  1318             ; ascii for F = 0100 0110
0020+  1318             ; ascii for 9 = 0011 1001
0021+  1318             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  1318             hex_ascii_encode:
0023+  1318 1B          	mov al, bl
0024+  1319 93 40       	test al, $40				; test if letter or number
0025+  131B C7 21 13    	jnz hex_letter
0026+  131E 87 0F       	and al, $0F				; get number
0027+  1320 09          	ret
0028+  1321             hex_letter:
0029+  1321 87 0F       	and al, $0F				; get letter
0030+  1323 6A 09       	add al, 9
0031+  1325 09          	ret
0032+  1326             
0033+  1326             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  1326             ; ATOI
0035+  1326             ; 2 letter hex string in B
0036+  1326             ; 8bit integer returned in AL
0037+  1326             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  1326             atoi:
0039+  1326 D8          	push b
0040+  1327 07 18 13    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  132A 30          	mov bl, bh
0042+  132B DB          	push al					; save a
0043+  132C 07 18 13    	call hex_ascii_encode
0044+  132F EA          	pop bl	
0045+  1330 FD 9E 04    	shl al, 4
0046+  1333 8C          	or al, bl
0047+  1334 E5          	pop b
0048+  1335 09          	ret	
0049+  1336             
0050+  1336             
0051+  1336             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  1336             ; printf
0053+  1336             ; no need for explanations!
0054+  1336             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  1336             printf:
0056+  1336 09          	ret
0057+  1337             
0058+  1337             
0059+  1337             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  1337             ; scanf
0061+  1337             ; no need for explanations!
0062+  1337             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  1337             scanf:
0064+  1337 09          	ret
0065+  1338             
0066+  1338             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  1338             ; ITOA
0068+  1338             ; 8bit value in BL
0069+  1338             ; 2 byte ASCII result in A
0070+  1338             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  1338             itoa:
0072+  1338 DA          	push d
0073+  1339 D8          	push b
0074+  133A A7 00       	mov bh, 0
0075+  133C FD A4 04    	shr bl, 4	
0076+  133F 74          	mov d, b
0077+  1340 1F F6 12    	mov al, [d + s_hex_digits]
0078+  1343 23          	mov ah, al
0079+  1344             	
0080+  1344 E5          	pop b
0081+  1345 D8          	push b
0082+  1346 A7 00       	mov bh, 0
0083+  1348 FD 87 0F    	and bl, $0F
0084+  134B 74          	mov d, b
0085+  134C 1F F6 12    	mov al, [d + s_hex_digits]
0086+  134F E5          	pop b
0087+  1350 E7          	pop d
0088+  1351 09          	ret
0089+  1352             
0090+  1352             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  1352             ; HEX STRING TO BINARY
0092+  1352             ; di = destination address
0093+  1352             ; si = source
0094+  1352             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  1352             hex_to_int:
0096+  1352             hex_to_int_L1:
0097+  1352 F6          	lodsb					; load from [SI] to AL
0098+  1353 B9 00       	cmp al, 0				; check if ASCII 0
0099+  1355 C6 62 13    	jz hex_to_int_ret
0100+  1358 36          	mov bh, al
0101+  1359 F6          	lodsb
0102+  135A 2F          	mov bl, al
0103+  135B 07 26 13    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  135E F7          	stosb					; store AL to [DI]
0105+  135F 0A 52 13    	jmp hex_to_int_L1
0106+  1362             hex_to_int_ret:
0107+  1362 09          	ret		
0108+  1363             
0109+  1363             
0110+  1363             
0111+  1363             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  1363             ; GETCHAR
0113+  1363             ; char in ah
0114+  1363             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  1363             getchar:
0116+  1363 DB          	push al
0117+  1364             getchar_retry:
0118+  1364 FD 0C       	sti
0119+  1366 19 01       	mov al, 1
0120+  1368 05 03       	syscall sys_io			; receive in AH
0121+  136A B9 00       	cmp al, 0			; check if any char was receive
0122+  136C C6 64 13    	je getchar_retry
0123+  136F E8          	pop al
0124+  1370 09          	ret
0125+  1371             
0126+  1371             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  1371             ; PUTCHAR
0128+  1371             ; char in ah
0129+  1371             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  1371             putchar:
0131+  1371 D7          	push a
0132+  1372 19 00       	mov al, 0
0133+  1374 05 03       	syscall sys_io			; char in AH
0134+  1376 E4          	pop a
0135+  1377 09          	ret
0136+  1378             
0137+  1378             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  1378             ;; INPUT A STRING
0139+  1378             ;; terminates with null
0140+  1378             ;; pointer in D
0141+  1378             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  1378             gets:
0143+  1378 D7          	push a
0144+  1379 DA          	push d
0145+  137A             gets_loop:
0146+  137A FD 0C       	sti
0147+  137C 19 01       	mov al, 1
0148+  137E 05 03       	syscall sys_io			; receive in AH
0149+  1380 B9 00       	cmp al, 0				; check error code (AL)
0150+  1382 C6 7A 13    	je gets_loop			; if no char received, retry
0151+  1385             
0152+  1385 76 1B       	cmp ah, 27
0153+  1387 C6 A8 13    	je gets_telnet_escape
0154+  138A 76 0A       	cmp ah, $0A				; LF
0155+  138C C6 01 14    	je gets_end
0156+  138F 76 0D       	cmp ah, $0D				; CR
0157+  1391 C6 01 14    	je gets_end
0158+  1394 76 5C       	cmp ah, $5C				; '\\'
0159+  1396 C6 D8 13    	je gets_escape
0160+  1399             	
0161+  1399 76 08       	cmp ah, $08			; check for backspace
0162+  139B C6 A4 13    	je gets_backspace
0163+  139E             
0164+  139E 1A          	mov al, ah
0165+  139F 3E          	mov [d], al
0166+  13A0 79          	inc d
0167+  13A1 0A 7A 13    	jmp gets_loop
0168+  13A4             gets_backspace:
0169+  13A4 7F          	dec d
0170+  13A5 0A 7A 13    	jmp gets_loop
0171+  13A8             gets_telnet_escape:
0172+  13A8 FD 0C       	sti
0173+  13AA 19 01       	mov al, 1
0174+  13AC 05 03       	syscall sys_io				; receive in AH without echo
0175+  13AE B9 00       	cmp al, 0					; check error code (AL)
0176+  13B0 C6 A8 13    	je gets_telnet_escape		; if no char received, retry
0177+  13B3 76 5B       	cmp ah, '['
0178+  13B5 C7 7A 13    	jne gets_loop
0179+  13B8             gets_telnet_escape_phase2:
0180+  13B8 FD 0C       	sti
0181+  13BA 19 01       	mov al, 1
0182+  13BC 05 03       	syscall sys_io					; receive in AH without echo
0183+  13BE B9 00       	cmp al, 0						; check error code (AL)
0184+  13C0 C6 B8 13    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  13C3 76 44       	cmp ah, 'D'
0186+  13C5 C6 D0 13    	je gets_left_arrow
0187+  13C8 76 43       	cmp ah, 'C'
0188+  13CA C6 D4 13    	je gets_right_arrow
0189+  13CD 0A 7A 13    	jmp gets_loop
0190+  13D0             gets_left_arrow:
0191+  13D0 7F          	dec d
0192+  13D1 0A 7A 13    	jmp gets_loop
0193+  13D4             gets_right_arrow:
0194+  13D4 79          	inc d
0195+  13D5 0A 7A 13    	jmp gets_loop
0196+  13D8             gets_escape:
0197+  13D8 FD 0C       	sti
0198+  13DA 19 01       	mov al, 1
0199+  13DC 05 03       	syscall sys_io			; receive in AH
0200+  13DE B9 00       	cmp al, 0				; check error code (AL)
0201+  13E0 C6 D8 13    	je gets_escape			; if no char received, retry
0202+  13E3 76 6E       	cmp ah, 'n'
0203+  13E5 C6 F3 13    	je gets_LF
0204+  13E8 76 72       	cmp ah, 'r'
0205+  13EA C6 FA 13    	je gets_CR
0206+  13ED 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  13EE 3E          	mov [d], al
0208+  13EF 79          	inc d
0209+  13F0 0A 7A 13    	jmp gets_loop
0210+  13F3             gets_LF:
0211+  13F3 19 0A       	mov al, $0A
0212+  13F5 3E          	mov [d], al
0213+  13F6 79          	inc d
0214+  13F7 0A 7A 13    	jmp gets_loop
0215+  13FA             gets_CR:
0216+  13FA 19 0D       	mov al, $0D
0217+  13FC 3E          	mov [d], al
0218+  13FD 79          	inc d
0219+  13FE 0A 7A 13    	jmp gets_loop
0220+  1401             gets_end:
0221+  1401 19 00       	mov al, 0
0222+  1403 3E          	mov [d], al				; terminate string
0223+  1404 E7          	pop d
0224+  1405 E4          	pop a
0225+  1406 09          	ret
0226+  1407             
0227+  1407             
0228+  1407             
0229+  1407             
0230+  1407             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  1407             ;; INPUT TEXT
0232+  1407             ;; terminated with CTRL+D
0233+  1407             ;; pointer in D
0234+  1407             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  1407             gettxt:
0236+  1407 D7          	push a
0237+  1408 DA          	push d
0238+  1409             gettxt_loop:
0239+  1409 19 01       	mov al, 1
0240+  140B 05 03       	syscall sys_io			; receive in AH
0241+  140D B9 00       	cmp al, 0				; check error code (AL)
0242+  140F C6 09 14    	je gettxt_loop		; if no char received, retry
0243+  1412 76 04       	cmp ah, 4			; EOT
0244+  1414 C6 52 14    	je gettxt_end
0245+  1417 76 08       	cmp ah, $08			; check for backspace
0246+  1419 C6 4E 14    	je gettxt_backspace
0247+  141C 76 5C       	cmp ah, $5C				; '\\'
0248+  141E C6 27 14    	je gettxt_escape
0249+  1421 1A          	mov al, ah
0250+  1422 3E          	mov [d], al
0251+  1423 79          	inc d
0252+  1424 0A 09 14    	jmp gettxt_loop
0253+  1427             gettxt_escape:
0254+  1427 19 01       	mov al, 1
0255+  1429 05 03       	syscall sys_io			; receive in AH
0256+  142B B9 00       	cmp al, 0				; check error code (AL)
0257+  142D C6 27 14    	je gettxt_escape		; if no char received, retry
0258+  1430 76 6E       	cmp ah, 'n'
0259+  1432 C6 40 14    	je gettxt_LF
0260+  1435 76 72       	cmp ah, 'r'
0261+  1437 C6 47 14    	je gettxt_CR
0262+  143A 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  143B 3E          	mov [d], al
0264+  143C 79          	inc d
0265+  143D 0A 09 14    	jmp gettxt_loop
0266+  1440             gettxt_LF:
0267+  1440 19 0A       	mov al, $0A
0268+  1442 3E          	mov [d], al
0269+  1443 79          	inc d
0270+  1444 0A 09 14    	jmp gettxt_loop
0271+  1447             gettxt_CR:
0272+  1447 19 0D       	mov al, $0D
0273+  1449 3E          	mov [d], al
0274+  144A 79          	inc d
0275+  144B 0A 09 14    	jmp gettxt_loop
0276+  144E             gettxt_backspace:
0277+  144E 7F          	dec d
0278+  144F 0A 09 14    	jmp gettxt_loop
0279+  1452             gettxt_end:
0280+  1452 19 00       	mov al, 0
0281+  1454 3E          	mov [d], al				; terminate string
0282+  1455 E7          	pop d
0283+  1456 E4          	pop a
0284+  1457 09          	ret
0285+  1458             
0286+  1458             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  1458             ; PRINT NEW LINE
0288+  1458             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  1458             printnl:
0290+  1458 D7          	push a
0291+  1459 10 00 0A    	mov a, $0A00
0292+  145C 05 03       	syscall sys_io
0293+  145E 10 00 0D    	mov a, $0D00
0294+  1461 05 03       	syscall sys_io
0295+  1463 E4          	pop a
0296+  1464 09          	ret
0297+  1465             
0298+  1465             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  1465             ; strtoint
0300+  1465             ; 4 digit hex string number in d
0301+  1465             ; integer returned in A
0302+  1465             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  1465             strtointx:
0304+  1465 D8          	push b
0305+  1466 32          	mov bl, [d]
0306+  1467 37          	mov bh, bl
0307+  1468 33 01 00    	mov bl, [d + 1]
0308+  146B 07 26 13    	call atoi				; convert to int in AL
0309+  146E 23          	mov ah, al				; move to AH
0310+  146F 33 02 00    	mov bl, [d + 2]
0311+  1472 37          	mov bh, bl
0312+  1473 33 03 00    	mov bl, [d + 3]
0313+  1476 07 26 13    	call atoi				; convert to int in AL
0314+  1479 E5          	pop b
0315+  147A 09          	ret
0316+  147B             
0317+  147B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  147B             ; strtoint
0319+  147B             ; 5 digit base10 string number in d
0320+  147B             ; integer returned in A
0321+  147B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  147B             strtoint:
0323+  147B E2          	push si
0324+  147C D8          	push b
0325+  147D D9          	push c
0326+  147E DA          	push d
0327+  147F 07 A6 12    	call strlen			; get string length in C
0328+  1482 7E          	dec c
0329+  1483 FD 4E       	mov si, d
0330+  1485 12          	mov a, c
0331+  1486 FD 99       	shl a
0332+  1488 3B 0E 13    	mov d, table_power
0333+  148B 59          	add d, a
0334+  148C 38 00 00    	mov c, 0
0335+  148F             strtoint_L0:
0336+  148F F6          	lodsb			; load ASCII to al
0337+  1490 B9 00       	cmp al, 0
0338+  1492 C6 A5 14    	je strtoint_end
0339+  1495 6F 30       	sub al, $30		; make into integer
0340+  1497 22 00       	mov ah, 0
0341+  1499 2A          	mov b, [d]
0342+  149A AC          	mul a, b			; result in B since it fits in 16bits
0343+  149B 11          	mov a, b
0344+  149C 28          	mov b, c
0345+  149D 54          	add a, b
0346+  149E 39          	mov c, a
0347+  149F 63 02 00    	sub d, 2
0348+  14A2 0A 8F 14    	jmp strtoint_L0
0349+  14A5             strtoint_end:
0350+  14A5 12          	mov a, c
0351+  14A6 E7          	pop d
0352+  14A7 E6          	pop c
0353+  14A8 E5          	pop b
0354+  14A9 EF          	pop si
0355+  14AA 09          	ret
0356+  14AB             
0357+  14AB             
0358+  14AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  14AB             ; PRINT NULL TERMINATED STRING
0360+  14AB             ; pointer in D
0361+  14AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  14AB             puts:
0363+  14AB D7          	push a
0364+  14AC DA          	push d
0365+  14AD             puts_L1:
0366+  14AD 1E          	mov al, [d]
0367+  14AE B9 00       	cmp al, 0
0368+  14B0 C6 BC 14    	jz puts_END
0369+  14B3 23          	mov ah, al
0370+  14B4 19 00       	mov al, 0
0371+  14B6 05 03       	syscall sys_io
0372+  14B8 79          	inc d
0373+  14B9 0A AD 14    	jmp puts_L1
0374+  14BC             puts_END:
0375+  14BC E7          	pop d
0376+  14BD E4          	pop a
0377+  14BE 09          	ret
0378+  14BF             
0379+  14BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  14BF             ; PRINT N SIZE STRING
0381+  14BF             ; pointer in D
0382+  14BF             ; size in C
0383+  14BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  14BF             putsn:
0385+  14BF DB          	push al
0386+  14C0 DA          	push d
0387+  14C1 D9          	push c
0388+  14C2             putsn_L0:
0389+  14C2 1E          	mov al, [d]
0390+  14C3 23          	mov ah, al
0391+  14C4 19 00       	mov al, 0
0392+  14C6 05 03       	syscall sys_io
0393+  14C8 79          	inc d
0394+  14C9 7E          	dec c	
0395+  14CA C2 00 00    	cmp c, 0
0396+  14CD C7 C2 14    	jne putsn_L0
0397+  14D0             putsn_end:
0398+  14D0 E6          	pop c
0399+  14D1 E7          	pop d
0400+  14D2 E8          	pop al
0401+  14D3 09          	ret
0402+  14D4             
0403+  14D4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  14D4             ; print 16bit decimal number
0405+  14D4             ; input number in A
0406+  14D4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  14D4             print_u16d:
0408+  14D4 D7          	push a
0409+  14D5 D8          	push b
0410+  14D6 26 10 27    	mov b, 10000
0411+  14D9 AE          	div a, b			; get 10000 coeff.
0412+  14DA 07 00 15    	call print_number
0413+  14DD 11          	mov a, b
0414+  14DE 26 E8 03    	mov b, 1000
0415+  14E1 AE          	div a, b			; get 10000 coeff.
0416+  14E2 07 00 15    	call print_number
0417+  14E5 11          	mov a, b
0418+  14E6 26 64 00    	mov b, 100
0419+  14E9 AE          	div a, b
0420+  14EA 07 00 15    	call print_number
0421+  14ED 11          	mov a, b
0422+  14EE 26 0A 00    	mov b, 10
0423+  14F1 AE          	div a, b
0424+  14F2 07 00 15    	call print_number
0425+  14F5 11          	mov a, b
0426+  14F6 6A 30       	add al, $30
0427+  14F8 23          	mov ah, al
0428+  14F9 19 00       	mov al, 0
0429+  14FB 05 03       	syscall sys_io	; print coeff
0430+  14FD E5          	pop b
0431+  14FE E4          	pop a
0432+  14FF 09          	ret
0433+  1500             
0434+  1500             
0435+  1500             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  1500             ; if A == 0, print space
0437+  1500             ; else print A
0438+  1500             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0439+  1500             print_number:
0440+  1500 6A 30       	add al, $30
0441+  1502 23          	mov ah, al
0442+  1503 07 71 13    	call putchar
0443+  1506 09          	ret
0444+  1507             
0445+  1507             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0446+  1507             ; PRINT 16BIT HEX INTEGER
0447+  1507             ; integer value in reg B
0448+  1507             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  1507             print_u16x:
0450+  1507 D7          	push a
0451+  1508 D8          	push b
0452+  1509 DD          	push bl
0453+  150A 30          	mov bl, bh
0454+  150B 07 38 13    	call itoa				; convert bh to char in A
0455+  150E 2F          	mov bl, al				; save al
0456+  150F 19 00       	mov al, 0
0457+  1511 05 03       	syscall sys_io				; display AH
0458+  1513 24          	mov ah, bl				; retrieve al
0459+  1514 19 00       	mov al, 0
0460+  1516 05 03       	syscall sys_io				; display AL
0461+  1518             
0462+  1518 EA          	pop bl
0463+  1519 07 38 13    	call itoa				; convert bh to char in A
0464+  151C 2F          	mov bl, al				; save al
0465+  151D 19 00       	mov al, 0
0466+  151F 05 03       	syscall sys_io				; display AH
0467+  1521 24          	mov ah, bl				; retrieve al
0468+  1522 19 00       	mov al, 0
0469+  1524 05 03       	syscall sys_io				; display AL
0470+  1526             
0471+  1526 E5          	pop b
0472+  1527 E4          	pop a
0473+  1528 09          	ret
0474+  1529             
0475+  1529             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  1529             ; INPUT 16BIT HEX INTEGER
0477+  1529             ; read 16bit integer into A
0478+  1529             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  1529             scan_u16x:
0480+  1529 F8 10 00    	enter 16
0481+  152C D8          	push b
0482+  152D DA          	push d
0483+  152E             
0484+  152E FA F1 FF    	lea d, [bp + -15]
0485+  1531 07 78 13    	call gets				; get number
0486+  1534             
0487+  1534 32          	mov bl, [d]
0488+  1535 37          	mov bh, bl
0489+  1536 33 01 00    	mov bl, [d + 1]
0490+  1539 07 26 13    	call atoi				; convert to int in AL
0491+  153C 23          	mov ah, al				; move to AH
0492+  153D             
0493+  153D 33 02 00    	mov bl, [d + 2]
0494+  1540 37          	mov bh, bl
0495+  1541 33 03 00    	mov bl, [d + 3]
0496+  1544 07 26 13    	call atoi				; convert to int in AL
0497+  1547             
0498+  1547 E7          	pop d
0499+  1548 E5          	pop b
0500+  1549 F9          	leave
0501+  154A 09          	ret
0502+  154B             
0503+  154B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0504+  154B             ; PRINT 8bit HEX INTEGER
0505+  154B             ; integer value in reg bl
0506+  154B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  154B             print_u8x:
0508+  154B D7          	push a
0509+  154C DD          	push bl
0510+  154D             
0511+  154D 07 38 13    	call itoa				; convert bl to char in A
0512+  1550 2F          	mov bl, al				; save al
0513+  1551 19 00       	mov al, 0
0514+  1553 05 03       	syscall sys_io				; display AH
0515+  1555 24          	mov ah, bl				; retrieve al
0516+  1556 19 00       	mov al, 0
0517+  1558 05 03       	syscall sys_io				; display AL
0518+  155A             
0519+  155A EA          	pop bl
0520+  155B E4          	pop a
0521+  155C 09          	ret
0522+  155D             
0523+  155D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0524+  155D             ; print 8bit decimal unsigned number
0525+  155D             ; input number in AL
0526+  155D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  155D             print_u8d:
0528+  155D D7          	push a
0529+  155E D8          	push b
0530+  155F             
0531+  155F 22 00       	mov ah, 0
0532+  1561 26 64 00    	mov b, 100
0533+  1564 AE          	div a, b
0534+  1565 D8          	push b			; save remainder
0535+  1566 B9 00       	cmp al, 0
0536+  1568 C6 72 15    	je skip100
0537+  156B 6A 30       	add al, $30
0538+  156D 23          	mov ah, al
0539+  156E 19 00       	mov al, 0
0540+  1570 05 03       	syscall sys_io	; print coeff
0541+  1572             skip100:
0542+  1572 E4          	pop a
0543+  1573 22 00       	mov ah, 0
0544+  1575 26 0A 00    	mov b, 10
0545+  1578 AE          	div a, b
0546+  1579 D8          	push b			; save remainder
0547+  157A B9 00       	cmp al, 0
0548+  157C C6 86 15    	je skip10
0549+  157F 6A 30       	add al, $30
0550+  1581 23          	mov ah, al
0551+  1582 19 00       	mov al, 0
0552+  1584 05 03       	syscall sys_io	; print coeff
0553+  1586             skip10:
0554+  1586 E4          	pop a
0555+  1587 1B          	mov al, bl
0556+  1588 6A 30       	add al, $30
0557+  158A 23          	mov ah, al
0558+  158B 19 00       	mov al, 0
0559+  158D 05 03       	syscall sys_io	; print coeff
0560+  158F E5          	pop b
0561+  1590 E4          	pop a
0562+  1591 09          	ret
0563+  1592             
0564+  1592             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0565+  1592             ; INPUT 8BIT HEX INTEGER
0566+  1592             ; read 8bit integer into AL
0567+  1592             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  1592             scan_u8x:
0569+  1592 F8 04 00    	enter 4
0570+  1595 D8          	push b
0571+  1596 DA          	push d
0572+  1597             
0573+  1597 FA FD FF    	lea d, [bp + -3]
0574+  159A 07 78 13    	call gets				; get number
0575+  159D             
0576+  159D 32          	mov bl, [d]
0577+  159E 37          	mov bh, bl
0578+  159F 33 01 00    	mov bl, [d + 1]
0579+  15A2 07 26 13    	call atoi				; convert to int in AL
0580+  15A5             
0581+  15A5 E7          	pop d
0582+  15A6 E5          	pop b
0583+  15A7 F9          	leave
0584+  15A8 09          	ret
0585+  15A9             
0586+  15A9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  15A9             ; input decimal number
0588+  15A9             ; result in A
0589+  15A9             ; 655'\0'
0590+  15A9             ; low--------high
0591+  15A9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0592+  15A9             scan_u16d:
0593+  15A9 F8 08 00    	enter 8
0594+  15AC E2          	push si
0595+  15AD D8          	push b
0596+  15AE D9          	push c
0597+  15AF DA          	push d
0598+  15B0 FA F9 FF    	lea d, [bp +- 7]
0599+  15B3 07 78 13    	call gets
0600+  15B6 07 A6 12    	call strlen			; get string length in C
0601+  15B9 7E          	dec c
0602+  15BA FD 4E       	mov si, d
0603+  15BC 12          	mov a, c
0604+  15BD FD 99       	shl a
0605+  15BF 3B 0E 13    	mov d, table_power
0606+  15C2 59          	add d, a
0607+  15C3 38 00 00    	mov c, 0
0608+  15C6             mul_loop:
0609+  15C6 F6          	lodsb			; load ASCII to al
0610+  15C7 B9 00       	cmp al, 0
0611+  15C9 C6 DC 15    	je mul_exit
0612+  15CC 6F 30       	sub al, $30		; make into integer
0613+  15CE 22 00       	mov ah, 0
0614+  15D0 2A          	mov b, [d]
0615+  15D1 AC          	mul a, b			; result in B since it fits in 16bits
0616+  15D2 11          	mov a, b
0617+  15D3 28          	mov b, c
0618+  15D4 54          	add a, b
0619+  15D5 39          	mov c, a
0620+  15D6 63 02 00    	sub d, 2
0621+  15D9 0A C6 15    	jmp mul_loop
0622+  15DC             mul_exit:
0623+  15DC 12          	mov a, c
0624+  15DD E7          	pop d
0625+  15DE E6          	pop c
0626+  15DF E5          	pop b
0627+  15E0 EF          	pop si
0628+  15E1 F9          	leave
0629+  15E2 09          	ret
2028   15E3             ; --- END INCLUDE BLOCK
2029   15E3             
2030   15E3             
2031   15E3             .end
tasm: Number of errors = 0
