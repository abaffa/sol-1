0001   0000             ; --- Filename: pascal.c
0002   0000             
0003   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0004   0000             
0005   0400             .org PROC_TEXT_ORG
0006   0400             
0007   0400             ; --- begin text block
0008   0400             main:
0009   0400 D2          	push bp
0010   0401 9B          	mov bp, sp
0011   0402             ; --- begin inline asm block
0012   0402 3B 39 05      mov d, s_data
0013   0405 07 B0 07      call puts
0014   0408 07 AE 08      call scan_u16d
0015   040B 42 5F 05      mov [rows], a
0016   040E             ; --- end inline asm block
0017   040E             _for1_init:
0018   040E 26 00 00      mov b, 0
0019   0411 FD 42 63 05   mov [i], b
0020   0415             _for1_cond:
0021   0415 29 63 05      mov b, [i]
0022   0418 D7            push a
0023   0419 11            mov a, b
0024   041A 29 5F 05      mov b, [rows]
0025   041D B0            cmp a, b
0026   041E 0E            lodflgs
0027   041F 87 02         and al, %00000010
0028   0421 22 00         mov ah, 0
0029   0423 27            mov b, a
0030   0424 E4            pop a
0031   0425 11            mov a, b
0032   0426 AF 00 00      cmp a, 0
0033   0429 C6 2D 05      je _for1_exit
0034   042C             _for1_block:
0035   042C             _for2_init:
0036   042C 26 01 00      mov b, 1
0037   042F FD 42 61 05   mov [space], b
0038   0433             _for2_cond:
0039   0433 29 61 05      mov b, [space]
0040   0436 D7            push a
0041   0437 11            mov a, b
0042   0438 29 5F 05      mov b, [rows]
0043   043B D7            push a
0044   043C 11            mov a, b
0045   043D 29 63 05      mov b, [i]
0046   0440 60            sub a, b
0047   0441 27            mov b, a
0048   0442 E4            pop a
0049   0443 B0            cmp a, b
0050   0444 0E            lodflgs
0051   0445 87 03         and al, %00000011
0052   0447 22 00         mov ah, 0
0053   0449 27            mov b, a
0054   044A E4            pop a
0055   044B 11            mov a, b
0056   044C AF 00 00      cmp a, 0
0057   044F C6 67 04      je _for2_exit
0058   0452             _for2_block:
0059   0452 07 2F 05      call print
0060   0455             _for2_update:
0061   0455 29 61 05      mov b, [space]
0062   0458 D7            push a
0063   0459 11            mov a, b
0064   045A 26 01 00      mov b, 1
0065   045D 54            add a, b
0066   045E 27            mov b, a
0067   045F E4            pop a
0068   0460 FD 42 61 05   mov [space], b
0069   0464 0A 33 04      jmp _for2_cond
0070   0467             _for2_exit:
0071   0467             _for3_init:
0072   0467 26 00 00      mov b, 0
0073   046A FD 42 65 05   mov [j], b
0074   046E             _for3_cond:
0075   046E 29 65 05      mov b, [j]
0076   0471 D7            push a
0077   0472 11            mov a, b
0078   0473 29 63 05      mov b, [i]
0079   0476 B0            cmp a, b
0080   0477 0E            lodflgs
0081   0478 87 03         and al, %00000011
0082   047A 22 00         mov ah, 0
0083   047C 27            mov b, a
0084   047D E4            pop a
0085   047E 11            mov a, b
0086   047F AF 00 00      cmp a, 0
0087   0482 C6 15 05      je _for3_exit
0088   0485             _for3_block:
0089   0485             _if4_cond:
0090   0485 29 65 05      mov b, [j]
0091   0488 D7            push a
0092   0489 11            mov a, b
0093   048A 26 00 00      mov b, 0
0094   048D B0            cmp a, b
0095   048E 0E            lodflgs
0096   048F 87 01         and al, %00000001
0097   0491 22 00         mov ah, 0
0098   0493 27            mov b, a
0099   0494 E4            pop a
0100   0495 D7            push a
0101   0496 11            mov a, b
0102   0497 29 63 05      mov b, [i]
0103   049A D7            push a
0104   049B 11            mov a, b
0105   049C 26 00 00      mov b, 0
0106   049F B0            cmp a, b
0107   04A0 0E            lodflgs
0108   04A1 87 01         and al, %00000001
0109   04A3 22 00         mov ah, 0
0110   04A5 27            mov b, a
0111   04A6 E4            pop a
0112   04A7 C0 00 00      cmp b, 0
0113   04AA D7            push a
0114   04AB 0E            lodflgs
0115   04AC 27            mov b, a
0116   04AD E4            pop a
0117   04AE 98            not bl
0118   04AF FD 87 01      and bl, %00000001
0119   04B2 A7 00         mov bh, 0
0120   04B4 AF 00 00      cmp a, 0
0121   04B7 0E            lodflgs
0122   04B8 96            not al
0123   04B9 87 01         and al, %00000001
0124   04BB 22 00         mov ah, 0
0125   04BD 8A            or a, b
0126   04BE 27            mov b, a
0127   04BF E4            pop a
0128   04C0 C0 00 00      cmp b, 0
0129   04C3 C6 D0 04      je _if4_else_block
0130   04C6             _if4_block:
0131   04C6 26 01 00      mov b, 1
0132   04C9 FD 42 5D 05   mov [coef], b
0133   04CD 0A FA 04      jmp _if4_exit
0134   04D0             _if4_else_block:
0135   04D0 29 5D 05      mov b, [coef]
0136   04D3 D7            push a
0137   04D4 11            mov a, b
0138   04D5 29 63 05      mov b, [i]
0139   04D8 D7            push a
0140   04D9 11            mov a, b
0141   04DA 29 65 05      mov b, [j]
0142   04DD 60            sub a, b
0143   04DE 27            mov b, a
0144   04DF E4            pop a
0145   04E0 D7            push a
0146   04E1 11            mov a, b
0147   04E2 26 01 00      mov b, 1
0148   04E5 54            add a, b
0149   04E6 27            mov b, a
0150   04E7 E4            pop a
0151   04E8 AC            mul a, b
0152   04E9 E4            pop a
0153   04EA D7            push a
0154   04EB 11            mov a, b
0155   04EC 29 65 05      mov b, [j]
0156   04EF AE            div a, b
0157   04F0 FD 78         mov g, a
0158   04F2 11            mov a, b
0159   04F3 FD 27         mov b, g
0160   04F5 E4            pop a
0161   04F6 FD 42 5D 05   mov [coef], b
0162   04FA             _if4_exit:
0163   04FA 07 2F 05      call print
0164   04FD             ; --- begin inline asm block
0165   04FD 14 5D 05      mov a, [coef]
0166   0500 07 D9 07      call print_u16d
0167   0503             ; --- end inline asm block
0168   0503             _for3_update:
0169   0503 29 65 05      mov b, [j]
0170   0506 D7            push a
0171   0507 11            mov a, b
0172   0508 26 01 00      mov b, 1
0173   050B 54            add a, b
0174   050C 27            mov b, a
0175   050D E4            pop a
0176   050E FD 42 65 05   mov [j], b
0177   0512 0A 6E 04      jmp _for3_cond
0178   0515             _for3_exit:
0179   0515             ; --- begin inline asm block
0180   0515 3B 67 05      mov d, nl_data
0181   0518 07 B0 07      call puts
0182   051B             ; --- end inline asm block
0183   051B             _for1_update:
0184   051B 29 63 05      mov b, [i]
0185   051E D7            push a
0186   051F 11            mov a, b
0187   0520 26 01 00      mov b, 1
0188   0523 54            add a, b
0189   0524 27            mov b, a
0190   0525 E4            pop a
0191   0526 FD 42 63 05   mov [i], b
0192   052A 0A 15 04      jmp _for1_cond
0193   052D             _for1_exit:
0194   052D             ; --- begin inline asm block
0195   052D 05 0B         syscall sys_terminate_proc
0196   052F             ; --- end inline asm block
0197   052F             print:
0198   052F D2          	push bp
0199   0530 9B          	mov bp, sp
0200   0531             ; --- begin inline asm block
0201   0531 3B 56 05      mov d, ss_data
0202   0534 07 B0 07      call puts
0203   0537             ; --- end inline asm block
0204   0537 F9            leave
0205   0538 09            ret
0206   0539             ; --- end text block
0207   0539             
0208   0539             ; --- begin data block
0209   0539 45 6E 74 65 s_data: .db "Enter the number of rows: ", 0
0209   053D 72 20 74 68 
0209   0541 65 20 6E 75 
0209   0545 6D 62 65 72 
0209   0549 20 6F 66 20 
0209   054D 72 6F 77 73 
0209   0551 3A 20 00 
0210   0554 39 05       s: .dw s_data
0211   0556 20 20 20 20 ss_data: .db "    ", 0
0211   055A 00 
0212   055B 56 05       ss: .dw ss_data
0213   055D 01 00       coef: .dw 1
0214   055F 00 00       rows: .dw 0
0215   0561 00 00       space: .dw 0
0216   0563 00 00       i: .dw 0
0217   0565 00 00       j: .dw 0
0218   0567 0A 0D 00    nl_data: .db "\n\r", 0
0219   056A 67 05       nl: .dw nl_data
0220   056C             ; --- end data block
0221   056C             ; --- begin include block
0222   056C             .include "lib/stdio.asm"
0001+  056C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  056C             ; stdio.s
0003+  056C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  056C             .include "lib/string.asm"
0001++ 056C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 056C             ; string.s
0003++ 056C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 056C             
0005++ 056C             
0006++ 056C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 056C             ; strrev
0008++ 056C             ; reverse a string
0009++ 056C             ; D = string address
0010++ 056C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 056C             ; 01234
0012++ 056C             strrev:
0013++ 056C 4B          	pusha
0014++ 056D 07 B3 05    	call strlen	; length in C
0015++ 0570 12          	mov a, c
0016++ 0571 AF 01 00    	cmp a, 1
0017++ 0574 D0 8E 05    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0577 7D          	dec a
0019++ 0578 FD 4E       	mov si, d	; beginning of string
0020++ 057A FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 057C 59          	add d, a	; end of string
0022++ 057D 12          	mov a, c
0023++ 057E FD 9B       	shr a		; divide by 2
0024++ 0580 39          	mov c, a	; C now counts the steps
0025++ 0581             strrev_L0:
0026++ 0581 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0582 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0583 3E          	mov [d], al	; store left char into right side
0029++ 0584 1B          	mov al, bl
0030++ 0585 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0586 7E          	dec c
0032++ 0587 7F          	dec d
0033++ 0588 C2 00 00    	cmp c, 0
0034++ 058B C7 81 05    	jne strrev_L0
0035++ 058E             strrev_end:
0036++ 058E 4C          	popa
0037++ 058F 09          	ret
0038++ 0590             	
0039++ 0590             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0590             ; strchr
0041++ 0590             ; search string in D for char in AL
0042++ 0590             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0590             strchr:
0044++ 0590             strchr_L0:
0045++ 0590 32          	mov bl, [d]
0046++ 0591 C1 00       	cmp bl, 0
0047++ 0593 C6 9E 05    	je strchr_end
0048++ 0596 BA          	cmp al, bl
0049++ 0597 C6 9E 05    	je strchr_end
0050++ 059A 79          	inc d
0051++ 059B 0A 90 05    	jmp strchr_L0
0052++ 059E             strchr_end:
0053++ 059E 1B          	mov al, bl
0054++ 059F 09          	ret
0055++ 05A0             
0056++ 05A0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 05A0             ; strstr
0058++ 05A0             ; find sub-string
0059++ 05A0             ; str1 in SI
0060++ 05A0             ; str2 in DI
0061++ 05A0             ; SI points to end of source string
0062++ 05A0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 05A0             strstr:
0064++ 05A0 DB          	push al
0065++ 05A1 DA          	push d
0066++ 05A2 E3          	push di
0067++ 05A3             strstr_loop:
0068++ 05A3 F3          	cmpsb					; compare a byte of the strings
0069++ 05A4 C7 AF 05    	jne strstr_ret
0070++ 05A7 FC 00 00    	lea d, [di + 0]
0071++ 05AA BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 05AC C7 A3 05    	jne strstr_loop				; equal chars but not at end
0073++ 05AF             strstr_ret:
0074++ 05AF F0          	pop di
0075++ 05B0 E7          	pop d
0076++ 05B1 E8          	pop al
0077++ 05B2 09          	ret
0078++ 05B3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 05B3             ; length of null terminated string
0080++ 05B3             ; result in C
0081++ 05B3             ; pointer in D
0082++ 05B3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 05B3             strlen:
0084++ 05B3 DA          	push d
0085++ 05B4 38 00 00    	mov c, 0
0086++ 05B7             strlen_L1:
0087++ 05B7 BD 00       	cmp byte [d], 0
0088++ 05B9 C6 C1 05    	je strlen_ret
0089++ 05BC 79          	inc d
0090++ 05BD 78          	inc c
0091++ 05BE 0A B7 05    	jmp strlen_L1
0092++ 05C1             strlen_ret:
0093++ 05C1 E7          	pop d
0094++ 05C2 09          	ret
0095++ 05C3             
0096++ 05C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 05C3             ; STRCMP
0098++ 05C3             ; compare two strings
0099++ 05C3             ; str1 in SI
0100++ 05C3             ; str2 in DI
0101++ 05C3             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 05C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 05C3             strcmp:
0104++ 05C3 DB          	push al
0105++ 05C4 DA          	push d
0106++ 05C5 E3          	push di
0107++ 05C6 E2          	push si
0108++ 05C7             strcmp_loop:
0109++ 05C7 F3          	cmpsb					; compare a byte of the strings
0110++ 05C8 C7 D3 05    	jne strcmp_ret
0111++ 05CB FB FF FF    	lea d, [si +- 1]
0112++ 05CE BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 05D0 C7 C7 05    	jne strcmp_loop				; equal chars but not at end
0114++ 05D3             strcmp_ret:
0115++ 05D3 EF          	pop si
0116++ 05D4 F0          	pop di
0117++ 05D5 E7          	pop d
0118++ 05D6 E8          	pop al
0119++ 05D7 09          	ret
0120++ 05D8             
0121++ 05D8             
0122++ 05D8             ; STRCPY
0123++ 05D8             ; copy null terminated string from SI to DI
0124++ 05D8             ; source in SI
0125++ 05D8             ; destination in DI
0126++ 05D8             strcpy:
0127++ 05D8 E2          	push si
0128++ 05D9 E3          	push di
0129++ 05DA DB          	push al
0130++ 05DB             strcpy_L1:
0131++ 05DB F6          	lodsb
0132++ 05DC F7          	stosb
0133++ 05DD B9 00       	cmp al, 0
0134++ 05DF C7 DB 05    	jne strcpy_L1
0135++ 05E2             strcpy_end:
0136++ 05E2 E8          	pop al
0137++ 05E3 F0          	pop di
0138++ 05E4 EF          	pop si
0139++ 05E5 09          	ret
0140++ 05E6             
0141++ 05E6             ; STRCAT
0142++ 05E6             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 05E6             ; source in SI
0144++ 05E6             ; destination in DI
0145++ 05E6             strcat:
0146++ 05E6 E2          	push si
0147++ 05E7 E3          	push di
0148++ 05E8 D7          	push a
0149++ 05E9 DA          	push d
0150++ 05EA 50          	mov a, di
0151++ 05EB 3C          	mov d, a
0152++ 05EC             strcat_goto_end_L1:
0153++ 05EC BD 00       	cmp byte[d], 0
0154++ 05EE C6 F5 05    	je strcat_start
0155++ 05F1 79          	inc d
0156++ 05F2 0A EC 05    	jmp strcat_goto_end_L1
0157++ 05F5             strcat_start:
0158++ 05F5 FD 50       	mov di, d
0159++ 05F7             strcat_L1:
0160++ 05F7 F6          	lodsb
0161++ 05F8 F7          	stosb
0162++ 05F9 B9 00       	cmp al, 0
0163++ 05FB C7 F7 05    	jne strcat_L1
0164++ 05FE             strcat_end:
0165++ 05FE E7          	pop d
0166++ 05FF E4          	pop a
0167++ 0600 F0          	pop di
0168++ 0601 EF          	pop si
0169++ 0602 09          	ret
0005+  0603             
0006+  0603 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  0607 34 35 36 37 
0006+  060B 38 39 41 42 
0006+  060F 43 44 45 46 
0007+  0613             
0008+  0613 01 00       table_power:.dw 1
0009+  0615 0A 00       			.dw 10
0010+  0617 64 00       			.dw 100
0011+  0619 E8 03       			.dw 1000
0012+  061B 10 27       			.dw 10000
0013+  061D             
0014+  061D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0015+  061D             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0016+  061D             ; ASCII in BL
0017+  061D             ; result in AL
0018+  061D             ; ascii for F = 0100 0110
0019+  061D             ; ascii for 9 = 0011 1001
0020+  061D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0021+  061D             hex_ascii_encode:
0022+  061D 1B          	mov al, bl
0023+  061E 93 40       	test al, $40				; test if letter or number
0024+  0620 C7 26 06    	jnz hex_letter
0025+  0623 87 0F       	and al, $0F				; get number
0026+  0625 09          	ret
0027+  0626             hex_letter:
0028+  0626 87 0F       	and al, $0F				; get letter
0029+  0628 6A 09       	add al, 9
0030+  062A 09          	ret
0031+  062B             
0032+  062B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0033+  062B             ; ATOI
0034+  062B             ; 2 letter hex string in B
0035+  062B             ; 8bit integer returned in AL
0036+  062B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0037+  062B             atoi:
0038+  062B D8          	push b
0039+  062C 07 1D 06    	call hex_ascii_encode			; convert BL to 4bit code in AL
0040+  062F 30          	mov bl, bh
0041+  0630 DB          	push al					; save a
0042+  0631 07 1D 06    	call hex_ascii_encode
0043+  0634 EA          	pop bl	
0044+  0635 FD 9E 04    	shl al, 4
0045+  0638 8C          	or al, bl
0046+  0639 E5          	pop b
0047+  063A 09          	ret	
0048+  063B             
0049+  063B             
0050+  063B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  063B             ; printf
0052+  063B             ; no need for explanations!
0053+  063B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0054+  063B             printf:
0055+  063B 09          	ret
0056+  063C             
0057+  063C             
0058+  063C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  063C             ; scanf
0060+  063C             ; no need for explanations!
0061+  063C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  063C             scanf:
0063+  063C 09          	ret
0064+  063D             
0065+  063D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  063D             ; ITOA
0067+  063D             ; 8bit value in BL
0068+  063D             ; 2 byte ASCII result in A
0069+  063D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0070+  063D             itoa:
0071+  063D DA          	push d
0072+  063E D8          	push b
0073+  063F A7 00       	mov bh, 0
0074+  0641 FD A4 04    	shr bl, 4	
0075+  0644 74          	mov d, b
0076+  0645 1F 03 06    	mov al, [d + s_hex_digits]
0077+  0648 23          	mov ah, al
0078+  0649             	
0079+  0649 E5          	pop b
0080+  064A D8          	push b
0081+  064B A7 00       	mov bh, 0
0082+  064D FD 87 0F    	and bl, $0F
0083+  0650 74          	mov d, b
0084+  0651 1F 03 06    	mov al, [d + s_hex_digits]
0085+  0654 E5          	pop b
0086+  0655 E7          	pop d
0087+  0656 09          	ret
0088+  0657             
0089+  0657             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0090+  0657             ; HEX STRING TO BINARY
0091+  0657             ; di = destination address
0092+  0657             ; si = source
0093+  0657             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0094+  0657             hex_to_int:
0095+  0657             hex_to_int_L1:
0096+  0657 F6          	lodsb					; load from [SI] to AL
0097+  0658 B9 00       	cmp al, 0				; check if ASCII 0
0098+  065A C6 67 06    	jz hex_to_int_ret
0099+  065D 36          	mov bh, al
0100+  065E F6          	lodsb
0101+  065F 2F          	mov bl, al
0102+  0660 07 2B 06    	call atoi				; convert ASCII byte in B to int (to AL)
0103+  0663 F7          	stosb					; store AL to [DI]
0104+  0664 0A 57 06    	jmp hex_to_int_L1
0105+  0667             hex_to_int_ret:
0106+  0667 09          	ret		
0107+  0668             
0108+  0668             
0109+  0668             
0110+  0668             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  0668             ; GETCHAR
0112+  0668             ; char in ah
0113+  0668             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0114+  0668             getchar:
0115+  0668 DB          	push al
0116+  0669             getchar_retry:
0117+  0669 FD 0C       	sti
0118+  066B 19 01       	mov al, 1
0119+  066D 05 03       	syscall sys_io			; receive in AH
0120+  066F B9 00       	cmp al, 0			; check if any char was receive
0121+  0671 C6 69 06    	je getchar_retry
0122+  0674 E8          	pop al
0123+  0675 09          	ret
0124+  0676             
0125+  0676             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0126+  0676             ; PUTCHAR
0127+  0676             ; char in ah
0128+  0676             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  0676             putchar:
0130+  0676 D7          	push a
0131+  0677 19 00       	mov al, 0
0132+  0679 05 03       	syscall sys_io			; char in AH
0133+  067B E4          	pop a
0134+  067C 09          	ret
0135+  067D             
0136+  067D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0137+  067D             ;; INPUT A STRING
0138+  067D             ;; terminates with null
0139+  067D             ;; pointer in D
0140+  067D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  067D             gets:
0142+  067D D7          	push a
0143+  067E DA          	push d
0144+  067F             gets_loop:
0145+  067F FD 0C       	sti
0146+  0681 19 01       	mov al, 1
0147+  0683 05 03       	syscall sys_io			; receive in AH
0148+  0685 B9 00       	cmp al, 0				; check error code (AL)
0149+  0687 C6 7F 06    	je gets_loop			; if no char received, retry
0150+  068A             
0151+  068A 76 1B       	cmp ah, 27
0152+  068C C6 AD 06    	je gets_telnet_escape
0153+  068F 76 0A       	cmp ah, $0A				; LF
0154+  0691 C6 06 07    	je gets_end
0155+  0694 76 0D       	cmp ah, $0D				; CR
0156+  0696 C6 06 07    	je gets_end
0157+  0699 76 5C       	cmp ah, $5C				; '\\'
0158+  069B C6 DD 06    	je gets_escape
0159+  069E             	
0160+  069E 76 08       	cmp ah, $08			; check for backspace
0161+  06A0 C6 A9 06    	je gets_backspace
0162+  06A3             
0163+  06A3 1A          	mov al, ah
0164+  06A4 3E          	mov [d], al
0165+  06A5 79          	inc d
0166+  06A6 0A 7F 06    	jmp gets_loop
0167+  06A9             gets_backspace:
0168+  06A9 7F          	dec d
0169+  06AA 0A 7F 06    	jmp gets_loop
0170+  06AD             gets_telnet_escape:
0171+  06AD FD 0C       	sti
0172+  06AF 19 01       	mov al, 1
0173+  06B1 05 03       	syscall sys_io				; receive in AH without echo
0174+  06B3 B9 00       	cmp al, 0					; check error code (AL)
0175+  06B5 C6 AD 06    	je gets_telnet_escape		; if no char received, retry
0176+  06B8 76 5B       	cmp ah, '['
0177+  06BA C7 7F 06    	jne gets_loop
0178+  06BD             gets_telnet_escape_phase2:
0179+  06BD FD 0C       	sti
0180+  06BF 19 01       	mov al, 1
0181+  06C1 05 03       	syscall sys_io					; receive in AH without echo
0182+  06C3 B9 00       	cmp al, 0						; check error code (AL)
0183+  06C5 C6 BD 06    	je gets_telnet_escape_phase2	; if no char received, retry
0184+  06C8 76 44       	cmp ah, 'D'
0185+  06CA C6 D5 06    	je gets_left_arrow
0186+  06CD 76 43       	cmp ah, 'C'
0187+  06CF C6 D9 06    	je gets_right_arrow
0188+  06D2 0A 7F 06    	jmp gets_loop
0189+  06D5             gets_left_arrow:
0190+  06D5 7F          	dec d
0191+  06D6 0A 7F 06    	jmp gets_loop
0192+  06D9             gets_right_arrow:
0193+  06D9 79          	inc d
0194+  06DA 0A 7F 06    	jmp gets_loop
0195+  06DD             gets_escape:
0196+  06DD FD 0C       	sti
0197+  06DF 19 01       	mov al, 1
0198+  06E1 05 03       	syscall sys_io			; receive in AH
0199+  06E3 B9 00       	cmp al, 0				; check error code (AL)
0200+  06E5 C6 DD 06    	je gets_escape			; if no char received, retry
0201+  06E8 76 6E       	cmp ah, 'n'
0202+  06EA C6 F8 06    	je gets_LF
0203+  06ED 76 72       	cmp ah, 'r'
0204+  06EF C6 FF 06    	je gets_CR
0205+  06F2 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0206+  06F3 3E          	mov [d], al
0207+  06F4 79          	inc d
0208+  06F5 0A 7F 06    	jmp gets_loop
0209+  06F8             gets_LF:
0210+  06F8 19 0A       	mov al, $0A
0211+  06FA 3E          	mov [d], al
0212+  06FB 79          	inc d
0213+  06FC 0A 7F 06    	jmp gets_loop
0214+  06FF             gets_CR:
0215+  06FF 19 0D       	mov al, $0D
0216+  0701 3E          	mov [d], al
0217+  0702 79          	inc d
0218+  0703 0A 7F 06    	jmp gets_loop
0219+  0706             gets_end:
0220+  0706 19 00       	mov al, 0
0221+  0708 3E          	mov [d], al				; terminate string
0222+  0709 E7          	pop d
0223+  070A E4          	pop a
0224+  070B 09          	ret
0225+  070C             
0226+  070C             
0227+  070C             
0228+  070C             
0229+  070C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0230+  070C             ;; INPUT TEXT
0231+  070C             ;; terminated with CTRL+D
0232+  070C             ;; pointer in D
0233+  070C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0234+  070C             gettxt:
0235+  070C D7          	push a
0236+  070D DA          	push d
0237+  070E             gettxt_loop:
0238+  070E 19 01       	mov al, 1
0239+  0710 05 03       	syscall sys_io			; receive in AH
0240+  0712 B9 00       	cmp al, 0				; check error code (AL)
0241+  0714 C6 0E 07    	je gettxt_loop		; if no char received, retry
0242+  0717 76 04       	cmp ah, 4			; EOT
0243+  0719 C6 57 07    	je gettxt_end
0244+  071C 76 08       	cmp ah, $08			; check for backspace
0245+  071E C6 53 07    	je gettxt_backspace
0246+  0721 76 5C       	cmp ah, $5C				; '\\'
0247+  0723 C6 2C 07    	je gettxt_escape
0248+  0726 1A          	mov al, ah
0249+  0727 3E          	mov [d], al
0250+  0728 79          	inc d
0251+  0729 0A 0E 07    	jmp gettxt_loop
0252+  072C             gettxt_escape:
0253+  072C 19 01       	mov al, 1
0254+  072E 05 03       	syscall sys_io			; receive in AH
0255+  0730 B9 00       	cmp al, 0				; check error code (AL)
0256+  0732 C6 2C 07    	je gettxt_escape		; if no char received, retry
0257+  0735 76 6E       	cmp ah, 'n'
0258+  0737 C6 45 07    	je gettxt_LF
0259+  073A 76 72       	cmp ah, 'r'
0260+  073C C6 4C 07    	je gettxt_CR
0261+  073F 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0262+  0740 3E          	mov [d], al
0263+  0741 79          	inc d
0264+  0742 0A 0E 07    	jmp gettxt_loop
0265+  0745             gettxt_LF:
0266+  0745 19 0A       	mov al, $0A
0267+  0747 3E          	mov [d], al
0268+  0748 79          	inc d
0269+  0749 0A 0E 07    	jmp gettxt_loop
0270+  074C             gettxt_CR:
0271+  074C 19 0D       	mov al, $0D
0272+  074E 3E          	mov [d], al
0273+  074F 79          	inc d
0274+  0750 0A 0E 07    	jmp gettxt_loop
0275+  0753             gettxt_backspace:
0276+  0753 7F          	dec d
0277+  0754 0A 0E 07    	jmp gettxt_loop
0278+  0757             gettxt_end:
0279+  0757 19 00       	mov al, 0
0280+  0759 3E          	mov [d], al				; terminate string
0281+  075A E7          	pop d
0282+  075B E4          	pop a
0283+  075C 09          	ret
0284+  075D             
0285+  075D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0286+  075D             ; PRINT NEW LINE
0287+  075D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  075D             printnl:
0289+  075D D7          	push a
0290+  075E 10 00 0A    	mov a, $0A00
0291+  0761 05 03       	syscall sys_io
0292+  0763 10 00 0D    	mov a, $0D00
0293+  0766 05 03       	syscall sys_io
0294+  0768 E4          	pop a
0295+  0769 09          	ret
0296+  076A             
0297+  076A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0298+  076A             ; strtoint
0299+  076A             ; 4 digit hex string number in d
0300+  076A             ; integer returned in A
0301+  076A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0302+  076A             strtointx:
0303+  076A D8          	push b
0304+  076B 32          	mov bl, [d]
0305+  076C 37          	mov bh, bl
0306+  076D 33 01 00    	mov bl, [d + 1]
0307+  0770 07 2B 06    	call atoi				; convert to int in AL
0308+  0773 23          	mov ah, al				; move to AH
0309+  0774 33 02 00    	mov bl, [d + 2]
0310+  0777 37          	mov bh, bl
0311+  0778 33 03 00    	mov bl, [d + 3]
0312+  077B 07 2B 06    	call atoi				; convert to int in AL
0313+  077E E5          	pop b
0314+  077F 09          	ret
0315+  0780             
0316+  0780             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0317+  0780             ; strtoint
0318+  0780             ; 5 digit base10 string number in d
0319+  0780             ; integer returned in A
0320+  0780             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0321+  0780             strtoint:
0322+  0780 E2          	push si
0323+  0781 D8          	push b
0324+  0782 D9          	push c
0325+  0783 DA          	push d
0326+  0784 07 B3 05    	call strlen			; get string length in C
0327+  0787 7E          	dec c
0328+  0788 FD 4E       	mov si, d
0329+  078A 12          	mov a, c
0330+  078B FD 99       	shl a
0331+  078D 3B 13 06    	mov d, table_power
0332+  0790 59          	add d, a
0333+  0791 38 00 00    	mov c, 0
0334+  0794             strtoint_L0:
0335+  0794 F6          	lodsb			; load ASCII to al
0336+  0795 B9 00       	cmp al, 0
0337+  0797 C6 AA 07    	je strtoint_end
0338+  079A 6F 30       	sub al, $30		; make into integer
0339+  079C 22 00       	mov ah, 0
0340+  079E 2A          	mov b, [d]
0341+  079F AC          	mul a, b			; result in B since it fits in 16bits
0342+  07A0 11          	mov a, b
0343+  07A1 28          	mov b, c
0344+  07A2 54          	add a, b
0345+  07A3 39          	mov c, a
0346+  07A4 63 02 00    	sub d, 2
0347+  07A7 0A 94 07    	jmp strtoint_L0
0348+  07AA             strtoint_end:
0349+  07AA 12          	mov a, c
0350+  07AB E7          	pop d
0351+  07AC E6          	pop c
0352+  07AD E5          	pop b
0353+  07AE EF          	pop si
0354+  07AF 09          	ret
0355+  07B0             
0356+  07B0             
0357+  07B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0358+  07B0             ; PRINT NULL TERMINATED STRING
0359+  07B0             ; pointer in D
0360+  07B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0361+  07B0             puts:
0362+  07B0 D7          	push a
0363+  07B1 DA          	push d
0364+  07B2             puts_L1:
0365+  07B2 1E          	mov al, [d]
0366+  07B3 B9 00       	cmp al, 0
0367+  07B5 C6 C1 07    	jz puts_END
0368+  07B8 23          	mov ah, al
0369+  07B9 19 00       	mov al, 0
0370+  07BB 05 03       	syscall sys_io
0371+  07BD 79          	inc d
0372+  07BE 0A B2 07    	jmp puts_L1
0373+  07C1             puts_END:
0374+  07C1 E7          	pop d
0375+  07C2 E4          	pop a
0376+  07C3 09          	ret
0377+  07C4             
0378+  07C4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  07C4             ; PRINT N SIZE STRING
0380+  07C4             ; pointer in D
0381+  07C4             ; size in C
0382+  07C4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0383+  07C4             putsn:
0384+  07C4 DB          	push al
0385+  07C5 DA          	push d
0386+  07C6 D9          	push c
0387+  07C7             putsn_L0:
0388+  07C7 1E          	mov al, [d]
0389+  07C8 23          	mov ah, al
0390+  07C9 19 00       	mov al, 0
0391+  07CB 05 03       	syscall sys_io
0392+  07CD 79          	inc d
0393+  07CE 7E          	dec c	
0394+  07CF C2 00 00    	cmp c, 0
0395+  07D2 C7 C7 07    	jne putsn_L0
0396+  07D5             putsn_end:
0397+  07D5 E6          	pop c
0398+  07D6 E7          	pop d
0399+  07D7 E8          	pop al
0400+  07D8 09          	ret
0401+  07D9             
0402+  07D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0403+  07D9             ; print 16bit decimal number
0404+  07D9             ; input number in A
0405+  07D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  07D9             print_u16d:
0407+  07D9 D7          	push a
0408+  07DA D8          	push b
0409+  07DB 26 10 27    	mov b, 10000
0410+  07DE AE          	div a, b			; get 10000 coeff.
0411+  07DF 07 05 08    	call print_number
0412+  07E2 11          	mov a, b
0413+  07E3 26 E8 03    	mov b, 1000
0414+  07E6 AE          	div a, b			; get 10000 coeff.
0415+  07E7 07 05 08    	call print_number
0416+  07EA 11          	mov a, b
0417+  07EB 26 64 00    	mov b, 100
0418+  07EE AE          	div a, b
0419+  07EF 07 05 08    	call print_number
0420+  07F2 11          	mov a, b
0421+  07F3 26 0A 00    	mov b, 10
0422+  07F6 AE          	div a, b
0423+  07F7 07 05 08    	call print_number
0424+  07FA 11          	mov a, b
0425+  07FB 6A 30       	add al, $30
0426+  07FD 23          	mov ah, al
0427+  07FE 19 00       	mov al, 0
0428+  0800 05 03       	syscall sys_io	; print coeff
0429+  0802 E5          	pop b
0430+  0803 E4          	pop a
0431+  0804 09          	ret
0432+  0805             
0433+  0805             
0434+  0805             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0435+  0805             ; if A == 0, print space
0436+  0805             ; else print A
0437+  0805             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0438+  0805             print_number:
0439+  0805 6A 30       	add al, $30
0440+  0807 23          	mov ah, al
0441+  0808 07 76 06    	call putchar
0442+  080B 09          	ret
0443+  080C             
0444+  080C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  080C             ; PRINT 16BIT HEX INTEGER
0446+  080C             ; integer value in reg B
0447+  080C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  080C             print_u16x:
0449+  080C D7          	push a
0450+  080D D8          	push b
0451+  080E DD          	push bl
0452+  080F 30          	mov bl, bh
0453+  0810 07 3D 06    	call itoa				; convert bh to char in A
0454+  0813 2F          	mov bl, al				; save al
0455+  0814 19 00       	mov al, 0
0456+  0816 05 03       	syscall sys_io				; display AH
0457+  0818 24          	mov ah, bl				; retrieve al
0458+  0819 19 00       	mov al, 0
0459+  081B 05 03       	syscall sys_io				; display AL
0460+  081D             
0461+  081D EA          	pop bl
0462+  081E 07 3D 06    	call itoa				; convert bh to char in A
0463+  0821 2F          	mov bl, al				; save al
0464+  0822 19 00       	mov al, 0
0465+  0824 05 03       	syscall sys_io				; display AH
0466+  0826 24          	mov ah, bl				; retrieve al
0467+  0827 19 00       	mov al, 0
0468+  0829 05 03       	syscall sys_io				; display AL
0469+  082B             
0470+  082B E5          	pop b
0471+  082C E4          	pop a
0472+  082D 09          	ret
0473+  082E             
0474+  082E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0475+  082E             ; INPUT 16BIT HEX INTEGER
0476+  082E             ; read 16bit integer into A
0477+  082E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0478+  082E             scan_u16x:
0479+  082E F8 10 00    	enter 16
0480+  0831 D8          	push b
0481+  0832 DA          	push d
0482+  0833             
0483+  0833 FA F1 FF    	lea d, [bp + -15]
0484+  0836 07 7D 06    	call gets				; get number
0485+  0839             
0486+  0839 32          	mov bl, [d]
0487+  083A 37          	mov bh, bl
0488+  083B 33 01 00    	mov bl, [d + 1]
0489+  083E 07 2B 06    	call atoi				; convert to int in AL
0490+  0841 23          	mov ah, al				; move to AH
0491+  0842             
0492+  0842 33 02 00    	mov bl, [d + 2]
0493+  0845 37          	mov bh, bl
0494+  0846 33 03 00    	mov bl, [d + 3]
0495+  0849 07 2B 06    	call atoi				; convert to int in AL
0496+  084C             
0497+  084C E7          	pop d
0498+  084D E5          	pop b
0499+  084E F9          	leave
0500+  084F 09          	ret
0501+  0850             
0502+  0850             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0503+  0850             ; PRINT 8bit HEX INTEGER
0504+  0850             ; integer value in reg bl
0505+  0850             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0506+  0850             print_u8x:
0507+  0850 D7          	push a
0508+  0851 DD          	push bl
0509+  0852             
0510+  0852 07 3D 06    	call itoa				; convert bl to char in A
0511+  0855 2F          	mov bl, al				; save al
0512+  0856 19 00       	mov al, 0
0513+  0858 05 03       	syscall sys_io				; display AH
0514+  085A 24          	mov ah, bl				; retrieve al
0515+  085B 19 00       	mov al, 0
0516+  085D 05 03       	syscall sys_io				; display AL
0517+  085F             
0518+  085F EA          	pop bl
0519+  0860 E4          	pop a
0520+  0861 09          	ret
0521+  0862             
0522+  0862             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0523+  0862             ; print 8bit decimal unsigned number
0524+  0862             ; input number in AL
0525+  0862             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0526+  0862             print_u8d:
0527+  0862 D7          	push a
0528+  0863 D8          	push b
0529+  0864             
0530+  0864 22 00       	mov ah, 0
0531+  0866 26 64 00    	mov b, 100
0532+  0869 AE          	div a, b
0533+  086A D8          	push b			; save remainder
0534+  086B B9 00       	cmp al, 0
0535+  086D C6 77 08    	je skip100
0536+  0870 6A 30       	add al, $30
0537+  0872 23          	mov ah, al
0538+  0873 19 00       	mov al, 0
0539+  0875 05 03       	syscall sys_io	; print coeff
0540+  0877             skip100:
0541+  0877 E4          	pop a
0542+  0878 22 00       	mov ah, 0
0543+  087A 26 0A 00    	mov b, 10
0544+  087D AE          	div a, b
0545+  087E D8          	push b			; save remainder
0546+  087F B9 00       	cmp al, 0
0547+  0881 C6 8B 08    	je skip10
0548+  0884 6A 30       	add al, $30
0549+  0886 23          	mov ah, al
0550+  0887 19 00       	mov al, 0
0551+  0889 05 03       	syscall sys_io	; print coeff
0552+  088B             skip10:
0553+  088B E4          	pop a
0554+  088C 1B          	mov al, bl
0555+  088D 6A 30       	add al, $30
0556+  088F 23          	mov ah, al
0557+  0890 19 00       	mov al, 0
0558+  0892 05 03       	syscall sys_io	; print coeff
0559+  0894 E5          	pop b
0560+  0895 E4          	pop a
0561+  0896 09          	ret
0562+  0897             
0563+  0897             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0564+  0897             ; INPUT 8BIT HEX INTEGER
0565+  0897             ; read 8bit integer into AL
0566+  0897             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0567+  0897             scan_u8x:
0568+  0897 F8 04 00    	enter 4
0569+  089A D8          	push b
0570+  089B DA          	push d
0571+  089C             
0572+  089C FA FD FF    	lea d, [bp + -3]
0573+  089F 07 7D 06    	call gets				; get number
0574+  08A2             
0575+  08A2 32          	mov bl, [d]
0576+  08A3 37          	mov bh, bl
0577+  08A4 33 01 00    	mov bl, [d + 1]
0578+  08A7 07 2B 06    	call atoi				; convert to int in AL
0579+  08AA             
0580+  08AA E7          	pop d
0581+  08AB E5          	pop b
0582+  08AC F9          	leave
0583+  08AD 09          	ret
0584+  08AE             
0585+  08AE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0586+  08AE             ; input decimal number
0587+  08AE             ; result in A
0588+  08AE             ; 655'\0'
0589+  08AE             ; low--------high
0590+  08AE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0591+  08AE             scan_u16d:
0592+  08AE F8 08 00    	enter 8
0593+  08B1 E2          	push si
0594+  08B2 D8          	push b
0595+  08B3 D9          	push c
0596+  08B4 DA          	push d
0597+  08B5 FA F9 FF    	lea d, [bp +- 7]
0598+  08B8 07 7D 06    	call gets
0599+  08BB 07 B3 05    	call strlen			; get string length in C
0600+  08BE 7E          	dec c
0601+  08BF FD 4E       	mov si, d
0602+  08C1 12          	mov a, c
0603+  08C2 FD 99       	shl a
0604+  08C4 3B 13 06    	mov d, table_power
0605+  08C7 59          	add d, a
0606+  08C8 38 00 00    	mov c, 0
0607+  08CB             mul_loop:
0608+  08CB F6          	lodsb			; load ASCII to al
0609+  08CC B9 00       	cmp al, 0
0610+  08CE C6 E1 08    	je mul_exit
0611+  08D1 6F 30       	sub al, $30		; make into integer
0612+  08D3 22 00       	mov ah, 0
0613+  08D5 2A          	mov b, [d]
0614+  08D6 AC          	mul a, b			; result in B since it fits in 16bits
0615+  08D7 11          	mov a, b
0616+  08D8 28          	mov b, c
0617+  08D9 54          	add a, b
0618+  08DA 39          	mov c, a
0619+  08DB 63 02 00    	sub d, 2
0620+  08DE 0A CB 08    	jmp mul_loop
0621+  08E1             mul_exit:
0622+  08E1 12          	mov a, c
0623+  08E2 E7          	pop d
0624+  08E3 E6          	pop c
0625+  08E4 E5          	pop b
0626+  08E5 EF          	pop si
0627+  08E6 F9          	leave
0628+  08E7 09          	ret
0223   08E8             ; --- end include block
0224   08E8             
0225   08E8             .end
tasm: Number of errors = 0
