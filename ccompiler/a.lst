0001   0000             ; --- FILENAME: polish.c
0002   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0400             .org PROC_TEXT_ORG
0004   0400             
0005   0400             ; --- BEGIN TEXT BLOCK
0006   0400             
0007   0400             main:
0008   0400 D2            push bp
0009   0401 9B            mov bp, sp
0010   0402 52 02 00      sub sp, 2 ; type
0011   0405 52 02 00      sub sp, 2 ; op2
0012   0408 52 64 00      sub sp, 100 ; s
0013   040B             _while1_cond:
0014   040B FA 99 FF      lea d, [bp + -103] ; s_data
0015   040E 2D            mov b, d
0016   040F FD AB         swp b
0017   0411 D8            push b
0018   0412 07 23 06      call getop
0019   0415 51 02 00      add sp, 2
0020   0418 D7            push a
0021   0419 11            mov a, b
0022   041A 45 FF FF      mov [bp + -1], a ; type
0023   041D E4            pop a
0024   041E D7            push a
0025   041F 11            mov a, b
0026   0420 26 24 00      mov b, '$'
0027   0423 B0            cmp a, b
0028   0424 0E            lodflgs
0029   0425 87 01         and al, %00000001
0030   0427 8F 01         xor al, %00000001 ; !=
0031   0429 B9 00         cmp al, 0
0032   042B 0E            lodflgs
0033   042C 96            not al
0034   042D 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0035   042F 22 00         mov ah, 0
0036   0431 27            mov b, a
0037   0432 E4            pop a
0038   0433 C0 00 00      cmp b, 0
0039   0436 C6 5C 05      je _while1_exit
0040   0439             _while1_block:
0041   0439             _switch2_expr:
0042   0439 2C FF FF      mov b, [bp + -1] ; type
0043   043C             _switch2_comparisons:
0044   043C C0 E7 03      cmp b, 999
0045   043F C6 5F 04      je _switch2_case0
0046   0442 C1 2B         cmp bl, '+'
0047   0444 C6 78 04      je _switch2_case1
0048   0447 C1 2A         cmp bl, '*'
0049   0449 C6 8F 04      je _switch2_case2
0050   044C C1 2D         cmp bl, '-'
0051   044E C6 A5 04      je _switch2_case3
0052   0451 C1 2F         cmp bl, '/'
0053   0453 C6 C5 04      je _switch2_case4
0054   0456 C0 0A 00      cmp b, 10
0055   0459 C6 16 05      je _switch2_case5
0056   045C 0A 31 05      jmp _switch2_default
0057   045F             _switch2_case0:
0058   045F FA 99 FF      lea d, [bp + -103] ; s_data
0059   0462 2D            mov b, d
0060   0463 FD AB         swp b
0061   0465 D8            push b
0062   0466 07 62 05      call _atoi
0063   0469 51 02 00      add sp, 2
0064   046C FD AB         swp b
0065   046E D8            push b
0066   046F 07 77 05      call push
0067   0472 51 02 00      add sp, 2
0068   0475 0A 59 05      jmp _switch2_exit ; case break
0069   0478             _switch2_case1:
0070   0478 07 D0 05      call pop
0071   047B D7            push a
0072   047C 11            mov a, b
0073   047D 07 D0 05      call pop
0074   0480 54            add a, b
0075   0481 27            mov b, a
0076   0482 E4            pop a
0077   0483 FD AB         swp b
0078   0485 D8            push b
0079   0486 07 77 05      call push
0080   0489 51 02 00      add sp, 2
0081   048C 0A 59 05      jmp _switch2_exit ; case break
0082   048F             _switch2_case2:
0083   048F 07 D0 05      call pop
0084   0492 D7            push a
0085   0493 11            mov a, b
0086   0494 07 D0 05      call pop
0087   0497 AC            mul a, b
0088   0498 E4            pop a
0089   0499 FD AB         swp b
0090   049B D8            push b
0091   049C 07 77 05      call push
0092   049F 51 02 00      add sp, 2
0093   04A2 0A 59 05      jmp _switch2_exit ; case break
0094   04A5             _switch2_case3:
0095   04A5 07 D0 05      call pop
0096   04A8 D7            push a
0097   04A9 11            mov a, b
0098   04AA 45 FD FF      mov [bp + -3], a ; op2
0099   04AD E4            pop a
0100   04AE 07 D0 05      call pop
0101   04B1 D7            push a
0102   04B2 11            mov a, b
0103   04B3 2C FD FF      mov b, [bp + -3] ; op2
0104   04B6 60            sub a, b
0105   04B7 27            mov b, a
0106   04B8 E4            pop a
0107   04B9 FD AB         swp b
0108   04BB D8            push b
0109   04BC 07 77 05      call push
0110   04BF 51 02 00      add sp, 2
0111   04C2 0A 59 05      jmp _switch2_exit ; case break
0112   04C5             _switch2_case4:
0113   04C5 07 D0 05      call pop
0114   04C8 D7            push a
0115   04C9 11            mov a, b
0116   04CA 45 FD FF      mov [bp + -3], a ; op2
0117   04CD E4            pop a
0118   04CE             _if3_cond:
0119   04CE 2C FD FF      mov b, [bp + -3] ; op2
0120   04D1 D7            push a
0121   04D2 11            mov a, b
0122   04D3 26 00 00      mov b, 0
0123   04D6 B0            cmp a, b
0124   04D7 0E            lodflgs
0125   04D8 87 01         and al, %00000001
0126   04DA 8F 01         xor al, %00000001 ; !=
0127   04DC B9 00         cmp al, 0
0128   04DE 0E            lodflgs
0129   04DF 96            not al
0130   04E0 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0131   04E2 22 00         mov ah, 0
0132   04E4 27            mov b, a
0133   04E5 E4            pop a
0134   04E6 C0 00 00      cmp b, 0
0135   04E9 C6 07 05      je _if3_else
0136   04EC             _if3_true:
0137   04EC 07 D0 05      call pop
0138   04EF D7            push a
0139   04F0 11            mov a, b
0140   04F1 2C FD FF      mov b, [bp + -3] ; op2
0141   04F4 AE            div a, b
0142   04F5 FD 78         mov g, a
0143   04F7 11            mov a, b
0144   04F8 FD 27         mov b, g
0145   04FA E4            pop a
0146   04FB FD AB         swp b
0147   04FD D8            push b
0148   04FE 07 77 05      call push
0149   0501 51 02 00      add sp, 2
0150   0504 0A 13 05      jmp _if3_exit
0151   0507             _if3_else:
0152   0507 26 A8 09      mov b, _string_0 ; "Divide by zero error\n"
0153   050A FD AB         swp b
0154   050C D8            push b
0155   050D 07 69 08      call print
0156   0510 51 02 00      add sp, 2
0157   0513             _if3_exit:
0158   0513 0A 59 05      jmp _switch2_exit ; case break
0159   0516             _switch2_case5:
0160   0516 07 D0 05      call pop
0161   0519 FD AB         swp b
0162   051B D8            push b
0163   051C 07 5F 08      call printn
0164   051F 51 02 00      add sp, 2
0165   0522 26 BE 09      mov b, _string_1 ; "\n"
0166   0525 FD AB         swp b
0167   0527 D8            push b
0168   0528 07 69 08      call print
0169   052B 51 02 00      add sp, 2
0170   052E 0A 59 05      jmp _switch2_exit ; case break
0171   0531             _switch2_default:
0172   0531 26 C0 09      mov b, _string_2 ; "Unknown input: "
0173   0534 FD AB         swp b
0174   0536 D8            push b
0175   0537 07 69 08      call print
0176   053A 51 02 00      add sp, 2
0177   053D FA 99 FF      lea d, [bp + -103] ; s_data
0178   0540 2D            mov b, d
0179   0541 FD AB         swp b
0180   0543 D8            push b
0181   0544 07 69 08      call print
0182   0547 51 02 00      add sp, 2
0183   054A 26 BE 09      mov b, _string_1 ; "\n"
0184   054D FD AB         swp b
0185   054F D8            push b
0186   0550 07 69 08      call print
0187   0553 51 02 00      add sp, 2
0188   0556 0A 59 05      jmp _switch2_exit ; case break
0189   0559             _switch2_exit:
0190   0559 0A 0B 04      jmp _while1_cond
0191   055C             _while1_exit:
0192   055C 26 00 00      mov b, 0
0193   055F F9            leave
0194   0560 05 0B         syscall sys_terminate_proc
0195   0562             
0196   0562             _atoi:
0197   0562 D2            push bp
0198   0563 9B            mov bp, sp
0199   0564 52 02 00      sub sp, 2 ; n
0200   0567             
0201   0567             ; --- BEGIN INLINE ASM BLOCK
0202   0567 FA 05 00      lea d, [bp + 5]
0203   056A 15            mov a, [d]
0204   056B 3C            mov d, a
0205   056C 07 3D 0C      call strtoint
0206   056F 45 FF FF      mov [bp + -1], a
0207   0572             ; --- END INLINE ASM BLOCK
0208   0572             
0209   0572 2C FF FF      mov b, [bp + -1] ; n
0210   0575 F9            leave
0211   0576 09            ret
0212   0577             
0213   0577             push:
0214   0577 D2            push bp
0215   0578 9B            mov bp, sp
0216   0579             _if4_cond:
0217   0579 29 74 08      mov b, [sp] ; sp
0218   057C D7            push a
0219   057D 11            mov a, b
0220   057E 26 64 00      mov b, 100
0221   0581 B0            cmp a, b
0222   0582 0E            lodflgs
0223   0583 87 02         and al, %00000010 ; <
0224   0585 B9 00         cmp al, 0
0225   0587 0E            lodflgs
0226   0588 96            not al
0227   0589 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0228   058B 22 00         mov ah, 0
0229   058D 27            mov b, a
0230   058E E4            pop a
0231   058F C0 00 00      cmp b, 0
0232   0592 C6 B6 05      je _if4_else
0233   0595             _if4_true:
0234   0595 29 3E 09      mov b, [val]
0235   0598 74            mov d, b
0236   0599 DA            push d
0237   059A 29 74 08      mov b, [sp] ; sp
0238   059D E7            pop d
0239   059E 10 02 00      mov a, 2
0240   05A1 AC            mul a, b
0241   05A2 5A            add d, b
0242   05A3 DA            push d
0243   05A4 2C 05 00      mov b, [bp + 5] ; f
0244   05A7 E7            pop d
0245   05A8 11            mov a, b
0246   05A9 43            mov [d], a
0247   05AA 29 74 08      mov b, [sp] ; sp
0248   05AD FD 77         inc b
0249   05AF FD 42 74 08   mov [sp], b
0250   05B3 0A CE 05      jmp _if4_exit
0251   05B6             _if4_else:
0252   05B6 26 D0 09      mov b, _string_3 ; "Error: stack full, can't push: "
0253   05B9 FD AB         swp b
0254   05BB D8            push b
0255   05BC 07 69 08      call print
0256   05BF 51 02 00      add sp, 2
0257   05C2 2C 05 00      mov b, [bp + 5] ; f
0258   05C5 FD AB         swp b
0259   05C7 D8            push b
0260   05C8 07 5F 08      call printn
0261   05CB 51 02 00      add sp, 2
0262   05CE             _if4_exit:
0263   05CE F9            leave
0264   05CF 09            ret
0265   05D0             
0266   05D0             pop:
0267   05D0 D2            push bp
0268   05D1 9B            mov bp, sp
0269   05D2             _if5_cond:
0270   05D2 29 74 08      mov b, [sp] ; sp
0271   05D5 D7            push a
0272   05D6 11            mov a, b
0273   05D7 26 00 00      mov b, 0
0274   05DA B0            cmp a, b
0275   05DB 0E            lodflgs
0276   05DC 87 03         and al, %00000011
0277   05DE B9 00         cmp al, %00000000
0278   05E0 0E            lodflgs
0279   05E1 87 01         and al, %00000001 ; >
0280   05E3 B9 00         cmp al, 0
0281   05E5 0E            lodflgs
0282   05E6 96            not al
0283   05E7 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0284   05E9 22 00         mov ah, 0
0285   05EB 27            mov b, a
0286   05EC E4            pop a
0287   05ED C0 00 00      cmp b, 0
0288   05F0 C6 12 06      je _if5_else
0289   05F3             _if5_true:
0290   05F3 29 74 08      mov b, [sp] ; sp
0291   05F6 FD 7D         dec b
0292   05F8 FD 42 74 08   mov [sp], b
0293   05FC 29 3E 09      mov b, [val]
0294   05FF D7            push a
0295   0600 74            mov d, b
0296   0601 DA            push d
0297   0602 29 74 08      mov b, [sp] ; sp
0298   0605 E7            pop d
0299   0606 10 02 00      mov a, 2
0300   0609 AC            mul a, b
0301   060A 5A            add d, b
0302   060B 2A            mov b, [d]
0303   060C E4            pop a
0304   060D F9            leave
0305   060E 09            ret
0306   060F 0A 23 06      jmp _if5_exit
0307   0612             _if5_else:
0308   0612 26 EF 09      mov b, _string_4 ; "Error: stack empty.\n"
0309   0615 FD AB         swp b
0310   0617 D8            push b
0311   0618 07 69 08      call print
0312   061B 51 02 00      add sp, 2
0313   061E 26 00 00      mov b, 0
0314   0621 F9            leave
0315   0622 09            ret
0316   0623             _if5_exit:
0317   0623             
0318   0623             getop:
0319   0623 D2            push bp
0320   0624 9B            mov bp, sp
0321   0625 52 02 00      sub sp, 2 ; i
0322   0628 52 01 00      sub sp, 1 ; c
0323   062B             _while6_cond:
0324   062B FA 05 00      lea d, [bp + 5] ; s
0325   062E 2A            mov b, [d]
0326   062F 74            mov d, b
0327   0630 DA            push d
0328   0631 26 00 00      mov b, 0
0329   0634 E7            pop d
0330   0635 10 01 00      mov a, 1
0331   0638 AC            mul a, b
0332   0639 5A            add d, b
0333   063A DA            push d
0334   063B 07 3C 07      call getch
0335   063E DB            push al
0336   063F 1B            mov al, bl
0337   0640 40 FE FF      mov [bp + -2], al ; c
0338   0643 E8            pop al
0339   0644 E7            pop d
0340   0645 1B            mov al, bl
0341   0646 3E            mov [d], al
0342   0647 D7            push a
0343   0648 11            mov a, b
0344   0649 26 20 00      mov b, ' '
0345   064C B0            cmp a, b
0346   064D 0E            lodflgs
0347   064E 87 01         and al, %00000001 ; ==
0348   0650 B9 00         cmp al, 0
0349   0652 0E            lodflgs
0350   0653 96            not al
0351   0654 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0352   0656 22 00         mov ah, 0
0353   0658 27            mov b, a
0354   0659 E4            pop a
0355   065A C0 00 00      cmp b, 0
0356   065D C6 63 06      je _while6_exit
0357   0660             _while6_block:
0358   0660 0A 2B 06      jmp _while6_cond
0359   0663             _while6_exit:
0360   0663 FA 05 00      lea d, [bp + 5] ; s
0361   0666 2A            mov b, [d]
0362   0667 74            mov d, b
0363   0668 DA            push d
0364   0669 26 01 00      mov b, 1
0365   066C E7            pop d
0366   066D 10 01 00      mov a, 1
0367   0670 AC            mul a, b
0368   0671 5A            add d, b
0369   0672 DA            push d
0370   0673 26 00 00      mov b, 0
0371   0676 E7            pop d
0372   0677 1B            mov al, bl
0373   0678 3E            mov [d], al
0374   0679             _if7_cond:
0375   0679 34 FE FF      mov bl, [bp + -2] ; c
0376   067C A7 00         mov bh, 0
0377   067E DD            push bl
0378   067F 07 D6 07      call isdigit
0379   0682 51 01 00      add sp, 1
0380   0685 DB            push al
0381   0686 C0 00 00      cmp b, 0
0382   0689 0E            lodflgs
0383   068A 87 01         and al, %00000001 ; transform logical not condition result into a single bit
0384   068C 2F            mov bl, al
0385   068D A7 00         mov bh, 0
0386   068F E8            pop al
0387   0690 C0 00 00      cmp b, 0
0388   0693 C6 A0 06      je _if7_exit
0389   0696             _if7_true:
0390   0696 34 FE FF      mov bl, [bp + -2] ; c
0391   0699 A7 00         mov bh, 0
0392   069B F9            leave
0393   069C 09            ret
0394   069D 0A A0 06      jmp _if7_exit
0395   06A0             _if7_exit:
0396   06A0 26 00 00      mov b, 0
0397   06A3 D7            push a
0398   06A4 11            mov a, b
0399   06A5 45 FF FF      mov [bp + -1], a ; i
0400   06A8 E4            pop a
0401   06A9             _if8_cond:
0402   06A9 34 FE FF      mov bl, [bp + -2] ; c
0403   06AC A7 00         mov bh, 0
0404   06AE DD            push bl
0405   06AF 07 D6 07      call isdigit
0406   06B2 51 01 00      add sp, 1
0407   06B5 C0 00 00      cmp b, 0
0408   06B8 C6 F2 06      je _if8_exit
0409   06BB             _if8_true:
0410   06BB             _while9_cond:
0411   06BB FA 05 00      lea d, [bp + 5] ; s
0412   06BE 2A            mov b, [d]
0413   06BF 74            mov d, b
0414   06C0 DA            push d
0415   06C1 2C FF FF      mov b, [bp + -1] ; i
0416   06C4 FD 77         inc b
0417   06C6 D7            push a
0418   06C7 11            mov a, b
0419   06C8 45 FF FF      mov [bp + -1], a ; i
0420   06CB E4            pop a
0421   06CC E7            pop d
0422   06CD 10 01 00      mov a, 1
0423   06D0 AC            mul a, b
0424   06D1 5A            add d, b
0425   06D2 DA            push d
0426   06D3 07 3C 07      call getch
0427   06D6 DB            push al
0428   06D7 1B            mov al, bl
0429   06D8 40 FE FF      mov [bp + -2], al ; c
0430   06DB E8            pop al
0431   06DC E7            pop d
0432   06DD 1B            mov al, bl
0433   06DE 3E            mov [d], al
0434   06DF DD            push bl
0435   06E0 07 D6 07      call isdigit
0436   06E3 51 01 00      add sp, 1
0437   06E6 C0 00 00      cmp b, 0
0438   06E9 C6 EF 06      je _while9_exit
0439   06EC             _while9_block:
0440   06EC 0A BB 06      jmp _while9_cond
0441   06EF             _while9_exit:
0442   06EF 0A F2 06      jmp _if8_exit
0443   06F2             _if8_exit:
0444   06F2 FA 05 00      lea d, [bp + 5] ; s
0445   06F5 2A            mov b, [d]
0446   06F6 74            mov d, b
0447   06F7 DA            push d
0448   06F8 2C FF FF      mov b, [bp + -1] ; i
0449   06FB E7            pop d
0450   06FC 10 01 00      mov a, 1
0451   06FF AC            mul a, b
0452   0700 5A            add d, b
0453   0701 DA            push d
0454   0702 26 00 00      mov b, 0
0455   0705 E7            pop d
0456   0706 1B            mov al, bl
0457   0707 3E            mov [d], al
0458   0708             _if10_cond:
0459   0708 34 FE FF      mov bl, [bp + -2] ; c
0460   070B A7 00         mov bh, 0
0461   070D D7            push a
0462   070E 11            mov a, b
0463   070F 26 24 00      mov b, '$'
0464   0712 B0            cmp a, b
0465   0713 0E            lodflgs
0466   0714 87 01         and al, %00000001
0467   0716 8F 01         xor al, %00000001 ; !=
0468   0718 B9 00         cmp al, 0
0469   071A 0E            lodflgs
0470   071B 96            not al
0471   071C 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0472   071E 22 00         mov ah, 0
0473   0720 27            mov b, a
0474   0721 E4            pop a
0475   0722 C0 00 00      cmp b, 0
0476   0725 C6 37 07      je _if10_exit
0477   0728             _if10_true:
0478   0728 34 FE FF      mov bl, [bp + -2] ; c
0479   072B A7 00         mov bh, 0
0480   072D DD            push bl
0481   072E 07 85 07      call ungetch
0482   0731 51 01 00      add sp, 1
0483   0734 0A 37 07      jmp _if10_exit
0484   0737             _if10_exit:
0485   0737 26 E7 03      mov b, 999
0486   073A F9            leave
0487   073B 09            ret
0488   073C             
0489   073C             getch:
0490   073C D2            push bp
0491   073D 9B            mov bp, sp
0492   073E             _if11_cond:
0493   073E 29 A6 09      mov b, [bufp] ; bufp
0494   0741 D7            push a
0495   0742 11            mov a, b
0496   0743 26 00 00      mov b, 0
0497   0746 B0            cmp a, b
0498   0747 0E            lodflgs
0499   0748 87 03         and al, %00000011
0500   074A B9 00         cmp al, %00000000
0501   074C 0E            lodflgs
0502   074D 87 01         and al, %00000001 ; >
0503   074F B9 00         cmp al, 0
0504   0751 0E            lodflgs
0505   0752 96            not al
0506   0753 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0507   0755 22 00         mov ah, 0
0508   0757 27            mov b, a
0509   0758 E4            pop a
0510   0759 C0 00 00      cmp b, 0
0511   075C C6 80 07      je _if11_else
0512   075F             _if11_true:
0513   075F 29 A6 09      mov b, [bufp] ; bufp
0514   0762 FD 7D         dec b
0515   0764 FD 42 A6 09   mov [bufp], b
0516   0768 29 A4 09      mov b, [buf]
0517   076B D7            push a
0518   076C 74            mov d, b
0519   076D DA            push d
0520   076E 29 A6 09      mov b, [bufp] ; bufp
0521   0771 E7            pop d
0522   0772 10 01 00      mov a, 1
0523   0775 AC            mul a, b
0524   0776 5A            add d, b
0525   0777 32            mov bl, [d]
0526   0778 A7 00         mov bh, 0
0527   077A E4            pop a
0528   077B F9            leave
0529   077C 09            ret
0530   077D 0A 85 07      jmp _if11_exit
0531   0780             _if11_else:
0532   0780 07 34 08      call _getchar
0533   0783 F9            leave
0534   0784 09            ret
0535   0785             _if11_exit:
0536   0785             
0537   0785             ungetch:
0538   0785 D2            push bp
0539   0786 9B            mov bp, sp
0540   0787             _if12_cond:
0541   0787 29 A6 09      mov b, [bufp] ; bufp
0542   078A D7            push a
0543   078B 11            mov a, b
0544   078C 26 64 00      mov b, 100
0545   078F B0            cmp a, b
0546   0790 0E            lodflgs
0547   0791 87 03         and al, %00000011
0548   0793 8F 02         xor al, %00000010 ; >=
0549   0795 B9 00         cmp al, 0
0550   0797 0E            lodflgs
0551   0798 96            not al
0552   0799 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0553   079B 22 00         mov ah, 0
0554   079D 27            mov b, a
0555   079E E4            pop a
0556   079F C0 00 00      cmp b, 0
0557   07A2 C6 B4 07      je _if12_else
0558   07A5             _if12_true:
0559   07A5 26 04 0A      mov b, _string_5 ; "Error: too many characters.\n"
0560   07A8 FD AB         swp b
0561   07AA D8            push b
0562   07AB 07 69 08      call print
0563   07AE 51 02 00      add sp, 2
0564   07B1 0A D4 07      jmp _if12_exit
0565   07B4             _if12_else:
0566   07B4 29 A4 09      mov b, [buf]
0567   07B7 74            mov d, b
0568   07B8 DA            push d
0569   07B9 29 A6 09      mov b, [bufp] ; bufp
0570   07BC E7            pop d
0571   07BD 10 01 00      mov a, 1
0572   07C0 AC            mul a, b
0573   07C1 5A            add d, b
0574   07C2 DA            push d
0575   07C3 34 05 00      mov bl, [bp + 5] ; c
0576   07C6 A7 00         mov bh, 0
0577   07C8 E7            pop d
0578   07C9 1B            mov al, bl
0579   07CA 3E            mov [d], al
0580   07CB 29 A6 09      mov b, [bufp] ; bufp
0581   07CE FD 77         inc b
0582   07D0 FD 42 A6 09   mov [bufp], b
0583   07D4             _if12_exit:
0584   07D4 F9            leave
0585   07D5 09            ret
0586   07D6             
0587   07D6             isdigit:
0588   07D6 D2            push bp
0589   07D7 9B            mov bp, sp
0590   07D8             _if13_cond:
0591   07D8 34 05 00      mov bl, [bp + 5] ; c
0592   07DB A7 00         mov bh, 0
0593   07DD D7            push a
0594   07DE 11            mov a, b
0595   07DF 26 30 00      mov b, '0'
0596   07E2 B0            cmp a, b
0597   07E3 0E            lodflgs
0598   07E4 87 03         and al, %00000011
0599   07E6 8F 02         xor al, %00000010 ; >=
0600   07E8 B9 00         cmp al, 0
0601   07EA 0E            lodflgs
0602   07EB 96            not al
0603   07EC 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0604   07EE 22 00         mov ah, 0
0605   07F0 27            mov b, a
0606   07F1 E4            pop a
0607   07F2 D7            push a
0608   07F3 11            mov a, b
0609   07F4 AF 00 00      cmp a, 0
0610   07F7 0E            lodflgs
0611   07F8 96            not al
0612   07F9 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
0613   07FB 34 05 00      mov bl, [bp + 5] ; c
0614   07FE A7 00         mov bh, 0
0615   0800 D7            push a
0616   0801 11            mov a, b
0617   0802 26 39 00      mov b, '9'
0618   0805 B0            cmp a, b
0619   0806 0E            lodflgs
0620   0807 87 03         and al, %00000011 ; <=
0621   0809 B9 00         cmp al, 0
0622   080B 0E            lodflgs
0623   080C 96            not al
0624   080D 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0625   080F 22 00         mov ah, 0
0626   0811 27            mov b, a
0627   0812 E4            pop a
0628   0813 DB            push al
0629   0814 C0 00 00      cmp b, 0
0630   0817 0E            lodflgs
0631   0818 96            not al
0632   0819 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
0633   081B EA            pop bl
0634   081C 88            and al, bl
0635   081D 2F            mov bl, al
0636   081E A7 00         mov bh, 0
0637   0820 E4            pop a
0638   0821 C0 00 00      cmp b, 0
0639   0824 C6 2F 08      je _if13_else
0640   0827             _if13_true:
0641   0827 26 01 00      mov b, 1
0642   082A F9            leave
0643   082B 09            ret
0644   082C 0A 34 08      jmp _if13_exit
0645   082F             _if13_else:
0646   082F 26 00 00      mov b, 0
0647   0832 F9            leave
0648   0833 09            ret
0649   0834             _if13_exit:
0650   0834             
0651   0834             _getchar:
0652   0834 D2            push bp
0653   0835 9B            mov bp, sp
0654   0836 52 01 00      sub sp, 1 ; c
0655   0839             
0656   0839             ; --- BEGIN INLINE ASM BLOCK
0657   0839 07 25 0B      call getchar
0658   083C 1A            mov al, ah
0659   083D 40 00 00      mov [bp + 0], al
0660   0840             ; --- END INLINE ASM BLOCK
0661   0840             
0662   0840 34 00 00      mov bl, [bp + 0] ; c
0663   0843 A7 00         mov bh, 0
0664   0845 F9            leave
0665   0846 09            ret
0666   0847             
0667   0847             scann:
0668   0847 D2            push bp
0669   0848 9B            mov bp, sp
0670   0849 52 02 00      sub sp, 2 ; m
0671   084C             
0672   084C             ; --- BEGIN INLINE ASM BLOCK
0673   084C 07 6B 0D      call scan_u16d
0674   084F 45 FF FF      mov [bp + -1], a
0675   0852             ; --- END INLINE ASM BLOCK
0676   0852             
0677   0852 FA 05 00      lea d, [bp + 5] ; n
0678   0855 2A            mov b, [d]
0679   0856 D8            push b
0680   0857 2C FF FF      mov b, [bp + -1] ; m
0681   085A E7            pop d
0682   085B 11            mov a, b
0683   085C 43            mov [d], a
0684   085D F9            leave
0685   085E 09            ret
0686   085F             
0687   085F             printn:
0688   085F D2            push bp
0689   0860 9B            mov bp, sp
0690   0861             
0691   0861             ; --- BEGIN INLINE ASM BLOCK
0692   0861 17 05 00      mov a, [bp + 5]
0693   0864 07 96 0C      call print_u16d
0694   0867             ; --- END INLINE ASM BLOCK
0695   0867             
0696   0867 F9            leave
0697   0868 09            ret
0698   0869             
0699   0869             print:
0700   0869 D2            push bp
0701   086A 9B            mov bp, sp
0702   086B             
0703   086B             ; --- BEGIN INLINE ASM BLOCK
0704   086B 17 05 00      mov a, [bp + 5]
0705   086E 3C            mov d, a
0706   086F 07 6D 0C      call puts
0707   0872             ; --- END INLINE ASM BLOCK
0708   0872             
0709   0872 F9            leave
0710   0873 09            ret
0711   0874             ; --- END TEXT BLOCK
0712   0874             
0713   0874             ; --- BEGIN DATA BLOCK
0714   0874 00 00       sp: .dw 0
0715   0876 00 00 00 00 val_data: .fill 200, 0
0715   087A 00 00 00 00 
0715   087E 00 00 00 00 
0715   0882 00 00 00 00 
0715   0886 00 00 00 00 
0715   088A 00 00 00 00 
0715   088E 00 00 00 00 
0715   0892 00 00 00 00 
0715   0896 00 00 00 00 
0715   089A 00 00 00 00 
0715   089E 00 00 00 00 
0715   08A2 00 00 00 00 
0715   08A6 00 00 00 00 
0715   08AA 00 00 00 00 
0715   08AE 00 00 00 00 
0715   08B2 00 00 00 00 
0715   08B6 00 00 00 00 
0715   08BA 00 00 00 00 
0715   08BE 00 00 00 00 
0715   08C2 00 00 00 00 
0715   08C6 00 00 00 00 
0715   08CA 00 00 00 00 
0715   08CE 00 00 00 00 
0715   08D2 00 00 00 00 
0715   08D6 00 00 00 00 
0715   08DA 00 00 00 00 
0715   08DE 00 00 00 00 
0715   08E2 00 00 00 00 
0715   08E6 00 00 00 00 
0715   08EA 00 00 00 00 
0715   08EE 00 00 00 00 
0715   08F2 00 00 00 00 
0715   08F6 00 00 00 00 
0715   08FA 00 00 00 00 
0715   08FE 00 00 00 00 
0715   0902 00 00 00 00 
0715   0906 00 00 00 00 
0715   090A 00 00 00 00 
0715   090E 00 00 00 00 
0715   0912 00 00 00 00 
0715   0916 00 00 00 00 
0715   091A 00 00 00 00 
0715   091E 00 00 00 00 
0715   0922 00 00 00 00 
0715   0926 00 00 00 00 
0715   092A 00 00 00 00 
0715   092E 00 00 00 00 
0715   0932 00 00 00 00 
0715   0936 00 00 00 00 
0715   093A 00 00 00 00 
0716   093E 76 08       val: .dw val_data
0717   0940 00 00 00 00 buf_data: .fill 100, 0
0717   0944 00 00 00 00 
0717   0948 00 00 00 00 
0717   094C 00 00 00 00 
0717   0950 00 00 00 00 
0717   0954 00 00 00 00 
0717   0958 00 00 00 00 
0717   095C 00 00 00 00 
0717   0960 00 00 00 00 
0717   0964 00 00 00 00 
0717   0968 00 00 00 00 
0717   096C 00 00 00 00 
0717   0970 00 00 00 00 
0717   0974 00 00 00 00 
0717   0978 00 00 00 00 
0717   097C 00 00 00 00 
0717   0980 00 00 00 00 
0717   0984 00 00 00 00 
0717   0988 00 00 00 00 
0717   098C 00 00 00 00 
0717   0990 00 00 00 00 
0717   0994 00 00 00 00 
0717   0998 00 00 00 00 
0717   099C 00 00 00 00 
0717   09A0 00 00 00 00 
0718   09A4 40 09       buf: .dw buf_data
0719   09A6 00 00       bufp: .dw 0
0720   09A8 44 69 76 69 _string_0: .db "Divide by zero error\n", 0
0720   09AC 64 65 20 62 
0720   09B0 79 20 7A 65 
0720   09B4 72 6F 20 65 
0720   09B8 72 72 6F 72 
0720   09BC 0A 00 
0721   09BE 0A 00       _string_1: .db "\n", 0
0722   09C0 55 6E 6B 6E _string_2: .db "Unknown input: ", 0
0722   09C4 6F 77 6E 20 
0722   09C8 69 6E 70 75 
0722   09CC 74 3A 20 00 
0723   09D0 45 72 72 6F _string_3: .db "Error: stack full, can't push: ", 0
0723   09D4 72 3A 20 73 
0723   09D8 74 61 63 6B 
0723   09DC 20 66 75 6C 
0723   09E0 6C 2C 20 63 
0723   09E4 61 6E 27 74 
0723   09E8 20 70 75 73 
0723   09EC 68 3A 20 
0724   09EF 45 72 72 6F _string_4: .db "Error: stack empty.\n", 0
0724   09F3 72 3A 20 73 
0724   09F7 74 61 63 6B 
0724   09FB 20 65 6D 70 
0724   09FF 74 79 2E 0A 
0724   0A03 00 
0725   0A04 45 72 72 6F _string_5: .db "Error: too many characters.\n", 0
0725   0A08 72 3A 20 74 
0725   0A0C 6F 6F 20 6D 
0725   0A10 61 6E 79 20 
0725   0A14 63 68 61 72 
0725   0A18 61 63 74 65 
0725   0A1C 72 73 2E 0A 
0725   0A20 00 
0726   0A21             ; --- END DATA BLOCK
0727   0A21             
0728   0A21             ; --- BEGIN INCLUDE BLOCK
0729   0A21             .include "lib/stdio.asm"
0001+  0A21             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0A21             ; stdio.s
0003+  0A21             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0A21             .include "lib/string.asm"
0001++ 0A21             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0A21             ; string.s
0003++ 0A21             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0A21             
0005++ 0A21             
0006++ 0A21             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0A21             ; strrev
0008++ 0A21             ; reverse a string
0009++ 0A21             ; D = string address
0010++ 0A21             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0A21             ; 01234
0012++ 0A21             strrev:
0013++ 0A21 4B          	pusha
0014++ 0A22 07 68 0A    	call strlen	; length in C
0015++ 0A25 12          	mov a, c
0016++ 0A26 AF 01 00    	cmp a, 1
0017++ 0A29 D0 43 0A    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0A2C 7D          	dec a
0019++ 0A2D FD 4E       	mov si, d	; beginning of string
0020++ 0A2F FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0A31 59          	add d, a	; end of string
0022++ 0A32 12          	mov a, c
0023++ 0A33 FD 9B       	shr a		; divide by 2
0024++ 0A35 39          	mov c, a	; C now counts the steps
0025++ 0A36             strrev_L0:
0026++ 0A36 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0A37 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0A38 3E          	mov [d], al	; store left char into right side
0029++ 0A39 1B          	mov al, bl
0030++ 0A3A F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0A3B 7E          	dec c
0032++ 0A3C 7F          	dec d
0033++ 0A3D C2 00 00    	cmp c, 0
0034++ 0A40 C7 36 0A    	jne strrev_L0
0035++ 0A43             strrev_end:
0036++ 0A43 4C          	popa
0037++ 0A44 09          	ret
0038++ 0A45             	
0039++ 0A45             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0A45             ; strchr
0041++ 0A45             ; search string in D for char in AL
0042++ 0A45             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0A45             strchr:
0044++ 0A45             strchr_L0:
0045++ 0A45 32          	mov bl, [d]
0046++ 0A46 C1 00       	cmp bl, 0
0047++ 0A48 C6 53 0A    	je strchr_end
0048++ 0A4B BA          	cmp al, bl
0049++ 0A4C C6 53 0A    	je strchr_end
0050++ 0A4F 79          	inc d
0051++ 0A50 0A 45 0A    	jmp strchr_L0
0052++ 0A53             strchr_end:
0053++ 0A53 1B          	mov al, bl
0054++ 0A54 09          	ret
0055++ 0A55             
0056++ 0A55             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0A55             ; strstr
0058++ 0A55             ; find sub-string
0059++ 0A55             ; str1 in SI
0060++ 0A55             ; str2 in DI
0061++ 0A55             ; SI points to end of source string
0062++ 0A55             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0A55             strstr:
0064++ 0A55 DB          	push al
0065++ 0A56 DA          	push d
0066++ 0A57 E3          	push di
0067++ 0A58             strstr_loop:
0068++ 0A58 F3          	cmpsb					; compare a byte of the strings
0069++ 0A59 C7 64 0A    	jne strstr_ret
0070++ 0A5C FC 00 00    	lea d, [di + 0]
0071++ 0A5F BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0A61 C7 58 0A    	jne strstr_loop				; equal chars but not at end
0073++ 0A64             strstr_ret:
0074++ 0A64 F0          	pop di
0075++ 0A65 E7          	pop d
0076++ 0A66 E8          	pop al
0077++ 0A67 09          	ret
0078++ 0A68             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0A68             ; length of null terminated string
0080++ 0A68             ; result in C
0081++ 0A68             ; pointer in D
0082++ 0A68             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0A68             strlen:
0084++ 0A68 DA          	push d
0085++ 0A69 38 00 00    	mov c, 0
0086++ 0A6C             strlen_L1:
0087++ 0A6C BD 00       	cmp byte [d], 0
0088++ 0A6E C6 76 0A    	je strlen_ret
0089++ 0A71 79          	inc d
0090++ 0A72 78          	inc c
0091++ 0A73 0A 6C 0A    	jmp strlen_L1
0092++ 0A76             strlen_ret:
0093++ 0A76 E7          	pop d
0094++ 0A77 09          	ret
0095++ 0A78             
0096++ 0A78             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0A78             ; STRCMP
0098++ 0A78             ; compare two strings
0099++ 0A78             ; str1 in SI
0100++ 0A78             ; str2 in DI
0101++ 0A78             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0A78             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0A78             strcmp:
0104++ 0A78 DB          	push al
0105++ 0A79 DA          	push d
0106++ 0A7A E3          	push di
0107++ 0A7B E2          	push si
0108++ 0A7C             strcmp_loop:
0109++ 0A7C F3          	cmpsb					; compare a byte of the strings
0110++ 0A7D C7 88 0A    	jne strcmp_ret
0111++ 0A80 FB FF FF    	lea d, [si +- 1]
0112++ 0A83 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0A85 C7 7C 0A    	jne strcmp_loop				; equal chars but not at end
0114++ 0A88             strcmp_ret:
0115++ 0A88 EF          	pop si
0116++ 0A89 F0          	pop di
0117++ 0A8A E7          	pop d
0118++ 0A8B E8          	pop al
0119++ 0A8C 09          	ret
0120++ 0A8D             
0121++ 0A8D             
0122++ 0A8D             ; STRCPY
0123++ 0A8D             ; copy null terminated string from SI to DI
0124++ 0A8D             ; source in SI
0125++ 0A8D             ; destination in DI
0126++ 0A8D             strcpy:
0127++ 0A8D E2          	push si
0128++ 0A8E E3          	push di
0129++ 0A8F DB          	push al
0130++ 0A90             strcpy_L1:
0131++ 0A90 F6          	lodsb
0132++ 0A91 F7          	stosb
0133++ 0A92 B9 00       	cmp al, 0
0134++ 0A94 C7 90 0A    	jne strcpy_L1
0135++ 0A97             strcpy_end:
0136++ 0A97 E8          	pop al
0137++ 0A98 F0          	pop di
0138++ 0A99 EF          	pop si
0139++ 0A9A 09          	ret
0140++ 0A9B             
0141++ 0A9B             ; STRCAT
0142++ 0A9B             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0A9B             ; source in SI
0144++ 0A9B             ; destination in DI
0145++ 0A9B             strcat:
0146++ 0A9B E2          	push si
0147++ 0A9C E3          	push di
0148++ 0A9D D7          	push a
0149++ 0A9E DA          	push d
0150++ 0A9F 50          	mov a, di
0151++ 0AA0 3C          	mov d, a
0152++ 0AA1             strcat_goto_end_L1:
0153++ 0AA1 BD 00       	cmp byte[d], 0
0154++ 0AA3 C6 AA 0A    	je strcat_start
0155++ 0AA6 79          	inc d
0156++ 0AA7 0A A1 0A    	jmp strcat_goto_end_L1
0157++ 0AAA             strcat_start:
0158++ 0AAA FD 50       	mov di, d
0159++ 0AAC             strcat_L1:
0160++ 0AAC F6          	lodsb
0161++ 0AAD F7          	stosb
0162++ 0AAE B9 00       	cmp al, 0
0163++ 0AB0 C7 AC 0A    	jne strcat_L1
0164++ 0AB3             strcat_end:
0165++ 0AB3 E7          	pop d
0166++ 0AB4 E4          	pop a
0167++ 0AB5 F0          	pop di
0168++ 0AB6 EF          	pop si
0169++ 0AB7 09          	ret
0005+  0AB8             
0006+  0AB8 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  0ABC 34 35 36 37 
0006+  0AC0 38 39 41 42 
0006+  0AC4 43 44 45 46 
0007+  0AC8 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  0ACC 1B 5B 48 00 
0008+  0AD0             
0009+  0AD0 01 00       table_power:.dw 1
0010+  0AD2 0A 00       			.dw 10
0011+  0AD4 64 00       			.dw 100
0012+  0AD6 E8 03       			.dw 1000
0013+  0AD8 10 27       			.dw 10000
0014+  0ADA             
0015+  0ADA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  0ADA             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  0ADA             ; ASCII in BL
0018+  0ADA             ; result in AL
0019+  0ADA             ; ascii for F = 0100 0110
0020+  0ADA             ; ascii for 9 = 0011 1001
0021+  0ADA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  0ADA             hex_ascii_encode:
0023+  0ADA 1B          	mov al, bl
0024+  0ADB 93 40       	test al, $40				; test if letter or number
0025+  0ADD C7 E3 0A    	jnz hex_letter
0026+  0AE0 87 0F       	and al, $0F				; get number
0027+  0AE2 09          	ret
0028+  0AE3             hex_letter:
0029+  0AE3 87 0F       	and al, $0F				; get letter
0030+  0AE5 6A 09       	add al, 9
0031+  0AE7 09          	ret
0032+  0AE8             
0033+  0AE8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  0AE8             ; ATOI
0035+  0AE8             ; 2 letter hex string in B
0036+  0AE8             ; 8bit integer returned in AL
0037+  0AE8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0AE8             atoi:
0039+  0AE8 D8          	push b
0040+  0AE9 07 DA 0A    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  0AEC 30          	mov bl, bh
0042+  0AED DB          	push al					; save a
0043+  0AEE 07 DA 0A    	call hex_ascii_encode
0044+  0AF1 EA          	pop bl	
0045+  0AF2 FD 9E 04    	shl al, 4
0046+  0AF5 8C          	or al, bl
0047+  0AF6 E5          	pop b
0048+  0AF7 09          	ret	
0049+  0AF8             
0050+  0AF8             
0051+  0AF8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  0AF8             ; printf
0053+  0AF8             ; no need for explanations!
0054+  0AF8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0AF8             printf:
0056+  0AF8 09          	ret
0057+  0AF9             
0058+  0AF9             
0059+  0AF9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  0AF9             ; scanf
0061+  0AF9             ; no need for explanations!
0062+  0AF9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  0AF9             scanf:
0064+  0AF9 09          	ret
0065+  0AFA             
0066+  0AFA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  0AFA             ; ITOA
0068+  0AFA             ; 8bit value in BL
0069+  0AFA             ; 2 byte ASCII result in A
0070+  0AFA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  0AFA             itoa:
0072+  0AFA DA          	push d
0073+  0AFB D8          	push b
0074+  0AFC A7 00       	mov bh, 0
0075+  0AFE FD A4 04    	shr bl, 4	
0076+  0B01 74          	mov d, b
0077+  0B02 1F B8 0A    	mov al, [d + s_hex_digits]
0078+  0B05 23          	mov ah, al
0079+  0B06             	
0080+  0B06 E5          	pop b
0081+  0B07 D8          	push b
0082+  0B08 A7 00       	mov bh, 0
0083+  0B0A FD 87 0F    	and bl, $0F
0084+  0B0D 74          	mov d, b
0085+  0B0E 1F B8 0A    	mov al, [d + s_hex_digits]
0086+  0B11 E5          	pop b
0087+  0B12 E7          	pop d
0088+  0B13 09          	ret
0089+  0B14             
0090+  0B14             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  0B14             ; HEX STRING TO BINARY
0092+  0B14             ; di = destination address
0093+  0B14             ; si = source
0094+  0B14             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  0B14             hex_to_int:
0096+  0B14             hex_to_int_L1:
0097+  0B14 F6          	lodsb					; load from [SI] to AL
0098+  0B15 B9 00       	cmp al, 0				; check if ASCII 0
0099+  0B17 C6 24 0B    	jz hex_to_int_ret
0100+  0B1A 36          	mov bh, al
0101+  0B1B F6          	lodsb
0102+  0B1C 2F          	mov bl, al
0103+  0B1D 07 E8 0A    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  0B20 F7          	stosb					; store AL to [DI]
0105+  0B21 0A 14 0B    	jmp hex_to_int_L1
0106+  0B24             hex_to_int_ret:
0107+  0B24 09          	ret		
0108+  0B25             
0109+  0B25             
0110+  0B25             
0111+  0B25             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  0B25             ; GETCHAR
0113+  0B25             ; char in ah
0114+  0B25             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  0B25             getchar:
0116+  0B25 DB          	push al
0117+  0B26             getchar_retry:
0118+  0B26 FD 0C       	sti
0119+  0B28 19 01       	mov al, 1
0120+  0B2A 05 03       	syscall sys_io			; receive in AH
0121+  0B2C B9 00       	cmp al, 0			; check if any char was receive
0122+  0B2E C6 26 0B    	je getchar_retry
0123+  0B31 E8          	pop al
0124+  0B32 09          	ret
0125+  0B33             
0126+  0B33             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  0B33             ; PUTCHAR
0128+  0B33             ; char in ah
0129+  0B33             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0B33             putchar:
0131+  0B33 D7          	push a
0132+  0B34 19 00       	mov al, 0
0133+  0B36 05 03       	syscall sys_io			; char in AH
0134+  0B38 E4          	pop a
0135+  0B39 09          	ret
0136+  0B3A             
0137+  0B3A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  0B3A             ;; INPUT A STRING
0139+  0B3A             ;; terminates with null
0140+  0B3A             ;; pointer in D
0141+  0B3A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  0B3A             gets:
0143+  0B3A D7          	push a
0144+  0B3B DA          	push d
0145+  0B3C             gets_loop:
0146+  0B3C FD 0C       	sti
0147+  0B3E 19 01       	mov al, 1
0148+  0B40 05 03       	syscall sys_io			; receive in AH
0149+  0B42 B9 00       	cmp al, 0				; check error code (AL)
0150+  0B44 C6 3C 0B    	je gets_loop			; if no char received, retry
0151+  0B47             
0152+  0B47 76 1B       	cmp ah, 27
0153+  0B49 C6 6A 0B    	je gets_telnet_escape
0154+  0B4C 76 0A       	cmp ah, $0A				; LF
0155+  0B4E C6 C3 0B    	je gets_end
0156+  0B51 76 0D       	cmp ah, $0D				; CR
0157+  0B53 C6 C3 0B    	je gets_end
0158+  0B56 76 5C       	cmp ah, $5C				; '\\'
0159+  0B58 C6 9A 0B    	je gets_escape
0160+  0B5B             	
0161+  0B5B 76 08       	cmp ah, $08			; check for backspace
0162+  0B5D C6 66 0B    	je gets_backspace
0163+  0B60             
0164+  0B60 1A          	mov al, ah
0165+  0B61 3E          	mov [d], al
0166+  0B62 79          	inc d
0167+  0B63 0A 3C 0B    	jmp gets_loop
0168+  0B66             gets_backspace:
0169+  0B66 7F          	dec d
0170+  0B67 0A 3C 0B    	jmp gets_loop
0171+  0B6A             gets_telnet_escape:
0172+  0B6A FD 0C       	sti
0173+  0B6C 19 01       	mov al, 1
0174+  0B6E 05 03       	syscall sys_io				; receive in AH without echo
0175+  0B70 B9 00       	cmp al, 0					; check error code (AL)
0176+  0B72 C6 6A 0B    	je gets_telnet_escape		; if no char received, retry
0177+  0B75 76 5B       	cmp ah, '['
0178+  0B77 C7 3C 0B    	jne gets_loop
0179+  0B7A             gets_telnet_escape_phase2:
0180+  0B7A FD 0C       	sti
0181+  0B7C 19 01       	mov al, 1
0182+  0B7E 05 03       	syscall sys_io					; receive in AH without echo
0183+  0B80 B9 00       	cmp al, 0						; check error code (AL)
0184+  0B82 C6 7A 0B    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  0B85 76 44       	cmp ah, 'D'
0186+  0B87 C6 92 0B    	je gets_left_arrow
0187+  0B8A 76 43       	cmp ah, 'C'
0188+  0B8C C6 96 0B    	je gets_right_arrow
0189+  0B8F 0A 3C 0B    	jmp gets_loop
0190+  0B92             gets_left_arrow:
0191+  0B92 7F          	dec d
0192+  0B93 0A 3C 0B    	jmp gets_loop
0193+  0B96             gets_right_arrow:
0194+  0B96 79          	inc d
0195+  0B97 0A 3C 0B    	jmp gets_loop
0196+  0B9A             gets_escape:
0197+  0B9A FD 0C       	sti
0198+  0B9C 19 01       	mov al, 1
0199+  0B9E 05 03       	syscall sys_io			; receive in AH
0200+  0BA0 B9 00       	cmp al, 0				; check error code (AL)
0201+  0BA2 C6 9A 0B    	je gets_escape			; if no char received, retry
0202+  0BA5 76 6E       	cmp ah, 'n'
0203+  0BA7 C6 B5 0B    	je gets_LF
0204+  0BAA 76 72       	cmp ah, 'r'
0205+  0BAC C6 BC 0B    	je gets_CR
0206+  0BAF 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  0BB0 3E          	mov [d], al
0208+  0BB1 79          	inc d
0209+  0BB2 0A 3C 0B    	jmp gets_loop
0210+  0BB5             gets_LF:
0211+  0BB5 19 0A       	mov al, $0A
0212+  0BB7 3E          	mov [d], al
0213+  0BB8 79          	inc d
0214+  0BB9 0A 3C 0B    	jmp gets_loop
0215+  0BBC             gets_CR:
0216+  0BBC 19 0D       	mov al, $0D
0217+  0BBE 3E          	mov [d], al
0218+  0BBF 79          	inc d
0219+  0BC0 0A 3C 0B    	jmp gets_loop
0220+  0BC3             gets_end:
0221+  0BC3 19 00       	mov al, 0
0222+  0BC5 3E          	mov [d], al				; terminate string
0223+  0BC6 E7          	pop d
0224+  0BC7 E4          	pop a
0225+  0BC8 09          	ret
0226+  0BC9             
0227+  0BC9             
0228+  0BC9             
0229+  0BC9             
0230+  0BC9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  0BC9             ;; INPUT TEXT
0232+  0BC9             ;; terminated with CTRL+D
0233+  0BC9             ;; pointer in D
0234+  0BC9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  0BC9             gettxt:
0236+  0BC9 D7          	push a
0237+  0BCA DA          	push d
0238+  0BCB             gettxt_loop:
0239+  0BCB 19 01       	mov al, 1
0240+  0BCD 05 03       	syscall sys_io			; receive in AH
0241+  0BCF B9 00       	cmp al, 0				; check error code (AL)
0242+  0BD1 C6 CB 0B    	je gettxt_loop		; if no char received, retry
0243+  0BD4 76 04       	cmp ah, 4			; EOT
0244+  0BD6 C6 14 0C    	je gettxt_end
0245+  0BD9 76 08       	cmp ah, $08			; check for backspace
0246+  0BDB C6 10 0C    	je gettxt_backspace
0247+  0BDE 76 5C       	cmp ah, $5C				; '\\'
0248+  0BE0 C6 E9 0B    	je gettxt_escape
0249+  0BE3 1A          	mov al, ah
0250+  0BE4 3E          	mov [d], al
0251+  0BE5 79          	inc d
0252+  0BE6 0A CB 0B    	jmp gettxt_loop
0253+  0BE9             gettxt_escape:
0254+  0BE9 19 01       	mov al, 1
0255+  0BEB 05 03       	syscall sys_io			; receive in AH
0256+  0BED B9 00       	cmp al, 0				; check error code (AL)
0257+  0BEF C6 E9 0B    	je gettxt_escape		; if no char received, retry
0258+  0BF2 76 6E       	cmp ah, 'n'
0259+  0BF4 C6 02 0C    	je gettxt_LF
0260+  0BF7 76 72       	cmp ah, 'r'
0261+  0BF9 C6 09 0C    	je gettxt_CR
0262+  0BFC 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  0BFD 3E          	mov [d], al
0264+  0BFE 79          	inc d
0265+  0BFF 0A CB 0B    	jmp gettxt_loop
0266+  0C02             gettxt_LF:
0267+  0C02 19 0A       	mov al, $0A
0268+  0C04 3E          	mov [d], al
0269+  0C05 79          	inc d
0270+  0C06 0A CB 0B    	jmp gettxt_loop
0271+  0C09             gettxt_CR:
0272+  0C09 19 0D       	mov al, $0D
0273+  0C0B 3E          	mov [d], al
0274+  0C0C 79          	inc d
0275+  0C0D 0A CB 0B    	jmp gettxt_loop
0276+  0C10             gettxt_backspace:
0277+  0C10 7F          	dec d
0278+  0C11 0A CB 0B    	jmp gettxt_loop
0279+  0C14             gettxt_end:
0280+  0C14 19 00       	mov al, 0
0281+  0C16 3E          	mov [d], al				; terminate string
0282+  0C17 E7          	pop d
0283+  0C18 E4          	pop a
0284+  0C19 09          	ret
0285+  0C1A             
0286+  0C1A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  0C1A             ; PRINT NEW LINE
0288+  0C1A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  0C1A             printnl:
0290+  0C1A D7          	push a
0291+  0C1B 10 00 0A    	mov a, $0A00
0292+  0C1E 05 03       	syscall sys_io
0293+  0C20 10 00 0D    	mov a, $0D00
0294+  0C23 05 03       	syscall sys_io
0295+  0C25 E4          	pop a
0296+  0C26 09          	ret
0297+  0C27             
0298+  0C27             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  0C27             ; strtoint
0300+  0C27             ; 4 digit hex string number in d
0301+  0C27             ; integer returned in A
0302+  0C27             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  0C27             strtointx:
0304+  0C27 D8          	push b
0305+  0C28 32          	mov bl, [d]
0306+  0C29 37          	mov bh, bl
0307+  0C2A 33 01 00    	mov bl, [d + 1]
0308+  0C2D 07 E8 0A    	call atoi				; convert to int in AL
0309+  0C30 23          	mov ah, al				; move to AH
0310+  0C31 33 02 00    	mov bl, [d + 2]
0311+  0C34 37          	mov bh, bl
0312+  0C35 33 03 00    	mov bl, [d + 3]
0313+  0C38 07 E8 0A    	call atoi				; convert to int in AL
0314+  0C3B E5          	pop b
0315+  0C3C 09          	ret
0316+  0C3D             
0317+  0C3D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  0C3D             ; strtoint
0319+  0C3D             ; 5 digit base10 string number in d
0320+  0C3D             ; integer returned in A
0321+  0C3D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  0C3D             strtoint:
0323+  0C3D E2          	push si
0324+  0C3E D8          	push b
0325+  0C3F D9          	push c
0326+  0C40 DA          	push d
0327+  0C41 07 68 0A    	call strlen			; get string length in C
0328+  0C44 7E          	dec c
0329+  0C45 FD 4E       	mov si, d
0330+  0C47 12          	mov a, c
0331+  0C48 FD 99       	shl a
0332+  0C4A 3B D0 0A    	mov d, table_power
0333+  0C4D 59          	add d, a
0334+  0C4E 38 00 00    	mov c, 0
0335+  0C51             strtoint_L0:
0336+  0C51 F6          	lodsb			; load ASCII to al
0337+  0C52 B9 00       	cmp al, 0
0338+  0C54 C6 67 0C    	je strtoint_end
0339+  0C57 6F 30       	sub al, $30		; make into integer
0340+  0C59 22 00       	mov ah, 0
0341+  0C5B 2A          	mov b, [d]
0342+  0C5C AC          	mul a, b			; result in B since it fits in 16bits
0343+  0C5D 11          	mov a, b
0344+  0C5E 28          	mov b, c
0345+  0C5F 54          	add a, b
0346+  0C60 39          	mov c, a
0347+  0C61 63 02 00    	sub d, 2
0348+  0C64 0A 51 0C    	jmp strtoint_L0
0349+  0C67             strtoint_end:
0350+  0C67 12          	mov a, c
0351+  0C68 E7          	pop d
0352+  0C69 E6          	pop c
0353+  0C6A E5          	pop b
0354+  0C6B EF          	pop si
0355+  0C6C 09          	ret
0356+  0C6D             
0357+  0C6D             
0358+  0C6D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  0C6D             ; PRINT NULL TERMINATED STRING
0360+  0C6D             ; pointer in D
0361+  0C6D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  0C6D             puts:
0363+  0C6D D7          	push a
0364+  0C6E DA          	push d
0365+  0C6F             puts_L1:
0366+  0C6F 1E          	mov al, [d]
0367+  0C70 B9 00       	cmp al, 0
0368+  0C72 C6 7E 0C    	jz puts_END
0369+  0C75 23          	mov ah, al
0370+  0C76 19 00       	mov al, 0
0371+  0C78 05 03       	syscall sys_io
0372+  0C7A 79          	inc d
0373+  0C7B 0A 6F 0C    	jmp puts_L1
0374+  0C7E             puts_END:
0375+  0C7E E7          	pop d
0376+  0C7F E4          	pop a
0377+  0C80 09          	ret
0378+  0C81             
0379+  0C81             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  0C81             ; PRINT N SIZE STRING
0381+  0C81             ; pointer in D
0382+  0C81             ; size in C
0383+  0C81             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  0C81             putsn:
0385+  0C81 DB          	push al
0386+  0C82 DA          	push d
0387+  0C83 D9          	push c
0388+  0C84             putsn_L0:
0389+  0C84 1E          	mov al, [d]
0390+  0C85 23          	mov ah, al
0391+  0C86 19 00       	mov al, 0
0392+  0C88 05 03       	syscall sys_io
0393+  0C8A 79          	inc d
0394+  0C8B 7E          	dec c	
0395+  0C8C C2 00 00    	cmp c, 0
0396+  0C8F C7 84 0C    	jne putsn_L0
0397+  0C92             putsn_end:
0398+  0C92 E6          	pop c
0399+  0C93 E7          	pop d
0400+  0C94 E8          	pop al
0401+  0C95 09          	ret
0402+  0C96             
0403+  0C96             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  0C96             ; print 16bit decimal number
0405+  0C96             ; input number in A
0406+  0C96             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  0C96             print_u16d:
0408+  0C96 D7          	push a
0409+  0C97 D8          	push b
0410+  0C98 26 10 27    	mov b, 10000
0411+  0C9B AE          	div a, b			; get 10000 coeff.
0412+  0C9C 07 C2 0C    	call print_number
0413+  0C9F 11          	mov a, b
0414+  0CA0 26 E8 03    	mov b, 1000
0415+  0CA3 AE          	div a, b			; get 10000 coeff.
0416+  0CA4 07 C2 0C    	call print_number
0417+  0CA7 11          	mov a, b
0418+  0CA8 26 64 00    	mov b, 100
0419+  0CAB AE          	div a, b
0420+  0CAC 07 C2 0C    	call print_number
0421+  0CAF 11          	mov a, b
0422+  0CB0 26 0A 00    	mov b, 10
0423+  0CB3 AE          	div a, b
0424+  0CB4 07 C2 0C    	call print_number
0425+  0CB7 11          	mov a, b
0426+  0CB8 6A 30       	add al, $30
0427+  0CBA 23          	mov ah, al
0428+  0CBB 19 00       	mov al, 0
0429+  0CBD 05 03       	syscall sys_io	; print coeff
0430+  0CBF E5          	pop b
0431+  0CC0 E4          	pop a
0432+  0CC1 09          	ret
0433+  0CC2             
0434+  0CC2             
0435+  0CC2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  0CC2             ; if A == 0, print space
0437+  0CC2             ; else print A
0438+  0CC2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0439+  0CC2             print_number:
0440+  0CC2 6A 30       	add al, $30
0441+  0CC4 23          	mov ah, al
0442+  0CC5 07 33 0B    	call putchar
0443+  0CC8 09          	ret
0444+  0CC9             
0445+  0CC9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0446+  0CC9             ; PRINT 16BIT HEX INTEGER
0447+  0CC9             ; integer value in reg B
0448+  0CC9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  0CC9             print_u16x:
0450+  0CC9 D7          	push a
0451+  0CCA D8          	push b
0452+  0CCB DD          	push bl
0453+  0CCC 30          	mov bl, bh
0454+  0CCD 07 FA 0A    	call itoa				; convert bh to char in A
0455+  0CD0 2F          	mov bl, al				; save al
0456+  0CD1 19 00       	mov al, 0
0457+  0CD3 05 03       	syscall sys_io				; display AH
0458+  0CD5 24          	mov ah, bl				; retrieve al
0459+  0CD6 19 00       	mov al, 0
0460+  0CD8 05 03       	syscall sys_io				; display AL
0461+  0CDA             
0462+  0CDA EA          	pop bl
0463+  0CDB 07 FA 0A    	call itoa				; convert bh to char in A
0464+  0CDE 2F          	mov bl, al				; save al
0465+  0CDF 19 00       	mov al, 0
0466+  0CE1 05 03       	syscall sys_io				; display AH
0467+  0CE3 24          	mov ah, bl				; retrieve al
0468+  0CE4 19 00       	mov al, 0
0469+  0CE6 05 03       	syscall sys_io				; display AL
0470+  0CE8             
0471+  0CE8 E5          	pop b
0472+  0CE9 E4          	pop a
0473+  0CEA 09          	ret
0474+  0CEB             
0475+  0CEB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  0CEB             ; INPUT 16BIT HEX INTEGER
0477+  0CEB             ; read 16bit integer into A
0478+  0CEB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  0CEB             scan_u16x:
0480+  0CEB F8 10 00    	enter 16
0481+  0CEE D8          	push b
0482+  0CEF DA          	push d
0483+  0CF0             
0484+  0CF0 FA F1 FF    	lea d, [bp + -15]
0485+  0CF3 07 3A 0B    	call gets				; get number
0486+  0CF6             
0487+  0CF6 32          	mov bl, [d]
0488+  0CF7 37          	mov bh, bl
0489+  0CF8 33 01 00    	mov bl, [d + 1]
0490+  0CFB 07 E8 0A    	call atoi				; convert to int in AL
0491+  0CFE 23          	mov ah, al				; move to AH
0492+  0CFF             
0493+  0CFF 33 02 00    	mov bl, [d + 2]
0494+  0D02 37          	mov bh, bl
0495+  0D03 33 03 00    	mov bl, [d + 3]
0496+  0D06 07 E8 0A    	call atoi				; convert to int in AL
0497+  0D09             
0498+  0D09 E7          	pop d
0499+  0D0A E5          	pop b
0500+  0D0B F9          	leave
0501+  0D0C 09          	ret
0502+  0D0D             
0503+  0D0D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0504+  0D0D             ; PRINT 8bit HEX INTEGER
0505+  0D0D             ; integer value in reg bl
0506+  0D0D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  0D0D             print_u8x:
0508+  0D0D D7          	push a
0509+  0D0E DD          	push bl
0510+  0D0F             
0511+  0D0F 07 FA 0A    	call itoa				; convert bl to char in A
0512+  0D12 2F          	mov bl, al				; save al
0513+  0D13 19 00       	mov al, 0
0514+  0D15 05 03       	syscall sys_io				; display AH
0515+  0D17 24          	mov ah, bl				; retrieve al
0516+  0D18 19 00       	mov al, 0
0517+  0D1A 05 03       	syscall sys_io				; display AL
0518+  0D1C             
0519+  0D1C EA          	pop bl
0520+  0D1D E4          	pop a
0521+  0D1E 09          	ret
0522+  0D1F             
0523+  0D1F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0524+  0D1F             ; print 8bit decimal unsigned number
0525+  0D1F             ; input number in AL
0526+  0D1F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  0D1F             print_u8d:
0528+  0D1F D7          	push a
0529+  0D20 D8          	push b
0530+  0D21             
0531+  0D21 22 00       	mov ah, 0
0532+  0D23 26 64 00    	mov b, 100
0533+  0D26 AE          	div a, b
0534+  0D27 D8          	push b			; save remainder
0535+  0D28 B9 00       	cmp al, 0
0536+  0D2A C6 34 0D    	je skip100
0537+  0D2D 6A 30       	add al, $30
0538+  0D2F 23          	mov ah, al
0539+  0D30 19 00       	mov al, 0
0540+  0D32 05 03       	syscall sys_io	; print coeff
0541+  0D34             skip100:
0542+  0D34 E4          	pop a
0543+  0D35 22 00       	mov ah, 0
0544+  0D37 26 0A 00    	mov b, 10
0545+  0D3A AE          	div a, b
0546+  0D3B D8          	push b			; save remainder
0547+  0D3C B9 00       	cmp al, 0
0548+  0D3E C6 48 0D    	je skip10
0549+  0D41 6A 30       	add al, $30
0550+  0D43 23          	mov ah, al
0551+  0D44 19 00       	mov al, 0
0552+  0D46 05 03       	syscall sys_io	; print coeff
0553+  0D48             skip10:
0554+  0D48 E4          	pop a
0555+  0D49 1B          	mov al, bl
0556+  0D4A 6A 30       	add al, $30
0557+  0D4C 23          	mov ah, al
0558+  0D4D 19 00       	mov al, 0
0559+  0D4F 05 03       	syscall sys_io	; print coeff
0560+  0D51 E5          	pop b
0561+  0D52 E4          	pop a
0562+  0D53 09          	ret
0563+  0D54             
0564+  0D54             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0565+  0D54             ; INPUT 8BIT HEX INTEGER
0566+  0D54             ; read 8bit integer into AL
0567+  0D54             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  0D54             scan_u8x:
0569+  0D54 F8 04 00    	enter 4
0570+  0D57 D8          	push b
0571+  0D58 DA          	push d
0572+  0D59             
0573+  0D59 FA FD FF    	lea d, [bp + -3]
0574+  0D5C 07 3A 0B    	call gets				; get number
0575+  0D5F             
0576+  0D5F 32          	mov bl, [d]
0577+  0D60 37          	mov bh, bl
0578+  0D61 33 01 00    	mov bl, [d + 1]
0579+  0D64 07 E8 0A    	call atoi				; convert to int in AL
0580+  0D67             
0581+  0D67 E7          	pop d
0582+  0D68 E5          	pop b
0583+  0D69 F9          	leave
0584+  0D6A 09          	ret
0585+  0D6B             
0586+  0D6B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  0D6B             ; input decimal number
0588+  0D6B             ; result in A
0589+  0D6B             ; 655'\0'
0590+  0D6B             ; low--------high
0591+  0D6B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0592+  0D6B             scan_u16d:
0593+  0D6B F8 08 00    	enter 8
0594+  0D6E E2          	push si
0595+  0D6F D8          	push b
0596+  0D70 D9          	push c
0597+  0D71 DA          	push d
0598+  0D72 FA F9 FF    	lea d, [bp +- 7]
0599+  0D75 07 3A 0B    	call gets
0600+  0D78 07 68 0A    	call strlen			; get string length in C
0601+  0D7B 7E          	dec c
0602+  0D7C FD 4E       	mov si, d
0603+  0D7E 12          	mov a, c
0604+  0D7F FD 99       	shl a
0605+  0D81 3B D0 0A    	mov d, table_power
0606+  0D84 59          	add d, a
0607+  0D85 38 00 00    	mov c, 0
0608+  0D88             mul_loop:
0609+  0D88 F6          	lodsb			; load ASCII to al
0610+  0D89 B9 00       	cmp al, 0
0611+  0D8B C6 9E 0D    	je mul_exit
0612+  0D8E 6F 30       	sub al, $30		; make into integer
0613+  0D90 22 00       	mov ah, 0
0614+  0D92 2A          	mov b, [d]
0615+  0D93 AC          	mul a, b			; result in B since it fits in 16bits
0616+  0D94 11          	mov a, b
0617+  0D95 28          	mov b, c
0618+  0D96 54          	add a, b
0619+  0D97 39          	mov c, a
0620+  0D98 63 02 00    	sub d, 2
0621+  0D9B 0A 88 0D    	jmp mul_loop
0622+  0D9E             mul_exit:
0623+  0D9E 12          	mov a, c
0624+  0D9F E7          	pop d
0625+  0DA0 E6          	pop c
0626+  0DA1 E5          	pop b
0627+  0DA2 EF          	pop si
0628+  0DA3 F9          	leave
0629+  0DA4 09          	ret
0730   0DA5             ; --- END INCLUDE BLOCK
0731   0DA5             
0732   0DA5             
0733   0DA5             .end
tasm: Number of errors = 0
