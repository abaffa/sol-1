0001   0000             ; --- FILENAME: auto2.c
0002   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0400             .org PROC_TEXT_ORG
0004   0400             
0005   0400             ; --- BEGIN TEXT BLOCK
0006   0400             main:
0007   0400 D2            push bp
0008   0401 9B            mov bp, sp
0009   0402 52 02 00      sub sp, 2 ; i
0010   0405 52 02 00      sub sp, 2 ; j
0011   0408 29 FB 05      mov b, [state]
0012   040B 74            mov d, b
0013   040C 26 14 00      mov b, 20
0014   040F D7            push a
0015   0410 11            mov a, b
0016   0411 26 02 00      mov b, 2
0017   0414 AE            div a, b
0018   0415 FD 78         mov g, a
0019   0417 11            mov a, b
0020   0418 FD 27         mov b, g
0021   041A E4            pop a
0022   041B 10 02 00      mov a, 2
0023   041E AC            mul a, b
0024   041F 5A            add d, b
0025   0420 DA            push d
0026   0421 26 01 00      mov b, 1
0027   0424 E7            pop d
0028   0425 11            mov a, b
0029   0426 43            mov [d], a
0030   0427             _for1_init:
0031   0427 26 00 00      mov b, 0
0032   042A D7            push a
0033   042B 11            mov a, b
0034   042C 45 FF FF      mov [bp + -1], a ; i
0035   042F E4            pop a
0036   0430             _for1_cond:
0037   0430 2C FF FF      mov b, [bp + -1] ; i
0038   0433 D7            push a
0039   0434 11            mov a, b
0040   0435 26 14 00      mov b, 20
0041   0438 B0            cmp a, b
0042   0439 0E            lodflgs
0043   043A 87 02         and al, %00000010
0044   043C 22 00         mov ah, 0
0045   043E 27            mov b, a
0046   043F E4            pop a
0047   0440 C0 00 00      cmp b, 0
0048   0443 C6 6A 04      je _for1_exit
0049   0446             _for1_block:
0050   0446 29 FB 05      mov b, [state]
0051   0449 74            mov d, b
0052   044A 2C FF FF      mov b, [bp + -1] ; i
0053   044D 10 02 00      mov a, 2
0054   0450 AC            mul a, b
0055   0451 5A            add d, b
0056   0452 2A            mov b, [d]
0057   0453 FD AB         swp b
0058   0455 D8            push b
0059   0456 07 C9 05      call printn
0060   0459 51 02 00      add sp, 2
0061   045C             _for1_update:
0062   045C 2C FF FF      mov b, [bp + -1] ; i
0063   045F FD 77         inc b
0064   0461 D7            push a
0065   0462 11            mov a, b
0066   0463 45 FF FF      mov [bp + -1], a ; i
0067   0466 E4            pop a
0068   0467 0A 30 04      jmp _for1_cond
0069   046A             _for1_exit:
0070   046A 26 27 06      mov b, _string_0
0071   046D FD AB         swp b
0072   046F D8            push b
0073   0470 07 BE 05      call print
0074   0473 51 02 00      add sp, 2
0075   0476             _for2_init:
0076   0476 26 01 00      mov b, 1
0077   0479 D7            push a
0078   047A 11            mov a, b
0079   047B 45 FD FF      mov [bp + -3], a ; j
0080   047E E4            pop a
0081   047F             _for2_cond:
0082   047F 2C FD FF      mov b, [bp + -3] ; j
0083   0482 D7            push a
0084   0483 11            mov a, b
0085   0484 26 14 00      mov b, 20
0086   0487 B0            cmp a, b
0087   0488 0E            lodflgs
0088   0489 87 02         and al, %00000010
0089   048B 22 00         mov ah, 0
0090   048D 27            mov b, a
0091   048E E4            pop a
0092   048F C0 00 00      cmp b, 0
0093   0492 C6 B8 05      je _for2_exit
0094   0495             _for2_block:
0095   0495             _for3_init:
0096   0495 26 01 00      mov b, 1
0097   0498 D7            push a
0098   0499 11            mov a, b
0099   049A 45 FF FF      mov [bp + -1], a ; i
0100   049D E4            pop a
0101   049E             _for3_cond:
0102   049E 2C FF FF      mov b, [bp + -1] ; i
0103   04A1 D7            push a
0104   04A2 11            mov a, b
0105   04A3 26 14 00      mov b, 20
0106   04A6 D7            push a
0107   04A7 11            mov a, b
0108   04A8 26 01 00      mov b, 1
0109   04AB 60            sub a, b
0110   04AC 27            mov b, a
0111   04AD E4            pop a
0112   04AE B0            cmp a, b
0113   04AF 0E            lodflgs
0114   04B0 87 02         and al, %00000010
0115   04B2 22 00         mov ah, 0
0116   04B4 27            mov b, a
0117   04B5 E4            pop a
0118   04B6 C0 00 00      cmp b, 0
0119   04B9 C6 09 05      je _for3_exit
0120   04BC             _for3_block:
0121   04BC 29 25 06      mov b, [next_state]
0122   04BF 74            mov d, b
0123   04C0 2C FF FF      mov b, [bp + -1] ; i
0124   04C3 10 02 00      mov a, 2
0125   04C6 AC            mul a, b
0126   04C7 5A            add d, b
0127   04C8 DA            push d
0128   04C9 29 FB 05      mov b, [state]
0129   04CC 74            mov d, b
0130   04CD 2C FF FF      mov b, [bp + -1] ; i
0131   04D0 D7            push a
0132   04D1 11            mov a, b
0133   04D2 26 01 00      mov b, 1
0134   04D5 60            sub a, b
0135   04D6 27            mov b, a
0136   04D7 E4            pop a
0137   04D8 10 02 00      mov a, 2
0138   04DB AC            mul a, b
0139   04DC 5A            add d, b
0140   04DD 2A            mov b, [d]
0141   04DE D7            push a
0142   04DF 11            mov a, b
0143   04E0 29 FB 05      mov b, [state]
0144   04E3 74            mov d, b
0145   04E4 2C FF FF      mov b, [bp + -1] ; i
0146   04E7 D7            push a
0147   04E8 11            mov a, b
0148   04E9 26 01 00      mov b, 1
0149   04EC 54            add a, b
0150   04ED 27            mov b, a
0151   04EE E4            pop a
0152   04EF 10 02 00      mov a, 2
0153   04F2 AC            mul a, b
0154   04F3 5A            add d, b
0155   04F4 2A            mov b, [d]
0156   04F5 8E            xor a, b
0157   04F6 27            mov b, a
0158   04F7 E4            pop a
0159   04F8 E7            pop d
0160   04F9 11            mov a, b
0161   04FA 43            mov [d], a
0162   04FB             _for3_update:
0163   04FB 2C FF FF      mov b, [bp + -1] ; i
0164   04FE FD 77         inc b
0165   0500 D7            push a
0166   0501 11            mov a, b
0167   0502 45 FF FF      mov [bp + -1], a ; i
0168   0505 E4            pop a
0169   0506 0A 9E 04      jmp _for3_cond
0170   0509             _for3_exit:
0171   0509             _for4_init:
0172   0509 26 01 00      mov b, 1
0173   050C D7            push a
0174   050D 11            mov a, b
0175   050E 45 FF FF      mov [bp + -1], a ; i
0176   0511 E4            pop a
0177   0512             _for4_cond:
0178   0512 2C FF FF      mov b, [bp + -1] ; i
0179   0515 D7            push a
0180   0516 11            mov a, b
0181   0517 26 14 00      mov b, 20
0182   051A D7            push a
0183   051B 11            mov a, b
0184   051C 26 01 00      mov b, 1
0185   051F 60            sub a, b
0186   0520 27            mov b, a
0187   0521 E4            pop a
0188   0522 B0            cmp a, b
0189   0523 0E            lodflgs
0190   0524 87 02         and al, %00000010
0191   0526 22 00         mov ah, 0
0192   0528 27            mov b, a
0193   0529 E4            pop a
0194   052A C0 00 00      cmp b, 0
0195   052D C6 5B 05      je _for4_exit
0196   0530             _for4_block:
0197   0530 29 FB 05      mov b, [state]
0198   0533 74            mov d, b
0199   0534 2C FF FF      mov b, [bp + -1] ; i
0200   0537 10 02 00      mov a, 2
0201   053A AC            mul a, b
0202   053B 5A            add d, b
0203   053C DA            push d
0204   053D 29 25 06      mov b, [next_state]
0205   0540 74            mov d, b
0206   0541 2C FF FF      mov b, [bp + -1] ; i
0207   0544 10 02 00      mov a, 2
0208   0547 AC            mul a, b
0209   0548 5A            add d, b
0210   0549 2A            mov b, [d]
0211   054A E7            pop d
0212   054B 11            mov a, b
0213   054C 43            mov [d], a
0214   054D             _for4_update:
0215   054D 2C FF FF      mov b, [bp + -1] ; i
0216   0550 FD 77         inc b
0217   0552 D7            push a
0218   0553 11            mov a, b
0219   0554 45 FF FF      mov [bp + -1], a ; i
0220   0557 E4            pop a
0221   0558 0A 12 05      jmp _for4_cond
0222   055B             _for4_exit:
0223   055B             _for5_init:
0224   055B 26 00 00      mov b, 0
0225   055E D7            push a
0226   055F 11            mov a, b
0227   0560 45 FF FF      mov [bp + -1], a ; i
0228   0563 E4            pop a
0229   0564             _for5_cond:
0230   0564 2C FF FF      mov b, [bp + -1] ; i
0231   0567 D7            push a
0232   0568 11            mov a, b
0233   0569 26 14 00      mov b, 20
0234   056C B0            cmp a, b
0235   056D 0E            lodflgs
0236   056E 87 02         and al, %00000010
0237   0570 22 00         mov ah, 0
0238   0572 27            mov b, a
0239   0573 E4            pop a
0240   0574 C0 00 00      cmp b, 0
0241   0577 C6 9E 05      je _for5_exit
0242   057A             _for5_block:
0243   057A 29 FB 05      mov b, [state]
0244   057D 74            mov d, b
0245   057E 2C FF FF      mov b, [bp + -1] ; i
0246   0581 10 02 00      mov a, 2
0247   0584 AC            mul a, b
0248   0585 5A            add d, b
0249   0586 2A            mov b, [d]
0250   0587 FD AB         swp b
0251   0589 D8            push b
0252   058A 07 C9 05      call printn
0253   058D 51 02 00      add sp, 2
0254   0590             _for5_update:
0255   0590 2C FF FF      mov b, [bp + -1] ; i
0256   0593 FD 77         inc b
0257   0595 D7            push a
0258   0596 11            mov a, b
0259   0597 45 FF FF      mov [bp + -1], a ; i
0260   059A E4            pop a
0261   059B 0A 64 05      jmp _for5_cond
0262   059E             _for5_exit:
0263   059E 26 27 06      mov b, _string_0
0264   05A1 FD AB         swp b
0265   05A3 D8            push b
0266   05A4 07 BE 05      call print
0267   05A7 51 02 00      add sp, 2
0268   05AA             _for2_update:
0269   05AA 2C FD FF      mov b, [bp + -3] ; j
0270   05AD FD 77         inc b
0271   05AF D7            push a
0272   05B0 11            mov a, b
0273   05B1 45 FD FF      mov [bp + -3], a ; j
0274   05B4 E4            pop a
0275   05B5 0A 7F 04      jmp _for2_cond
0276   05B8             _for2_exit:
0277   05B8 26 00 00      mov b, 0
0278   05BB F9            leave
0279   05BC 05 0B         syscall sys_terminate_proc
0280   05BE             print:
0281   05BE D2            push bp
0282   05BF 9B            mov bp, sp
0283   05C0             
0284   05C0             ; --- BEGIN INLINE ASM BLOCK
0285   05C0 17 05 00      mov a, [bp + 5]
0286   05C3 3C            mov d, a
0287   05C4 07 6D 08      call puts
0288   05C7             ; --- END INLINE ASM BLOCK
0289   05C7             
0290   05C7 F9            leave
0291   05C8 09            ret
0292   05C9             printn:
0293   05C9 D2            push bp
0294   05CA 9B            mov bp, sp
0295   05CB             
0296   05CB             ; --- BEGIN INLINE ASM BLOCK
0297   05CB 2C 05 00      mov b, [bp + 5]
0298   05CE 07 0D 09      call print_u8x
0299   05D1             ; --- END INLINE ASM BLOCK
0300   05D1             
0301   05D1 F9            leave
0302   05D2 09            ret
0303   05D3             ; --- END TEXT BLOCK
0304   05D3             
0305   05D3             ; --- BEGIN DATA BLOCK
0306   05D3 00 00 00 00 state_data: .fill 40, 0
0306   05D7 00 00 00 00 
0306   05DB 00 00 00 00 
0306   05DF 00 00 00 00 
0306   05E3 00 00 00 00 
0306   05E7 00 00 00 00 
0306   05EB 00 00 00 00 
0306   05EF 00 00 00 00 
0306   05F3 00 00 00 00 
0306   05F7 00 00 00 00 
0307   05FB D3 05       state: .dw state_data
0308   05FD 00 00 00 00 next_state_data: .fill 40, 0
0308   0601 00 00 00 00 
0308   0605 00 00 00 00 
0308   0609 00 00 00 00 
0308   060D 00 00 00 00 
0308   0611 00 00 00 00 
0308   0615 00 00 00 00 
0308   0619 00 00 00 00 
0308   061D 00 00 00 00 
0308   0621 00 00 00 00 
0309   0625 FD 05       next_state: .dw next_state_data
0310   0627 0A 00       _string_0: .db "\n", 0
0311   0629             ; --- END DATA BLOCK
0312   0629             
0313   0629             ; --- BEGIN INCLUDE BLOCK
0314   0629             .include "lib/stdio.asm"
0001+  0629             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0629             ; stdio.s
0003+  0629             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0629             .include "lib/string.asm"
0001++ 0629             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0629             ; string.s
0003++ 0629             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0629             
0005++ 0629             
0006++ 0629             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0629             ; strrev
0008++ 0629             ; reverse a string
0009++ 0629             ; D = string address
0010++ 0629             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0629             ; 01234
0012++ 0629             strrev:
0013++ 0629 4B          	pusha
0014++ 062A 07 70 06    	call strlen	; length in C
0015++ 062D 12          	mov a, c
0016++ 062E AF 01 00    	cmp a, 1
0017++ 0631 D0 4B 06    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0634 7D          	dec a
0019++ 0635 FD 4E       	mov si, d	; beginning of string
0020++ 0637 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0639 59          	add d, a	; end of string
0022++ 063A 12          	mov a, c
0023++ 063B FD 9B       	shr a		; divide by 2
0024++ 063D 39          	mov c, a	; C now counts the steps
0025++ 063E             strrev_L0:
0026++ 063E 32          	mov bl, [d]	; save load right-side char into BL
0027++ 063F F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0640 3E          	mov [d], al	; store left char into right side
0029++ 0641 1B          	mov al, bl
0030++ 0642 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0643 7E          	dec c
0032++ 0644 7F          	dec d
0033++ 0645 C2 00 00    	cmp c, 0
0034++ 0648 C7 3E 06    	jne strrev_L0
0035++ 064B             strrev_end:
0036++ 064B 4C          	popa
0037++ 064C 09          	ret
0038++ 064D             	
0039++ 064D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 064D             ; strchr
0041++ 064D             ; search string in D for char in AL
0042++ 064D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 064D             strchr:
0044++ 064D             strchr_L0:
0045++ 064D 32          	mov bl, [d]
0046++ 064E C1 00       	cmp bl, 0
0047++ 0650 C6 5B 06    	je strchr_end
0048++ 0653 BA          	cmp al, bl
0049++ 0654 C6 5B 06    	je strchr_end
0050++ 0657 79          	inc d
0051++ 0658 0A 4D 06    	jmp strchr_L0
0052++ 065B             strchr_end:
0053++ 065B 1B          	mov al, bl
0054++ 065C 09          	ret
0055++ 065D             
0056++ 065D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 065D             ; strstr
0058++ 065D             ; find sub-string
0059++ 065D             ; str1 in SI
0060++ 065D             ; str2 in DI
0061++ 065D             ; SI points to end of source string
0062++ 065D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 065D             strstr:
0064++ 065D DB          	push al
0065++ 065E DA          	push d
0066++ 065F E3          	push di
0067++ 0660             strstr_loop:
0068++ 0660 F3          	cmpsb					; compare a byte of the strings
0069++ 0661 C7 6C 06    	jne strstr_ret
0070++ 0664 FC 00 00    	lea d, [di + 0]
0071++ 0667 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0669 C7 60 06    	jne strstr_loop				; equal chars but not at end
0073++ 066C             strstr_ret:
0074++ 066C F0          	pop di
0075++ 066D E7          	pop d
0076++ 066E E8          	pop al
0077++ 066F 09          	ret
0078++ 0670             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0670             ; length of null terminated string
0080++ 0670             ; result in C
0081++ 0670             ; pointer in D
0082++ 0670             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0670             strlen:
0084++ 0670 DA          	push d
0085++ 0671 38 00 00    	mov c, 0
0086++ 0674             strlen_L1:
0087++ 0674 BD 00       	cmp byte [d], 0
0088++ 0676 C6 7E 06    	je strlen_ret
0089++ 0679 79          	inc d
0090++ 067A 78          	inc c
0091++ 067B 0A 74 06    	jmp strlen_L1
0092++ 067E             strlen_ret:
0093++ 067E E7          	pop d
0094++ 067F 09          	ret
0095++ 0680             
0096++ 0680             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0680             ; STRCMP
0098++ 0680             ; compare two strings
0099++ 0680             ; str1 in SI
0100++ 0680             ; str2 in DI
0101++ 0680             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0680             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0680             strcmp:
0104++ 0680 DB          	push al
0105++ 0681 DA          	push d
0106++ 0682 E3          	push di
0107++ 0683 E2          	push si
0108++ 0684             strcmp_loop:
0109++ 0684 F3          	cmpsb					; compare a byte of the strings
0110++ 0685 C7 90 06    	jne strcmp_ret
0111++ 0688 FB FF FF    	lea d, [si +- 1]
0112++ 068B BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 068D C7 84 06    	jne strcmp_loop				; equal chars but not at end
0114++ 0690             strcmp_ret:
0115++ 0690 EF          	pop si
0116++ 0691 F0          	pop di
0117++ 0692 E7          	pop d
0118++ 0693 E8          	pop al
0119++ 0694 09          	ret
0120++ 0695             
0121++ 0695             
0122++ 0695             ; STRCPY
0123++ 0695             ; copy null terminated string from SI to DI
0124++ 0695             ; source in SI
0125++ 0695             ; destination in DI
0126++ 0695             strcpy:
0127++ 0695 E2          	push si
0128++ 0696 E3          	push di
0129++ 0697 DB          	push al
0130++ 0698             strcpy_L1:
0131++ 0698 F6          	lodsb
0132++ 0699 F7          	stosb
0133++ 069A B9 00       	cmp al, 0
0134++ 069C C7 98 06    	jne strcpy_L1
0135++ 069F             strcpy_end:
0136++ 069F E8          	pop al
0137++ 06A0 F0          	pop di
0138++ 06A1 EF          	pop si
0139++ 06A2 09          	ret
0140++ 06A3             
0141++ 06A3             ; STRCAT
0142++ 06A3             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 06A3             ; source in SI
0144++ 06A3             ; destination in DI
0145++ 06A3             strcat:
0146++ 06A3 E2          	push si
0147++ 06A4 E3          	push di
0148++ 06A5 D7          	push a
0149++ 06A6 DA          	push d
0150++ 06A7 50          	mov a, di
0151++ 06A8 3C          	mov d, a
0152++ 06A9             strcat_goto_end_L1:
0153++ 06A9 BD 00       	cmp byte[d], 0
0154++ 06AB C6 B2 06    	je strcat_start
0155++ 06AE 79          	inc d
0156++ 06AF 0A A9 06    	jmp strcat_goto_end_L1
0157++ 06B2             strcat_start:
0158++ 06B2 FD 50       	mov di, d
0159++ 06B4             strcat_L1:
0160++ 06B4 F6          	lodsb
0161++ 06B5 F7          	stosb
0162++ 06B6 B9 00       	cmp al, 0
0163++ 06B8 C7 B4 06    	jne strcat_L1
0164++ 06BB             strcat_end:
0165++ 06BB E7          	pop d
0166++ 06BC E4          	pop a
0167++ 06BD F0          	pop di
0168++ 06BE EF          	pop si
0169++ 06BF 09          	ret
0005+  06C0             
0006+  06C0 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  06C4 34 35 36 37 
0006+  06C8 38 39 41 42 
0006+  06CC 43 44 45 46 
0007+  06D0             
0008+  06D0 01 00       table_power:.dw 1
0009+  06D2 0A 00       			.dw 10
0010+  06D4 64 00       			.dw 100
0011+  06D6 E8 03       			.dw 1000
0012+  06D8 10 27       			.dw 10000
0013+  06DA             
0014+  06DA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0015+  06DA             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0016+  06DA             ; ASCII in BL
0017+  06DA             ; result in AL
0018+  06DA             ; ascii for F = 0100 0110
0019+  06DA             ; ascii for 9 = 0011 1001
0020+  06DA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0021+  06DA             hex_ascii_encode:
0022+  06DA 1B          	mov al, bl
0023+  06DB 93 40       	test al, $40				; test if letter or number
0024+  06DD C7 E3 06    	jnz hex_letter
0025+  06E0 87 0F       	and al, $0F				; get number
0026+  06E2 09          	ret
0027+  06E3             hex_letter:
0028+  06E3 87 0F       	and al, $0F				; get letter
0029+  06E5 6A 09       	add al, 9
0030+  06E7 09          	ret
0031+  06E8             
0032+  06E8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0033+  06E8             ; ATOI
0034+  06E8             ; 2 letter hex string in B
0035+  06E8             ; 8bit integer returned in AL
0036+  06E8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0037+  06E8             atoi:
0038+  06E8 D8          	push b
0039+  06E9 07 DA 06    	call hex_ascii_encode			; convert BL to 4bit code in AL
0040+  06EC 30          	mov bl, bh
0041+  06ED DB          	push al					; save a
0042+  06EE 07 DA 06    	call hex_ascii_encode
0043+  06F1 EA          	pop bl	
0044+  06F2 FD 9E 04    	shl al, 4
0045+  06F5 8C          	or al, bl
0046+  06F6 E5          	pop b
0047+  06F7 09          	ret	
0048+  06F8             
0049+  06F8             
0050+  06F8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  06F8             ; printf
0052+  06F8             ; no need for explanations!
0053+  06F8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0054+  06F8             printf:
0055+  06F8 09          	ret
0056+  06F9             
0057+  06F9             
0058+  06F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  06F9             ; scanf
0060+  06F9             ; no need for explanations!
0061+  06F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  06F9             scanf:
0063+  06F9 09          	ret
0064+  06FA             
0065+  06FA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  06FA             ; ITOA
0067+  06FA             ; 8bit value in BL
0068+  06FA             ; 2 byte ASCII result in A
0069+  06FA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0070+  06FA             itoa:
0071+  06FA DA          	push d
0072+  06FB D8          	push b
0073+  06FC A7 00       	mov bh, 0
0074+  06FE FD A4 04    	shr bl, 4	
0075+  0701 74          	mov d, b
0076+  0702 1F C0 06    	mov al, [d + s_hex_digits]
0077+  0705 23          	mov ah, al
0078+  0706             	
0079+  0706 E5          	pop b
0080+  0707 D8          	push b
0081+  0708 A7 00       	mov bh, 0
0082+  070A FD 87 0F    	and bl, $0F
0083+  070D 74          	mov d, b
0084+  070E 1F C0 06    	mov al, [d + s_hex_digits]
0085+  0711 E5          	pop b
0086+  0712 E7          	pop d
0087+  0713 09          	ret
0088+  0714             
0089+  0714             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0090+  0714             ; HEX STRING TO BINARY
0091+  0714             ; di = destination address
0092+  0714             ; si = source
0093+  0714             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0094+  0714             hex_to_int:
0095+  0714             hex_to_int_L1:
0096+  0714 F6          	lodsb					; load from [SI] to AL
0097+  0715 B9 00       	cmp al, 0				; check if ASCII 0
0098+  0717 C6 24 07    	jz hex_to_int_ret
0099+  071A 36          	mov bh, al
0100+  071B F6          	lodsb
0101+  071C 2F          	mov bl, al
0102+  071D 07 E8 06    	call atoi				; convert ASCII byte in B to int (to AL)
0103+  0720 F7          	stosb					; store AL to [DI]
0104+  0721 0A 14 07    	jmp hex_to_int_L1
0105+  0724             hex_to_int_ret:
0106+  0724 09          	ret		
0107+  0725             
0108+  0725             
0109+  0725             
0110+  0725             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  0725             ; GETCHAR
0112+  0725             ; char in ah
0113+  0725             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0114+  0725             getchar:
0115+  0725 DB          	push al
0116+  0726             getchar_retry:
0117+  0726 FD 0C       	sti
0118+  0728 19 01       	mov al, 1
0119+  072A 05 03       	syscall sys_io			; receive in AH
0120+  072C B9 00       	cmp al, 0			; check if any char was receive
0121+  072E C6 26 07    	je getchar_retry
0122+  0731 E8          	pop al
0123+  0732 09          	ret
0124+  0733             
0125+  0733             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0126+  0733             ; PUTCHAR
0127+  0733             ; char in ah
0128+  0733             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  0733             putchar:
0130+  0733 D7          	push a
0131+  0734 19 00       	mov al, 0
0132+  0736 05 03       	syscall sys_io			; char in AH
0133+  0738 E4          	pop a
0134+  0739 09          	ret
0135+  073A             
0136+  073A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0137+  073A             ;; INPUT A STRING
0138+  073A             ;; terminates with null
0139+  073A             ;; pointer in D
0140+  073A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  073A             gets:
0142+  073A D7          	push a
0143+  073B DA          	push d
0144+  073C             gets_loop:
0145+  073C FD 0C       	sti
0146+  073E 19 01       	mov al, 1
0147+  0740 05 03       	syscall sys_io			; receive in AH
0148+  0742 B9 00       	cmp al, 0				; check error code (AL)
0149+  0744 C6 3C 07    	je gets_loop			; if no char received, retry
0150+  0747             
0151+  0747 76 1B       	cmp ah, 27
0152+  0749 C6 6A 07    	je gets_telnet_escape
0153+  074C 76 0A       	cmp ah, $0A				; LF
0154+  074E C6 C3 07    	je gets_end
0155+  0751 76 0D       	cmp ah, $0D				; CR
0156+  0753 C6 C3 07    	je gets_end
0157+  0756 76 5C       	cmp ah, $5C				; '\\'
0158+  0758 C6 9A 07    	je gets_escape
0159+  075B             	
0160+  075B 76 08       	cmp ah, $08			; check for backspace
0161+  075D C6 66 07    	je gets_backspace
0162+  0760             
0163+  0760 1A          	mov al, ah
0164+  0761 3E          	mov [d], al
0165+  0762 79          	inc d
0166+  0763 0A 3C 07    	jmp gets_loop
0167+  0766             gets_backspace:
0168+  0766 7F          	dec d
0169+  0767 0A 3C 07    	jmp gets_loop
0170+  076A             gets_telnet_escape:
0171+  076A FD 0C       	sti
0172+  076C 19 01       	mov al, 1
0173+  076E 05 03       	syscall sys_io				; receive in AH without echo
0174+  0770 B9 00       	cmp al, 0					; check error code (AL)
0175+  0772 C6 6A 07    	je gets_telnet_escape		; if no char received, retry
0176+  0775 76 5B       	cmp ah, '['
0177+  0777 C7 3C 07    	jne gets_loop
0178+  077A             gets_telnet_escape_phase2:
0179+  077A FD 0C       	sti
0180+  077C 19 01       	mov al, 1
0181+  077E 05 03       	syscall sys_io					; receive in AH without echo
0182+  0780 B9 00       	cmp al, 0						; check error code (AL)
0183+  0782 C6 7A 07    	je gets_telnet_escape_phase2	; if no char received, retry
0184+  0785 76 44       	cmp ah, 'D'
0185+  0787 C6 92 07    	je gets_left_arrow
0186+  078A 76 43       	cmp ah, 'C'
0187+  078C C6 96 07    	je gets_right_arrow
0188+  078F 0A 3C 07    	jmp gets_loop
0189+  0792             gets_left_arrow:
0190+  0792 7F          	dec d
0191+  0793 0A 3C 07    	jmp gets_loop
0192+  0796             gets_right_arrow:
0193+  0796 79          	inc d
0194+  0797 0A 3C 07    	jmp gets_loop
0195+  079A             gets_escape:
0196+  079A FD 0C       	sti
0197+  079C 19 01       	mov al, 1
0198+  079E 05 03       	syscall sys_io			; receive in AH
0199+  07A0 B9 00       	cmp al, 0				; check error code (AL)
0200+  07A2 C6 9A 07    	je gets_escape			; if no char received, retry
0201+  07A5 76 6E       	cmp ah, 'n'
0202+  07A7 C6 B5 07    	je gets_LF
0203+  07AA 76 72       	cmp ah, 'r'
0204+  07AC C6 BC 07    	je gets_CR
0205+  07AF 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0206+  07B0 3E          	mov [d], al
0207+  07B1 79          	inc d
0208+  07B2 0A 3C 07    	jmp gets_loop
0209+  07B5             gets_LF:
0210+  07B5 19 0A       	mov al, $0A
0211+  07B7 3E          	mov [d], al
0212+  07B8 79          	inc d
0213+  07B9 0A 3C 07    	jmp gets_loop
0214+  07BC             gets_CR:
0215+  07BC 19 0D       	mov al, $0D
0216+  07BE 3E          	mov [d], al
0217+  07BF 79          	inc d
0218+  07C0 0A 3C 07    	jmp gets_loop
0219+  07C3             gets_end:
0220+  07C3 19 00       	mov al, 0
0221+  07C5 3E          	mov [d], al				; terminate string
0222+  07C6 E7          	pop d
0223+  07C7 E4          	pop a
0224+  07C8 09          	ret
0225+  07C9             
0226+  07C9             
0227+  07C9             
0228+  07C9             
0229+  07C9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0230+  07C9             ;; INPUT TEXT
0231+  07C9             ;; terminated with CTRL+D
0232+  07C9             ;; pointer in D
0233+  07C9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0234+  07C9             gettxt:
0235+  07C9 D7          	push a
0236+  07CA DA          	push d
0237+  07CB             gettxt_loop:
0238+  07CB 19 01       	mov al, 1
0239+  07CD 05 03       	syscall sys_io			; receive in AH
0240+  07CF B9 00       	cmp al, 0				; check error code (AL)
0241+  07D1 C6 CB 07    	je gettxt_loop		; if no char received, retry
0242+  07D4 76 04       	cmp ah, 4			; EOT
0243+  07D6 C6 14 08    	je gettxt_end
0244+  07D9 76 08       	cmp ah, $08			; check for backspace
0245+  07DB C6 10 08    	je gettxt_backspace
0246+  07DE 76 5C       	cmp ah, $5C				; '\\'
0247+  07E0 C6 E9 07    	je gettxt_escape
0248+  07E3 1A          	mov al, ah
0249+  07E4 3E          	mov [d], al
0250+  07E5 79          	inc d
0251+  07E6 0A CB 07    	jmp gettxt_loop
0252+  07E9             gettxt_escape:
0253+  07E9 19 01       	mov al, 1
0254+  07EB 05 03       	syscall sys_io			; receive in AH
0255+  07ED B9 00       	cmp al, 0				; check error code (AL)
0256+  07EF C6 E9 07    	je gettxt_escape		; if no char received, retry
0257+  07F2 76 6E       	cmp ah, 'n'
0258+  07F4 C6 02 08    	je gettxt_LF
0259+  07F7 76 72       	cmp ah, 'r'
0260+  07F9 C6 09 08    	je gettxt_CR
0261+  07FC 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0262+  07FD 3E          	mov [d], al
0263+  07FE 79          	inc d
0264+  07FF 0A CB 07    	jmp gettxt_loop
0265+  0802             gettxt_LF:
0266+  0802 19 0A       	mov al, $0A
0267+  0804 3E          	mov [d], al
0268+  0805 79          	inc d
0269+  0806 0A CB 07    	jmp gettxt_loop
0270+  0809             gettxt_CR:
0271+  0809 19 0D       	mov al, $0D
0272+  080B 3E          	mov [d], al
0273+  080C 79          	inc d
0274+  080D 0A CB 07    	jmp gettxt_loop
0275+  0810             gettxt_backspace:
0276+  0810 7F          	dec d
0277+  0811 0A CB 07    	jmp gettxt_loop
0278+  0814             gettxt_end:
0279+  0814 19 00       	mov al, 0
0280+  0816 3E          	mov [d], al				; terminate string
0281+  0817 E7          	pop d
0282+  0818 E4          	pop a
0283+  0819 09          	ret
0284+  081A             
0285+  081A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0286+  081A             ; PRINT NEW LINE
0287+  081A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  081A             printnl:
0289+  081A D7          	push a
0290+  081B 10 00 0A    	mov a, $0A00
0291+  081E 05 03       	syscall sys_io
0292+  0820 10 00 0D    	mov a, $0D00
0293+  0823 05 03       	syscall sys_io
0294+  0825 E4          	pop a
0295+  0826 09          	ret
0296+  0827             
0297+  0827             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0298+  0827             ; strtoint
0299+  0827             ; 4 digit hex string number in d
0300+  0827             ; integer returned in A
0301+  0827             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0302+  0827             strtointx:
0303+  0827 D8          	push b
0304+  0828 32          	mov bl, [d]
0305+  0829 37          	mov bh, bl
0306+  082A 33 01 00    	mov bl, [d + 1]
0307+  082D 07 E8 06    	call atoi				; convert to int in AL
0308+  0830 23          	mov ah, al				; move to AH
0309+  0831 33 02 00    	mov bl, [d + 2]
0310+  0834 37          	mov bh, bl
0311+  0835 33 03 00    	mov bl, [d + 3]
0312+  0838 07 E8 06    	call atoi				; convert to int in AL
0313+  083B E5          	pop b
0314+  083C 09          	ret
0315+  083D             
0316+  083D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0317+  083D             ; strtoint
0318+  083D             ; 5 digit base10 string number in d
0319+  083D             ; integer returned in A
0320+  083D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0321+  083D             strtoint:
0322+  083D E2          	push si
0323+  083E D8          	push b
0324+  083F D9          	push c
0325+  0840 DA          	push d
0326+  0841 07 70 06    	call strlen			; get string length in C
0327+  0844 7E          	dec c
0328+  0845 FD 4E       	mov si, d
0329+  0847 12          	mov a, c
0330+  0848 FD 99       	shl a
0331+  084A 3B D0 06    	mov d, table_power
0332+  084D 59          	add d, a
0333+  084E 38 00 00    	mov c, 0
0334+  0851             strtoint_L0:
0335+  0851 F6          	lodsb			; load ASCII to al
0336+  0852 B9 00       	cmp al, 0
0337+  0854 C6 67 08    	je strtoint_end
0338+  0857 6F 30       	sub al, $30		; make into integer
0339+  0859 22 00       	mov ah, 0
0340+  085B 2A          	mov b, [d]
0341+  085C AC          	mul a, b			; result in B since it fits in 16bits
0342+  085D 11          	mov a, b
0343+  085E 28          	mov b, c
0344+  085F 54          	add a, b
0345+  0860 39          	mov c, a
0346+  0861 63 02 00    	sub d, 2
0347+  0864 0A 51 08    	jmp strtoint_L0
0348+  0867             strtoint_end:
0349+  0867 12          	mov a, c
0350+  0868 E7          	pop d
0351+  0869 E6          	pop c
0352+  086A E5          	pop b
0353+  086B EF          	pop si
0354+  086C 09          	ret
0355+  086D             
0356+  086D             
0357+  086D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0358+  086D             ; PRINT NULL TERMINATED STRING
0359+  086D             ; pointer in D
0360+  086D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0361+  086D             puts:
0362+  086D D7          	push a
0363+  086E DA          	push d
0364+  086F             puts_L1:
0365+  086F 1E          	mov al, [d]
0366+  0870 B9 00       	cmp al, 0
0367+  0872 C6 7E 08    	jz puts_END
0368+  0875 23          	mov ah, al
0369+  0876 19 00       	mov al, 0
0370+  0878 05 03       	syscall sys_io
0371+  087A 79          	inc d
0372+  087B 0A 6F 08    	jmp puts_L1
0373+  087E             puts_END:
0374+  087E E7          	pop d
0375+  087F E4          	pop a
0376+  0880 09          	ret
0377+  0881             
0378+  0881             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  0881             ; PRINT N SIZE STRING
0380+  0881             ; pointer in D
0381+  0881             ; size in C
0382+  0881             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0383+  0881             putsn:
0384+  0881 DB          	push al
0385+  0882 DA          	push d
0386+  0883 D9          	push c
0387+  0884             putsn_L0:
0388+  0884 1E          	mov al, [d]
0389+  0885 23          	mov ah, al
0390+  0886 19 00       	mov al, 0
0391+  0888 05 03       	syscall sys_io
0392+  088A 79          	inc d
0393+  088B 7E          	dec c	
0394+  088C C2 00 00    	cmp c, 0
0395+  088F C7 84 08    	jne putsn_L0
0396+  0892             putsn_end:
0397+  0892 E6          	pop c
0398+  0893 E7          	pop d
0399+  0894 E8          	pop al
0400+  0895 09          	ret
0401+  0896             
0402+  0896             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0403+  0896             ; print 16bit decimal number
0404+  0896             ; input number in A
0405+  0896             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  0896             print_u16d:
0407+  0896 D7          	push a
0408+  0897 D8          	push b
0409+  0898 26 10 27    	mov b, 10000
0410+  089B AE          	div a, b			; get 10000 coeff.
0411+  089C 07 C2 08    	call print_number
0412+  089F 11          	mov a, b
0413+  08A0 26 E8 03    	mov b, 1000
0414+  08A3 AE          	div a, b			; get 10000 coeff.
0415+  08A4 07 C2 08    	call print_number
0416+  08A7 11          	mov a, b
0417+  08A8 26 64 00    	mov b, 100
0418+  08AB AE          	div a, b
0419+  08AC 07 C2 08    	call print_number
0420+  08AF 11          	mov a, b
0421+  08B0 26 0A 00    	mov b, 10
0422+  08B3 AE          	div a, b
0423+  08B4 07 C2 08    	call print_number
0424+  08B7 11          	mov a, b
0425+  08B8 6A 30       	add al, $30
0426+  08BA 23          	mov ah, al
0427+  08BB 19 00       	mov al, 0
0428+  08BD 05 03       	syscall sys_io	; print coeff
0429+  08BF E5          	pop b
0430+  08C0 E4          	pop a
0431+  08C1 09          	ret
0432+  08C2             
0433+  08C2             
0434+  08C2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0435+  08C2             ; if A == 0, print space
0436+  08C2             ; else print A
0437+  08C2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0438+  08C2             print_number:
0439+  08C2 6A 30       	add al, $30
0440+  08C4 23          	mov ah, al
0441+  08C5 07 33 07    	call putchar
0442+  08C8 09          	ret
0443+  08C9             
0444+  08C9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  08C9             ; PRINT 16BIT HEX INTEGER
0446+  08C9             ; integer value in reg B
0447+  08C9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  08C9             print_u16x:
0449+  08C9 D7          	push a
0450+  08CA D8          	push b
0451+  08CB DD          	push bl
0452+  08CC 30          	mov bl, bh
0453+  08CD 07 FA 06    	call itoa				; convert bh to char in A
0454+  08D0 2F          	mov bl, al				; save al
0455+  08D1 19 00       	mov al, 0
0456+  08D3 05 03       	syscall sys_io				; display AH
0457+  08D5 24          	mov ah, bl				; retrieve al
0458+  08D6 19 00       	mov al, 0
0459+  08D8 05 03       	syscall sys_io				; display AL
0460+  08DA             
0461+  08DA EA          	pop bl
0462+  08DB 07 FA 06    	call itoa				; convert bh to char in A
0463+  08DE 2F          	mov bl, al				; save al
0464+  08DF 19 00       	mov al, 0
0465+  08E1 05 03       	syscall sys_io				; display AH
0466+  08E3 24          	mov ah, bl				; retrieve al
0467+  08E4 19 00       	mov al, 0
0468+  08E6 05 03       	syscall sys_io				; display AL
0469+  08E8             
0470+  08E8 E5          	pop b
0471+  08E9 E4          	pop a
0472+  08EA 09          	ret
0473+  08EB             
0474+  08EB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0475+  08EB             ; INPUT 16BIT HEX INTEGER
0476+  08EB             ; read 16bit integer into A
0477+  08EB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0478+  08EB             scan_u16x:
0479+  08EB F8 10 00    	enter 16
0480+  08EE D8          	push b
0481+  08EF DA          	push d
0482+  08F0             
0483+  08F0 FA F1 FF    	lea d, [bp + -15]
0484+  08F3 07 3A 07    	call gets				; get number
0485+  08F6             
0486+  08F6 32          	mov bl, [d]
0487+  08F7 37          	mov bh, bl
0488+  08F8 33 01 00    	mov bl, [d + 1]
0489+  08FB 07 E8 06    	call atoi				; convert to int in AL
0490+  08FE 23          	mov ah, al				; move to AH
0491+  08FF             
0492+  08FF 33 02 00    	mov bl, [d + 2]
0493+  0902 37          	mov bh, bl
0494+  0903 33 03 00    	mov bl, [d + 3]
0495+  0906 07 E8 06    	call atoi				; convert to int in AL
0496+  0909             
0497+  0909 E7          	pop d
0498+  090A E5          	pop b
0499+  090B F9          	leave
0500+  090C 09          	ret
0501+  090D             
0502+  090D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0503+  090D             ; PRINT 8bit HEX INTEGER
0504+  090D             ; integer value in reg bl
0505+  090D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0506+  090D             print_u8x:
0507+  090D D7          	push a
0508+  090E DD          	push bl
0509+  090F             
0510+  090F 07 FA 06    	call itoa				; convert bl to char in A
0511+  0912 2F          	mov bl, al				; save al
0512+  0913 19 00       	mov al, 0
0513+  0915 05 03       	syscall sys_io				; display AH
0514+  0917 24          	mov ah, bl				; retrieve al
0515+  0918 19 00       	mov al, 0
0516+  091A 05 03       	syscall sys_io				; display AL
0517+  091C             
0518+  091C EA          	pop bl
0519+  091D E4          	pop a
0520+  091E 09          	ret
0521+  091F             
0522+  091F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0523+  091F             ; print 8bit decimal unsigned number
0524+  091F             ; input number in AL
0525+  091F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0526+  091F             print_u8d:
0527+  091F D7          	push a
0528+  0920 D8          	push b
0529+  0921             
0530+  0921 22 00       	mov ah, 0
0531+  0923 26 64 00    	mov b, 100
0532+  0926 AE          	div a, b
0533+  0927 D8          	push b			; save remainder
0534+  0928 B9 00       	cmp al, 0
0535+  092A C6 34 09    	je skip100
0536+  092D 6A 30       	add al, $30
0537+  092F 23          	mov ah, al
0538+  0930 19 00       	mov al, 0
0539+  0932 05 03       	syscall sys_io	; print coeff
0540+  0934             skip100:
0541+  0934 E4          	pop a
0542+  0935 22 00       	mov ah, 0
0543+  0937 26 0A 00    	mov b, 10
0544+  093A AE          	div a, b
0545+  093B D8          	push b			; save remainder
0546+  093C B9 00       	cmp al, 0
0547+  093E C6 48 09    	je skip10
0548+  0941 6A 30       	add al, $30
0549+  0943 23          	mov ah, al
0550+  0944 19 00       	mov al, 0
0551+  0946 05 03       	syscall sys_io	; print coeff
0552+  0948             skip10:
0553+  0948 E4          	pop a
0554+  0949 1B          	mov al, bl
0555+  094A 6A 30       	add al, $30
0556+  094C 23          	mov ah, al
0557+  094D 19 00       	mov al, 0
0558+  094F 05 03       	syscall sys_io	; print coeff
0559+  0951 E5          	pop b
0560+  0952 E4          	pop a
0561+  0953 09          	ret
0562+  0954             
0563+  0954             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0564+  0954             ; INPUT 8BIT HEX INTEGER
0565+  0954             ; read 8bit integer into AL
0566+  0954             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0567+  0954             scan_u8x:
0568+  0954 F8 04 00    	enter 4
0569+  0957 D8          	push b
0570+  0958 DA          	push d
0571+  0959             
0572+  0959 FA FD FF    	lea d, [bp + -3]
0573+  095C 07 3A 07    	call gets				; get number
0574+  095F             
0575+  095F 32          	mov bl, [d]
0576+  0960 37          	mov bh, bl
0577+  0961 33 01 00    	mov bl, [d + 1]
0578+  0964 07 E8 06    	call atoi				; convert to int in AL
0579+  0967             
0580+  0967 E7          	pop d
0581+  0968 E5          	pop b
0582+  0969 F9          	leave
0583+  096A 09          	ret
0584+  096B             
0585+  096B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0586+  096B             ; input decimal number
0587+  096B             ; result in A
0588+  096B             ; 655'\0'
0589+  096B             ; low--------high
0590+  096B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0591+  096B             scan_u16d:
0592+  096B F8 08 00    	enter 8
0593+  096E E2          	push si
0594+  096F D8          	push b
0595+  0970 D9          	push c
0596+  0971 DA          	push d
0597+  0972 FA F9 FF    	lea d, [bp +- 7]
0598+  0975 07 3A 07    	call gets
0599+  0978 07 70 06    	call strlen			; get string length in C
0600+  097B 7E          	dec c
0601+  097C FD 4E       	mov si, d
0602+  097E 12          	mov a, c
0603+  097F FD 99       	shl a
0604+  0981 3B D0 06    	mov d, table_power
0605+  0984 59          	add d, a
0606+  0985 38 00 00    	mov c, 0
0607+  0988             mul_loop:
0608+  0988 F6          	lodsb			; load ASCII to al
0609+  0989 B9 00       	cmp al, 0
0610+  098B C6 9E 09    	je mul_exit
0611+  098E 6F 30       	sub al, $30		; make into integer
0612+  0990 22 00       	mov ah, 0
0613+  0992 2A          	mov b, [d]
0614+  0993 AC          	mul a, b			; result in B since it fits in 16bits
0615+  0994 11          	mov a, b
0616+  0995 28          	mov b, c
0617+  0996 54          	add a, b
0618+  0997 39          	mov c, a
0619+  0998 63 02 00    	sub d, 2
0620+  099B 0A 88 09    	jmp mul_loop
0621+  099E             mul_exit:
0622+  099E 12          	mov a, c
0623+  099F E7          	pop d
0624+  09A0 E6          	pop c
0625+  09A1 E5          	pop b
0626+  09A2 EF          	pop si
0627+  09A3 F9          	leave
0628+  09A4 09          	ret
0315   09A5             ; --- END INCLUDE BLOCK
0316   09A5             
0317   09A5             
0318   09A5             .end
tasm: Number of errors = 0
