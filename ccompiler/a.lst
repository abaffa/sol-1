0001   0000             ; --- FILENAME: test.c
0002   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0400             .org PROC_TEXT_ORG
0004   0400             
0005   0400             ; --- BEGIN TEXT BLOCK
0006   0400             main:
0007   0400 D2            push bp
0008   0401 9B            mov bp, sp
0009   0402 29 79 05      mov b, [s1]
0010   0405 FD AB         swp b
0011   0407 D8            push b
0012   0408 29 8F 05      mov b, [s2]
0013   040B FD AB         swp b
0014   040D D8            push b
0015   040E 07 79 04      call _strcat
0016   0411 51 04 00      add sp, 4
0017   0414 29 79 05      mov b, [s1]
0018   0417 FD AB         swp b
0019   0419 D8            push b
0020   041A 07 2F 04      call _strlen
0021   041D 51 02 00      add sp, 2
0022   0420 FD AB         swp b
0023   0422 D8            push b
0024   0423 07 2C 05      call printn
0025   0426 51 02 00      add sp, 2
0026   0429 26 00 00      mov b, 0
0027   042C F9            leave
0028   042D 05 0B         syscall sys_terminate_proc
0029   042F             _strlen:
0030   042F D2            push bp
0031   0430 9B            mov bp, sp
0032   0431 52 02 00      sub sp, 2 ; length
0033   0434 26 00 00      mov b, 0
0034   0437 D7            push a
0035   0438 11            mov a, b
0036   0439 45 FF FF      mov [bp + -1], a ; length
0037   043C E4            pop a
0038   043D             _while1_cond:
0039   043D FA 05 00      lea d, [bp + 5] ; str
0040   0440 2A            mov b, [d]
0041   0441 D7            push a
0042   0442 11            mov a, b
0043   0443 2C FF FF      mov b, [bp + -1] ; length
0044   0446 54            add a, b
0045   0447 27            mov b, a
0046   0448 E4            pop a
0047   0449 74            mov d, b
0048   044A 2A            mov b, [d]
0049   044B D7            push a
0050   044C 11            mov a, b
0051   044D 26 00 00      mov b, 0
0052   0450 B0            cmp a, b
0053   0451 0E            lodflgs
0054   0452 87 01         and al, %00000001
0055   0454 8F 01         xor al, %00000001 ; !=
0056   0456 B9 00         cmp al, 0
0057   0458 0E            lodflgs
0058   0459 96            not al
0059   045A 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0060   045C 22 00         mov ah, 0
0061   045E 27            mov b, a
0062   045F E4            pop a
0063   0460 C0 00 00      cmp b, 0
0064   0463 C6 74 04      je _while1_exit
0065   0466             _while1_block:
0066   0466 2C FF FF      mov b, [bp + -1] ; length
0067   0469 FD 77         inc b
0068   046B D7            push a
0069   046C 11            mov a, b
0070   046D 45 FF FF      mov [bp + -1], a ; length
0071   0470 E4            pop a
0072   0471 0A 3D 04      jmp _while1_cond
0073   0474             _while1_exit:
0074   0474 2C FF FF      mov b, [bp + -1] ; length
0075   0477 F9            leave
0076   0478 09            ret
0077   0479             _strcat:
0078   0479 D2            push bp
0079   047A 9B            mov bp, sp
0080   047B 52 02 00      sub sp, 2 ; dest_len
0081   047E 52 02 00      sub sp, 2 ; i
0082   0481 FA 07 00      lea d, [bp + 7] ; dest
0083   0484 2A            mov b, [d]
0084   0485 FD AB         swp b
0085   0487 D8            push b
0086   0488 07 2F 04      call _strlen
0087   048B 51 02 00      add sp, 2
0088   048E D7            push a
0089   048F 11            mov a, b
0090   0490 45 FF FF      mov [bp + -1], a ; dest_len
0091   0493 E4            pop a
0092   0494             _for2_init:
0093   0494 26 00 00      mov b, 0
0094   0497 D7            push a
0095   0498 11            mov a, b
0096   0499 45 FD FF      mov [bp + -3], a ; i
0097   049C E4            pop a
0098   049D             _for2_cond:
0099   049D FA 05 00      lea d, [bp + 5] ; src
0100   04A0 2A            mov b, [d]
0101   04A1 D7            push a
0102   04A2 11            mov a, b
0103   04A3 2C FD FF      mov b, [bp + -3] ; i
0104   04A6 54            add a, b
0105   04A7 27            mov b, a
0106   04A8 E4            pop a
0107   04A9 74            mov d, b
0108   04AA 2A            mov b, [d]
0109   04AB D7            push a
0110   04AC 11            mov a, b
0111   04AD 26 00 00      mov b, 0
0112   04B0 B0            cmp a, b
0113   04B1 0E            lodflgs
0114   04B2 87 01         and al, %00000001
0115   04B4 8F 01         xor al, %00000001 ; !=
0116   04B6 B9 00         cmp al, 0
0117   04B8 0E            lodflgs
0118   04B9 96            not al
0119   04BA 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0120   04BC 22 00         mov ah, 0
0121   04BE 27            mov b, a
0122   04BF E4            pop a
0123   04C0 C0 00 00      cmp b, 0
0124   04C3 C6 F7 04      je _for2_exit
0125   04C6             _for2_block:
0126   04C6 FA 07 00      lea d, [bp + 7] ; dest
0127   04C9 2A            mov b, [d]
0128   04CA D7            push a
0129   04CB 11            mov a, b
0130   04CC 2C FF FF      mov b, [bp + -1] ; dest_len
0131   04CF 54            add a, b
0132   04D0 27            mov b, a
0133   04D1 11            mov a, b
0134   04D2 2C FD FF      mov b, [bp + -3] ; i
0135   04D5 54            add a, b
0136   04D6 27            mov b, a
0137   04D7 E4            pop a
0138   04D8 74            mov d, b
0139   04D9 FA 05 00      lea d, [bp + 5] ; src
0140   04DC 2A            mov b, [d]
0141   04DD D7            push a
0142   04DE 11            mov a, b
0143   04DF 2C FD FF      mov b, [bp + -3] ; i
0144   04E2 54            add a, b
0145   04E3 27            mov b, a
0146   04E4 E4            pop a
0147   04E5 74            mov d, b
0148   04E6 2A            mov b, [d]
0149   04E7 11            mov a, b
0150   04E8 43            mov [d], a
0151   04E9             _for2_update:
0152   04E9 2C FD FF      mov b, [bp + -3] ; i
0153   04EC FD 77         inc b
0154   04EE D7            push a
0155   04EF 11            mov a, b
0156   04F0 45 FD FF      mov [bp + -3], a ; i
0157   04F3 E4            pop a
0158   04F4 0A 9D 04      jmp _for2_cond
0159   04F7             _for2_exit:
0160   04F7 FA 07 00      lea d, [bp + 7] ; dest
0161   04FA 2A            mov b, [d]
0162   04FB D7            push a
0163   04FC 11            mov a, b
0164   04FD 2C FF FF      mov b, [bp + -1] ; dest_len
0165   0500 54            add a, b
0166   0501 27            mov b, a
0167   0502 11            mov a, b
0168   0503 2C FD FF      mov b, [bp + -3] ; i
0169   0506 54            add a, b
0170   0507 27            mov b, a
0171   0508 E4            pop a
0172   0509 74            mov d, b
0173   050A 26 00 00      mov b, 0
0174   050D 11            mov a, b
0175   050E 43            mov [d], a
0176   050F FA 07 00      lea d, [bp + 7] ; dest
0177   0512 2A            mov b, [d]
0178   0513 F9            leave
0179   0514 09            ret
0180   0515             scann:
0181   0515 D2            push bp
0182   0516 9B            mov bp, sp
0183   0517 52 02 00      sub sp, 2 ; m
0184   051A             
0185   051A             ; --- BEGIN INLINE ASM BLOCK
0186   051A 07 DB 08      call scan_u16d
0187   051D 45 FF FF      mov [bp + -1], a
0188   0520             ; --- END INLINE ASM BLOCK
0189   0520             
0190   0520 FA 05 00      lea d, [bp + 5] ; n
0191   0523 2A            mov b, [d]
0192   0524 74            mov d, b
0193   0525 2C FF FF      mov b, [bp + -1] ; m
0194   0528 11            mov a, b
0195   0529 43            mov [d], a
0196   052A F9            leave
0197   052B 09            ret
0198   052C             printn:
0199   052C D2            push bp
0200   052D 9B            mov bp, sp
0201   052E             
0202   052E             ; --- BEGIN INLINE ASM BLOCK
0203   052E 17 05 00      mov a, [bp + 5]
0204   0531 07 06 08      call print_u16d
0205   0534             ; --- END INLINE ASM BLOCK
0206   0534             
0207   0534 F9            leave
0208   0535 09            ret
0209   0536             print:
0210   0536 D2            push bp
0211   0537 9B            mov bp, sp
0212   0538             
0213   0538             ; --- BEGIN INLINE ASM BLOCK
0214   0538 17 05 00      mov a, [bp + 5]
0215   053B 3C            mov d, a
0216   053C 07 DD 07      call puts
0217   053F             ; --- END INLINE ASM BLOCK
0218   053F             
0219   053F F9            leave
0220   0540 09            ret
0221   0541             ; --- END TEXT BLOCK
0222   0541             
0223   0541             ; --- BEGIN DATA BLOCK
0224   0541             s1_data: 
0225   0541 48 00 65 00 .dw 'H', 'e', 'l', 'l', 'o', 0,
0225   0545 6C 00 6C 00 
0225   0549 6F 00 00 00 
0226   054D 00 00 00 00 .fill 44, 0
0226   0551 00 00 00 00 
0226   0555 00 00 00 00 
0226   0559 00 00 00 00 
0226   055D 00 00 00 00 
0226   0561 00 00 00 00 
0226   0565 00 00 00 00 
0226   0569 00 00 00 00 
0226   056D 00 00 00 00 
0226   0571 00 00 00 00 
0226   0575 00 00 00 00 
0227   0579 41 05       s1: .dw s1_data
0228   057B 2E 20 4D 79 s2_data: .db ". My name is Sol-1.", 0
0228   057F 20 6E 61 6D 
0228   0583 65 20 69 73 
0228   0587 20 53 6F 6C 
0228   058B 2D 31 2E 00 
0229   058F 7B 05       s2: .dw s2_data
0230   0591             ; --- END DATA BLOCK
0231   0591             
0232   0591             ; --- BEGIN INCLUDE BLOCK
0233   0591             .include "lib/stdio.asm"
0001+  0591             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0591             ; stdio.s
0003+  0591             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0591             .include "lib/string.asm"
0001++ 0591             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0591             ; string.s
0003++ 0591             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0591             
0005++ 0591             
0006++ 0591             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0591             ; strrev
0008++ 0591             ; reverse a string
0009++ 0591             ; D = string address
0010++ 0591             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0591             ; 01234
0012++ 0591             strrev:
0013++ 0591 4B          	pusha
0014++ 0592 07 D8 05    	call strlen	; length in C
0015++ 0595 12          	mov a, c
0016++ 0596 AF 01 00    	cmp a, 1
0017++ 0599 D0 B3 05    	jleu strrev_end	; check string length. string len must be > 1
0018++ 059C 7D          	dec a
0019++ 059D FD 4E       	mov si, d	; beginning of string
0020++ 059F FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 05A1 59          	add d, a	; end of string
0022++ 05A2 12          	mov a, c
0023++ 05A3 FD 9B       	shr a		; divide by 2
0024++ 05A5 39          	mov c, a	; C now counts the steps
0025++ 05A6             strrev_L0:
0026++ 05A6 32          	mov bl, [d]	; save load right-side char into BL
0027++ 05A7 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 05A8 3E          	mov [d], al	; store left char into right side
0029++ 05A9 1B          	mov al, bl
0030++ 05AA F7          	stosb		; store right-side char into left-side; increase DI
0031++ 05AB 7E          	dec c
0032++ 05AC 7F          	dec d
0033++ 05AD C2 00 00    	cmp c, 0
0034++ 05B0 C7 A6 05    	jne strrev_L0
0035++ 05B3             strrev_end:
0036++ 05B3 4C          	popa
0037++ 05B4 09          	ret
0038++ 05B5             	
0039++ 05B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 05B5             ; strchr
0041++ 05B5             ; search string in D for char in AL
0042++ 05B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 05B5             strchr:
0044++ 05B5             strchr_L0:
0045++ 05B5 32          	mov bl, [d]
0046++ 05B6 C1 00       	cmp bl, 0
0047++ 05B8 C6 C3 05    	je strchr_end
0048++ 05BB BA          	cmp al, bl
0049++ 05BC C6 C3 05    	je strchr_end
0050++ 05BF 79          	inc d
0051++ 05C0 0A B5 05    	jmp strchr_L0
0052++ 05C3             strchr_end:
0053++ 05C3 1B          	mov al, bl
0054++ 05C4 09          	ret
0055++ 05C5             
0056++ 05C5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 05C5             ; strstr
0058++ 05C5             ; find sub-string
0059++ 05C5             ; str1 in SI
0060++ 05C5             ; str2 in DI
0061++ 05C5             ; SI points to end of source string
0062++ 05C5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 05C5             strstr:
0064++ 05C5 DB          	push al
0065++ 05C6 DA          	push d
0066++ 05C7 E3          	push di
0067++ 05C8             strstr_loop:
0068++ 05C8 F3          	cmpsb					; compare a byte of the strings
0069++ 05C9 C7 D4 05    	jne strstr_ret
0070++ 05CC FC 00 00    	lea d, [di + 0]
0071++ 05CF BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 05D1 C7 C8 05    	jne strstr_loop				; equal chars but not at end
0073++ 05D4             strstr_ret:
0074++ 05D4 F0          	pop di
0075++ 05D5 E7          	pop d
0076++ 05D6 E8          	pop al
0077++ 05D7 09          	ret
0078++ 05D8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 05D8             ; length of null terminated string
0080++ 05D8             ; result in C
0081++ 05D8             ; pointer in D
0082++ 05D8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 05D8             strlen:
0084++ 05D8 DA          	push d
0085++ 05D9 38 00 00    	mov c, 0
0086++ 05DC             strlen_L1:
0087++ 05DC BD 00       	cmp byte [d], 0
0088++ 05DE C6 E6 05    	je strlen_ret
0089++ 05E1 79          	inc d
0090++ 05E2 78          	inc c
0091++ 05E3 0A DC 05    	jmp strlen_L1
0092++ 05E6             strlen_ret:
0093++ 05E6 E7          	pop d
0094++ 05E7 09          	ret
0095++ 05E8             
0096++ 05E8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 05E8             ; STRCMP
0098++ 05E8             ; compare two strings
0099++ 05E8             ; str1 in SI
0100++ 05E8             ; str2 in DI
0101++ 05E8             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 05E8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 05E8             strcmp:
0104++ 05E8 DB          	push al
0105++ 05E9 DA          	push d
0106++ 05EA E3          	push di
0107++ 05EB E2          	push si
0108++ 05EC             strcmp_loop:
0109++ 05EC F3          	cmpsb					; compare a byte of the strings
0110++ 05ED C7 F8 05    	jne strcmp_ret
0111++ 05F0 FB FF FF    	lea d, [si +- 1]
0112++ 05F3 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 05F5 C7 EC 05    	jne strcmp_loop				; equal chars but not at end
0114++ 05F8             strcmp_ret:
0115++ 05F8 EF          	pop si
0116++ 05F9 F0          	pop di
0117++ 05FA E7          	pop d
0118++ 05FB E8          	pop al
0119++ 05FC 09          	ret
0120++ 05FD             
0121++ 05FD             
0122++ 05FD             ; STRCPY
0123++ 05FD             ; copy null terminated string from SI to DI
0124++ 05FD             ; source in SI
0125++ 05FD             ; destination in DI
0126++ 05FD             strcpy:
0127++ 05FD E2          	push si
0128++ 05FE E3          	push di
0129++ 05FF DB          	push al
0130++ 0600             strcpy_L1:
0131++ 0600 F6          	lodsb
0132++ 0601 F7          	stosb
0133++ 0602 B9 00       	cmp al, 0
0134++ 0604 C7 00 06    	jne strcpy_L1
0135++ 0607             strcpy_end:
0136++ 0607 E8          	pop al
0137++ 0608 F0          	pop di
0138++ 0609 EF          	pop si
0139++ 060A 09          	ret
0140++ 060B             
0141++ 060B             ; STRCAT
0142++ 060B             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 060B             ; source in SI
0144++ 060B             ; destination in DI
0145++ 060B             strcat:
0146++ 060B E2          	push si
0147++ 060C E3          	push di
0148++ 060D D7          	push a
0149++ 060E DA          	push d
0150++ 060F 50          	mov a, di
0151++ 0610 3C          	mov d, a
0152++ 0611             strcat_goto_end_L1:
0153++ 0611 BD 00       	cmp byte[d], 0
0154++ 0613 C6 1A 06    	je strcat_start
0155++ 0616 79          	inc d
0156++ 0617 0A 11 06    	jmp strcat_goto_end_L1
0157++ 061A             strcat_start:
0158++ 061A FD 50       	mov di, d
0159++ 061C             strcat_L1:
0160++ 061C F6          	lodsb
0161++ 061D F7          	stosb
0162++ 061E B9 00       	cmp al, 0
0163++ 0620 C7 1C 06    	jne strcat_L1
0164++ 0623             strcat_end:
0165++ 0623 E7          	pop d
0166++ 0624 E4          	pop a
0167++ 0625 F0          	pop di
0168++ 0626 EF          	pop si
0169++ 0627 09          	ret
0005+  0628             
0006+  0628 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  062C 34 35 36 37 
0006+  0630 38 39 41 42 
0006+  0634 43 44 45 46 
0007+  0638 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  063C 1B 5B 48 00 
0008+  0640             
0009+  0640 01 00       table_power:.dw 1
0010+  0642 0A 00       			.dw 10
0011+  0644 64 00       			.dw 100
0012+  0646 E8 03       			.dw 1000
0013+  0648 10 27       			.dw 10000
0014+  064A             
0015+  064A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  064A             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  064A             ; ASCII in BL
0018+  064A             ; result in AL
0019+  064A             ; ascii for F = 0100 0110
0020+  064A             ; ascii for 9 = 0011 1001
0021+  064A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  064A             hex_ascii_encode:
0023+  064A 1B          	mov al, bl
0024+  064B 93 40       	test al, $40				; test if letter or number
0025+  064D C7 53 06    	jnz hex_letter
0026+  0650 87 0F       	and al, $0F				; get number
0027+  0652 09          	ret
0028+  0653             hex_letter:
0029+  0653 87 0F       	and al, $0F				; get letter
0030+  0655 6A 09       	add al, 9
0031+  0657 09          	ret
0032+  0658             
0033+  0658             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  0658             ; ATOI
0035+  0658             ; 2 letter hex string in B
0036+  0658             ; 8bit integer returned in AL
0037+  0658             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0658             atoi:
0039+  0658 D8          	push b
0040+  0659 07 4A 06    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  065C 30          	mov bl, bh
0042+  065D DB          	push al					; save a
0043+  065E 07 4A 06    	call hex_ascii_encode
0044+  0661 EA          	pop bl	
0045+  0662 FD 9E 04    	shl al, 4
0046+  0665 8C          	or al, bl
0047+  0666 E5          	pop b
0048+  0667 09          	ret	
0049+  0668             
0050+  0668             
0051+  0668             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  0668             ; printf
0053+  0668             ; no need for explanations!
0054+  0668             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0668             printf:
0056+  0668 09          	ret
0057+  0669             
0058+  0669             
0059+  0669             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  0669             ; scanf
0061+  0669             ; no need for explanations!
0062+  0669             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  0669             scanf:
0064+  0669 09          	ret
0065+  066A             
0066+  066A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  066A             ; ITOA
0068+  066A             ; 8bit value in BL
0069+  066A             ; 2 byte ASCII result in A
0070+  066A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  066A             itoa:
0072+  066A DA          	push d
0073+  066B D8          	push b
0074+  066C A7 00       	mov bh, 0
0075+  066E FD A4 04    	shr bl, 4	
0076+  0671 74          	mov d, b
0077+  0672 1F 28 06    	mov al, [d + s_hex_digits]
0078+  0675 23          	mov ah, al
0079+  0676             	
0080+  0676 E5          	pop b
0081+  0677 D8          	push b
0082+  0678 A7 00       	mov bh, 0
0083+  067A FD 87 0F    	and bl, $0F
0084+  067D 74          	mov d, b
0085+  067E 1F 28 06    	mov al, [d + s_hex_digits]
0086+  0681 E5          	pop b
0087+  0682 E7          	pop d
0088+  0683 09          	ret
0089+  0684             
0090+  0684             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  0684             ; HEX STRING TO BINARY
0092+  0684             ; di = destination address
0093+  0684             ; si = source
0094+  0684             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  0684             hex_to_int:
0096+  0684             hex_to_int_L1:
0097+  0684 F6          	lodsb					; load from [SI] to AL
0098+  0685 B9 00       	cmp al, 0				; check if ASCII 0
0099+  0687 C6 94 06    	jz hex_to_int_ret
0100+  068A 36          	mov bh, al
0101+  068B F6          	lodsb
0102+  068C 2F          	mov bl, al
0103+  068D 07 58 06    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  0690 F7          	stosb					; store AL to [DI]
0105+  0691 0A 84 06    	jmp hex_to_int_L1
0106+  0694             hex_to_int_ret:
0107+  0694 09          	ret		
0108+  0695             
0109+  0695             
0110+  0695             
0111+  0695             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  0695             ; GETCHAR
0113+  0695             ; char in ah
0114+  0695             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  0695             getchar:
0116+  0695 DB          	push al
0117+  0696             getchar_retry:
0118+  0696 FD 0C       	sti
0119+  0698 19 01       	mov al, 1
0120+  069A 05 03       	syscall sys_io			; receive in AH
0121+  069C B9 00       	cmp al, 0			; check if any char was receive
0122+  069E C6 96 06    	je getchar_retry
0123+  06A1 E8          	pop al
0124+  06A2 09          	ret
0125+  06A3             
0126+  06A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  06A3             ; PUTCHAR
0128+  06A3             ; char in ah
0129+  06A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  06A3             putchar:
0131+  06A3 D7          	push a
0132+  06A4 19 00       	mov al, 0
0133+  06A6 05 03       	syscall sys_io			; char in AH
0134+  06A8 E4          	pop a
0135+  06A9 09          	ret
0136+  06AA             
0137+  06AA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  06AA             ;; INPUT A STRING
0139+  06AA             ;; terminates with null
0140+  06AA             ;; pointer in D
0141+  06AA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  06AA             gets:
0143+  06AA D7          	push a
0144+  06AB DA          	push d
0145+  06AC             gets_loop:
0146+  06AC FD 0C       	sti
0147+  06AE 19 01       	mov al, 1
0148+  06B0 05 03       	syscall sys_io			; receive in AH
0149+  06B2 B9 00       	cmp al, 0				; check error code (AL)
0150+  06B4 C6 AC 06    	je gets_loop			; if no char received, retry
0151+  06B7             
0152+  06B7 76 1B       	cmp ah, 27
0153+  06B9 C6 DA 06    	je gets_telnet_escape
0154+  06BC 76 0A       	cmp ah, $0A				; LF
0155+  06BE C6 33 07    	je gets_end
0156+  06C1 76 0D       	cmp ah, $0D				; CR
0157+  06C3 C6 33 07    	je gets_end
0158+  06C6 76 5C       	cmp ah, $5C				; '\\'
0159+  06C8 C6 0A 07    	je gets_escape
0160+  06CB             	
0161+  06CB 76 08       	cmp ah, $08			; check for backspace
0162+  06CD C6 D6 06    	je gets_backspace
0163+  06D0             
0164+  06D0 1A          	mov al, ah
0165+  06D1 3E          	mov [d], al
0166+  06D2 79          	inc d
0167+  06D3 0A AC 06    	jmp gets_loop
0168+  06D6             gets_backspace:
0169+  06D6 7F          	dec d
0170+  06D7 0A AC 06    	jmp gets_loop
0171+  06DA             gets_telnet_escape:
0172+  06DA FD 0C       	sti
0173+  06DC 19 01       	mov al, 1
0174+  06DE 05 03       	syscall sys_io				; receive in AH without echo
0175+  06E0 B9 00       	cmp al, 0					; check error code (AL)
0176+  06E2 C6 DA 06    	je gets_telnet_escape		; if no char received, retry
0177+  06E5 76 5B       	cmp ah, '['
0178+  06E7 C7 AC 06    	jne gets_loop
0179+  06EA             gets_telnet_escape_phase2:
0180+  06EA FD 0C       	sti
0181+  06EC 19 01       	mov al, 1
0182+  06EE 05 03       	syscall sys_io					; receive in AH without echo
0183+  06F0 B9 00       	cmp al, 0						; check error code (AL)
0184+  06F2 C6 EA 06    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  06F5 76 44       	cmp ah, 'D'
0186+  06F7 C6 02 07    	je gets_left_arrow
0187+  06FA 76 43       	cmp ah, 'C'
0188+  06FC C6 06 07    	je gets_right_arrow
0189+  06FF 0A AC 06    	jmp gets_loop
0190+  0702             gets_left_arrow:
0191+  0702 7F          	dec d
0192+  0703 0A AC 06    	jmp gets_loop
0193+  0706             gets_right_arrow:
0194+  0706 79          	inc d
0195+  0707 0A AC 06    	jmp gets_loop
0196+  070A             gets_escape:
0197+  070A FD 0C       	sti
0198+  070C 19 01       	mov al, 1
0199+  070E 05 03       	syscall sys_io			; receive in AH
0200+  0710 B9 00       	cmp al, 0				; check error code (AL)
0201+  0712 C6 0A 07    	je gets_escape			; if no char received, retry
0202+  0715 76 6E       	cmp ah, 'n'
0203+  0717 C6 25 07    	je gets_LF
0204+  071A 76 72       	cmp ah, 'r'
0205+  071C C6 2C 07    	je gets_CR
0206+  071F 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  0720 3E          	mov [d], al
0208+  0721 79          	inc d
0209+  0722 0A AC 06    	jmp gets_loop
0210+  0725             gets_LF:
0211+  0725 19 0A       	mov al, $0A
0212+  0727 3E          	mov [d], al
0213+  0728 79          	inc d
0214+  0729 0A AC 06    	jmp gets_loop
0215+  072C             gets_CR:
0216+  072C 19 0D       	mov al, $0D
0217+  072E 3E          	mov [d], al
0218+  072F 79          	inc d
0219+  0730 0A AC 06    	jmp gets_loop
0220+  0733             gets_end:
0221+  0733 19 00       	mov al, 0
0222+  0735 3E          	mov [d], al				; terminate string
0223+  0736 E7          	pop d
0224+  0737 E4          	pop a
0225+  0738 09          	ret
0226+  0739             
0227+  0739             
0228+  0739             
0229+  0739             
0230+  0739             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  0739             ;; INPUT TEXT
0232+  0739             ;; terminated with CTRL+D
0233+  0739             ;; pointer in D
0234+  0739             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  0739             gettxt:
0236+  0739 D7          	push a
0237+  073A DA          	push d
0238+  073B             gettxt_loop:
0239+  073B 19 01       	mov al, 1
0240+  073D 05 03       	syscall sys_io			; receive in AH
0241+  073F B9 00       	cmp al, 0				; check error code (AL)
0242+  0741 C6 3B 07    	je gettxt_loop		; if no char received, retry
0243+  0744 76 04       	cmp ah, 4			; EOT
0244+  0746 C6 84 07    	je gettxt_end
0245+  0749 76 08       	cmp ah, $08			; check for backspace
0246+  074B C6 80 07    	je gettxt_backspace
0247+  074E 76 5C       	cmp ah, $5C				; '\\'
0248+  0750 C6 59 07    	je gettxt_escape
0249+  0753 1A          	mov al, ah
0250+  0754 3E          	mov [d], al
0251+  0755 79          	inc d
0252+  0756 0A 3B 07    	jmp gettxt_loop
0253+  0759             gettxt_escape:
0254+  0759 19 01       	mov al, 1
0255+  075B 05 03       	syscall sys_io			; receive in AH
0256+  075D B9 00       	cmp al, 0				; check error code (AL)
0257+  075F C6 59 07    	je gettxt_escape		; if no char received, retry
0258+  0762 76 6E       	cmp ah, 'n'
0259+  0764 C6 72 07    	je gettxt_LF
0260+  0767 76 72       	cmp ah, 'r'
0261+  0769 C6 79 07    	je gettxt_CR
0262+  076C 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  076D 3E          	mov [d], al
0264+  076E 79          	inc d
0265+  076F 0A 3B 07    	jmp gettxt_loop
0266+  0772             gettxt_LF:
0267+  0772 19 0A       	mov al, $0A
0268+  0774 3E          	mov [d], al
0269+  0775 79          	inc d
0270+  0776 0A 3B 07    	jmp gettxt_loop
0271+  0779             gettxt_CR:
0272+  0779 19 0D       	mov al, $0D
0273+  077B 3E          	mov [d], al
0274+  077C 79          	inc d
0275+  077D 0A 3B 07    	jmp gettxt_loop
0276+  0780             gettxt_backspace:
0277+  0780 7F          	dec d
0278+  0781 0A 3B 07    	jmp gettxt_loop
0279+  0784             gettxt_end:
0280+  0784 19 00       	mov al, 0
0281+  0786 3E          	mov [d], al				; terminate string
0282+  0787 E7          	pop d
0283+  0788 E4          	pop a
0284+  0789 09          	ret
0285+  078A             
0286+  078A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  078A             ; PRINT NEW LINE
0288+  078A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  078A             printnl:
0290+  078A D7          	push a
0291+  078B 10 00 0A    	mov a, $0A00
0292+  078E 05 03       	syscall sys_io
0293+  0790 10 00 0D    	mov a, $0D00
0294+  0793 05 03       	syscall sys_io
0295+  0795 E4          	pop a
0296+  0796 09          	ret
0297+  0797             
0298+  0797             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  0797             ; strtoint
0300+  0797             ; 4 digit hex string number in d
0301+  0797             ; integer returned in A
0302+  0797             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  0797             strtointx:
0304+  0797 D8          	push b
0305+  0798 32          	mov bl, [d]
0306+  0799 37          	mov bh, bl
0307+  079A 33 01 00    	mov bl, [d + 1]
0308+  079D 07 58 06    	call atoi				; convert to int in AL
0309+  07A0 23          	mov ah, al				; move to AH
0310+  07A1 33 02 00    	mov bl, [d + 2]
0311+  07A4 37          	mov bh, bl
0312+  07A5 33 03 00    	mov bl, [d + 3]
0313+  07A8 07 58 06    	call atoi				; convert to int in AL
0314+  07AB E5          	pop b
0315+  07AC 09          	ret
0316+  07AD             
0317+  07AD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  07AD             ; strtoint
0319+  07AD             ; 5 digit base10 string number in d
0320+  07AD             ; integer returned in A
0321+  07AD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  07AD             strtoint:
0323+  07AD E2          	push si
0324+  07AE D8          	push b
0325+  07AF D9          	push c
0326+  07B0 DA          	push d
0327+  07B1 07 D8 05    	call strlen			; get string length in C
0328+  07B4 7E          	dec c
0329+  07B5 FD 4E       	mov si, d
0330+  07B7 12          	mov a, c
0331+  07B8 FD 99       	shl a
0332+  07BA 3B 40 06    	mov d, table_power
0333+  07BD 59          	add d, a
0334+  07BE 38 00 00    	mov c, 0
0335+  07C1             strtoint_L0:
0336+  07C1 F6          	lodsb			; load ASCII to al
0337+  07C2 B9 00       	cmp al, 0
0338+  07C4 C6 D7 07    	je strtoint_end
0339+  07C7 6F 30       	sub al, $30		; make into integer
0340+  07C9 22 00       	mov ah, 0
0341+  07CB 2A          	mov b, [d]
0342+  07CC AC          	mul a, b			; result in B since it fits in 16bits
0343+  07CD 11          	mov a, b
0344+  07CE 28          	mov b, c
0345+  07CF 54          	add a, b
0346+  07D0 39          	mov c, a
0347+  07D1 63 02 00    	sub d, 2
0348+  07D4 0A C1 07    	jmp strtoint_L0
0349+  07D7             strtoint_end:
0350+  07D7 12          	mov a, c
0351+  07D8 E7          	pop d
0352+  07D9 E6          	pop c
0353+  07DA E5          	pop b
0354+  07DB EF          	pop si
0355+  07DC 09          	ret
0356+  07DD             
0357+  07DD             
0358+  07DD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  07DD             ; PRINT NULL TERMINATED STRING
0360+  07DD             ; pointer in D
0361+  07DD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  07DD             puts:
0363+  07DD D7          	push a
0364+  07DE DA          	push d
0365+  07DF             puts_L1:
0366+  07DF 1E          	mov al, [d]
0367+  07E0 B9 00       	cmp al, 0
0368+  07E2 C6 EE 07    	jz puts_END
0369+  07E5 23          	mov ah, al
0370+  07E6 19 00       	mov al, 0
0371+  07E8 05 03       	syscall sys_io
0372+  07EA 79          	inc d
0373+  07EB 0A DF 07    	jmp puts_L1
0374+  07EE             puts_END:
0375+  07EE E7          	pop d
0376+  07EF E4          	pop a
0377+  07F0 09          	ret
0378+  07F1             
0379+  07F1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  07F1             ; PRINT N SIZE STRING
0381+  07F1             ; pointer in D
0382+  07F1             ; size in C
0383+  07F1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  07F1             putsn:
0385+  07F1 DB          	push al
0386+  07F2 DA          	push d
0387+  07F3 D9          	push c
0388+  07F4             putsn_L0:
0389+  07F4 1E          	mov al, [d]
0390+  07F5 23          	mov ah, al
0391+  07F6 19 00       	mov al, 0
0392+  07F8 05 03       	syscall sys_io
0393+  07FA 79          	inc d
0394+  07FB 7E          	dec c	
0395+  07FC C2 00 00    	cmp c, 0
0396+  07FF C7 F4 07    	jne putsn_L0
0397+  0802             putsn_end:
0398+  0802 E6          	pop c
0399+  0803 E7          	pop d
0400+  0804 E8          	pop al
0401+  0805 09          	ret
0402+  0806             
0403+  0806             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  0806             ; print 16bit decimal number
0405+  0806             ; input number in A
0406+  0806             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  0806             print_u16d:
0408+  0806 D7          	push a
0409+  0807 D8          	push b
0410+  0808 26 10 27    	mov b, 10000
0411+  080B AE          	div a, b			; get 10000 coeff.
0412+  080C 07 32 08    	call print_number
0413+  080F 11          	mov a, b
0414+  0810 26 E8 03    	mov b, 1000
0415+  0813 AE          	div a, b			; get 10000 coeff.
0416+  0814 07 32 08    	call print_number
0417+  0817 11          	mov a, b
0418+  0818 26 64 00    	mov b, 100
0419+  081B AE          	div a, b
0420+  081C 07 32 08    	call print_number
0421+  081F 11          	mov a, b
0422+  0820 26 0A 00    	mov b, 10
0423+  0823 AE          	div a, b
0424+  0824 07 32 08    	call print_number
0425+  0827 11          	mov a, b
0426+  0828 6A 30       	add al, $30
0427+  082A 23          	mov ah, al
0428+  082B 19 00       	mov al, 0
0429+  082D 05 03       	syscall sys_io	; print coeff
0430+  082F E5          	pop b
0431+  0830 E4          	pop a
0432+  0831 09          	ret
0433+  0832             
0434+  0832             
0435+  0832             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  0832             ; if A == 0, print space
0437+  0832             ; else print A
0438+  0832             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0439+  0832             print_number:
0440+  0832 6A 30       	add al, $30
0441+  0834 23          	mov ah, al
0442+  0835 07 A3 06    	call putchar
0443+  0838 09          	ret
0444+  0839             
0445+  0839             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0446+  0839             ; PRINT 16BIT HEX INTEGER
0447+  0839             ; integer value in reg B
0448+  0839             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  0839             print_u16x:
0450+  0839 D7          	push a
0451+  083A D8          	push b
0452+  083B DD          	push bl
0453+  083C 30          	mov bl, bh
0454+  083D 07 6A 06    	call itoa				; convert bh to char in A
0455+  0840 2F          	mov bl, al				; save al
0456+  0841 19 00       	mov al, 0
0457+  0843 05 03       	syscall sys_io				; display AH
0458+  0845 24          	mov ah, bl				; retrieve al
0459+  0846 19 00       	mov al, 0
0460+  0848 05 03       	syscall sys_io				; display AL
0461+  084A             
0462+  084A EA          	pop bl
0463+  084B 07 6A 06    	call itoa				; convert bh to char in A
0464+  084E 2F          	mov bl, al				; save al
0465+  084F 19 00       	mov al, 0
0466+  0851 05 03       	syscall sys_io				; display AH
0467+  0853 24          	mov ah, bl				; retrieve al
0468+  0854 19 00       	mov al, 0
0469+  0856 05 03       	syscall sys_io				; display AL
0470+  0858             
0471+  0858 E5          	pop b
0472+  0859 E4          	pop a
0473+  085A 09          	ret
0474+  085B             
0475+  085B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  085B             ; INPUT 16BIT HEX INTEGER
0477+  085B             ; read 16bit integer into A
0478+  085B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  085B             scan_u16x:
0480+  085B F8 10 00    	enter 16
0481+  085E D8          	push b
0482+  085F DA          	push d
0483+  0860             
0484+  0860 FA F1 FF    	lea d, [bp + -15]
0485+  0863 07 AA 06    	call gets				; get number
0486+  0866             
0487+  0866 32          	mov bl, [d]
0488+  0867 37          	mov bh, bl
0489+  0868 33 01 00    	mov bl, [d + 1]
0490+  086B 07 58 06    	call atoi				; convert to int in AL
0491+  086E 23          	mov ah, al				; move to AH
0492+  086F             
0493+  086F 33 02 00    	mov bl, [d + 2]
0494+  0872 37          	mov bh, bl
0495+  0873 33 03 00    	mov bl, [d + 3]
0496+  0876 07 58 06    	call atoi				; convert to int in AL
0497+  0879             
0498+  0879 E7          	pop d
0499+  087A E5          	pop b
0500+  087B F9          	leave
0501+  087C 09          	ret
0502+  087D             
0503+  087D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0504+  087D             ; PRINT 8bit HEX INTEGER
0505+  087D             ; integer value in reg bl
0506+  087D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  087D             print_u8x:
0508+  087D D7          	push a
0509+  087E DD          	push bl
0510+  087F             
0511+  087F 07 6A 06    	call itoa				; convert bl to char in A
0512+  0882 2F          	mov bl, al				; save al
0513+  0883 19 00       	mov al, 0
0514+  0885 05 03       	syscall sys_io				; display AH
0515+  0887 24          	mov ah, bl				; retrieve al
0516+  0888 19 00       	mov al, 0
0517+  088A 05 03       	syscall sys_io				; display AL
0518+  088C             
0519+  088C EA          	pop bl
0520+  088D E4          	pop a
0521+  088E 09          	ret
0522+  088F             
0523+  088F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0524+  088F             ; print 8bit decimal unsigned number
0525+  088F             ; input number in AL
0526+  088F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  088F             print_u8d:
0528+  088F D7          	push a
0529+  0890 D8          	push b
0530+  0891             
0531+  0891 22 00       	mov ah, 0
0532+  0893 26 64 00    	mov b, 100
0533+  0896 AE          	div a, b
0534+  0897 D8          	push b			; save remainder
0535+  0898 B9 00       	cmp al, 0
0536+  089A C6 A4 08    	je skip100
0537+  089D 6A 30       	add al, $30
0538+  089F 23          	mov ah, al
0539+  08A0 19 00       	mov al, 0
0540+  08A2 05 03       	syscall sys_io	; print coeff
0541+  08A4             skip100:
0542+  08A4 E4          	pop a
0543+  08A5 22 00       	mov ah, 0
0544+  08A7 26 0A 00    	mov b, 10
0545+  08AA AE          	div a, b
0546+  08AB D8          	push b			; save remainder
0547+  08AC B9 00       	cmp al, 0
0548+  08AE C6 B8 08    	je skip10
0549+  08B1 6A 30       	add al, $30
0550+  08B3 23          	mov ah, al
0551+  08B4 19 00       	mov al, 0
0552+  08B6 05 03       	syscall sys_io	; print coeff
0553+  08B8             skip10:
0554+  08B8 E4          	pop a
0555+  08B9 1B          	mov al, bl
0556+  08BA 6A 30       	add al, $30
0557+  08BC 23          	mov ah, al
0558+  08BD 19 00       	mov al, 0
0559+  08BF 05 03       	syscall sys_io	; print coeff
0560+  08C1 E5          	pop b
0561+  08C2 E4          	pop a
0562+  08C3 09          	ret
0563+  08C4             
0564+  08C4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0565+  08C4             ; INPUT 8BIT HEX INTEGER
0566+  08C4             ; read 8bit integer into AL
0567+  08C4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  08C4             scan_u8x:
0569+  08C4 F8 04 00    	enter 4
0570+  08C7 D8          	push b
0571+  08C8 DA          	push d
0572+  08C9             
0573+  08C9 FA FD FF    	lea d, [bp + -3]
0574+  08CC 07 AA 06    	call gets				; get number
0575+  08CF             
0576+  08CF 32          	mov bl, [d]
0577+  08D0 37          	mov bh, bl
0578+  08D1 33 01 00    	mov bl, [d + 1]
0579+  08D4 07 58 06    	call atoi				; convert to int in AL
0580+  08D7             
0581+  08D7 E7          	pop d
0582+  08D8 E5          	pop b
0583+  08D9 F9          	leave
0584+  08DA 09          	ret
0585+  08DB             
0586+  08DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  08DB             ; input decimal number
0588+  08DB             ; result in A
0589+  08DB             ; 655'\0'
0590+  08DB             ; low--------high
0591+  08DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0592+  08DB             scan_u16d:
0593+  08DB F8 08 00    	enter 8
0594+  08DE E2          	push si
0595+  08DF D8          	push b
0596+  08E0 D9          	push c
0597+  08E1 DA          	push d
0598+  08E2 FA F9 FF    	lea d, [bp +- 7]
0599+  08E5 07 AA 06    	call gets
0600+  08E8 07 D8 05    	call strlen			; get string length in C
0601+  08EB 7E          	dec c
0602+  08EC FD 4E       	mov si, d
0603+  08EE 12          	mov a, c
0604+  08EF FD 99       	shl a
0605+  08F1 3B 40 06    	mov d, table_power
0606+  08F4 59          	add d, a
0607+  08F5 38 00 00    	mov c, 0
0608+  08F8             mul_loop:
0609+  08F8 F6          	lodsb			; load ASCII to al
0610+  08F9 B9 00       	cmp al, 0
0611+  08FB C6 0E 09    	je mul_exit
0612+  08FE 6F 30       	sub al, $30		; make into integer
0613+  0900 22 00       	mov ah, 0
0614+  0902 2A          	mov b, [d]
0615+  0903 AC          	mul a, b			; result in B since it fits in 16bits
0616+  0904 11          	mov a, b
0617+  0905 28          	mov b, c
0618+  0906 54          	add a, b
0619+  0907 39          	mov c, a
0620+  0908 63 02 00    	sub d, 2
0621+  090B 0A F8 08    	jmp mul_loop
0622+  090E             mul_exit:
0623+  090E 12          	mov a, c
0624+  090F E7          	pop d
0625+  0910 E6          	pop c
0626+  0911 E5          	pop b
0627+  0912 EF          	pop si
0628+  0913 F9          	leave
0629+  0914 09          	ret
0234   0915             ; --- END INCLUDE BLOCK
0235   0915             
0236   0915             
0237   0915             .end
tasm: Number of errors = 0
