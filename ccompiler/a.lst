0001   0000             ; --- FILENAME: test.c
0002   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0400             .org PROC_TEXT_ORG
0004   0400             
0005   0400             ; --- BEGIN TEXT BLOCK
0006   0400             main:
0007   0400 D2            push bp
0008   0401 9B            mov bp, sp
0009   0402 29 78 05      mov b, [s1]
0010   0405 FD AB         swp b
0011   0407 D8            push b
0012   0408 29 8E 05      mov b, [s2]
0013   040B FD AB         swp b
0014   040D D8            push b
0015   040E 07 79 04      call _strcat
0016   0411 51 04 00      add sp, 4
0017   0414 29 78 05      mov b, [s1]
0018   0417 FD AB         swp b
0019   0419 D8            push b
0020   041A 07 2F 04      call _strlen
0021   041D 51 02 00      add sp, 2
0022   0420 FD AB         swp b
0023   0422 D8            push b
0024   0423 07 2B 05      call printn
0025   0426 51 02 00      add sp, 2
0026   0429 26 00 00      mov b, 0
0027   042C F9            leave
0028   042D 05 0B         syscall sys_terminate_proc
0029   042F             _strlen:
0030   042F D2            push bp
0031   0430 9B            mov bp, sp
0032   0431 52 02 00      sub sp, 2 ; length
0033   0434 26 00 00      mov b, 0
0034   0437 D7            push a
0035   0438 11            mov a, b
0036   0439 45 FF FF      mov [bp + -1], a ; length
0037   043C E4            pop a
0038   043D             _while1_cond:
0039   043D FA 05 00      lea d, [bp + 5] ; str
0040   0440 2A            mov b, [d]
0041   0441 D7            push a
0042   0442 11            mov a, b
0043   0443 2C FF FF      mov b, [bp + -1] ; length
0044   0446 54            add a, b
0045   0447 27            mov b, a
0046   0448 E4            pop a
0047   0449 74            mov d, b
0048   044A 2A            mov b, [d]
0049   044B D7            push a
0050   044C 11            mov a, b
0051   044D 26 00 00      mov b, 0
0052   0450 B0            cmp a, b
0053   0451 0E            lodflgs
0054   0452 87 01         and al, %00000001
0055   0454 8F 01         xor al, %00000001 ; !=
0056   0456 B9 00         cmp al, 0
0057   0458 0E            lodflgs
0058   0459 96            not al
0059   045A 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0060   045C 22 00         mov ah, 0
0061   045E 27            mov b, a
0062   045F E4            pop a
0063   0460 C0 00 00      cmp b, 0
0064   0463 C6 74 04      je _while1_exit
0065   0466             _while1_block:
0066   0466 2C FF FF      mov b, [bp + -1] ; length
0067   0469 FD 77         inc b
0068   046B D7            push a
0069   046C 11            mov a, b
0070   046D 45 FF FF      mov [bp + -1], a ; length
0071   0470 E4            pop a
0072   0471 0A 3D 04      jmp _while1_cond
0073   0474             _while1_exit:
0074   0474 2C FF FF      mov b, [bp + -1] ; length
0075   0477 F9            leave
0076   0478 09            ret
0077   0479             _strcat:
0078   0479 D2            push bp
0079   047A 9B            mov bp, sp
0080   047B 52 02 00      sub sp, 2 ; dest_len
0081   047E 52 02 00      sub sp, 2 ; i
0082   0481 FA 07 00      lea d, [bp + 7] ; dest
0083   0484 2A            mov b, [d]
0084   0485 FD AB         swp b
0085   0487 D8            push b
0086   0488 07 2F 04      call _strlen
0087   048B 51 02 00      add sp, 2
0088   048E D7            push a
0089   048F 11            mov a, b
0090   0490 45 FF FF      mov [bp + -1], a ; dest_len
0091   0493 E4            pop a
0092   0494             _for2_init:
0093   0494 26 00 00      mov b, 0
0094   0497 D7            push a
0095   0498 11            mov a, b
0096   0499 45 FD FF      mov [bp + -3], a ; i
0097   049C E4            pop a
0098   049D             _for2_cond:
0099   049D FA 05 00      lea d, [bp + 5] ; src
0100   04A0 2A            mov b, [d]
0101   04A1 D7            push a
0102   04A2 11            mov a, b
0103   04A3 2C FD FF      mov b, [bp + -3] ; i
0104   04A6 54            add a, b
0105   04A7 27            mov b, a
0106   04A8 E4            pop a
0107   04A9 74            mov d, b
0108   04AA D7            push a
0109   04AB 11            mov a, b
0110   04AC 26 00 00      mov b, 0
0111   04AF B0            cmp a, b
0112   04B0 0E            lodflgs
0113   04B1 87 01         and al, %00000001
0114   04B3 8F 01         xor al, %00000001 ; !=
0115   04B5 B9 00         cmp al, 0
0116   04B7 0E            lodflgs
0117   04B8 96            not al
0118   04B9 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0119   04BB 22 00         mov ah, 0
0120   04BD 27            mov b, a
0121   04BE E4            pop a
0122   04BF C0 00 00      cmp b, 0
0123   04C2 C6 F6 04      je _for2_exit
0124   04C5             _for2_block:
0125   04C5 FA 07 00      lea d, [bp + 7] ; dest
0126   04C8 2A            mov b, [d]
0127   04C9 D7            push a
0128   04CA 11            mov a, b
0129   04CB 2C FF FF      mov b, [bp + -1] ; dest_len
0130   04CE 54            add a, b
0131   04CF 27            mov b, a
0132   04D0 11            mov a, b
0133   04D1 2C FD FF      mov b, [bp + -3] ; i
0134   04D4 54            add a, b
0135   04D5 27            mov b, a
0136   04D6 E4            pop a
0137   04D7 74            mov d, b
0138   04D8 FA 05 00      lea d, [bp + 5] ; src
0139   04DB 2A            mov b, [d]
0140   04DC D7            push a
0141   04DD 11            mov a, b
0142   04DE 2C FD FF      mov b, [bp + -3] ; i
0143   04E1 54            add a, b
0144   04E2 27            mov b, a
0145   04E3 E4            pop a
0146   04E4 74            mov d, b
0147   04E5 2A            mov b, [d]
0148   04E6 11            mov a, b
0149   04E7 43            mov [d], a
0150   04E8             _for2_update:
0151   04E8 2C FD FF      mov b, [bp + -3] ; i
0152   04EB FD 77         inc b
0153   04ED D7            push a
0154   04EE 11            mov a, b
0155   04EF 45 FD FF      mov [bp + -3], a ; i
0156   04F2 E4            pop a
0157   04F3 0A 9D 04      jmp _for2_cond
0158   04F6             _for2_exit:
0159   04F6 FA 07 00      lea d, [bp + 7] ; dest
0160   04F9 2A            mov b, [d]
0161   04FA D7            push a
0162   04FB 11            mov a, b
0163   04FC 2C FF FF      mov b, [bp + -1] ; dest_len
0164   04FF 54            add a, b
0165   0500 27            mov b, a
0166   0501 11            mov a, b
0167   0502 2C FD FF      mov b, [bp + -3] ; i
0168   0505 54            add a, b
0169   0506 27            mov b, a
0170   0507 E4            pop a
0171   0508 74            mov d, b
0172   0509 26 00 00      mov b, 0
0173   050C 11            mov a, b
0174   050D 43            mov [d], a
0175   050E FA 07 00      lea d, [bp + 7] ; dest
0176   0511 2A            mov b, [d]
0177   0512 F9            leave
0178   0513 09            ret
0179   0514             scann:
0180   0514 D2            push bp
0181   0515 9B            mov bp, sp
0182   0516 52 02 00      sub sp, 2 ; m
0183   0519             
0184   0519             ; --- BEGIN INLINE ASM BLOCK
0185   0519 07 DA 08      call scan_u16d
0186   051C 45 FF FF      mov [bp + -1], a
0187   051F             ; --- END INLINE ASM BLOCK
0188   051F             
0189   051F FA 05 00      lea d, [bp + 5] ; n
0190   0522 2A            mov b, [d]
0191   0523 74            mov d, b
0192   0524 2C FF FF      mov b, [bp + -1] ; m
0193   0527 11            mov a, b
0194   0528 43            mov [d], a
0195   0529 F9            leave
0196   052A 09            ret
0197   052B             printn:
0198   052B D2            push bp
0199   052C 9B            mov bp, sp
0200   052D             
0201   052D             ; --- BEGIN INLINE ASM BLOCK
0202   052D 17 05 00      mov a, [bp + 5]
0203   0530 07 05 08      call print_u16d
0204   0533             ; --- END INLINE ASM BLOCK
0205   0533             
0206   0533 F9            leave
0207   0534 09            ret
0208   0535             print:
0209   0535 D2            push bp
0210   0536 9B            mov bp, sp
0211   0537             
0212   0537             ; --- BEGIN INLINE ASM BLOCK
0213   0537 17 05 00      mov a, [bp + 5]
0214   053A 3C            mov d, a
0215   053B 07 DC 07      call puts
0216   053E             ; --- END INLINE ASM BLOCK
0217   053E             
0218   053E F9            leave
0219   053F 09            ret
0220   0540             ; --- END TEXT BLOCK
0221   0540             
0222   0540             ; --- BEGIN DATA BLOCK
0223   0540             s1_data: 
0224   0540 48 00 65 00 .dw 'H', 'e', 'l', 'l', 'o', 0,
0224   0544 6C 00 6C 00 
0224   0548 6F 00 00 00 
0225   054C 00 00 00 00 .fill 44, 0
0225   0550 00 00 00 00 
0225   0554 00 00 00 00 
0225   0558 00 00 00 00 
0225   055C 00 00 00 00 
0225   0560 00 00 00 00 
0225   0564 00 00 00 00 
0225   0568 00 00 00 00 
0225   056C 00 00 00 00 
0225   0570 00 00 00 00 
0225   0574 00 00 00 00 
0226   0578 40 05       s1: .dw s1_data
0227   057A 2E 20 4D 79 s2_data: .db ". My name is Sol-1.", 0
0227   057E 20 6E 61 6D 
0227   0582 65 20 69 73 
0227   0586 20 53 6F 6C 
0227   058A 2D 31 2E 00 
0228   058E 7A 05       s2: .dw s2_data
0229   0590             ; --- END DATA BLOCK
0230   0590             
0231   0590             ; --- BEGIN INCLUDE BLOCK
0232   0590             .include "lib/stdio.asm"
0001+  0590             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0590             ; stdio.s
0003+  0590             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0590             .include "lib/string.asm"
0001++ 0590             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0590             ; string.s
0003++ 0590             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0590             
0005++ 0590             
0006++ 0590             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0590             ; strrev
0008++ 0590             ; reverse a string
0009++ 0590             ; D = string address
0010++ 0590             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0590             ; 01234
0012++ 0590             strrev:
0013++ 0590 4B          	pusha
0014++ 0591 07 D7 05    	call strlen	; length in C
0015++ 0594 12          	mov a, c
0016++ 0595 AF 01 00    	cmp a, 1
0017++ 0598 D0 B2 05    	jleu strrev_end	; check string length. string len must be > 1
0018++ 059B 7D          	dec a
0019++ 059C FD 4E       	mov si, d	; beginning of string
0020++ 059E FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 05A0 59          	add d, a	; end of string
0022++ 05A1 12          	mov a, c
0023++ 05A2 FD 9B       	shr a		; divide by 2
0024++ 05A4 39          	mov c, a	; C now counts the steps
0025++ 05A5             strrev_L0:
0026++ 05A5 32          	mov bl, [d]	; save load right-side char into BL
0027++ 05A6 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 05A7 3E          	mov [d], al	; store left char into right side
0029++ 05A8 1B          	mov al, bl
0030++ 05A9 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 05AA 7E          	dec c
0032++ 05AB 7F          	dec d
0033++ 05AC C2 00 00    	cmp c, 0
0034++ 05AF C7 A5 05    	jne strrev_L0
0035++ 05B2             strrev_end:
0036++ 05B2 4C          	popa
0037++ 05B3 09          	ret
0038++ 05B4             	
0039++ 05B4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 05B4             ; strchr
0041++ 05B4             ; search string in D for char in AL
0042++ 05B4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 05B4             strchr:
0044++ 05B4             strchr_L0:
0045++ 05B4 32          	mov bl, [d]
0046++ 05B5 C1 00       	cmp bl, 0
0047++ 05B7 C6 C2 05    	je strchr_end
0048++ 05BA BA          	cmp al, bl
0049++ 05BB C6 C2 05    	je strchr_end
0050++ 05BE 79          	inc d
0051++ 05BF 0A B4 05    	jmp strchr_L0
0052++ 05C2             strchr_end:
0053++ 05C2 1B          	mov al, bl
0054++ 05C3 09          	ret
0055++ 05C4             
0056++ 05C4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 05C4             ; strstr
0058++ 05C4             ; find sub-string
0059++ 05C4             ; str1 in SI
0060++ 05C4             ; str2 in DI
0061++ 05C4             ; SI points to end of source string
0062++ 05C4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 05C4             strstr:
0064++ 05C4 DB          	push al
0065++ 05C5 DA          	push d
0066++ 05C6 E3          	push di
0067++ 05C7             strstr_loop:
0068++ 05C7 F3          	cmpsb					; compare a byte of the strings
0069++ 05C8 C7 D3 05    	jne strstr_ret
0070++ 05CB FC 00 00    	lea d, [di + 0]
0071++ 05CE BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 05D0 C7 C7 05    	jne strstr_loop				; equal chars but not at end
0073++ 05D3             strstr_ret:
0074++ 05D3 F0          	pop di
0075++ 05D4 E7          	pop d
0076++ 05D5 E8          	pop al
0077++ 05D6 09          	ret
0078++ 05D7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 05D7             ; length of null terminated string
0080++ 05D7             ; result in C
0081++ 05D7             ; pointer in D
0082++ 05D7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 05D7             strlen:
0084++ 05D7 DA          	push d
0085++ 05D8 38 00 00    	mov c, 0
0086++ 05DB             strlen_L1:
0087++ 05DB BD 00       	cmp byte [d], 0
0088++ 05DD C6 E5 05    	je strlen_ret
0089++ 05E0 79          	inc d
0090++ 05E1 78          	inc c
0091++ 05E2 0A DB 05    	jmp strlen_L1
0092++ 05E5             strlen_ret:
0093++ 05E5 E7          	pop d
0094++ 05E6 09          	ret
0095++ 05E7             
0096++ 05E7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 05E7             ; STRCMP
0098++ 05E7             ; compare two strings
0099++ 05E7             ; str1 in SI
0100++ 05E7             ; str2 in DI
0101++ 05E7             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 05E7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 05E7             strcmp:
0104++ 05E7 DB          	push al
0105++ 05E8 DA          	push d
0106++ 05E9 E3          	push di
0107++ 05EA E2          	push si
0108++ 05EB             strcmp_loop:
0109++ 05EB F3          	cmpsb					; compare a byte of the strings
0110++ 05EC C7 F7 05    	jne strcmp_ret
0111++ 05EF FB FF FF    	lea d, [si +- 1]
0112++ 05F2 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 05F4 C7 EB 05    	jne strcmp_loop				; equal chars but not at end
0114++ 05F7             strcmp_ret:
0115++ 05F7 EF          	pop si
0116++ 05F8 F0          	pop di
0117++ 05F9 E7          	pop d
0118++ 05FA E8          	pop al
0119++ 05FB 09          	ret
0120++ 05FC             
0121++ 05FC             
0122++ 05FC             ; STRCPY
0123++ 05FC             ; copy null terminated string from SI to DI
0124++ 05FC             ; source in SI
0125++ 05FC             ; destination in DI
0126++ 05FC             strcpy:
0127++ 05FC E2          	push si
0128++ 05FD E3          	push di
0129++ 05FE DB          	push al
0130++ 05FF             strcpy_L1:
0131++ 05FF F6          	lodsb
0132++ 0600 F7          	stosb
0133++ 0601 B9 00       	cmp al, 0
0134++ 0603 C7 FF 05    	jne strcpy_L1
0135++ 0606             strcpy_end:
0136++ 0606 E8          	pop al
0137++ 0607 F0          	pop di
0138++ 0608 EF          	pop si
0139++ 0609 09          	ret
0140++ 060A             
0141++ 060A             ; STRCAT
0142++ 060A             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 060A             ; source in SI
0144++ 060A             ; destination in DI
0145++ 060A             strcat:
0146++ 060A E2          	push si
0147++ 060B E3          	push di
0148++ 060C D7          	push a
0149++ 060D DA          	push d
0150++ 060E 50          	mov a, di
0151++ 060F 3C          	mov d, a
0152++ 0610             strcat_goto_end_L1:
0153++ 0610 BD 00       	cmp byte[d], 0
0154++ 0612 C6 19 06    	je strcat_start
0155++ 0615 79          	inc d
0156++ 0616 0A 10 06    	jmp strcat_goto_end_L1
0157++ 0619             strcat_start:
0158++ 0619 FD 50       	mov di, d
0159++ 061B             strcat_L1:
0160++ 061B F6          	lodsb
0161++ 061C F7          	stosb
0162++ 061D B9 00       	cmp al, 0
0163++ 061F C7 1B 06    	jne strcat_L1
0164++ 0622             strcat_end:
0165++ 0622 E7          	pop d
0166++ 0623 E4          	pop a
0167++ 0624 F0          	pop di
0168++ 0625 EF          	pop si
0169++ 0626 09          	ret
0005+  0627             
0006+  0627 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  062B 34 35 36 37 
0006+  062F 38 39 41 42 
0006+  0633 43 44 45 46 
0007+  0637 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  063B 1B 5B 48 00 
0008+  063F             
0009+  063F 01 00       table_power:.dw 1
0010+  0641 0A 00       			.dw 10
0011+  0643 64 00       			.dw 100
0012+  0645 E8 03       			.dw 1000
0013+  0647 10 27       			.dw 10000
0014+  0649             
0015+  0649             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  0649             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  0649             ; ASCII in BL
0018+  0649             ; result in AL
0019+  0649             ; ascii for F = 0100 0110
0020+  0649             ; ascii for 9 = 0011 1001
0021+  0649             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  0649             hex_ascii_encode:
0023+  0649 1B          	mov al, bl
0024+  064A 93 40       	test al, $40				; test if letter or number
0025+  064C C7 52 06    	jnz hex_letter
0026+  064F 87 0F       	and al, $0F				; get number
0027+  0651 09          	ret
0028+  0652             hex_letter:
0029+  0652 87 0F       	and al, $0F				; get letter
0030+  0654 6A 09       	add al, 9
0031+  0656 09          	ret
0032+  0657             
0033+  0657             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  0657             ; ATOI
0035+  0657             ; 2 letter hex string in B
0036+  0657             ; 8bit integer returned in AL
0037+  0657             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0657             atoi:
0039+  0657 D8          	push b
0040+  0658 07 49 06    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  065B 30          	mov bl, bh
0042+  065C DB          	push al					; save a
0043+  065D 07 49 06    	call hex_ascii_encode
0044+  0660 EA          	pop bl	
0045+  0661 FD 9E 04    	shl al, 4
0046+  0664 8C          	or al, bl
0047+  0665 E5          	pop b
0048+  0666 09          	ret	
0049+  0667             
0050+  0667             
0051+  0667             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  0667             ; printf
0053+  0667             ; no need for explanations!
0054+  0667             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0667             printf:
0056+  0667 09          	ret
0057+  0668             
0058+  0668             
0059+  0668             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  0668             ; scanf
0061+  0668             ; no need for explanations!
0062+  0668             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  0668             scanf:
0064+  0668 09          	ret
0065+  0669             
0066+  0669             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  0669             ; ITOA
0068+  0669             ; 8bit value in BL
0069+  0669             ; 2 byte ASCII result in A
0070+  0669             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  0669             itoa:
0072+  0669 DA          	push d
0073+  066A D8          	push b
0074+  066B A7 00       	mov bh, 0
0075+  066D FD A4 04    	shr bl, 4	
0076+  0670 74          	mov d, b
0077+  0671 1F 27 06    	mov al, [d + s_hex_digits]
0078+  0674 23          	mov ah, al
0079+  0675             	
0080+  0675 E5          	pop b
0081+  0676 D8          	push b
0082+  0677 A7 00       	mov bh, 0
0083+  0679 FD 87 0F    	and bl, $0F
0084+  067C 74          	mov d, b
0085+  067D 1F 27 06    	mov al, [d + s_hex_digits]
0086+  0680 E5          	pop b
0087+  0681 E7          	pop d
0088+  0682 09          	ret
0089+  0683             
0090+  0683             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  0683             ; HEX STRING TO BINARY
0092+  0683             ; di = destination address
0093+  0683             ; si = source
0094+  0683             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  0683             hex_to_int:
0096+  0683             hex_to_int_L1:
0097+  0683 F6          	lodsb					; load from [SI] to AL
0098+  0684 B9 00       	cmp al, 0				; check if ASCII 0
0099+  0686 C6 93 06    	jz hex_to_int_ret
0100+  0689 36          	mov bh, al
0101+  068A F6          	lodsb
0102+  068B 2F          	mov bl, al
0103+  068C 07 57 06    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  068F F7          	stosb					; store AL to [DI]
0105+  0690 0A 83 06    	jmp hex_to_int_L1
0106+  0693             hex_to_int_ret:
0107+  0693 09          	ret		
0108+  0694             
0109+  0694             
0110+  0694             
0111+  0694             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  0694             ; GETCHAR
0113+  0694             ; char in ah
0114+  0694             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  0694             getchar:
0116+  0694 DB          	push al
0117+  0695             getchar_retry:
0118+  0695 FD 0C       	sti
0119+  0697 19 01       	mov al, 1
0120+  0699 05 03       	syscall sys_io			; receive in AH
0121+  069B B9 00       	cmp al, 0			; check if any char was receive
0122+  069D C6 95 06    	je getchar_retry
0123+  06A0 E8          	pop al
0124+  06A1 09          	ret
0125+  06A2             
0126+  06A2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  06A2             ; PUTCHAR
0128+  06A2             ; char in ah
0129+  06A2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  06A2             putchar:
0131+  06A2 D7          	push a
0132+  06A3 19 00       	mov al, 0
0133+  06A5 05 03       	syscall sys_io			; char in AH
0134+  06A7 E4          	pop a
0135+  06A8 09          	ret
0136+  06A9             
0137+  06A9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  06A9             ;; INPUT A STRING
0139+  06A9             ;; terminates with null
0140+  06A9             ;; pointer in D
0141+  06A9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  06A9             gets:
0143+  06A9 D7          	push a
0144+  06AA DA          	push d
0145+  06AB             gets_loop:
0146+  06AB FD 0C       	sti
0147+  06AD 19 01       	mov al, 1
0148+  06AF 05 03       	syscall sys_io			; receive in AH
0149+  06B1 B9 00       	cmp al, 0				; check error code (AL)
0150+  06B3 C6 AB 06    	je gets_loop			; if no char received, retry
0151+  06B6             
0152+  06B6 76 1B       	cmp ah, 27
0153+  06B8 C6 D9 06    	je gets_telnet_escape
0154+  06BB 76 0A       	cmp ah, $0A				; LF
0155+  06BD C6 32 07    	je gets_end
0156+  06C0 76 0D       	cmp ah, $0D				; CR
0157+  06C2 C6 32 07    	je gets_end
0158+  06C5 76 5C       	cmp ah, $5C				; '\\'
0159+  06C7 C6 09 07    	je gets_escape
0160+  06CA             	
0161+  06CA 76 08       	cmp ah, $08			; check for backspace
0162+  06CC C6 D5 06    	je gets_backspace
0163+  06CF             
0164+  06CF 1A          	mov al, ah
0165+  06D0 3E          	mov [d], al
0166+  06D1 79          	inc d
0167+  06D2 0A AB 06    	jmp gets_loop
0168+  06D5             gets_backspace:
0169+  06D5 7F          	dec d
0170+  06D6 0A AB 06    	jmp gets_loop
0171+  06D9             gets_telnet_escape:
0172+  06D9 FD 0C       	sti
0173+  06DB 19 01       	mov al, 1
0174+  06DD 05 03       	syscall sys_io				; receive in AH without echo
0175+  06DF B9 00       	cmp al, 0					; check error code (AL)
0176+  06E1 C6 D9 06    	je gets_telnet_escape		; if no char received, retry
0177+  06E4 76 5B       	cmp ah, '['
0178+  06E6 C7 AB 06    	jne gets_loop
0179+  06E9             gets_telnet_escape_phase2:
0180+  06E9 FD 0C       	sti
0181+  06EB 19 01       	mov al, 1
0182+  06ED 05 03       	syscall sys_io					; receive in AH without echo
0183+  06EF B9 00       	cmp al, 0						; check error code (AL)
0184+  06F1 C6 E9 06    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  06F4 76 44       	cmp ah, 'D'
0186+  06F6 C6 01 07    	je gets_left_arrow
0187+  06F9 76 43       	cmp ah, 'C'
0188+  06FB C6 05 07    	je gets_right_arrow
0189+  06FE 0A AB 06    	jmp gets_loop
0190+  0701             gets_left_arrow:
0191+  0701 7F          	dec d
0192+  0702 0A AB 06    	jmp gets_loop
0193+  0705             gets_right_arrow:
0194+  0705 79          	inc d
0195+  0706 0A AB 06    	jmp gets_loop
0196+  0709             gets_escape:
0197+  0709 FD 0C       	sti
0198+  070B 19 01       	mov al, 1
0199+  070D 05 03       	syscall sys_io			; receive in AH
0200+  070F B9 00       	cmp al, 0				; check error code (AL)
0201+  0711 C6 09 07    	je gets_escape			; if no char received, retry
0202+  0714 76 6E       	cmp ah, 'n'
0203+  0716 C6 24 07    	je gets_LF
0204+  0719 76 72       	cmp ah, 'r'
0205+  071B C6 2B 07    	je gets_CR
0206+  071E 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  071F 3E          	mov [d], al
0208+  0720 79          	inc d
0209+  0721 0A AB 06    	jmp gets_loop
0210+  0724             gets_LF:
0211+  0724 19 0A       	mov al, $0A
0212+  0726 3E          	mov [d], al
0213+  0727 79          	inc d
0214+  0728 0A AB 06    	jmp gets_loop
0215+  072B             gets_CR:
0216+  072B 19 0D       	mov al, $0D
0217+  072D 3E          	mov [d], al
0218+  072E 79          	inc d
0219+  072F 0A AB 06    	jmp gets_loop
0220+  0732             gets_end:
0221+  0732 19 00       	mov al, 0
0222+  0734 3E          	mov [d], al				; terminate string
0223+  0735 E7          	pop d
0224+  0736 E4          	pop a
0225+  0737 09          	ret
0226+  0738             
0227+  0738             
0228+  0738             
0229+  0738             
0230+  0738             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  0738             ;; INPUT TEXT
0232+  0738             ;; terminated with CTRL+D
0233+  0738             ;; pointer in D
0234+  0738             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  0738             gettxt:
0236+  0738 D7          	push a
0237+  0739 DA          	push d
0238+  073A             gettxt_loop:
0239+  073A 19 01       	mov al, 1
0240+  073C 05 03       	syscall sys_io			; receive in AH
0241+  073E B9 00       	cmp al, 0				; check error code (AL)
0242+  0740 C6 3A 07    	je gettxt_loop		; if no char received, retry
0243+  0743 76 04       	cmp ah, 4			; EOT
0244+  0745 C6 83 07    	je gettxt_end
0245+  0748 76 08       	cmp ah, $08			; check for backspace
0246+  074A C6 7F 07    	je gettxt_backspace
0247+  074D 76 5C       	cmp ah, $5C				; '\\'
0248+  074F C6 58 07    	je gettxt_escape
0249+  0752 1A          	mov al, ah
0250+  0753 3E          	mov [d], al
0251+  0754 79          	inc d
0252+  0755 0A 3A 07    	jmp gettxt_loop
0253+  0758             gettxt_escape:
0254+  0758 19 01       	mov al, 1
0255+  075A 05 03       	syscall sys_io			; receive in AH
0256+  075C B9 00       	cmp al, 0				; check error code (AL)
0257+  075E C6 58 07    	je gettxt_escape		; if no char received, retry
0258+  0761 76 6E       	cmp ah, 'n'
0259+  0763 C6 71 07    	je gettxt_LF
0260+  0766 76 72       	cmp ah, 'r'
0261+  0768 C6 78 07    	je gettxt_CR
0262+  076B 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  076C 3E          	mov [d], al
0264+  076D 79          	inc d
0265+  076E 0A 3A 07    	jmp gettxt_loop
0266+  0771             gettxt_LF:
0267+  0771 19 0A       	mov al, $0A
0268+  0773 3E          	mov [d], al
0269+  0774 79          	inc d
0270+  0775 0A 3A 07    	jmp gettxt_loop
0271+  0778             gettxt_CR:
0272+  0778 19 0D       	mov al, $0D
0273+  077A 3E          	mov [d], al
0274+  077B 79          	inc d
0275+  077C 0A 3A 07    	jmp gettxt_loop
0276+  077F             gettxt_backspace:
0277+  077F 7F          	dec d
0278+  0780 0A 3A 07    	jmp gettxt_loop
0279+  0783             gettxt_end:
0280+  0783 19 00       	mov al, 0
0281+  0785 3E          	mov [d], al				; terminate string
0282+  0786 E7          	pop d
0283+  0787 E4          	pop a
0284+  0788 09          	ret
0285+  0789             
0286+  0789             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  0789             ; PRINT NEW LINE
0288+  0789             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  0789             printnl:
0290+  0789 D7          	push a
0291+  078A 10 00 0A    	mov a, $0A00
0292+  078D 05 03       	syscall sys_io
0293+  078F 10 00 0D    	mov a, $0D00
0294+  0792 05 03       	syscall sys_io
0295+  0794 E4          	pop a
0296+  0795 09          	ret
0297+  0796             
0298+  0796             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  0796             ; strtoint
0300+  0796             ; 4 digit hex string number in d
0301+  0796             ; integer returned in A
0302+  0796             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  0796             strtointx:
0304+  0796 D8          	push b
0305+  0797 32          	mov bl, [d]
0306+  0798 37          	mov bh, bl
0307+  0799 33 01 00    	mov bl, [d + 1]
0308+  079C 07 57 06    	call atoi				; convert to int in AL
0309+  079F 23          	mov ah, al				; move to AH
0310+  07A0 33 02 00    	mov bl, [d + 2]
0311+  07A3 37          	mov bh, bl
0312+  07A4 33 03 00    	mov bl, [d + 3]
0313+  07A7 07 57 06    	call atoi				; convert to int in AL
0314+  07AA E5          	pop b
0315+  07AB 09          	ret
0316+  07AC             
0317+  07AC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  07AC             ; strtoint
0319+  07AC             ; 5 digit base10 string number in d
0320+  07AC             ; integer returned in A
0321+  07AC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  07AC             strtoint:
0323+  07AC E2          	push si
0324+  07AD D8          	push b
0325+  07AE D9          	push c
0326+  07AF DA          	push d
0327+  07B0 07 D7 05    	call strlen			; get string length in C
0328+  07B3 7E          	dec c
0329+  07B4 FD 4E       	mov si, d
0330+  07B6 12          	mov a, c
0331+  07B7 FD 99       	shl a
0332+  07B9 3B 3F 06    	mov d, table_power
0333+  07BC 59          	add d, a
0334+  07BD 38 00 00    	mov c, 0
0335+  07C0             strtoint_L0:
0336+  07C0 F6          	lodsb			; load ASCII to al
0337+  07C1 B9 00       	cmp al, 0
0338+  07C3 C6 D6 07    	je strtoint_end
0339+  07C6 6F 30       	sub al, $30		; make into integer
0340+  07C8 22 00       	mov ah, 0
0341+  07CA 2A          	mov b, [d]
0342+  07CB AC          	mul a, b			; result in B since it fits in 16bits
0343+  07CC 11          	mov a, b
0344+  07CD 28          	mov b, c
0345+  07CE 54          	add a, b
0346+  07CF 39          	mov c, a
0347+  07D0 63 02 00    	sub d, 2
0348+  07D3 0A C0 07    	jmp strtoint_L0
0349+  07D6             strtoint_end:
0350+  07D6 12          	mov a, c
0351+  07D7 E7          	pop d
0352+  07D8 E6          	pop c
0353+  07D9 E5          	pop b
0354+  07DA EF          	pop si
0355+  07DB 09          	ret
0356+  07DC             
0357+  07DC             
0358+  07DC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  07DC             ; PRINT NULL TERMINATED STRING
0360+  07DC             ; pointer in D
0361+  07DC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  07DC             puts:
0363+  07DC D7          	push a
0364+  07DD DA          	push d
0365+  07DE             puts_L1:
0366+  07DE 1E          	mov al, [d]
0367+  07DF B9 00       	cmp al, 0
0368+  07E1 C6 ED 07    	jz puts_END
0369+  07E4 23          	mov ah, al
0370+  07E5 19 00       	mov al, 0
0371+  07E7 05 03       	syscall sys_io
0372+  07E9 79          	inc d
0373+  07EA 0A DE 07    	jmp puts_L1
0374+  07ED             puts_END:
0375+  07ED E7          	pop d
0376+  07EE E4          	pop a
0377+  07EF 09          	ret
0378+  07F0             
0379+  07F0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  07F0             ; PRINT N SIZE STRING
0381+  07F0             ; pointer in D
0382+  07F0             ; size in C
0383+  07F0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  07F0             putsn:
0385+  07F0 DB          	push al
0386+  07F1 DA          	push d
0387+  07F2 D9          	push c
0388+  07F3             putsn_L0:
0389+  07F3 1E          	mov al, [d]
0390+  07F4 23          	mov ah, al
0391+  07F5 19 00       	mov al, 0
0392+  07F7 05 03       	syscall sys_io
0393+  07F9 79          	inc d
0394+  07FA 7E          	dec c	
0395+  07FB C2 00 00    	cmp c, 0
0396+  07FE C7 F3 07    	jne putsn_L0
0397+  0801             putsn_end:
0398+  0801 E6          	pop c
0399+  0802 E7          	pop d
0400+  0803 E8          	pop al
0401+  0804 09          	ret
0402+  0805             
0403+  0805             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  0805             ; print 16bit decimal number
0405+  0805             ; input number in A
0406+  0805             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  0805             print_u16d:
0408+  0805 D7          	push a
0409+  0806 D8          	push b
0410+  0807 26 10 27    	mov b, 10000
0411+  080A AE          	div a, b			; get 10000 coeff.
0412+  080B 07 31 08    	call print_number
0413+  080E 11          	mov a, b
0414+  080F 26 E8 03    	mov b, 1000
0415+  0812 AE          	div a, b			; get 10000 coeff.
0416+  0813 07 31 08    	call print_number
0417+  0816 11          	mov a, b
0418+  0817 26 64 00    	mov b, 100
0419+  081A AE          	div a, b
0420+  081B 07 31 08    	call print_number
0421+  081E 11          	mov a, b
0422+  081F 26 0A 00    	mov b, 10
0423+  0822 AE          	div a, b
0424+  0823 07 31 08    	call print_number
0425+  0826 11          	mov a, b
0426+  0827 6A 30       	add al, $30
0427+  0829 23          	mov ah, al
0428+  082A 19 00       	mov al, 0
0429+  082C 05 03       	syscall sys_io	; print coeff
0430+  082E E5          	pop b
0431+  082F E4          	pop a
0432+  0830 09          	ret
0433+  0831             
0434+  0831             
0435+  0831             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  0831             ; if A == 0, print space
0437+  0831             ; else print A
0438+  0831             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0439+  0831             print_number:
0440+  0831 6A 30       	add al, $30
0441+  0833 23          	mov ah, al
0442+  0834 07 A2 06    	call putchar
0443+  0837 09          	ret
0444+  0838             
0445+  0838             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0446+  0838             ; PRINT 16BIT HEX INTEGER
0447+  0838             ; integer value in reg B
0448+  0838             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  0838             print_u16x:
0450+  0838 D7          	push a
0451+  0839 D8          	push b
0452+  083A DD          	push bl
0453+  083B 30          	mov bl, bh
0454+  083C 07 69 06    	call itoa				; convert bh to char in A
0455+  083F 2F          	mov bl, al				; save al
0456+  0840 19 00       	mov al, 0
0457+  0842 05 03       	syscall sys_io				; display AH
0458+  0844 24          	mov ah, bl				; retrieve al
0459+  0845 19 00       	mov al, 0
0460+  0847 05 03       	syscall sys_io				; display AL
0461+  0849             
0462+  0849 EA          	pop bl
0463+  084A 07 69 06    	call itoa				; convert bh to char in A
0464+  084D 2F          	mov bl, al				; save al
0465+  084E 19 00       	mov al, 0
0466+  0850 05 03       	syscall sys_io				; display AH
0467+  0852 24          	mov ah, bl				; retrieve al
0468+  0853 19 00       	mov al, 0
0469+  0855 05 03       	syscall sys_io				; display AL
0470+  0857             
0471+  0857 E5          	pop b
0472+  0858 E4          	pop a
0473+  0859 09          	ret
0474+  085A             
0475+  085A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  085A             ; INPUT 16BIT HEX INTEGER
0477+  085A             ; read 16bit integer into A
0478+  085A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  085A             scan_u16x:
0480+  085A F8 10 00    	enter 16
0481+  085D D8          	push b
0482+  085E DA          	push d
0483+  085F             
0484+  085F FA F1 FF    	lea d, [bp + -15]
0485+  0862 07 A9 06    	call gets				; get number
0486+  0865             
0487+  0865 32          	mov bl, [d]
0488+  0866 37          	mov bh, bl
0489+  0867 33 01 00    	mov bl, [d + 1]
0490+  086A 07 57 06    	call atoi				; convert to int in AL
0491+  086D 23          	mov ah, al				; move to AH
0492+  086E             
0493+  086E 33 02 00    	mov bl, [d + 2]
0494+  0871 37          	mov bh, bl
0495+  0872 33 03 00    	mov bl, [d + 3]
0496+  0875 07 57 06    	call atoi				; convert to int in AL
0497+  0878             
0498+  0878 E7          	pop d
0499+  0879 E5          	pop b
0500+  087A F9          	leave
0501+  087B 09          	ret
0502+  087C             
0503+  087C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0504+  087C             ; PRINT 8bit HEX INTEGER
0505+  087C             ; integer value in reg bl
0506+  087C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  087C             print_u8x:
0508+  087C D7          	push a
0509+  087D DD          	push bl
0510+  087E             
0511+  087E 07 69 06    	call itoa				; convert bl to char in A
0512+  0881 2F          	mov bl, al				; save al
0513+  0882 19 00       	mov al, 0
0514+  0884 05 03       	syscall sys_io				; display AH
0515+  0886 24          	mov ah, bl				; retrieve al
0516+  0887 19 00       	mov al, 0
0517+  0889 05 03       	syscall sys_io				; display AL
0518+  088B             
0519+  088B EA          	pop bl
0520+  088C E4          	pop a
0521+  088D 09          	ret
0522+  088E             
0523+  088E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0524+  088E             ; print 8bit decimal unsigned number
0525+  088E             ; input number in AL
0526+  088E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  088E             print_u8d:
0528+  088E D7          	push a
0529+  088F D8          	push b
0530+  0890             
0531+  0890 22 00       	mov ah, 0
0532+  0892 26 64 00    	mov b, 100
0533+  0895 AE          	div a, b
0534+  0896 D8          	push b			; save remainder
0535+  0897 B9 00       	cmp al, 0
0536+  0899 C6 A3 08    	je skip100
0537+  089C 6A 30       	add al, $30
0538+  089E 23          	mov ah, al
0539+  089F 19 00       	mov al, 0
0540+  08A1 05 03       	syscall sys_io	; print coeff
0541+  08A3             skip100:
0542+  08A3 E4          	pop a
0543+  08A4 22 00       	mov ah, 0
0544+  08A6 26 0A 00    	mov b, 10
0545+  08A9 AE          	div a, b
0546+  08AA D8          	push b			; save remainder
0547+  08AB B9 00       	cmp al, 0
0548+  08AD C6 B7 08    	je skip10
0549+  08B0 6A 30       	add al, $30
0550+  08B2 23          	mov ah, al
0551+  08B3 19 00       	mov al, 0
0552+  08B5 05 03       	syscall sys_io	; print coeff
0553+  08B7             skip10:
0554+  08B7 E4          	pop a
0555+  08B8 1B          	mov al, bl
0556+  08B9 6A 30       	add al, $30
0557+  08BB 23          	mov ah, al
0558+  08BC 19 00       	mov al, 0
0559+  08BE 05 03       	syscall sys_io	; print coeff
0560+  08C0 E5          	pop b
0561+  08C1 E4          	pop a
0562+  08C2 09          	ret
0563+  08C3             
0564+  08C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0565+  08C3             ; INPUT 8BIT HEX INTEGER
0566+  08C3             ; read 8bit integer into AL
0567+  08C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  08C3             scan_u8x:
0569+  08C3 F8 04 00    	enter 4
0570+  08C6 D8          	push b
0571+  08C7 DA          	push d
0572+  08C8             
0573+  08C8 FA FD FF    	lea d, [bp + -3]
0574+  08CB 07 A9 06    	call gets				; get number
0575+  08CE             
0576+  08CE 32          	mov bl, [d]
0577+  08CF 37          	mov bh, bl
0578+  08D0 33 01 00    	mov bl, [d + 1]
0579+  08D3 07 57 06    	call atoi				; convert to int in AL
0580+  08D6             
0581+  08D6 E7          	pop d
0582+  08D7 E5          	pop b
0583+  08D8 F9          	leave
0584+  08D9 09          	ret
0585+  08DA             
0586+  08DA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  08DA             ; input decimal number
0588+  08DA             ; result in A
0589+  08DA             ; 655'\0'
0590+  08DA             ; low--------high
0591+  08DA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0592+  08DA             scan_u16d:
0593+  08DA F8 08 00    	enter 8
0594+  08DD E2          	push si
0595+  08DE D8          	push b
0596+  08DF D9          	push c
0597+  08E0 DA          	push d
0598+  08E1 FA F9 FF    	lea d, [bp +- 7]
0599+  08E4 07 A9 06    	call gets
0600+  08E7 07 D7 05    	call strlen			; get string length in C
0601+  08EA 7E          	dec c
0602+  08EB FD 4E       	mov si, d
0603+  08ED 12          	mov a, c
0604+  08EE FD 99       	shl a
0605+  08F0 3B 3F 06    	mov d, table_power
0606+  08F3 59          	add d, a
0607+  08F4 38 00 00    	mov c, 0
0608+  08F7             mul_loop:
0609+  08F7 F6          	lodsb			; load ASCII to al
0610+  08F8 B9 00       	cmp al, 0
0611+  08FA C6 0D 09    	je mul_exit
0612+  08FD 6F 30       	sub al, $30		; make into integer
0613+  08FF 22 00       	mov ah, 0
0614+  0901 2A          	mov b, [d]
0615+  0902 AC          	mul a, b			; result in B since it fits in 16bits
0616+  0903 11          	mov a, b
0617+  0904 28          	mov b, c
0618+  0905 54          	add a, b
0619+  0906 39          	mov c, a
0620+  0907 63 02 00    	sub d, 2
0621+  090A 0A F7 08    	jmp mul_loop
0622+  090D             mul_exit:
0623+  090D 12          	mov a, c
0624+  090E E7          	pop d
0625+  090F E6          	pop c
0626+  0910 E5          	pop b
0627+  0911 EF          	pop si
0628+  0912 F9          	leave
0629+  0913 09          	ret
0233   0914             ; --- END INCLUDE BLOCK
0234   0914             
0235   0914             
0236   0914             .end
tasm: Number of errors = 0
