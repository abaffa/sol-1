0001   0000             ; --- FILENAME: sort.c
0002   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0400             .org PROC_TEXT_ORG
0004   0400             
0005   0400             ; --- BEGIN TEXT BLOCK
0006   0400             
0007   0400             main:
0008   0400 D2            push bp
0009   0401 9B            mov bp, sp
0010   0402 52 02 00      sub sp, 2 ; n
0011   0405 52 02 00      sub sp, 2 ; i
0012   0408 52 64 00      sub sp, 100 ; s
0013   040B 26 77 08      mov b, __string_0 ; "Enter the elements of the array as a string: "
0014   040E FD AB         swp b
0015   0410 D8            push b
0016   0411 07 6C 08      call print
0017   0414 51 02 00      add sp, 2
0018   0417 FA 99 FF      lea d, [bp + -103] ; s beginning on the stack
0019   041A 2D            mov b, d
0020   041B FD AB         swp b
0021   041D D8            push b
0022   041E 07 31 06      call _gets
0023   0421 51 02 00      add sp, 2
0024   0424 26 A5 08      mov b, __string_1 ; "OK.\n"
0025   0427 FD AB         swp b
0026   0429 D8            push b
0027   042A 07 6C 08      call print
0028   042D 51 02 00      add sp, 2
0029   0430 FA 99 FF      lea d, [bp + -103] ; s beginning on the stack
0030   0433 2D            mov b, d
0031   0434 FD AB         swp b
0032   0436 D8            push b
0033   0437 07 3C 06      call _strlen
0034   043A 51 02 00      add sp, 2
0035   043D D7            push a
0036   043E 11            mov a, b
0037   043F 45 FF FF      mov [bp + -1], a ; n
0038   0442 E4            pop a
0039   0443 26 AA 08      mov b, __string_2 ; "Now sorting...\n"
0040   0446 FD AB         swp b
0041   0448 D8            push b
0042   0449 07 6C 08      call print
0043   044C 51 02 00      add sp, 2
0044   044F FA 99 FF      lea d, [bp + -103] ; s beginning on the stack
0045   0452 2D            mov b, d
0046   0453 FD AB         swp b
0047   0455 D8            push b
0048   0456 2C FF FF      mov b, [bp + -1] ; n
0049   0459 FD AB         swp b
0050   045B D8            push b
0051   045C 07 D5 04      call bubble_sort
0052   045F 51 04 00      add sp, 4
0053   0462 26 BA 08      mov b, __string_3 ; "Sorted array: "
0054   0465 FD AB         swp b
0055   0467 D8            push b
0056   0468 07 6C 08      call print
0057   046B 51 02 00      add sp, 2
0058   046E             _for1_init:
0059   046E 26 00 00      mov b, 0
0060   0471 D7            push a
0061   0472 11            mov a, b
0062   0473 45 FD FF      mov [bp + -3], a ; i
0063   0476 E4            pop a
0064   0477             _for1_cond:
0065   0477 2C FD FF      mov b, [bp + -3] ; i
0066   047A D7            push a
0067   047B 11            mov a, b
0068   047C 2C FF FF      mov b, [bp + -1] ; n
0069   047F B0            cmp a, b
0070   0480 0E            lodflgs
0071   0481 2F            mov bl, al
0072   0482 FD A2 03      shr al, 3
0073   0485 FD A4 02      shr bl, 2
0074   0488 FD 87 01      and bl, %00000001
0075   048B 90            xor al, bl ; < (signed)
0076   048C 22 00         mov ah, 0
0077   048E 27            mov b, a
0078   048F E4            pop a
0079   0490 C0 00 00      cmp b, 0
0080   0493 C6 C3 04      je _for1_exit
0081   0496             _for1_block:
0082   0496 FA 99 FF      lea d, [bp + -103] ; s beginning on the stack
0083   0499 2D            mov b, d
0084   049A D7            push a
0085   049B 74            mov d, b
0086   049C DA            push d
0087   049D 2C FD FF      mov b, [bp + -3] ; i
0088   04A0 E7            pop d
0089   04A1 10 01 00      mov a, 1
0090   04A4 AC            mul a, b
0091   04A5 5A            add d, b
0092   04A6 E4            pop a
0093   04A7 32            mov bl, [d]
0094   04A8 A7 00         mov bh, 0
0095   04AA DD            push bl
0096   04AB 07 51 08      call _putchar
0097   04AE 51 01 00      add sp, 1
0098   04B1             _for1_update:
0099   04B1 2C FD FF      mov b, [bp + -3] ; i
0100   04B4 D7            push a
0101   04B5 11            mov a, b
0102   04B6 FD 77         inc b
0103   04B8 D7            push a
0104   04B9 11            mov a, b
0105   04BA 45 FD FF      mov [bp + -3], a ; i
0106   04BD E4            pop a
0107   04BE 27            mov b, a
0108   04BF E4            pop a
0109   04C0 0A 77 04      jmp _for1_cond
0110   04C3             _for1_exit:
0111   04C3 26 C9 08      mov b, __string_4 ; "\n"
0112   04C6 FD AB         swp b
0113   04C8 D8            push b
0114   04C9 07 6C 08      call print
0115   04CC 51 02 00      add sp, 2
0116   04CF 26 00 00      mov b, 0
0117   04D2 F9            leave
0118   04D3 05 0B         syscall sys_terminate_proc
0119   04D5             
0120   04D5             bubble_sort:
0121   04D5 D2            push bp
0122   04D6 9B            mov bp, sp
0123   04D7 52 02 00      sub sp, 2 ; i
0124   04DA 52 02 00      sub sp, 2 ; j
0125   04DD 52 01 00      sub sp, 1 ; temp
0126   04E0             _for2_init:
0127   04E0 26 00 00      mov b, 0
0128   04E3 D7            push a
0129   04E4 11            mov a, b
0130   04E5 45 FF FF      mov [bp + -1], a ; i
0131   04E8 E4            pop a
0132   04E9             _for2_cond:
0133   04E9 2C FF FF      mov b, [bp + -1] ; i
0134   04EC D7            push a
0135   04ED 11            mov a, b
0136   04EE 2C 05 00      mov b, [bp + 5] ; n
0137   04F1 D7            push a
0138   04F2 11            mov a, b
0139   04F3 26 01 00      mov b, 1
0140   04F6 60            sub a, b
0141   04F7 27            mov b, a
0142   04F8 E4            pop a
0143   04F9 B0            cmp a, b
0144   04FA 0E            lodflgs
0145   04FB 2F            mov bl, al
0146   04FC FD A2 03      shr al, 3
0147   04FF FD A4 02      shr bl, 2
0148   0502 FD 87 01      and bl, %00000001
0149   0505 90            xor al, bl ; < (signed)
0150   0506 22 00         mov ah, 0
0151   0508 27            mov b, a
0152   0509 E4            pop a
0153   050A C0 00 00      cmp b, 0
0154   050D C6 2F 06      je _for2_exit
0155   0510             _for2_block:
0156   0510             _for3_init:
0157   0510 26 00 00      mov b, 0
0158   0513 D7            push a
0159   0514 11            mov a, b
0160   0515 45 FD FF      mov [bp + -3], a ; j
0161   0518 E4            pop a
0162   0519             _for3_cond:
0163   0519 2C FD FF      mov b, [bp + -3] ; j
0164   051C D7            push a
0165   051D 11            mov a, b
0166   051E 2C 05 00      mov b, [bp + 5] ; n
0167   0521 D7            push a
0168   0522 11            mov a, b
0169   0523 2C FF FF      mov b, [bp + -1] ; i
0170   0526 60            sub a, b
0171   0527 27            mov b, a
0172   0528 E4            pop a
0173   0529 D7            push a
0174   052A 11            mov a, b
0175   052B 26 01 00      mov b, 1
0176   052E 60            sub a, b
0177   052F 27            mov b, a
0178   0530 E4            pop a
0179   0531 B0            cmp a, b
0180   0532 0E            lodflgs
0181   0533 2F            mov bl, al
0182   0534 FD A2 03      shr al, 3
0183   0537 FD A4 02      shr bl, 2
0184   053A FD 87 01      and bl, %00000001
0185   053D 90            xor al, bl ; < (signed)
0186   053E 22 00         mov ah, 0
0187   0540 27            mov b, a
0188   0541 E4            pop a
0189   0542 C0 00 00      cmp b, 0
0190   0545 C6 1D 06      je _for3_exit
0191   0548             _for3_block:
0192   0548             _if4_cond:
0193   0548 FA 07 00      lea d, [bp + 7] ; arr
0194   054B 2A            mov b, [d]
0195   054C D7            push a
0196   054D 74            mov d, b
0197   054E DA            push d
0198   054F 2C FD FF      mov b, [bp + -3] ; j
0199   0552 E7            pop d
0200   0553 10 01 00      mov a, 1
0201   0556 AC            mul a, b
0202   0557 5A            add d, b
0203   0558 E4            pop a
0204   0559 32            mov bl, [d]
0205   055A A7 00         mov bh, 0
0206   055C D7            push a
0207   055D 11            mov a, b
0208   055E FA 07 00      lea d, [bp + 7] ; arr
0209   0561 2A            mov b, [d]
0210   0562 D7            push a
0211   0563 74            mov d, b
0212   0564 DA            push d
0213   0565 2C FD FF      mov b, [bp + -3] ; j
0214   0568 D7            push a
0215   0569 11            mov a, b
0216   056A 26 01 00      mov b, 1
0217   056D 54            add a, b
0218   056E 27            mov b, a
0219   056F E4            pop a
0220   0570 E7            pop d
0221   0571 10 01 00      mov a, 1
0222   0574 AC            mul a, b
0223   0575 5A            add d, b
0224   0576 E4            pop a
0225   0577 32            mov bl, [d]
0226   0578 A7 00         mov bh, 0
0227   057A B0            cmp a, b
0228   057B 0E            lodflgs
0229   057C 2F            mov bl, al
0230   057D FD 78         mov g, a
0231   057F FD A2 03      shr al, 3
0232   0582 FD A4 02      shr bl, 2
0233   0585 FD 87 01      and bl, %00000001
0234   0588 90            xor al, bl
0235   0589 FD 27         mov b, g
0236   058B FD 87 01      and bl, %00000001
0237   058E 8C            or al, bl
0238   058F 8F 01         xor al, %00000001 ; > (signed)
0239   0591 22 00         mov ah, 0
0240   0593 27            mov b, a
0241   0594 E4            pop a
0242   0595 C0 00 00      cmp b, 0
0243   0598 C6 0B 06      je _if4_exit
0244   059B             _if4_true:
0245   059B FA 07 00      lea d, [bp + 7] ; arr
0246   059E 2A            mov b, [d]
0247   059F D7            push a
0248   05A0 74            mov d, b
0249   05A1 DA            push d
0250   05A2 2C FD FF      mov b, [bp + -3] ; j
0251   05A5 E7            pop d
0252   05A6 10 01 00      mov a, 1
0253   05A9 AC            mul a, b
0254   05AA 5A            add d, b
0255   05AB E4            pop a
0256   05AC 32            mov bl, [d]
0257   05AD A7 00         mov bh, 0
0258   05AF DB            push al
0259   05B0 1B            mov al, bl
0260   05B1 40 FC FF      mov [bp + -4], al ; temp
0261   05B4 E8            pop al
0262   05B5 FA 07 00      lea d, [bp + 7] ; arr
0263   05B8 2A            mov b, [d]
0264   05B9 D7            push a
0265   05BA 74            mov d, b
0266   05BB DA            push d
0267   05BC 2C FD FF      mov b, [bp + -3] ; j
0268   05BF E7            pop d
0269   05C0 10 01 00      mov a, 1
0270   05C3 AC            mul a, b
0271   05C4 5A            add d, b
0272   05C5 E4            pop a
0273   05C6 DA            push d
0274   05C7 FA 07 00      lea d, [bp + 7] ; arr
0275   05CA 2A            mov b, [d]
0276   05CB D7            push a
0277   05CC 74            mov d, b
0278   05CD DA            push d
0279   05CE 2C FD FF      mov b, [bp + -3] ; j
0280   05D1 D7            push a
0281   05D2 11            mov a, b
0282   05D3 26 01 00      mov b, 1
0283   05D6 54            add a, b
0284   05D7 27            mov b, a
0285   05D8 E4            pop a
0286   05D9 E7            pop d
0287   05DA 10 01 00      mov a, 1
0288   05DD AC            mul a, b
0289   05DE 5A            add d, b
0290   05DF E4            pop a
0291   05E0 32            mov bl, [d]
0292   05E1 A7 00         mov bh, 0
0293   05E3 E7            pop d
0294   05E4 FD 3E         mov [d], bl
0295   05E6 FA 07 00      lea d, [bp + 7] ; arr
0296   05E9 2A            mov b, [d]
0297   05EA D7            push a
0298   05EB 74            mov d, b
0299   05EC DA            push d
0300   05ED 2C FD FF      mov b, [bp + -3] ; j
0301   05F0 D7            push a
0302   05F1 11            mov a, b
0303   05F2 26 01 00      mov b, 1
0304   05F5 54            add a, b
0305   05F6 27            mov b, a
0306   05F7 E4            pop a
0307   05F8 E7            pop d
0308   05F9 10 01 00      mov a, 1
0309   05FC AC            mul a, b
0310   05FD 5A            add d, b
0311   05FE E4            pop a
0312   05FF DA            push d
0313   0600 34 FC FF      mov bl, [bp + -4] ; temp
0314   0603 A7 00         mov bh, 0
0315   0605 E7            pop d
0316   0606 FD 3E         mov [d], bl
0317   0608 0A 0B 06      jmp _if4_exit
0318   060B             _if4_exit:
0319   060B             _for3_update:
0320   060B 2C FD FF      mov b, [bp + -3] ; j
0321   060E D7            push a
0322   060F 11            mov a, b
0323   0610 FD 77         inc b
0324   0612 D7            push a
0325   0613 11            mov a, b
0326   0614 45 FD FF      mov [bp + -3], a ; j
0327   0617 E4            pop a
0328   0618 27            mov b, a
0329   0619 E4            pop a
0330   061A 0A 19 05      jmp _for3_cond
0331   061D             _for3_exit:
0332   061D             _for2_update:
0333   061D 2C FF FF      mov b, [bp + -1] ; i
0334   0620 D7            push a
0335   0621 11            mov a, b
0336   0622 FD 77         inc b
0337   0624 D7            push a
0338   0625 11            mov a, b
0339   0626 45 FF FF      mov [bp + -1], a ; i
0340   0629 E4            pop a
0341   062A 27            mov b, a
0342   062B E4            pop a
0343   062C 0A E9 04      jmp _for2_cond
0344   062F             _for2_exit:
0345   062F F9            leave
0346   0630 09            ret
0347   0631             
0348   0631             _gets:
0349   0631 D2            push bp
0350   0632 9B            mov bp, sp
0351   0633             
0352   0633             ; --- BEGIN INLINE ASM BLOCK
0353   0633 17 05 00      mov a, [bp + 5]
0354   0636 3C            mov d, a
0355   0637 07 E4 09      call gets
0356   063A             ; --- END INLINE ASM BLOCK
0357   063A             
0358   063A F9            leave
0359   063B 09            ret
0360   063C             
0361   063C             _strlen:
0362   063C D2            push bp
0363   063D 9B            mov bp, sp
0364   063E 52 02 00      sub sp, 2 ; length
0365   0641 26 00 00      mov b, 0
0366   0644 D7            push a
0367   0645 11            mov a, b
0368   0646 45 FF FF      mov [bp + -1], a ; length
0369   0649 E4            pop a
0370   064A             _while5_cond:
0371   064A FA 05 00      lea d, [bp + 5] ; str
0372   064D 2A            mov b, [d]
0373   064E D7            push a
0374   064F 74            mov d, b
0375   0650 DA            push d
0376   0651 2C FF FF      mov b, [bp + -1] ; length
0377   0654 E7            pop d
0378   0655 10 01 00      mov a, 1
0379   0658 AC            mul a, b
0380   0659 5A            add d, b
0381   065A E4            pop a
0382   065B 32            mov bl, [d]
0383   065C A7 00         mov bh, 0
0384   065E D7            push a
0385   065F 11            mov a, b
0386   0660 26 00 00      mov b, 0
0387   0663 B0            cmp a, b
0388   0664 0E            lodflgs
0389   0665 87 01         and al, %00000001
0390   0667 8F 01         xor al, %00000001 ; !=
0391   0669 22 00         mov ah, 0
0392   066B 27            mov b, a
0393   066C E4            pop a
0394   066D C0 00 00      cmp b, 0
0395   0670 C6 85 06      je _while5_exit
0396   0673             _while5_block:
0397   0673 2C FF FF      mov b, [bp + -1] ; length
0398   0676 D7            push a
0399   0677 11            mov a, b
0400   0678 FD 77         inc b
0401   067A D7            push a
0402   067B 11            mov a, b
0403   067C 45 FF FF      mov [bp + -1], a ; length
0404   067F E4            pop a
0405   0680 27            mov b, a
0406   0681 E4            pop a
0407   0682 0A 4A 06      jmp _while5_cond
0408   0685             _while5_exit:
0409   0685 2C FF FF      mov b, [bp + -1] ; length
0410   0688 F9            leave
0411   0689 09            ret
0412   068A             
0413   068A             print_num:
0414   068A D2            push bp
0415   068B 9B            mov bp, sp
0416   068C 52 05 00      sub sp, 5 ; digits
0417   068F 52 02 00      sub sp, 2 ; i
0418   0692 26 00 00      mov b, 0
0419   0695 D7            push a
0420   0696 11            mov a, b
0421   0697 45 FA FF      mov [bp + -6], a ; i
0422   069A E4            pop a
0423   069B             _if6_cond:
0424   069B 2C 05 00      mov b, [bp + 5] ; num
0425   069E D7            push a
0426   069F 11            mov a, b
0427   06A0 26 00 00      mov b, 0
0428   06A3 B0            cmp a, b
0429   06A4 0E            lodflgs
0430   06A5 87 01         and al, %00000001 ; ==
0431   06A7 22 00         mov ah, 0
0432   06A9 27            mov b, a
0433   06AA E4            pop a
0434   06AB C0 00 00      cmp b, 0
0435   06AE C6 C0 06      je _if6_exit
0436   06B1             _if6_true:
0437   06B1 26 30 00      mov b, '0'
0438   06B4 DD            push bl
0439   06B5 07 51 08      call _putchar
0440   06B8 51 01 00      add sp, 1
0441   06BB F9            leave
0442   06BC 09            ret
0443   06BD 0A C0 06      jmp _if6_exit
0444   06C0             _if6_exit:
0445   06C0             _while7_cond:
0446   06C0 2C 05 00      mov b, [bp + 5] ; num
0447   06C3 D7            push a
0448   06C4 11            mov a, b
0449   06C5 26 00 00      mov b, 0
0450   06C8 B0            cmp a, b
0451   06C9 0E            lodflgs
0452   06CA 2F            mov bl, al
0453   06CB FD 78         mov g, a
0454   06CD FD A2 03      shr al, 3
0455   06D0 FD A4 02      shr bl, 2
0456   06D3 FD 87 01      and bl, %00000001
0457   06D6 90            xor al, bl
0458   06D7 FD 27         mov b, g
0459   06D9 FD 87 01      and bl, %00000001
0460   06DC 8C            or al, bl
0461   06DD 8F 01         xor al, %00000001 ; > (signed)
0462   06DF 22 00         mov ah, 0
0463   06E1 27            mov b, a
0464   06E2 E4            pop a
0465   06E3 C0 00 00      cmp b, 0
0466   06E6 C6 37 07      je _while7_exit
0467   06E9             _while7_block:
0468   06E9 FA FC FF      lea d, [bp + -4] ; digits beginning on the stack
0469   06EC 2D            mov b, d
0470   06ED D7            push a
0471   06EE 74            mov d, b
0472   06EF DA            push d
0473   06F0 2C FA FF      mov b, [bp + -6] ; i
0474   06F3 E7            pop d
0475   06F4 10 01 00      mov a, 1
0476   06F7 AC            mul a, b
0477   06F8 5A            add d, b
0478   06F9 E4            pop a
0479   06FA DA            push d
0480   06FB 26 30 00      mov b, '0'
0481   06FE D7            push a
0482   06FF 11            mov a, b
0483   0700 2C 05 00      mov b, [bp + 5] ; num
0484   0703 D7            push a
0485   0704 11            mov a, b
0486   0705 26 0A 00      mov b, 10
0487   0708 AE            div a, b
0488   0709 E4            pop a
0489   070A 54            add a, b
0490   070B 27            mov b, a
0491   070C E4            pop a
0492   070D E7            pop d
0493   070E FD 3E         mov [d], bl
0494   0710 2C 05 00      mov b, [bp + 5] ; num
0495   0713 D7            push a
0496   0714 11            mov a, b
0497   0715 26 0A 00      mov b, 10
0498   0718 AE            div a, b
0499   0719 FD 78         mov g, a
0500   071B 11            mov a, b
0501   071C FD 27         mov b, g
0502   071E E4            pop a
0503   071F D7            push a
0504   0720 11            mov a, b
0505   0721 45 05 00      mov [bp + 5], a ; num
0506   0724 E4            pop a
0507   0725 2C FA FF      mov b, [bp + -6] ; i
0508   0728 D7            push a
0509   0729 11            mov a, b
0510   072A FD 77         inc b
0511   072C D7            push a
0512   072D 11            mov a, b
0513   072E 45 FA FF      mov [bp + -6], a ; i
0514   0731 E4            pop a
0515   0732 27            mov b, a
0516   0733 E4            pop a
0517   0734 0A C0 06      jmp _while7_cond
0518   0737             _while7_exit:
0519   0737             _while8_cond:
0520   0737 2C FA FF      mov b, [bp + -6] ; i
0521   073A D7            push a
0522   073B 11            mov a, b
0523   073C 26 00 00      mov b, 0
0524   073F B0            cmp a, b
0525   0740 0E            lodflgs
0526   0741 2F            mov bl, al
0527   0742 FD 78         mov g, a
0528   0744 FD A2 03      shr al, 3
0529   0747 FD A4 02      shr bl, 2
0530   074A FD 87 01      and bl, %00000001
0531   074D 90            xor al, bl
0532   074E FD 27         mov b, g
0533   0750 FD 87 01      and bl, %00000001
0534   0753 8C            or al, bl
0535   0754 8F 01         xor al, %00000001 ; > (signed)
0536   0756 22 00         mov ah, 0
0537   0758 27            mov b, a
0538   0759 E4            pop a
0539   075A C0 00 00      cmp b, 0
0540   075D C6 8D 07      je _while8_exit
0541   0760             _while8_block:
0542   0760 2C FA FF      mov b, [bp + -6] ; i
0543   0763 D7            push a
0544   0764 11            mov a, b
0545   0765 FD 7D         dec b
0546   0767 D7            push a
0547   0768 11            mov a, b
0548   0769 45 FA FF      mov [bp + -6], a ; i
0549   076C E4            pop a
0550   076D 27            mov b, a
0551   076E E4            pop a
0552   076F FA FC FF      lea d, [bp + -4] ; digits beginning on the stack
0553   0772 2D            mov b, d
0554   0773 D7            push a
0555   0774 74            mov d, b
0556   0775 DA            push d
0557   0776 2C FA FF      mov b, [bp + -6] ; i
0558   0779 E7            pop d
0559   077A 10 01 00      mov a, 1
0560   077D AC            mul a, b
0561   077E 5A            add d, b
0562   077F E4            pop a
0563   0780 32            mov bl, [d]
0564   0781 A7 00         mov bh, 0
0565   0783 DD            push bl
0566   0784 07 51 08      call _putchar
0567   0787 51 01 00      add sp, 1
0568   078A 0A 37 07      jmp _while8_cond
0569   078D             _while8_exit:
0570   078D F9            leave
0571   078E 09            ret
0572   078F             
0573   078F             integer_square_root:
0574   078F D2            push bp
0575   0790 9B            mov bp, sp
0576   0791             _if9_cond:
0577   0791 2C 05 00      mov b, [bp + 5] ; n
0578   0794 D7            push a
0579   0795 11            mov a, b
0580   0796 26 01 00      mov b, 1
0581   0799 B0            cmp a, b
0582   079A 0E            lodflgs
0583   079B 2F            mov bl, al
0584   079C FD 78         mov g, a
0585   079E FD A2 03      shr al, 3
0586   07A1 FD A4 02      shr bl, 2
0587   07A4 FD 87 01      and bl, %00000001
0588   07A7 90            xor al, bl
0589   07A8 FD 27         mov b, g
0590   07AA FD 87 01      and bl, %00000001
0591   07AD 8C            or al, bl ; <= (signed)
0592   07AE 22 00         mov ah, 0
0593   07B0 27            mov b, a
0594   07B1 E4            pop a
0595   07B2 C0 00 00      cmp b, 0
0596   07B5 C6 C0 07      je _if9_exit
0597   07B8             _if9_true:
0598   07B8 2C 05 00      mov b, [bp + 5] ; n
0599   07BB F9            leave
0600   07BC 09            ret
0601   07BD 0A C0 07      jmp _if9_exit
0602   07C0             _if9_exit:
0603   07C0 52 02 00      sub sp, 2 ; x
0604   07C3 52 02 00      sub sp, 2 ; y
0605   07C6 2C 05 00      mov b, [bp + 5] ; n
0606   07C9 D7            push a
0607   07CA 11            mov a, b
0608   07CB 45 FF FF      mov [bp + -1], a ; x
0609   07CE E4            pop a
0610   07CF 2C FF FF      mov b, [bp + -1] ; x
0611   07D2 D7            push a
0612   07D3 11            mov a, b
0613   07D4 2C 05 00      mov b, [bp + 5] ; n
0614   07D7 D7            push a
0615   07D8 11            mov a, b
0616   07D9 2C FF FF      mov b, [bp + -1] ; x
0617   07DC AE            div a, b
0618   07DD FD 78         mov g, a
0619   07DF 11            mov a, b
0620   07E0 FD 27         mov b, g
0621   07E2 E4            pop a
0622   07E3 54            add a, b
0623   07E4 27            mov b, a
0624   07E5 E4            pop a
0625   07E6 D7            push a
0626   07E7 11            mov a, b
0627   07E8 26 02 00      mov b, 2
0628   07EB AE            div a, b
0629   07EC FD 78         mov g, a
0630   07EE 11            mov a, b
0631   07EF FD 27         mov b, g
0632   07F1 E4            pop a
0633   07F2 D7            push a
0634   07F3 11            mov a, b
0635   07F4 45 FD FF      mov [bp + -3], a ; y
0636   07F7 E4            pop a
0637   07F8             _while10_cond:
0638   07F8 2C FD FF      mov b, [bp + -3] ; y
0639   07FB D7            push a
0640   07FC 11            mov a, b
0641   07FD 2C FF FF      mov b, [bp + -1] ; x
0642   0800 B0            cmp a, b
0643   0801 0E            lodflgs
0644   0802 2F            mov bl, al
0645   0803 FD A2 03      shr al, 3
0646   0806 FD A4 02      shr bl, 2
0647   0809 FD 87 01      and bl, %00000001
0648   080C 90            xor al, bl ; < (signed)
0649   080D 22 00         mov ah, 0
0650   080F 27            mov b, a
0651   0810 E4            pop a
0652   0811 C0 00 00      cmp b, 0
0653   0814 C6 4C 08      je _while10_exit
0654   0817             _while10_block:
0655   0817 2C FD FF      mov b, [bp + -3] ; y
0656   081A D7            push a
0657   081B 11            mov a, b
0658   081C 45 FF FF      mov [bp + -1], a ; x
0659   081F E4            pop a
0660   0820 2C FF FF      mov b, [bp + -1] ; x
0661   0823 D7            push a
0662   0824 11            mov a, b
0663   0825 2C 05 00      mov b, [bp + 5] ; n
0664   0828 D7            push a
0665   0829 11            mov a, b
0666   082A 2C FF FF      mov b, [bp + -1] ; x
0667   082D AE            div a, b
0668   082E FD 78         mov g, a
0669   0830 11            mov a, b
0670   0831 FD 27         mov b, g
0671   0833 E4            pop a
0672   0834 54            add a, b
0673   0835 27            mov b, a
0674   0836 E4            pop a
0675   0837 D7            push a
0676   0838 11            mov a, b
0677   0839 26 02 00      mov b, 2
0678   083C AE            div a, b
0679   083D FD 78         mov g, a
0680   083F 11            mov a, b
0681   0840 FD 27         mov b, g
0682   0842 E4            pop a
0683   0843 D7            push a
0684   0844 11            mov a, b
0685   0845 45 FD FF      mov [bp + -3], a ; y
0686   0848 E4            pop a
0687   0849 0A F8 07      jmp _while10_cond
0688   084C             _while10_exit:
0689   084C 2C FF FF      mov b, [bp + -1] ; x
0690   084F F9            leave
0691   0850 09            ret
0692   0851             
0693   0851             _putchar:
0694   0851 D2            push bp
0695   0852 9B            mov bp, sp
0696   0853             
0697   0853             ; --- BEGIN INLINE ASM BLOCK
0698   0853 20 05 00      mov al, [bp + 5]
0699   0856 23            mov ah, al
0700   0857 07 DD 09      call putchar
0701   085A             ; --- END INLINE ASM BLOCK
0702   085A             
0703   085A F9            leave
0704   085B 09            ret
0705   085C             
0706   085C             scann:
0707   085C D2            push bp
0708   085D 9B            mov bp, sp
0709   085E 52 02 00      sub sp, 2 ; m
0710   0861             
0711   0861             ; --- BEGIN INLINE ASM BLOCK
0712   0861 07 15 0C      call scan_u16d
0713   0864 45 FF FF      mov [bp + -1], a
0714   0867             ; --- END INLINE ASM BLOCK
0715   0867             
0716   0867 2C FF FF      mov b, [bp + -1] ; m
0717   086A F9            leave
0718   086B 09            ret
0719   086C             
0720   086C             print:
0721   086C D2            push bp
0722   086D 9B            mov bp, sp
0723   086E             
0724   086E             ; --- BEGIN INLINE ASM BLOCK
0725   086E 17 05 00      mov a, [bp + 5]
0726   0871 3C            mov d, a
0727   0872 07 17 0B      call puts
0728   0875             ; --- END INLINE ASM BLOCK
0729   0875             
0730   0875 F9            leave
0731   0876 09            ret
0732   0877             ; --- END TEXT BLOCK
0733   0877             
0734   0877             ; --- BEGIN DATA BLOCK
0735   0877 45 6E 74 65 __string_0: .db "Enter the elements of the array as a string: ", 0
0735   087B 72 20 74 68 
0735   087F 65 20 65 6C 
0735   0883 65 6D 65 6E 
0735   0887 74 73 20 6F 
0735   088B 66 20 74 68 
0735   088F 65 20 61 72 
0735   0893 72 61 79 20 
0735   0897 61 73 20 61 
0735   089B 20 73 74 72 
0735   089F 69 6E 67 3A 
0735   08A3 20 00 
0736   08A5 4F 4B 2E 0A __string_1: .db "OK.\n", 0
0736   08A9 00 
0737   08AA 4E 6F 77 20 __string_2: .db "Now sorting...\n", 0
0737   08AE 73 6F 72 74 
0737   08B2 69 6E 67 2E 
0737   08B6 2E 2E 0A 00 
0738   08BA 53 6F 72 74 __string_3: .db "Sorted array: ", 0
0738   08BE 65 64 20 61 
0738   08C2 72 72 61 79 
0738   08C6 3A 20 00 
0739   08C9 0A 00       __string_4: .db "\n", 0
0740   08CB             ; --- END DATA BLOCK
0741   08CB             
0742   08CB             ; --- BEGIN INCLUDE BLOCK
0743   08CB             .include "lib/stdio.asm"
0001+  08CB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  08CB             ; stdio.s
0003+  08CB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  08CB             .include "lib/string.asm"
0001++ 08CB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 08CB             ; string.s
0003++ 08CB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 08CB             
0005++ 08CB             
0006++ 08CB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 08CB             ; strrev
0008++ 08CB             ; reverse a string
0009++ 08CB             ; D = string address
0010++ 08CB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 08CB             ; 01234
0012++ 08CB             strrev:
0013++ 08CB 4B          	pusha
0014++ 08CC 07 12 09    	call strlen	; length in C
0015++ 08CF 12          	mov a, c
0016++ 08D0 AF 01 00    	cmp a, 1
0017++ 08D3 D0 ED 08    	jleu strrev_end	; check string length. string len must be > 1
0018++ 08D6 7D          	dec a
0019++ 08D7 FD 4E       	mov si, d	; beginning of string
0020++ 08D9 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 08DB 59          	add d, a	; end of string
0022++ 08DC 12          	mov a, c
0023++ 08DD FD 9B       	shr a		; divide by 2
0024++ 08DF 39          	mov c, a	; C now counts the steps
0025++ 08E0             strrev_L0:
0026++ 08E0 32          	mov bl, [d]	; save load right-side char into BL
0027++ 08E1 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 08E2 3E          	mov [d], al	; store left char into right side
0029++ 08E3 1B          	mov al, bl
0030++ 08E4 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 08E5 7E          	dec c
0032++ 08E6 7F          	dec d
0033++ 08E7 C2 00 00    	cmp c, 0
0034++ 08EA C7 E0 08    	jne strrev_L0
0035++ 08ED             strrev_end:
0036++ 08ED 4C          	popa
0037++ 08EE 09          	ret
0038++ 08EF             	
0039++ 08EF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 08EF             ; strchr
0041++ 08EF             ; search string in D for char in AL
0042++ 08EF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 08EF             strchr:
0044++ 08EF             strchr_L0:
0045++ 08EF 32          	mov bl, [d]
0046++ 08F0 C1 00       	cmp bl, 0
0047++ 08F2 C6 FD 08    	je strchr_end
0048++ 08F5 BA          	cmp al, bl
0049++ 08F6 C6 FD 08    	je strchr_end
0050++ 08F9 79          	inc d
0051++ 08FA 0A EF 08    	jmp strchr_L0
0052++ 08FD             strchr_end:
0053++ 08FD 1B          	mov al, bl
0054++ 08FE 09          	ret
0055++ 08FF             
0056++ 08FF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 08FF             ; strstr
0058++ 08FF             ; find sub-string
0059++ 08FF             ; str1 in SI
0060++ 08FF             ; str2 in DI
0061++ 08FF             ; SI points to end of source string
0062++ 08FF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 08FF             strstr:
0064++ 08FF DB          	push al
0065++ 0900 DA          	push d
0066++ 0901 E3          	push di
0067++ 0902             strstr_loop:
0068++ 0902 F3          	cmpsb					; compare a byte of the strings
0069++ 0903 C7 0E 09    	jne strstr_ret
0070++ 0906 FC 00 00    	lea d, [di + 0]
0071++ 0909 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 090B C7 02 09    	jne strstr_loop				; equal chars but not at end
0073++ 090E             strstr_ret:
0074++ 090E F0          	pop di
0075++ 090F E7          	pop d
0076++ 0910 E8          	pop al
0077++ 0911 09          	ret
0078++ 0912             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0912             ; length of null terminated string
0080++ 0912             ; result in C
0081++ 0912             ; pointer in D
0082++ 0912             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0912             strlen:
0084++ 0912 DA          	push d
0085++ 0913 38 00 00    	mov c, 0
0086++ 0916             strlen_L1:
0087++ 0916 BD 00       	cmp byte [d], 0
0088++ 0918 C6 20 09    	je strlen_ret
0089++ 091B 79          	inc d
0090++ 091C 78          	inc c
0091++ 091D 0A 16 09    	jmp strlen_L1
0092++ 0920             strlen_ret:
0093++ 0920 E7          	pop d
0094++ 0921 09          	ret
0095++ 0922             
0096++ 0922             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0922             ; STRCMP
0098++ 0922             ; compare two strings
0099++ 0922             ; str1 in SI
0100++ 0922             ; str2 in DI
0101++ 0922             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0922             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0922             strcmp:
0104++ 0922 DB          	push al
0105++ 0923 DA          	push d
0106++ 0924 E3          	push di
0107++ 0925 E2          	push si
0108++ 0926             strcmp_loop:
0109++ 0926 F3          	cmpsb					; compare a byte of the strings
0110++ 0927 C7 32 09    	jne strcmp_ret
0111++ 092A FB FF FF    	lea d, [si +- 1]
0112++ 092D BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 092F C7 26 09    	jne strcmp_loop				; equal chars but not at end
0114++ 0932             strcmp_ret:
0115++ 0932 EF          	pop si
0116++ 0933 F0          	pop di
0117++ 0934 E7          	pop d
0118++ 0935 E8          	pop al
0119++ 0936 09          	ret
0120++ 0937             
0121++ 0937             
0122++ 0937             ; STRCPY
0123++ 0937             ; copy null terminated string from SI to DI
0124++ 0937             ; source in SI
0125++ 0937             ; destination in DI
0126++ 0937             strcpy:
0127++ 0937 E2          	push si
0128++ 0938 E3          	push di
0129++ 0939 DB          	push al
0130++ 093A             strcpy_L1:
0131++ 093A F6          	lodsb
0132++ 093B F7          	stosb
0133++ 093C B9 00       	cmp al, 0
0134++ 093E C7 3A 09    	jne strcpy_L1
0135++ 0941             strcpy_end:
0136++ 0941 E8          	pop al
0137++ 0942 F0          	pop di
0138++ 0943 EF          	pop si
0139++ 0944 09          	ret
0140++ 0945             
0141++ 0945             ; STRCAT
0142++ 0945             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0945             ; source in SI
0144++ 0945             ; destination in DI
0145++ 0945             strcat:
0146++ 0945 E2          	push si
0147++ 0946 E3          	push di
0148++ 0947 D7          	push a
0149++ 0948 DA          	push d
0150++ 0949 50          	mov a, di
0151++ 094A 3C          	mov d, a
0152++ 094B             strcat_goto_end_L1:
0153++ 094B BD 00       	cmp byte[d], 0
0154++ 094D C6 54 09    	je strcat_start
0155++ 0950 79          	inc d
0156++ 0951 0A 4B 09    	jmp strcat_goto_end_L1
0157++ 0954             strcat_start:
0158++ 0954 FD 50       	mov di, d
0159++ 0956             strcat_L1:
0160++ 0956 F6          	lodsb
0161++ 0957 F7          	stosb
0162++ 0958 B9 00       	cmp al, 0
0163++ 095A C7 56 09    	jne strcat_L1
0164++ 095D             strcat_end:
0165++ 095D E7          	pop d
0166++ 095E E4          	pop a
0167++ 095F F0          	pop di
0168++ 0960 EF          	pop si
0169++ 0961 09          	ret
0005+  0962             
0006+  0962 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  0966 34 35 36 37 
0006+  096A 38 39 41 42 
0006+  096E 43 44 45 46 
0007+  0972 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  0976 1B 5B 48 00 
0008+  097A             
0009+  097A 01 00       table_power:.dw 1
0010+  097C 0A 00       			.dw 10
0011+  097E 64 00       			.dw 100
0012+  0980 E8 03       			.dw 1000
0013+  0982 10 27       			.dw 10000
0014+  0984             
0015+  0984             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  0984             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  0984             ; ASCII in BL
0018+  0984             ; result in AL
0019+  0984             ; ascii for F = 0100 0110
0020+  0984             ; ascii for 9 = 0011 1001
0021+  0984             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  0984             hex_ascii_encode:
0023+  0984 1B          	mov al, bl
0024+  0985 93 40       	test al, $40				; test if letter or number
0025+  0987 C7 8D 09    	jnz hex_letter
0026+  098A 87 0F       	and al, $0F				; get number
0027+  098C 09          	ret
0028+  098D             hex_letter:
0029+  098D 87 0F       	and al, $0F				; get letter
0030+  098F 6A 09       	add al, 9
0031+  0991 09          	ret
0032+  0992             
0033+  0992             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  0992             ; ATOI
0035+  0992             ; 2 letter hex string in B
0036+  0992             ; 8bit integer returned in AL
0037+  0992             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0992             atoi:
0039+  0992 D8          	push b
0040+  0993 07 84 09    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  0996 30          	mov bl, bh
0042+  0997 DB          	push al					; save a
0043+  0998 07 84 09    	call hex_ascii_encode
0044+  099B EA          	pop bl	
0045+  099C FD 9E 04    	shl al, 4
0046+  099F 8C          	or al, bl
0047+  09A0 E5          	pop b
0048+  09A1 09          	ret	
0049+  09A2             
0050+  09A2             
0051+  09A2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  09A2             ; printf
0053+  09A2             ; no need for explanations!
0054+  09A2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  09A2             printf:
0056+  09A2 09          	ret
0057+  09A3             
0058+  09A3             
0059+  09A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  09A3             ; scanf
0061+  09A3             ; no need for explanations!
0062+  09A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  09A3             scanf:
0064+  09A3 09          	ret
0065+  09A4             
0066+  09A4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  09A4             ; ITOA
0068+  09A4             ; 8bit value in BL
0069+  09A4             ; 2 byte ASCII result in A
0070+  09A4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  09A4             itoa:
0072+  09A4 DA          	push d
0073+  09A5 D8          	push b
0074+  09A6 A7 00       	mov bh, 0
0075+  09A8 FD A4 04    	shr bl, 4	
0076+  09AB 74          	mov d, b
0077+  09AC 1F 62 09    	mov al, [d + s_hex_digits]
0078+  09AF 23          	mov ah, al
0079+  09B0             	
0080+  09B0 E5          	pop b
0081+  09B1 D8          	push b
0082+  09B2 A7 00       	mov bh, 0
0083+  09B4 FD 87 0F    	and bl, $0F
0084+  09B7 74          	mov d, b
0085+  09B8 1F 62 09    	mov al, [d + s_hex_digits]
0086+  09BB E5          	pop b
0087+  09BC E7          	pop d
0088+  09BD 09          	ret
0089+  09BE             
0090+  09BE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  09BE             ; HEX STRING TO BINARY
0092+  09BE             ; di = destination address
0093+  09BE             ; si = source
0094+  09BE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  09BE             hex_to_int:
0096+  09BE             hex_to_int_L1:
0097+  09BE F6          	lodsb					; load from [SI] to AL
0098+  09BF B9 00       	cmp al, 0				; check if ASCII 0
0099+  09C1 C6 CE 09    	jz hex_to_int_ret
0100+  09C4 36          	mov bh, al
0101+  09C5 F6          	lodsb
0102+  09C6 2F          	mov bl, al
0103+  09C7 07 92 09    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  09CA F7          	stosb					; store AL to [DI]
0105+  09CB 0A BE 09    	jmp hex_to_int_L1
0106+  09CE             hex_to_int_ret:
0107+  09CE 09          	ret		
0108+  09CF             
0109+  09CF             
0110+  09CF             
0111+  09CF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  09CF             ; GETCHAR
0113+  09CF             ; char in ah
0114+  09CF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  09CF             getchar:
0116+  09CF DB          	push al
0117+  09D0             getchar_retry:
0118+  09D0 FD 0C       	sti
0119+  09D2 19 01       	mov al, 1
0120+  09D4 05 03       	syscall sys_io			; receive in AH
0121+  09D6 B9 00       	cmp al, 0			; check if any char was receive
0122+  09D8 C6 D0 09    	je getchar_retry
0123+  09DB E8          	pop al
0124+  09DC 09          	ret
0125+  09DD             
0126+  09DD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  09DD             ; PUTCHAR
0128+  09DD             ; char in ah
0129+  09DD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  09DD             putchar:
0131+  09DD D7          	push a
0132+  09DE 19 00       	mov al, 0
0133+  09E0 05 03       	syscall sys_io			; char in AH
0134+  09E2 E4          	pop a
0135+  09E3 09          	ret
0136+  09E4             
0137+  09E4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  09E4             ;; INPUT A STRING
0139+  09E4             ;; terminates with null
0140+  09E4             ;; pointer in D
0141+  09E4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  09E4             gets:
0143+  09E4 D7          	push a
0144+  09E5 DA          	push d
0145+  09E6             gets_loop:
0146+  09E6 FD 0C       	sti
0147+  09E8 19 01       	mov al, 1
0148+  09EA 05 03       	syscall sys_io			; receive in AH
0149+  09EC B9 00       	cmp al, 0				; check error code (AL)
0150+  09EE C6 E6 09    	je gets_loop			; if no char received, retry
0151+  09F1             
0152+  09F1 76 1B       	cmp ah, 27
0153+  09F3 C6 14 0A    	je gets_telnet_escape
0154+  09F6 76 0A       	cmp ah, $0A				; LF
0155+  09F8 C6 6D 0A    	je gets_end
0156+  09FB 76 0D       	cmp ah, $0D				; CR
0157+  09FD C6 6D 0A    	je gets_end
0158+  0A00 76 5C       	cmp ah, $5C				; '\\'
0159+  0A02 C6 44 0A    	je gets_escape
0160+  0A05             	
0161+  0A05 76 08       	cmp ah, $08			; check for backspace
0162+  0A07 C6 10 0A    	je gets_backspace
0163+  0A0A             
0164+  0A0A 1A          	mov al, ah
0165+  0A0B 3E          	mov [d], al
0166+  0A0C 79          	inc d
0167+  0A0D 0A E6 09    	jmp gets_loop
0168+  0A10             gets_backspace:
0169+  0A10 7F          	dec d
0170+  0A11 0A E6 09    	jmp gets_loop
0171+  0A14             gets_telnet_escape:
0172+  0A14 FD 0C       	sti
0173+  0A16 19 01       	mov al, 1
0174+  0A18 05 03       	syscall sys_io				; receive in AH without echo
0175+  0A1A B9 00       	cmp al, 0					; check error code (AL)
0176+  0A1C C6 14 0A    	je gets_telnet_escape		; if no char received, retry
0177+  0A1F 76 5B       	cmp ah, '['
0178+  0A21 C7 E6 09    	jne gets_loop
0179+  0A24             gets_telnet_escape_phase2:
0180+  0A24 FD 0C       	sti
0181+  0A26 19 01       	mov al, 1
0182+  0A28 05 03       	syscall sys_io					; receive in AH without echo
0183+  0A2A B9 00       	cmp al, 0						; check error code (AL)
0184+  0A2C C6 24 0A    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  0A2F 76 44       	cmp ah, 'D'
0186+  0A31 C6 3C 0A    	je gets_left_arrow
0187+  0A34 76 43       	cmp ah, 'C'
0188+  0A36 C6 40 0A    	je gets_right_arrow
0189+  0A39 0A E6 09    	jmp gets_loop
0190+  0A3C             gets_left_arrow:
0191+  0A3C 7F          	dec d
0192+  0A3D 0A E6 09    	jmp gets_loop
0193+  0A40             gets_right_arrow:
0194+  0A40 79          	inc d
0195+  0A41 0A E6 09    	jmp gets_loop
0196+  0A44             gets_escape:
0197+  0A44 FD 0C       	sti
0198+  0A46 19 01       	mov al, 1
0199+  0A48 05 03       	syscall sys_io			; receive in AH
0200+  0A4A B9 00       	cmp al, 0				; check error code (AL)
0201+  0A4C C6 44 0A    	je gets_escape			; if no char received, retry
0202+  0A4F 76 6E       	cmp ah, 'n'
0203+  0A51 C6 5F 0A    	je gets_LF
0204+  0A54 76 72       	cmp ah, 'r'
0205+  0A56 C6 66 0A    	je gets_CR
0206+  0A59 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  0A5A 3E          	mov [d], al
0208+  0A5B 79          	inc d
0209+  0A5C 0A E6 09    	jmp gets_loop
0210+  0A5F             gets_LF:
0211+  0A5F 19 0A       	mov al, $0A
0212+  0A61 3E          	mov [d], al
0213+  0A62 79          	inc d
0214+  0A63 0A E6 09    	jmp gets_loop
0215+  0A66             gets_CR:
0216+  0A66 19 0D       	mov al, $0D
0217+  0A68 3E          	mov [d], al
0218+  0A69 79          	inc d
0219+  0A6A 0A E6 09    	jmp gets_loop
0220+  0A6D             gets_end:
0221+  0A6D 19 00       	mov al, 0
0222+  0A6F 3E          	mov [d], al				; terminate string
0223+  0A70 E7          	pop d
0224+  0A71 E4          	pop a
0225+  0A72 09          	ret
0226+  0A73             
0227+  0A73             
0228+  0A73             
0229+  0A73             
0230+  0A73             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  0A73             ;; INPUT TEXT
0232+  0A73             ;; terminated with CTRL+D
0233+  0A73             ;; pointer in D
0234+  0A73             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  0A73             gettxt:
0236+  0A73 D7          	push a
0237+  0A74 DA          	push d
0238+  0A75             gettxt_loop:
0239+  0A75 19 01       	mov al, 1
0240+  0A77 05 03       	syscall sys_io			; receive in AH
0241+  0A79 B9 00       	cmp al, 0				; check error code (AL)
0242+  0A7B C6 75 0A    	je gettxt_loop		; if no char received, retry
0243+  0A7E 76 04       	cmp ah, 4			; EOT
0244+  0A80 C6 BE 0A    	je gettxt_end
0245+  0A83 76 08       	cmp ah, $08			; check for backspace
0246+  0A85 C6 BA 0A    	je gettxt_backspace
0247+  0A88 76 5C       	cmp ah, $5C				; '\\'
0248+  0A8A C6 93 0A    	je gettxt_escape
0249+  0A8D 1A          	mov al, ah
0250+  0A8E 3E          	mov [d], al
0251+  0A8F 79          	inc d
0252+  0A90 0A 75 0A    	jmp gettxt_loop
0253+  0A93             gettxt_escape:
0254+  0A93 19 01       	mov al, 1
0255+  0A95 05 03       	syscall sys_io			; receive in AH
0256+  0A97 B9 00       	cmp al, 0				; check error code (AL)
0257+  0A99 C6 93 0A    	je gettxt_escape		; if no char received, retry
0258+  0A9C 76 6E       	cmp ah, 'n'
0259+  0A9E C6 AC 0A    	je gettxt_LF
0260+  0AA1 76 72       	cmp ah, 'r'
0261+  0AA3 C6 B3 0A    	je gettxt_CR
0262+  0AA6 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  0AA7 3E          	mov [d], al
0264+  0AA8 79          	inc d
0265+  0AA9 0A 75 0A    	jmp gettxt_loop
0266+  0AAC             gettxt_LF:
0267+  0AAC 19 0A       	mov al, $0A
0268+  0AAE 3E          	mov [d], al
0269+  0AAF 79          	inc d
0270+  0AB0 0A 75 0A    	jmp gettxt_loop
0271+  0AB3             gettxt_CR:
0272+  0AB3 19 0D       	mov al, $0D
0273+  0AB5 3E          	mov [d], al
0274+  0AB6 79          	inc d
0275+  0AB7 0A 75 0A    	jmp gettxt_loop
0276+  0ABA             gettxt_backspace:
0277+  0ABA 7F          	dec d
0278+  0ABB 0A 75 0A    	jmp gettxt_loop
0279+  0ABE             gettxt_end:
0280+  0ABE 19 00       	mov al, 0
0281+  0AC0 3E          	mov [d], al				; terminate string
0282+  0AC1 E7          	pop d
0283+  0AC2 E4          	pop a
0284+  0AC3 09          	ret
0285+  0AC4             
0286+  0AC4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  0AC4             ; PRINT NEW LINE
0288+  0AC4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  0AC4             printnl:
0290+  0AC4 D7          	push a
0291+  0AC5 10 00 0A    	mov a, $0A00
0292+  0AC8 05 03       	syscall sys_io
0293+  0ACA 10 00 0D    	mov a, $0D00
0294+  0ACD 05 03       	syscall sys_io
0295+  0ACF E4          	pop a
0296+  0AD0 09          	ret
0297+  0AD1             
0298+  0AD1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  0AD1             ; strtoint
0300+  0AD1             ; 4 digit hex string number in d
0301+  0AD1             ; integer returned in A
0302+  0AD1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  0AD1             strtointx:
0304+  0AD1 D8          	push b
0305+  0AD2 32          	mov bl, [d]
0306+  0AD3 37          	mov bh, bl
0307+  0AD4 33 01 00    	mov bl, [d + 1]
0308+  0AD7 07 92 09    	call atoi				; convert to int in AL
0309+  0ADA 23          	mov ah, al				; move to AH
0310+  0ADB 33 02 00    	mov bl, [d + 2]
0311+  0ADE 37          	mov bh, bl
0312+  0ADF 33 03 00    	mov bl, [d + 3]
0313+  0AE2 07 92 09    	call atoi				; convert to int in AL
0314+  0AE5 E5          	pop b
0315+  0AE6 09          	ret
0316+  0AE7             
0317+  0AE7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  0AE7             ; strtoint
0319+  0AE7             ; 5 digit base10 string number in d
0320+  0AE7             ; integer returned in A
0321+  0AE7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  0AE7             strtoint:
0323+  0AE7 E2          	push si
0324+  0AE8 D8          	push b
0325+  0AE9 D9          	push c
0326+  0AEA DA          	push d
0327+  0AEB 07 12 09    	call strlen			; get string length in C
0328+  0AEE 7E          	dec c
0329+  0AEF FD 4E       	mov si, d
0330+  0AF1 12          	mov a, c
0331+  0AF2 FD 99       	shl a
0332+  0AF4 3B 7A 09    	mov d, table_power
0333+  0AF7 59          	add d, a
0334+  0AF8 38 00 00    	mov c, 0
0335+  0AFB             strtoint_L0:
0336+  0AFB F6          	lodsb			; load ASCII to al
0337+  0AFC B9 00       	cmp al, 0
0338+  0AFE C6 11 0B    	je strtoint_end
0339+  0B01 6F 30       	sub al, $30		; make into integer
0340+  0B03 22 00       	mov ah, 0
0341+  0B05 2A          	mov b, [d]
0342+  0B06 AC          	mul a, b			; result in B since it fits in 16bits
0343+  0B07 11          	mov a, b
0344+  0B08 28          	mov b, c
0345+  0B09 54          	add a, b
0346+  0B0A 39          	mov c, a
0347+  0B0B 63 02 00    	sub d, 2
0348+  0B0E 0A FB 0A    	jmp strtoint_L0
0349+  0B11             strtoint_end:
0350+  0B11 12          	mov a, c
0351+  0B12 E7          	pop d
0352+  0B13 E6          	pop c
0353+  0B14 E5          	pop b
0354+  0B15 EF          	pop si
0355+  0B16 09          	ret
0356+  0B17             
0357+  0B17             
0358+  0B17             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  0B17             ; PRINT NULL TERMINATED STRING
0360+  0B17             ; pointer in D
0361+  0B17             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  0B17             puts:
0363+  0B17 D7          	push a
0364+  0B18 DA          	push d
0365+  0B19             puts_L1:
0366+  0B19 1E          	mov al, [d]
0367+  0B1A B9 00       	cmp al, 0
0368+  0B1C C6 28 0B    	jz puts_END
0369+  0B1F 23          	mov ah, al
0370+  0B20 19 00       	mov al, 0
0371+  0B22 05 03       	syscall sys_io
0372+  0B24 79          	inc d
0373+  0B25 0A 19 0B    	jmp puts_L1
0374+  0B28             puts_END:
0375+  0B28 E7          	pop d
0376+  0B29 E4          	pop a
0377+  0B2A 09          	ret
0378+  0B2B             
0379+  0B2B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  0B2B             ; PRINT N SIZE STRING
0381+  0B2B             ; pointer in D
0382+  0B2B             ; size in C
0383+  0B2B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  0B2B             putsn:
0385+  0B2B DB          	push al
0386+  0B2C DA          	push d
0387+  0B2D D9          	push c
0388+  0B2E             putsn_L0:
0389+  0B2E 1E          	mov al, [d]
0390+  0B2F 23          	mov ah, al
0391+  0B30 19 00       	mov al, 0
0392+  0B32 05 03       	syscall sys_io
0393+  0B34 79          	inc d
0394+  0B35 7E          	dec c	
0395+  0B36 C2 00 00    	cmp c, 0
0396+  0B39 C7 2E 0B    	jne putsn_L0
0397+  0B3C             putsn_end:
0398+  0B3C E6          	pop c
0399+  0B3D E7          	pop d
0400+  0B3E E8          	pop al
0401+  0B3F 09          	ret
0402+  0B40             
0403+  0B40             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  0B40             ; print 16bit decimal number
0405+  0B40             ; input number in A
0406+  0B40             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  0B40             print_u16d:
0408+  0B40 D7          	push a
0409+  0B41 D8          	push b
0410+  0B42 26 10 27    	mov b, 10000
0411+  0B45 AE          	div a, b			; get 10000 coeff.
0412+  0B46 07 6C 0B    	call print_number
0413+  0B49 11          	mov a, b
0414+  0B4A 26 E8 03    	mov b, 1000
0415+  0B4D AE          	div a, b			; get 10000 coeff.
0416+  0B4E 07 6C 0B    	call print_number
0417+  0B51 11          	mov a, b
0418+  0B52 26 64 00    	mov b, 100
0419+  0B55 AE          	div a, b
0420+  0B56 07 6C 0B    	call print_number
0421+  0B59 11          	mov a, b
0422+  0B5A 26 0A 00    	mov b, 10
0423+  0B5D AE          	div a, b
0424+  0B5E 07 6C 0B    	call print_number
0425+  0B61 11          	mov a, b
0426+  0B62 6A 30       	add al, $30
0427+  0B64 23          	mov ah, al
0428+  0B65 19 00       	mov al, 0
0429+  0B67 05 03       	syscall sys_io	; print coeff
0430+  0B69 E5          	pop b
0431+  0B6A E4          	pop a
0432+  0B6B 09          	ret
0433+  0B6C             
0434+  0B6C             
0435+  0B6C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  0B6C             ; if A == 0, print space
0437+  0B6C             ; else print A
0438+  0B6C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0439+  0B6C             print_number:
0440+  0B6C 6A 30       	add al, $30
0441+  0B6E 23          	mov ah, al
0442+  0B6F 07 DD 09    	call putchar
0443+  0B72 09          	ret
0444+  0B73             
0445+  0B73             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0446+  0B73             ; PRINT 16BIT HEX INTEGER
0447+  0B73             ; integer value in reg B
0448+  0B73             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  0B73             print_u16x:
0450+  0B73 D7          	push a
0451+  0B74 D8          	push b
0452+  0B75 DD          	push bl
0453+  0B76 30          	mov bl, bh
0454+  0B77 07 A4 09    	call itoa				; convert bh to char in A
0455+  0B7A 2F          	mov bl, al				; save al
0456+  0B7B 19 00       	mov al, 0
0457+  0B7D 05 03       	syscall sys_io				; display AH
0458+  0B7F 24          	mov ah, bl				; retrieve al
0459+  0B80 19 00       	mov al, 0
0460+  0B82 05 03       	syscall sys_io				; display AL
0461+  0B84             
0462+  0B84 EA          	pop bl
0463+  0B85 07 A4 09    	call itoa				; convert bh to char in A
0464+  0B88 2F          	mov bl, al				; save al
0465+  0B89 19 00       	mov al, 0
0466+  0B8B 05 03       	syscall sys_io				; display AH
0467+  0B8D 24          	mov ah, bl				; retrieve al
0468+  0B8E 19 00       	mov al, 0
0469+  0B90 05 03       	syscall sys_io				; display AL
0470+  0B92             
0471+  0B92 E5          	pop b
0472+  0B93 E4          	pop a
0473+  0B94 09          	ret
0474+  0B95             
0475+  0B95             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  0B95             ; INPUT 16BIT HEX INTEGER
0477+  0B95             ; read 16bit integer into A
0478+  0B95             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  0B95             scan_u16x:
0480+  0B95 F8 10 00    	enter 16
0481+  0B98 D8          	push b
0482+  0B99 DA          	push d
0483+  0B9A             
0484+  0B9A FA F1 FF    	lea d, [bp + -15]
0485+  0B9D 07 E4 09    	call gets				; get number
0486+  0BA0             
0487+  0BA0 32          	mov bl, [d]
0488+  0BA1 37          	mov bh, bl
0489+  0BA2 33 01 00    	mov bl, [d + 1]
0490+  0BA5 07 92 09    	call atoi				; convert to int in AL
0491+  0BA8 23          	mov ah, al				; move to AH
0492+  0BA9             
0493+  0BA9 33 02 00    	mov bl, [d + 2]
0494+  0BAC 37          	mov bh, bl
0495+  0BAD 33 03 00    	mov bl, [d + 3]
0496+  0BB0 07 92 09    	call atoi				; convert to int in AL
0497+  0BB3             
0498+  0BB3 E7          	pop d
0499+  0BB4 E5          	pop b
0500+  0BB5 F9          	leave
0501+  0BB6 09          	ret
0502+  0BB7             
0503+  0BB7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0504+  0BB7             ; PRINT 8bit HEX INTEGER
0505+  0BB7             ; integer value in reg bl
0506+  0BB7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  0BB7             print_u8x:
0508+  0BB7 D7          	push a
0509+  0BB8 DD          	push bl
0510+  0BB9             
0511+  0BB9 07 A4 09    	call itoa				; convert bl to char in A
0512+  0BBC 2F          	mov bl, al				; save al
0513+  0BBD 19 00       	mov al, 0
0514+  0BBF 05 03       	syscall sys_io				; display AH
0515+  0BC1 24          	mov ah, bl				; retrieve al
0516+  0BC2 19 00       	mov al, 0
0517+  0BC4 05 03       	syscall sys_io				; display AL
0518+  0BC6             
0519+  0BC6 EA          	pop bl
0520+  0BC7 E4          	pop a
0521+  0BC8 09          	ret
0522+  0BC9             
0523+  0BC9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0524+  0BC9             ; print 8bit decimal unsigned number
0525+  0BC9             ; input number in AL
0526+  0BC9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  0BC9             print_u8d:
0528+  0BC9 D7          	push a
0529+  0BCA D8          	push b
0530+  0BCB             
0531+  0BCB 22 00       	mov ah, 0
0532+  0BCD 26 64 00    	mov b, 100
0533+  0BD0 AE          	div a, b
0534+  0BD1 D8          	push b			; save remainder
0535+  0BD2 B9 00       	cmp al, 0
0536+  0BD4 C6 DE 0B    	je skip100
0537+  0BD7 6A 30       	add al, $30
0538+  0BD9 23          	mov ah, al
0539+  0BDA 19 00       	mov al, 0
0540+  0BDC 05 03       	syscall sys_io	; print coeff
0541+  0BDE             skip100:
0542+  0BDE E4          	pop a
0543+  0BDF 22 00       	mov ah, 0
0544+  0BE1 26 0A 00    	mov b, 10
0545+  0BE4 AE          	div a, b
0546+  0BE5 D8          	push b			; save remainder
0547+  0BE6 B9 00       	cmp al, 0
0548+  0BE8 C6 F2 0B    	je skip10
0549+  0BEB 6A 30       	add al, $30
0550+  0BED 23          	mov ah, al
0551+  0BEE 19 00       	mov al, 0
0552+  0BF0 05 03       	syscall sys_io	; print coeff
0553+  0BF2             skip10:
0554+  0BF2 E4          	pop a
0555+  0BF3 1B          	mov al, bl
0556+  0BF4 6A 30       	add al, $30
0557+  0BF6 23          	mov ah, al
0558+  0BF7 19 00       	mov al, 0
0559+  0BF9 05 03       	syscall sys_io	; print coeff
0560+  0BFB E5          	pop b
0561+  0BFC E4          	pop a
0562+  0BFD 09          	ret
0563+  0BFE             
0564+  0BFE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0565+  0BFE             ; INPUT 8BIT HEX INTEGER
0566+  0BFE             ; read 8bit integer into AL
0567+  0BFE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  0BFE             scan_u8x:
0569+  0BFE F8 04 00    	enter 4
0570+  0C01 D8          	push b
0571+  0C02 DA          	push d
0572+  0C03             
0573+  0C03 FA FD FF    	lea d, [bp + -3]
0574+  0C06 07 E4 09    	call gets				; get number
0575+  0C09             
0576+  0C09 32          	mov bl, [d]
0577+  0C0A 37          	mov bh, bl
0578+  0C0B 33 01 00    	mov bl, [d + 1]
0579+  0C0E 07 92 09    	call atoi				; convert to int in AL
0580+  0C11             
0581+  0C11 E7          	pop d
0582+  0C12 E5          	pop b
0583+  0C13 F9          	leave
0584+  0C14 09          	ret
0585+  0C15             
0586+  0C15             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  0C15             ; input decimal number
0588+  0C15             ; result in A
0589+  0C15             ; 655'\0'
0590+  0C15             ; low--------high
0591+  0C15             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0592+  0C15             scan_u16d:
0593+  0C15 F8 08 00    	enter 8
0594+  0C18 E2          	push si
0595+  0C19 D8          	push b
0596+  0C1A D9          	push c
0597+  0C1B DA          	push d
0598+  0C1C FA F9 FF    	lea d, [bp +- 7]
0599+  0C1F 07 E4 09    	call gets
0600+  0C22 07 12 09    	call strlen			; get string length in C
0601+  0C25 7E          	dec c
0602+  0C26 FD 4E       	mov si, d
0603+  0C28 12          	mov a, c
0604+  0C29 FD 99       	shl a
0605+  0C2B 3B 7A 09    	mov d, table_power
0606+  0C2E 59          	add d, a
0607+  0C2F 38 00 00    	mov c, 0
0608+  0C32             mul_loop:
0609+  0C32 F6          	lodsb			; load ASCII to al
0610+  0C33 B9 00       	cmp al, 0
0611+  0C35 C6 48 0C    	je mul_exit
0612+  0C38 6F 30       	sub al, $30		; make into integer
0613+  0C3A 22 00       	mov ah, 0
0614+  0C3C 2A          	mov b, [d]
0615+  0C3D AC          	mul a, b			; result in B since it fits in 16bits
0616+  0C3E 11          	mov a, b
0617+  0C3F 28          	mov b, c
0618+  0C40 54          	add a, b
0619+  0C41 39          	mov c, a
0620+  0C42 63 02 00    	sub d, 2
0621+  0C45 0A 32 0C    	jmp mul_loop
0622+  0C48             mul_exit:
0623+  0C48 12          	mov a, c
0624+  0C49 E7          	pop d
0625+  0C4A E6          	pop c
0626+  0C4B E5          	pop b
0627+  0C4C EF          	pop si
0628+  0C4D F9          	leave
0629+  0C4E 09          	ret
0744   0C4F             ; --- END INCLUDE BLOCK
0745   0C4F             
0746   0C4F             
0747   0C4F             .end
tasm: Number of errors = 0
