0001   0000             ; --- FILENAME: test2.c
0002   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0400             .org PROC_TEXT_ORG
0004   0400             
0005   0400             ; --- BEGIN TEXT BLOCK
0006   0400             main:
0007   0400 D2            push bp
0008   0401 9B            mov bp, sp
0009   0402             _for1_init:
0010   0402 26 00 00      mov b, 0
0011   0405 FD 42 8E 07   mov [infi], b
0012   0409             _for1_cond:
0013   0409 29 8E 07      mov b, [infi]
0014   040C D7            push a
0015   040D 11            mov a, b
0016   040E 26 0A 00      mov b, 10
0017   0411 B0            cmp a, b
0018   0412 0E            lodflgs
0019   0413 87 02         and al, %00000010 ; <
0020   0415 B9 00         cmp al, 0
0021   0417 0E            lodflgs
0022   0418 96            not al
0023   0419 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0024   041B 22 00         mov ah, 0
0025   041D 27            mov b, a
0026   041E E4            pop a
0027   041F C0 00 00      cmp b, 0
0028   0422 C6 64 05      je _for1_exit
0029   0425             _for1_block:
0030   0425 26 00 00      mov b, 0
0031   0428 FD 42 80 07   mov [pc], b
0032   042C 26 18 30      mov b, 12312
0033   042F FD AB         swp b
0034   0431 D8            push b
0035   0432 07 77 05      call displaynumber
0036   0435 51 02 00      add sp, 2
0037   0438 07 67 05      call readint
0038   043B FD 42 76 07   mov [cmdadr], b
0039   043F             _if2_cond:
0040   043F 29 76 07      mov b, [cmdadr]
0041   0442 D7            push a
0042   0443 11            mov a, b
0043   0444 26 78 00      mov b, 120
0044   0447 B0            cmp a, b
0045   0448 0E            lodflgs
0046   0449 87 03         and al, %00000011 ; <=
0047   044B B9 00         cmp al, 0
0048   044D 0E            lodflgs
0049   044E 96            not al
0050   044F 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0051   0451 22 00         mov ah, 0
0052   0453 27            mov b, a
0053   0454 E4            pop a
0054   0455 C0 00 00      cmp b, 0
0055   0458 C6 52 05      je _if2_exit
0056   045B             _if2_true:
0057   045B 07 67 05      call readint
0058   045E FD 42 78 07   mov [opr], b
0059   0462 07 67 05      call readint
0060   0465 FD 42 7A 07   mov [datadr1], b
0061   0469 07 67 05      call readint
0062   046C FD 42 7C 07   mov [datadr2], b
0063   0470 07 67 05      call readint
0064   0473 FD 42 7E 07   mov [datadr3], b
0065   0477 29 74 07      mov b, [instruction]
0066   047A 74            mov d, b
0067   047B 29 76 07      mov b, [cmdadr]
0068   047E D7            push a
0069   047F 11            mov a, b
0070   0480 26 04 00      mov b, 4
0071   0483 AC            mul a, b
0072   0484 E4            pop a
0073   0485 10 02 00      mov a, 2
0074   0488 AC            mul a, b
0075   0489 5A            add d, b
0076   048A DA            push d
0077   048B 29 78 07      mov b, [opr]
0078   048E E7            pop d
0079   048F 11            mov a, b
0080   0490 43            mov [d], a
0081   0491 29 74 07      mov b, [instruction]
0082   0494 74            mov d, b
0083   0495 29 76 07      mov b, [cmdadr]
0084   0498 D7            push a
0085   0499 11            mov a, b
0086   049A 26 04 00      mov b, 4
0087   049D AC            mul a, b
0088   049E 11            mov a, b
0089   049F 26 01 00      mov b, 1
0090   04A2 54            add a, b
0091   04A3 27            mov b, a
0092   04A4 E4            pop a
0093   04A5 10 02 00      mov a, 2
0094   04A8 AC            mul a, b
0095   04A9 5A            add d, b
0096   04AA DA            push d
0097   04AB 29 7A 07      mov b, [datadr1]
0098   04AE E7            pop d
0099   04AF 11            mov a, b
0100   04B0 43            mov [d], a
0101   04B1 29 74 07      mov b, [instruction]
0102   04B4 74            mov d, b
0103   04B5 29 76 07      mov b, [cmdadr]
0104   04B8 D7            push a
0105   04B9 11            mov a, b
0106   04BA 26 04 00      mov b, 4
0107   04BD AC            mul a, b
0108   04BE 11            mov a, b
0109   04BF 26 02 00      mov b, 2
0110   04C2 54            add a, b
0111   04C3 27            mov b, a
0112   04C4 E4            pop a
0113   04C5 10 02 00      mov a, 2
0114   04C8 AC            mul a, b
0115   04C9 5A            add d, b
0116   04CA DA            push d
0117   04CB 29 7C 07      mov b, [datadr2]
0118   04CE E7            pop d
0119   04CF 11            mov a, b
0120   04D0 43            mov [d], a
0121   04D1 29 74 07      mov b, [instruction]
0122   04D4 74            mov d, b
0123   04D5 29 76 07      mov b, [cmdadr]
0124   04D8 D7            push a
0125   04D9 11            mov a, b
0126   04DA 26 04 00      mov b, 4
0127   04DD AC            mul a, b
0128   04DE 11            mov a, b
0129   04DF 26 03 00      mov b, 3
0130   04E2 54            add a, b
0131   04E3 27            mov b, a
0132   04E4 E4            pop a
0133   04E5 10 02 00      mov a, 2
0134   04E8 AC            mul a, b
0135   04E9 5A            add d, b
0136   04EA DA            push d
0137   04EB 29 7E 07      mov b, [datadr3]
0138   04EE E7            pop d
0139   04EF 11            mov a, b
0140   04F0 43            mov [d], a
0141   04F1 29 76 07      mov b, [cmdadr]
0142   04F4 FD AB         swp b
0143   04F6 D8            push b
0144   04F7 07 77 05      call displaynumber
0145   04FA 51 02 00      add sp, 2
0146   04FD 29 78 07      mov b, [opr]
0147   0500 FD AB         swp b
0148   0502 D8            push b
0149   0503 07 77 05      call displaynumber
0150   0506 51 02 00      add sp, 2
0151   0509 29 7A 07      mov b, [datadr1]
0152   050C FD AB         swp b
0153   050E D8            push b
0154   050F 07 77 05      call displaynumber
0155   0512 51 02 00      add sp, 2
0156   0515 29 7C 07      mov b, [datadr2]
0157   0518 FD AB         swp b
0158   051A D8            push b
0159   051B 07 77 05      call displaynumber
0160   051E 51 02 00      add sp, 2
0161   0521 29 7E 07      mov b, [datadr3]
0162   0524 FD AB         swp b
0163   0526 D8            push b
0164   0527 07 77 05      call displaynumber
0165   052A 51 02 00      add sp, 2
0166   052D             _if3_cond:
0167   052D 29 76 07      mov b, [cmdadr]
0168   0530 D7            push a
0169   0531 11            mov a, b
0170   0532 26 00 00      mov b, 0
0171   0535 B0            cmp a, b
0172   0536 0E            lodflgs
0173   0537 87 01         and al, %00000001 ; ==
0174   0539 B9 00         cmp al, 0
0175   053B 0E            lodflgs
0176   053C 96            not al
0177   053D 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0178   053F 22 00         mov ah, 0
0179   0541 27            mov b, a
0180   0542 E4            pop a
0181   0543 C0 00 00      cmp b, 0
0182   0546 C6 4F 05      je _if3_exit
0183   0549             _if3_true:
a.s line 0184: Label not found: (_for3_exit)
a.s line 0184: Unused data in MS byte of argument. (2)
0184   0549 0A 00 00      jmp _for3_exit
0185   054C 0A 4F 05      jmp _if3_exit
0186   054F             _if3_exit:
0187   054F 0A 52 05      jmp _if2_exit
0188   0552             _if2_exit:
0189   0552             _for1_update:
0190   0552 29 8E 07      mov b, [infi]
0191   0555 D7            push a
0192   0556 11            mov a, b
0193   0557 26 01 00      mov b, 1
0194   055A 54            add a, b
0195   055B 27            mov b, a
0196   055C E4            pop a
0197   055D FD 42 8E 07   mov [infi], b
0198   0561 0A 09 04      jmp _for1_cond
0199   0564             _for1_exit:
0200   0564 F9            leave
0201   0565 05 0B         syscall sys_terminate_proc
0202   0567             readint:
0203   0567 D2            push bp
0204   0568 9B            mov bp, sp
0205   0569 52 02 00      sub sp, 2 ; n
0206   056C             
0207   056C             ; --- BEGIN INLINE ASM BLOCK
0208   056C 07 DC 0A      call scan_u16d
0209   056F 45 FF FF      mov [bp + -1], a
0210   0572             ; --- END INLINE ASM BLOCK
0211   0572             
0212   0572 2C FF FF      mov b, [bp + -1] ; n
0213   0575 F9            leave
0214   0576 09            ret
0215   0577             displaynumber:
0216   0577 D2            push bp
0217   0578 9B            mov bp, sp
0218   0579             
0219   0579             ; --- BEGIN INLINE ASM BLOCK
0220   0579 17 05 00      mov a, [bp + 5]
0221   057C 07 07 0A      call print_u16d
0222   057F 14 8A 05      mov a, [ss]
0223   0582 3C            mov d, a
0224   0583 07 DE 09      call puts
0225   0586             ; --- END INLINE ASM BLOCK
0226   0586             
0227   0586 F9            leave
0228   0587 09            ret
0229   0588             ; --- END TEXT BLOCK
0230   0588             
0231   0588             ; --- BEGIN DATA BLOCK
0232   0588 0A 00       ss_data: .db "\n", 0
0233   058A 88 05       ss: .dw ss_data
0234   058C 00 00 00 00 datum_data: .fill 246, 0
0234   0590 00 00 00 00 
0234   0594 00 00 00 00 
0234   0598 00 00 00 00 
0234   059C 00 00 00 00 
0234   05A0 00 00 00 00 
0234   05A4 00 00 00 00 
0234   05A8 00 00 00 00 
0234   05AC 00 00 00 00 
0234   05B0 00 00 00 00 
0234   05B4 00 00 00 00 
0234   05B8 00 00 00 00 
0234   05BC 00 00 00 00 
0234   05C0 00 00 00 00 
0234   05C4 00 00 00 00 
0234   05C8 00 00 00 00 
0234   05CC 00 00 00 00 
0234   05D0 00 00 00 00 
0234   05D4 00 00 00 00 
0234   05D8 00 00 00 00 
0234   05DC 00 00 00 00 
0234   05E0 00 00 00 00 
0234   05E4 00 00 00 00 
0234   05E8 00 00 00 00 
0234   05EC 00 00 00 00 
0234   05F0 00 00 00 00 
0234   05F4 00 00 00 00 
0234   05F8 00 00 00 00 
0234   05FC 00 00 00 00 
0234   0600 00 00 00 00 
0234   0604 00 00 00 00 
0234   0608 00 00 00 00 
0234   060C 00 00 00 00 
0234   0610 00 00 00 00 
0234   0614 00 00 00 00 
0234   0618 00 00 00 00 
0234   061C 00 00 00 00 
0234   0620 00 00 00 00 
0234   0624 00 00 00 00 
0234   0628 00 00 00 00 
0234   062C 00 00 00 00 
0234   0630 00 00 00 00 
0234   0634 00 00 00 00 
0234   0638 00 00 00 00 
0234   063C 00 00 00 00 
0234   0640 00 00 00 00 
0234   0644 00 00 00 00 
0234   0648 00 00 00 00 
0234   064C 00 00 00 00 
0234   0650 00 00 00 00 
0234   0654 00 00 00 00 
0234   0658 00 00 00 00 
0234   065C 00 00 00 00 
0234   0660 00 00 00 00 
0234   0664 00 00 00 00 
0234   0668 00 00 00 00 
0234   066C 00 00 00 00 
0234   0670 00 00 00 00 
0234   0674 00 00 00 00 
0234   0678 00 00 00 00 
0234   067C 00 00 00 00 
0234   0680 00 00 
0235   0682 8C 05       datum: .dw datum_data
0236   0684 00 00 00 00 instruction_data: .fill 240, 0
0236   0688 00 00 00 00 
0236   068C 00 00 00 00 
0236   0690 00 00 00 00 
0236   0694 00 00 00 00 
0236   0698 00 00 00 00 
0236   069C 00 00 00 00 
0236   06A0 00 00 00 00 
0236   06A4 00 00 00 00 
0236   06A8 00 00 00 00 
0236   06AC 00 00 00 00 
0236   06B0 00 00 00 00 
0236   06B4 00 00 00 00 
0236   06B8 00 00 00 00 
0236   06BC 00 00 00 00 
0236   06C0 00 00 00 00 
0236   06C4 00 00 00 00 
0236   06C8 00 00 00 00 
0236   06CC 00 00 00 00 
0236   06D0 00 00 00 00 
0236   06D4 00 00 00 00 
0236   06D8 00 00 00 00 
0236   06DC 00 00 00 00 
0236   06E0 00 00 00 00 
0236   06E4 00 00 00 00 
0236   06E8 00 00 00 00 
0236   06EC 00 00 00 00 
0236   06F0 00 00 00 00 
0236   06F4 00 00 00 00 
0236   06F8 00 00 00 00 
0236   06FC 00 00 00 00 
0236   0700 00 00 00 00 
0236   0704 00 00 00 00 
0236   0708 00 00 00 00 
0236   070C 00 00 00 00 
0236   0710 00 00 00 00 
0236   0714 00 00 00 00 
0236   0718 00 00 00 00 
0236   071C 00 00 00 00 
0236   0720 00 00 00 00 
0236   0724 00 00 00 00 
0236   0728 00 00 00 00 
0236   072C 00 00 00 00 
0236   0730 00 00 00 00 
0236   0734 00 00 00 00 
0236   0738 00 00 00 00 
0236   073C 00 00 00 00 
0236   0740 00 00 00 00 
0236   0744 00 00 00 00 
0236   0748 00 00 00 00 
0236   074C 00 00 00 00 
0236   0750 00 00 00 00 
0236   0754 00 00 00 00 
0236   0758 00 00 00 00 
0236   075C 00 00 00 00 
0236   0760 00 00 00 00 
0236   0764 00 00 00 00 
0236   0768 00 00 00 00 
0236   076C 00 00 00 00 
0236   0770 00 00 00 00 
0237   0774 84 06       instruction: .dw instruction_data
0238   0776 00 00       cmdadr: .dw 0
0239   0778 00 00       opr: .dw 0
0240   077A 00 00       datadr1: .dw 0
0241   077C 00 00       datadr2: .dw 0
0242   077E 00 00       datadr3: .dw 0
0243   0780 00 00       pc: .dw 0
0244   0782 00 00       h: .dw 0
0245   0784 00 00       i: .dw 0
0246   0786 00 00       j: .dw 0
0247   0788 00 00       k: .dw 0
0248   078A 00 00       l: .dw 0
0249   078C 00 00       p: .dw 0
0250   078E 00 00       infi: .dw 0
0251   0790 00 00       runlimit: .dw 0
0252   0792             ; --- END DATA BLOCK
0253   0792             
0254   0792             ; --- BEGIN INCLUDE BLOCK
0255   0792             .include "lib/stdio.asm"
0001+  0792             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0792             ; stdio.s
0003+  0792             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0792             .include "lib/string.asm"
0001++ 0792             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0792             ; string.s
0003++ 0792             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0792             
0005++ 0792             
0006++ 0792             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0792             ; strrev
0008++ 0792             ; reverse a string
0009++ 0792             ; D = string address
0010++ 0792             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0792             ; 01234
0012++ 0792             strrev:
0013++ 0792 4B          	pusha
0014++ 0793 07 D9 07    	call strlen	; length in C
0015++ 0796 12          	mov a, c
0016++ 0797 AF 01 00    	cmp a, 1
0017++ 079A D0 B4 07    	jleu strrev_end	; check string length. string len must be > 1
0018++ 079D 7D          	dec a
0019++ 079E FD 4E       	mov si, d	; beginning of string
0020++ 07A0 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 07A2 59          	add d, a	; end of string
0022++ 07A3 12          	mov a, c
0023++ 07A4 FD 9B       	shr a		; divide by 2
0024++ 07A6 39          	mov c, a	; C now counts the steps
0025++ 07A7             strrev_L0:
0026++ 07A7 32          	mov bl, [d]	; save load right-side char into BL
0027++ 07A8 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 07A9 3E          	mov [d], al	; store left char into right side
0029++ 07AA 1B          	mov al, bl
0030++ 07AB F7          	stosb		; store right-side char into left-side; increase DI
0031++ 07AC 7E          	dec c
0032++ 07AD 7F          	dec d
0033++ 07AE C2 00 00    	cmp c, 0
0034++ 07B1 C7 A7 07    	jne strrev_L0
0035++ 07B4             strrev_end:
0036++ 07B4 4C          	popa
0037++ 07B5 09          	ret
0038++ 07B6             	
0039++ 07B6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 07B6             ; strchr
0041++ 07B6             ; search string in D for char in AL
0042++ 07B6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 07B6             strchr:
0044++ 07B6             strchr_L0:
0045++ 07B6 32          	mov bl, [d]
0046++ 07B7 C1 00       	cmp bl, 0
0047++ 07B9 C6 C4 07    	je strchr_end
0048++ 07BC BA          	cmp al, bl
0049++ 07BD C6 C4 07    	je strchr_end
0050++ 07C0 79          	inc d
0051++ 07C1 0A B6 07    	jmp strchr_L0
0052++ 07C4             strchr_end:
0053++ 07C4 1B          	mov al, bl
0054++ 07C5 09          	ret
0055++ 07C6             
0056++ 07C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 07C6             ; strstr
0058++ 07C6             ; find sub-string
0059++ 07C6             ; str1 in SI
0060++ 07C6             ; str2 in DI
0061++ 07C6             ; SI points to end of source string
0062++ 07C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 07C6             strstr:
0064++ 07C6 DB          	push al
0065++ 07C7 DA          	push d
0066++ 07C8 E3          	push di
0067++ 07C9             strstr_loop:
0068++ 07C9 F3          	cmpsb					; compare a byte of the strings
0069++ 07CA C7 D5 07    	jne strstr_ret
0070++ 07CD FC 00 00    	lea d, [di + 0]
0071++ 07D0 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 07D2 C7 C9 07    	jne strstr_loop				; equal chars but not at end
0073++ 07D5             strstr_ret:
0074++ 07D5 F0          	pop di
0075++ 07D6 E7          	pop d
0076++ 07D7 E8          	pop al
0077++ 07D8 09          	ret
0078++ 07D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 07D9             ; length of null terminated string
0080++ 07D9             ; result in C
0081++ 07D9             ; pointer in D
0082++ 07D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 07D9             strlen:
0084++ 07D9 DA          	push d
0085++ 07DA 38 00 00    	mov c, 0
0086++ 07DD             strlen_L1:
0087++ 07DD BD 00       	cmp byte [d], 0
0088++ 07DF C6 E7 07    	je strlen_ret
0089++ 07E2 79          	inc d
0090++ 07E3 78          	inc c
0091++ 07E4 0A DD 07    	jmp strlen_L1
0092++ 07E7             strlen_ret:
0093++ 07E7 E7          	pop d
0094++ 07E8 09          	ret
0095++ 07E9             
0096++ 07E9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 07E9             ; STRCMP
0098++ 07E9             ; compare two strings
0099++ 07E9             ; str1 in SI
0100++ 07E9             ; str2 in DI
0101++ 07E9             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 07E9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 07E9             strcmp:
0104++ 07E9 DB          	push al
0105++ 07EA DA          	push d
0106++ 07EB E3          	push di
0107++ 07EC E2          	push si
0108++ 07ED             strcmp_loop:
0109++ 07ED F3          	cmpsb					; compare a byte of the strings
0110++ 07EE C7 F9 07    	jne strcmp_ret
0111++ 07F1 FB FF FF    	lea d, [si +- 1]
0112++ 07F4 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 07F6 C7 ED 07    	jne strcmp_loop				; equal chars but not at end
0114++ 07F9             strcmp_ret:
0115++ 07F9 EF          	pop si
0116++ 07FA F0          	pop di
0117++ 07FB E7          	pop d
0118++ 07FC E8          	pop al
0119++ 07FD 09          	ret
0120++ 07FE             
0121++ 07FE             
0122++ 07FE             ; STRCPY
0123++ 07FE             ; copy null terminated string from SI to DI
0124++ 07FE             ; source in SI
0125++ 07FE             ; destination in DI
0126++ 07FE             strcpy:
0127++ 07FE E2          	push si
0128++ 07FF E3          	push di
0129++ 0800 DB          	push al
0130++ 0801             strcpy_L1:
0131++ 0801 F6          	lodsb
0132++ 0802 F7          	stosb
0133++ 0803 B9 00       	cmp al, 0
0134++ 0805 C7 01 08    	jne strcpy_L1
0135++ 0808             strcpy_end:
0136++ 0808 E8          	pop al
0137++ 0809 F0          	pop di
0138++ 080A EF          	pop si
0139++ 080B 09          	ret
0140++ 080C             
0141++ 080C             ; STRCAT
0142++ 080C             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 080C             ; source in SI
0144++ 080C             ; destination in DI
0145++ 080C             strcat:
0146++ 080C E2          	push si
0147++ 080D E3          	push di
0148++ 080E D7          	push a
0149++ 080F DA          	push d
0150++ 0810 50          	mov a, di
0151++ 0811 3C          	mov d, a
0152++ 0812             strcat_goto_end_L1:
0153++ 0812 BD 00       	cmp byte[d], 0
0154++ 0814 C6 1B 08    	je strcat_start
0155++ 0817 79          	inc d
0156++ 0818 0A 12 08    	jmp strcat_goto_end_L1
0157++ 081B             strcat_start:
0158++ 081B FD 50       	mov di, d
0159++ 081D             strcat_L1:
0160++ 081D F6          	lodsb
0161++ 081E F7          	stosb
0162++ 081F B9 00       	cmp al, 0
0163++ 0821 C7 1D 08    	jne strcat_L1
0164++ 0824             strcat_end:
0165++ 0824 E7          	pop d
0166++ 0825 E4          	pop a
0167++ 0826 F0          	pop di
0168++ 0827 EF          	pop si
0169++ 0828 09          	ret
0005+  0829             
0006+  0829 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  082D 34 35 36 37 
0006+  0831 38 39 41 42 
0006+  0835 43 44 45 46 
0007+  0839 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  083D 1B 5B 48 00 
0008+  0841             
0009+  0841 01 00       table_power:.dw 1
0010+  0843 0A 00       			.dw 10
0011+  0845 64 00       			.dw 100
0012+  0847 E8 03       			.dw 1000
0013+  0849 10 27       			.dw 10000
0014+  084B             
0015+  084B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  084B             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  084B             ; ASCII in BL
0018+  084B             ; result in AL
0019+  084B             ; ascii for F = 0100 0110
0020+  084B             ; ascii for 9 = 0011 1001
0021+  084B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  084B             hex_ascii_encode:
0023+  084B 1B          	mov al, bl
0024+  084C 93 40       	test al, $40				; test if letter or number
0025+  084E C7 54 08    	jnz hex_letter
0026+  0851 87 0F       	and al, $0F				; get number
0027+  0853 09          	ret
0028+  0854             hex_letter:
0029+  0854 87 0F       	and al, $0F				; get letter
0030+  0856 6A 09       	add al, 9
0031+  0858 09          	ret
0032+  0859             
0033+  0859             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  0859             ; ATOI
0035+  0859             ; 2 letter hex string in B
0036+  0859             ; 8bit integer returned in AL
0037+  0859             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0859             atoi:
0039+  0859 D8          	push b
0040+  085A 07 4B 08    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  085D 30          	mov bl, bh
0042+  085E DB          	push al					; save a
0043+  085F 07 4B 08    	call hex_ascii_encode
0044+  0862 EA          	pop bl	
0045+  0863 FD 9E 04    	shl al, 4
0046+  0866 8C          	or al, bl
0047+  0867 E5          	pop b
0048+  0868 09          	ret	
0049+  0869             
0050+  0869             
0051+  0869             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  0869             ; printf
0053+  0869             ; no need for explanations!
0054+  0869             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0869             printf:
0056+  0869 09          	ret
0057+  086A             
0058+  086A             
0059+  086A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  086A             ; scanf
0061+  086A             ; no need for explanations!
0062+  086A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  086A             scanf:
0064+  086A 09          	ret
0065+  086B             
0066+  086B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  086B             ; ITOA
0068+  086B             ; 8bit value in BL
0069+  086B             ; 2 byte ASCII result in A
0070+  086B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  086B             itoa:
0072+  086B DA          	push d
0073+  086C D8          	push b
0074+  086D A7 00       	mov bh, 0
0075+  086F FD A4 04    	shr bl, 4	
0076+  0872 74          	mov d, b
0077+  0873 1F 29 08    	mov al, [d + s_hex_digits]
0078+  0876 23          	mov ah, al
0079+  0877             	
0080+  0877 E5          	pop b
0081+  0878 D8          	push b
0082+  0879 A7 00       	mov bh, 0
0083+  087B FD 87 0F    	and bl, $0F
0084+  087E 74          	mov d, b
0085+  087F 1F 29 08    	mov al, [d + s_hex_digits]
0086+  0882 E5          	pop b
0087+  0883 E7          	pop d
0088+  0884 09          	ret
0089+  0885             
0090+  0885             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  0885             ; HEX STRING TO BINARY
0092+  0885             ; di = destination address
0093+  0885             ; si = source
0094+  0885             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  0885             hex_to_int:
0096+  0885             hex_to_int_L1:
0097+  0885 F6          	lodsb					; load from [SI] to AL
0098+  0886 B9 00       	cmp al, 0				; check if ASCII 0
0099+  0888 C6 95 08    	jz hex_to_int_ret
0100+  088B 36          	mov bh, al
0101+  088C F6          	lodsb
0102+  088D 2F          	mov bl, al
0103+  088E 07 59 08    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  0891 F7          	stosb					; store AL to [DI]
0105+  0892 0A 85 08    	jmp hex_to_int_L1
0106+  0895             hex_to_int_ret:
0107+  0895 09          	ret		
0108+  0896             
0109+  0896             
0110+  0896             
0111+  0896             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  0896             ; GETCHAR
0113+  0896             ; char in ah
0114+  0896             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  0896             getchar:
0116+  0896 DB          	push al
0117+  0897             getchar_retry:
0118+  0897 FD 0C       	sti
0119+  0899 19 01       	mov al, 1
0120+  089B 05 03       	syscall sys_io			; receive in AH
0121+  089D B9 00       	cmp al, 0			; check if any char was receive
0122+  089F C6 97 08    	je getchar_retry
0123+  08A2 E8          	pop al
0124+  08A3 09          	ret
0125+  08A4             
0126+  08A4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  08A4             ; PUTCHAR
0128+  08A4             ; char in ah
0129+  08A4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  08A4             putchar:
0131+  08A4 D7          	push a
0132+  08A5 19 00       	mov al, 0
0133+  08A7 05 03       	syscall sys_io			; char in AH
0134+  08A9 E4          	pop a
0135+  08AA 09          	ret
0136+  08AB             
0137+  08AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  08AB             ;; INPUT A STRING
0139+  08AB             ;; terminates with null
0140+  08AB             ;; pointer in D
0141+  08AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  08AB             gets:
0143+  08AB D7          	push a
0144+  08AC DA          	push d
0145+  08AD             gets_loop:
0146+  08AD FD 0C       	sti
0147+  08AF 19 01       	mov al, 1
0148+  08B1 05 03       	syscall sys_io			; receive in AH
0149+  08B3 B9 00       	cmp al, 0				; check error code (AL)
0150+  08B5 C6 AD 08    	je gets_loop			; if no char received, retry
0151+  08B8             
0152+  08B8 76 1B       	cmp ah, 27
0153+  08BA C6 DB 08    	je gets_telnet_escape
0154+  08BD 76 0A       	cmp ah, $0A				; LF
0155+  08BF C6 34 09    	je gets_end
0156+  08C2 76 0D       	cmp ah, $0D				; CR
0157+  08C4 C6 34 09    	je gets_end
0158+  08C7 76 5C       	cmp ah, $5C				; '\\'
0159+  08C9 C6 0B 09    	je gets_escape
0160+  08CC             	
0161+  08CC 76 08       	cmp ah, $08			; check for backspace
0162+  08CE C6 D7 08    	je gets_backspace
0163+  08D1             
0164+  08D1 1A          	mov al, ah
0165+  08D2 3E          	mov [d], al
0166+  08D3 79          	inc d
0167+  08D4 0A AD 08    	jmp gets_loop
0168+  08D7             gets_backspace:
0169+  08D7 7F          	dec d
0170+  08D8 0A AD 08    	jmp gets_loop
0171+  08DB             gets_telnet_escape:
0172+  08DB FD 0C       	sti
0173+  08DD 19 01       	mov al, 1
0174+  08DF 05 03       	syscall sys_io				; receive in AH without echo
0175+  08E1 B9 00       	cmp al, 0					; check error code (AL)
0176+  08E3 C6 DB 08    	je gets_telnet_escape		; if no char received, retry
0177+  08E6 76 5B       	cmp ah, '['
0178+  08E8 C7 AD 08    	jne gets_loop
0179+  08EB             gets_telnet_escape_phase2:
0180+  08EB FD 0C       	sti
0181+  08ED 19 01       	mov al, 1
0182+  08EF 05 03       	syscall sys_io					; receive in AH without echo
0183+  08F1 B9 00       	cmp al, 0						; check error code (AL)
0184+  08F3 C6 EB 08    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  08F6 76 44       	cmp ah, 'D'
0186+  08F8 C6 03 09    	je gets_left_arrow
0187+  08FB 76 43       	cmp ah, 'C'
0188+  08FD C6 07 09    	je gets_right_arrow
0189+  0900 0A AD 08    	jmp gets_loop
0190+  0903             gets_left_arrow:
0191+  0903 7F          	dec d
0192+  0904 0A AD 08    	jmp gets_loop
0193+  0907             gets_right_arrow:
0194+  0907 79          	inc d
0195+  0908 0A AD 08    	jmp gets_loop
0196+  090B             gets_escape:
0197+  090B FD 0C       	sti
0198+  090D 19 01       	mov al, 1
0199+  090F 05 03       	syscall sys_io			; receive in AH
0200+  0911 B9 00       	cmp al, 0				; check error code (AL)
0201+  0913 C6 0B 09    	je gets_escape			; if no char received, retry
0202+  0916 76 6E       	cmp ah, 'n'
0203+  0918 C6 26 09    	je gets_LF
0204+  091B 76 72       	cmp ah, 'r'
0205+  091D C6 2D 09    	je gets_CR
0206+  0920 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  0921 3E          	mov [d], al
0208+  0922 79          	inc d
0209+  0923 0A AD 08    	jmp gets_loop
0210+  0926             gets_LF:
0211+  0926 19 0A       	mov al, $0A
0212+  0928 3E          	mov [d], al
0213+  0929 79          	inc d
0214+  092A 0A AD 08    	jmp gets_loop
0215+  092D             gets_CR:
0216+  092D 19 0D       	mov al, $0D
0217+  092F 3E          	mov [d], al
0218+  0930 79          	inc d
0219+  0931 0A AD 08    	jmp gets_loop
0220+  0934             gets_end:
0221+  0934 19 00       	mov al, 0
0222+  0936 3E          	mov [d], al				; terminate string
0223+  0937 E7          	pop d
0224+  0938 E4          	pop a
0225+  0939 09          	ret
0226+  093A             
0227+  093A             
0228+  093A             
0229+  093A             
0230+  093A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  093A             ;; INPUT TEXT
0232+  093A             ;; terminated with CTRL+D
0233+  093A             ;; pointer in D
0234+  093A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  093A             gettxt:
0236+  093A D7          	push a
0237+  093B DA          	push d
0238+  093C             gettxt_loop:
0239+  093C 19 01       	mov al, 1
0240+  093E 05 03       	syscall sys_io			; receive in AH
0241+  0940 B9 00       	cmp al, 0				; check error code (AL)
0242+  0942 C6 3C 09    	je gettxt_loop		; if no char received, retry
0243+  0945 76 04       	cmp ah, 4			; EOT
0244+  0947 C6 85 09    	je gettxt_end
0245+  094A 76 08       	cmp ah, $08			; check for backspace
0246+  094C C6 81 09    	je gettxt_backspace
0247+  094F 76 5C       	cmp ah, $5C				; '\\'
0248+  0951 C6 5A 09    	je gettxt_escape
0249+  0954 1A          	mov al, ah
0250+  0955 3E          	mov [d], al
0251+  0956 79          	inc d
0252+  0957 0A 3C 09    	jmp gettxt_loop
0253+  095A             gettxt_escape:
0254+  095A 19 01       	mov al, 1
0255+  095C 05 03       	syscall sys_io			; receive in AH
0256+  095E B9 00       	cmp al, 0				; check error code (AL)
0257+  0960 C6 5A 09    	je gettxt_escape		; if no char received, retry
0258+  0963 76 6E       	cmp ah, 'n'
0259+  0965 C6 73 09    	je gettxt_LF
0260+  0968 76 72       	cmp ah, 'r'
0261+  096A C6 7A 09    	je gettxt_CR
0262+  096D 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  096E 3E          	mov [d], al
0264+  096F 79          	inc d
0265+  0970 0A 3C 09    	jmp gettxt_loop
0266+  0973             gettxt_LF:
0267+  0973 19 0A       	mov al, $0A
0268+  0975 3E          	mov [d], al
0269+  0976 79          	inc d
0270+  0977 0A 3C 09    	jmp gettxt_loop
0271+  097A             gettxt_CR:
0272+  097A 19 0D       	mov al, $0D
0273+  097C 3E          	mov [d], al
0274+  097D 79          	inc d
0275+  097E 0A 3C 09    	jmp gettxt_loop
0276+  0981             gettxt_backspace:
0277+  0981 7F          	dec d
0278+  0982 0A 3C 09    	jmp gettxt_loop
0279+  0985             gettxt_end:
0280+  0985 19 00       	mov al, 0
0281+  0987 3E          	mov [d], al				; terminate string
0282+  0988 E7          	pop d
0283+  0989 E4          	pop a
0284+  098A 09          	ret
0285+  098B             
0286+  098B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  098B             ; PRINT NEW LINE
0288+  098B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  098B             printnl:
0290+  098B D7          	push a
0291+  098C 10 00 0A    	mov a, $0A00
0292+  098F 05 03       	syscall sys_io
0293+  0991 10 00 0D    	mov a, $0D00
0294+  0994 05 03       	syscall sys_io
0295+  0996 E4          	pop a
0296+  0997 09          	ret
0297+  0998             
0298+  0998             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  0998             ; strtoint
0300+  0998             ; 4 digit hex string number in d
0301+  0998             ; integer returned in A
0302+  0998             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  0998             strtointx:
0304+  0998 D8          	push b
0305+  0999 32          	mov bl, [d]
0306+  099A 37          	mov bh, bl
0307+  099B 33 01 00    	mov bl, [d + 1]
0308+  099E 07 59 08    	call atoi				; convert to int in AL
0309+  09A1 23          	mov ah, al				; move to AH
0310+  09A2 33 02 00    	mov bl, [d + 2]
0311+  09A5 37          	mov bh, bl
0312+  09A6 33 03 00    	mov bl, [d + 3]
0313+  09A9 07 59 08    	call atoi				; convert to int in AL
0314+  09AC E5          	pop b
0315+  09AD 09          	ret
0316+  09AE             
0317+  09AE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  09AE             ; strtoint
0319+  09AE             ; 5 digit base10 string number in d
0320+  09AE             ; integer returned in A
0321+  09AE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  09AE             strtoint:
0323+  09AE E2          	push si
0324+  09AF D8          	push b
0325+  09B0 D9          	push c
0326+  09B1 DA          	push d
0327+  09B2 07 D9 07    	call strlen			; get string length in C
0328+  09B5 7E          	dec c
0329+  09B6 FD 4E       	mov si, d
0330+  09B8 12          	mov a, c
0331+  09B9 FD 99       	shl a
0332+  09BB 3B 41 08    	mov d, table_power
0333+  09BE 59          	add d, a
0334+  09BF 38 00 00    	mov c, 0
0335+  09C2             strtoint_L0:
0336+  09C2 F6          	lodsb			; load ASCII to al
0337+  09C3 B9 00       	cmp al, 0
0338+  09C5 C6 D8 09    	je strtoint_end
0339+  09C8 6F 30       	sub al, $30		; make into integer
0340+  09CA 22 00       	mov ah, 0
0341+  09CC 2A          	mov b, [d]
0342+  09CD AC          	mul a, b			; result in B since it fits in 16bits
0343+  09CE 11          	mov a, b
0344+  09CF 28          	mov b, c
0345+  09D0 54          	add a, b
0346+  09D1 39          	mov c, a
0347+  09D2 63 02 00    	sub d, 2
0348+  09D5 0A C2 09    	jmp strtoint_L0
0349+  09D8             strtoint_end:
0350+  09D8 12          	mov a, c
0351+  09D9 E7          	pop d
0352+  09DA E6          	pop c
0353+  09DB E5          	pop b
0354+  09DC EF          	pop si
0355+  09DD 09          	ret
0356+  09DE             
0357+  09DE             
0358+  09DE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  09DE             ; PRINT NULL TERMINATED STRING
0360+  09DE             ; pointer in D
0361+  09DE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  09DE             puts:
0363+  09DE D7          	push a
0364+  09DF DA          	push d
0365+  09E0             puts_L1:
0366+  09E0 1E          	mov al, [d]
0367+  09E1 B9 00       	cmp al, 0
0368+  09E3 C6 EF 09    	jz puts_END
0369+  09E6 23          	mov ah, al
0370+  09E7 19 00       	mov al, 0
0371+  09E9 05 03       	syscall sys_io
0372+  09EB 79          	inc d
0373+  09EC 0A E0 09    	jmp puts_L1
0374+  09EF             puts_END:
0375+  09EF E7          	pop d
0376+  09F0 E4          	pop a
0377+  09F1 09          	ret
0378+  09F2             
0379+  09F2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  09F2             ; PRINT N SIZE STRING
0381+  09F2             ; pointer in D
0382+  09F2             ; size in C
0383+  09F2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  09F2             putsn:
0385+  09F2 DB          	push al
0386+  09F3 DA          	push d
0387+  09F4 D9          	push c
0388+  09F5             putsn_L0:
0389+  09F5 1E          	mov al, [d]
0390+  09F6 23          	mov ah, al
0391+  09F7 19 00       	mov al, 0
0392+  09F9 05 03       	syscall sys_io
0393+  09FB 79          	inc d
0394+  09FC 7E          	dec c	
0395+  09FD C2 00 00    	cmp c, 0
0396+  0A00 C7 F5 09    	jne putsn_L0
0397+  0A03             putsn_end:
0398+  0A03 E6          	pop c
0399+  0A04 E7          	pop d
0400+  0A05 E8          	pop al
0401+  0A06 09          	ret
0402+  0A07             
0403+  0A07             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  0A07             ; print 16bit decimal number
0405+  0A07             ; input number in A
0406+  0A07             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  0A07             print_u16d:
0408+  0A07 D7          	push a
0409+  0A08 D8          	push b
0410+  0A09 26 10 27    	mov b, 10000
0411+  0A0C AE          	div a, b			; get 10000 coeff.
0412+  0A0D 07 33 0A    	call print_number
0413+  0A10 11          	mov a, b
0414+  0A11 26 E8 03    	mov b, 1000
0415+  0A14 AE          	div a, b			; get 10000 coeff.
0416+  0A15 07 33 0A    	call print_number
0417+  0A18 11          	mov a, b
0418+  0A19 26 64 00    	mov b, 100
0419+  0A1C AE          	div a, b
0420+  0A1D 07 33 0A    	call print_number
0421+  0A20 11          	mov a, b
0422+  0A21 26 0A 00    	mov b, 10
0423+  0A24 AE          	div a, b
0424+  0A25 07 33 0A    	call print_number
0425+  0A28 11          	mov a, b
0426+  0A29 6A 30       	add al, $30
0427+  0A2B 23          	mov ah, al
0428+  0A2C 19 00       	mov al, 0
0429+  0A2E 05 03       	syscall sys_io	; print coeff
0430+  0A30 E5          	pop b
0431+  0A31 E4          	pop a
0432+  0A32 09          	ret
0433+  0A33             
0434+  0A33             
0435+  0A33             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  0A33             ; if A == 0, print space
0437+  0A33             ; else print A
0438+  0A33             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0439+  0A33             print_number:
0440+  0A33 6A 30       	add al, $30
0441+  0A35 23          	mov ah, al
0442+  0A36 07 A4 08    	call putchar
0443+  0A39 09          	ret
0444+  0A3A             
0445+  0A3A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0446+  0A3A             ; PRINT 16BIT HEX INTEGER
0447+  0A3A             ; integer value in reg B
0448+  0A3A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  0A3A             print_u16x:
0450+  0A3A D7          	push a
0451+  0A3B D8          	push b
0452+  0A3C DD          	push bl
0453+  0A3D 30          	mov bl, bh
0454+  0A3E 07 6B 08    	call itoa				; convert bh to char in A
0455+  0A41 2F          	mov bl, al				; save al
0456+  0A42 19 00       	mov al, 0
0457+  0A44 05 03       	syscall sys_io				; display AH
0458+  0A46 24          	mov ah, bl				; retrieve al
0459+  0A47 19 00       	mov al, 0
0460+  0A49 05 03       	syscall sys_io				; display AL
0461+  0A4B             
0462+  0A4B EA          	pop bl
0463+  0A4C 07 6B 08    	call itoa				; convert bh to char in A
0464+  0A4F 2F          	mov bl, al				; save al
0465+  0A50 19 00       	mov al, 0
0466+  0A52 05 03       	syscall sys_io				; display AH
0467+  0A54 24          	mov ah, bl				; retrieve al
0468+  0A55 19 00       	mov al, 0
0469+  0A57 05 03       	syscall sys_io				; display AL
0470+  0A59             
0471+  0A59 E5          	pop b
0472+  0A5A E4          	pop a
0473+  0A5B 09          	ret
0474+  0A5C             
0475+  0A5C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  0A5C             ; INPUT 16BIT HEX INTEGER
0477+  0A5C             ; read 16bit integer into A
0478+  0A5C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  0A5C             scan_u16x:
0480+  0A5C F8 10 00    	enter 16
0481+  0A5F D8          	push b
0482+  0A60 DA          	push d
0483+  0A61             
0484+  0A61 FA F1 FF    	lea d, [bp + -15]
0485+  0A64 07 AB 08    	call gets				; get number
0486+  0A67             
0487+  0A67 32          	mov bl, [d]
0488+  0A68 37          	mov bh, bl
0489+  0A69 33 01 00    	mov bl, [d + 1]
0490+  0A6C 07 59 08    	call atoi				; convert to int in AL
0491+  0A6F 23          	mov ah, al				; move to AH
0492+  0A70             
0493+  0A70 33 02 00    	mov bl, [d + 2]
0494+  0A73 37          	mov bh, bl
0495+  0A74 33 03 00    	mov bl, [d + 3]
0496+  0A77 07 59 08    	call atoi				; convert to int in AL
0497+  0A7A             
0498+  0A7A E7          	pop d
0499+  0A7B E5          	pop b
0500+  0A7C F9          	leave
0501+  0A7D 09          	ret
0502+  0A7E             
0503+  0A7E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0504+  0A7E             ; PRINT 8bit HEX INTEGER
0505+  0A7E             ; integer value in reg bl
0506+  0A7E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  0A7E             print_u8x:
0508+  0A7E D7          	push a
0509+  0A7F DD          	push bl
0510+  0A80             
0511+  0A80 07 6B 08    	call itoa				; convert bl to char in A
0512+  0A83 2F          	mov bl, al				; save al
0513+  0A84 19 00       	mov al, 0
0514+  0A86 05 03       	syscall sys_io				; display AH
0515+  0A88 24          	mov ah, bl				; retrieve al
0516+  0A89 19 00       	mov al, 0
0517+  0A8B 05 03       	syscall sys_io				; display AL
0518+  0A8D             
0519+  0A8D EA          	pop bl
0520+  0A8E E4          	pop a
0521+  0A8F 09          	ret
0522+  0A90             
0523+  0A90             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0524+  0A90             ; print 8bit decimal unsigned number
0525+  0A90             ; input number in AL
0526+  0A90             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  0A90             print_u8d:
0528+  0A90 D7          	push a
0529+  0A91 D8          	push b
0530+  0A92             
0531+  0A92 22 00       	mov ah, 0
0532+  0A94 26 64 00    	mov b, 100
0533+  0A97 AE          	div a, b
0534+  0A98 D8          	push b			; save remainder
0535+  0A99 B9 00       	cmp al, 0
0536+  0A9B C6 A5 0A    	je skip100
0537+  0A9E 6A 30       	add al, $30
0538+  0AA0 23          	mov ah, al
0539+  0AA1 19 00       	mov al, 0
0540+  0AA3 05 03       	syscall sys_io	; print coeff
0541+  0AA5             skip100:
0542+  0AA5 E4          	pop a
0543+  0AA6 22 00       	mov ah, 0
0544+  0AA8 26 0A 00    	mov b, 10
0545+  0AAB AE          	div a, b
0546+  0AAC D8          	push b			; save remainder
0547+  0AAD B9 00       	cmp al, 0
0548+  0AAF C6 B9 0A    	je skip10
0549+  0AB2 6A 30       	add al, $30
0550+  0AB4 23          	mov ah, al
0551+  0AB5 19 00       	mov al, 0
0552+  0AB7 05 03       	syscall sys_io	; print coeff
0553+  0AB9             skip10:
0554+  0AB9 E4          	pop a
0555+  0ABA 1B          	mov al, bl
0556+  0ABB 6A 30       	add al, $30
0557+  0ABD 23          	mov ah, al
0558+  0ABE 19 00       	mov al, 0
0559+  0AC0 05 03       	syscall sys_io	; print coeff
0560+  0AC2 E5          	pop b
0561+  0AC3 E4          	pop a
0562+  0AC4 09          	ret
0563+  0AC5             
0564+  0AC5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0565+  0AC5             ; INPUT 8BIT HEX INTEGER
0566+  0AC5             ; read 8bit integer into AL
0567+  0AC5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  0AC5             scan_u8x:
0569+  0AC5 F8 04 00    	enter 4
0570+  0AC8 D8          	push b
0571+  0AC9 DA          	push d
0572+  0ACA             
0573+  0ACA FA FD FF    	lea d, [bp + -3]
0574+  0ACD 07 AB 08    	call gets				; get number
0575+  0AD0             
0576+  0AD0 32          	mov bl, [d]
0577+  0AD1 37          	mov bh, bl
0578+  0AD2 33 01 00    	mov bl, [d + 1]
0579+  0AD5 07 59 08    	call atoi				; convert to int in AL
0580+  0AD8             
0581+  0AD8 E7          	pop d
0582+  0AD9 E5          	pop b
0583+  0ADA F9          	leave
0584+  0ADB 09          	ret
0585+  0ADC             
0586+  0ADC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  0ADC             ; input decimal number
0588+  0ADC             ; result in A
0589+  0ADC             ; 655'\0'
0590+  0ADC             ; low--------high
0591+  0ADC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0592+  0ADC             scan_u16d:
0593+  0ADC F8 08 00    	enter 8
0594+  0ADF E2          	push si
0595+  0AE0 D8          	push b
0596+  0AE1 D9          	push c
0597+  0AE2 DA          	push d
0598+  0AE3 FA F9 FF    	lea d, [bp +- 7]
0599+  0AE6 07 AB 08    	call gets
0600+  0AE9 07 D9 07    	call strlen			; get string length in C
0601+  0AEC 7E          	dec c
0602+  0AED FD 4E       	mov si, d
0603+  0AEF 12          	mov a, c
0604+  0AF0 FD 99       	shl a
0605+  0AF2 3B 41 08    	mov d, table_power
0606+  0AF5 59          	add d, a
0607+  0AF6 38 00 00    	mov c, 0
0608+  0AF9             mul_loop:
0609+  0AF9 F6          	lodsb			; load ASCII to al
0610+  0AFA B9 00       	cmp al, 0
0611+  0AFC C6 0F 0B    	je mul_exit
0612+  0AFF 6F 30       	sub al, $30		; make into integer
0613+  0B01 22 00       	mov ah, 0
0614+  0B03 2A          	mov b, [d]
0615+  0B04 AC          	mul a, b			; result in B since it fits in 16bits
0616+  0B05 11          	mov a, b
0617+  0B06 28          	mov b, c
0618+  0B07 54          	add a, b
0619+  0B08 39          	mov c, a
0620+  0B09 63 02 00    	sub d, 2
0621+  0B0C 0A F9 0A    	jmp mul_loop
0622+  0B0F             mul_exit:
0623+  0B0F 12          	mov a, c
0624+  0B10 E7          	pop d
0625+  0B11 E6          	pop c
0626+  0B12 E5          	pop b
0627+  0B13 EF          	pop si
0628+  0B14 F9          	leave
0629+  0B15 09          	ret
0256   0B16             ; --- END INCLUDE BLOCK
0257   0B16             
0258   0B16             
0259   0B16             .end
tasm: Number of errors = 2
