0001   0000             ; --- Filename: pascal.c
0002   0000             
0003   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0004   0000             
0005   0400             .org PROC_TEXT_ORG
0006   0400             
0007   0400             ; --- begin text block
0008   0400             main:
0009   0400 D2          	push bp
0010   0401 9B          	mov bp, sp
0011   0402             ; --- begin asm block
0012   0402 14 66 05    		mov a, [s]
0013   0405 3C          		mov d, a
0014   0406 07 C2 07    		call puts
0015   0409 07 C0 08    		call scan_u16d
0016   040C 42 71 05    		mov [rows], a
0017   040F             	; --- end asm block
0018   040F             _for1_init:
0019   040F 26 00 00      mov b, 0
0020   0412 FD 42 75 05   mov [i], b
0021   0416             _for1_cond:
0022   0416 29 75 05      mov b, [i]
0023   0419 D7            push a
0024   041A 11            mov a, b
0025   041B 29 71 05      mov b, [rows]
0026   041E B0            cmp a, b
0027   041F 0E            lodflgs
0028   0420 87 02         and al, %00000010
0029   0422 22 00         mov ah, 0
0030   0424 27            mov b, a
0031   0425 E4            pop a
0032   0426 11            mov a, b
0033   0427 AF 00 00      cmp a, 0
0034   042A C6 33 05      je _for1_exit
0035   042D             _for1_block:
0036   042D             _for2_init:
0037   042D 26 01 00      mov b, 1
0038   0430 FD 42 73 05   mov [space], b
0039   0434             _for2_cond:
0040   0434 29 73 05      mov b, [space]
0041   0437 D7            push a
0042   0438 11            mov a, b
0043   0439 29 71 05      mov b, [rows]
0044   043C D7            push a
0045   043D 11            mov a, b
0046   043E 29 75 05      mov b, [i]
0047   0441 60            sub a, b
0048   0442 27            mov b, a
0049   0443 E4            pop a
0050   0444 B0            cmp a, b
0051   0445 0E            lodflgs
0052   0446 87 03         and al, %00000011
0053   0448 22 00         mov ah, 0
0054   044A 27            mov b, a
0055   044B E4            pop a
0056   044C 11            mov a, b
0057   044D AF 00 00      cmp a, 0
0058   0450 C6 68 04      je _for2_exit
0059   0453             _for2_block:
0060   0453 07 40 05      call print
0061   0456             _for2_update:
0062   0456 29 73 05      mov b, [space]
0063   0459 D7            push a
0064   045A 11            mov a, b
0065   045B 26 01 00      mov b, 1
0066   045E 54            add a, b
0067   045F 27            mov b, a
0068   0460 E4            pop a
0069   0461 FD 42 73 05   mov [space], b
0070   0465 0A 34 04      jmp _for2_cond
0071   0468             _for2_exit:
0072   0468             _for3_init:
0073   0468 26 00 00      mov b, 0
0074   046B FD 42 77 05   mov [j], b
0075   046F             _for3_cond:
0076   046F 29 77 05      mov b, [j]
0077   0472 D7            push a
0078   0473 11            mov a, b
0079   0474 29 75 05      mov b, [i]
0080   0477 B0            cmp a, b
0081   0478 0E            lodflgs
0082   0479 87 03         and al, %00000011
0083   047B 22 00         mov ah, 0
0084   047D 27            mov b, a
0085   047E E4            pop a
0086   047F 11            mov a, b
0087   0480 AF 00 00      cmp a, 0
0088   0483 C6 1A 05      je _for3_exit
0089   0486             _for3_block:
0090   0486             _if4_cond:
0091   0486 29 77 05      mov b, [j]
0092   0489 D7            push a
0093   048A 11            mov a, b
0094   048B 26 00 00      mov b, 0
0095   048E B0            cmp a, b
0096   048F 0E            lodflgs
0097   0490 87 01         and al, %00000001
0098   0492 22 00         mov ah, 0
0099   0494 27            mov b, a
0100   0495 E4            pop a
0101   0496 D7            push a
0102   0497 11            mov a, b
0103   0498 29 75 05      mov b, [i]
0104   049B D7            push a
0105   049C 11            mov a, b
0106   049D 26 00 00      mov b, 0
0107   04A0 B0            cmp a, b
0108   04A1 0E            lodflgs
0109   04A2 87 01         and al, %00000001
0110   04A4 22 00         mov ah, 0
0111   04A6 27            mov b, a
0112   04A7 E4            pop a
0113   04A8 C0 00 00      cmp b, 0
0114   04AB D7            push a
0115   04AC 0E            lodflgs
0116   04AD 27            mov b, a
0117   04AE E4            pop a
0118   04AF 98            not bl
0119   04B0 FD 87 01      and bl, %00000001
0120   04B3 A7 00         mov bh, 0
0121   04B5 AF 00 00      cmp a, 0
0122   04B8 0E            lodflgs
0123   04B9 96            not al
0124   04BA 87 01         and al, %00000001
0125   04BC 22 00         mov ah, 0
0126   04BE 8A            or a, b
0127   04BF 27            mov b, a
0128   04C0 E4            pop a
0129   04C1 C0 00 00      cmp b, 0
0130   04C4 C6 D1 04      je _if4_else_block
0131   04C7             _if4_block:
0132   04C7 26 01 00      mov b, 1
0133   04CA FD 42 6F 05   mov [coef], b
0134   04CE 0A FB 04      jmp _if4_exit
0135   04D1             _if4_else_block:
0136   04D1 29 6F 05      mov b, [coef]
0137   04D4 D7            push a
0138   04D5 11            mov a, b
0139   04D6 29 75 05      mov b, [i]
0140   04D9 D7            push a
0141   04DA 11            mov a, b
0142   04DB 29 77 05      mov b, [j]
0143   04DE 60            sub a, b
0144   04DF 27            mov b, a
0145   04E0 E4            pop a
0146   04E1 D7            push a
0147   04E2 11            mov a, b
0148   04E3 26 01 00      mov b, 1
0149   04E6 54            add a, b
0150   04E7 27            mov b, a
0151   04E8 E4            pop a
0152   04E9 AC            mul a, b
0153   04EA E4            pop a
0154   04EB D7            push a
0155   04EC 11            mov a, b
0156   04ED 29 77 05      mov b, [j]
0157   04F0 AE            div a, b
0158   04F1 FD 78         mov g, a
0159   04F3 11            mov a, b
0160   04F4 FD 27         mov b, g
0161   04F6 E4            pop a
0162   04F7 FD 42 6F 05   mov [coef], b
0163   04FB             _if4_exit:
0164   04FB 07 40 05      call print
0165   04FE 29 6F 05      mov b, [coef]
0166   0501 D8            push b
0167   0502 07 36 05      call print_nbr
0168   0505 51 02 00      add sp, 2
0169   0508             _for3_update:
0170   0508 29 77 05      mov b, [j]
0171   050B D7            push a
0172   050C 11            mov a, b
0173   050D 26 01 00      mov b, 1
0174   0510 54            add a, b
0175   0511 27            mov b, a
0176   0512 E4            pop a
0177   0513 FD 42 77 05   mov [j], b
0178   0517 0A 6F 04      jmp _for3_cond
0179   051A             _for3_exit:
0180   051A             ; --- begin asm block
0181   051A 14 7C 05    			mov a, [nl]
0182   051D 3C          			mov d, a
0183   051E 07 C2 07    			call puts
0184   0521             		; --- end asm block
0185   0521             _for1_update:
0186   0521 29 75 05      mov b, [i]
0187   0524 D7            push a
0188   0525 11            mov a, b
0189   0526 26 01 00      mov b, 1
0190   0529 54            add a, b
0191   052A 27            mov b, a
0192   052B E4            pop a
0193   052C FD 42 75 05   mov [i], b
0194   0530 0A 16 04      jmp _for1_cond
0195   0533             _for1_exit:
0196   0533 F9            leave
0197   0534 05 0B         syscall sys_terminate_proc
0198   0536             print_nbr:
0199   0536 D2          	push bp
0200   0537 9B          	mov bp, sp
0201   0538             ; --- begin asm block
0202   0538 17 05 00    	mov a, [bp + 5]
0203   053B 07 EB 07    	call print_u16d
0204   053E               ; --- end asm block
0205   053E F9            leave
0206   053F 09            ret
0207   0540             print:
0208   0540 D2          	push bp
0209   0541 9B          	mov bp, sp
0210   0542             ; --- begin asm block
0211   0542 14 66 05    		mov a, [s]
0212   0545 3C          		mov d, a
0213   0546 07 C2 07    		call puts
0214   0549             	; --- end asm block
0215   0549 F9            leave
0216   054A 09            ret
0217   054B             ; --- end text block
0218   054B             
0219   054B             ; --- begin data block
0220   054B 45 6E 74 65 s_data: .db "Enter the number of rows: ", 0
0220   054F 72 20 74 68 
0220   0553 65 20 6E 75 
0220   0557 6D 62 65 72 
0220   055B 20 6F 66 20 
0220   055F 72 6F 77 73 
0220   0563 3A 20 00 
0221   0566 4B 05       s: .dw s_data
0222   0568 20 20 20 20 ss_data: .db "    ", 0
0222   056C 00 
0223   056D 68 05       ss: .dw ss_data
0224   056F 01 00       coef: .dw 1
0225   0571 00 00       rows: .dw 0
0226   0573 00 00       space: .dw 0
0227   0575 00 00       i: .dw 0
0228   0577 00 00       j: .dw 0
0229   0579 0A 0D 00    nl_data: .db "\n\r", 0
0230   057C 79 05       nl: .dw nl_data
0231   057E             ; --- end data block
0232   057E             ; --- begin include block
0233   057E             .include "lib/stdio.asm"
0001+  057E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  057E             ; stdio.s
0003+  057E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  057E             .include "lib/string.asm"
0001++ 057E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 057E             ; string.s
0003++ 057E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 057E             
0005++ 057E             
0006++ 057E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 057E             ; strrev
0008++ 057E             ; reverse a string
0009++ 057E             ; D = string address
0010++ 057E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 057E             ; 01234
0012++ 057E             strrev:
0013++ 057E 4B          	pusha
0014++ 057F 07 C5 05    	call strlen	; length in C
0015++ 0582 12          	mov a, c
0016++ 0583 AF 01 00    	cmp a, 1
0017++ 0586 D0 A0 05    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0589 7D          	dec a
0019++ 058A FD 4E       	mov si, d	; beginning of string
0020++ 058C FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 058E 59          	add d, a	; end of string
0022++ 058F 12          	mov a, c
0023++ 0590 FD 9B       	shr a		; divide by 2
0024++ 0592 39          	mov c, a	; C now counts the steps
0025++ 0593             strrev_L0:
0026++ 0593 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0594 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0595 3E          	mov [d], al	; store left char into right side
0029++ 0596 1B          	mov al, bl
0030++ 0597 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0598 7E          	dec c
0032++ 0599 7F          	dec d
0033++ 059A C2 00 00    	cmp c, 0
0034++ 059D C7 93 05    	jne strrev_L0
0035++ 05A0             strrev_end:
0036++ 05A0 4C          	popa
0037++ 05A1 09          	ret
0038++ 05A2             	
0039++ 05A2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 05A2             ; strchr
0041++ 05A2             ; search string in D for char in AL
0042++ 05A2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 05A2             strchr:
0044++ 05A2             strchr_L0:
0045++ 05A2 32          	mov bl, [d]
0046++ 05A3 C1 00       	cmp bl, 0
0047++ 05A5 C6 B0 05    	je strchr_end
0048++ 05A8 BA          	cmp al, bl
0049++ 05A9 C6 B0 05    	je strchr_end
0050++ 05AC 79          	inc d
0051++ 05AD 0A A2 05    	jmp strchr_L0
0052++ 05B0             strchr_end:
0053++ 05B0 1B          	mov al, bl
0054++ 05B1 09          	ret
0055++ 05B2             
0056++ 05B2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 05B2             ; strstr
0058++ 05B2             ; find sub-string
0059++ 05B2             ; str1 in SI
0060++ 05B2             ; str2 in DI
0061++ 05B2             ; SI points to end of source string
0062++ 05B2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 05B2             strstr:
0064++ 05B2 DB          	push al
0065++ 05B3 DA          	push d
0066++ 05B4 E3          	push di
0067++ 05B5             strstr_loop:
0068++ 05B5 F3          	cmpsb					; compare a byte of the strings
0069++ 05B6 C7 C1 05    	jne strstr_ret
0070++ 05B9 FC 00 00    	lea d, [di + 0]
0071++ 05BC BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 05BE C7 B5 05    	jne strstr_loop				; equal chars but not at end
0073++ 05C1             strstr_ret:
0074++ 05C1 F0          	pop di
0075++ 05C2 E7          	pop d
0076++ 05C3 E8          	pop al
0077++ 05C4 09          	ret
0078++ 05C5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 05C5             ; length of null terminated string
0080++ 05C5             ; result in C
0081++ 05C5             ; pointer in D
0082++ 05C5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 05C5             strlen:
0084++ 05C5 DA          	push d
0085++ 05C6 38 00 00    	mov c, 0
0086++ 05C9             strlen_L1:
0087++ 05C9 BD 00       	cmp byte [d], 0
0088++ 05CB C6 D3 05    	je strlen_ret
0089++ 05CE 79          	inc d
0090++ 05CF 78          	inc c
0091++ 05D0 0A C9 05    	jmp strlen_L1
0092++ 05D3             strlen_ret:
0093++ 05D3 E7          	pop d
0094++ 05D4 09          	ret
0095++ 05D5             
0096++ 05D5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 05D5             ; STRCMP
0098++ 05D5             ; compare two strings
0099++ 05D5             ; str1 in SI
0100++ 05D5             ; str2 in DI
0101++ 05D5             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 05D5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 05D5             strcmp:
0104++ 05D5 DB          	push al
0105++ 05D6 DA          	push d
0106++ 05D7 E3          	push di
0107++ 05D8 E2          	push si
0108++ 05D9             strcmp_loop:
0109++ 05D9 F3          	cmpsb					; compare a byte of the strings
0110++ 05DA C7 E5 05    	jne strcmp_ret
0111++ 05DD FB FF FF    	lea d, [si +- 1]
0112++ 05E0 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 05E2 C7 D9 05    	jne strcmp_loop				; equal chars but not at end
0114++ 05E5             strcmp_ret:
0115++ 05E5 EF          	pop si
0116++ 05E6 F0          	pop di
0117++ 05E7 E7          	pop d
0118++ 05E8 E8          	pop al
0119++ 05E9 09          	ret
0120++ 05EA             
0121++ 05EA             
0122++ 05EA             ; STRCPY
0123++ 05EA             ; copy null terminated string from SI to DI
0124++ 05EA             ; source in SI
0125++ 05EA             ; destination in DI
0126++ 05EA             strcpy:
0127++ 05EA E2          	push si
0128++ 05EB E3          	push di
0129++ 05EC DB          	push al
0130++ 05ED             strcpy_L1:
0131++ 05ED F6          	lodsb
0132++ 05EE F7          	stosb
0133++ 05EF B9 00       	cmp al, 0
0134++ 05F1 C7 ED 05    	jne strcpy_L1
0135++ 05F4             strcpy_end:
0136++ 05F4 E8          	pop al
0137++ 05F5 F0          	pop di
0138++ 05F6 EF          	pop si
0139++ 05F7 09          	ret
0140++ 05F8             
0141++ 05F8             ; STRCAT
0142++ 05F8             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 05F8             ; source in SI
0144++ 05F8             ; destination in DI
0145++ 05F8             strcat:
0146++ 05F8 E2          	push si
0147++ 05F9 E3          	push di
0148++ 05FA D7          	push a
0149++ 05FB DA          	push d
0150++ 05FC 50          	mov a, di
0151++ 05FD 3C          	mov d, a
0152++ 05FE             strcat_goto_end_L1:
0153++ 05FE BD 00       	cmp byte[d], 0
0154++ 0600 C6 07 06    	je strcat_start
0155++ 0603 79          	inc d
0156++ 0604 0A FE 05    	jmp strcat_goto_end_L1
0157++ 0607             strcat_start:
0158++ 0607 FD 50       	mov di, d
0159++ 0609             strcat_L1:
0160++ 0609 F6          	lodsb
0161++ 060A F7          	stosb
0162++ 060B B9 00       	cmp al, 0
0163++ 060D C7 09 06    	jne strcat_L1
0164++ 0610             strcat_end:
0165++ 0610 E7          	pop d
0166++ 0611 E4          	pop a
0167++ 0612 F0          	pop di
0168++ 0613 EF          	pop si
0169++ 0614 09          	ret
0005+  0615             
0006+  0615 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  0619 34 35 36 37 
0006+  061D 38 39 41 42 
0006+  0621 43 44 45 46 
0007+  0625             
0008+  0625 01 00       table_power:.dw 1
0009+  0627 0A 00       			.dw 10
0010+  0629 64 00       			.dw 100
0011+  062B E8 03       			.dw 1000
0012+  062D 10 27       			.dw 10000
0013+  062F             
0014+  062F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0015+  062F             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0016+  062F             ; ASCII in BL
0017+  062F             ; result in AL
0018+  062F             ; ascii for F = 0100 0110
0019+  062F             ; ascii for 9 = 0011 1001
0020+  062F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0021+  062F             hex_ascii_encode:
0022+  062F 1B          	mov al, bl
0023+  0630 93 40       	test al, $40				; test if letter or number
0024+  0632 C7 38 06    	jnz hex_letter
0025+  0635 87 0F       	and al, $0F				; get number
0026+  0637 09          	ret
0027+  0638             hex_letter:
0028+  0638 87 0F       	and al, $0F				; get letter
0029+  063A 6A 09       	add al, 9
0030+  063C 09          	ret
0031+  063D             
0032+  063D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0033+  063D             ; ATOI
0034+  063D             ; 2 letter hex string in B
0035+  063D             ; 8bit integer returned in AL
0036+  063D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0037+  063D             atoi:
0038+  063D D8          	push b
0039+  063E 07 2F 06    	call hex_ascii_encode			; convert BL to 4bit code in AL
0040+  0641 30          	mov bl, bh
0041+  0642 DB          	push al					; save a
0042+  0643 07 2F 06    	call hex_ascii_encode
0043+  0646 EA          	pop bl	
0044+  0647 FD 9E 04    	shl al, 4
0045+  064A 8C          	or al, bl
0046+  064B E5          	pop b
0047+  064C 09          	ret	
0048+  064D             
0049+  064D             
0050+  064D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  064D             ; printf
0052+  064D             ; no need for explanations!
0053+  064D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0054+  064D             printf:
0055+  064D 09          	ret
0056+  064E             
0057+  064E             
0058+  064E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  064E             ; scanf
0060+  064E             ; no need for explanations!
0061+  064E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  064E             scanf:
0063+  064E 09          	ret
0064+  064F             
0065+  064F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  064F             ; ITOA
0067+  064F             ; 8bit value in BL
0068+  064F             ; 2 byte ASCII result in A
0069+  064F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0070+  064F             itoa:
0071+  064F DA          	push d
0072+  0650 D8          	push b
0073+  0651 A7 00       	mov bh, 0
0074+  0653 FD A4 04    	shr bl, 4	
0075+  0656 74          	mov d, b
0076+  0657 1F 15 06    	mov al, [d + s_hex_digits]
0077+  065A 23          	mov ah, al
0078+  065B             	
0079+  065B E5          	pop b
0080+  065C D8          	push b
0081+  065D A7 00       	mov bh, 0
0082+  065F FD 87 0F    	and bl, $0F
0083+  0662 74          	mov d, b
0084+  0663 1F 15 06    	mov al, [d + s_hex_digits]
0085+  0666 E5          	pop b
0086+  0667 E7          	pop d
0087+  0668 09          	ret
0088+  0669             
0089+  0669             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0090+  0669             ; HEX STRING TO BINARY
0091+  0669             ; di = destination address
0092+  0669             ; si = source
0093+  0669             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0094+  0669             hex_to_int:
0095+  0669             hex_to_int_L1:
0096+  0669 F6          	lodsb					; load from [SI] to AL
0097+  066A B9 00       	cmp al, 0				; check if ASCII 0
0098+  066C C6 79 06    	jz hex_to_int_ret
0099+  066F 36          	mov bh, al
0100+  0670 F6          	lodsb
0101+  0671 2F          	mov bl, al
0102+  0672 07 3D 06    	call atoi				; convert ASCII byte in B to int (to AL)
0103+  0675 F7          	stosb					; store AL to [DI]
0104+  0676 0A 69 06    	jmp hex_to_int_L1
0105+  0679             hex_to_int_ret:
0106+  0679 09          	ret		
0107+  067A             
0108+  067A             
0109+  067A             
0110+  067A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  067A             ; GETCHAR
0112+  067A             ; char in ah
0113+  067A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0114+  067A             getchar:
0115+  067A DB          	push al
0116+  067B             getchar_retry:
0117+  067B FD 0C       	sti
0118+  067D 19 01       	mov al, 1
0119+  067F 05 03       	syscall sys_io			; receive in AH
0120+  0681 B9 00       	cmp al, 0			; check if any char was receive
0121+  0683 C6 7B 06    	je getchar_retry
0122+  0686 E8          	pop al
0123+  0687 09          	ret
0124+  0688             
0125+  0688             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0126+  0688             ; PUTCHAR
0127+  0688             ; char in ah
0128+  0688             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  0688             putchar:
0130+  0688 D7          	push a
0131+  0689 19 00       	mov al, 0
0132+  068B 05 03       	syscall sys_io			; char in AH
0133+  068D E4          	pop a
0134+  068E 09          	ret
0135+  068F             
0136+  068F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0137+  068F             ;; INPUT A STRING
0138+  068F             ;; terminates with null
0139+  068F             ;; pointer in D
0140+  068F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  068F             gets:
0142+  068F D7          	push a
0143+  0690 DA          	push d
0144+  0691             gets_loop:
0145+  0691 FD 0C       	sti
0146+  0693 19 01       	mov al, 1
0147+  0695 05 03       	syscall sys_io			; receive in AH
0148+  0697 B9 00       	cmp al, 0				; check error code (AL)
0149+  0699 C6 91 06    	je gets_loop			; if no char received, retry
0150+  069C             
0151+  069C 76 1B       	cmp ah, 27
0152+  069E C6 BF 06    	je gets_telnet_escape
0153+  06A1 76 0A       	cmp ah, $0A				; LF
0154+  06A3 C6 18 07    	je gets_end
0155+  06A6 76 0D       	cmp ah, $0D				; CR
0156+  06A8 C6 18 07    	je gets_end
0157+  06AB 76 5C       	cmp ah, $5C				; '\\'
0158+  06AD C6 EF 06    	je gets_escape
0159+  06B0             	
0160+  06B0 76 08       	cmp ah, $08			; check for backspace
0161+  06B2 C6 BB 06    	je gets_backspace
0162+  06B5             
0163+  06B5 1A          	mov al, ah
0164+  06B6 3E          	mov [d], al
0165+  06B7 79          	inc d
0166+  06B8 0A 91 06    	jmp gets_loop
0167+  06BB             gets_backspace:
0168+  06BB 7F          	dec d
0169+  06BC 0A 91 06    	jmp gets_loop
0170+  06BF             gets_telnet_escape:
0171+  06BF FD 0C       	sti
0172+  06C1 19 01       	mov al, 1
0173+  06C3 05 03       	syscall sys_io				; receive in AH without echo
0174+  06C5 B9 00       	cmp al, 0					; check error code (AL)
0175+  06C7 C6 BF 06    	je gets_telnet_escape		; if no char received, retry
0176+  06CA 76 5B       	cmp ah, '['
0177+  06CC C7 91 06    	jne gets_loop
0178+  06CF             gets_telnet_escape_phase2:
0179+  06CF FD 0C       	sti
0180+  06D1 19 01       	mov al, 1
0181+  06D3 05 03       	syscall sys_io					; receive in AH without echo
0182+  06D5 B9 00       	cmp al, 0						; check error code (AL)
0183+  06D7 C6 CF 06    	je gets_telnet_escape_phase2	; if no char received, retry
0184+  06DA 76 44       	cmp ah, 'D'
0185+  06DC C6 E7 06    	je gets_left_arrow
0186+  06DF 76 43       	cmp ah, 'C'
0187+  06E1 C6 EB 06    	je gets_right_arrow
0188+  06E4 0A 91 06    	jmp gets_loop
0189+  06E7             gets_left_arrow:
0190+  06E7 7F          	dec d
0191+  06E8 0A 91 06    	jmp gets_loop
0192+  06EB             gets_right_arrow:
0193+  06EB 79          	inc d
0194+  06EC 0A 91 06    	jmp gets_loop
0195+  06EF             gets_escape:
0196+  06EF FD 0C       	sti
0197+  06F1 19 01       	mov al, 1
0198+  06F3 05 03       	syscall sys_io			; receive in AH
0199+  06F5 B9 00       	cmp al, 0				; check error code (AL)
0200+  06F7 C6 EF 06    	je gets_escape			; if no char received, retry
0201+  06FA 76 6E       	cmp ah, 'n'
0202+  06FC C6 0A 07    	je gets_LF
0203+  06FF 76 72       	cmp ah, 'r'
0204+  0701 C6 11 07    	je gets_CR
0205+  0704 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0206+  0705 3E          	mov [d], al
0207+  0706 79          	inc d
0208+  0707 0A 91 06    	jmp gets_loop
0209+  070A             gets_LF:
0210+  070A 19 0A       	mov al, $0A
0211+  070C 3E          	mov [d], al
0212+  070D 79          	inc d
0213+  070E 0A 91 06    	jmp gets_loop
0214+  0711             gets_CR:
0215+  0711 19 0D       	mov al, $0D
0216+  0713 3E          	mov [d], al
0217+  0714 79          	inc d
0218+  0715 0A 91 06    	jmp gets_loop
0219+  0718             gets_end:
0220+  0718 19 00       	mov al, 0
0221+  071A 3E          	mov [d], al				; terminate string
0222+  071B E7          	pop d
0223+  071C E4          	pop a
0224+  071D 09          	ret
0225+  071E             
0226+  071E             
0227+  071E             
0228+  071E             
0229+  071E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0230+  071E             ;; INPUT TEXT
0231+  071E             ;; terminated with CTRL+D
0232+  071E             ;; pointer in D
0233+  071E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0234+  071E             gettxt:
0235+  071E D7          	push a
0236+  071F DA          	push d
0237+  0720             gettxt_loop:
0238+  0720 19 01       	mov al, 1
0239+  0722 05 03       	syscall sys_io			; receive in AH
0240+  0724 B9 00       	cmp al, 0				; check error code (AL)
0241+  0726 C6 20 07    	je gettxt_loop		; if no char received, retry
0242+  0729 76 04       	cmp ah, 4			; EOT
0243+  072B C6 69 07    	je gettxt_end
0244+  072E 76 08       	cmp ah, $08			; check for backspace
0245+  0730 C6 65 07    	je gettxt_backspace
0246+  0733 76 5C       	cmp ah, $5C				; '\\'
0247+  0735 C6 3E 07    	je gettxt_escape
0248+  0738 1A          	mov al, ah
0249+  0739 3E          	mov [d], al
0250+  073A 79          	inc d
0251+  073B 0A 20 07    	jmp gettxt_loop
0252+  073E             gettxt_escape:
0253+  073E 19 01       	mov al, 1
0254+  0740 05 03       	syscall sys_io			; receive in AH
0255+  0742 B9 00       	cmp al, 0				; check error code (AL)
0256+  0744 C6 3E 07    	je gettxt_escape		; if no char received, retry
0257+  0747 76 6E       	cmp ah, 'n'
0258+  0749 C6 57 07    	je gettxt_LF
0259+  074C 76 72       	cmp ah, 'r'
0260+  074E C6 5E 07    	je gettxt_CR
0261+  0751 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0262+  0752 3E          	mov [d], al
0263+  0753 79          	inc d
0264+  0754 0A 20 07    	jmp gettxt_loop
0265+  0757             gettxt_LF:
0266+  0757 19 0A       	mov al, $0A
0267+  0759 3E          	mov [d], al
0268+  075A 79          	inc d
0269+  075B 0A 20 07    	jmp gettxt_loop
0270+  075E             gettxt_CR:
0271+  075E 19 0D       	mov al, $0D
0272+  0760 3E          	mov [d], al
0273+  0761 79          	inc d
0274+  0762 0A 20 07    	jmp gettxt_loop
0275+  0765             gettxt_backspace:
0276+  0765 7F          	dec d
0277+  0766 0A 20 07    	jmp gettxt_loop
0278+  0769             gettxt_end:
0279+  0769 19 00       	mov al, 0
0280+  076B 3E          	mov [d], al				; terminate string
0281+  076C E7          	pop d
0282+  076D E4          	pop a
0283+  076E 09          	ret
0284+  076F             
0285+  076F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0286+  076F             ; PRINT NEW LINE
0287+  076F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  076F             printnl:
0289+  076F D7          	push a
0290+  0770 10 00 0A    	mov a, $0A00
0291+  0773 05 03       	syscall sys_io
0292+  0775 10 00 0D    	mov a, $0D00
0293+  0778 05 03       	syscall sys_io
0294+  077A E4          	pop a
0295+  077B 09          	ret
0296+  077C             
0297+  077C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0298+  077C             ; strtoint
0299+  077C             ; 4 digit hex string number in d
0300+  077C             ; integer returned in A
0301+  077C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0302+  077C             strtointx:
0303+  077C D8          	push b
0304+  077D 32          	mov bl, [d]
0305+  077E 37          	mov bh, bl
0306+  077F 33 01 00    	mov bl, [d + 1]
0307+  0782 07 3D 06    	call atoi				; convert to int in AL
0308+  0785 23          	mov ah, al				; move to AH
0309+  0786 33 02 00    	mov bl, [d + 2]
0310+  0789 37          	mov bh, bl
0311+  078A 33 03 00    	mov bl, [d + 3]
0312+  078D 07 3D 06    	call atoi				; convert to int in AL
0313+  0790 E5          	pop b
0314+  0791 09          	ret
0315+  0792             
0316+  0792             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0317+  0792             ; strtoint
0318+  0792             ; 5 digit base10 string number in d
0319+  0792             ; integer returned in A
0320+  0792             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0321+  0792             strtoint:
0322+  0792 E2          	push si
0323+  0793 D8          	push b
0324+  0794 D9          	push c
0325+  0795 DA          	push d
0326+  0796 07 C5 05    	call strlen			; get string length in C
0327+  0799 7E          	dec c
0328+  079A FD 4E       	mov si, d
0329+  079C 12          	mov a, c
0330+  079D FD 99       	shl a
0331+  079F 3B 25 06    	mov d, table_power
0332+  07A2 59          	add d, a
0333+  07A3 38 00 00    	mov c, 0
0334+  07A6             strtoint_L0:
0335+  07A6 F6          	lodsb			; load ASCII to al
0336+  07A7 B9 00       	cmp al, 0
0337+  07A9 C6 BC 07    	je strtoint_end
0338+  07AC 6F 30       	sub al, $30		; make into integer
0339+  07AE 22 00       	mov ah, 0
0340+  07B0 2A          	mov b, [d]
0341+  07B1 AC          	mul a, b			; result in B since it fits in 16bits
0342+  07B2 11          	mov a, b
0343+  07B3 28          	mov b, c
0344+  07B4 54          	add a, b
0345+  07B5 39          	mov c, a
0346+  07B6 63 02 00    	sub d, 2
0347+  07B9 0A A6 07    	jmp strtoint_L0
0348+  07BC             strtoint_end:
0349+  07BC 12          	mov a, c
0350+  07BD E7          	pop d
0351+  07BE E6          	pop c
0352+  07BF E5          	pop b
0353+  07C0 EF          	pop si
0354+  07C1 09          	ret
0355+  07C2             
0356+  07C2             
0357+  07C2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0358+  07C2             ; PRINT NULL TERMINATED STRING
0359+  07C2             ; pointer in D
0360+  07C2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0361+  07C2             puts:
0362+  07C2 D7          	push a
0363+  07C3 DA          	push d
0364+  07C4             puts_L1:
0365+  07C4 1E          	mov al, [d]
0366+  07C5 B9 00       	cmp al, 0
0367+  07C7 C6 D3 07    	jz puts_END
0368+  07CA 23          	mov ah, al
0369+  07CB 19 00       	mov al, 0
0370+  07CD 05 03       	syscall sys_io
0371+  07CF 79          	inc d
0372+  07D0 0A C4 07    	jmp puts_L1
0373+  07D3             puts_END:
0374+  07D3 E7          	pop d
0375+  07D4 E4          	pop a
0376+  07D5 09          	ret
0377+  07D6             
0378+  07D6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  07D6             ; PRINT N SIZE STRING
0380+  07D6             ; pointer in D
0381+  07D6             ; size in C
0382+  07D6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0383+  07D6             putsn:
0384+  07D6 DB          	push al
0385+  07D7 DA          	push d
0386+  07D8 D9          	push c
0387+  07D9             putsn_L0:
0388+  07D9 1E          	mov al, [d]
0389+  07DA 23          	mov ah, al
0390+  07DB 19 00       	mov al, 0
0391+  07DD 05 03       	syscall sys_io
0392+  07DF 79          	inc d
0393+  07E0 7E          	dec c	
0394+  07E1 C2 00 00    	cmp c, 0
0395+  07E4 C7 D9 07    	jne putsn_L0
0396+  07E7             putsn_end:
0397+  07E7 E6          	pop c
0398+  07E8 E7          	pop d
0399+  07E9 E8          	pop al
0400+  07EA 09          	ret
0401+  07EB             
0402+  07EB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0403+  07EB             ; print 16bit decimal number
0404+  07EB             ; input number in A
0405+  07EB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  07EB             print_u16d:
0407+  07EB D7          	push a
0408+  07EC D8          	push b
0409+  07ED 26 10 27    	mov b, 10000
0410+  07F0 AE          	div a, b			; get 10000 coeff.
0411+  07F1 07 17 08    	call print_number
0412+  07F4 11          	mov a, b
0413+  07F5 26 E8 03    	mov b, 1000
0414+  07F8 AE          	div a, b			; get 10000 coeff.
0415+  07F9 07 17 08    	call print_number
0416+  07FC 11          	mov a, b
0417+  07FD 26 64 00    	mov b, 100
0418+  0800 AE          	div a, b
0419+  0801 07 17 08    	call print_number
0420+  0804 11          	mov a, b
0421+  0805 26 0A 00    	mov b, 10
0422+  0808 AE          	div a, b
0423+  0809 07 17 08    	call print_number
0424+  080C 11          	mov a, b
0425+  080D 6A 30       	add al, $30
0426+  080F 23          	mov ah, al
0427+  0810 19 00       	mov al, 0
0428+  0812 05 03       	syscall sys_io	; print coeff
0429+  0814 E5          	pop b
0430+  0815 E4          	pop a
0431+  0816 09          	ret
0432+  0817             
0433+  0817             
0434+  0817             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0435+  0817             ; if A == 0, print space
0436+  0817             ; else print A
0437+  0817             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0438+  0817             print_number:
0439+  0817 6A 30       	add al, $30
0440+  0819 23          	mov ah, al
0441+  081A 07 88 06    	call putchar
0442+  081D 09          	ret
0443+  081E             
0444+  081E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  081E             ; PRINT 16BIT HEX INTEGER
0446+  081E             ; integer value in reg B
0447+  081E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  081E             print_u16x:
0449+  081E D7          	push a
0450+  081F D8          	push b
0451+  0820 DD          	push bl
0452+  0821 30          	mov bl, bh
0453+  0822 07 4F 06    	call itoa				; convert bh to char in A
0454+  0825 2F          	mov bl, al				; save al
0455+  0826 19 00       	mov al, 0
0456+  0828 05 03       	syscall sys_io				; display AH
0457+  082A 24          	mov ah, bl				; retrieve al
0458+  082B 19 00       	mov al, 0
0459+  082D 05 03       	syscall sys_io				; display AL
0460+  082F             
0461+  082F EA          	pop bl
0462+  0830 07 4F 06    	call itoa				; convert bh to char in A
0463+  0833 2F          	mov bl, al				; save al
0464+  0834 19 00       	mov al, 0
0465+  0836 05 03       	syscall sys_io				; display AH
0466+  0838 24          	mov ah, bl				; retrieve al
0467+  0839 19 00       	mov al, 0
0468+  083B 05 03       	syscall sys_io				; display AL
0469+  083D             
0470+  083D E5          	pop b
0471+  083E E4          	pop a
0472+  083F 09          	ret
0473+  0840             
0474+  0840             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0475+  0840             ; INPUT 16BIT HEX INTEGER
0476+  0840             ; read 16bit integer into A
0477+  0840             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0478+  0840             scan_u16x:
0479+  0840 F8 10 00    	enter 16
0480+  0843 D8          	push b
0481+  0844 DA          	push d
0482+  0845             
0483+  0845 FA F1 FF    	lea d, [bp + -15]
0484+  0848 07 8F 06    	call gets				; get number
0485+  084B             
0486+  084B 32          	mov bl, [d]
0487+  084C 37          	mov bh, bl
0488+  084D 33 01 00    	mov bl, [d + 1]
0489+  0850 07 3D 06    	call atoi				; convert to int in AL
0490+  0853 23          	mov ah, al				; move to AH
0491+  0854             
0492+  0854 33 02 00    	mov bl, [d + 2]
0493+  0857 37          	mov bh, bl
0494+  0858 33 03 00    	mov bl, [d + 3]
0495+  085B 07 3D 06    	call atoi				; convert to int in AL
0496+  085E             
0497+  085E E7          	pop d
0498+  085F E5          	pop b
0499+  0860 F9          	leave
0500+  0861 09          	ret
0501+  0862             
0502+  0862             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0503+  0862             ; PRINT 8bit HEX INTEGER
0504+  0862             ; integer value in reg bl
0505+  0862             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0506+  0862             print_u8x:
0507+  0862 D7          	push a
0508+  0863 DD          	push bl
0509+  0864             
0510+  0864 07 4F 06    	call itoa				; convert bl to char in A
0511+  0867 2F          	mov bl, al				; save al
0512+  0868 19 00       	mov al, 0
0513+  086A 05 03       	syscall sys_io				; display AH
0514+  086C 24          	mov ah, bl				; retrieve al
0515+  086D 19 00       	mov al, 0
0516+  086F 05 03       	syscall sys_io				; display AL
0517+  0871             
0518+  0871 EA          	pop bl
0519+  0872 E4          	pop a
0520+  0873 09          	ret
0521+  0874             
0522+  0874             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0523+  0874             ; print 8bit decimal unsigned number
0524+  0874             ; input number in AL
0525+  0874             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0526+  0874             print_u8d:
0527+  0874 D7          	push a
0528+  0875 D8          	push b
0529+  0876             
0530+  0876 22 00       	mov ah, 0
0531+  0878 26 64 00    	mov b, 100
0532+  087B AE          	div a, b
0533+  087C D8          	push b			; save remainder
0534+  087D B9 00       	cmp al, 0
0535+  087F C6 89 08    	je skip100
0536+  0882 6A 30       	add al, $30
0537+  0884 23          	mov ah, al
0538+  0885 19 00       	mov al, 0
0539+  0887 05 03       	syscall sys_io	; print coeff
0540+  0889             skip100:
0541+  0889 E4          	pop a
0542+  088A 22 00       	mov ah, 0
0543+  088C 26 0A 00    	mov b, 10
0544+  088F AE          	div a, b
0545+  0890 D8          	push b			; save remainder
0546+  0891 B9 00       	cmp al, 0
0547+  0893 C6 9D 08    	je skip10
0548+  0896 6A 30       	add al, $30
0549+  0898 23          	mov ah, al
0550+  0899 19 00       	mov al, 0
0551+  089B 05 03       	syscall sys_io	; print coeff
0552+  089D             skip10:
0553+  089D E4          	pop a
0554+  089E 1B          	mov al, bl
0555+  089F 6A 30       	add al, $30
0556+  08A1 23          	mov ah, al
0557+  08A2 19 00       	mov al, 0
0558+  08A4 05 03       	syscall sys_io	; print coeff
0559+  08A6 E5          	pop b
0560+  08A7 E4          	pop a
0561+  08A8 09          	ret
0562+  08A9             
0563+  08A9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0564+  08A9             ; INPUT 8BIT HEX INTEGER
0565+  08A9             ; read 8bit integer into AL
0566+  08A9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0567+  08A9             scan_u8x:
0568+  08A9 F8 04 00    	enter 4
0569+  08AC D8          	push b
0570+  08AD DA          	push d
0571+  08AE             
0572+  08AE FA FD FF    	lea d, [bp + -3]
0573+  08B1 07 8F 06    	call gets				; get number
0574+  08B4             
0575+  08B4 32          	mov bl, [d]
0576+  08B5 37          	mov bh, bl
0577+  08B6 33 01 00    	mov bl, [d + 1]
0578+  08B9 07 3D 06    	call atoi				; convert to int in AL
0579+  08BC             
0580+  08BC E7          	pop d
0581+  08BD E5          	pop b
0582+  08BE F9          	leave
0583+  08BF 09          	ret
0584+  08C0             
0585+  08C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0586+  08C0             ; input decimal number
0587+  08C0             ; result in A
0588+  08C0             ; 655'\0'
0589+  08C0             ; low--------high
0590+  08C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0591+  08C0             scan_u16d:
0592+  08C0 F8 08 00    	enter 8
0593+  08C3 E2          	push si
0594+  08C4 D8          	push b
0595+  08C5 D9          	push c
0596+  08C6 DA          	push d
0597+  08C7 FA F9 FF    	lea d, [bp +- 7]
0598+  08CA 07 8F 06    	call gets
0599+  08CD 07 C5 05    	call strlen			; get string length in C
0600+  08D0 7E          	dec c
0601+  08D1 FD 4E       	mov si, d
0602+  08D3 12          	mov a, c
0603+  08D4 FD 99       	shl a
0604+  08D6 3B 25 06    	mov d, table_power
0605+  08D9 59          	add d, a
0606+  08DA 38 00 00    	mov c, 0
0607+  08DD             mul_loop:
0608+  08DD F6          	lodsb			; load ASCII to al
0609+  08DE B9 00       	cmp al, 0
0610+  08E0 C6 F3 08    	je mul_exit
0611+  08E3 6F 30       	sub al, $30		; make into integer
0612+  08E5 22 00       	mov ah, 0
0613+  08E7 2A          	mov b, [d]
0614+  08E8 AC          	mul a, b			; result in B since it fits in 16bits
0615+  08E9 11          	mov a, b
0616+  08EA 28          	mov b, c
0617+  08EB 54          	add a, b
0618+  08EC 39          	mov c, a
0619+  08ED 63 02 00    	sub d, 2
0620+  08F0 0A DD 08    	jmp mul_loop
0621+  08F3             mul_exit:
0622+  08F3 12          	mov a, c
0623+  08F4 E7          	pop d
0624+  08F5 E6          	pop c
0625+  08F6 E5          	pop b
0626+  08F7 EF          	pop si
0627+  08F8 F9          	leave
0628+  08F9 09          	ret
0234   08FA             ; --- end include block
0235   08FA             
0236   08FA             .end
tasm: Number of errors = 0
