0001   0000             ; --- Filename: pascal.c
0002   0000             
0003   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0004   0000             
0005   0400             .org PROC_TEXT_ORG
0006   0400             
0007   0400             ; --- begin text block
0008   0400             main:
0009   0400 D2            push bp
0010   0401 9B            mov bp, sp
0011   0402             ; --- begin asm block
0012   0402 14 65 05        mov a, [s]
0013   0405 3C              mov d, a
0014   0406 07 C4 07        call puts
0015   0409 07 C2 08        call scan_u16d
0016   040C 42 71 05        mov [rows], a
0017   040F               ; --- end asm block
0018   040F             _for1_init:
0019   040F 26 00 00      mov b, 0
0020   0412 FD 42 75 05   mov [i], b
0021   0416             _for1_cond:
0022   0416 29 75 05      mov b, [i]
0023   0419 D7            push a
0024   041A 11            mov a, b
0025   041B 29 71 05      mov b, [rows]
0026   041E B0            cmp a, b
0027   041F 0E            lodflgs
0028   0420 87 02         and al, %00000010
0029   0422 22 00         mov ah, 0
0030   0424 27            mov b, a
0031   0425 E4            pop a
0032   0426 C0 00 00      cmp b, 0
0033   0429 C6 30 05      je _for1_exit
0034   042C             _for1_block:
0035   042C             _for2_init:
0036   042C 26 01 00      mov b, 1
0037   042F FD 42 73 05   mov [space], b
0038   0433             _for2_cond:
0039   0433 29 73 05      mov b, [space]
0040   0436 D7            push a
0041   0437 11            mov a, b
0042   0438 29 71 05      mov b, [rows]
0043   043B D7            push a
0044   043C 11            mov a, b
0045   043D 29 75 05      mov b, [i]
0046   0440 60            sub a, b
0047   0441 27            mov b, a
0048   0442 E4            pop a
0049   0443 B0            cmp a, b
0050   0444 0E            lodflgs
0051   0445 87 03         and al, %00000011
0052   0447 22 00         mov ah, 0
0053   0449 27            mov b, a
0054   044A E4            pop a
0055   044B C0 00 00      cmp b, 0
0056   044E C6 66 04      je _for2_exit
0057   0451             _for2_block:
0058   0451 07 3F 05      call print
0059   0454             _for2_update:
0060   0454 29 73 05      mov b, [space]
0061   0457 D7            push a
0062   0458 11            mov a, b
0063   0459 26 01 00      mov b, 1
0064   045C 54            add a, b
0065   045D 27            mov b, a
0066   045E E4            pop a
0067   045F FD 42 73 05   mov [space], b
0068   0463 0A 33 04      jmp _for2_cond
0069   0466             _for2_exit:
0070   0466             _for3_init:
0071   0466 26 00 00      mov b, 0
0072   0469 FD 42 77 05   mov [j], b
0073   046D             _for3_cond:
0074   046D 29 77 05      mov b, [j]
0075   0470 D7            push a
0076   0471 11            mov a, b
0077   0472 29 75 05      mov b, [i]
0078   0475 B0            cmp a, b
0079   0476 0E            lodflgs
0080   0477 87 03         and al, %00000011
0081   0479 22 00         mov ah, 0
0082   047B 27            mov b, a
0083   047C E4            pop a
0084   047D C0 00 00      cmp b, 0
0085   0480 C6 17 05      je _for3_exit
0086   0483             _for3_block:
0087   0483             _if4_cond:
0088   0483 29 77 05      mov b, [j]
0089   0486 D7            push a
0090   0487 11            mov a, b
0091   0488 26 00 00      mov b, 0
0092   048B B0            cmp a, b
0093   048C 0E            lodflgs
0094   048D 87 01         and al, %00000001
0095   048F 22 00         mov ah, 0
0096   0491 27            mov b, a
0097   0492 E4            pop a
0098   0493 D7            push a
0099   0494 11            mov a, b
0100   0495 29 75 05      mov b, [i]
0101   0498 D7            push a
0102   0499 11            mov a, b
0103   049A 26 00 00      mov b, 0
0104   049D B0            cmp a, b
0105   049E 0E            lodflgs
0106   049F 87 01         and al, %00000001
0107   04A1 22 00         mov ah, 0
0108   04A3 27            mov b, a
0109   04A4 E4            pop a
0110   04A5 C0 00 00      cmp b, 0
0111   04A8 D7            push a
0112   04A9 0E            lodflgs
0113   04AA 27            mov b, a
0114   04AB E4            pop a
0115   04AC 98            not bl
0116   04AD FD 87 01      and bl, %00000001
0117   04B0 A7 00         mov bh, 0
0118   04B2 AF 00 00      cmp a, 0
0119   04B5 0E            lodflgs
0120   04B6 96            not al
0121   04B7 87 01         and al, %00000001
0122   04B9 22 00         mov ah, 0
0123   04BB 8A            or a, b
0124   04BC 27            mov b, a
0125   04BD E4            pop a
0126   04BE C0 00 00      cmp b, 0
0127   04C1 C6 CE 04      je _if4_else_block
0128   04C4             _if4_block:
0129   04C4 26 01 00      mov b, 1
0130   04C7 FD 42 6F 05   mov [coef], b
0131   04CB 0A F8 04      jmp _if4_exit
0132   04CE             _if4_else_block:
0133   04CE 29 6F 05      mov b, [coef]
0134   04D1 D7            push a
0135   04D2 11            mov a, b
0136   04D3 29 75 05      mov b, [i]
0137   04D6 D7            push a
0138   04D7 11            mov a, b
0139   04D8 29 77 05      mov b, [j]
0140   04DB 60            sub a, b
0141   04DC 27            mov b, a
0142   04DD E4            pop a
0143   04DE D7            push a
0144   04DF 11            mov a, b
0145   04E0 26 01 00      mov b, 1
0146   04E3 54            add a, b
0147   04E4 27            mov b, a
0148   04E5 E4            pop a
0149   04E6 AC            mul a, b
0150   04E7 E4            pop a
0151   04E8 D7            push a
0152   04E9 11            mov a, b
0153   04EA 29 77 05      mov b, [j]
0154   04ED AE            div a, b
0155   04EE FD 78         mov g, a
0156   04F0 11            mov a, b
0157   04F1 FD 27         mov b, g
0158   04F3 E4            pop a
0159   04F4 FD 42 6F 05   mov [coef], b
0160   04F8             _if4_exit:
0161   04F8 07 3F 05      call print
0162   04FB 29 6F 05      mov b, [coef]
0163   04FE D8            push b
0164   04FF 07 33 05      call print_nbr
0165   0502 51 02 00      add sp, 2
0166   0505             _for3_update:
0167   0505 29 77 05      mov b, [j]
0168   0508 D7            push a
0169   0509 11            mov a, b
0170   050A 26 01 00      mov b, 1
0171   050D 54            add a, b
0172   050E 27            mov b, a
0173   050F E4            pop a
0174   0510 FD 42 77 05   mov [j], b
0175   0514 0A 6D 04      jmp _for3_cond
0176   0517             _for3_exit:
0177   0517             ; --- begin asm block
0178   0517 14 7C 05          mov a, [nl]
0179   051A 3C                mov d, a
0180   051B 07 C4 07          call puts
0181   051E                 ; --- end asm block
0182   051E             _for1_update:
0183   051E 29 75 05      mov b, [i]
0184   0521 D7            push a
0185   0522 11            mov a, b
0186   0523 26 01 00      mov b, 1
0187   0526 54            add a, b
0188   0527 27            mov b, a
0189   0528 E4            pop a
0190   0529 FD 42 75 05   mov [i], b
0191   052D 0A 16 04      jmp _for1_cond
0192   0530             _for1_exit:
0193   0530 F9            leave
0194   0531 05 0B         syscall sys_terminate_proc
0195   0533             print_nbr:
0196   0533 D2            push bp
0197   0534 9B            mov bp, sp
0198   0535             ; --- begin asm block
0199   0535 17 05 00        mov a, [bp + 5]
0200   0538 FD AA           swp a ; swap to make up for stack weirdness
0201   053A 07 ED 07        call print_u16d
0202   053D               ; --- end asm block
0203   053D F9            leave
0204   053E 09            ret
0205   053F             print:
0206   053F D2            push bp
0207   0540 9B            mov bp, sp
0208   0541             ; --- begin asm block
0209   0541 14 6D 05        mov a, [ss]
0210   0544 3C              mov d, a
0211   0545 07 C4 07        call puts
0212   0548               ; --- end asm block
0213   0548 F9            leave
0214   0549 09            ret
0215   054A             ; --- end text block
0216   054A             
0217   054A             ; --- begin data block
0218   054A 45 6E 74 65 s_data: .db "Enter the number of rows: ", 0
0218   054E 72 20 74 68 
0218   0552 65 20 6E 75 
0218   0556 6D 62 65 72 
0218   055A 20 6F 66 20 
0218   055E 72 6F 77 73 
0218   0562 3A 20 00 
0219   0565 4A 05       s: .dw s_data
0220   0567 20 20 20 20 ss_data: .db "     ", 0
0220   056B 20 00 
0221   056D 67 05       ss: .dw ss_data
0222   056F 01 00       coef: .dw 1
0223   0571 00 00       rows: .dw 0
0224   0573 00 00       space: .dw 0
0225   0575 00 00       i: .dw 0
0226   0577 00 00       j: .dw 0
0227   0579 0A 0D 00    nl_data: .db "\n\r", 0
0228   057C 79 05       nl: .dw nl_data
0229   057E 00 00       pp: .dw 0
0230   0580             ; --- end data block
0231   0580             ; --- begin include block
0232   0580             .include "lib/stdio.asm"
0001+  0580             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0580             ; stdio.s
0003+  0580             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0580             .include "lib/string.asm"
0001++ 0580             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0580             ; string.s
0003++ 0580             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0580             
0005++ 0580             
0006++ 0580             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0580             ; strrev
0008++ 0580             ; reverse a string
0009++ 0580             ; D = string address
0010++ 0580             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0580             ; 01234
0012++ 0580             strrev:
0013++ 0580 4B          	pusha
0014++ 0581 07 C7 05    	call strlen	; length in C
0015++ 0584 12          	mov a, c
0016++ 0585 AF 01 00    	cmp a, 1
0017++ 0588 D0 A2 05    	jleu strrev_end	; check string length. string len must be > 1
0018++ 058B 7D          	dec a
0019++ 058C FD 4E       	mov si, d	; beginning of string
0020++ 058E FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0590 59          	add d, a	; end of string
0022++ 0591 12          	mov a, c
0023++ 0592 FD 9B       	shr a		; divide by 2
0024++ 0594 39          	mov c, a	; C now counts the steps
0025++ 0595             strrev_L0:
0026++ 0595 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0596 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0597 3E          	mov [d], al	; store left char into right side
0029++ 0598 1B          	mov al, bl
0030++ 0599 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 059A 7E          	dec c
0032++ 059B 7F          	dec d
0033++ 059C C2 00 00    	cmp c, 0
0034++ 059F C7 95 05    	jne strrev_L0
0035++ 05A2             strrev_end:
0036++ 05A2 4C          	popa
0037++ 05A3 09          	ret
0038++ 05A4             	
0039++ 05A4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 05A4             ; strchr
0041++ 05A4             ; search string in D for char in AL
0042++ 05A4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 05A4             strchr:
0044++ 05A4             strchr_L0:
0045++ 05A4 32          	mov bl, [d]
0046++ 05A5 C1 00       	cmp bl, 0
0047++ 05A7 C6 B2 05    	je strchr_end
0048++ 05AA BA          	cmp al, bl
0049++ 05AB C6 B2 05    	je strchr_end
0050++ 05AE 79          	inc d
0051++ 05AF 0A A4 05    	jmp strchr_L0
0052++ 05B2             strchr_end:
0053++ 05B2 1B          	mov al, bl
0054++ 05B3 09          	ret
0055++ 05B4             
0056++ 05B4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 05B4             ; strstr
0058++ 05B4             ; find sub-string
0059++ 05B4             ; str1 in SI
0060++ 05B4             ; str2 in DI
0061++ 05B4             ; SI points to end of source string
0062++ 05B4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 05B4             strstr:
0064++ 05B4 DB          	push al
0065++ 05B5 DA          	push d
0066++ 05B6 E3          	push di
0067++ 05B7             strstr_loop:
0068++ 05B7 F3          	cmpsb					; compare a byte of the strings
0069++ 05B8 C7 C3 05    	jne strstr_ret
0070++ 05BB FC 00 00    	lea d, [di + 0]
0071++ 05BE BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 05C0 C7 B7 05    	jne strstr_loop				; equal chars but not at end
0073++ 05C3             strstr_ret:
0074++ 05C3 F0          	pop di
0075++ 05C4 E7          	pop d
0076++ 05C5 E8          	pop al
0077++ 05C6 09          	ret
0078++ 05C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 05C7             ; length of null terminated string
0080++ 05C7             ; result in C
0081++ 05C7             ; pointer in D
0082++ 05C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 05C7             strlen:
0084++ 05C7 DA          	push d
0085++ 05C8 38 00 00    	mov c, 0
0086++ 05CB             strlen_L1:
0087++ 05CB BD 00       	cmp byte [d], 0
0088++ 05CD C6 D5 05    	je strlen_ret
0089++ 05D0 79          	inc d
0090++ 05D1 78          	inc c
0091++ 05D2 0A CB 05    	jmp strlen_L1
0092++ 05D5             strlen_ret:
0093++ 05D5 E7          	pop d
0094++ 05D6 09          	ret
0095++ 05D7             
0096++ 05D7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 05D7             ; STRCMP
0098++ 05D7             ; compare two strings
0099++ 05D7             ; str1 in SI
0100++ 05D7             ; str2 in DI
0101++ 05D7             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 05D7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 05D7             strcmp:
0104++ 05D7 DB          	push al
0105++ 05D8 DA          	push d
0106++ 05D9 E3          	push di
0107++ 05DA E2          	push si
0108++ 05DB             strcmp_loop:
0109++ 05DB F3          	cmpsb					; compare a byte of the strings
0110++ 05DC C7 E7 05    	jne strcmp_ret
0111++ 05DF FB FF FF    	lea d, [si +- 1]
0112++ 05E2 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 05E4 C7 DB 05    	jne strcmp_loop				; equal chars but not at end
0114++ 05E7             strcmp_ret:
0115++ 05E7 EF          	pop si
0116++ 05E8 F0          	pop di
0117++ 05E9 E7          	pop d
0118++ 05EA E8          	pop al
0119++ 05EB 09          	ret
0120++ 05EC             
0121++ 05EC             
0122++ 05EC             ; STRCPY
0123++ 05EC             ; copy null terminated string from SI to DI
0124++ 05EC             ; source in SI
0125++ 05EC             ; destination in DI
0126++ 05EC             strcpy:
0127++ 05EC E2          	push si
0128++ 05ED E3          	push di
0129++ 05EE DB          	push al
0130++ 05EF             strcpy_L1:
0131++ 05EF F6          	lodsb
0132++ 05F0 F7          	stosb
0133++ 05F1 B9 00       	cmp al, 0
0134++ 05F3 C7 EF 05    	jne strcpy_L1
0135++ 05F6             strcpy_end:
0136++ 05F6 E8          	pop al
0137++ 05F7 F0          	pop di
0138++ 05F8 EF          	pop si
0139++ 05F9 09          	ret
0140++ 05FA             
0141++ 05FA             ; STRCAT
0142++ 05FA             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 05FA             ; source in SI
0144++ 05FA             ; destination in DI
0145++ 05FA             strcat:
0146++ 05FA E2          	push si
0147++ 05FB E3          	push di
0148++ 05FC D7          	push a
0149++ 05FD DA          	push d
0150++ 05FE 50          	mov a, di
0151++ 05FF 3C          	mov d, a
0152++ 0600             strcat_goto_end_L1:
0153++ 0600 BD 00       	cmp byte[d], 0
0154++ 0602 C6 09 06    	je strcat_start
0155++ 0605 79          	inc d
0156++ 0606 0A 00 06    	jmp strcat_goto_end_L1
0157++ 0609             strcat_start:
0158++ 0609 FD 50       	mov di, d
0159++ 060B             strcat_L1:
0160++ 060B F6          	lodsb
0161++ 060C F7          	stosb
0162++ 060D B9 00       	cmp al, 0
0163++ 060F C7 0B 06    	jne strcat_L1
0164++ 0612             strcat_end:
0165++ 0612 E7          	pop d
0166++ 0613 E4          	pop a
0167++ 0614 F0          	pop di
0168++ 0615 EF          	pop si
0169++ 0616 09          	ret
0005+  0617             
0006+  0617 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  061B 34 35 36 37 
0006+  061F 38 39 41 42 
0006+  0623 43 44 45 46 
0007+  0627             
0008+  0627 01 00       table_power:.dw 1
0009+  0629 0A 00       			.dw 10
0010+  062B 64 00       			.dw 100
0011+  062D E8 03       			.dw 1000
0012+  062F 10 27       			.dw 10000
0013+  0631             
0014+  0631             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0015+  0631             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0016+  0631             ; ASCII in BL
0017+  0631             ; result in AL
0018+  0631             ; ascii for F = 0100 0110
0019+  0631             ; ascii for 9 = 0011 1001
0020+  0631             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0021+  0631             hex_ascii_encode:
0022+  0631 1B          	mov al, bl
0023+  0632 93 40       	test al, $40				; test if letter or number
0024+  0634 C7 3A 06    	jnz hex_letter
0025+  0637 87 0F       	and al, $0F				; get number
0026+  0639 09          	ret
0027+  063A             hex_letter:
0028+  063A 87 0F       	and al, $0F				; get letter
0029+  063C 6A 09       	add al, 9
0030+  063E 09          	ret
0031+  063F             
0032+  063F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0033+  063F             ; ATOI
0034+  063F             ; 2 letter hex string in B
0035+  063F             ; 8bit integer returned in AL
0036+  063F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0037+  063F             atoi:
0038+  063F D8          	push b
0039+  0640 07 31 06    	call hex_ascii_encode			; convert BL to 4bit code in AL
0040+  0643 30          	mov bl, bh
0041+  0644 DB          	push al					; save a
0042+  0645 07 31 06    	call hex_ascii_encode
0043+  0648 EA          	pop bl	
0044+  0649 FD 9E 04    	shl al, 4
0045+  064C 8C          	or al, bl
0046+  064D E5          	pop b
0047+  064E 09          	ret	
0048+  064F             
0049+  064F             
0050+  064F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  064F             ; printf
0052+  064F             ; no need for explanations!
0053+  064F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0054+  064F             printf:
0055+  064F 09          	ret
0056+  0650             
0057+  0650             
0058+  0650             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  0650             ; scanf
0060+  0650             ; no need for explanations!
0061+  0650             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  0650             scanf:
0063+  0650 09          	ret
0064+  0651             
0065+  0651             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  0651             ; ITOA
0067+  0651             ; 8bit value in BL
0068+  0651             ; 2 byte ASCII result in A
0069+  0651             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0070+  0651             itoa:
0071+  0651 DA          	push d
0072+  0652 D8          	push b
0073+  0653 A7 00       	mov bh, 0
0074+  0655 FD A4 04    	shr bl, 4	
0075+  0658 74          	mov d, b
0076+  0659 1F 17 06    	mov al, [d + s_hex_digits]
0077+  065C 23          	mov ah, al
0078+  065D             	
0079+  065D E5          	pop b
0080+  065E D8          	push b
0081+  065F A7 00       	mov bh, 0
0082+  0661 FD 87 0F    	and bl, $0F
0083+  0664 74          	mov d, b
0084+  0665 1F 17 06    	mov al, [d + s_hex_digits]
0085+  0668 E5          	pop b
0086+  0669 E7          	pop d
0087+  066A 09          	ret
0088+  066B             
0089+  066B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0090+  066B             ; HEX STRING TO BINARY
0091+  066B             ; di = destination address
0092+  066B             ; si = source
0093+  066B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0094+  066B             hex_to_int:
0095+  066B             hex_to_int_L1:
0096+  066B F6          	lodsb					; load from [SI] to AL
0097+  066C B9 00       	cmp al, 0				; check if ASCII 0
0098+  066E C6 7B 06    	jz hex_to_int_ret
0099+  0671 36          	mov bh, al
0100+  0672 F6          	lodsb
0101+  0673 2F          	mov bl, al
0102+  0674 07 3F 06    	call atoi				; convert ASCII byte in B to int (to AL)
0103+  0677 F7          	stosb					; store AL to [DI]
0104+  0678 0A 6B 06    	jmp hex_to_int_L1
0105+  067B             hex_to_int_ret:
0106+  067B 09          	ret		
0107+  067C             
0108+  067C             
0109+  067C             
0110+  067C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  067C             ; GETCHAR
0112+  067C             ; char in ah
0113+  067C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0114+  067C             getchar:
0115+  067C DB          	push al
0116+  067D             getchar_retry:
0117+  067D FD 0C       	sti
0118+  067F 19 01       	mov al, 1
0119+  0681 05 03       	syscall sys_io			; receive in AH
0120+  0683 B9 00       	cmp al, 0			; check if any char was receive
0121+  0685 C6 7D 06    	je getchar_retry
0122+  0688 E8          	pop al
0123+  0689 09          	ret
0124+  068A             
0125+  068A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0126+  068A             ; PUTCHAR
0127+  068A             ; char in ah
0128+  068A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  068A             putchar:
0130+  068A D7          	push a
0131+  068B 19 00       	mov al, 0
0132+  068D 05 03       	syscall sys_io			; char in AH
0133+  068F E4          	pop a
0134+  0690 09          	ret
0135+  0691             
0136+  0691             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0137+  0691             ;; INPUT A STRING
0138+  0691             ;; terminates with null
0139+  0691             ;; pointer in D
0140+  0691             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  0691             gets:
0142+  0691 D7          	push a
0143+  0692 DA          	push d
0144+  0693             gets_loop:
0145+  0693 FD 0C       	sti
0146+  0695 19 01       	mov al, 1
0147+  0697 05 03       	syscall sys_io			; receive in AH
0148+  0699 B9 00       	cmp al, 0				; check error code (AL)
0149+  069B C6 93 06    	je gets_loop			; if no char received, retry
0150+  069E             
0151+  069E 76 1B       	cmp ah, 27
0152+  06A0 C6 C1 06    	je gets_telnet_escape
0153+  06A3 76 0A       	cmp ah, $0A				; LF
0154+  06A5 C6 1A 07    	je gets_end
0155+  06A8 76 0D       	cmp ah, $0D				; CR
0156+  06AA C6 1A 07    	je gets_end
0157+  06AD 76 5C       	cmp ah, $5C				; '\\'
0158+  06AF C6 F1 06    	je gets_escape
0159+  06B2             	
0160+  06B2 76 08       	cmp ah, $08			; check for backspace
0161+  06B4 C6 BD 06    	je gets_backspace
0162+  06B7             
0163+  06B7 1A          	mov al, ah
0164+  06B8 3E          	mov [d], al
0165+  06B9 79          	inc d
0166+  06BA 0A 93 06    	jmp gets_loop
0167+  06BD             gets_backspace:
0168+  06BD 7F          	dec d
0169+  06BE 0A 93 06    	jmp gets_loop
0170+  06C1             gets_telnet_escape:
0171+  06C1 FD 0C       	sti
0172+  06C3 19 01       	mov al, 1
0173+  06C5 05 03       	syscall sys_io				; receive in AH without echo
0174+  06C7 B9 00       	cmp al, 0					; check error code (AL)
0175+  06C9 C6 C1 06    	je gets_telnet_escape		; if no char received, retry
0176+  06CC 76 5B       	cmp ah, '['
0177+  06CE C7 93 06    	jne gets_loop
0178+  06D1             gets_telnet_escape_phase2:
0179+  06D1 FD 0C       	sti
0180+  06D3 19 01       	mov al, 1
0181+  06D5 05 03       	syscall sys_io					; receive in AH without echo
0182+  06D7 B9 00       	cmp al, 0						; check error code (AL)
0183+  06D9 C6 D1 06    	je gets_telnet_escape_phase2	; if no char received, retry
0184+  06DC 76 44       	cmp ah, 'D'
0185+  06DE C6 E9 06    	je gets_left_arrow
0186+  06E1 76 43       	cmp ah, 'C'
0187+  06E3 C6 ED 06    	je gets_right_arrow
0188+  06E6 0A 93 06    	jmp gets_loop
0189+  06E9             gets_left_arrow:
0190+  06E9 7F          	dec d
0191+  06EA 0A 93 06    	jmp gets_loop
0192+  06ED             gets_right_arrow:
0193+  06ED 79          	inc d
0194+  06EE 0A 93 06    	jmp gets_loop
0195+  06F1             gets_escape:
0196+  06F1 FD 0C       	sti
0197+  06F3 19 01       	mov al, 1
0198+  06F5 05 03       	syscall sys_io			; receive in AH
0199+  06F7 B9 00       	cmp al, 0				; check error code (AL)
0200+  06F9 C6 F1 06    	je gets_escape			; if no char received, retry
0201+  06FC 76 6E       	cmp ah, 'n'
0202+  06FE C6 0C 07    	je gets_LF
0203+  0701 76 72       	cmp ah, 'r'
0204+  0703 C6 13 07    	je gets_CR
0205+  0706 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0206+  0707 3E          	mov [d], al
0207+  0708 79          	inc d
0208+  0709 0A 93 06    	jmp gets_loop
0209+  070C             gets_LF:
0210+  070C 19 0A       	mov al, $0A
0211+  070E 3E          	mov [d], al
0212+  070F 79          	inc d
0213+  0710 0A 93 06    	jmp gets_loop
0214+  0713             gets_CR:
0215+  0713 19 0D       	mov al, $0D
0216+  0715 3E          	mov [d], al
0217+  0716 79          	inc d
0218+  0717 0A 93 06    	jmp gets_loop
0219+  071A             gets_end:
0220+  071A 19 00       	mov al, 0
0221+  071C 3E          	mov [d], al				; terminate string
0222+  071D E7          	pop d
0223+  071E E4          	pop a
0224+  071F 09          	ret
0225+  0720             
0226+  0720             
0227+  0720             
0228+  0720             
0229+  0720             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0230+  0720             ;; INPUT TEXT
0231+  0720             ;; terminated with CTRL+D
0232+  0720             ;; pointer in D
0233+  0720             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0234+  0720             gettxt:
0235+  0720 D7          	push a
0236+  0721 DA          	push d
0237+  0722             gettxt_loop:
0238+  0722 19 01       	mov al, 1
0239+  0724 05 03       	syscall sys_io			; receive in AH
0240+  0726 B9 00       	cmp al, 0				; check error code (AL)
0241+  0728 C6 22 07    	je gettxt_loop		; if no char received, retry
0242+  072B 76 04       	cmp ah, 4			; EOT
0243+  072D C6 6B 07    	je gettxt_end
0244+  0730 76 08       	cmp ah, $08			; check for backspace
0245+  0732 C6 67 07    	je gettxt_backspace
0246+  0735 76 5C       	cmp ah, $5C				; '\\'
0247+  0737 C6 40 07    	je gettxt_escape
0248+  073A 1A          	mov al, ah
0249+  073B 3E          	mov [d], al
0250+  073C 79          	inc d
0251+  073D 0A 22 07    	jmp gettxt_loop
0252+  0740             gettxt_escape:
0253+  0740 19 01       	mov al, 1
0254+  0742 05 03       	syscall sys_io			; receive in AH
0255+  0744 B9 00       	cmp al, 0				; check error code (AL)
0256+  0746 C6 40 07    	je gettxt_escape		; if no char received, retry
0257+  0749 76 6E       	cmp ah, 'n'
0258+  074B C6 59 07    	je gettxt_LF
0259+  074E 76 72       	cmp ah, 'r'
0260+  0750 C6 60 07    	je gettxt_CR
0261+  0753 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0262+  0754 3E          	mov [d], al
0263+  0755 79          	inc d
0264+  0756 0A 22 07    	jmp gettxt_loop
0265+  0759             gettxt_LF:
0266+  0759 19 0A       	mov al, $0A
0267+  075B 3E          	mov [d], al
0268+  075C 79          	inc d
0269+  075D 0A 22 07    	jmp gettxt_loop
0270+  0760             gettxt_CR:
0271+  0760 19 0D       	mov al, $0D
0272+  0762 3E          	mov [d], al
0273+  0763 79          	inc d
0274+  0764 0A 22 07    	jmp gettxt_loop
0275+  0767             gettxt_backspace:
0276+  0767 7F          	dec d
0277+  0768 0A 22 07    	jmp gettxt_loop
0278+  076B             gettxt_end:
0279+  076B 19 00       	mov al, 0
0280+  076D 3E          	mov [d], al				; terminate string
0281+  076E E7          	pop d
0282+  076F E4          	pop a
0283+  0770 09          	ret
0284+  0771             
0285+  0771             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0286+  0771             ; PRINT NEW LINE
0287+  0771             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  0771             printnl:
0289+  0771 D7          	push a
0290+  0772 10 00 0A    	mov a, $0A00
0291+  0775 05 03       	syscall sys_io
0292+  0777 10 00 0D    	mov a, $0D00
0293+  077A 05 03       	syscall sys_io
0294+  077C E4          	pop a
0295+  077D 09          	ret
0296+  077E             
0297+  077E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0298+  077E             ; strtoint
0299+  077E             ; 4 digit hex string number in d
0300+  077E             ; integer returned in A
0301+  077E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0302+  077E             strtointx:
0303+  077E D8          	push b
0304+  077F 32          	mov bl, [d]
0305+  0780 37          	mov bh, bl
0306+  0781 33 01 00    	mov bl, [d + 1]
0307+  0784 07 3F 06    	call atoi				; convert to int in AL
0308+  0787 23          	mov ah, al				; move to AH
0309+  0788 33 02 00    	mov bl, [d + 2]
0310+  078B 37          	mov bh, bl
0311+  078C 33 03 00    	mov bl, [d + 3]
0312+  078F 07 3F 06    	call atoi				; convert to int in AL
0313+  0792 E5          	pop b
0314+  0793 09          	ret
0315+  0794             
0316+  0794             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0317+  0794             ; strtoint
0318+  0794             ; 5 digit base10 string number in d
0319+  0794             ; integer returned in A
0320+  0794             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0321+  0794             strtoint:
0322+  0794 E2          	push si
0323+  0795 D8          	push b
0324+  0796 D9          	push c
0325+  0797 DA          	push d
0326+  0798 07 C7 05    	call strlen			; get string length in C
0327+  079B 7E          	dec c
0328+  079C FD 4E       	mov si, d
0329+  079E 12          	mov a, c
0330+  079F FD 99       	shl a
0331+  07A1 3B 27 06    	mov d, table_power
0332+  07A4 59          	add d, a
0333+  07A5 38 00 00    	mov c, 0
0334+  07A8             strtoint_L0:
0335+  07A8 F6          	lodsb			; load ASCII to al
0336+  07A9 B9 00       	cmp al, 0
0337+  07AB C6 BE 07    	je strtoint_end
0338+  07AE 6F 30       	sub al, $30		; make into integer
0339+  07B0 22 00       	mov ah, 0
0340+  07B2 2A          	mov b, [d]
0341+  07B3 AC          	mul a, b			; result in B since it fits in 16bits
0342+  07B4 11          	mov a, b
0343+  07B5 28          	mov b, c
0344+  07B6 54          	add a, b
0345+  07B7 39          	mov c, a
0346+  07B8 63 02 00    	sub d, 2
0347+  07BB 0A A8 07    	jmp strtoint_L0
0348+  07BE             strtoint_end:
0349+  07BE 12          	mov a, c
0350+  07BF E7          	pop d
0351+  07C0 E6          	pop c
0352+  07C1 E5          	pop b
0353+  07C2 EF          	pop si
0354+  07C3 09          	ret
0355+  07C4             
0356+  07C4             
0357+  07C4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0358+  07C4             ; PRINT NULL TERMINATED STRING
0359+  07C4             ; pointer in D
0360+  07C4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0361+  07C4             puts:
0362+  07C4 D7          	push a
0363+  07C5 DA          	push d
0364+  07C6             puts_L1:
0365+  07C6 1E          	mov al, [d]
0366+  07C7 B9 00       	cmp al, 0
0367+  07C9 C6 D5 07    	jz puts_END
0368+  07CC 23          	mov ah, al
0369+  07CD 19 00       	mov al, 0
0370+  07CF 05 03       	syscall sys_io
0371+  07D1 79          	inc d
0372+  07D2 0A C6 07    	jmp puts_L1
0373+  07D5             puts_END:
0374+  07D5 E7          	pop d
0375+  07D6 E4          	pop a
0376+  07D7 09          	ret
0377+  07D8             
0378+  07D8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  07D8             ; PRINT N SIZE STRING
0380+  07D8             ; pointer in D
0381+  07D8             ; size in C
0382+  07D8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0383+  07D8             putsn:
0384+  07D8 DB          	push al
0385+  07D9 DA          	push d
0386+  07DA D9          	push c
0387+  07DB             putsn_L0:
0388+  07DB 1E          	mov al, [d]
0389+  07DC 23          	mov ah, al
0390+  07DD 19 00       	mov al, 0
0391+  07DF 05 03       	syscall sys_io
0392+  07E1 79          	inc d
0393+  07E2 7E          	dec c	
0394+  07E3 C2 00 00    	cmp c, 0
0395+  07E6 C7 DB 07    	jne putsn_L0
0396+  07E9             putsn_end:
0397+  07E9 E6          	pop c
0398+  07EA E7          	pop d
0399+  07EB E8          	pop al
0400+  07EC 09          	ret
0401+  07ED             
0402+  07ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0403+  07ED             ; print 16bit decimal number
0404+  07ED             ; input number in A
0405+  07ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  07ED             print_u16d:
0407+  07ED D7          	push a
0408+  07EE D8          	push b
0409+  07EF 26 10 27    	mov b, 10000
0410+  07F2 AE          	div a, b			; get 10000 coeff.
0411+  07F3 07 19 08    	call print_number
0412+  07F6 11          	mov a, b
0413+  07F7 26 E8 03    	mov b, 1000
0414+  07FA AE          	div a, b			; get 10000 coeff.
0415+  07FB 07 19 08    	call print_number
0416+  07FE 11          	mov a, b
0417+  07FF 26 64 00    	mov b, 100
0418+  0802 AE          	div a, b
0419+  0803 07 19 08    	call print_number
0420+  0806 11          	mov a, b
0421+  0807 26 0A 00    	mov b, 10
0422+  080A AE          	div a, b
0423+  080B 07 19 08    	call print_number
0424+  080E 11          	mov a, b
0425+  080F 6A 30       	add al, $30
0426+  0811 23          	mov ah, al
0427+  0812 19 00       	mov al, 0
0428+  0814 05 03       	syscall sys_io	; print coeff
0429+  0816 E5          	pop b
0430+  0817 E4          	pop a
0431+  0818 09          	ret
0432+  0819             
0433+  0819             
0434+  0819             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0435+  0819             ; if A == 0, print space
0436+  0819             ; else print A
0437+  0819             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0438+  0819             print_number:
0439+  0819 6A 30       	add al, $30
0440+  081B 23          	mov ah, al
0441+  081C 07 8A 06    	call putchar
0442+  081F 09          	ret
0443+  0820             
0444+  0820             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  0820             ; PRINT 16BIT HEX INTEGER
0446+  0820             ; integer value in reg B
0447+  0820             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  0820             print_u16x:
0449+  0820 D7          	push a
0450+  0821 D8          	push b
0451+  0822 DD          	push bl
0452+  0823 30          	mov bl, bh
0453+  0824 07 51 06    	call itoa				; convert bh to char in A
0454+  0827 2F          	mov bl, al				; save al
0455+  0828 19 00       	mov al, 0
0456+  082A 05 03       	syscall sys_io				; display AH
0457+  082C 24          	mov ah, bl				; retrieve al
0458+  082D 19 00       	mov al, 0
0459+  082F 05 03       	syscall sys_io				; display AL
0460+  0831             
0461+  0831 EA          	pop bl
0462+  0832 07 51 06    	call itoa				; convert bh to char in A
0463+  0835 2F          	mov bl, al				; save al
0464+  0836 19 00       	mov al, 0
0465+  0838 05 03       	syscall sys_io				; display AH
0466+  083A 24          	mov ah, bl				; retrieve al
0467+  083B 19 00       	mov al, 0
0468+  083D 05 03       	syscall sys_io				; display AL
0469+  083F             
0470+  083F E5          	pop b
0471+  0840 E4          	pop a
0472+  0841 09          	ret
0473+  0842             
0474+  0842             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0475+  0842             ; INPUT 16BIT HEX INTEGER
0476+  0842             ; read 16bit integer into A
0477+  0842             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0478+  0842             scan_u16x:
0479+  0842 F8 10 00    	enter 16
0480+  0845 D8          	push b
0481+  0846 DA          	push d
0482+  0847             
0483+  0847 FA F1 FF    	lea d, [bp + -15]
0484+  084A 07 91 06    	call gets				; get number
0485+  084D             
0486+  084D 32          	mov bl, [d]
0487+  084E 37          	mov bh, bl
0488+  084F 33 01 00    	mov bl, [d + 1]
0489+  0852 07 3F 06    	call atoi				; convert to int in AL
0490+  0855 23          	mov ah, al				; move to AH
0491+  0856             
0492+  0856 33 02 00    	mov bl, [d + 2]
0493+  0859 37          	mov bh, bl
0494+  085A 33 03 00    	mov bl, [d + 3]
0495+  085D 07 3F 06    	call atoi				; convert to int in AL
0496+  0860             
0497+  0860 E7          	pop d
0498+  0861 E5          	pop b
0499+  0862 F9          	leave
0500+  0863 09          	ret
0501+  0864             
0502+  0864             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0503+  0864             ; PRINT 8bit HEX INTEGER
0504+  0864             ; integer value in reg bl
0505+  0864             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0506+  0864             print_u8x:
0507+  0864 D7          	push a
0508+  0865 DD          	push bl
0509+  0866             
0510+  0866 07 51 06    	call itoa				; convert bl to char in A
0511+  0869 2F          	mov bl, al				; save al
0512+  086A 19 00       	mov al, 0
0513+  086C 05 03       	syscall sys_io				; display AH
0514+  086E 24          	mov ah, bl				; retrieve al
0515+  086F 19 00       	mov al, 0
0516+  0871 05 03       	syscall sys_io				; display AL
0517+  0873             
0518+  0873 EA          	pop bl
0519+  0874 E4          	pop a
0520+  0875 09          	ret
0521+  0876             
0522+  0876             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0523+  0876             ; print 8bit decimal unsigned number
0524+  0876             ; input number in AL
0525+  0876             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0526+  0876             print_u8d:
0527+  0876 D7          	push a
0528+  0877 D8          	push b
0529+  0878             
0530+  0878 22 00       	mov ah, 0
0531+  087A 26 64 00    	mov b, 100
0532+  087D AE          	div a, b
0533+  087E D8          	push b			; save remainder
0534+  087F B9 00       	cmp al, 0
0535+  0881 C6 8B 08    	je skip100
0536+  0884 6A 30       	add al, $30
0537+  0886 23          	mov ah, al
0538+  0887 19 00       	mov al, 0
0539+  0889 05 03       	syscall sys_io	; print coeff
0540+  088B             skip100:
0541+  088B E4          	pop a
0542+  088C 22 00       	mov ah, 0
0543+  088E 26 0A 00    	mov b, 10
0544+  0891 AE          	div a, b
0545+  0892 D8          	push b			; save remainder
0546+  0893 B9 00       	cmp al, 0
0547+  0895 C6 9F 08    	je skip10
0548+  0898 6A 30       	add al, $30
0549+  089A 23          	mov ah, al
0550+  089B 19 00       	mov al, 0
0551+  089D 05 03       	syscall sys_io	; print coeff
0552+  089F             skip10:
0553+  089F E4          	pop a
0554+  08A0 1B          	mov al, bl
0555+  08A1 6A 30       	add al, $30
0556+  08A3 23          	mov ah, al
0557+  08A4 19 00       	mov al, 0
0558+  08A6 05 03       	syscall sys_io	; print coeff
0559+  08A8 E5          	pop b
0560+  08A9 E4          	pop a
0561+  08AA 09          	ret
0562+  08AB             
0563+  08AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0564+  08AB             ; INPUT 8BIT HEX INTEGER
0565+  08AB             ; read 8bit integer into AL
0566+  08AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0567+  08AB             scan_u8x:
0568+  08AB F8 04 00    	enter 4
0569+  08AE D8          	push b
0570+  08AF DA          	push d
0571+  08B0             
0572+  08B0 FA FD FF    	lea d, [bp + -3]
0573+  08B3 07 91 06    	call gets				; get number
0574+  08B6             
0575+  08B6 32          	mov bl, [d]
0576+  08B7 37          	mov bh, bl
0577+  08B8 33 01 00    	mov bl, [d + 1]
0578+  08BB 07 3F 06    	call atoi				; convert to int in AL
0579+  08BE             
0580+  08BE E7          	pop d
0581+  08BF E5          	pop b
0582+  08C0 F9          	leave
0583+  08C1 09          	ret
0584+  08C2             
0585+  08C2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0586+  08C2             ; input decimal number
0587+  08C2             ; result in A
0588+  08C2             ; 655'\0'
0589+  08C2             ; low--------high
0590+  08C2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0591+  08C2             scan_u16d:
0592+  08C2 F8 08 00    	enter 8
0593+  08C5 E2          	push si
0594+  08C6 D8          	push b
0595+  08C7 D9          	push c
0596+  08C8 DA          	push d
0597+  08C9 FA F9 FF    	lea d, [bp +- 7]
0598+  08CC 07 91 06    	call gets
0599+  08CF 07 C7 05    	call strlen			; get string length in C
0600+  08D2 7E          	dec c
0601+  08D3 FD 4E       	mov si, d
0602+  08D5 12          	mov a, c
0603+  08D6 FD 99       	shl a
0604+  08D8 3B 27 06    	mov d, table_power
0605+  08DB 59          	add d, a
0606+  08DC 38 00 00    	mov c, 0
0607+  08DF             mul_loop:
0608+  08DF F6          	lodsb			; load ASCII to al
0609+  08E0 B9 00       	cmp al, 0
0610+  08E2 C6 F5 08    	je mul_exit
0611+  08E5 6F 30       	sub al, $30		; make into integer
0612+  08E7 22 00       	mov ah, 0
0613+  08E9 2A          	mov b, [d]
0614+  08EA AC          	mul a, b			; result in B since it fits in 16bits
0615+  08EB 11          	mov a, b
0616+  08EC 28          	mov b, c
0617+  08ED 54          	add a, b
0618+  08EE 39          	mov c, a
0619+  08EF 63 02 00    	sub d, 2
0620+  08F2 0A DF 08    	jmp mul_loop
0621+  08F5             mul_exit:
0622+  08F5 12          	mov a, c
0623+  08F6 E7          	pop d
0624+  08F7 E6          	pop c
0625+  08F8 E5          	pop b
0626+  08F9 EF          	pop si
0627+  08FA F9          	leave
0628+  08FB 09          	ret
0233   08FC             ; --- end include block
0234   08FC             
0235   08FC             .end
tasm: Number of errors = 0
