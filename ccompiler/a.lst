0001   0000             ; --- FILENAME: ivosol1d.c
0002   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0400             .org PROC_TEXT_ORG
0004   0400             
0005   0400             ; --- BEGIN TEXT BLOCK
0006   0400             main:
0007   0400 D2            push bp
0008   0401 9B            mov bp, sp
0009   0402             _while1_cond:
0010   0402 29 09 12      mov b, [exitflag]
0011   0405 D7            push a
0012   0406 11            mov a, b
0013   0407 26 00 00      mov b, 0
0014   040A B0            cmp a, b
0015   040B 0E            lodflgs
0016   040C 87 01         and al, %00000001 ; ==
0017   040E B9 00         cmp al, 0
0018   0410 0E            lodflgs
0019   0411 96            not al
0020   0412 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0021   0414 22 00         mov ah, 0
0022   0416 27            mov b, a
0023   0417 E4            pop a
0024   0418 C0 00 00      cmp b, 0
0025   041B C6 E0 0F      je _while1_exit
0026   041E             _while1_block:
0027   041E 26 10 0E      mov b, 3600
0028   0421 FD 42 07 12   mov [runlimit], b
0029   0425             _while2_cond:
0030   0425 26 01 00      mov b, 1
0031   0428 C0 00 00      cmp b, 0
0032   042B C6 A8 07      je _while2_exit
0033   042E             _while2_block:
0034   042E 26 00 00      mov b, 0
0035   0431 FD 42 F9 11   mov [pc], b
0036   0435 26 18 30      mov b, 12312
0037   0438 FD AB         swp b
0038   043A D8            push b
0039   043B 07 F0 0F      call displaynumber
0040   043E 51 02 00      add sp, 2
0041   0441 07 E0 0F      call readint
0042   0444 FD 42 EF 11   mov [cmdadr], b
0043   0448             _if3_cond:
0044   0448 29 EF 11      mov b, [cmdadr]
0045   044B D7            push a
0046   044C 11            mov a, b
0047   044D 26 1E 00      mov b, 30
0048   0450 B0            cmp a, b
0049   0451 0E            lodflgs
0050   0452 87 03         and al, %00000011 ; <=
0051   0454 B9 00         cmp al, 0
0052   0456 0E            lodflgs
0053   0457 96            not al
0054   0458 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0055   045A 22 00         mov ah, 0
0056   045C 27            mov b, a
0057   045D E4            pop a
0058   045E C0 00 00      cmp b, 0
0059   0461 C6 63 05      je _if3_else
0060   0464             _if3_true:
0061   0464 07 E0 0F      call readint
0062   0467 FD 42 F1 11   mov [opr], b
0063   046B 07 E0 0F      call readint
0064   046E FD 42 F3 11   mov [datadr1], b
0065   0472 07 E0 0F      call readint
0066   0475 FD 42 F5 11   mov [datadr2], b
0067   0479 07 E0 0F      call readint
0068   047C FD 42 F7 11   mov [datadr3], b
0069   0480 29 ED 11      mov b, [instruction]
0070   0483 74            mov d, b
0071   0484 DA            push d
0072   0485 29 EF 11      mov b, [cmdadr]
0073   0488 D7            push a
0074   0489 11            mov a, b
0075   048A 26 04 00      mov b, 4
0076   048D AC            mul a, b
0077   048E E4            pop a
0078   048F E7            pop d
0079   0490 10 02 00      mov a, 2
0080   0493 AC            mul a, b
0081   0494 5A            add d, b
0082   0495 DA            push d
0083   0496 29 F1 11      mov b, [opr]
0084   0499 E7            pop d
0085   049A 11            mov a, b
0086   049B 43            mov [d], a
0087   049C 29 ED 11      mov b, [instruction]
0088   049F 74            mov d, b
0089   04A0 DA            push d
0090   04A1 29 EF 11      mov b, [cmdadr]
0091   04A4 D7            push a
0092   04A5 11            mov a, b
0093   04A6 26 04 00      mov b, 4
0094   04A9 AC            mul a, b
0095   04AA 11            mov a, b
0096   04AB 26 01 00      mov b, 1
0097   04AE 54            add a, b
0098   04AF 27            mov b, a
0099   04B0 E4            pop a
0100   04B1 E7            pop d
0101   04B2 10 02 00      mov a, 2
0102   04B5 AC            mul a, b
0103   04B6 5A            add d, b
0104   04B7 DA            push d
0105   04B8 29 F3 11      mov b, [datadr1]
0106   04BB E7            pop d
0107   04BC 11            mov a, b
0108   04BD 43            mov [d], a
0109   04BE 29 ED 11      mov b, [instruction]
0110   04C1 74            mov d, b
0111   04C2 DA            push d
0112   04C3 29 EF 11      mov b, [cmdadr]
0113   04C6 D7            push a
0114   04C7 11            mov a, b
0115   04C8 26 04 00      mov b, 4
0116   04CB AC            mul a, b
0117   04CC 11            mov a, b
0118   04CD 26 02 00      mov b, 2
0119   04D0 54            add a, b
0120   04D1 27            mov b, a
0121   04D2 E4            pop a
0122   04D3 E7            pop d
0123   04D4 10 02 00      mov a, 2
0124   04D7 AC            mul a, b
0125   04D8 5A            add d, b
0126   04D9 DA            push d
0127   04DA 29 F5 11      mov b, [datadr2]
0128   04DD E7            pop d
0129   04DE 11            mov a, b
0130   04DF 43            mov [d], a
0131   04E0 29 ED 11      mov b, [instruction]
0132   04E3 74            mov d, b
0133   04E4 DA            push d
0134   04E5 29 EF 11      mov b, [cmdadr]
0135   04E8 D7            push a
0136   04E9 11            mov a, b
0137   04EA 26 04 00      mov b, 4
0138   04ED AC            mul a, b
0139   04EE 11            mov a, b
0140   04EF 26 03 00      mov b, 3
0141   04F2 54            add a, b
0142   04F3 27            mov b, a
0143   04F4 E4            pop a
0144   04F5 E7            pop d
0145   04F6 10 02 00      mov a, 2
0146   04F9 AC            mul a, b
0147   04FA 5A            add d, b
0148   04FB DA            push d
0149   04FC 29 F7 11      mov b, [datadr3]
0150   04FF E7            pop d
0151   0500 11            mov a, b
0152   0501 43            mov [d], a
0153   0502 29 EF 11      mov b, [cmdadr]
0154   0505 FD AB         swp b
0155   0507 D8            push b
0156   0508 07 F0 0F      call displaynumber
0157   050B 51 02 00      add sp, 2
0158   050E 29 F1 11      mov b, [opr]
0159   0511 FD AB         swp b
0160   0513 D8            push b
0161   0514 07 F0 0F      call displaynumber
0162   0517 51 02 00      add sp, 2
0163   051A 29 F3 11      mov b, [datadr1]
0164   051D FD AB         swp b
0165   051F D8            push b
0166   0520 07 F0 0F      call displaynumber
0167   0523 51 02 00      add sp, 2
0168   0526 29 F5 11      mov b, [datadr2]
0169   0529 FD AB         swp b
0170   052B D8            push b
0171   052C 07 F0 0F      call displaynumber
0172   052F 51 02 00      add sp, 2
0173   0532 29 F7 11      mov b, [datadr3]
0174   0535 FD AB         swp b
0175   0537 D8            push b
0176   0538 07 F0 0F      call displaynumber
0177   053B 51 02 00      add sp, 2
0178   053E             _if4_cond:
0179   053E 29 EF 11      mov b, [cmdadr]
0180   0541 D7            push a
0181   0542 11            mov a, b
0182   0543 26 00 00      mov b, 0
0183   0546 B0            cmp a, b
0184   0547 0E            lodflgs
0185   0548 87 01         and al, %00000001 ; ==
0186   054A B9 00         cmp al, 0
0187   054C 0E            lodflgs
0188   054D 96            not al
0189   054E 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0190   0550 22 00         mov ah, 0
0191   0552 27            mov b, a
0192   0553 E4            pop a
0193   0554 C0 00 00      cmp b, 0
0194   0557 C6 60 05      je _if4_exit
0195   055A             _if4_true:
0196   055A 0A A8 07      jmp _while2_exit ; while break
0197   055D 0A 60 05      jmp _if4_exit
0198   0560             _if4_exit:
0199   0560 0A A5 07      jmp _if3_exit
0200   0563             _if3_else:
0201   0563             _if5_cond:
0202   0563 29 EF 11      mov b, [cmdadr]
0203   0566 D7            push a
0204   0567 11            mov a, b
0205   0568 26 57 04      mov b, 1111
0206   056B B0            cmp a, b
0207   056C 0E            lodflgs
0208   056D 87 01         and al, %00000001 ; ==
0209   056F B9 00         cmp al, 0
0210   0571 0E            lodflgs
0211   0572 96            not al
0212   0573 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0213   0575 22 00         mov ah, 0
0214   0577 27            mov b, a
0215   0578 E4            pop a
0216   0579 C0 00 00      cmp b, 0
0217   057C C6 1F 06      je _if5_else
0218   057F             _if5_true:
0219   057F 07 E0 0F      call readint
0220   0582 FD 42 FD 11   mov [i], b
0221   0586 29 ED 11      mov b, [instruction]
0222   0589 D7            push a
0223   058A 74            mov d, b
0224   058B DA            push d
0225   058C 29 FD 11      mov b, [i]
0226   058F D7            push a
0227   0590 11            mov a, b
0228   0591 26 04 00      mov b, 4
0229   0594 AC            mul a, b
0230   0595 E4            pop a
0231   0596 E7            pop d
0232   0597 10 02 00      mov a, 2
0233   059A AC            mul a, b
0234   059B 5A            add d, b
0235   059C 2A            mov b, [d]
0236   059D E4            pop a
0237   059E FD AB         swp b
0238   05A0 D8            push b
0239   05A1 07 F0 0F      call displaynumber
0240   05A4 51 02 00      add sp, 2
0241   05A7 29 ED 11      mov b, [instruction]
0242   05AA D7            push a
0243   05AB 74            mov d, b
0244   05AC DA            push d
0245   05AD 29 FD 11      mov b, [i]
0246   05B0 D7            push a
0247   05B1 11            mov a, b
0248   05B2 26 04 00      mov b, 4
0249   05B5 AC            mul a, b
0250   05B6 11            mov a, b
0251   05B7 26 01 00      mov b, 1
0252   05BA 54            add a, b
0253   05BB 27            mov b, a
0254   05BC E4            pop a
0255   05BD E7            pop d
0256   05BE 10 02 00      mov a, 2
0257   05C1 AC            mul a, b
0258   05C2 5A            add d, b
0259   05C3 2A            mov b, [d]
0260   05C4 E4            pop a
0261   05C5 FD AB         swp b
0262   05C7 D8            push b
0263   05C8 07 F0 0F      call displaynumber
0264   05CB 51 02 00      add sp, 2
0265   05CE 29 ED 11      mov b, [instruction]
0266   05D1 D7            push a
0267   05D2 74            mov d, b
0268   05D3 DA            push d
0269   05D4 29 FD 11      mov b, [i]
0270   05D7 D7            push a
0271   05D8 11            mov a, b
0272   05D9 26 04 00      mov b, 4
0273   05DC AC            mul a, b
0274   05DD 11            mov a, b
0275   05DE 26 02 00      mov b, 2
0276   05E1 54            add a, b
0277   05E2 27            mov b, a
0278   05E3 E4            pop a
0279   05E4 E7            pop d
0280   05E5 10 02 00      mov a, 2
0281   05E8 AC            mul a, b
0282   05E9 5A            add d, b
0283   05EA 2A            mov b, [d]
0284   05EB E4            pop a
0285   05EC FD AB         swp b
0286   05EE D8            push b
0287   05EF 07 F0 0F      call displaynumber
0288   05F2 51 02 00      add sp, 2
0289   05F5 29 ED 11      mov b, [instruction]
0290   05F8 D7            push a
0291   05F9 74            mov d, b
0292   05FA DA            push d
0293   05FB 29 FD 11      mov b, [i]
0294   05FE D7            push a
0295   05FF 11            mov a, b
0296   0600 26 04 00      mov b, 4
0297   0603 AC            mul a, b
0298   0604 11            mov a, b
0299   0605 26 03 00      mov b, 3
0300   0608 54            add a, b
0301   0609 27            mov b, a
0302   060A E4            pop a
0303   060B E7            pop d
0304   060C 10 02 00      mov a, 2
0305   060F AC            mul a, b
0306   0610 5A            add d, b
0307   0611 2A            mov b, [d]
0308   0612 E4            pop a
0309   0613 FD AB         swp b
0310   0615 D8            push b
0311   0616 07 F0 0F      call displaynumber
0312   0619 51 02 00      add sp, 2
0313   061C 0A A5 07      jmp _if5_exit
0314   061F             _if5_else:
0315   061F             _if6_cond:
0316   061F 29 EF 11      mov b, [cmdadr]
0317   0622 D7            push a
0318   0623 11            mov a, b
0319   0624 26 AE 08      mov b, 2222
0320   0627 B0            cmp a, b
0321   0628 0E            lodflgs
0322   0629 87 01         and al, %00000001 ; ==
0323   062B B9 00         cmp al, 0
0324   062D 0E            lodflgs
0325   062E 96            not al
0326   062F 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0327   0631 22 00         mov ah, 0
0328   0633 27            mov b, a
0329   0634 E4            pop a
0330   0635 C0 00 00      cmp b, 0
0331   0638 C6 5F 06      je _if6_else
0332   063B             _if6_true:
0333   063B 07 E0 0F      call readint
0334   063E FD 42 FD 11   mov [i], b
0335   0642 29 FB 10      mov b, [datum]
0336   0645 D7            push a
0337   0646 74            mov d, b
0338   0647 DA            push d
0339   0648 29 FD 11      mov b, [i]
0340   064B E7            pop d
0341   064C 10 02 00      mov a, 2
0342   064F AC            mul a, b
0343   0650 5A            add d, b
0344   0651 2A            mov b, [d]
0345   0652 E4            pop a
0346   0653 FD AB         swp b
0347   0655 D8            push b
0348   0656 07 F0 0F      call displaynumber
0349   0659 51 02 00      add sp, 2
0350   065C 0A A5 07      jmp _if6_exit
0351   065F             _if6_else:
0352   065F             _if7_cond:
0353   065F 29 EF 11      mov b, [cmdadr]
0354   0662 D7            push a
0355   0663 11            mov a, b
0356   0664 26 5C 11      mov b, 4444
0357   0667 B0            cmp a, b
0358   0668 0E            lodflgs
0359   0669 87 01         and al, %00000001 ; ==
0360   066B B9 00         cmp al, 0
0361   066D 0E            lodflgs
0362   066E 96            not al
0363   066F 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0364   0671 22 00         mov ah, 0
0365   0673 27            mov b, a
0366   0674 E4            pop a
0367   0675 C0 00 00      cmp b, 0
0368   0678 C6 93 06      je _if7_else
0369   067B             _if7_true:
0370   067B 29 FB 10      mov b, [datum]
0371   067E 74            mov d, b
0372   067F DA            push d
0373   0680 07 E0 0F      call readint
0374   0683 E7            pop d
0375   0684 10 02 00      mov a, 2
0376   0687 AC            mul a, b
0377   0688 5A            add d, b
0378   0689 DA            push d
0379   068A 07 E0 0F      call readint
0380   068D E7            pop d
0381   068E 11            mov a, b
0382   068F 43            mov [d], a
0383   0690 0A A5 07      jmp _if7_exit
0384   0693             _if7_else:
0385   0693             _if8_cond:
0386   0693 29 EF 11      mov b, [cmdadr]
0387   0696 D7            push a
0388   0697 11            mov a, b
0389   0698 26 B3 15      mov b, 5555
0390   069B B0            cmp a, b
0391   069C 0E            lodflgs
0392   069D 87 01         and al, %00000001 ; ==
0393   069F B9 00         cmp al, 0
0394   06A1 0E            lodflgs
0395   06A2 96            not al
0396   06A3 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0397   06A5 22 00         mov ah, 0
0398   06A7 27            mov b, a
0399   06A8 E4            pop a
0400   06A9 C0 00 00      cmp b, 0
0401   06AC C6 F6 06      je _if8_else
0402   06AF             _if8_true:
0403   06AF             _for9_init:
0404   06AF 26 00 00      mov b, 0
0405   06B2 FD 42 FD 11   mov [i], b
0406   06B6             _for9_cond:
0407   06B6 29 FD 11      mov b, [i]
0408   06B9 D7            push a
0409   06BA 11            mov a, b
0410   06BB 26 1E 00      mov b, 30
0411   06BE B0            cmp a, b
0412   06BF 0E            lodflgs
0413   06C0 87 02         and al, %00000010 ; <
0414   06C2 B9 00         cmp al, 0
0415   06C4 0E            lodflgs
0416   06C5 96            not al
0417   06C6 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0418   06C8 22 00         mov ah, 0
0419   06CA 27            mov b, a
0420   06CB E4            pop a
0421   06CC C0 00 00      cmp b, 0
0422   06CF C6 F3 06      je _for9_exit
0423   06D2             _for9_block:
0424   06D2 29 ED 11      mov b, [instruction]
0425   06D5 74            mov d, b
0426   06D6 DA            push d
0427   06D7 29 FD 11      mov b, [i]
0428   06DA E7            pop d
0429   06DB 10 02 00      mov a, 2
0430   06DE AC            mul a, b
0431   06DF 5A            add d, b
0432   06E0 DA            push d
0433   06E1 26 00 00      mov b, 0
0434   06E4 E7            pop d
0435   06E5 11            mov a, b
0436   06E6 43            mov [d], a
0437   06E7             _for9_update:
0438   06E7 29 FD 11      mov b, [i]
0439   06EA FD 77         inc b
0440   06EC FD 42 FD 11   mov [i], b
0441   06F0 0A B6 06      jmp _for9_cond
0442   06F3             _for9_exit:
0443   06F3 0A A5 07      jmp _if8_exit
0444   06F6             _if8_else:
0445   06F6             _if10_cond:
0446   06F6 29 EF 11      mov b, [cmdadr]
0447   06F9 D7            push a
0448   06FA 11            mov a, b
0449   06FB 26 0A 1A      mov b, 6666
0450   06FE B0            cmp a, b
0451   06FF 0E            lodflgs
0452   0700 87 01         and al, %00000001 ; ==
0453   0702 B9 00         cmp al, 0
0454   0704 0E            lodflgs
0455   0705 96            not al
0456   0706 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0457   0708 22 00         mov ah, 0
0458   070A 27            mov b, a
0459   070B E4            pop a
0460   070C C0 00 00      cmp b, 0
0461   070F C6 59 07      je _if10_else
0462   0712             _if10_true:
0463   0712             _for11_init:
0464   0712 29 F3 11      mov b, [datadr1]
0465   0715 FD 42 FD 11   mov [i], b
0466   0719             _for11_cond:
0467   0719 29 FD 11      mov b, [i]
0468   071C D7            push a
0469   071D 11            mov a, b
0470   071E 26 7B 00      mov b, 123
0471   0721 B0            cmp a, b
0472   0722 0E            lodflgs
0473   0723 87 02         and al, %00000010 ; <
0474   0725 B9 00         cmp al, 0
0475   0727 0E            lodflgs
0476   0728 96            not al
0477   0729 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0478   072B 22 00         mov ah, 0
0479   072D 27            mov b, a
0480   072E E4            pop a
0481   072F C0 00 00      cmp b, 0
0482   0732 C6 56 07      je _for11_exit
0483   0735             _for11_block:
0484   0735 29 FB 10      mov b, [datum]
0485   0738 74            mov d, b
0486   0739 DA            push d
0487   073A 29 FD 11      mov b, [i]
0488   073D E7            pop d
0489   073E 10 02 00      mov a, 2
0490   0741 AC            mul a, b
0491   0742 5A            add d, b
0492   0743 DA            push d
0493   0744 26 00 00      mov b, 0
0494   0747 E7            pop d
0495   0748 11            mov a, b
0496   0749 43            mov [d], a
0497   074A             _for11_update:
0498   074A 29 FD 11      mov b, [i]
0499   074D FD 77         inc b
0500   074F FD 42 FD 11   mov [i], b
0501   0753 0A 19 07      jmp _for11_cond
0502   0756             _for11_exit:
0503   0756 0A A5 07      jmp _if10_exit
0504   0759             _if10_else:
0505   0759             _if12_cond:
0506   0759 29 EF 11      mov b, [cmdadr]
0507   075C D7            push a
0508   075D 11            mov a, b
0509   075E 26 0F 27      mov b, 9999
0510   0761 B0            cmp a, b
0511   0762 0E            lodflgs
0512   0763 87 01         and al, %00000001 ; ==
0513   0765 B9 00         cmp al, 0
0514   0767 0E            lodflgs
0515   0768 96            not al
0516   0769 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0517   076B 22 00         mov ah, 0
0518   076D 27            mov b, a
0519   076E E4            pop a
0520   076F C0 00 00      cmp b, 0
0521   0772 C6 7F 07      je _if12_else
0522   0775             _if12_true:
0523   0775 07 E0 0F      call readint
0524   0778 FD 42 07 12   mov [runlimit], b
0525   077C 0A A5 07      jmp _if12_exit
0526   077F             _if12_else:
0527   077F             _if13_cond:
0528   077F 29 EF 11      mov b, [cmdadr]
0529   0782 D7            push a
0530   0783 11            mov a, b
0531   0784 26 B8 22      mov b, 8888
0532   0787 B0            cmp a, b
0533   0788 0E            lodflgs
0534   0789 87 01         and al, %00000001 ; ==
0535   078B B9 00         cmp al, 0
0536   078D 0E            lodflgs
0537   078E 96            not al
0538   078F 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0539   0791 22 00         mov ah, 0
0540   0793 27            mov b, a
0541   0794 E4            pop a
0542   0795 C0 00 00      cmp b, 0
0543   0798 C6 A5 07      je _if13_exit
0544   079B             _if13_true:
0545   079B 26 01 00      mov b, 1
0546   079E FD 42 09 12   mov [exitflag], b
0547   07A2 0A A5 07      jmp _if13_exit
0548   07A5             _if13_exit:
0549   07A5             _if12_exit:
0550   07A5             _if10_exit:
0551   07A5             _if8_exit:
0552   07A5             _if7_exit:
0553   07A5             _if6_exit:
0554   07A5             _if5_exit:
0555   07A5             _if3_exit:
0556   07A5 0A 25 04      jmp _while2_cond
0557   07A8             _while2_exit:
0558   07A8 26 00 00      mov b, 0
0559   07AB FD 42 0B 12   mov [exitexec], b
0560   07AF             _if14_cond:
0561   07AF 29 09 12      mov b, [exitflag]
0562   07B2 D7            push a
0563   07B3 11            mov a, b
0564   07B4 26 00 00      mov b, 0
0565   07B7 B0            cmp a, b
0566   07B8 0E            lodflgs
0567   07B9 87 01         and al, %00000001 ; ==
0568   07BB B9 00         cmp al, 0
0569   07BD 0E            lodflgs
0570   07BE 96            not al
0571   07BF 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0572   07C1 22 00         mov ah, 0
0573   07C3 27            mov b, a
0574   07C4 E4            pop a
0575   07C5 C0 00 00      cmp b, 0
0576   07C8 C6 DD 0F      je _if14_exit
0577   07CB             _if14_true:
0578   07CB             _while15_cond:
0579   07CB 29 F9 11      mov b, [pc]
0580   07CE D7            push a
0581   07CF 11            mov a, b
0582   07D0 26 1E 00      mov b, 30
0583   07D3 B0            cmp a, b
0584   07D4 0E            lodflgs
0585   07D5 87 02         and al, %00000010 ; <
0586   07D7 B9 00         cmp al, 0
0587   07D9 0E            lodflgs
0588   07DA 96            not al
0589   07DB 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0590   07DD 22 00         mov ah, 0
0591   07DF 27            mov b, a
0592   07E0 E4            pop a
0593   07E1 C0 00 00      cmp b, 0
0594   07E4 C6 DA 0F      je _while15_exit
0595   07E7             _while15_block:
0596   07E7             _if16_cond:
0597   07E7 29 07 12      mov b, [runlimit]
0598   07EA D7            push a
0599   07EB 11            mov a, b
0600   07EC 26 01 00      mov b, 1
0601   07EF B0            cmp a, b
0602   07F0 0E            lodflgs
0603   07F1 87 01         and al, %00000001 ; ==
0604   07F3 B9 00         cmp al, 0
0605   07F5 0E            lodflgs
0606   07F6 96            not al
0607   07F7 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0608   07F9 22 00         mov ah, 0
0609   07FB 27            mov b, a
0610   07FC E4            pop a
0611   07FD C0 00 00      cmp b, 0
0612   0800 C6 09 08      je _if16_else
0613   0803             _if16_true:
0614   0803 0A DA 0F      jmp _while15_exit ; while break
0615   0806 0A 36 08      jmp _if16_exit
0616   0809             _if16_else:
0617   0809             _if17_cond:
0618   0809 29 07 12      mov b, [runlimit]
0619   080C D7            push a
0620   080D 11            mov a, b
0621   080E 26 01 00      mov b, 1
0622   0811 B0            cmp a, b
0623   0812 0E            lodflgs
0624   0813 87 03         and al, %00000011
0625   0815 B9 00         cmp al, %00000000
0626   0817 0E            lodflgs
0627   0818 87 01         and al, %00000001 ; >
0628   081A B9 00         cmp al, 0
0629   081C 0E            lodflgs
0630   081D 96            not al
0631   081E 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0632   0820 22 00         mov ah, 0
0633   0822 27            mov b, a
0634   0823 E4            pop a
0635   0824 C0 00 00      cmp b, 0
0636   0827 C6 36 08      je _if17_exit
0637   082A             _if17_true:
0638   082A 29 07 12      mov b, [runlimit]
0639   082D FD 7D         dec b
0640   082F FD 42 07 12   mov [runlimit], b
0641   0833 0A 36 08      jmp _if17_exit
0642   0836             _if17_exit:
0643   0836             _if16_exit:
0644   0836 29 FB 10      mov b, [datum]
0645   0839 74            mov d, b
0646   083A DA            push d
0647   083B 26 00 00      mov b, 0
0648   083E E7            pop d
0649   083F 10 02 00      mov a, 2
0650   0842 AC            mul a, b
0651   0843 5A            add d, b
0652   0844 DA            push d
0653   0845 26 00 00      mov b, 0
0654   0848 E7            pop d
0655   0849 11            mov a, b
0656   084A 43            mov [d], a
0657   084B 29 ED 11      mov b, [instruction]
0658   084E D7            push a
0659   084F 74            mov d, b
0660   0850 DA            push d
0661   0851 29 F9 11      mov b, [pc]
0662   0854 D7            push a
0663   0855 11            mov a, b
0664   0856 26 04 00      mov b, 4
0665   0859 AC            mul a, b
0666   085A E4            pop a
0667   085B E7            pop d
0668   085C 10 02 00      mov a, 2
0669   085F AC            mul a, b
0670   0860 5A            add d, b
0671   0861 2A            mov b, [d]
0672   0862 E4            pop a
0673   0863 FD 42 F1 11   mov [opr], b
0674   0867 29 ED 11      mov b, [instruction]
0675   086A D7            push a
0676   086B 74            mov d, b
0677   086C DA            push d
0678   086D 29 F9 11      mov b, [pc]
0679   0870 D7            push a
0680   0871 11            mov a, b
0681   0872 26 04 00      mov b, 4
0682   0875 AC            mul a, b
0683   0876 11            mov a, b
0684   0877 26 01 00      mov b, 1
0685   087A 54            add a, b
0686   087B 27            mov b, a
0687   087C E4            pop a
0688   087D E7            pop d
0689   087E 10 02 00      mov a, 2
0690   0881 AC            mul a, b
0691   0882 5A            add d, b
0692   0883 2A            mov b, [d]
0693   0884 E4            pop a
0694   0885 FD 42 F3 11   mov [datadr1], b
0695   0889 29 ED 11      mov b, [instruction]
0696   088C D7            push a
0697   088D 74            mov d, b
0698   088E DA            push d
0699   088F 29 F9 11      mov b, [pc]
0700   0892 D7            push a
0701   0893 11            mov a, b
0702   0894 26 04 00      mov b, 4
0703   0897 AC            mul a, b
0704   0898 11            mov a, b
0705   0899 26 02 00      mov b, 2
0706   089C 54            add a, b
0707   089D 27            mov b, a
0708   089E E4            pop a
0709   089F E7            pop d
0710   08A0 10 02 00      mov a, 2
0711   08A3 AC            mul a, b
0712   08A4 5A            add d, b
0713   08A5 2A            mov b, [d]
0714   08A6 E4            pop a
0715   08A7 FD 42 F5 11   mov [datadr2], b
0716   08AB 29 ED 11      mov b, [instruction]
0717   08AE D7            push a
0718   08AF 74            mov d, b
0719   08B0 DA            push d
0720   08B1 29 F9 11      mov b, [pc]
0721   08B4 D7            push a
0722   08B5 11            mov a, b
0723   08B6 26 04 00      mov b, 4
0724   08B9 AC            mul a, b
0725   08BA 11            mov a, b
0726   08BB 26 03 00      mov b, 3
0727   08BE 54            add a, b
0728   08BF 27            mov b, a
0729   08C0 E4            pop a
0730   08C1 E7            pop d
0731   08C2 10 02 00      mov a, 2
0732   08C5 AC            mul a, b
0733   08C6 5A            add d, b
0734   08C7 2A            mov b, [d]
0735   08C8 E4            pop a
0736   08C9 FD 42 F7 11   mov [datadr3], b
0737   08CD             _if18_cond:
0738   08CD 29 FB 11      mov b, [h]
0739   08D0 D7            push a
0740   08D1 11            mov a, b
0741   08D2 26 00 00      mov b, 0
0742   08D5 B0            cmp a, b
0743   08D6 0E            lodflgs
0744   08D7 87 03         and al, %00000011
0745   08D9 B9 00         cmp al, %00000000
0746   08DB 0E            lodflgs
0747   08DC 87 01         and al, %00000001 ; >
0748   08DE B9 00         cmp al, 0
0749   08E0 0E            lodflgs
0750   08E1 96            not al
0751   08E2 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0752   08E4 22 00         mov ah, 0
0753   08E6 27            mov b, a
0754   08E7 11            mov a, b
0755   08E8 29 01 12      mov b, [k]
0756   08EB D7            push a
0757   08EC 11            mov a, b
0758   08ED 26 00 00      mov b, 0
0759   08F0 B0            cmp a, b
0760   08F1 0E            lodflgs
0761   08F2 87 03         and al, %00000011
0762   08F4 B9 00         cmp al, %00000000
0763   08F6 0E            lodflgs
0764   08F7 87 01         and al, %00000001 ; >
0765   08F9 B9 00         cmp al, 0
0766   08FB 0E            lodflgs
0767   08FC 96            not al
0768   08FD 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0769   08FF 22 00         mov ah, 0
0770   0901 27            mov b, a
0771   0902 E4            pop a
0772   0903 8A            or a, b
0773   0904 27            mov b, a
0774   0905 11            mov a, b
0775   0906 29 03 12      mov b, [l]
0776   0909 D7            push a
0777   090A 11            mov a, b
0778   090B 26 00 00      mov b, 0
0779   090E B0            cmp a, b
0780   090F 0E            lodflgs
0781   0910 87 03         and al, %00000011
0782   0912 B9 00         cmp al, %00000000
0783   0914 0E            lodflgs
0784   0915 87 01         and al, %00000001 ; >
0785   0917 B9 00         cmp al, 0
0786   0919 0E            lodflgs
0787   091A 96            not al
0788   091B 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0789   091D 22 00         mov ah, 0
0790   091F 27            mov b, a
0791   0920 E4            pop a
0792   0921 8A            or a, b
0793   0922 27            mov b, a
0794   0923 E4            pop a
0795   0924 C0 00 00      cmp b, 0
0796   0927 C6 57 09      je _if18_exit
0797   092A             _if18_true:
0798   092A 29 FB 11      mov b, [h]
0799   092D FD 42 F3 11   mov [datadr1], b
0800   0931 29 01 12      mov b, [k]
0801   0934 FD 42 F5 11   mov [datadr2], b
0802   0938 29 03 12      mov b, [l]
0803   093B FD 42 F7 11   mov [datadr3], b
0804   093F 26 00 00      mov b, 0
0805   0942 FD 42 FB 11   mov [h], b
0806   0946 26 00 00      mov b, 0
0807   0949 FD 42 01 12   mov [k], b
0808   094D 26 00 00      mov b, 0
0809   0950 FD 42 03 12   mov [l], b
0810   0954 0A 57 09      jmp _if18_exit
0811   0957             _if18_exit:
0812   0957 29 F9 11      mov b, [pc]
0813   095A D7            push a
0814   095B 11            mov a, b
0815   095C 26 64 00      mov b, 100
0816   095F AC            mul a, b
0817   0960 11            mov a, b
0818   0961 29 F1 11      mov b, [opr]
0819   0964 54            add a, b
0820   0965 27            mov b, a
0821   0966 E4            pop a
0822   0967 FD AB         swp b
0823   0969 D8            push b
0824   096A 07 F0 0F      call displaynumber
0825   096D 51 02 00      add sp, 2
0826   0970             _if19_cond:
0827   0970 29 F1 11      mov b, [opr]
0828   0973 D7            push a
0829   0974 11            mov a, b
0830   0975 26 00 00      mov b, 0
0831   0978 B0            cmp a, b
0832   0979 0E            lodflgs
0833   097A 87 01         and al, %00000001 ; ==
0834   097C B9 00         cmp al, 0
0835   097E 0E            lodflgs
0836   097F 96            not al
0837   0980 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0838   0982 22 00         mov ah, 0
0839   0984 27            mov b, a
0840   0985 E4            pop a
0841   0986 C0 00 00      cmp b, 0
0842   0989 C6 8F 09      je _if19_else
0843   098C             _if19_true:
0844   098C 0A 63 0F      jmp _if19_exit
0845   098F             _if19_else:
0846   098F             _if20_cond:
0847   098F 29 F1 11      mov b, [opr]
0848   0992 D7            push a
0849   0993 11            mov a, b
0850   0994 26 01 00      mov b, 1
0851   0997 B0            cmp a, b
0852   0998 0E            lodflgs
0853   0999 87 01         and al, %00000001 ; ==
0854   099B B9 00         cmp al, 0
0855   099D 0E            lodflgs
0856   099E 96            not al
0857   099F 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0858   09A1 22 00         mov ah, 0
0859   09A3 27            mov b, a
0860   09A4 E4            pop a
0861   09A5 C0 00 00      cmp b, 0
0862   09A8 C6 8B 0C      je _if20_else
0863   09AB             _if20_true:
0864   09AB 26 00 00      mov b, 0
0865   09AE FD 42 01 12   mov [k], b
0866   09B2             _if21_cond:
0867   09B2 29 F7 11      mov b, [datadr3]
0868   09B5 D7            push a
0869   09B6 11            mov a, b
0870   09B7 26 06 00      mov b, 6
0871   09BA B0            cmp a, b
0872   09BB 0E            lodflgs
0873   09BC 87 03         and al, %00000011
0874   09BE B9 00         cmp al, %00000000
0875   09C0 0E            lodflgs
0876   09C1 87 01         and al, %00000001 ; >
0877   09C3 B9 00         cmp al, 0
0878   09C5 0E            lodflgs
0879   09C6 96            not al
0880   09C7 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0881   09C9 22 00         mov ah, 0
0882   09CB 27            mov b, a
0883   09CC E4            pop a
0884   09CD C0 00 00      cmp b, 0
0885   09D0 C6 EC 09      je _if21_exit
0886   09D3             _if21_true:
0887   09D3 29 F7 11      mov b, [datadr3]
0888   09D6 D7            push a
0889   09D7 11            mov a, b
0890   09D8 26 07 00      mov b, 7
0891   09DB 60            sub a, b
0892   09DC 27            mov b, a
0893   09DD E4            pop a
0894   09DE FD 42 F7 11   mov [datadr3], b
0895   09E2 26 40 00      mov b, 64
0896   09E5 FD 42 01 12   mov [k], b
0897   09E9 0A EC 09      jmp _if21_exit
0898   09EC             _if21_exit:
0899   09EC             _if22_cond:
0900   09EC 29 FB 10      mov b, [datum]
0901   09EF D7            push a
0902   09F0 74            mov d, b
0903   09F1 DA            push d
0904   09F2 29 F3 11      mov b, [datadr1]
0905   09F5 E7            pop d
0906   09F6 10 02 00      mov a, 2
0907   09F9 AC            mul a, b
0908   09FA 5A            add d, b
0909   09FB 2A            mov b, [d]
0910   09FC 11            mov a, b
0911   09FD 26 00 00      mov b, 0
0912   0A00 B0            cmp a, b
0913   0A01 0E            lodflgs
0914   0A02 87 01         and al, %00000001 ; ==
0915   0A04 B9 00         cmp al, 0
0916   0A06 0E            lodflgs
0917   0A07 96            not al
0918   0A08 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0919   0A0A 22 00         mov ah, 0
0920   0A0C 27            mov b, a
0921   0A0D 11            mov a, b
0922   0A0E AF 00 00      cmp a, 0
0923   0A11 0E            lodflgs
0924   0A12 96            not al
0925   0A13 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
0926   0A15 29 F7 11      mov b, [datadr3]
0927   0A18 D7            push a
0928   0A19 11            mov a, b
0929   0A1A 26 00 00      mov b, 0
0930   0A1D B0            cmp a, b
0931   0A1E 0E            lodflgs
0932   0A1F 87 01         and al, %00000001 ; ==
0933   0A21 B9 00         cmp al, 0
0934   0A23 0E            lodflgs
0935   0A24 96            not al
0936   0A25 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0937   0A27 22 00         mov ah, 0
0938   0A29 27            mov b, a
0939   0A2A E4            pop a
0940   0A2B DB            push al
0941   0A2C C0 00 00      cmp b, 0
0942   0A2F 0E            lodflgs
0943   0A30 96            not al
0944   0A31 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
0945   0A33 EA            pop bl
0946   0A34 88            and al, bl
0947   0A35 2F            mov bl, al
0948   0A36 A7 00         mov bh, 0
0949   0A38 11            mov a, b
0950   0A39 29 FB 10      mov b, [datum]
0951   0A3C D7            push a
0952   0A3D 74            mov d, b
0953   0A3E DA            push d
0954   0A3F 29 F3 11      mov b, [datadr1]
0955   0A42 E7            pop d
0956   0A43 10 02 00      mov a, 2
0957   0A46 AC            mul a, b
0958   0A47 5A            add d, b
0959   0A48 2A            mov b, [d]
0960   0A49 11            mov a, b
0961   0A4A 26 FF 7F      mov b, 32767
0962   0A4D B0            cmp a, b
0963   0A4E 0E            lodflgs
0964   0A4F 87 03         and al, %00000011
0965   0A51 B9 00         cmp al, %00000000
0966   0A53 0E            lodflgs
0967   0A54 87 01         and al, %00000001 ; >
0968   0A56 B9 00         cmp al, 0
0969   0A58 0E            lodflgs
0970   0A59 96            not al
0971   0A5A 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0972   0A5C 22 00         mov ah, 0
0973   0A5E 27            mov b, a
0974   0A5F 11            mov a, b
0975   0A60 AF 00 00      cmp a, 0
0976   0A63 0E            lodflgs
0977   0A64 96            not al
0978   0A65 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
0979   0A67 29 F7 11      mov b, [datadr3]
0980   0A6A D7            push a
0981   0A6B 11            mov a, b
0982   0A6C 26 02 00      mov b, 2
0983   0A6F B0            cmp a, b
0984   0A70 0E            lodflgs
0985   0A71 87 01         and al, %00000001 ; ==
0986   0A73 B9 00         cmp al, 0
0987   0A75 0E            lodflgs
0988   0A76 96            not al
0989   0A77 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0990   0A79 22 00         mov ah, 0
0991   0A7B 27            mov b, a
0992   0A7C E4            pop a
0993   0A7D DB            push al
0994   0A7E C0 00 00      cmp b, 0
0995   0A81 0E            lodflgs
0996   0A82 96            not al
0997   0A83 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
0998   0A85 EA            pop bl
0999   0A86 88            and al, bl
1000   0A87 2F            mov bl, al
1001   0A88 A7 00         mov bh, 0
1002   0A8A E4            pop a
1003   0A8B 8A            or a, b
1004   0A8C 27            mov b, a
1005   0A8D 11            mov a, b
1006   0A8E 29 FB 10      mov b, [datum]
1007   0A91 D7            push a
1008   0A92 74            mov d, b
1009   0A93 DA            push d
1010   0A94 29 F3 11      mov b, [datadr1]
1011   0A97 E7            pop d
1012   0A98 10 02 00      mov a, 2
1013   0A9B AC            mul a, b
1014   0A9C 5A            add d, b
1015   0A9D 2A            mov b, [d]
1016   0A9E 11            mov a, b
1017   0A9F 26 FF 7F      mov b, 32767
1018   0AA2 B0            cmp a, b
1019   0AA3 0E            lodflgs
1020   0AA4 87 03         and al, %00000011
1021   0AA6 8F 02         xor al, %00000010 ; >=
1022   0AA8 B9 00         cmp al, 0
1023   0AAA 0E            lodflgs
1024   0AAB 96            not al
1025   0AAC 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1026   0AAE 22 00         mov ah, 0
1027   0AB0 27            mov b, a
1028   0AB1 11            mov a, b
1029   0AB2 AF 00 00      cmp a, 0
1030   0AB5 0E            lodflgs
1031   0AB6 96            not al
1032   0AB7 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
1033   0AB9 29 F7 11      mov b, [datadr3]
1034   0ABC D7            push a
1035   0ABD 11            mov a, b
1036   0ABE 26 04 00      mov b, 4
1037   0AC1 B0            cmp a, b
1038   0AC2 0E            lodflgs
1039   0AC3 87 01         and al, %00000001 ; ==
1040   0AC5 B9 00         cmp al, 0
1041   0AC7 0E            lodflgs
1042   0AC8 96            not al
1043   0AC9 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1044   0ACB 22 00         mov ah, 0
1045   0ACD 27            mov b, a
1046   0ACE E4            pop a
1047   0ACF DB            push al
1048   0AD0 C0 00 00      cmp b, 0
1049   0AD3 0E            lodflgs
1050   0AD4 96            not al
1051   0AD5 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
1052   0AD7 EA            pop bl
1053   0AD8 88            and al, bl
1054   0AD9 2F            mov bl, al
1055   0ADA A7 00         mov bh, 0
1056   0ADC E4            pop a
1057   0ADD 8A            or a, b
1058   0ADE 27            mov b, a
1059   0ADF 11            mov a, b
1060   0AE0 29 FB 10      mov b, [datum]
1061   0AE3 D7            push a
1062   0AE4 74            mov d, b
1063   0AE5 DA            push d
1064   0AE6 29 F3 11      mov b, [datadr1]
1065   0AE9 E7            pop d
1066   0AEA 10 02 00      mov a, 2
1067   0AED AC            mul a, b
1068   0AEE 5A            add d, b
1069   0AEF 2A            mov b, [d]
1070   0AF0 11            mov a, b
1071   0AF1 26 00 00      mov b, 0
1072   0AF4 B0            cmp a, b
1073   0AF5 0E            lodflgs
1074   0AF6 87 03         and al, %00000011
1075   0AF8 B9 00         cmp al, %00000000
1076   0AFA 0E            lodflgs
1077   0AFB 87 01         and al, %00000001 ; >
1078   0AFD B9 00         cmp al, 0
1079   0AFF 0E            lodflgs
1080   0B00 96            not al
1081   0B01 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1082   0B03 22 00         mov ah, 0
1083   0B05 27            mov b, a
1084   0B06 11            mov a, b
1085   0B07 AF 00 00      cmp a, 0
1086   0B0A 0E            lodflgs
1087   0B0B 96            not al
1088   0B0C 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
1089   0B0E 29 FB 10      mov b, [datum]
1090   0B11 D7            push a
1091   0B12 74            mov d, b
1092   0B13 DA            push d
1093   0B14 29 F3 11      mov b, [datadr1]
1094   0B17 E7            pop d
1095   0B18 10 02 00      mov a, 2
1096   0B1B AC            mul a, b
1097   0B1C 5A            add d, b
1098   0B1D 2A            mov b, [d]
1099   0B1E 11            mov a, b
1100   0B1F 26 FF 7F      mov b, 32767
1101   0B22 B0            cmp a, b
1102   0B23 0E            lodflgs
1103   0B24 87 03         and al, %00000011 ; <=
1104   0B26 B9 00         cmp al, 0
1105   0B28 0E            lodflgs
1106   0B29 96            not al
1107   0B2A 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1108   0B2C 22 00         mov ah, 0
1109   0B2E 27            mov b, a
1110   0B2F E4            pop a
1111   0B30 DB            push al
1112   0B31 C0 00 00      cmp b, 0
1113   0B34 0E            lodflgs
1114   0B35 96            not al
1115   0B36 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
1116   0B38 EA            pop bl
1117   0B39 88            and al, bl
1118   0B3A 2F            mov bl, al
1119   0B3B A7 00         mov bh, 0
1120   0B3D 11            mov a, b
1121   0B3E AF 00 00      cmp a, 0
1122   0B41 0E            lodflgs
1123   0B42 96            not al
1124   0B43 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
1125   0B45 29 F7 11      mov b, [datadr3]
1126   0B48 D7            push a
1127   0B49 11            mov a, b
1128   0B4A 26 01 00      mov b, 1
1129   0B4D B0            cmp a, b
1130   0B4E 0E            lodflgs
1131   0B4F 87 01         and al, %00000001 ; ==
1132   0B51 B9 00         cmp al, 0
1133   0B53 0E            lodflgs
1134   0B54 96            not al
1135   0B55 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1136   0B57 22 00         mov ah, 0
1137   0B59 27            mov b, a
1138   0B5A E4            pop a
1139   0B5B DB            push al
1140   0B5C C0 00 00      cmp b, 0
1141   0B5F 0E            lodflgs
1142   0B60 96            not al
1143   0B61 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
1144   0B63 EA            pop bl
1145   0B64 88            and al, bl
1146   0B65 2F            mov bl, al
1147   0B66 A7 00         mov bh, 0
1148   0B68 E4            pop a
1149   0B69 8A            or a, b
1150   0B6A 27            mov b, a
1151   0B6B 11            mov a, b
1152   0B6C 29 FB 10      mov b, [datum]
1153   0B6F D7            push a
1154   0B70 74            mov d, b
1155   0B71 DA            push d
1156   0B72 29 F3 11      mov b, [datadr1]
1157   0B75 E7            pop d
1158   0B76 10 02 00      mov a, 2
1159   0B79 AC            mul a, b
1160   0B7A 5A            add d, b
1161   0B7B 2A            mov b, [d]
1162   0B7C 11            mov a, b
1163   0B7D 26 00 00      mov b, 0
1164   0B80 B0            cmp a, b
1165   0B81 0E            lodflgs
1166   0B82 87 03         and al, %00000011
1167   0B84 8F 02         xor al, %00000010 ; >=
1168   0B86 B9 00         cmp al, 0
1169   0B88 0E            lodflgs
1170   0B89 96            not al
1171   0B8A 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1172   0B8C 22 00         mov ah, 0
1173   0B8E 27            mov b, a
1174   0B8F 11            mov a, b
1175   0B90 AF 00 00      cmp a, 0
1176   0B93 0E            lodflgs
1177   0B94 96            not al
1178   0B95 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
1179   0B97 29 FB 10      mov b, [datum]
1180   0B9A D7            push a
1181   0B9B 74            mov d, b
1182   0B9C DA            push d
1183   0B9D 29 F3 11      mov b, [datadr1]
1184   0BA0 E7            pop d
1185   0BA1 10 02 00      mov a, 2
1186   0BA4 AC            mul a, b
1187   0BA5 5A            add d, b
1188   0BA6 2A            mov b, [d]
1189   0BA7 11            mov a, b
1190   0BA8 26 FF 7F      mov b, 32767
1191   0BAB B0            cmp a, b
1192   0BAC 0E            lodflgs
1193   0BAD 87 03         and al, %00000011 ; <=
1194   0BAF B9 00         cmp al, 0
1195   0BB1 0E            lodflgs
1196   0BB2 96            not al
1197   0BB3 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1198   0BB5 22 00         mov ah, 0
1199   0BB7 27            mov b, a
1200   0BB8 E4            pop a
1201   0BB9 DB            push al
1202   0BBA C0 00 00      cmp b, 0
1203   0BBD 0E            lodflgs
1204   0BBE 96            not al
1205   0BBF 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
1206   0BC1 EA            pop bl
1207   0BC2 88            and al, bl
1208   0BC3 2F            mov bl, al
1209   0BC4 A7 00         mov bh, 0
1210   0BC6 11            mov a, b
1211   0BC7 AF 00 00      cmp a, 0
1212   0BCA 0E            lodflgs
1213   0BCB 96            not al
1214   0BCC 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
1215   0BCE 29 F7 11      mov b, [datadr3]
1216   0BD1 D7            push a
1217   0BD2 11            mov a, b
1218   0BD3 26 03 00      mov b, 3
1219   0BD6 B0            cmp a, b
1220   0BD7 0E            lodflgs
1221   0BD8 87 01         and al, %00000001 ; ==
1222   0BDA B9 00         cmp al, 0
1223   0BDC 0E            lodflgs
1224   0BDD 96            not al
1225   0BDE 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1226   0BE0 22 00         mov ah, 0
1227   0BE2 27            mov b, a
1228   0BE3 E4            pop a
1229   0BE4 DB            push al
1230   0BE5 C0 00 00      cmp b, 0
1231   0BE8 0E            lodflgs
1232   0BE9 96            not al
1233   0BEA 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
1234   0BEC EA            pop bl
1235   0BED 88            and al, bl
1236   0BEE 2F            mov bl, al
1237   0BEF A7 00         mov bh, 0
1238   0BF1 E4            pop a
1239   0BF2 8A            or a, b
1240   0BF3 27            mov b, a
1241   0BF4 11            mov a, b
1242   0BF5 29 FB 10      mov b, [datum]
1243   0BF8 D7            push a
1244   0BF9 74            mov d, b
1245   0BFA DA            push d
1246   0BFB 29 F3 11      mov b, [datadr1]
1247   0BFE E7            pop d
1248   0BFF 10 02 00      mov a, 2
1249   0C02 AC            mul a, b
1250   0C03 5A            add d, b
1251   0C04 2A            mov b, [d]
1252   0C05 11            mov a, b
1253   0C06 26 00 00      mov b, 0
1254   0C09 B0            cmp a, b
1255   0C0A 0E            lodflgs
1256   0C0B 87 01         and al, %00000001
1257   0C0D 8F 01         xor al, %00000001 ; !=
1258   0C0F B9 00         cmp al, 0
1259   0C11 0E            lodflgs
1260   0C12 96            not al
1261   0C13 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1262   0C15 22 00         mov ah, 0
1263   0C17 27            mov b, a
1264   0C18 11            mov a, b
1265   0C19 AF 00 00      cmp a, 0
1266   0C1C 0E            lodflgs
1267   0C1D 96            not al
1268   0C1E 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
1269   0C20 29 F7 11      mov b, [datadr3]
1270   0C23 D7            push a
1271   0C24 11            mov a, b
1272   0C25 26 05 00      mov b, 5
1273   0C28 B0            cmp a, b
1274   0C29 0E            lodflgs
1275   0C2A 87 01         and al, %00000001 ; ==
1276   0C2C B9 00         cmp al, 0
1277   0C2E 0E            lodflgs
1278   0C2F 96            not al
1279   0C30 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1280   0C32 22 00         mov ah, 0
1281   0C34 27            mov b, a
1282   0C35 E4            pop a
1283   0C36 DB            push al
1284   0C37 C0 00 00      cmp b, 0
1285   0C3A 0E            lodflgs
1286   0C3B 96            not al
1287   0C3C 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
1288   0C3E EA            pop bl
1289   0C3F 88            and al, bl
1290   0C40 2F            mov bl, al
1291   0C41 A7 00         mov bh, 0
1292   0C43 E4            pop a
1293   0C44 8A            or a, b
1294   0C45 27            mov b, a
1295   0C46 11            mov a, b
1296   0C47 29 F7 11      mov b, [datadr3]
1297   0C4A D7            push a
1298   0C4B 11            mov a, b
1299   0C4C 26 06 00      mov b, 6
1300   0C4F B0            cmp a, b
1301   0C50 0E            lodflgs
1302   0C51 87 01         and al, %00000001 ; ==
1303   0C53 B9 00         cmp al, 0
1304   0C55 0E            lodflgs
1305   0C56 96            not al
1306   0C57 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1307   0C59 22 00         mov ah, 0
1308   0C5B 27            mov b, a
1309   0C5C E4            pop a
1310   0C5D 8A            or a, b
1311   0C5E 27            mov b, a
1312   0C5F E4            pop a
1313   0C60 C0 00 00      cmp b, 0
1314   0C63 C6 7F 0C      je _if22_else
1315   0C66             _if22_true:
1316   0C66 29 F5 11      mov b, [datadr2]
1317   0C69 D7            push a
1318   0C6A 11            mov a, b
1319   0C6B 29 01 12      mov b, [k]
1320   0C6E 54            add a, b
1321   0C6F 27            mov b, a
1322   0C70 E4            pop a
1323   0C71 FD 42 F9 11   mov [pc], b
1324   0C75 26 00 00      mov b, 0
1325   0C78 FD 42 01 12   mov [k], b
1326   0C7C 0A 88 0C      jmp _if22_exit
1327   0C7F             _if22_else:
1328   0C7F 29 F9 11      mov b, [pc]
1329   0C82 FD 77         inc b
1330   0C84 FD 42 F9 11   mov [pc], b
1331   0C88             _if22_exit:
1332   0C88 0A 63 0F      jmp _if20_exit
1333   0C8B             _if20_else:
1334   0C8B             _if23_cond:
1335   0C8B 29 F1 11      mov b, [opr]
1336   0C8E D7            push a
1337   0C8F 11            mov a, b
1338   0C90 26 02 00      mov b, 2
1339   0C93 B0            cmp a, b
1340   0C94 0E            lodflgs
1341   0C95 87 01         and al, %00000001 ; ==
1342   0C97 B9 00         cmp al, 0
1343   0C99 0E            lodflgs
1344   0C9A 96            not al
1345   0C9B 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1346   0C9D 22 00         mov ah, 0
1347   0C9F 27            mov b, a
1348   0CA0 E4            pop a
1349   0CA1 C0 00 00      cmp b, 0
1350   0CA4 C6 E9 0C      je _if23_else
1351   0CA7             _if23_true:
1352   0CA7 29 FB 10      mov b, [datum]
1353   0CAA D7            push a
1354   0CAB 74            mov d, b
1355   0CAC DA            push d
1356   0CAD 29 F3 11      mov b, [datadr1]
1357   0CB0 E7            pop d
1358   0CB1 10 02 00      mov a, 2
1359   0CB4 AC            mul a, b
1360   0CB5 5A            add d, b
1361   0CB6 2A            mov b, [d]
1362   0CB7 E4            pop a
1363   0CB8 FD 42 FB 11   mov [h], b
1364   0CBC 29 FB 10      mov b, [datum]
1365   0CBF D7            push a
1366   0CC0 74            mov d, b
1367   0CC1 DA            push d
1368   0CC2 29 F5 11      mov b, [datadr2]
1369   0CC5 E7            pop d
1370   0CC6 10 02 00      mov a, 2
1371   0CC9 AC            mul a, b
1372   0CCA 5A            add d, b
1373   0CCB 2A            mov b, [d]
1374   0CCC E4            pop a
1375   0CCD FD 42 01 12   mov [k], b
1376   0CD1 29 FB 10      mov b, [datum]
1377   0CD4 D7            push a
1378   0CD5 74            mov d, b
1379   0CD6 DA            push d
1380   0CD7 29 F7 11      mov b, [datadr3]
1381   0CDA E7            pop d
1382   0CDB 10 02 00      mov a, 2
1383   0CDE AC            mul a, b
1384   0CDF 5A            add d, b
1385   0CE0 2A            mov b, [d]
1386   0CE1 E4            pop a
1387   0CE2 FD 42 03 12   mov [l], b
1388   0CE6 0A 63 0F      jmp _if23_exit
1389   0CE9             _if23_else:
1390   0CE9             _if24_cond:
1391   0CE9 29 F1 11      mov b, [opr]
1392   0CEC D7            push a
1393   0CED 11            mov a, b
1394   0CEE 26 05 00      mov b, 5
1395   0CF1 B0            cmp a, b
1396   0CF2 0E            lodflgs
1397   0CF3 87 01         and al, %00000001 ; ==
1398   0CF5 B9 00         cmp al, 0
1399   0CF7 0E            lodflgs
1400   0CF8 96            not al
1401   0CF9 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1402   0CFB 22 00         mov ah, 0
1403   0CFD 27            mov b, a
1404   0CFE E4            pop a
1405   0CFF C0 00 00      cmp b, 0
1406   0D02 C6 25 0D      je _if24_else
1407   0D05             _if24_true:
1408   0D05 29 FB 10      mov b, [datum]
1409   0D08 74            mov d, b
1410   0D09 DA            push d
1411   0D0A 29 F7 11      mov b, [datadr3]
1412   0D0D E7            pop d
1413   0D0E 10 02 00      mov a, 2
1414   0D11 AC            mul a, b
1415   0D12 5A            add d, b
1416   0D13 DA            push d
1417   0D14 29 F5 11      mov b, [datadr2]
1418   0D17 D7            push a
1419   0D18 11            mov a, b
1420   0D19 29 F3 11      mov b, [datadr1]
1421   0D1C 54            add a, b
1422   0D1D 27            mov b, a
1423   0D1E E4            pop a
1424   0D1F E7            pop d
1425   0D20 11            mov a, b
1426   0D21 43            mov [d], a
1427   0D22 0A 63 0F      jmp _if24_exit
1428   0D25             _if24_else:
1429   0D25             _if25_cond:
1430   0D25 29 F1 11      mov b, [opr]
1431   0D28 D7            push a
1432   0D29 11            mov a, b
1433   0D2A 26 06 00      mov b, 6
1434   0D2D B0            cmp a, b
1435   0D2E 0E            lodflgs
1436   0D2F 87 01         and al, %00000001 ; ==
1437   0D31 B9 00         cmp al, 0
1438   0D33 0E            lodflgs
1439   0D34 96            not al
1440   0D35 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1441   0D37 22 00         mov ah, 0
1442   0D39 27            mov b, a
1443   0D3A E4            pop a
1444   0D3B C0 00 00      cmp b, 0
1445   0D3E C6 67 0D      je _if25_else
1446   0D41             _if25_true:
1447   0D41 29 FB 10      mov b, [datum]
1448   0D44 74            mov d, b
1449   0D45 DA            push d
1450   0D46 29 F7 11      mov b, [datadr3]
1451   0D49 E7            pop d
1452   0D4A 10 02 00      mov a, 2
1453   0D4D AC            mul a, b
1454   0D4E 5A            add d, b
1455   0D4F DA            push d
1456   0D50 29 FB 10      mov b, [datum]
1457   0D53 D7            push a
1458   0D54 74            mov d, b
1459   0D55 DA            push d
1460   0D56 29 F5 11      mov b, [datadr2]
1461   0D59 E7            pop d
1462   0D5A 10 02 00      mov a, 2
1463   0D5D AC            mul a, b
1464   0D5E 5A            add d, b
1465   0D5F 2A            mov b, [d]
1466   0D60 E4            pop a
1467   0D61 E7            pop d
1468   0D62 11            mov a, b
1469   0D63 43            mov [d], a
1470   0D64 0A 63 0F      jmp _if25_exit
1471   0D67             _if25_else:
1472   0D67             _if26_cond:
1473   0D67 29 F1 11      mov b, [opr]
1474   0D6A D7            push a
1475   0D6B 11            mov a, b
1476   0D6C 26 08 00      mov b, 8
1477   0D6F B0            cmp a, b
1478   0D70 0E            lodflgs
1479   0D71 87 01         and al, %00000001 ; ==
1480   0D73 B9 00         cmp al, 0
1481   0D75 0E            lodflgs
1482   0D76 96            not al
1483   0D77 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1484   0D79 22 00         mov ah, 0
1485   0D7B 27            mov b, a
1486   0D7C E4            pop a
1487   0D7D C0 00 00      cmp b, 0
1488   0D80 C6 B7 0D      je _if26_else
1489   0D83             _if26_true:
1490   0D83 29 FB 10      mov b, [datum]
1491   0D86 74            mov d, b
1492   0D87 DA            push d
1493   0D88 29 FB 10      mov b, [datum]
1494   0D8B D7            push a
1495   0D8C 74            mov d, b
1496   0D8D DA            push d
1497   0D8E 29 F7 11      mov b, [datadr3]
1498   0D91 E7            pop d
1499   0D92 10 02 00      mov a, 2
1500   0D95 AC            mul a, b
1501   0D96 5A            add d, b
1502   0D97 2A            mov b, [d]
1503   0D98 E4            pop a
1504   0D99 E7            pop d
1505   0D9A 10 02 00      mov a, 2
1506   0D9D AC            mul a, b
1507   0D9E 5A            add d, b
1508   0D9F DA            push d
1509   0DA0 29 FB 10      mov b, [datum]
1510   0DA3 D7            push a
1511   0DA4 74            mov d, b
1512   0DA5 DA            push d
1513   0DA6 29 F5 11      mov b, [datadr2]
1514   0DA9 E7            pop d
1515   0DAA 10 02 00      mov a, 2
1516   0DAD AC            mul a, b
1517   0DAE 5A            add d, b
1518   0DAF 2A            mov b, [d]
1519   0DB0 E4            pop a
1520   0DB1 E7            pop d
1521   0DB2 11            mov a, b
1522   0DB3 43            mov [d], a
1523   0DB4 0A 63 0F      jmp _if26_exit
1524   0DB7             _if26_else:
1525   0DB7             _if27_cond:
1526   0DB7 29 F1 11      mov b, [opr]
1527   0DBA D7            push a
1528   0DBB 11            mov a, b
1529   0DBC 26 09 00      mov b, 9
1530   0DBF B0            cmp a, b
1531   0DC0 0E            lodflgs
1532   0DC1 87 01         and al, %00000001 ; ==
1533   0DC3 B9 00         cmp al, 0
1534   0DC5 0E            lodflgs
1535   0DC6 96            not al
1536   0DC7 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1537   0DC9 22 00         mov ah, 0
1538   0DCB 27            mov b, a
1539   0DCC E4            pop a
1540   0DCD C0 00 00      cmp b, 0
1541   0DD0 C6 0D 0E      je _if27_else
1542   0DD3             _if27_true:
1543   0DD3 29 FB 10      mov b, [datum]
1544   0DD6 74            mov d, b
1545   0DD7 DA            push d
1546   0DD8 29 F7 11      mov b, [datadr3]
1547   0DDB E7            pop d
1548   0DDC 10 02 00      mov a, 2
1549   0DDF AC            mul a, b
1550   0DE0 5A            add d, b
1551   0DE1 DA            push d
1552   0DE2 29 FB 10      mov b, [datum]
1553   0DE5 D7            push a
1554   0DE6 74            mov d, b
1555   0DE7 DA            push d
1556   0DE8 29 F3 11      mov b, [datadr1]
1557   0DEB E7            pop d
1558   0DEC 10 02 00      mov a, 2
1559   0DEF AC            mul a, b
1560   0DF0 5A            add d, b
1561   0DF1 2A            mov b, [d]
1562   0DF2 11            mov a, b
1563   0DF3 29 FB 10      mov b, [datum]
1564   0DF6 D7            push a
1565   0DF7 74            mov d, b
1566   0DF8 DA            push d
1567   0DF9 29 F5 11      mov b, [datadr2]
1568   0DFC E7            pop d
1569   0DFD 10 02 00      mov a, 2
1570   0E00 AC            mul a, b
1571   0E01 5A            add d, b
1572   0E02 2A            mov b, [d]
1573   0E03 E4            pop a
1574   0E04 54            add a, b
1575   0E05 27            mov b, a
1576   0E06 E4            pop a
1577   0E07 E7            pop d
1578   0E08 11            mov a, b
1579   0E09 43            mov [d], a
1580   0E0A 0A 63 0F      jmp _if27_exit
1581   0E0D             _if27_else:
1582   0E0D             _if28_cond:
1583   0E0D 29 F1 11      mov b, [opr]
1584   0E10 D7            push a
1585   0E11 11            mov a, b
1586   0E12 26 0A 00      mov b, 10
1587   0E15 B0            cmp a, b
1588   0E16 0E            lodflgs
1589   0E17 87 01         and al, %00000001 ; ==
1590   0E19 B9 00         cmp al, 0
1591   0E1B 0E            lodflgs
1592   0E1C 96            not al
1593   0E1D 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1594   0E1F 22 00         mov ah, 0
1595   0E21 27            mov b, a
1596   0E22 E4            pop a
1597   0E23 C0 00 00      cmp b, 0
1598   0E26 C6 63 0E      je _if28_else
1599   0E29             _if28_true:
1600   0E29 29 FB 10      mov b, [datum]
1601   0E2C 74            mov d, b
1602   0E2D DA            push d
1603   0E2E 29 F7 11      mov b, [datadr3]
1604   0E31 E7            pop d
1605   0E32 10 02 00      mov a, 2
1606   0E35 AC            mul a, b
1607   0E36 5A            add d, b
1608   0E37 DA            push d
1609   0E38 29 FB 10      mov b, [datum]
1610   0E3B D7            push a
1611   0E3C 74            mov d, b
1612   0E3D DA            push d
1613   0E3E 29 F3 11      mov b, [datadr1]
1614   0E41 E7            pop d
1615   0E42 10 02 00      mov a, 2
1616   0E45 AC            mul a, b
1617   0E46 5A            add d, b
1618   0E47 2A            mov b, [d]
1619   0E48 11            mov a, b
1620   0E49 29 FB 10      mov b, [datum]
1621   0E4C D7            push a
1622   0E4D 74            mov d, b
1623   0E4E DA            push d
1624   0E4F 29 F5 11      mov b, [datadr2]
1625   0E52 E7            pop d
1626   0E53 10 02 00      mov a, 2
1627   0E56 AC            mul a, b
1628   0E57 5A            add d, b
1629   0E58 2A            mov b, [d]
1630   0E59 E4            pop a
1631   0E5A 60            sub a, b
1632   0E5B 27            mov b, a
1633   0E5C E4            pop a
1634   0E5D E7            pop d
1635   0E5E 11            mov a, b
1636   0E5F 43            mov [d], a
1637   0E60 0A 63 0F      jmp _if28_exit
1638   0E63             _if28_else:
1639   0E63             _if29_cond:
1640   0E63 29 F1 11      mov b, [opr]
1641   0E66 D7            push a
1642   0E67 11            mov a, b
1643   0E68 26 0B 00      mov b, 11
1644   0E6B B0            cmp a, b
1645   0E6C 0E            lodflgs
1646   0E6D 87 01         and al, %00000001 ; ==
1647   0E6F B9 00         cmp al, 0
1648   0E71 0E            lodflgs
1649   0E72 96            not al
1650   0E73 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1651   0E75 22 00         mov ah, 0
1652   0E77 27            mov b, a
1653   0E78 E4            pop a
1654   0E79 C0 00 00      cmp b, 0
1655   0E7C C6 C2 0E      je _if29_else
1656   0E7F             _if29_true:
1657   0E7F 29 FB 10      mov b, [datum]
1658   0E82 74            mov d, b
1659   0E83 DA            push d
1660   0E84 29 F7 11      mov b, [datadr3]
1661   0E87 E7            pop d
1662   0E88 10 02 00      mov a, 2
1663   0E8B AC            mul a, b
1664   0E8C 5A            add d, b
1665   0E8D DA            push d
1666   0E8E 29 FB 10      mov b, [datum]
1667   0E91 D7            push a
1668   0E92 74            mov d, b
1669   0E93 DA            push d
1670   0E94 29 F3 11      mov b, [datadr1]
1671   0E97 E7            pop d
1672   0E98 10 02 00      mov a, 2
1673   0E9B AC            mul a, b
1674   0E9C 5A            add d, b
1675   0E9D 2A            mov b, [d]
1676   0E9E 11            mov a, b
1677   0E9F 29 FB 10      mov b, [datum]
1678   0EA2 D7            push a
1679   0EA3 74            mov d, b
1680   0EA4 DA            push d
1681   0EA5 29 F5 11      mov b, [datadr2]
1682   0EA8 E7            pop d
1683   0EA9 10 02 00      mov a, 2
1684   0EAC AC            mul a, b
1685   0EAD 5A            add d, b
1686   0EAE 2A            mov b, [d]
1687   0EAF E4            pop a
1688   0EB0 AC            mul a, b
1689   0EB1 11            mov a, b
1690   0EB2 26 64 00      mov b, 100
1691   0EB5 AE            div a, b
1692   0EB6 FD 78         mov g, a
1693   0EB8 11            mov a, b
1694   0EB9 FD 27         mov b, g
1695   0EBB E4            pop a
1696   0EBC E7            pop d
1697   0EBD 11            mov a, b
1698   0EBE 43            mov [d], a
1699   0EBF 0A 63 0F      jmp _if29_exit
1700   0EC2             _if29_else:
1701   0EC2             _if30_cond:
1702   0EC2 29 F1 11      mov b, [opr]
1703   0EC5 D7            push a
1704   0EC6 11            mov a, b
1705   0EC7 26 0C 00      mov b, 12
1706   0ECA B0            cmp a, b
1707   0ECB 0E            lodflgs
1708   0ECC 87 01         and al, %00000001 ; ==
1709   0ECE B9 00         cmp al, 0
1710   0ED0 0E            lodflgs
1711   0ED1 96            not al
1712   0ED2 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1713   0ED4 22 00         mov ah, 0
1714   0ED6 27            mov b, a
1715   0ED7 E4            pop a
1716   0ED8 C0 00 00      cmp b, 0
1717   0EDB C6 63 0F      je _if30_exit
1718   0EDE             _if30_true:
1719   0EDE             _if31_cond:
1720   0EDE 29 FB 10      mov b, [datum]
1721   0EE1 D7            push a
1722   0EE2 74            mov d, b
1723   0EE3 DA            push d
1724   0EE4 29 F5 11      mov b, [datadr2]
1725   0EE7 E7            pop d
1726   0EE8 10 02 00      mov a, 2
1727   0EEB AC            mul a, b
1728   0EEC 5A            add d, b
1729   0EED 2A            mov b, [d]
1730   0EEE 11            mov a, b
1731   0EEF 26 00 00      mov b, 0
1732   0EF2 B0            cmp a, b
1733   0EF3 0E            lodflgs
1734   0EF4 87 01         and al, %00000001
1735   0EF6 8F 01         xor al, %00000001 ; !=
1736   0EF8 B9 00         cmp al, 0
1737   0EFA 0E            lodflgs
1738   0EFB 96            not al
1739   0EFC 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1740   0EFE 22 00         mov ah, 0
1741   0F00 27            mov b, a
1742   0F01 E4            pop a
1743   0F02 C0 00 00      cmp b, 0
1744   0F05 C6 4B 0F      je _if31_else
1745   0F08             _if31_true:
1746   0F08 29 FB 10      mov b, [datum]
1747   0F0B 74            mov d, b
1748   0F0C DA            push d
1749   0F0D 29 F7 11      mov b, [datadr3]
1750   0F10 E7            pop d
1751   0F11 10 02 00      mov a, 2
1752   0F14 AC            mul a, b
1753   0F15 5A            add d, b
1754   0F16 DA            push d
1755   0F17 29 FB 10      mov b, [datum]
1756   0F1A D7            push a
1757   0F1B 74            mov d, b
1758   0F1C DA            push d
1759   0F1D 29 F3 11      mov b, [datadr1]
1760   0F20 E7            pop d
1761   0F21 10 02 00      mov a, 2
1762   0F24 AC            mul a, b
1763   0F25 5A            add d, b
1764   0F26 2A            mov b, [d]
1765   0F27 11            mov a, b
1766   0F28 26 64 00      mov b, 100
1767   0F2B AC            mul a, b
1768   0F2C 11            mov a, b
1769   0F2D 29 FB 10      mov b, [datum]
1770   0F30 D7            push a
1771   0F31 74            mov d, b
1772   0F32 DA            push d
1773   0F33 29 F5 11      mov b, [datadr2]
1774   0F36 E7            pop d
1775   0F37 10 02 00      mov a, 2
1776   0F3A AC            mul a, b
1777   0F3B 5A            add d, b
1778   0F3C 2A            mov b, [d]
1779   0F3D E4            pop a
1780   0F3E AE            div a, b
1781   0F3F FD 78         mov g, a
1782   0F41 11            mov a, b
1783   0F42 FD 27         mov b, g
1784   0F44 E4            pop a
1785   0F45 E7            pop d
1786   0F46 11            mov a, b
1787   0F47 43            mov [d], a
1788   0F48 0A 60 0F      jmp _if31_exit
1789   0F4B             _if31_else:
1790   0F4B 29 FB 10      mov b, [datum]
1791   0F4E 74            mov d, b
1792   0F4F DA            push d
1793   0F50 29 F7 11      mov b, [datadr3]
1794   0F53 E7            pop d
1795   0F54 10 02 00      mov a, 2
1796   0F57 AC            mul a, b
1797   0F58 5A            add d, b
1798   0F59 DA            push d
1799   0F5A 26 00 00      mov b, 0
1800   0F5D E7            pop d
1801   0F5E 11            mov a, b
1802   0F5F 43            mov [d], a
1803   0F60             _if31_exit:
1804   0F60 0A 63 0F      jmp _if30_exit
1805   0F63             _if30_exit:
1806   0F63             _if29_exit:
1807   0F63             _if28_exit:
1808   0F63             _if27_exit:
1809   0F63             _if26_exit:
1810   0F63             _if25_exit:
1811   0F63             _if24_exit:
1812   0F63             _if23_exit:
1813   0F63             _if20_exit:
1814   0F63             _if19_exit:
1815   0F63             _if32_cond:
1816   0F63 29 F1 11      mov b, [opr]
1817   0F66 D7            push a
1818   0F67 11            mov a, b
1819   0F68 26 01 00      mov b, 1
1820   0F6B B0            cmp a, b
1821   0F6C 0E            lodflgs
1822   0F6D 87 01         and al, %00000001
1823   0F6F 8F 01         xor al, %00000001 ; !=
1824   0F71 B9 00         cmp al, 0
1825   0F73 0E            lodflgs
1826   0F74 96            not al
1827   0F75 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1828   0F77 22 00         mov ah, 0
1829   0F79 27            mov b, a
1830   0F7A E4            pop a
1831   0F7B C0 00 00      cmp b, 0
1832   0F7E C6 D7 0F      je _if32_exit
1833   0F81             _if32_true:
1834   0F81             _if33_cond:
1835   0F81 29 F9 11      mov b, [pc]
1836   0F84 D7            push a
1837   0F85 11            mov a, b
1838   0F86 26 00 00      mov b, 0
1839   0F89 B0            cmp a, b
1840   0F8A 0E            lodflgs
1841   0F8B 87 03         and al, %00000011
1842   0F8D B9 00         cmp al, %00000000
1843   0F8F 0E            lodflgs
1844   0F90 87 01         and al, %00000001 ; >
1845   0F92 B9 00         cmp al, 0
1846   0F94 0E            lodflgs
1847   0F95 96            not al
1848   0F96 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1849   0F98 22 00         mov ah, 0
1850   0F9A 27            mov b, a
1851   0F9B E4            pop a
1852   0F9C C0 00 00      cmp b, 0
1853   0F9F C6 AE 0F      je _if33_else
1854   0FA2             _if33_true:
1855   0FA2 29 F9 11      mov b, [pc]
1856   0FA5 FD 77         inc b
1857   0FA7 FD 42 F9 11   mov [pc], b
1858   0FAB 0A D4 0F      jmp _if33_exit
1859   0FAE             _if33_else:
1860   0FAE             _if34_cond:
1861   0FAE 29 F9 11      mov b, [pc]
1862   0FB1 D7            push a
1863   0FB2 11            mov a, b
1864   0FB3 26 00 00      mov b, 0
1865   0FB6 B0            cmp a, b
1866   0FB7 0E            lodflgs
1867   0FB8 87 01         and al, %00000001 ; ==
1868   0FBA B9 00         cmp al, 0
1869   0FBC 0E            lodflgs
1870   0FBD 96            not al
1871   0FBE 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
1872   0FC0 22 00         mov ah, 0
1873   0FC2 27            mov b, a
1874   0FC3 E4            pop a
1875   0FC4 C0 00 00      cmp b, 0
1876   0FC7 C6 D4 0F      je _if34_exit
1877   0FCA             _if34_true:
1878   0FCA 26 1E 00      mov b, 30
1879   0FCD FD 42 F9 11   mov [pc], b
1880   0FD1 0A D4 0F      jmp _if34_exit
1881   0FD4             _if34_exit:
1882   0FD4             _if33_exit:
1883   0FD4 0A D7 0F      jmp _if32_exit
1884   0FD7             _if32_exit:
1885   0FD7 0A CB 07      jmp _while15_cond
1886   0FDA             _while15_exit:
1887   0FDA 0A DD 0F      jmp _if14_exit
1888   0FDD             _if14_exit:
1889   0FDD 0A 02 04      jmp _while1_cond
1890   0FE0             _while1_exit:
1891   0FE0             readint:
1892   0FE0 D2            push bp
1893   0FE1 9B            mov bp, sp
1894   0FE2 52 02 00      sub sp, 2 ; n
1895   0FE5             
1896   0FE5             ; --- BEGIN INLINE ASM BLOCK
1897   0FE5 07 57 15      call scan_u16d
1898   0FE8 45 FF FF      mov [bp + -1], a
1899   0FEB             ; --- END INLINE ASM BLOCK
1900   0FEB             
1901   0FEB 2C FF FF      mov b, [bp + -1] ; n
1902   0FEE F9            leave
1903   0FEF 09            ret
1904   0FF0             displaynumber:
1905   0FF0 D2            push bp
1906   0FF1 9B            mov bp, sp
1907   0FF2             
1908   0FF2             ; --- BEGIN INLINE ASM BLOCK
1909   0FF2 17 05 00      mov a, [bp + 5]
1910   0FF5 07 82 14      call print_u16d
1911   0FF8 14 03 10      mov a, [ss]
1912   0FFB 3C            mov d, a
1913   0FFC 07 59 14      call puts
1914   0FFF             ; --- END INLINE ASM BLOCK
1915   0FFF             
1916   0FFF F9            leave
1917   1000 09            ret
1918   1001             ; --- END TEXT BLOCK
1919   1001             
1920   1001             ; --- BEGIN DATA BLOCK
1921   1001 0A 00       ss_data: .db "\n", 0
1922   1003 01 10       ss: .dw ss_data
1923   1005 00 00 00 00 datum_data: .fill 246, 0
1923   1009 00 00 00 00 
1923   100D 00 00 00 00 
1923   1011 00 00 00 00 
1923   1015 00 00 00 00 
1923   1019 00 00 00 00 
1923   101D 00 00 00 00 
1923   1021 00 00 00 00 
1923   1025 00 00 00 00 
1923   1029 00 00 00 00 
1923   102D 00 00 00 00 
1923   1031 00 00 00 00 
1923   1035 00 00 00 00 
1923   1039 00 00 00 00 
1923   103D 00 00 00 00 
1923   1041 00 00 00 00 
1923   1045 00 00 00 00 
1923   1049 00 00 00 00 
1923   104D 00 00 00 00 
1923   1051 00 00 00 00 
1923   1055 00 00 00 00 
1923   1059 00 00 00 00 
1923   105D 00 00 00 00 
1923   1061 00 00 00 00 
1923   1065 00 00 00 00 
1923   1069 00 00 00 00 
1923   106D 00 00 00 00 
1923   1071 00 00 00 00 
1923   1075 00 00 00 00 
1923   1079 00 00 00 00 
1923   107D 00 00 00 00 
1923   1081 00 00 00 00 
1923   1085 00 00 00 00 
1923   1089 00 00 00 00 
1923   108D 00 00 00 00 
1923   1091 00 00 00 00 
1923   1095 00 00 00 00 
1923   1099 00 00 00 00 
1923   109D 00 00 00 00 
1923   10A1 00 00 00 00 
1923   10A5 00 00 00 00 
1923   10A9 00 00 00 00 
1923   10AD 00 00 00 00 
1923   10B1 00 00 00 00 
1923   10B5 00 00 00 00 
1923   10B9 00 00 00 00 
1923   10BD 00 00 00 00 
1923   10C1 00 00 00 00 
1923   10C5 00 00 00 00 
1923   10C9 00 00 00 00 
1923   10CD 00 00 00 00 
1923   10D1 00 00 00 00 
1923   10D5 00 00 00 00 
1923   10D9 00 00 00 00 
1923   10DD 00 00 00 00 
1923   10E1 00 00 00 00 
1923   10E5 00 00 00 00 
1923   10E9 00 00 00 00 
1923   10ED 00 00 00 00 
1923   10F1 00 00 00 00 
1923   10F5 00 00 00 00 
1923   10F9 00 00 
1924   10FB 05 10       datum: .dw datum_data
1925   10FD 00 00 00 00 instruction_data: .fill 240, 0
1925   1101 00 00 00 00 
1925   1105 00 00 00 00 
1925   1109 00 00 00 00 
1925   110D 00 00 00 00 
1925   1111 00 00 00 00 
1925   1115 00 00 00 00 
1925   1119 00 00 00 00 
1925   111D 00 00 00 00 
1925   1121 00 00 00 00 
1925   1125 00 00 00 00 
1925   1129 00 00 00 00 
1925   112D 00 00 00 00 
1925   1131 00 00 00 00 
1925   1135 00 00 00 00 
1925   1139 00 00 00 00 
1925   113D 00 00 00 00 
1925   1141 00 00 00 00 
1925   1145 00 00 00 00 
1925   1149 00 00 00 00 
1925   114D 00 00 00 00 
1925   1151 00 00 00 00 
1925   1155 00 00 00 00 
1925   1159 00 00 00 00 
1925   115D 00 00 00 00 
1925   1161 00 00 00 00 
1925   1165 00 00 00 00 
1925   1169 00 00 00 00 
1925   116D 00 00 00 00 
1925   1171 00 00 00 00 
1925   1175 00 00 00 00 
1925   1179 00 00 00 00 
1925   117D 00 00 00 00 
1925   1181 00 00 00 00 
1925   1185 00 00 00 00 
1925   1189 00 00 00 00 
1925   118D 00 00 00 00 
1925   1191 00 00 00 00 
1925   1195 00 00 00 00 
1925   1199 00 00 00 00 
1925   119D 00 00 00 00 
1925   11A1 00 00 00 00 
1925   11A5 00 00 00 00 
1925   11A9 00 00 00 00 
1925   11AD 00 00 00 00 
1925   11B1 00 00 00 00 
1925   11B5 00 00 00 00 
1925   11B9 00 00 00 00 
1925   11BD 00 00 00 00 
1925   11C1 00 00 00 00 
1925   11C5 00 00 00 00 
1925   11C9 00 00 00 00 
1925   11CD 00 00 00 00 
1925   11D1 00 00 00 00 
1925   11D5 00 00 00 00 
1925   11D9 00 00 00 00 
1925   11DD 00 00 00 00 
1925   11E1 00 00 00 00 
1925   11E5 00 00 00 00 
1925   11E9 00 00 00 00 
1926   11ED FD 10       instruction: .dw instruction_data
1927   11EF 00 00       cmdadr: .dw 0
1928   11F1 00 00       opr: .dw 0
1929   11F3 00 00       datadr1: .dw 0
1930   11F5 00 00       datadr2: .dw 0
1931   11F7 00 00       datadr3: .dw 0
1932   11F9 00 00       pc: .dw 0
1933   11FB 00 00       h: .dw 0
1934   11FD 00 00       i: .dw 0
1935   11FF 00 00       j: .dw 0
1936   1201 00 00       k: .dw 0
1937   1203 00 00       l: .dw 0
1938   1205 00 00       p: .dw 0
1939   1207 00 00       runlimit: .dw 0
1940   1209 00 00       exitflag: .dw 0
1941   120B 00 00       exitexec: .dw 0
1942   120D             ; --- END DATA BLOCK
1943   120D             
1944   120D             ; --- BEGIN INCLUDE BLOCK
1945   120D             .include "lib/stdio.asm"
0001+  120D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  120D             ; stdio.s
0003+  120D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  120D             .include "lib/string.asm"
0001++ 120D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 120D             ; string.s
0003++ 120D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 120D             
0005++ 120D             
0006++ 120D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 120D             ; strrev
0008++ 120D             ; reverse a string
0009++ 120D             ; D = string address
0010++ 120D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 120D             ; 01234
0012++ 120D             strrev:
0013++ 120D 4B          	pusha
0014++ 120E 07 54 12    	call strlen	; length in C
0015++ 1211 12          	mov a, c
0016++ 1212 AF 01 00    	cmp a, 1
0017++ 1215 D0 2F 12    	jleu strrev_end	; check string length. string len must be > 1
0018++ 1218 7D          	dec a
0019++ 1219 FD 4E       	mov si, d	; beginning of string
0020++ 121B FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 121D 59          	add d, a	; end of string
0022++ 121E 12          	mov a, c
0023++ 121F FD 9B       	shr a		; divide by 2
0024++ 1221 39          	mov c, a	; C now counts the steps
0025++ 1222             strrev_L0:
0026++ 1222 32          	mov bl, [d]	; save load right-side char into BL
0027++ 1223 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 1224 3E          	mov [d], al	; store left char into right side
0029++ 1225 1B          	mov al, bl
0030++ 1226 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 1227 7E          	dec c
0032++ 1228 7F          	dec d
0033++ 1229 C2 00 00    	cmp c, 0
0034++ 122C C7 22 12    	jne strrev_L0
0035++ 122F             strrev_end:
0036++ 122F 4C          	popa
0037++ 1230 09          	ret
0038++ 1231             	
0039++ 1231             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 1231             ; strchr
0041++ 1231             ; search string in D for char in AL
0042++ 1231             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 1231             strchr:
0044++ 1231             strchr_L0:
0045++ 1231 32          	mov bl, [d]
0046++ 1232 C1 00       	cmp bl, 0
0047++ 1234 C6 3F 12    	je strchr_end
0048++ 1237 BA          	cmp al, bl
0049++ 1238 C6 3F 12    	je strchr_end
0050++ 123B 79          	inc d
0051++ 123C 0A 31 12    	jmp strchr_L0
0052++ 123F             strchr_end:
0053++ 123F 1B          	mov al, bl
0054++ 1240 09          	ret
0055++ 1241             
0056++ 1241             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 1241             ; strstr
0058++ 1241             ; find sub-string
0059++ 1241             ; str1 in SI
0060++ 1241             ; str2 in DI
0061++ 1241             ; SI points to end of source string
0062++ 1241             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 1241             strstr:
0064++ 1241 DB          	push al
0065++ 1242 DA          	push d
0066++ 1243 E3          	push di
0067++ 1244             strstr_loop:
0068++ 1244 F3          	cmpsb					; compare a byte of the strings
0069++ 1245 C7 50 12    	jne strstr_ret
0070++ 1248 FC 00 00    	lea d, [di + 0]
0071++ 124B BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 124D C7 44 12    	jne strstr_loop				; equal chars but not at end
0073++ 1250             strstr_ret:
0074++ 1250 F0          	pop di
0075++ 1251 E7          	pop d
0076++ 1252 E8          	pop al
0077++ 1253 09          	ret
0078++ 1254             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 1254             ; length of null terminated string
0080++ 1254             ; result in C
0081++ 1254             ; pointer in D
0082++ 1254             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 1254             strlen:
0084++ 1254 DA          	push d
0085++ 1255 38 00 00    	mov c, 0
0086++ 1258             strlen_L1:
0087++ 1258 BD 00       	cmp byte [d], 0
0088++ 125A C6 62 12    	je strlen_ret
0089++ 125D 79          	inc d
0090++ 125E 78          	inc c
0091++ 125F 0A 58 12    	jmp strlen_L1
0092++ 1262             strlen_ret:
0093++ 1262 E7          	pop d
0094++ 1263 09          	ret
0095++ 1264             
0096++ 1264             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 1264             ; STRCMP
0098++ 1264             ; compare two strings
0099++ 1264             ; str1 in SI
0100++ 1264             ; str2 in DI
0101++ 1264             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 1264             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 1264             strcmp:
0104++ 1264 DB          	push al
0105++ 1265 DA          	push d
0106++ 1266 E3          	push di
0107++ 1267 E2          	push si
0108++ 1268             strcmp_loop:
0109++ 1268 F3          	cmpsb					; compare a byte of the strings
0110++ 1269 C7 74 12    	jne strcmp_ret
0111++ 126C FB FF FF    	lea d, [si +- 1]
0112++ 126F BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 1271 C7 68 12    	jne strcmp_loop				; equal chars but not at end
0114++ 1274             strcmp_ret:
0115++ 1274 EF          	pop si
0116++ 1275 F0          	pop di
0117++ 1276 E7          	pop d
0118++ 1277 E8          	pop al
0119++ 1278 09          	ret
0120++ 1279             
0121++ 1279             
0122++ 1279             ; STRCPY
0123++ 1279             ; copy null terminated string from SI to DI
0124++ 1279             ; source in SI
0125++ 1279             ; destination in DI
0126++ 1279             strcpy:
0127++ 1279 E2          	push si
0128++ 127A E3          	push di
0129++ 127B DB          	push al
0130++ 127C             strcpy_L1:
0131++ 127C F6          	lodsb
0132++ 127D F7          	stosb
0133++ 127E B9 00       	cmp al, 0
0134++ 1280 C7 7C 12    	jne strcpy_L1
0135++ 1283             strcpy_end:
0136++ 1283 E8          	pop al
0137++ 1284 F0          	pop di
0138++ 1285 EF          	pop si
0139++ 1286 09          	ret
0140++ 1287             
0141++ 1287             ; STRCAT
0142++ 1287             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 1287             ; source in SI
0144++ 1287             ; destination in DI
0145++ 1287             strcat:
0146++ 1287 E2          	push si
0147++ 1288 E3          	push di
0148++ 1289 D7          	push a
0149++ 128A DA          	push d
0150++ 128B 50          	mov a, di
0151++ 128C 3C          	mov d, a
0152++ 128D             strcat_goto_end_L1:
0153++ 128D BD 00       	cmp byte[d], 0
0154++ 128F C6 96 12    	je strcat_start
0155++ 1292 79          	inc d
0156++ 1293 0A 8D 12    	jmp strcat_goto_end_L1
0157++ 1296             strcat_start:
0158++ 1296 FD 50       	mov di, d
0159++ 1298             strcat_L1:
0160++ 1298 F6          	lodsb
0161++ 1299 F7          	stosb
0162++ 129A B9 00       	cmp al, 0
0163++ 129C C7 98 12    	jne strcat_L1
0164++ 129F             strcat_end:
0165++ 129F E7          	pop d
0166++ 12A0 E4          	pop a
0167++ 12A1 F0          	pop di
0168++ 12A2 EF          	pop si
0169++ 12A3 09          	ret
0005+  12A4             
0006+  12A4 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  12A8 34 35 36 37 
0006+  12AC 38 39 41 42 
0006+  12B0 43 44 45 46 
0007+  12B4 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  12B8 1B 5B 48 00 
0008+  12BC             
0009+  12BC 01 00       table_power:.dw 1
0010+  12BE 0A 00       			.dw 10
0011+  12C0 64 00       			.dw 100
0012+  12C2 E8 03       			.dw 1000
0013+  12C4 10 27       			.dw 10000
0014+  12C6             
0015+  12C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  12C6             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  12C6             ; ASCII in BL
0018+  12C6             ; result in AL
0019+  12C6             ; ascii for F = 0100 0110
0020+  12C6             ; ascii for 9 = 0011 1001
0021+  12C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  12C6             hex_ascii_encode:
0023+  12C6 1B          	mov al, bl
0024+  12C7 93 40       	test al, $40				; test if letter or number
0025+  12C9 C7 CF 12    	jnz hex_letter
0026+  12CC 87 0F       	and al, $0F				; get number
0027+  12CE 09          	ret
0028+  12CF             hex_letter:
0029+  12CF 87 0F       	and al, $0F				; get letter
0030+  12D1 6A 09       	add al, 9
0031+  12D3 09          	ret
0032+  12D4             
0033+  12D4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  12D4             ; ATOI
0035+  12D4             ; 2 letter hex string in B
0036+  12D4             ; 8bit integer returned in AL
0037+  12D4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  12D4             atoi:
0039+  12D4 D8          	push b
0040+  12D5 07 C6 12    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  12D8 30          	mov bl, bh
0042+  12D9 DB          	push al					; save a
0043+  12DA 07 C6 12    	call hex_ascii_encode
0044+  12DD EA          	pop bl	
0045+  12DE FD 9E 04    	shl al, 4
0046+  12E1 8C          	or al, bl
0047+  12E2 E5          	pop b
0048+  12E3 09          	ret	
0049+  12E4             
0050+  12E4             
0051+  12E4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  12E4             ; printf
0053+  12E4             ; no need for explanations!
0054+  12E4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  12E4             printf:
0056+  12E4 09          	ret
0057+  12E5             
0058+  12E5             
0059+  12E5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  12E5             ; scanf
0061+  12E5             ; no need for explanations!
0062+  12E5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  12E5             scanf:
0064+  12E5 09          	ret
0065+  12E6             
0066+  12E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  12E6             ; ITOA
0068+  12E6             ; 8bit value in BL
0069+  12E6             ; 2 byte ASCII result in A
0070+  12E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  12E6             itoa:
0072+  12E6 DA          	push d
0073+  12E7 D8          	push b
0074+  12E8 A7 00       	mov bh, 0
0075+  12EA FD A4 04    	shr bl, 4	
0076+  12ED 74          	mov d, b
0077+  12EE 1F A4 12    	mov al, [d + s_hex_digits]
0078+  12F1 23          	mov ah, al
0079+  12F2             	
0080+  12F2 E5          	pop b
0081+  12F3 D8          	push b
0082+  12F4 A7 00       	mov bh, 0
0083+  12F6 FD 87 0F    	and bl, $0F
0084+  12F9 74          	mov d, b
0085+  12FA 1F A4 12    	mov al, [d + s_hex_digits]
0086+  12FD E5          	pop b
0087+  12FE E7          	pop d
0088+  12FF 09          	ret
0089+  1300             
0090+  1300             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  1300             ; HEX STRING TO BINARY
0092+  1300             ; di = destination address
0093+  1300             ; si = source
0094+  1300             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  1300             hex_to_int:
0096+  1300             hex_to_int_L1:
0097+  1300 F6          	lodsb					; load from [SI] to AL
0098+  1301 B9 00       	cmp al, 0				; check if ASCII 0
0099+  1303 C6 10 13    	jz hex_to_int_ret
0100+  1306 36          	mov bh, al
0101+  1307 F6          	lodsb
0102+  1308 2F          	mov bl, al
0103+  1309 07 D4 12    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  130C F7          	stosb					; store AL to [DI]
0105+  130D 0A 00 13    	jmp hex_to_int_L1
0106+  1310             hex_to_int_ret:
0107+  1310 09          	ret		
0108+  1311             
0109+  1311             
0110+  1311             
0111+  1311             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  1311             ; GETCHAR
0113+  1311             ; char in ah
0114+  1311             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  1311             getchar:
0116+  1311 DB          	push al
0117+  1312             getchar_retry:
0118+  1312 FD 0C       	sti
0119+  1314 19 01       	mov al, 1
0120+  1316 05 03       	syscall sys_io			; receive in AH
0121+  1318 B9 00       	cmp al, 0			; check if any char was receive
0122+  131A C6 12 13    	je getchar_retry
0123+  131D E8          	pop al
0124+  131E 09          	ret
0125+  131F             
0126+  131F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  131F             ; PUTCHAR
0128+  131F             ; char in ah
0129+  131F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  131F             putchar:
0131+  131F D7          	push a
0132+  1320 19 00       	mov al, 0
0133+  1322 05 03       	syscall sys_io			; char in AH
0134+  1324 E4          	pop a
0135+  1325 09          	ret
0136+  1326             
0137+  1326             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  1326             ;; INPUT A STRING
0139+  1326             ;; terminates with null
0140+  1326             ;; pointer in D
0141+  1326             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  1326             gets:
0143+  1326 D7          	push a
0144+  1327 DA          	push d
0145+  1328             gets_loop:
0146+  1328 FD 0C       	sti
0147+  132A 19 01       	mov al, 1
0148+  132C 05 03       	syscall sys_io			; receive in AH
0149+  132E B9 00       	cmp al, 0				; check error code (AL)
0150+  1330 C6 28 13    	je gets_loop			; if no char received, retry
0151+  1333             
0152+  1333 76 1B       	cmp ah, 27
0153+  1335 C6 56 13    	je gets_telnet_escape
0154+  1338 76 0A       	cmp ah, $0A				; LF
0155+  133A C6 AF 13    	je gets_end
0156+  133D 76 0D       	cmp ah, $0D				; CR
0157+  133F C6 AF 13    	je gets_end
0158+  1342 76 5C       	cmp ah, $5C				; '\\'
0159+  1344 C6 86 13    	je gets_escape
0160+  1347             	
0161+  1347 76 08       	cmp ah, $08			; check for backspace
0162+  1349 C6 52 13    	je gets_backspace
0163+  134C             
0164+  134C 1A          	mov al, ah
0165+  134D 3E          	mov [d], al
0166+  134E 79          	inc d
0167+  134F 0A 28 13    	jmp gets_loop
0168+  1352             gets_backspace:
0169+  1352 7F          	dec d
0170+  1353 0A 28 13    	jmp gets_loop
0171+  1356             gets_telnet_escape:
0172+  1356 FD 0C       	sti
0173+  1358 19 01       	mov al, 1
0174+  135A 05 03       	syscall sys_io				; receive in AH without echo
0175+  135C B9 00       	cmp al, 0					; check error code (AL)
0176+  135E C6 56 13    	je gets_telnet_escape		; if no char received, retry
0177+  1361 76 5B       	cmp ah, '['
0178+  1363 C7 28 13    	jne gets_loop
0179+  1366             gets_telnet_escape_phase2:
0180+  1366 FD 0C       	sti
0181+  1368 19 01       	mov al, 1
0182+  136A 05 03       	syscall sys_io					; receive in AH without echo
0183+  136C B9 00       	cmp al, 0						; check error code (AL)
0184+  136E C6 66 13    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  1371 76 44       	cmp ah, 'D'
0186+  1373 C6 7E 13    	je gets_left_arrow
0187+  1376 76 43       	cmp ah, 'C'
0188+  1378 C6 82 13    	je gets_right_arrow
0189+  137B 0A 28 13    	jmp gets_loop
0190+  137E             gets_left_arrow:
0191+  137E 7F          	dec d
0192+  137F 0A 28 13    	jmp gets_loop
0193+  1382             gets_right_arrow:
0194+  1382 79          	inc d
0195+  1383 0A 28 13    	jmp gets_loop
0196+  1386             gets_escape:
0197+  1386 FD 0C       	sti
0198+  1388 19 01       	mov al, 1
0199+  138A 05 03       	syscall sys_io			; receive in AH
0200+  138C B9 00       	cmp al, 0				; check error code (AL)
0201+  138E C6 86 13    	je gets_escape			; if no char received, retry
0202+  1391 76 6E       	cmp ah, 'n'
0203+  1393 C6 A1 13    	je gets_LF
0204+  1396 76 72       	cmp ah, 'r'
0205+  1398 C6 A8 13    	je gets_CR
0206+  139B 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  139C 3E          	mov [d], al
0208+  139D 79          	inc d
0209+  139E 0A 28 13    	jmp gets_loop
0210+  13A1             gets_LF:
0211+  13A1 19 0A       	mov al, $0A
0212+  13A3 3E          	mov [d], al
0213+  13A4 79          	inc d
0214+  13A5 0A 28 13    	jmp gets_loop
0215+  13A8             gets_CR:
0216+  13A8 19 0D       	mov al, $0D
0217+  13AA 3E          	mov [d], al
0218+  13AB 79          	inc d
0219+  13AC 0A 28 13    	jmp gets_loop
0220+  13AF             gets_end:
0221+  13AF 19 00       	mov al, 0
0222+  13B1 3E          	mov [d], al				; terminate string
0223+  13B2 E7          	pop d
0224+  13B3 E4          	pop a
0225+  13B4 09          	ret
0226+  13B5             
0227+  13B5             
0228+  13B5             
0229+  13B5             
0230+  13B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  13B5             ;; INPUT TEXT
0232+  13B5             ;; terminated with CTRL+D
0233+  13B5             ;; pointer in D
0234+  13B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  13B5             gettxt:
0236+  13B5 D7          	push a
0237+  13B6 DA          	push d
0238+  13B7             gettxt_loop:
0239+  13B7 19 01       	mov al, 1
0240+  13B9 05 03       	syscall sys_io			; receive in AH
0241+  13BB B9 00       	cmp al, 0				; check error code (AL)
0242+  13BD C6 B7 13    	je gettxt_loop		; if no char received, retry
0243+  13C0 76 04       	cmp ah, 4			; EOT
0244+  13C2 C6 00 14    	je gettxt_end
0245+  13C5 76 08       	cmp ah, $08			; check for backspace
0246+  13C7 C6 FC 13    	je gettxt_backspace
0247+  13CA 76 5C       	cmp ah, $5C				; '\\'
0248+  13CC C6 D5 13    	je gettxt_escape
0249+  13CF 1A          	mov al, ah
0250+  13D0 3E          	mov [d], al
0251+  13D1 79          	inc d
0252+  13D2 0A B7 13    	jmp gettxt_loop
0253+  13D5             gettxt_escape:
0254+  13D5 19 01       	mov al, 1
0255+  13D7 05 03       	syscall sys_io			; receive in AH
0256+  13D9 B9 00       	cmp al, 0				; check error code (AL)
0257+  13DB C6 D5 13    	je gettxt_escape		; if no char received, retry
0258+  13DE 76 6E       	cmp ah, 'n'
0259+  13E0 C6 EE 13    	je gettxt_LF
0260+  13E3 76 72       	cmp ah, 'r'
0261+  13E5 C6 F5 13    	je gettxt_CR
0262+  13E8 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  13E9 3E          	mov [d], al
0264+  13EA 79          	inc d
0265+  13EB 0A B7 13    	jmp gettxt_loop
0266+  13EE             gettxt_LF:
0267+  13EE 19 0A       	mov al, $0A
0268+  13F0 3E          	mov [d], al
0269+  13F1 79          	inc d
0270+  13F2 0A B7 13    	jmp gettxt_loop
0271+  13F5             gettxt_CR:
0272+  13F5 19 0D       	mov al, $0D
0273+  13F7 3E          	mov [d], al
0274+  13F8 79          	inc d
0275+  13F9 0A B7 13    	jmp gettxt_loop
0276+  13FC             gettxt_backspace:
0277+  13FC 7F          	dec d
0278+  13FD 0A B7 13    	jmp gettxt_loop
0279+  1400             gettxt_end:
0280+  1400 19 00       	mov al, 0
0281+  1402 3E          	mov [d], al				; terminate string
0282+  1403 E7          	pop d
0283+  1404 E4          	pop a
0284+  1405 09          	ret
0285+  1406             
0286+  1406             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  1406             ; PRINT NEW LINE
0288+  1406             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  1406             printnl:
0290+  1406 D7          	push a
0291+  1407 10 00 0A    	mov a, $0A00
0292+  140A 05 03       	syscall sys_io
0293+  140C 10 00 0D    	mov a, $0D00
0294+  140F 05 03       	syscall sys_io
0295+  1411 E4          	pop a
0296+  1412 09          	ret
0297+  1413             
0298+  1413             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  1413             ; strtoint
0300+  1413             ; 4 digit hex string number in d
0301+  1413             ; integer returned in A
0302+  1413             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  1413             strtointx:
0304+  1413 D8          	push b
0305+  1414 32          	mov bl, [d]
0306+  1415 37          	mov bh, bl
0307+  1416 33 01 00    	mov bl, [d + 1]
0308+  1419 07 D4 12    	call atoi				; convert to int in AL
0309+  141C 23          	mov ah, al				; move to AH
0310+  141D 33 02 00    	mov bl, [d + 2]
0311+  1420 37          	mov bh, bl
0312+  1421 33 03 00    	mov bl, [d + 3]
0313+  1424 07 D4 12    	call atoi				; convert to int in AL
0314+  1427 E5          	pop b
0315+  1428 09          	ret
0316+  1429             
0317+  1429             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  1429             ; strtoint
0319+  1429             ; 5 digit base10 string number in d
0320+  1429             ; integer returned in A
0321+  1429             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  1429             strtoint:
0323+  1429 E2          	push si
0324+  142A D8          	push b
0325+  142B D9          	push c
0326+  142C DA          	push d
0327+  142D 07 54 12    	call strlen			; get string length in C
0328+  1430 7E          	dec c
0329+  1431 FD 4E       	mov si, d
0330+  1433 12          	mov a, c
0331+  1434 FD 99       	shl a
0332+  1436 3B BC 12    	mov d, table_power
0333+  1439 59          	add d, a
0334+  143A 38 00 00    	mov c, 0
0335+  143D             strtoint_L0:
0336+  143D F6          	lodsb			; load ASCII to al
0337+  143E B9 00       	cmp al, 0
0338+  1440 C6 53 14    	je strtoint_end
0339+  1443 6F 30       	sub al, $30		; make into integer
0340+  1445 22 00       	mov ah, 0
0341+  1447 2A          	mov b, [d]
0342+  1448 AC          	mul a, b			; result in B since it fits in 16bits
0343+  1449 11          	mov a, b
0344+  144A 28          	mov b, c
0345+  144B 54          	add a, b
0346+  144C 39          	mov c, a
0347+  144D 63 02 00    	sub d, 2
0348+  1450 0A 3D 14    	jmp strtoint_L0
0349+  1453             strtoint_end:
0350+  1453 12          	mov a, c
0351+  1454 E7          	pop d
0352+  1455 E6          	pop c
0353+  1456 E5          	pop b
0354+  1457 EF          	pop si
0355+  1458 09          	ret
0356+  1459             
0357+  1459             
0358+  1459             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  1459             ; PRINT NULL TERMINATED STRING
0360+  1459             ; pointer in D
0361+  1459             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  1459             puts:
0363+  1459 D7          	push a
0364+  145A DA          	push d
0365+  145B             puts_L1:
0366+  145B 1E          	mov al, [d]
0367+  145C B9 00       	cmp al, 0
0368+  145E C6 6A 14    	jz puts_END
0369+  1461 23          	mov ah, al
0370+  1462 19 00       	mov al, 0
0371+  1464 05 03       	syscall sys_io
0372+  1466 79          	inc d
0373+  1467 0A 5B 14    	jmp puts_L1
0374+  146A             puts_END:
0375+  146A E7          	pop d
0376+  146B E4          	pop a
0377+  146C 09          	ret
0378+  146D             
0379+  146D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  146D             ; PRINT N SIZE STRING
0381+  146D             ; pointer in D
0382+  146D             ; size in C
0383+  146D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  146D             putsn:
0385+  146D DB          	push al
0386+  146E DA          	push d
0387+  146F D9          	push c
0388+  1470             putsn_L0:
0389+  1470 1E          	mov al, [d]
0390+  1471 23          	mov ah, al
0391+  1472 19 00       	mov al, 0
0392+  1474 05 03       	syscall sys_io
0393+  1476 79          	inc d
0394+  1477 7E          	dec c	
0395+  1478 C2 00 00    	cmp c, 0
0396+  147B C7 70 14    	jne putsn_L0
0397+  147E             putsn_end:
0398+  147E E6          	pop c
0399+  147F E7          	pop d
0400+  1480 E8          	pop al
0401+  1481 09          	ret
0402+  1482             
0403+  1482             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  1482             ; print 16bit decimal number
0405+  1482             ; input number in A
0406+  1482             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  1482             print_u16d:
0408+  1482 D7          	push a
0409+  1483 D8          	push b
0410+  1484 26 10 27    	mov b, 10000
0411+  1487 AE          	div a, b			; get 10000 coeff.
0412+  1488 07 AE 14    	call print_number
0413+  148B 11          	mov a, b
0414+  148C 26 E8 03    	mov b, 1000
0415+  148F AE          	div a, b			; get 10000 coeff.
0416+  1490 07 AE 14    	call print_number
0417+  1493 11          	mov a, b
0418+  1494 26 64 00    	mov b, 100
0419+  1497 AE          	div a, b
0420+  1498 07 AE 14    	call print_number
0421+  149B 11          	mov a, b
0422+  149C 26 0A 00    	mov b, 10
0423+  149F AE          	div a, b
0424+  14A0 07 AE 14    	call print_number
0425+  14A3 11          	mov a, b
0426+  14A4 6A 30       	add al, $30
0427+  14A6 23          	mov ah, al
0428+  14A7 19 00       	mov al, 0
0429+  14A9 05 03       	syscall sys_io	; print coeff
0430+  14AB E5          	pop b
0431+  14AC E4          	pop a
0432+  14AD 09          	ret
0433+  14AE             
0434+  14AE             
0435+  14AE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  14AE             ; if A == 0, print space
0437+  14AE             ; else print A
0438+  14AE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0439+  14AE             print_number:
0440+  14AE 6A 30       	add al, $30
0441+  14B0 23          	mov ah, al
0442+  14B1 07 1F 13    	call putchar
0443+  14B4 09          	ret
0444+  14B5             
0445+  14B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0446+  14B5             ; PRINT 16BIT HEX INTEGER
0447+  14B5             ; integer value in reg B
0448+  14B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  14B5             print_u16x:
0450+  14B5 D7          	push a
0451+  14B6 D8          	push b
0452+  14B7 DD          	push bl
0453+  14B8 30          	mov bl, bh
0454+  14B9 07 E6 12    	call itoa				; convert bh to char in A
0455+  14BC 2F          	mov bl, al				; save al
0456+  14BD 19 00       	mov al, 0
0457+  14BF 05 03       	syscall sys_io				; display AH
0458+  14C1 24          	mov ah, bl				; retrieve al
0459+  14C2 19 00       	mov al, 0
0460+  14C4 05 03       	syscall sys_io				; display AL
0461+  14C6             
0462+  14C6 EA          	pop bl
0463+  14C7 07 E6 12    	call itoa				; convert bh to char in A
0464+  14CA 2F          	mov bl, al				; save al
0465+  14CB 19 00       	mov al, 0
0466+  14CD 05 03       	syscall sys_io				; display AH
0467+  14CF 24          	mov ah, bl				; retrieve al
0468+  14D0 19 00       	mov al, 0
0469+  14D2 05 03       	syscall sys_io				; display AL
0470+  14D4             
0471+  14D4 E5          	pop b
0472+  14D5 E4          	pop a
0473+  14D6 09          	ret
0474+  14D7             
0475+  14D7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  14D7             ; INPUT 16BIT HEX INTEGER
0477+  14D7             ; read 16bit integer into A
0478+  14D7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  14D7             scan_u16x:
0480+  14D7 F8 10 00    	enter 16
0481+  14DA D8          	push b
0482+  14DB DA          	push d
0483+  14DC             
0484+  14DC FA F1 FF    	lea d, [bp + -15]
0485+  14DF 07 26 13    	call gets				; get number
0486+  14E2             
0487+  14E2 32          	mov bl, [d]
0488+  14E3 37          	mov bh, bl
0489+  14E4 33 01 00    	mov bl, [d + 1]
0490+  14E7 07 D4 12    	call atoi				; convert to int in AL
0491+  14EA 23          	mov ah, al				; move to AH
0492+  14EB             
0493+  14EB 33 02 00    	mov bl, [d + 2]
0494+  14EE 37          	mov bh, bl
0495+  14EF 33 03 00    	mov bl, [d + 3]
0496+  14F2 07 D4 12    	call atoi				; convert to int in AL
0497+  14F5             
0498+  14F5 E7          	pop d
0499+  14F6 E5          	pop b
0500+  14F7 F9          	leave
0501+  14F8 09          	ret
0502+  14F9             
0503+  14F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0504+  14F9             ; PRINT 8bit HEX INTEGER
0505+  14F9             ; integer value in reg bl
0506+  14F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  14F9             print_u8x:
0508+  14F9 D7          	push a
0509+  14FA DD          	push bl
0510+  14FB             
0511+  14FB 07 E6 12    	call itoa				; convert bl to char in A
0512+  14FE 2F          	mov bl, al				; save al
0513+  14FF 19 00       	mov al, 0
0514+  1501 05 03       	syscall sys_io				; display AH
0515+  1503 24          	mov ah, bl				; retrieve al
0516+  1504 19 00       	mov al, 0
0517+  1506 05 03       	syscall sys_io				; display AL
0518+  1508             
0519+  1508 EA          	pop bl
0520+  1509 E4          	pop a
0521+  150A 09          	ret
0522+  150B             
0523+  150B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0524+  150B             ; print 8bit decimal unsigned number
0525+  150B             ; input number in AL
0526+  150B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  150B             print_u8d:
0528+  150B D7          	push a
0529+  150C D8          	push b
0530+  150D             
0531+  150D 22 00       	mov ah, 0
0532+  150F 26 64 00    	mov b, 100
0533+  1512 AE          	div a, b
0534+  1513 D8          	push b			; save remainder
0535+  1514 B9 00       	cmp al, 0
0536+  1516 C6 20 15    	je skip100
0537+  1519 6A 30       	add al, $30
0538+  151B 23          	mov ah, al
0539+  151C 19 00       	mov al, 0
0540+  151E 05 03       	syscall sys_io	; print coeff
0541+  1520             skip100:
0542+  1520 E4          	pop a
0543+  1521 22 00       	mov ah, 0
0544+  1523 26 0A 00    	mov b, 10
0545+  1526 AE          	div a, b
0546+  1527 D8          	push b			; save remainder
0547+  1528 B9 00       	cmp al, 0
0548+  152A C6 34 15    	je skip10
0549+  152D 6A 30       	add al, $30
0550+  152F 23          	mov ah, al
0551+  1530 19 00       	mov al, 0
0552+  1532 05 03       	syscall sys_io	; print coeff
0553+  1534             skip10:
0554+  1534 E4          	pop a
0555+  1535 1B          	mov al, bl
0556+  1536 6A 30       	add al, $30
0557+  1538 23          	mov ah, al
0558+  1539 19 00       	mov al, 0
0559+  153B 05 03       	syscall sys_io	; print coeff
0560+  153D E5          	pop b
0561+  153E E4          	pop a
0562+  153F 09          	ret
0563+  1540             
0564+  1540             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0565+  1540             ; INPUT 8BIT HEX INTEGER
0566+  1540             ; read 8bit integer into AL
0567+  1540             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  1540             scan_u8x:
0569+  1540 F8 04 00    	enter 4
0570+  1543 D8          	push b
0571+  1544 DA          	push d
0572+  1545             
0573+  1545 FA FD FF    	lea d, [bp + -3]
0574+  1548 07 26 13    	call gets				; get number
0575+  154B             
0576+  154B 32          	mov bl, [d]
0577+  154C 37          	mov bh, bl
0578+  154D 33 01 00    	mov bl, [d + 1]
0579+  1550 07 D4 12    	call atoi				; convert to int in AL
0580+  1553             
0581+  1553 E7          	pop d
0582+  1554 E5          	pop b
0583+  1555 F9          	leave
0584+  1556 09          	ret
0585+  1557             
0586+  1557             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  1557             ; input decimal number
0588+  1557             ; result in A
0589+  1557             ; 655'\0'
0590+  1557             ; low--------high
0591+  1557             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0592+  1557             scan_u16d:
0593+  1557 F8 08 00    	enter 8
0594+  155A E2          	push si
0595+  155B D8          	push b
0596+  155C D9          	push c
0597+  155D DA          	push d
0598+  155E FA F9 FF    	lea d, [bp +- 7]
0599+  1561 07 26 13    	call gets
0600+  1564 07 54 12    	call strlen			; get string length in C
0601+  1567 7E          	dec c
0602+  1568 FD 4E       	mov si, d
0603+  156A 12          	mov a, c
0604+  156B FD 99       	shl a
0605+  156D 3B BC 12    	mov d, table_power
0606+  1570 59          	add d, a
0607+  1571 38 00 00    	mov c, 0
0608+  1574             mul_loop:
0609+  1574 F6          	lodsb			; load ASCII to al
0610+  1575 B9 00       	cmp al, 0
0611+  1577 C6 8A 15    	je mul_exit
0612+  157A 6F 30       	sub al, $30		; make into integer
0613+  157C 22 00       	mov ah, 0
0614+  157E 2A          	mov b, [d]
0615+  157F AC          	mul a, b			; result in B since it fits in 16bits
0616+  1580 11          	mov a, b
0617+  1581 28          	mov b, c
0618+  1582 54          	add a, b
0619+  1583 39          	mov c, a
0620+  1584 63 02 00    	sub d, 2
0621+  1587 0A 74 15    	jmp mul_loop
0622+  158A             mul_exit:
0623+  158A 12          	mov a, c
0624+  158B E7          	pop d
0625+  158C E6          	pop c
0626+  158D E5          	pop b
0627+  158E EF          	pop si
0628+  158F F9          	leave
0629+  1590 09          	ret
1946   1591             ; --- END INCLUDE BLOCK
1947   1591             
1948   1591             
1949   1591             .end
tasm: Number of errors = 0
