0001   0000             ; --- FILENAME: test.c
0002   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0400             .org PROC_TEXT_ORG
0004   0400             
0005   0400             ; --- BEGIN TEXT BLOCK
0006   0400             
0007   0400             main:
0008   0400 D2            push bp
0009   0401 9B            mov bp, sp
0010   0402 52 02 00      sub sp, 2 ; i
0011   0405 52 02 00      sub sp, 2 ; j
0012   0408 52 14 00      sub sp, 20 ; m
0013   040B             _for1_init:
0014   040B 26 00 00      mov b, 0
0015   040E D7            push a
0016   040F 11            mov a, b
0017   0410 45 FF FF      mov [bp + -1], a ; i
0018   0413 E4            pop a
0019   0414             _for1_cond:
0020   0414 2C FF FF      mov b, [bp + -1] ; i
0021   0417 D7            push a
0022   0418 11            mov a, b
0023   0419 26 14 00      mov b, 20
0024   041C B0            cmp a, b
0025   041D 0E            lodflgs
0026   041E 87 02         and al, %00000010 ; <
0027   0420 FD 9C         shr al
0028   0422 22 00         mov ah, 0
0029   0424 27            mov b, a
0030   0425 E4            pop a
0031   0426 C0 00 00      cmp b, 0
0032   0429 C6 51 04      je _for1_exit
0033   042C             _for1_block:
0034   042C 29 76 05      mov b, [matrix]
0035   042F 74            mov d, b
0036   0430 DA            push d
0037   0431 2C FF FF      mov b, [bp + -1] ; i
0038   0434 E7            pop d
0039   0435 10 02 00      mov a, 2
0040   0438 AC            mul a, b
0041   0439 5A            add d, b
0042   043A DA            push d
0043   043B 2C FF FF      mov b, [bp + -1] ; i
0044   043E E7            pop d
0045   043F 11            mov a, b
0046   0440 43            mov [d], a
0047   0441             _for1_update:
0048   0441 2C FF FF      mov b, [bp + -1] ; i
0049   0444 11            mov a, b
0050   0445 FD 77         inc b
0051   0447 D7            push a
0052   0448 11            mov a, b
0053   0449 45 FF FF      mov [bp + -1], a ; i
0054   044C E4            pop a
0055   044D 27            mov b, a
0056   044E 0A 14 04      jmp _for1_cond
0057   0451             _for1_exit:
0058   0451 26 00 00      mov b, 0
0059   0454 D7            push a
0060   0455 11            mov a, b
0061   0456 45 FD FF      mov [bp + -3], a ; j
0062   0459 E4            pop a
0063   045A FA E9 FF      lea d, [bp + -23] ; m_data
0064   045D 2D            mov b, d
0065   045E 74            mov d, b
0066   045F DA            push d
0067   0460 26 05 00      mov b, 5
0068   0463 E7            pop d
0069   0464 10 02 00      mov a, 2
0070   0467 AC            mul a, b
0071   0468 5A            add d, b
0072   0469 DA            push d
0073   046A 26 01 00      mov b, 1
0074   046D E7            pop d
0075   046E 11            mov a, b
0076   046F 43            mov [d], a
0077   0470 FA E9 FF      lea d, [bp + -23] ; m_data
0078   0473 2D            mov b, d
0079   0474 74            mov d, b
0080   0475 DA            push d
0081   0476 26 06 00      mov b, 6
0082   0479 E7            pop d
0083   047A 10 02 00      mov a, 2
0084   047D AC            mul a, b
0085   047E 5A            add d, b
0086   047F DA            push d
0087   0480 26 01 00      mov b, 1
0088   0483 E7            pop d
0089   0484 11            mov a, b
0090   0485 43            mov [d], a
0091   0486             _for2_init:
0092   0486 26 01 00      mov b, 1
0093   0489 D7            push a
0094   048A 11            mov a, b
0095   048B 45 FF FF      mov [bp + -1], a ; i
0096   048E E4            pop a
0097   048F             _for2_cond:
0098   048F 2C FF FF      mov b, [bp + -1] ; i
0099   0492 D7            push a
0100   0493 11            mov a, b
0101   0494 26 14 00      mov b, 20
0102   0497 B0            cmp a, b
0103   0498 0E            lodflgs
0104   0499 87 03         and al, %00000011 ; <=
0105   049B B9 00         cmp al, 0
0106   049D 0E            lodflgs
0107   049E 8F 01         xor al, %00000001
0108   04A0 22 00         mov ah, 0
0109   04A2 27            mov b, a
0110   04A3 E4            pop a
0111   04A4 C0 00 00      cmp b, 0
0112   04A7 C6 1E 05      je _for2_exit
0113   04AA             _for2_block:
0114   04AA 29 76 05      mov b, [matrix]
0115   04AD D7            push a
0116   04AE 74            mov d, b
0117   04AF DA            push d
0118   04B0 2C FF FF      mov b, [bp + -1] ; i
0119   04B3 D7            push a
0120   04B4 11            mov a, b
0121   04B5 26 01 00      mov b, 1
0122   04B8 60            sub a, b
0123   04B9 27            mov b, a
0124   04BA E4            pop a
0125   04BB D7            push a
0126   04BC 11            mov a, b
0127   04BD 2C FD FF      mov b, [bp + -3] ; j
0128   04C0 54            add a, b
0129   04C1 27            mov b, a
0130   04C2 E4            pop a
0131   04C3 D7            push a
0132   04C4 11            mov a, b
0133   04C5 FA E9 FF      lea d, [bp + -23] ; m_data
0134   04C8 2D            mov b, d
0135   04C9 D7            push a
0136   04CA 74            mov d, b
0137   04CB DA            push d
0138   04CC 26 05 00      mov b, 5
0139   04CF E7            pop d
0140   04D0 10 02 00      mov a, 2
0141   04D3 AC            mul a, b
0142   04D4 5A            add d, b
0143   04D5 2A            mov b, [d]
0144   04D6 E4            pop a
0145   04D7 54            add a, b
0146   04D8 27            mov b, a
0147   04D9 E4            pop a
0148   04DA D7            push a
0149   04DB 11            mov a, b
0150   04DC FA E9 FF      lea d, [bp + -23] ; m_data
0151   04DF 2D            mov b, d
0152   04E0 D7            push a
0153   04E1 74            mov d, b
0154   04E2 DA            push d
0155   04E3 26 06 00      mov b, 6
0156   04E6 E7            pop d
0157   04E7 10 02 00      mov a, 2
0158   04EA AC            mul a, b
0159   04EB 5A            add d, b
0160   04EC 2A            mov b, [d]
0161   04ED E4            pop a
0162   04EE 60            sub a, b
0163   04EF 27            mov b, a
0164   04F0 E4            pop a
0165   04F1 E7            pop d
0166   04F2 10 02 00      mov a, 2
0167   04F5 AC            mul a, b
0168   04F6 5A            add d, b
0169   04F7 2A            mov b, [d]
0170   04F8 E4            pop a
0171   04F9 FD AB         swp b
0172   04FB D8            push b
0173   04FC 07 39 05      call printn
0174   04FF 51 02 00      add sp, 2
0175   0502 26 78 05      mov b, _string_0 ; "\n"
0176   0505 FD AB         swp b
0177   0507 D8            push b
0178   0508 07 43 05      call print
0179   050B 51 02 00      add sp, 2
0180   050E             _for2_update:
0181   050E 2C FF FF      mov b, [bp + -1] ; i
0182   0511 11            mov a, b
0183   0512 FD 77         inc b
0184   0514 D7            push a
0185   0515 11            mov a, b
0186   0516 45 FF FF      mov [bp + -1], a ; i
0187   0519 E4            pop a
0188   051A 27            mov b, a
0189   051B 0A 8F 04      jmp _for2_cond
0190   051E             _for2_exit:
0191   051E F9            leave
0192   051F 05 0B         syscall sys_terminate_proc
0193   0521             
0194   0521             scann:
0195   0521 D2            push bp
0196   0522 9B            mov bp, sp
0197   0523 52 02 00      sub sp, 2 ; m
0198   0526             
0199   0526             ; --- BEGIN INLINE ASM BLOCK
0200   0526 07 C4 08      call scan_u16d
0201   0529 45 FF FF      mov [bp + -1], a
0202   052C             ; --- END INLINE ASM BLOCK
0203   052C             
0204   052C FA 05 00      lea d, [bp + 5] ; n
0205   052F 2A            mov b, [d]
0206   0530 D8            push b
0207   0531 2C FF FF      mov b, [bp + -1] ; m
0208   0534 E7            pop d
0209   0535 11            mov a, b
0210   0536 43            mov [d], a
0211   0537 F9            leave
0212   0538 09            ret
0213   0539             
0214   0539             printn:
0215   0539 D2            push bp
0216   053A 9B            mov bp, sp
0217   053B             
0218   053B             ; --- BEGIN INLINE ASM BLOCK
0219   053B 17 05 00      mov a, [bp + 5]
0220   053E 07 EF 07      call print_u16d
0221   0541             ; --- END INLINE ASM BLOCK
0222   0541             
0223   0541 F9            leave
0224   0542 09            ret
0225   0543             
0226   0543             print:
0227   0543 D2            push bp
0228   0544 9B            mov bp, sp
0229   0545             
0230   0545             ; --- BEGIN INLINE ASM BLOCK
0231   0545 17 05 00      mov a, [bp + 5]
0232   0548 3C            mov d, a
0233   0549 07 C6 07      call puts
0234   054C             ; --- END INLINE ASM BLOCK
0235   054C             
0236   054C F9            leave
0237   054D 09            ret
0238   054E             ; --- END TEXT BLOCK
0239   054E             
0240   054E             ; --- BEGIN DATA BLOCK
0241   054E 00 00 00 00 matrix_data: .fill 40, 0
0241   0552 00 00 00 00 
0241   0556 00 00 00 00 
0241   055A 00 00 00 00 
0241   055E 00 00 00 00 
0241   0562 00 00 00 00 
0241   0566 00 00 00 00 
0241   056A 00 00 00 00 
0241   056E 00 00 00 00 
0241   0572 00 00 00 00 
0242   0576 4E 05       matrix: .dw matrix_data
0243   0578 0A 00       _string_0: .db "\n", 0
0244   057A             ; --- END DATA BLOCK
0245   057A             
0246   057A             ; --- BEGIN INCLUDE BLOCK
0247   057A             .include "lib/stdio.asm"
0001+  057A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  057A             ; stdio.s
0003+  057A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  057A             .include "lib/string.asm"
0001++ 057A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 057A             ; string.s
0003++ 057A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 057A             
0005++ 057A             
0006++ 057A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 057A             ; strrev
0008++ 057A             ; reverse a string
0009++ 057A             ; D = string address
0010++ 057A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 057A             ; 01234
0012++ 057A             strrev:
0013++ 057A 4B          	pusha
0014++ 057B 07 C1 05    	call strlen	; length in C
0015++ 057E 12          	mov a, c
0016++ 057F AF 01 00    	cmp a, 1
0017++ 0582 D0 9C 05    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0585 7D          	dec a
0019++ 0586 FD 4E       	mov si, d	; beginning of string
0020++ 0588 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 058A 59          	add d, a	; end of string
0022++ 058B 12          	mov a, c
0023++ 058C FD 9B       	shr a		; divide by 2
0024++ 058E 39          	mov c, a	; C now counts the steps
0025++ 058F             strrev_L0:
0026++ 058F 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0590 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0591 3E          	mov [d], al	; store left char into right side
0029++ 0592 1B          	mov al, bl
0030++ 0593 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0594 7E          	dec c
0032++ 0595 7F          	dec d
0033++ 0596 C2 00 00    	cmp c, 0
0034++ 0599 C7 8F 05    	jne strrev_L0
0035++ 059C             strrev_end:
0036++ 059C 4C          	popa
0037++ 059D 09          	ret
0038++ 059E             	
0039++ 059E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 059E             ; strchr
0041++ 059E             ; search string in D for char in AL
0042++ 059E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 059E             strchr:
0044++ 059E             strchr_L0:
0045++ 059E 32          	mov bl, [d]
0046++ 059F C1 00       	cmp bl, 0
0047++ 05A1 C6 AC 05    	je strchr_end
0048++ 05A4 BA          	cmp al, bl
0049++ 05A5 C6 AC 05    	je strchr_end
0050++ 05A8 79          	inc d
0051++ 05A9 0A 9E 05    	jmp strchr_L0
0052++ 05AC             strchr_end:
0053++ 05AC 1B          	mov al, bl
0054++ 05AD 09          	ret
0055++ 05AE             
0056++ 05AE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 05AE             ; strstr
0058++ 05AE             ; find sub-string
0059++ 05AE             ; str1 in SI
0060++ 05AE             ; str2 in DI
0061++ 05AE             ; SI points to end of source string
0062++ 05AE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 05AE             strstr:
0064++ 05AE DB          	push al
0065++ 05AF DA          	push d
0066++ 05B0 E3          	push di
0067++ 05B1             strstr_loop:
0068++ 05B1 F3          	cmpsb					; compare a byte of the strings
0069++ 05B2 C7 BD 05    	jne strstr_ret
0070++ 05B5 FC 00 00    	lea d, [di + 0]
0071++ 05B8 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 05BA C7 B1 05    	jne strstr_loop				; equal chars but not at end
0073++ 05BD             strstr_ret:
0074++ 05BD F0          	pop di
0075++ 05BE E7          	pop d
0076++ 05BF E8          	pop al
0077++ 05C0 09          	ret
0078++ 05C1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 05C1             ; length of null terminated string
0080++ 05C1             ; result in C
0081++ 05C1             ; pointer in D
0082++ 05C1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 05C1             strlen:
0084++ 05C1 DA          	push d
0085++ 05C2 38 00 00    	mov c, 0
0086++ 05C5             strlen_L1:
0087++ 05C5 BD 00       	cmp byte [d], 0
0088++ 05C7 C6 CF 05    	je strlen_ret
0089++ 05CA 79          	inc d
0090++ 05CB 78          	inc c
0091++ 05CC 0A C5 05    	jmp strlen_L1
0092++ 05CF             strlen_ret:
0093++ 05CF E7          	pop d
0094++ 05D0 09          	ret
0095++ 05D1             
0096++ 05D1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 05D1             ; STRCMP
0098++ 05D1             ; compare two strings
0099++ 05D1             ; str1 in SI
0100++ 05D1             ; str2 in DI
0101++ 05D1             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 05D1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 05D1             strcmp:
0104++ 05D1 DB          	push al
0105++ 05D2 DA          	push d
0106++ 05D3 E3          	push di
0107++ 05D4 E2          	push si
0108++ 05D5             strcmp_loop:
0109++ 05D5 F3          	cmpsb					; compare a byte of the strings
0110++ 05D6 C7 E1 05    	jne strcmp_ret
0111++ 05D9 FB FF FF    	lea d, [si +- 1]
0112++ 05DC BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 05DE C7 D5 05    	jne strcmp_loop				; equal chars but not at end
0114++ 05E1             strcmp_ret:
0115++ 05E1 EF          	pop si
0116++ 05E2 F0          	pop di
0117++ 05E3 E7          	pop d
0118++ 05E4 E8          	pop al
0119++ 05E5 09          	ret
0120++ 05E6             
0121++ 05E6             
0122++ 05E6             ; STRCPY
0123++ 05E6             ; copy null terminated string from SI to DI
0124++ 05E6             ; source in SI
0125++ 05E6             ; destination in DI
0126++ 05E6             strcpy:
0127++ 05E6 E2          	push si
0128++ 05E7 E3          	push di
0129++ 05E8 DB          	push al
0130++ 05E9             strcpy_L1:
0131++ 05E9 F6          	lodsb
0132++ 05EA F7          	stosb
0133++ 05EB B9 00       	cmp al, 0
0134++ 05ED C7 E9 05    	jne strcpy_L1
0135++ 05F0             strcpy_end:
0136++ 05F0 E8          	pop al
0137++ 05F1 F0          	pop di
0138++ 05F2 EF          	pop si
0139++ 05F3 09          	ret
0140++ 05F4             
0141++ 05F4             ; STRCAT
0142++ 05F4             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 05F4             ; source in SI
0144++ 05F4             ; destination in DI
0145++ 05F4             strcat:
0146++ 05F4 E2          	push si
0147++ 05F5 E3          	push di
0148++ 05F6 D7          	push a
0149++ 05F7 DA          	push d
0150++ 05F8 50          	mov a, di
0151++ 05F9 3C          	mov d, a
0152++ 05FA             strcat_goto_end_L1:
0153++ 05FA BD 00       	cmp byte[d], 0
0154++ 05FC C6 03 06    	je strcat_start
0155++ 05FF 79          	inc d
0156++ 0600 0A FA 05    	jmp strcat_goto_end_L1
0157++ 0603             strcat_start:
0158++ 0603 FD 50       	mov di, d
0159++ 0605             strcat_L1:
0160++ 0605 F6          	lodsb
0161++ 0606 F7          	stosb
0162++ 0607 B9 00       	cmp al, 0
0163++ 0609 C7 05 06    	jne strcat_L1
0164++ 060C             strcat_end:
0165++ 060C E7          	pop d
0166++ 060D E4          	pop a
0167++ 060E F0          	pop di
0168++ 060F EF          	pop si
0169++ 0610 09          	ret
0005+  0611             
0006+  0611 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  0615 34 35 36 37 
0006+  0619 38 39 41 42 
0006+  061D 43 44 45 46 
0007+  0621 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  0625 1B 5B 48 00 
0008+  0629             
0009+  0629 01 00       table_power:.dw 1
0010+  062B 0A 00       			.dw 10
0011+  062D 64 00       			.dw 100
0012+  062F E8 03       			.dw 1000
0013+  0631 10 27       			.dw 10000
0014+  0633             
0015+  0633             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  0633             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  0633             ; ASCII in BL
0018+  0633             ; result in AL
0019+  0633             ; ascii for F = 0100 0110
0020+  0633             ; ascii for 9 = 0011 1001
0021+  0633             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  0633             hex_ascii_encode:
0023+  0633 1B          	mov al, bl
0024+  0634 93 40       	test al, $40				; test if letter or number
0025+  0636 C7 3C 06    	jnz hex_letter
0026+  0639 87 0F       	and al, $0F				; get number
0027+  063B 09          	ret
0028+  063C             hex_letter:
0029+  063C 87 0F       	and al, $0F				; get letter
0030+  063E 6A 09       	add al, 9
0031+  0640 09          	ret
0032+  0641             
0033+  0641             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  0641             ; ATOI
0035+  0641             ; 2 letter hex string in B
0036+  0641             ; 8bit integer returned in AL
0037+  0641             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0641             atoi:
0039+  0641 D8          	push b
0040+  0642 07 33 06    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  0645 30          	mov bl, bh
0042+  0646 DB          	push al					; save a
0043+  0647 07 33 06    	call hex_ascii_encode
0044+  064A EA          	pop bl	
0045+  064B FD 9E 04    	shl al, 4
0046+  064E 8C          	or al, bl
0047+  064F E5          	pop b
0048+  0650 09          	ret	
0049+  0651             
0050+  0651             
0051+  0651             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  0651             ; printf
0053+  0651             ; no need for explanations!
0054+  0651             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0651             printf:
0056+  0651 09          	ret
0057+  0652             
0058+  0652             
0059+  0652             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  0652             ; scanf
0061+  0652             ; no need for explanations!
0062+  0652             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  0652             scanf:
0064+  0652 09          	ret
0065+  0653             
0066+  0653             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  0653             ; ITOA
0068+  0653             ; 8bit value in BL
0069+  0653             ; 2 byte ASCII result in A
0070+  0653             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  0653             itoa:
0072+  0653 DA          	push d
0073+  0654 D8          	push b
0074+  0655 A7 00       	mov bh, 0
0075+  0657 FD A4 04    	shr bl, 4	
0076+  065A 74          	mov d, b
0077+  065B 1F 11 06    	mov al, [d + s_hex_digits]
0078+  065E 23          	mov ah, al
0079+  065F             	
0080+  065F E5          	pop b
0081+  0660 D8          	push b
0082+  0661 A7 00       	mov bh, 0
0083+  0663 FD 87 0F    	and bl, $0F
0084+  0666 74          	mov d, b
0085+  0667 1F 11 06    	mov al, [d + s_hex_digits]
0086+  066A E5          	pop b
0087+  066B E7          	pop d
0088+  066C 09          	ret
0089+  066D             
0090+  066D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  066D             ; HEX STRING TO BINARY
0092+  066D             ; di = destination address
0093+  066D             ; si = source
0094+  066D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  066D             hex_to_int:
0096+  066D             hex_to_int_L1:
0097+  066D F6          	lodsb					; load from [SI] to AL
0098+  066E B9 00       	cmp al, 0				; check if ASCII 0
0099+  0670 C6 7D 06    	jz hex_to_int_ret
0100+  0673 36          	mov bh, al
0101+  0674 F6          	lodsb
0102+  0675 2F          	mov bl, al
0103+  0676 07 41 06    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  0679 F7          	stosb					; store AL to [DI]
0105+  067A 0A 6D 06    	jmp hex_to_int_L1
0106+  067D             hex_to_int_ret:
0107+  067D 09          	ret		
0108+  067E             
0109+  067E             
0110+  067E             
0111+  067E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  067E             ; GETCHAR
0113+  067E             ; char in ah
0114+  067E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  067E             getchar:
0116+  067E DB          	push al
0117+  067F             getchar_retry:
0118+  067F FD 0C       	sti
0119+  0681 19 01       	mov al, 1
0120+  0683 05 03       	syscall sys_io			; receive in AH
0121+  0685 B9 00       	cmp al, 0			; check if any char was receive
0122+  0687 C6 7F 06    	je getchar_retry
0123+  068A E8          	pop al
0124+  068B 09          	ret
0125+  068C             
0126+  068C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  068C             ; PUTCHAR
0128+  068C             ; char in ah
0129+  068C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  068C             putchar:
0131+  068C D7          	push a
0132+  068D 19 00       	mov al, 0
0133+  068F 05 03       	syscall sys_io			; char in AH
0134+  0691 E4          	pop a
0135+  0692 09          	ret
0136+  0693             
0137+  0693             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  0693             ;; INPUT A STRING
0139+  0693             ;; terminates with null
0140+  0693             ;; pointer in D
0141+  0693             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  0693             gets:
0143+  0693 D7          	push a
0144+  0694 DA          	push d
0145+  0695             gets_loop:
0146+  0695 FD 0C       	sti
0147+  0697 19 01       	mov al, 1
0148+  0699 05 03       	syscall sys_io			; receive in AH
0149+  069B B9 00       	cmp al, 0				; check error code (AL)
0150+  069D C6 95 06    	je gets_loop			; if no char received, retry
0151+  06A0             
0152+  06A0 76 1B       	cmp ah, 27
0153+  06A2 C6 C3 06    	je gets_telnet_escape
0154+  06A5 76 0A       	cmp ah, $0A				; LF
0155+  06A7 C6 1C 07    	je gets_end
0156+  06AA 76 0D       	cmp ah, $0D				; CR
0157+  06AC C6 1C 07    	je gets_end
0158+  06AF 76 5C       	cmp ah, $5C				; '\\'
0159+  06B1 C6 F3 06    	je gets_escape
0160+  06B4             	
0161+  06B4 76 08       	cmp ah, $08			; check for backspace
0162+  06B6 C6 BF 06    	je gets_backspace
0163+  06B9             
0164+  06B9 1A          	mov al, ah
0165+  06BA 3E          	mov [d], al
0166+  06BB 79          	inc d
0167+  06BC 0A 95 06    	jmp gets_loop
0168+  06BF             gets_backspace:
0169+  06BF 7F          	dec d
0170+  06C0 0A 95 06    	jmp gets_loop
0171+  06C3             gets_telnet_escape:
0172+  06C3 FD 0C       	sti
0173+  06C5 19 01       	mov al, 1
0174+  06C7 05 03       	syscall sys_io				; receive in AH without echo
0175+  06C9 B9 00       	cmp al, 0					; check error code (AL)
0176+  06CB C6 C3 06    	je gets_telnet_escape		; if no char received, retry
0177+  06CE 76 5B       	cmp ah, '['
0178+  06D0 C7 95 06    	jne gets_loop
0179+  06D3             gets_telnet_escape_phase2:
0180+  06D3 FD 0C       	sti
0181+  06D5 19 01       	mov al, 1
0182+  06D7 05 03       	syscall sys_io					; receive in AH without echo
0183+  06D9 B9 00       	cmp al, 0						; check error code (AL)
0184+  06DB C6 D3 06    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  06DE 76 44       	cmp ah, 'D'
0186+  06E0 C6 EB 06    	je gets_left_arrow
0187+  06E3 76 43       	cmp ah, 'C'
0188+  06E5 C6 EF 06    	je gets_right_arrow
0189+  06E8 0A 95 06    	jmp gets_loop
0190+  06EB             gets_left_arrow:
0191+  06EB 7F          	dec d
0192+  06EC 0A 95 06    	jmp gets_loop
0193+  06EF             gets_right_arrow:
0194+  06EF 79          	inc d
0195+  06F0 0A 95 06    	jmp gets_loop
0196+  06F3             gets_escape:
0197+  06F3 FD 0C       	sti
0198+  06F5 19 01       	mov al, 1
0199+  06F7 05 03       	syscall sys_io			; receive in AH
0200+  06F9 B9 00       	cmp al, 0				; check error code (AL)
0201+  06FB C6 F3 06    	je gets_escape			; if no char received, retry
0202+  06FE 76 6E       	cmp ah, 'n'
0203+  0700 C6 0E 07    	je gets_LF
0204+  0703 76 72       	cmp ah, 'r'
0205+  0705 C6 15 07    	je gets_CR
0206+  0708 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  0709 3E          	mov [d], al
0208+  070A 79          	inc d
0209+  070B 0A 95 06    	jmp gets_loop
0210+  070E             gets_LF:
0211+  070E 19 0A       	mov al, $0A
0212+  0710 3E          	mov [d], al
0213+  0711 79          	inc d
0214+  0712 0A 95 06    	jmp gets_loop
0215+  0715             gets_CR:
0216+  0715 19 0D       	mov al, $0D
0217+  0717 3E          	mov [d], al
0218+  0718 79          	inc d
0219+  0719 0A 95 06    	jmp gets_loop
0220+  071C             gets_end:
0221+  071C 19 00       	mov al, 0
0222+  071E 3E          	mov [d], al				; terminate string
0223+  071F E7          	pop d
0224+  0720 E4          	pop a
0225+  0721 09          	ret
0226+  0722             
0227+  0722             
0228+  0722             
0229+  0722             
0230+  0722             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  0722             ;; INPUT TEXT
0232+  0722             ;; terminated with CTRL+D
0233+  0722             ;; pointer in D
0234+  0722             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  0722             gettxt:
0236+  0722 D7          	push a
0237+  0723 DA          	push d
0238+  0724             gettxt_loop:
0239+  0724 19 01       	mov al, 1
0240+  0726 05 03       	syscall sys_io			; receive in AH
0241+  0728 B9 00       	cmp al, 0				; check error code (AL)
0242+  072A C6 24 07    	je gettxt_loop		; if no char received, retry
0243+  072D 76 04       	cmp ah, 4			; EOT
0244+  072F C6 6D 07    	je gettxt_end
0245+  0732 76 08       	cmp ah, $08			; check for backspace
0246+  0734 C6 69 07    	je gettxt_backspace
0247+  0737 76 5C       	cmp ah, $5C				; '\\'
0248+  0739 C6 42 07    	je gettxt_escape
0249+  073C 1A          	mov al, ah
0250+  073D 3E          	mov [d], al
0251+  073E 79          	inc d
0252+  073F 0A 24 07    	jmp gettxt_loop
0253+  0742             gettxt_escape:
0254+  0742 19 01       	mov al, 1
0255+  0744 05 03       	syscall sys_io			; receive in AH
0256+  0746 B9 00       	cmp al, 0				; check error code (AL)
0257+  0748 C6 42 07    	je gettxt_escape		; if no char received, retry
0258+  074B 76 6E       	cmp ah, 'n'
0259+  074D C6 5B 07    	je gettxt_LF
0260+  0750 76 72       	cmp ah, 'r'
0261+  0752 C6 62 07    	je gettxt_CR
0262+  0755 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  0756 3E          	mov [d], al
0264+  0757 79          	inc d
0265+  0758 0A 24 07    	jmp gettxt_loop
0266+  075B             gettxt_LF:
0267+  075B 19 0A       	mov al, $0A
0268+  075D 3E          	mov [d], al
0269+  075E 79          	inc d
0270+  075F 0A 24 07    	jmp gettxt_loop
0271+  0762             gettxt_CR:
0272+  0762 19 0D       	mov al, $0D
0273+  0764 3E          	mov [d], al
0274+  0765 79          	inc d
0275+  0766 0A 24 07    	jmp gettxt_loop
0276+  0769             gettxt_backspace:
0277+  0769 7F          	dec d
0278+  076A 0A 24 07    	jmp gettxt_loop
0279+  076D             gettxt_end:
0280+  076D 19 00       	mov al, 0
0281+  076F 3E          	mov [d], al				; terminate string
0282+  0770 E7          	pop d
0283+  0771 E4          	pop a
0284+  0772 09          	ret
0285+  0773             
0286+  0773             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  0773             ; PRINT NEW LINE
0288+  0773             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  0773             printnl:
0290+  0773 D7          	push a
0291+  0774 10 00 0A    	mov a, $0A00
0292+  0777 05 03       	syscall sys_io
0293+  0779 10 00 0D    	mov a, $0D00
0294+  077C 05 03       	syscall sys_io
0295+  077E E4          	pop a
0296+  077F 09          	ret
0297+  0780             
0298+  0780             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  0780             ; strtoint
0300+  0780             ; 4 digit hex string number in d
0301+  0780             ; integer returned in A
0302+  0780             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  0780             strtointx:
0304+  0780 D8          	push b
0305+  0781 32          	mov bl, [d]
0306+  0782 37          	mov bh, bl
0307+  0783 33 01 00    	mov bl, [d + 1]
0308+  0786 07 41 06    	call atoi				; convert to int in AL
0309+  0789 23          	mov ah, al				; move to AH
0310+  078A 33 02 00    	mov bl, [d + 2]
0311+  078D 37          	mov bh, bl
0312+  078E 33 03 00    	mov bl, [d + 3]
0313+  0791 07 41 06    	call atoi				; convert to int in AL
0314+  0794 E5          	pop b
0315+  0795 09          	ret
0316+  0796             
0317+  0796             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  0796             ; strtoint
0319+  0796             ; 5 digit base10 string number in d
0320+  0796             ; integer returned in A
0321+  0796             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  0796             strtoint:
0323+  0796 E2          	push si
0324+  0797 D8          	push b
0325+  0798 D9          	push c
0326+  0799 DA          	push d
0327+  079A 07 C1 05    	call strlen			; get string length in C
0328+  079D 7E          	dec c
0329+  079E FD 4E       	mov si, d
0330+  07A0 12          	mov a, c
0331+  07A1 FD 99       	shl a
0332+  07A3 3B 29 06    	mov d, table_power
0333+  07A6 59          	add d, a
0334+  07A7 38 00 00    	mov c, 0
0335+  07AA             strtoint_L0:
0336+  07AA F6          	lodsb			; load ASCII to al
0337+  07AB B9 00       	cmp al, 0
0338+  07AD C6 C0 07    	je strtoint_end
0339+  07B0 6F 30       	sub al, $30		; make into integer
0340+  07B2 22 00       	mov ah, 0
0341+  07B4 2A          	mov b, [d]
0342+  07B5 AC          	mul a, b			; result in B since it fits in 16bits
0343+  07B6 11          	mov a, b
0344+  07B7 28          	mov b, c
0345+  07B8 54          	add a, b
0346+  07B9 39          	mov c, a
0347+  07BA 63 02 00    	sub d, 2
0348+  07BD 0A AA 07    	jmp strtoint_L0
0349+  07C0             strtoint_end:
0350+  07C0 12          	mov a, c
0351+  07C1 E7          	pop d
0352+  07C2 E6          	pop c
0353+  07C3 E5          	pop b
0354+  07C4 EF          	pop si
0355+  07C5 09          	ret
0356+  07C6             
0357+  07C6             
0358+  07C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  07C6             ; PRINT NULL TERMINATED STRING
0360+  07C6             ; pointer in D
0361+  07C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  07C6             puts:
0363+  07C6 D7          	push a
0364+  07C7 DA          	push d
0365+  07C8             puts_L1:
0366+  07C8 1E          	mov al, [d]
0367+  07C9 B9 00       	cmp al, 0
0368+  07CB C6 D7 07    	jz puts_END
0369+  07CE 23          	mov ah, al
0370+  07CF 19 00       	mov al, 0
0371+  07D1 05 03       	syscall sys_io
0372+  07D3 79          	inc d
0373+  07D4 0A C8 07    	jmp puts_L1
0374+  07D7             puts_END:
0375+  07D7 E7          	pop d
0376+  07D8 E4          	pop a
0377+  07D9 09          	ret
0378+  07DA             
0379+  07DA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  07DA             ; PRINT N SIZE STRING
0381+  07DA             ; pointer in D
0382+  07DA             ; size in C
0383+  07DA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  07DA             putsn:
0385+  07DA DB          	push al
0386+  07DB DA          	push d
0387+  07DC D9          	push c
0388+  07DD             putsn_L0:
0389+  07DD 1E          	mov al, [d]
0390+  07DE 23          	mov ah, al
0391+  07DF 19 00       	mov al, 0
0392+  07E1 05 03       	syscall sys_io
0393+  07E3 79          	inc d
0394+  07E4 7E          	dec c	
0395+  07E5 C2 00 00    	cmp c, 0
0396+  07E8 C7 DD 07    	jne putsn_L0
0397+  07EB             putsn_end:
0398+  07EB E6          	pop c
0399+  07EC E7          	pop d
0400+  07ED E8          	pop al
0401+  07EE 09          	ret
0402+  07EF             
0403+  07EF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  07EF             ; print 16bit decimal number
0405+  07EF             ; input number in A
0406+  07EF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  07EF             print_u16d:
0408+  07EF D7          	push a
0409+  07F0 D8          	push b
0410+  07F1 26 10 27    	mov b, 10000
0411+  07F4 AE          	div a, b			; get 10000 coeff.
0412+  07F5 07 1B 08    	call print_number
0413+  07F8 11          	mov a, b
0414+  07F9 26 E8 03    	mov b, 1000
0415+  07FC AE          	div a, b			; get 10000 coeff.
0416+  07FD 07 1B 08    	call print_number
0417+  0800 11          	mov a, b
0418+  0801 26 64 00    	mov b, 100
0419+  0804 AE          	div a, b
0420+  0805 07 1B 08    	call print_number
0421+  0808 11          	mov a, b
0422+  0809 26 0A 00    	mov b, 10
0423+  080C AE          	div a, b
0424+  080D 07 1B 08    	call print_number
0425+  0810 11          	mov a, b
0426+  0811 6A 30       	add al, $30
0427+  0813 23          	mov ah, al
0428+  0814 19 00       	mov al, 0
0429+  0816 05 03       	syscall sys_io	; print coeff
0430+  0818 E5          	pop b
0431+  0819 E4          	pop a
0432+  081A 09          	ret
0433+  081B             
0434+  081B             
0435+  081B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  081B             ; if A == 0, print space
0437+  081B             ; else print A
0438+  081B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0439+  081B             print_number:
0440+  081B 6A 30       	add al, $30
0441+  081D 23          	mov ah, al
0442+  081E 07 8C 06    	call putchar
0443+  0821 09          	ret
0444+  0822             
0445+  0822             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0446+  0822             ; PRINT 16BIT HEX INTEGER
0447+  0822             ; integer value in reg B
0448+  0822             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  0822             print_u16x:
0450+  0822 D7          	push a
0451+  0823 D8          	push b
0452+  0824 DD          	push bl
0453+  0825 30          	mov bl, bh
0454+  0826 07 53 06    	call itoa				; convert bh to char in A
0455+  0829 2F          	mov bl, al				; save al
0456+  082A 19 00       	mov al, 0
0457+  082C 05 03       	syscall sys_io				; display AH
0458+  082E 24          	mov ah, bl				; retrieve al
0459+  082F 19 00       	mov al, 0
0460+  0831 05 03       	syscall sys_io				; display AL
0461+  0833             
0462+  0833 EA          	pop bl
0463+  0834 07 53 06    	call itoa				; convert bh to char in A
0464+  0837 2F          	mov bl, al				; save al
0465+  0838 19 00       	mov al, 0
0466+  083A 05 03       	syscall sys_io				; display AH
0467+  083C 24          	mov ah, bl				; retrieve al
0468+  083D 19 00       	mov al, 0
0469+  083F 05 03       	syscall sys_io				; display AL
0470+  0841             
0471+  0841 E5          	pop b
0472+  0842 E4          	pop a
0473+  0843 09          	ret
0474+  0844             
0475+  0844             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  0844             ; INPUT 16BIT HEX INTEGER
0477+  0844             ; read 16bit integer into A
0478+  0844             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  0844             scan_u16x:
0480+  0844 F8 10 00    	enter 16
0481+  0847 D8          	push b
0482+  0848 DA          	push d
0483+  0849             
0484+  0849 FA F1 FF    	lea d, [bp + -15]
0485+  084C 07 93 06    	call gets				; get number
0486+  084F             
0487+  084F 32          	mov bl, [d]
0488+  0850 37          	mov bh, bl
0489+  0851 33 01 00    	mov bl, [d + 1]
0490+  0854 07 41 06    	call atoi				; convert to int in AL
0491+  0857 23          	mov ah, al				; move to AH
0492+  0858             
0493+  0858 33 02 00    	mov bl, [d + 2]
0494+  085B 37          	mov bh, bl
0495+  085C 33 03 00    	mov bl, [d + 3]
0496+  085F 07 41 06    	call atoi				; convert to int in AL
0497+  0862             
0498+  0862 E7          	pop d
0499+  0863 E5          	pop b
0500+  0864 F9          	leave
0501+  0865 09          	ret
0502+  0866             
0503+  0866             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0504+  0866             ; PRINT 8bit HEX INTEGER
0505+  0866             ; integer value in reg bl
0506+  0866             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  0866             print_u8x:
0508+  0866 D7          	push a
0509+  0867 DD          	push bl
0510+  0868             
0511+  0868 07 53 06    	call itoa				; convert bl to char in A
0512+  086B 2F          	mov bl, al				; save al
0513+  086C 19 00       	mov al, 0
0514+  086E 05 03       	syscall sys_io				; display AH
0515+  0870 24          	mov ah, bl				; retrieve al
0516+  0871 19 00       	mov al, 0
0517+  0873 05 03       	syscall sys_io				; display AL
0518+  0875             
0519+  0875 EA          	pop bl
0520+  0876 E4          	pop a
0521+  0877 09          	ret
0522+  0878             
0523+  0878             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0524+  0878             ; print 8bit decimal unsigned number
0525+  0878             ; input number in AL
0526+  0878             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  0878             print_u8d:
0528+  0878 D7          	push a
0529+  0879 D8          	push b
0530+  087A             
0531+  087A 22 00       	mov ah, 0
0532+  087C 26 64 00    	mov b, 100
0533+  087F AE          	div a, b
0534+  0880 D8          	push b			; save remainder
0535+  0881 B9 00       	cmp al, 0
0536+  0883 C6 8D 08    	je skip100
0537+  0886 6A 30       	add al, $30
0538+  0888 23          	mov ah, al
0539+  0889 19 00       	mov al, 0
0540+  088B 05 03       	syscall sys_io	; print coeff
0541+  088D             skip100:
0542+  088D E4          	pop a
0543+  088E 22 00       	mov ah, 0
0544+  0890 26 0A 00    	mov b, 10
0545+  0893 AE          	div a, b
0546+  0894 D8          	push b			; save remainder
0547+  0895 B9 00       	cmp al, 0
0548+  0897 C6 A1 08    	je skip10
0549+  089A 6A 30       	add al, $30
0550+  089C 23          	mov ah, al
0551+  089D 19 00       	mov al, 0
0552+  089F 05 03       	syscall sys_io	; print coeff
0553+  08A1             skip10:
0554+  08A1 E4          	pop a
0555+  08A2 1B          	mov al, bl
0556+  08A3 6A 30       	add al, $30
0557+  08A5 23          	mov ah, al
0558+  08A6 19 00       	mov al, 0
0559+  08A8 05 03       	syscall sys_io	; print coeff
0560+  08AA E5          	pop b
0561+  08AB E4          	pop a
0562+  08AC 09          	ret
0563+  08AD             
0564+  08AD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0565+  08AD             ; INPUT 8BIT HEX INTEGER
0566+  08AD             ; read 8bit integer into AL
0567+  08AD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  08AD             scan_u8x:
0569+  08AD F8 04 00    	enter 4
0570+  08B0 D8          	push b
0571+  08B1 DA          	push d
0572+  08B2             
0573+  08B2 FA FD FF    	lea d, [bp + -3]
0574+  08B5 07 93 06    	call gets				; get number
0575+  08B8             
0576+  08B8 32          	mov bl, [d]
0577+  08B9 37          	mov bh, bl
0578+  08BA 33 01 00    	mov bl, [d + 1]
0579+  08BD 07 41 06    	call atoi				; convert to int in AL
0580+  08C0             
0581+  08C0 E7          	pop d
0582+  08C1 E5          	pop b
0583+  08C2 F9          	leave
0584+  08C3 09          	ret
0585+  08C4             
0586+  08C4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  08C4             ; input decimal number
0588+  08C4             ; result in A
0589+  08C4             ; 655'\0'
0590+  08C4             ; low--------high
0591+  08C4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0592+  08C4             scan_u16d:
0593+  08C4 F8 08 00    	enter 8
0594+  08C7 E2          	push si
0595+  08C8 D8          	push b
0596+  08C9 D9          	push c
0597+  08CA DA          	push d
0598+  08CB FA F9 FF    	lea d, [bp +- 7]
0599+  08CE 07 93 06    	call gets
0600+  08D1 07 C1 05    	call strlen			; get string length in C
0601+  08D4 7E          	dec c
0602+  08D5 FD 4E       	mov si, d
0603+  08D7 12          	mov a, c
0604+  08D8 FD 99       	shl a
0605+  08DA 3B 29 06    	mov d, table_power
0606+  08DD 59          	add d, a
0607+  08DE 38 00 00    	mov c, 0
0608+  08E1             mul_loop:
0609+  08E1 F6          	lodsb			; load ASCII to al
0610+  08E2 B9 00       	cmp al, 0
0611+  08E4 C6 F7 08    	je mul_exit
0612+  08E7 6F 30       	sub al, $30		; make into integer
0613+  08E9 22 00       	mov ah, 0
0614+  08EB 2A          	mov b, [d]
0615+  08EC AC          	mul a, b			; result in B since it fits in 16bits
0616+  08ED 11          	mov a, b
0617+  08EE 28          	mov b, c
0618+  08EF 54          	add a, b
0619+  08F0 39          	mov c, a
0620+  08F1 63 02 00    	sub d, 2
0621+  08F4 0A E1 08    	jmp mul_loop
0622+  08F7             mul_exit:
0623+  08F7 12          	mov a, c
0624+  08F8 E7          	pop d
0625+  08F9 E6          	pop c
0626+  08FA E5          	pop b
0627+  08FB EF          	pop si
0628+  08FC F9          	leave
0629+  08FD 09          	ret
0248   08FE             ; --- END INCLUDE BLOCK
0249   08FE             
0250   08FE             
0251   08FE             .end
tasm: Number of errors = 0
