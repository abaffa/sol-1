0001   0000             ; --- Filename: pascal.c
0002   0000             
0003   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0004   0000             
0005   0400             .org PROC_TEXT_ORG
0006   0400             
0007   0400             ; --- begin text block
0008   0400             main:
0009   0400 D2          	push bp
0010   0401 9B          	mov bp, sp
0011   0402             ; --- begin inline asm block
0012   0402 3B 48 05      mov d, s_data
0013   0405 07 BF 07      call puts
0014   0408 07 BD 08      call scan_u16d
0015   040B 42 6E 05      mov [rows], a
0016   040E             ; --- end inline asm block
0017   040E             _for1_init:
0018   040E 26 00 00      mov b, 0
0019   0411 FD 42 72 05   mov [i], b
0020   0415             _for1_cond:
0021   0415 29 72 05      mov b, [i]
0022   0418 D7            push a
0023   0419 11            mov a, b
0024   041A 29 6E 05      mov b, [rows]
0025   041D B0            cmp a, b
0026   041E 0E            lodflgs
0027   041F 87 02         and al, %00000010
0028   0421 22 00         mov ah, 0
0029   0423 27            mov b, a
0030   0424 E4            pop a
0031   0425 11            mov a, b
0032   0426 AF 00 00      cmp a, 0
0033   0429 C6 31 05      je _for1_exit
0034   042C             _for1_block:
0035   042C             _for2_init:
0036   042C 26 01 00      mov b, 1
0037   042F FD 42 70 05   mov [space], b
0038   0433             _for2_cond:
0039   0433 29 70 05      mov b, [space]
0040   0436 D7            push a
0041   0437 11            mov a, b
0042   0438 29 6E 05      mov b, [rows]
0043   043B D7            push a
0044   043C 11            mov a, b
0045   043D 29 72 05      mov b, [i]
0046   0440 60            sub a, b
0047   0441 27            mov b, a
0048   0442 E4            pop a
0049   0443 B0            cmp a, b
0050   0444 0E            lodflgs
0051   0445 87 03         and al, %00000011
0052   0447 22 00         mov ah, 0
0053   0449 27            mov b, a
0054   044A E4            pop a
0055   044B 11            mov a, b
0056   044C AF 00 00      cmp a, 0
0057   044F C6 67 04      je _for2_exit
0058   0452             _for2_block:
0059   0452 07 3E 05      call print
0060   0455             _for2_update:
0061   0455 29 70 05      mov b, [space]
0062   0458 D7            push a
0063   0459 11            mov a, b
0064   045A 26 01 00      mov b, 1
0065   045D 54            add a, b
0066   045E 27            mov b, a
0067   045F E4            pop a
0068   0460 FD 42 70 05   mov [space], b
0069   0464 0A 33 04      jmp _for2_cond
0070   0467             _for2_exit:
0071   0467             _for3_init:
0072   0467 26 00 00      mov b, 0
0073   046A FD 42 74 05   mov [j], b
0074   046E             _for3_cond:
0075   046E 29 74 05      mov b, [j]
0076   0471 D7            push a
0077   0472 11            mov a, b
0078   0473 29 72 05      mov b, [i]
0079   0476 B0            cmp a, b
0080   0477 0E            lodflgs
0081   0478 87 03         and al, %00000011
0082   047A 22 00         mov ah, 0
0083   047C 27            mov b, a
0084   047D E4            pop a
0085   047E 11            mov a, b
0086   047F AF 00 00      cmp a, 0
0087   0482 C6 19 05      je _for3_exit
0088   0485             _for3_block:
0089   0485             _if4_cond:
0090   0485 29 74 05      mov b, [j]
0091   0488 D7            push a
0092   0489 11            mov a, b
0093   048A 26 00 00      mov b, 0
0094   048D B0            cmp a, b
0095   048E 0E            lodflgs
0096   048F 87 01         and al, %00000001
0097   0491 22 00         mov ah, 0
0098   0493 27            mov b, a
0099   0494 E4            pop a
0100   0495 D7            push a
0101   0496 11            mov a, b
0102   0497 29 72 05      mov b, [i]
0103   049A D7            push a
0104   049B 11            mov a, b
0105   049C 26 00 00      mov b, 0
0106   049F B0            cmp a, b
0107   04A0 0E            lodflgs
0108   04A1 87 01         and al, %00000001
0109   04A3 22 00         mov ah, 0
0110   04A5 27            mov b, a
0111   04A6 E4            pop a
0112   04A7 C0 00 00      cmp b, 0
0113   04AA D7            push a
0114   04AB 0E            lodflgs
0115   04AC 27            mov b, a
0116   04AD E4            pop a
0117   04AE 98            not bl
0118   04AF FD 87 01      and bl, %00000001
0119   04B2 A7 00         mov bh, 0
0120   04B4 AF 00 00      cmp a, 0
0121   04B7 0E            lodflgs
0122   04B8 96            not al
0123   04B9 87 01         and al, %00000001
0124   04BB 22 00         mov ah, 0
0125   04BD 8A            or a, b
0126   04BE 27            mov b, a
0127   04BF E4            pop a
0128   04C0 C0 00 00      cmp b, 0
0129   04C3 C6 D0 04      je _if4_else_block
0130   04C6             _if4_block:
0131   04C6 26 01 00      mov b, 1
0132   04C9 FD 42 6C 05   mov [coef], b
0133   04CD 0A FA 04      jmp _if4_exit
0134   04D0             _if4_else_block:
0135   04D0 29 6C 05      mov b, [coef]
0136   04D3 D7            push a
0137   04D4 11            mov a, b
0138   04D5 29 72 05      mov b, [i]
0139   04D8 D7            push a
0140   04D9 11            mov a, b
0141   04DA 29 74 05      mov b, [j]
0142   04DD 60            sub a, b
0143   04DE 27            mov b, a
0144   04DF E4            pop a
0145   04E0 D7            push a
0146   04E1 11            mov a, b
0147   04E2 26 01 00      mov b, 1
0148   04E5 54            add a, b
0149   04E6 27            mov b, a
0150   04E7 E4            pop a
0151   04E8 AC            mul a, b
0152   04E9 E4            pop a
0153   04EA D7            push a
0154   04EB 11            mov a, b
0155   04EC 29 74 05      mov b, [j]
0156   04EF AE            div a, b
0157   04F0 FD 78         mov g, a
0158   04F2 11            mov a, b
0159   04F3 FD 27         mov b, g
0160   04F5 E4            pop a
0161   04F6 FD 42 6C 05   mov [coef], b
0162   04FA             _if4_exit:
0163   04FA 07 3E 05      call print
0164   04FD 29 6C 05      mov b, [coef]
0165   0500 D8            push b
0166   0501 07 34 05      call print_nbr
0167   0504 51 02 00      add sp, 2
0168   0507             _for3_update:
0169   0507 29 74 05      mov b, [j]
0170   050A D7            push a
0171   050B 11            mov a, b
0172   050C 26 01 00      mov b, 1
0173   050F 54            add a, b
0174   0510 27            mov b, a
0175   0511 E4            pop a
0176   0512 FD 42 74 05   mov [j], b
0177   0516 0A 6E 04      jmp _for3_cond
0178   0519             _for3_exit:
0179   0519             ; --- begin inline asm block
0180   0519 3B 76 05      mov d, nl_data
0181   051C 07 BF 07      call puts
0182   051F             ; --- end inline asm block
0183   051F             _for1_update:
0184   051F 29 72 05      mov b, [i]
0185   0522 D7            push a
0186   0523 11            mov a, b
0187   0524 26 01 00      mov b, 1
0188   0527 54            add a, b
0189   0528 27            mov b, a
0190   0529 E4            pop a
0191   052A FD 42 72 05   mov [i], b
0192   052E 0A 15 04      jmp _for1_cond
0193   0531             _for1_exit:
0194   0531 F9            leave
0195   0532 05 0B         syscall sys_terminate_proc
0196   0534             print_nbr:
0197   0534 D2          	push bp
0198   0535 9B          	mov bp, sp
0199   0536             ; --- begin inline asm block
0200   0536 17 05 00      mov a, [bp + 5] ; n
0201   0539 07 E8 07      call print_u16d
0202   053C             ; --- end inline asm block
0203   053C F9            leave
0204   053D 09            ret
0205   053E             print:
0206   053E D2          	push bp
0207   053F 9B          	mov bp, sp
0208   0540             ; --- begin inline asm block
0209   0540 3B 65 05      mov d, ss_data
0210   0543 07 BF 07      call puts
0211   0546             ; --- end inline asm block
0212   0546 F9            leave
0213   0547 09            ret
0214   0548             ; --- end text block
0215   0548             
0216   0548             ; --- begin data block
0217   0548 45 6E 74 65 s_data: .db "Enter the number of rows: ", 0
0217   054C 72 20 74 68 
0217   0550 65 20 6E 75 
0217   0554 6D 62 65 72 
0217   0558 20 6F 66 20 
0217   055C 72 6F 77 73 
0217   0560 3A 20 00 
0218   0563 48 05       s: .dw s_data
0219   0565 20 20 20 20 ss_data: .db "    ", 0
0219   0569 00 
0220   056A 65 05       ss: .dw ss_data
0221   056C 01 00       coef: .dw 1
0222   056E 00 00       rows: .dw 0
0223   0570 00 00       space: .dw 0
0224   0572 00 00       i: .dw 0
0225   0574 00 00       j: .dw 0
0226   0576 0A 0D 00    nl_data: .db "\n\r", 0
0227   0579 76 05       nl: .dw nl_data
0228   057B             ; --- end data block
0229   057B             ; --- begin include block
0230   057B             .include "lib/stdio.asm"
0001+  057B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  057B             ; stdio.s
0003+  057B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  057B             .include "lib/string.asm"
0001++ 057B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 057B             ; string.s
0003++ 057B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 057B             
0005++ 057B             
0006++ 057B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 057B             ; strrev
0008++ 057B             ; reverse a string
0009++ 057B             ; D = string address
0010++ 057B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 057B             ; 01234
0012++ 057B             strrev:
0013++ 057B 4B          	pusha
0014++ 057C 07 C2 05    	call strlen	; length in C
0015++ 057F 12          	mov a, c
0016++ 0580 AF 01 00    	cmp a, 1
0017++ 0583 D0 9D 05    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0586 7D          	dec a
0019++ 0587 FD 4E       	mov si, d	; beginning of string
0020++ 0589 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 058B 59          	add d, a	; end of string
0022++ 058C 12          	mov a, c
0023++ 058D FD 9B       	shr a		; divide by 2
0024++ 058F 39          	mov c, a	; C now counts the steps
0025++ 0590             strrev_L0:
0026++ 0590 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0591 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0592 3E          	mov [d], al	; store left char into right side
0029++ 0593 1B          	mov al, bl
0030++ 0594 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0595 7E          	dec c
0032++ 0596 7F          	dec d
0033++ 0597 C2 00 00    	cmp c, 0
0034++ 059A C7 90 05    	jne strrev_L0
0035++ 059D             strrev_end:
0036++ 059D 4C          	popa
0037++ 059E 09          	ret
0038++ 059F             	
0039++ 059F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 059F             ; strchr
0041++ 059F             ; search string in D for char in AL
0042++ 059F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 059F             strchr:
0044++ 059F             strchr_L0:
0045++ 059F 32          	mov bl, [d]
0046++ 05A0 C1 00       	cmp bl, 0
0047++ 05A2 C6 AD 05    	je strchr_end
0048++ 05A5 BA          	cmp al, bl
0049++ 05A6 C6 AD 05    	je strchr_end
0050++ 05A9 79          	inc d
0051++ 05AA 0A 9F 05    	jmp strchr_L0
0052++ 05AD             strchr_end:
0053++ 05AD 1B          	mov al, bl
0054++ 05AE 09          	ret
0055++ 05AF             
0056++ 05AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 05AF             ; strstr
0058++ 05AF             ; find sub-string
0059++ 05AF             ; str1 in SI
0060++ 05AF             ; str2 in DI
0061++ 05AF             ; SI points to end of source string
0062++ 05AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 05AF             strstr:
0064++ 05AF DB          	push al
0065++ 05B0 DA          	push d
0066++ 05B1 E3          	push di
0067++ 05B2             strstr_loop:
0068++ 05B2 F3          	cmpsb					; compare a byte of the strings
0069++ 05B3 C7 BE 05    	jne strstr_ret
0070++ 05B6 FC 00 00    	lea d, [di + 0]
0071++ 05B9 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 05BB C7 B2 05    	jne strstr_loop				; equal chars but not at end
0073++ 05BE             strstr_ret:
0074++ 05BE F0          	pop di
0075++ 05BF E7          	pop d
0076++ 05C0 E8          	pop al
0077++ 05C1 09          	ret
0078++ 05C2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 05C2             ; length of null terminated string
0080++ 05C2             ; result in C
0081++ 05C2             ; pointer in D
0082++ 05C2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 05C2             strlen:
0084++ 05C2 DA          	push d
0085++ 05C3 38 00 00    	mov c, 0
0086++ 05C6             strlen_L1:
0087++ 05C6 BD 00       	cmp byte [d], 0
0088++ 05C8 C6 D0 05    	je strlen_ret
0089++ 05CB 79          	inc d
0090++ 05CC 78          	inc c
0091++ 05CD 0A C6 05    	jmp strlen_L1
0092++ 05D0             strlen_ret:
0093++ 05D0 E7          	pop d
0094++ 05D1 09          	ret
0095++ 05D2             
0096++ 05D2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 05D2             ; STRCMP
0098++ 05D2             ; compare two strings
0099++ 05D2             ; str1 in SI
0100++ 05D2             ; str2 in DI
0101++ 05D2             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 05D2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 05D2             strcmp:
0104++ 05D2 DB          	push al
0105++ 05D3 DA          	push d
0106++ 05D4 E3          	push di
0107++ 05D5 E2          	push si
0108++ 05D6             strcmp_loop:
0109++ 05D6 F3          	cmpsb					; compare a byte of the strings
0110++ 05D7 C7 E2 05    	jne strcmp_ret
0111++ 05DA FB FF FF    	lea d, [si +- 1]
0112++ 05DD BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 05DF C7 D6 05    	jne strcmp_loop				; equal chars but not at end
0114++ 05E2             strcmp_ret:
0115++ 05E2 EF          	pop si
0116++ 05E3 F0          	pop di
0117++ 05E4 E7          	pop d
0118++ 05E5 E8          	pop al
0119++ 05E6 09          	ret
0120++ 05E7             
0121++ 05E7             
0122++ 05E7             ; STRCPY
0123++ 05E7             ; copy null terminated string from SI to DI
0124++ 05E7             ; source in SI
0125++ 05E7             ; destination in DI
0126++ 05E7             strcpy:
0127++ 05E7 E2          	push si
0128++ 05E8 E3          	push di
0129++ 05E9 DB          	push al
0130++ 05EA             strcpy_L1:
0131++ 05EA F6          	lodsb
0132++ 05EB F7          	stosb
0133++ 05EC B9 00       	cmp al, 0
0134++ 05EE C7 EA 05    	jne strcpy_L1
0135++ 05F1             strcpy_end:
0136++ 05F1 E8          	pop al
0137++ 05F2 F0          	pop di
0138++ 05F3 EF          	pop si
0139++ 05F4 09          	ret
0140++ 05F5             
0141++ 05F5             ; STRCAT
0142++ 05F5             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 05F5             ; source in SI
0144++ 05F5             ; destination in DI
0145++ 05F5             strcat:
0146++ 05F5 E2          	push si
0147++ 05F6 E3          	push di
0148++ 05F7 D7          	push a
0149++ 05F8 DA          	push d
0150++ 05F9 50          	mov a, di
0151++ 05FA 3C          	mov d, a
0152++ 05FB             strcat_goto_end_L1:
0153++ 05FB BD 00       	cmp byte[d], 0
0154++ 05FD C6 04 06    	je strcat_start
0155++ 0600 79          	inc d
0156++ 0601 0A FB 05    	jmp strcat_goto_end_L1
0157++ 0604             strcat_start:
0158++ 0604 FD 50       	mov di, d
0159++ 0606             strcat_L1:
0160++ 0606 F6          	lodsb
0161++ 0607 F7          	stosb
0162++ 0608 B9 00       	cmp al, 0
0163++ 060A C7 06 06    	jne strcat_L1
0164++ 060D             strcat_end:
0165++ 060D E7          	pop d
0166++ 060E E4          	pop a
0167++ 060F F0          	pop di
0168++ 0610 EF          	pop si
0169++ 0611 09          	ret
0005+  0612             
0006+  0612 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  0616 34 35 36 37 
0006+  061A 38 39 41 42 
0006+  061E 43 44 45 46 
0007+  0622             
0008+  0622 01 00       table_power:.dw 1
0009+  0624 0A 00       			.dw 10
0010+  0626 64 00       			.dw 100
0011+  0628 E8 03       			.dw 1000
0012+  062A 10 27       			.dw 10000
0013+  062C             
0014+  062C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0015+  062C             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0016+  062C             ; ASCII in BL
0017+  062C             ; result in AL
0018+  062C             ; ascii for F = 0100 0110
0019+  062C             ; ascii for 9 = 0011 1001
0020+  062C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0021+  062C             hex_ascii_encode:
0022+  062C 1B          	mov al, bl
0023+  062D 93 40       	test al, $40				; test if letter or number
0024+  062F C7 35 06    	jnz hex_letter
0025+  0632 87 0F       	and al, $0F				; get number
0026+  0634 09          	ret
0027+  0635             hex_letter:
0028+  0635 87 0F       	and al, $0F				; get letter
0029+  0637 6A 09       	add al, 9
0030+  0639 09          	ret
0031+  063A             
0032+  063A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0033+  063A             ; ATOI
0034+  063A             ; 2 letter hex string in B
0035+  063A             ; 8bit integer returned in AL
0036+  063A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0037+  063A             atoi:
0038+  063A D8          	push b
0039+  063B 07 2C 06    	call hex_ascii_encode			; convert BL to 4bit code in AL
0040+  063E 30          	mov bl, bh
0041+  063F DB          	push al					; save a
0042+  0640 07 2C 06    	call hex_ascii_encode
0043+  0643 EA          	pop bl	
0044+  0644 FD 9E 04    	shl al, 4
0045+  0647 8C          	or al, bl
0046+  0648 E5          	pop b
0047+  0649 09          	ret	
0048+  064A             
0049+  064A             
0050+  064A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  064A             ; printf
0052+  064A             ; no need for explanations!
0053+  064A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0054+  064A             printf:
0055+  064A 09          	ret
0056+  064B             
0057+  064B             
0058+  064B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  064B             ; scanf
0060+  064B             ; no need for explanations!
0061+  064B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  064B             scanf:
0063+  064B 09          	ret
0064+  064C             
0065+  064C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  064C             ; ITOA
0067+  064C             ; 8bit value in BL
0068+  064C             ; 2 byte ASCII result in A
0069+  064C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0070+  064C             itoa:
0071+  064C DA          	push d
0072+  064D D8          	push b
0073+  064E A7 00       	mov bh, 0
0074+  0650 FD A4 04    	shr bl, 4	
0075+  0653 74          	mov d, b
0076+  0654 1F 12 06    	mov al, [d + s_hex_digits]
0077+  0657 23          	mov ah, al
0078+  0658             	
0079+  0658 E5          	pop b
0080+  0659 D8          	push b
0081+  065A A7 00       	mov bh, 0
0082+  065C FD 87 0F    	and bl, $0F
0083+  065F 74          	mov d, b
0084+  0660 1F 12 06    	mov al, [d + s_hex_digits]
0085+  0663 E5          	pop b
0086+  0664 E7          	pop d
0087+  0665 09          	ret
0088+  0666             
0089+  0666             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0090+  0666             ; HEX STRING TO BINARY
0091+  0666             ; di = destination address
0092+  0666             ; si = source
0093+  0666             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0094+  0666             hex_to_int:
0095+  0666             hex_to_int_L1:
0096+  0666 F6          	lodsb					; load from [SI] to AL
0097+  0667 B9 00       	cmp al, 0				; check if ASCII 0
0098+  0669 C6 76 06    	jz hex_to_int_ret
0099+  066C 36          	mov bh, al
0100+  066D F6          	lodsb
0101+  066E 2F          	mov bl, al
0102+  066F 07 3A 06    	call atoi				; convert ASCII byte in B to int (to AL)
0103+  0672 F7          	stosb					; store AL to [DI]
0104+  0673 0A 66 06    	jmp hex_to_int_L1
0105+  0676             hex_to_int_ret:
0106+  0676 09          	ret		
0107+  0677             
0108+  0677             
0109+  0677             
0110+  0677             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  0677             ; GETCHAR
0112+  0677             ; char in ah
0113+  0677             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0114+  0677             getchar:
0115+  0677 DB          	push al
0116+  0678             getchar_retry:
0117+  0678 FD 0C       	sti
0118+  067A 19 01       	mov al, 1
0119+  067C 05 03       	syscall sys_io			; receive in AH
0120+  067E B9 00       	cmp al, 0			; check if any char was receive
0121+  0680 C6 78 06    	je getchar_retry
0122+  0683 E8          	pop al
0123+  0684 09          	ret
0124+  0685             
0125+  0685             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0126+  0685             ; PUTCHAR
0127+  0685             ; char in ah
0128+  0685             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  0685             putchar:
0130+  0685 D7          	push a
0131+  0686 19 00       	mov al, 0
0132+  0688 05 03       	syscall sys_io			; char in AH
0133+  068A E4          	pop a
0134+  068B 09          	ret
0135+  068C             
0136+  068C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0137+  068C             ;; INPUT A STRING
0138+  068C             ;; terminates with null
0139+  068C             ;; pointer in D
0140+  068C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  068C             gets:
0142+  068C D7          	push a
0143+  068D DA          	push d
0144+  068E             gets_loop:
0145+  068E FD 0C       	sti
0146+  0690 19 01       	mov al, 1
0147+  0692 05 03       	syscall sys_io			; receive in AH
0148+  0694 B9 00       	cmp al, 0				; check error code (AL)
0149+  0696 C6 8E 06    	je gets_loop			; if no char received, retry
0150+  0699             
0151+  0699 76 1B       	cmp ah, 27
0152+  069B C6 BC 06    	je gets_telnet_escape
0153+  069E 76 0A       	cmp ah, $0A				; LF
0154+  06A0 C6 15 07    	je gets_end
0155+  06A3 76 0D       	cmp ah, $0D				; CR
0156+  06A5 C6 15 07    	je gets_end
0157+  06A8 76 5C       	cmp ah, $5C				; '\\'
0158+  06AA C6 EC 06    	je gets_escape
0159+  06AD             	
0160+  06AD 76 08       	cmp ah, $08			; check for backspace
0161+  06AF C6 B8 06    	je gets_backspace
0162+  06B2             
0163+  06B2 1A          	mov al, ah
0164+  06B3 3E          	mov [d], al
0165+  06B4 79          	inc d
0166+  06B5 0A 8E 06    	jmp gets_loop
0167+  06B8             gets_backspace:
0168+  06B8 7F          	dec d
0169+  06B9 0A 8E 06    	jmp gets_loop
0170+  06BC             gets_telnet_escape:
0171+  06BC FD 0C       	sti
0172+  06BE 19 01       	mov al, 1
0173+  06C0 05 03       	syscall sys_io				; receive in AH without echo
0174+  06C2 B9 00       	cmp al, 0					; check error code (AL)
0175+  06C4 C6 BC 06    	je gets_telnet_escape		; if no char received, retry
0176+  06C7 76 5B       	cmp ah, '['
0177+  06C9 C7 8E 06    	jne gets_loop
0178+  06CC             gets_telnet_escape_phase2:
0179+  06CC FD 0C       	sti
0180+  06CE 19 01       	mov al, 1
0181+  06D0 05 03       	syscall sys_io					; receive in AH without echo
0182+  06D2 B9 00       	cmp al, 0						; check error code (AL)
0183+  06D4 C6 CC 06    	je gets_telnet_escape_phase2	; if no char received, retry
0184+  06D7 76 44       	cmp ah, 'D'
0185+  06D9 C6 E4 06    	je gets_left_arrow
0186+  06DC 76 43       	cmp ah, 'C'
0187+  06DE C6 E8 06    	je gets_right_arrow
0188+  06E1 0A 8E 06    	jmp gets_loop
0189+  06E4             gets_left_arrow:
0190+  06E4 7F          	dec d
0191+  06E5 0A 8E 06    	jmp gets_loop
0192+  06E8             gets_right_arrow:
0193+  06E8 79          	inc d
0194+  06E9 0A 8E 06    	jmp gets_loop
0195+  06EC             gets_escape:
0196+  06EC FD 0C       	sti
0197+  06EE 19 01       	mov al, 1
0198+  06F0 05 03       	syscall sys_io			; receive in AH
0199+  06F2 B9 00       	cmp al, 0				; check error code (AL)
0200+  06F4 C6 EC 06    	je gets_escape			; if no char received, retry
0201+  06F7 76 6E       	cmp ah, 'n'
0202+  06F9 C6 07 07    	je gets_LF
0203+  06FC 76 72       	cmp ah, 'r'
0204+  06FE C6 0E 07    	je gets_CR
0205+  0701 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0206+  0702 3E          	mov [d], al
0207+  0703 79          	inc d
0208+  0704 0A 8E 06    	jmp gets_loop
0209+  0707             gets_LF:
0210+  0707 19 0A       	mov al, $0A
0211+  0709 3E          	mov [d], al
0212+  070A 79          	inc d
0213+  070B 0A 8E 06    	jmp gets_loop
0214+  070E             gets_CR:
0215+  070E 19 0D       	mov al, $0D
0216+  0710 3E          	mov [d], al
0217+  0711 79          	inc d
0218+  0712 0A 8E 06    	jmp gets_loop
0219+  0715             gets_end:
0220+  0715 19 00       	mov al, 0
0221+  0717 3E          	mov [d], al				; terminate string
0222+  0718 E7          	pop d
0223+  0719 E4          	pop a
0224+  071A 09          	ret
0225+  071B             
0226+  071B             
0227+  071B             
0228+  071B             
0229+  071B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0230+  071B             ;; INPUT TEXT
0231+  071B             ;; terminated with CTRL+D
0232+  071B             ;; pointer in D
0233+  071B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0234+  071B             gettxt:
0235+  071B D7          	push a
0236+  071C DA          	push d
0237+  071D             gettxt_loop:
0238+  071D 19 01       	mov al, 1
0239+  071F 05 03       	syscall sys_io			; receive in AH
0240+  0721 B9 00       	cmp al, 0				; check error code (AL)
0241+  0723 C6 1D 07    	je gettxt_loop		; if no char received, retry
0242+  0726 76 04       	cmp ah, 4			; EOT
0243+  0728 C6 66 07    	je gettxt_end
0244+  072B 76 08       	cmp ah, $08			; check for backspace
0245+  072D C6 62 07    	je gettxt_backspace
0246+  0730 76 5C       	cmp ah, $5C				; '\\'
0247+  0732 C6 3B 07    	je gettxt_escape
0248+  0735 1A          	mov al, ah
0249+  0736 3E          	mov [d], al
0250+  0737 79          	inc d
0251+  0738 0A 1D 07    	jmp gettxt_loop
0252+  073B             gettxt_escape:
0253+  073B 19 01       	mov al, 1
0254+  073D 05 03       	syscall sys_io			; receive in AH
0255+  073F B9 00       	cmp al, 0				; check error code (AL)
0256+  0741 C6 3B 07    	je gettxt_escape		; if no char received, retry
0257+  0744 76 6E       	cmp ah, 'n'
0258+  0746 C6 54 07    	je gettxt_LF
0259+  0749 76 72       	cmp ah, 'r'
0260+  074B C6 5B 07    	je gettxt_CR
0261+  074E 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0262+  074F 3E          	mov [d], al
0263+  0750 79          	inc d
0264+  0751 0A 1D 07    	jmp gettxt_loop
0265+  0754             gettxt_LF:
0266+  0754 19 0A       	mov al, $0A
0267+  0756 3E          	mov [d], al
0268+  0757 79          	inc d
0269+  0758 0A 1D 07    	jmp gettxt_loop
0270+  075B             gettxt_CR:
0271+  075B 19 0D       	mov al, $0D
0272+  075D 3E          	mov [d], al
0273+  075E 79          	inc d
0274+  075F 0A 1D 07    	jmp gettxt_loop
0275+  0762             gettxt_backspace:
0276+  0762 7F          	dec d
0277+  0763 0A 1D 07    	jmp gettxt_loop
0278+  0766             gettxt_end:
0279+  0766 19 00       	mov al, 0
0280+  0768 3E          	mov [d], al				; terminate string
0281+  0769 E7          	pop d
0282+  076A E4          	pop a
0283+  076B 09          	ret
0284+  076C             
0285+  076C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0286+  076C             ; PRINT NEW LINE
0287+  076C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  076C             printnl:
0289+  076C D7          	push a
0290+  076D 10 00 0A    	mov a, $0A00
0291+  0770 05 03       	syscall sys_io
0292+  0772 10 00 0D    	mov a, $0D00
0293+  0775 05 03       	syscall sys_io
0294+  0777 E4          	pop a
0295+  0778 09          	ret
0296+  0779             
0297+  0779             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0298+  0779             ; strtoint
0299+  0779             ; 4 digit hex string number in d
0300+  0779             ; integer returned in A
0301+  0779             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0302+  0779             strtointx:
0303+  0779 D8          	push b
0304+  077A 32          	mov bl, [d]
0305+  077B 37          	mov bh, bl
0306+  077C 33 01 00    	mov bl, [d + 1]
0307+  077F 07 3A 06    	call atoi				; convert to int in AL
0308+  0782 23          	mov ah, al				; move to AH
0309+  0783 33 02 00    	mov bl, [d + 2]
0310+  0786 37          	mov bh, bl
0311+  0787 33 03 00    	mov bl, [d + 3]
0312+  078A 07 3A 06    	call atoi				; convert to int in AL
0313+  078D E5          	pop b
0314+  078E 09          	ret
0315+  078F             
0316+  078F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0317+  078F             ; strtoint
0318+  078F             ; 5 digit base10 string number in d
0319+  078F             ; integer returned in A
0320+  078F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0321+  078F             strtoint:
0322+  078F E2          	push si
0323+  0790 D8          	push b
0324+  0791 D9          	push c
0325+  0792 DA          	push d
0326+  0793 07 C2 05    	call strlen			; get string length in C
0327+  0796 7E          	dec c
0328+  0797 FD 4E       	mov si, d
0329+  0799 12          	mov a, c
0330+  079A FD 99       	shl a
0331+  079C 3B 22 06    	mov d, table_power
0332+  079F 59          	add d, a
0333+  07A0 38 00 00    	mov c, 0
0334+  07A3             strtoint_L0:
0335+  07A3 F6          	lodsb			; load ASCII to al
0336+  07A4 B9 00       	cmp al, 0
0337+  07A6 C6 B9 07    	je strtoint_end
0338+  07A9 6F 30       	sub al, $30		; make into integer
0339+  07AB 22 00       	mov ah, 0
0340+  07AD 2A          	mov b, [d]
0341+  07AE AC          	mul a, b			; result in B since it fits in 16bits
0342+  07AF 11          	mov a, b
0343+  07B0 28          	mov b, c
0344+  07B1 54          	add a, b
0345+  07B2 39          	mov c, a
0346+  07B3 63 02 00    	sub d, 2
0347+  07B6 0A A3 07    	jmp strtoint_L0
0348+  07B9             strtoint_end:
0349+  07B9 12          	mov a, c
0350+  07BA E7          	pop d
0351+  07BB E6          	pop c
0352+  07BC E5          	pop b
0353+  07BD EF          	pop si
0354+  07BE 09          	ret
0355+  07BF             
0356+  07BF             
0357+  07BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0358+  07BF             ; PRINT NULL TERMINATED STRING
0359+  07BF             ; pointer in D
0360+  07BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0361+  07BF             puts:
0362+  07BF D7          	push a
0363+  07C0 DA          	push d
0364+  07C1             puts_L1:
0365+  07C1 1E          	mov al, [d]
0366+  07C2 B9 00       	cmp al, 0
0367+  07C4 C6 D0 07    	jz puts_END
0368+  07C7 23          	mov ah, al
0369+  07C8 19 00       	mov al, 0
0370+  07CA 05 03       	syscall sys_io
0371+  07CC 79          	inc d
0372+  07CD 0A C1 07    	jmp puts_L1
0373+  07D0             puts_END:
0374+  07D0 E7          	pop d
0375+  07D1 E4          	pop a
0376+  07D2 09          	ret
0377+  07D3             
0378+  07D3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  07D3             ; PRINT N SIZE STRING
0380+  07D3             ; pointer in D
0381+  07D3             ; size in C
0382+  07D3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0383+  07D3             putsn:
0384+  07D3 DB          	push al
0385+  07D4 DA          	push d
0386+  07D5 D9          	push c
0387+  07D6             putsn_L0:
0388+  07D6 1E          	mov al, [d]
0389+  07D7 23          	mov ah, al
0390+  07D8 19 00       	mov al, 0
0391+  07DA 05 03       	syscall sys_io
0392+  07DC 79          	inc d
0393+  07DD 7E          	dec c	
0394+  07DE C2 00 00    	cmp c, 0
0395+  07E1 C7 D6 07    	jne putsn_L0
0396+  07E4             putsn_end:
0397+  07E4 E6          	pop c
0398+  07E5 E7          	pop d
0399+  07E6 E8          	pop al
0400+  07E7 09          	ret
0401+  07E8             
0402+  07E8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0403+  07E8             ; print 16bit decimal number
0404+  07E8             ; input number in A
0405+  07E8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  07E8             print_u16d:
0407+  07E8 D7          	push a
0408+  07E9 D8          	push b
0409+  07EA 26 10 27    	mov b, 10000
0410+  07ED AE          	div a, b			; get 10000 coeff.
0411+  07EE 07 14 08    	call print_number
0412+  07F1 11          	mov a, b
0413+  07F2 26 E8 03    	mov b, 1000
0414+  07F5 AE          	div a, b			; get 10000 coeff.
0415+  07F6 07 14 08    	call print_number
0416+  07F9 11          	mov a, b
0417+  07FA 26 64 00    	mov b, 100
0418+  07FD AE          	div a, b
0419+  07FE 07 14 08    	call print_number
0420+  0801 11          	mov a, b
0421+  0802 26 0A 00    	mov b, 10
0422+  0805 AE          	div a, b
0423+  0806 07 14 08    	call print_number
0424+  0809 11          	mov a, b
0425+  080A 6A 30       	add al, $30
0426+  080C 23          	mov ah, al
0427+  080D 19 00       	mov al, 0
0428+  080F 05 03       	syscall sys_io	; print coeff
0429+  0811 E5          	pop b
0430+  0812 E4          	pop a
0431+  0813 09          	ret
0432+  0814             
0433+  0814             
0434+  0814             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0435+  0814             ; if A == 0, print space
0436+  0814             ; else print A
0437+  0814             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0438+  0814             print_number:
0439+  0814 6A 30       	add al, $30
0440+  0816 23          	mov ah, al
0441+  0817 07 85 06    	call putchar
0442+  081A 09          	ret
0443+  081B             
0444+  081B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  081B             ; PRINT 16BIT HEX INTEGER
0446+  081B             ; integer value in reg B
0447+  081B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  081B             print_u16x:
0449+  081B D7          	push a
0450+  081C D8          	push b
0451+  081D DD          	push bl
0452+  081E 30          	mov bl, bh
0453+  081F 07 4C 06    	call itoa				; convert bh to char in A
0454+  0822 2F          	mov bl, al				; save al
0455+  0823 19 00       	mov al, 0
0456+  0825 05 03       	syscall sys_io				; display AH
0457+  0827 24          	mov ah, bl				; retrieve al
0458+  0828 19 00       	mov al, 0
0459+  082A 05 03       	syscall sys_io				; display AL
0460+  082C             
0461+  082C EA          	pop bl
0462+  082D 07 4C 06    	call itoa				; convert bh to char in A
0463+  0830 2F          	mov bl, al				; save al
0464+  0831 19 00       	mov al, 0
0465+  0833 05 03       	syscall sys_io				; display AH
0466+  0835 24          	mov ah, bl				; retrieve al
0467+  0836 19 00       	mov al, 0
0468+  0838 05 03       	syscall sys_io				; display AL
0469+  083A             
0470+  083A E5          	pop b
0471+  083B E4          	pop a
0472+  083C 09          	ret
0473+  083D             
0474+  083D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0475+  083D             ; INPUT 16BIT HEX INTEGER
0476+  083D             ; read 16bit integer into A
0477+  083D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0478+  083D             scan_u16x:
0479+  083D F8 10 00    	enter 16
0480+  0840 D8          	push b
0481+  0841 DA          	push d
0482+  0842             
0483+  0842 FA F1 FF    	lea d, [bp + -15]
0484+  0845 07 8C 06    	call gets				; get number
0485+  0848             
0486+  0848 32          	mov bl, [d]
0487+  0849 37          	mov bh, bl
0488+  084A 33 01 00    	mov bl, [d + 1]
0489+  084D 07 3A 06    	call atoi				; convert to int in AL
0490+  0850 23          	mov ah, al				; move to AH
0491+  0851             
0492+  0851 33 02 00    	mov bl, [d + 2]
0493+  0854 37          	mov bh, bl
0494+  0855 33 03 00    	mov bl, [d + 3]
0495+  0858 07 3A 06    	call atoi				; convert to int in AL
0496+  085B             
0497+  085B E7          	pop d
0498+  085C E5          	pop b
0499+  085D F9          	leave
0500+  085E 09          	ret
0501+  085F             
0502+  085F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0503+  085F             ; PRINT 8bit HEX INTEGER
0504+  085F             ; integer value in reg bl
0505+  085F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0506+  085F             print_u8x:
0507+  085F D7          	push a
0508+  0860 DD          	push bl
0509+  0861             
0510+  0861 07 4C 06    	call itoa				; convert bl to char in A
0511+  0864 2F          	mov bl, al				; save al
0512+  0865 19 00       	mov al, 0
0513+  0867 05 03       	syscall sys_io				; display AH
0514+  0869 24          	mov ah, bl				; retrieve al
0515+  086A 19 00       	mov al, 0
0516+  086C 05 03       	syscall sys_io				; display AL
0517+  086E             
0518+  086E EA          	pop bl
0519+  086F E4          	pop a
0520+  0870 09          	ret
0521+  0871             
0522+  0871             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0523+  0871             ; print 8bit decimal unsigned number
0524+  0871             ; input number in AL
0525+  0871             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0526+  0871             print_u8d:
0527+  0871 D7          	push a
0528+  0872 D8          	push b
0529+  0873             
0530+  0873 22 00       	mov ah, 0
0531+  0875 26 64 00    	mov b, 100
0532+  0878 AE          	div a, b
0533+  0879 D8          	push b			; save remainder
0534+  087A B9 00       	cmp al, 0
0535+  087C C6 86 08    	je skip100
0536+  087F 6A 30       	add al, $30
0537+  0881 23          	mov ah, al
0538+  0882 19 00       	mov al, 0
0539+  0884 05 03       	syscall sys_io	; print coeff
0540+  0886             skip100:
0541+  0886 E4          	pop a
0542+  0887 22 00       	mov ah, 0
0543+  0889 26 0A 00    	mov b, 10
0544+  088C AE          	div a, b
0545+  088D D8          	push b			; save remainder
0546+  088E B9 00       	cmp al, 0
0547+  0890 C6 9A 08    	je skip10
0548+  0893 6A 30       	add al, $30
0549+  0895 23          	mov ah, al
0550+  0896 19 00       	mov al, 0
0551+  0898 05 03       	syscall sys_io	; print coeff
0552+  089A             skip10:
0553+  089A E4          	pop a
0554+  089B 1B          	mov al, bl
0555+  089C 6A 30       	add al, $30
0556+  089E 23          	mov ah, al
0557+  089F 19 00       	mov al, 0
0558+  08A1 05 03       	syscall sys_io	; print coeff
0559+  08A3 E5          	pop b
0560+  08A4 E4          	pop a
0561+  08A5 09          	ret
0562+  08A6             
0563+  08A6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0564+  08A6             ; INPUT 8BIT HEX INTEGER
0565+  08A6             ; read 8bit integer into AL
0566+  08A6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0567+  08A6             scan_u8x:
0568+  08A6 F8 04 00    	enter 4
0569+  08A9 D8          	push b
0570+  08AA DA          	push d
0571+  08AB             
0572+  08AB FA FD FF    	lea d, [bp + -3]
0573+  08AE 07 8C 06    	call gets				; get number
0574+  08B1             
0575+  08B1 32          	mov bl, [d]
0576+  08B2 37          	mov bh, bl
0577+  08B3 33 01 00    	mov bl, [d + 1]
0578+  08B6 07 3A 06    	call atoi				; convert to int in AL
0579+  08B9             
0580+  08B9 E7          	pop d
0581+  08BA E5          	pop b
0582+  08BB F9          	leave
0583+  08BC 09          	ret
0584+  08BD             
0585+  08BD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0586+  08BD             ; input decimal number
0587+  08BD             ; result in A
0588+  08BD             ; 655'\0'
0589+  08BD             ; low--------high
0590+  08BD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0591+  08BD             scan_u16d:
0592+  08BD F8 08 00    	enter 8
0593+  08C0 E2          	push si
0594+  08C1 D8          	push b
0595+  08C2 D9          	push c
0596+  08C3 DA          	push d
0597+  08C4 FA F9 FF    	lea d, [bp +- 7]
0598+  08C7 07 8C 06    	call gets
0599+  08CA 07 C2 05    	call strlen			; get string length in C
0600+  08CD 7E          	dec c
0601+  08CE FD 4E       	mov si, d
0602+  08D0 12          	mov a, c
0603+  08D1 FD 99       	shl a
0604+  08D3 3B 22 06    	mov d, table_power
0605+  08D6 59          	add d, a
0606+  08D7 38 00 00    	mov c, 0
0607+  08DA             mul_loop:
0608+  08DA F6          	lodsb			; load ASCII to al
0609+  08DB B9 00       	cmp al, 0
0610+  08DD C6 F0 08    	je mul_exit
0611+  08E0 6F 30       	sub al, $30		; make into integer
0612+  08E2 22 00       	mov ah, 0
0613+  08E4 2A          	mov b, [d]
0614+  08E5 AC          	mul a, b			; result in B since it fits in 16bits
0615+  08E6 11          	mov a, b
0616+  08E7 28          	mov b, c
0617+  08E8 54          	add a, b
0618+  08E9 39          	mov c, a
0619+  08EA 63 02 00    	sub d, 2
0620+  08ED 0A DA 08    	jmp mul_loop
0621+  08F0             mul_exit:
0622+  08F0 12          	mov a, c
0623+  08F1 E7          	pop d
0624+  08F2 E6          	pop c
0625+  08F3 E5          	pop b
0626+  08F4 EF          	pop si
0627+  08F5 F9          	leave
0628+  08F6 09          	ret
0231   08F7             ; --- end include block
0232   08F7             
0233   08F7             .end
tasm: Number of errors = 0
