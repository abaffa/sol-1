0001   0000             ; --- FILENAME: test.c
0002   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0400             .org PROC_TEXT_ORG
0004   0400             
0005   0400             ; --- BEGIN TEXT BLOCK
0006   0400             main:
0007   0400 D2            push bp
0008   0401 9B            mov bp, sp
0009   0402 52 02 00      sub sp, 2 ; i
0010   0405 52 02 00      sub sp, 2 ; j
0011   0408             _for1_init:
0012   0408 26 00 00      mov b, 0
0013   040B D7            push a
0014   040C 11            mov a, b
0015   040D 45 FF FF      mov [bp + -1], a ; i
0016   0410 E4            pop a
0017   0411             _for1_cond:
0018   0411 2C FF FF      mov b, [bp + -1] ; i
0019   0414 D7            push a
0020   0415 11            mov a, b
0021   0416 26 0A 00      mov b, 10
0022   0419 B0            cmp a, b
0023   041A 0E            lodflgs
0024   041B 87 02         and al, %00000010
0025   041D 22 00         mov ah, 0
0026   041F 27            mov b, a
0027   0420 E4            pop a
0028   0421 C0 00 00      cmp b, 0
0029   0424 C6 85 04      je _for1_exit
0030   0427             _for1_block:
0031   0427             _for2_init:
0032   0427 26 00 00      mov b, 0
0033   042A D7            push a
0034   042B 11            mov a, b
0035   042C 45 FD FF      mov [bp + -3], a ; j
0036   042F E4            pop a
0037   0430             _for2_cond:
0038   0430 2C FD FF      mov b, [bp + -3] ; j
0039   0433 D7            push a
0040   0434 11            mov a, b
0041   0435 26 0A 00      mov b, 10
0042   0438 B0            cmp a, b
0043   0439 0E            lodflgs
0044   043A 87 02         and al, %00000010
0045   043C 22 00         mov ah, 0
0046   043E 27            mov b, a
0047   043F E4            pop a
0048   0440 C0 00 00      cmp b, 0
0049   0443 C6 77 04      je _for2_exit
0050   0446             _for2_block:
0051   0446 26 11 05      mov b, m
0052   0449 74            mov d, b
0053   044A 2C FF FF      mov b, [bp + -1] ; i
0054   044D 10 0A 00      mov a, 10
0055   0450 AC            mul a, b
0056   0451 5A            add d, b
0057   0452 2C FD FF      mov b, [bp + -3] ; j
0058   0455 10 01 00      mov a, 1
0059   0458 AC            mul a, b
0060   0459 5A            add d, b
0061   045A DA            push d
0062   045B 2C FF FF      mov b, [bp + -1] ; i
0063   045E D7            push a
0064   045F 11            mov a, b
0065   0460 2C FD FF      mov b, [bp + -3] ; j
0066   0463 54            add a, b
0067   0464 27            mov b, a
0068   0465 E4            pop a
0069   0466 E7            pop d
0070   0467 1B            mov al, bl
0071   0468 3E            mov [d], al
0072   0469             _for2_update:
0073   0469 2C FD FF      mov b, [bp + -3] ; j
0074   046C FD 77         inc b
0075   046E D7            push a
0076   046F 11            mov a, b
0077   0470 45 FD FF      mov [bp + -3], a ; j
0078   0473 E4            pop a
0079   0474 0A 30 04      jmp _for2_cond
0080   0477             _for2_exit:
0081   0477             _for1_update:
0082   0477 2C FF FF      mov b, [bp + -1] ; i
0083   047A FD 77         inc b
0084   047C D7            push a
0085   047D 11            mov a, b
0086   047E 45 FF FF      mov [bp + -1], a ; i
0087   0481 E4            pop a
0088   0482 0A 11 04      jmp _for1_cond
0089   0485             _for1_exit:
0090   0485             _for3_init:
0091   0485 26 00 00      mov b, 0
0092   0488 D7            push a
0093   0489 11            mov a, b
0094   048A 45 FF FF      mov [bp + -1], a ; i
0095   048D E4            pop a
0096   048E             _for3_cond:
0097   048E 2C FF FF      mov b, [bp + -1] ; i
0098   0491 D7            push a
0099   0492 11            mov a, b
0100   0493 26 0A 00      mov b, 10
0101   0496 B0            cmp a, b
0102   0497 0E            lodflgs
0103   0498 87 02         and al, %00000010
0104   049A 22 00         mov ah, 0
0105   049C 27            mov b, a
0106   049D E4            pop a
0107   049E C0 00 00      cmp b, 0
0108   04A1 C6 FD 04      je _for3_exit
0109   04A4             _for3_block:
0110   04A4             _for4_init:
0111   04A4 26 00 00      mov b, 0
0112   04A7 D7            push a
0113   04A8 11            mov a, b
0114   04A9 45 FD FF      mov [bp + -3], a ; j
0115   04AC E4            pop a
0116   04AD             _for4_cond:
0117   04AD 2C FD FF      mov b, [bp + -3] ; j
0118   04B0 D7            push a
0119   04B1 11            mov a, b
0120   04B2 26 0A 00      mov b, 10
0121   04B5 B0            cmp a, b
0122   04B6 0E            lodflgs
0123   04B7 87 02         and al, %00000010
0124   04B9 22 00         mov ah, 0
0125   04BB 27            mov b, a
0126   04BC E4            pop a
0127   04BD C0 00 00      cmp b, 0
0128   04C0 C6 EF 04      je _for4_exit
0129   04C3             _for4_block:
0130   04C3 26 11 05      mov b, m
0131   04C6 74            mov d, b
0132   04C7 2C FF FF      mov b, [bp + -1] ; i
0133   04CA 10 0A 00      mov a, 10
0134   04CD AC            mul a, b
0135   04CE 5A            add d, b
0136   04CF 2C FD FF      mov b, [bp + -3] ; j
0137   04D2 10 01 00      mov a, 1
0138   04D5 AC            mul a, b
0139   04D6 5A            add d, b
0140   04D7 32            mov bl, [d]
0141   04D8 FD AB         swp b
0142   04DA D8            push b
0143   04DB 07 00 05      call print_nbr
0144   04DE 51 02 00      add sp, 2
0145   04E1             _for4_update:
0146   04E1 2C FD FF      mov b, [bp + -3] ; j
0147   04E4 FD 77         inc b
0148   04E6 D7            push a
0149   04E7 11            mov a, b
0150   04E8 45 FD FF      mov [bp + -3], a ; j
0151   04EB E4            pop a
0152   04EC 0A AD 04      jmp _for4_cond
0153   04EF             _for4_exit:
0154   04EF             _for3_update:
0155   04EF 2C FF FF      mov b, [bp + -1] ; i
0156   04F2 FD 77         inc b
0157   04F4 D7            push a
0158   04F5 11            mov a, b
0159   04F6 45 FF FF      mov [bp + -1], a ; i
0160   04F9 E4            pop a
0161   04FA 0A 8E 04      jmp _for3_cond
0162   04FD             _for3_exit:
0163   04FD F9            leave
0164   04FE 05 0B         syscall sys_terminate_proc
0165   0500             print_nbr:
0166   0500 D2            push bp
0167   0501 9B            mov bp, sp
0168   0502             
0169   0502             ; --- BEGIN INLINE ASM BLOCK
0170   0502 17 05 00      mov a, [bp + 5]
0171   0505 07 E6 07      call print_u16d
0172   0508 14 77 05      mov a, [ss]
0173   050B 3C            mov d, a
0174   050C 07 BD 07      call puts
0175   050F             ; --- END INLINE ASM BLOCK
0176   050F             
0177   050F F9            leave
0178   0510 09            ret
0179   0511             ; --- END TEXT BLOCK
0180   0511             
0181   0511             ; --- BEGIN DATA BLOCK
0182   0511 00 00 00 00 m: .db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
0182   0515 00 00 00 00 
0182   0519 00 00 00 00 
0182   051D 00 00 00 00 
0182   0521 00 00 00 00 
0182   0525 00 00 00 00 
0182   0529 00 00 00 00 
0182   052D 00 00 00 00 
0182   0531 00 00 00 00 
0182   0535 00 00 00 00 
0182   0539 00 00 00 00 
0182   053D 00 00 00 00 
0182   0541 00 00 00 00 
0182   0545 00 00 00 00 
0182   0549 00 00 00 00 
0182   054D 00 00 00 00 
0182   0551 00 00 00 00 
0182   0555 00 00 00 00 
0182   0559 00 00 00 00 
0182   055D 00 00 00 00 
0182   0561 00 00 00 00 
0182   0565 00 00 00 00 
0182   0569 00 00 00 00 
0182   056D 00 00 00 00 
0182   0571 00 00 00 00 
0183   0575 0A 00       ss_data: .db "\n", 0
0184   0577 75 05       ss: .dw ss_data
0185   0579             ; --- END DATA BLOCK
0186   0579             
0187   0579             ; --- BEGIN INCLUDE BLOCK
0188   0579             .include "lib/stdio.asm"
0001+  0579             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0579             ; stdio.s
0003+  0579             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0579             .include "lib/string.asm"
0001++ 0579             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0579             ; string.s
0003++ 0579             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0579             
0005++ 0579             
0006++ 0579             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0579             ; strrev
0008++ 0579             ; reverse a string
0009++ 0579             ; D = string address
0010++ 0579             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0579             ; 01234
0012++ 0579             strrev:
0013++ 0579 4B          	pusha
0014++ 057A 07 C0 05    	call strlen	; length in C
0015++ 057D 12          	mov a, c
0016++ 057E AF 01 00    	cmp a, 1
0017++ 0581 D0 9B 05    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0584 7D          	dec a
0019++ 0585 FD 4E       	mov si, d	; beginning of string
0020++ 0587 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0589 59          	add d, a	; end of string
0022++ 058A 12          	mov a, c
0023++ 058B FD 9B       	shr a		; divide by 2
0024++ 058D 39          	mov c, a	; C now counts the steps
0025++ 058E             strrev_L0:
0026++ 058E 32          	mov bl, [d]	; save load right-side char into BL
0027++ 058F F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0590 3E          	mov [d], al	; store left char into right side
0029++ 0591 1B          	mov al, bl
0030++ 0592 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0593 7E          	dec c
0032++ 0594 7F          	dec d
0033++ 0595 C2 00 00    	cmp c, 0
0034++ 0598 C7 8E 05    	jne strrev_L0
0035++ 059B             strrev_end:
0036++ 059B 4C          	popa
0037++ 059C 09          	ret
0038++ 059D             	
0039++ 059D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 059D             ; strchr
0041++ 059D             ; search string in D for char in AL
0042++ 059D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 059D             strchr:
0044++ 059D             strchr_L0:
0045++ 059D 32          	mov bl, [d]
0046++ 059E C1 00       	cmp bl, 0
0047++ 05A0 C6 AB 05    	je strchr_end
0048++ 05A3 BA          	cmp al, bl
0049++ 05A4 C6 AB 05    	je strchr_end
0050++ 05A7 79          	inc d
0051++ 05A8 0A 9D 05    	jmp strchr_L0
0052++ 05AB             strchr_end:
0053++ 05AB 1B          	mov al, bl
0054++ 05AC 09          	ret
0055++ 05AD             
0056++ 05AD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 05AD             ; strstr
0058++ 05AD             ; find sub-string
0059++ 05AD             ; str1 in SI
0060++ 05AD             ; str2 in DI
0061++ 05AD             ; SI points to end of source string
0062++ 05AD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 05AD             strstr:
0064++ 05AD DB          	push al
0065++ 05AE DA          	push d
0066++ 05AF E3          	push di
0067++ 05B0             strstr_loop:
0068++ 05B0 F3          	cmpsb					; compare a byte of the strings
0069++ 05B1 C7 BC 05    	jne strstr_ret
0070++ 05B4 FC 00 00    	lea d, [di + 0]
0071++ 05B7 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 05B9 C7 B0 05    	jne strstr_loop				; equal chars but not at end
0073++ 05BC             strstr_ret:
0074++ 05BC F0          	pop di
0075++ 05BD E7          	pop d
0076++ 05BE E8          	pop al
0077++ 05BF 09          	ret
0078++ 05C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 05C0             ; length of null terminated string
0080++ 05C0             ; result in C
0081++ 05C0             ; pointer in D
0082++ 05C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 05C0             strlen:
0084++ 05C0 DA          	push d
0085++ 05C1 38 00 00    	mov c, 0
0086++ 05C4             strlen_L1:
0087++ 05C4 BD 00       	cmp byte [d], 0
0088++ 05C6 C6 CE 05    	je strlen_ret
0089++ 05C9 79          	inc d
0090++ 05CA 78          	inc c
0091++ 05CB 0A C4 05    	jmp strlen_L1
0092++ 05CE             strlen_ret:
0093++ 05CE E7          	pop d
0094++ 05CF 09          	ret
0095++ 05D0             
0096++ 05D0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 05D0             ; STRCMP
0098++ 05D0             ; compare two strings
0099++ 05D0             ; str1 in SI
0100++ 05D0             ; str2 in DI
0101++ 05D0             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 05D0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 05D0             strcmp:
0104++ 05D0 DB          	push al
0105++ 05D1 DA          	push d
0106++ 05D2 E3          	push di
0107++ 05D3 E2          	push si
0108++ 05D4             strcmp_loop:
0109++ 05D4 F3          	cmpsb					; compare a byte of the strings
0110++ 05D5 C7 E0 05    	jne strcmp_ret
0111++ 05D8 FB FF FF    	lea d, [si +- 1]
0112++ 05DB BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 05DD C7 D4 05    	jne strcmp_loop				; equal chars but not at end
0114++ 05E0             strcmp_ret:
0115++ 05E0 EF          	pop si
0116++ 05E1 F0          	pop di
0117++ 05E2 E7          	pop d
0118++ 05E3 E8          	pop al
0119++ 05E4 09          	ret
0120++ 05E5             
0121++ 05E5             
0122++ 05E5             ; STRCPY
0123++ 05E5             ; copy null terminated string from SI to DI
0124++ 05E5             ; source in SI
0125++ 05E5             ; destination in DI
0126++ 05E5             strcpy:
0127++ 05E5 E2          	push si
0128++ 05E6 E3          	push di
0129++ 05E7 DB          	push al
0130++ 05E8             strcpy_L1:
0131++ 05E8 F6          	lodsb
0132++ 05E9 F7          	stosb
0133++ 05EA B9 00       	cmp al, 0
0134++ 05EC C7 E8 05    	jne strcpy_L1
0135++ 05EF             strcpy_end:
0136++ 05EF E8          	pop al
0137++ 05F0 F0          	pop di
0138++ 05F1 EF          	pop si
0139++ 05F2 09          	ret
0140++ 05F3             
0141++ 05F3             ; STRCAT
0142++ 05F3             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 05F3             ; source in SI
0144++ 05F3             ; destination in DI
0145++ 05F3             strcat:
0146++ 05F3 E2          	push si
0147++ 05F4 E3          	push di
0148++ 05F5 D7          	push a
0149++ 05F6 DA          	push d
0150++ 05F7 50          	mov a, di
0151++ 05F8 3C          	mov d, a
0152++ 05F9             strcat_goto_end_L1:
0153++ 05F9 BD 00       	cmp byte[d], 0
0154++ 05FB C6 02 06    	je strcat_start
0155++ 05FE 79          	inc d
0156++ 05FF 0A F9 05    	jmp strcat_goto_end_L1
0157++ 0602             strcat_start:
0158++ 0602 FD 50       	mov di, d
0159++ 0604             strcat_L1:
0160++ 0604 F6          	lodsb
0161++ 0605 F7          	stosb
0162++ 0606 B9 00       	cmp al, 0
0163++ 0608 C7 04 06    	jne strcat_L1
0164++ 060B             strcat_end:
0165++ 060B E7          	pop d
0166++ 060C E4          	pop a
0167++ 060D F0          	pop di
0168++ 060E EF          	pop si
0169++ 060F 09          	ret
0005+  0610             
0006+  0610 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  0614 34 35 36 37 
0006+  0618 38 39 41 42 
0006+  061C 43 44 45 46 
0007+  0620             
0008+  0620 01 00       table_power:.dw 1
0009+  0622 0A 00       			.dw 10
0010+  0624 64 00       			.dw 100
0011+  0626 E8 03       			.dw 1000
0012+  0628 10 27       			.dw 10000
0013+  062A             
0014+  062A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0015+  062A             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0016+  062A             ; ASCII in BL
0017+  062A             ; result in AL
0018+  062A             ; ascii for F = 0100 0110
0019+  062A             ; ascii for 9 = 0011 1001
0020+  062A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0021+  062A             hex_ascii_encode:
0022+  062A 1B          	mov al, bl
0023+  062B 93 40       	test al, $40				; test if letter or number
0024+  062D C7 33 06    	jnz hex_letter
0025+  0630 87 0F       	and al, $0F				; get number
0026+  0632 09          	ret
0027+  0633             hex_letter:
0028+  0633 87 0F       	and al, $0F				; get letter
0029+  0635 6A 09       	add al, 9
0030+  0637 09          	ret
0031+  0638             
0032+  0638             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0033+  0638             ; ATOI
0034+  0638             ; 2 letter hex string in B
0035+  0638             ; 8bit integer returned in AL
0036+  0638             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0037+  0638             atoi:
0038+  0638 D8          	push b
0039+  0639 07 2A 06    	call hex_ascii_encode			; convert BL to 4bit code in AL
0040+  063C 30          	mov bl, bh
0041+  063D DB          	push al					; save a
0042+  063E 07 2A 06    	call hex_ascii_encode
0043+  0641 EA          	pop bl	
0044+  0642 FD 9E 04    	shl al, 4
0045+  0645 8C          	or al, bl
0046+  0646 E5          	pop b
0047+  0647 09          	ret	
0048+  0648             
0049+  0648             
0050+  0648             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  0648             ; printf
0052+  0648             ; no need for explanations!
0053+  0648             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0054+  0648             printf:
0055+  0648 09          	ret
0056+  0649             
0057+  0649             
0058+  0649             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  0649             ; scanf
0060+  0649             ; no need for explanations!
0061+  0649             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  0649             scanf:
0063+  0649 09          	ret
0064+  064A             
0065+  064A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  064A             ; ITOA
0067+  064A             ; 8bit value in BL
0068+  064A             ; 2 byte ASCII result in A
0069+  064A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0070+  064A             itoa:
0071+  064A DA          	push d
0072+  064B D8          	push b
0073+  064C A7 00       	mov bh, 0
0074+  064E FD A4 04    	shr bl, 4	
0075+  0651 74          	mov d, b
0076+  0652 1F 10 06    	mov al, [d + s_hex_digits]
0077+  0655 23          	mov ah, al
0078+  0656             	
0079+  0656 E5          	pop b
0080+  0657 D8          	push b
0081+  0658 A7 00       	mov bh, 0
0082+  065A FD 87 0F    	and bl, $0F
0083+  065D 74          	mov d, b
0084+  065E 1F 10 06    	mov al, [d + s_hex_digits]
0085+  0661 E5          	pop b
0086+  0662 E7          	pop d
0087+  0663 09          	ret
0088+  0664             
0089+  0664             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0090+  0664             ; HEX STRING TO BINARY
0091+  0664             ; di = destination address
0092+  0664             ; si = source
0093+  0664             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0094+  0664             hex_to_int:
0095+  0664             hex_to_int_L1:
0096+  0664 F6          	lodsb					; load from [SI] to AL
0097+  0665 B9 00       	cmp al, 0				; check if ASCII 0
0098+  0667 C6 74 06    	jz hex_to_int_ret
0099+  066A 36          	mov bh, al
0100+  066B F6          	lodsb
0101+  066C 2F          	mov bl, al
0102+  066D 07 38 06    	call atoi				; convert ASCII byte in B to int (to AL)
0103+  0670 F7          	stosb					; store AL to [DI]
0104+  0671 0A 64 06    	jmp hex_to_int_L1
0105+  0674             hex_to_int_ret:
0106+  0674 09          	ret		
0107+  0675             
0108+  0675             
0109+  0675             
0110+  0675             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  0675             ; GETCHAR
0112+  0675             ; char in ah
0113+  0675             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0114+  0675             getchar:
0115+  0675 DB          	push al
0116+  0676             getchar_retry:
0117+  0676 FD 0C       	sti
0118+  0678 19 01       	mov al, 1
0119+  067A 05 03       	syscall sys_io			; receive in AH
0120+  067C B9 00       	cmp al, 0			; check if any char was receive
0121+  067E C6 76 06    	je getchar_retry
0122+  0681 E8          	pop al
0123+  0682 09          	ret
0124+  0683             
0125+  0683             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0126+  0683             ; PUTCHAR
0127+  0683             ; char in ah
0128+  0683             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  0683             putchar:
0130+  0683 D7          	push a
0131+  0684 19 00       	mov al, 0
0132+  0686 05 03       	syscall sys_io			; char in AH
0133+  0688 E4          	pop a
0134+  0689 09          	ret
0135+  068A             
0136+  068A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0137+  068A             ;; INPUT A STRING
0138+  068A             ;; terminates with null
0139+  068A             ;; pointer in D
0140+  068A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  068A             gets:
0142+  068A D7          	push a
0143+  068B DA          	push d
0144+  068C             gets_loop:
0145+  068C FD 0C       	sti
0146+  068E 19 01       	mov al, 1
0147+  0690 05 03       	syscall sys_io			; receive in AH
0148+  0692 B9 00       	cmp al, 0				; check error code (AL)
0149+  0694 C6 8C 06    	je gets_loop			; if no char received, retry
0150+  0697             
0151+  0697 76 1B       	cmp ah, 27
0152+  0699 C6 BA 06    	je gets_telnet_escape
0153+  069C 76 0A       	cmp ah, $0A				; LF
0154+  069E C6 13 07    	je gets_end
0155+  06A1 76 0D       	cmp ah, $0D				; CR
0156+  06A3 C6 13 07    	je gets_end
0157+  06A6 76 5C       	cmp ah, $5C				; '\\'
0158+  06A8 C6 EA 06    	je gets_escape
0159+  06AB             	
0160+  06AB 76 08       	cmp ah, $08			; check for backspace
0161+  06AD C6 B6 06    	je gets_backspace
0162+  06B0             
0163+  06B0 1A          	mov al, ah
0164+  06B1 3E          	mov [d], al
0165+  06B2 79          	inc d
0166+  06B3 0A 8C 06    	jmp gets_loop
0167+  06B6             gets_backspace:
0168+  06B6 7F          	dec d
0169+  06B7 0A 8C 06    	jmp gets_loop
0170+  06BA             gets_telnet_escape:
0171+  06BA FD 0C       	sti
0172+  06BC 19 01       	mov al, 1
0173+  06BE 05 03       	syscall sys_io				; receive in AH without echo
0174+  06C0 B9 00       	cmp al, 0					; check error code (AL)
0175+  06C2 C6 BA 06    	je gets_telnet_escape		; if no char received, retry
0176+  06C5 76 5B       	cmp ah, '['
0177+  06C7 C7 8C 06    	jne gets_loop
0178+  06CA             gets_telnet_escape_phase2:
0179+  06CA FD 0C       	sti
0180+  06CC 19 01       	mov al, 1
0181+  06CE 05 03       	syscall sys_io					; receive in AH without echo
0182+  06D0 B9 00       	cmp al, 0						; check error code (AL)
0183+  06D2 C6 CA 06    	je gets_telnet_escape_phase2	; if no char received, retry
0184+  06D5 76 44       	cmp ah, 'D'
0185+  06D7 C6 E2 06    	je gets_left_arrow
0186+  06DA 76 43       	cmp ah, 'C'
0187+  06DC C6 E6 06    	je gets_right_arrow
0188+  06DF 0A 8C 06    	jmp gets_loop
0189+  06E2             gets_left_arrow:
0190+  06E2 7F          	dec d
0191+  06E3 0A 8C 06    	jmp gets_loop
0192+  06E6             gets_right_arrow:
0193+  06E6 79          	inc d
0194+  06E7 0A 8C 06    	jmp gets_loop
0195+  06EA             gets_escape:
0196+  06EA FD 0C       	sti
0197+  06EC 19 01       	mov al, 1
0198+  06EE 05 03       	syscall sys_io			; receive in AH
0199+  06F0 B9 00       	cmp al, 0				; check error code (AL)
0200+  06F2 C6 EA 06    	je gets_escape			; if no char received, retry
0201+  06F5 76 6E       	cmp ah, 'n'
0202+  06F7 C6 05 07    	je gets_LF
0203+  06FA 76 72       	cmp ah, 'r'
0204+  06FC C6 0C 07    	je gets_CR
0205+  06FF 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0206+  0700 3E          	mov [d], al
0207+  0701 79          	inc d
0208+  0702 0A 8C 06    	jmp gets_loop
0209+  0705             gets_LF:
0210+  0705 19 0A       	mov al, $0A
0211+  0707 3E          	mov [d], al
0212+  0708 79          	inc d
0213+  0709 0A 8C 06    	jmp gets_loop
0214+  070C             gets_CR:
0215+  070C 19 0D       	mov al, $0D
0216+  070E 3E          	mov [d], al
0217+  070F 79          	inc d
0218+  0710 0A 8C 06    	jmp gets_loop
0219+  0713             gets_end:
0220+  0713 19 00       	mov al, 0
0221+  0715 3E          	mov [d], al				; terminate string
0222+  0716 E7          	pop d
0223+  0717 E4          	pop a
0224+  0718 09          	ret
0225+  0719             
0226+  0719             
0227+  0719             
0228+  0719             
0229+  0719             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0230+  0719             ;; INPUT TEXT
0231+  0719             ;; terminated with CTRL+D
0232+  0719             ;; pointer in D
0233+  0719             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0234+  0719             gettxt:
0235+  0719 D7          	push a
0236+  071A DA          	push d
0237+  071B             gettxt_loop:
0238+  071B 19 01       	mov al, 1
0239+  071D 05 03       	syscall sys_io			; receive in AH
0240+  071F B9 00       	cmp al, 0				; check error code (AL)
0241+  0721 C6 1B 07    	je gettxt_loop		; if no char received, retry
0242+  0724 76 04       	cmp ah, 4			; EOT
0243+  0726 C6 64 07    	je gettxt_end
0244+  0729 76 08       	cmp ah, $08			; check for backspace
0245+  072B C6 60 07    	je gettxt_backspace
0246+  072E 76 5C       	cmp ah, $5C				; '\\'
0247+  0730 C6 39 07    	je gettxt_escape
0248+  0733 1A          	mov al, ah
0249+  0734 3E          	mov [d], al
0250+  0735 79          	inc d
0251+  0736 0A 1B 07    	jmp gettxt_loop
0252+  0739             gettxt_escape:
0253+  0739 19 01       	mov al, 1
0254+  073B 05 03       	syscall sys_io			; receive in AH
0255+  073D B9 00       	cmp al, 0				; check error code (AL)
0256+  073F C6 39 07    	je gettxt_escape		; if no char received, retry
0257+  0742 76 6E       	cmp ah, 'n'
0258+  0744 C6 52 07    	je gettxt_LF
0259+  0747 76 72       	cmp ah, 'r'
0260+  0749 C6 59 07    	je gettxt_CR
0261+  074C 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0262+  074D 3E          	mov [d], al
0263+  074E 79          	inc d
0264+  074F 0A 1B 07    	jmp gettxt_loop
0265+  0752             gettxt_LF:
0266+  0752 19 0A       	mov al, $0A
0267+  0754 3E          	mov [d], al
0268+  0755 79          	inc d
0269+  0756 0A 1B 07    	jmp gettxt_loop
0270+  0759             gettxt_CR:
0271+  0759 19 0D       	mov al, $0D
0272+  075B 3E          	mov [d], al
0273+  075C 79          	inc d
0274+  075D 0A 1B 07    	jmp gettxt_loop
0275+  0760             gettxt_backspace:
0276+  0760 7F          	dec d
0277+  0761 0A 1B 07    	jmp gettxt_loop
0278+  0764             gettxt_end:
0279+  0764 19 00       	mov al, 0
0280+  0766 3E          	mov [d], al				; terminate string
0281+  0767 E7          	pop d
0282+  0768 E4          	pop a
0283+  0769 09          	ret
0284+  076A             
0285+  076A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0286+  076A             ; PRINT NEW LINE
0287+  076A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  076A             printnl:
0289+  076A D7          	push a
0290+  076B 10 00 0A    	mov a, $0A00
0291+  076E 05 03       	syscall sys_io
0292+  0770 10 00 0D    	mov a, $0D00
0293+  0773 05 03       	syscall sys_io
0294+  0775 E4          	pop a
0295+  0776 09          	ret
0296+  0777             
0297+  0777             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0298+  0777             ; strtoint
0299+  0777             ; 4 digit hex string number in d
0300+  0777             ; integer returned in A
0301+  0777             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0302+  0777             strtointx:
0303+  0777 D8          	push b
0304+  0778 32          	mov bl, [d]
0305+  0779 37          	mov bh, bl
0306+  077A 33 01 00    	mov bl, [d + 1]
0307+  077D 07 38 06    	call atoi				; convert to int in AL
0308+  0780 23          	mov ah, al				; move to AH
0309+  0781 33 02 00    	mov bl, [d + 2]
0310+  0784 37          	mov bh, bl
0311+  0785 33 03 00    	mov bl, [d + 3]
0312+  0788 07 38 06    	call atoi				; convert to int in AL
0313+  078B E5          	pop b
0314+  078C 09          	ret
0315+  078D             
0316+  078D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0317+  078D             ; strtoint
0318+  078D             ; 5 digit base10 string number in d
0319+  078D             ; integer returned in A
0320+  078D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0321+  078D             strtoint:
0322+  078D E2          	push si
0323+  078E D8          	push b
0324+  078F D9          	push c
0325+  0790 DA          	push d
0326+  0791 07 C0 05    	call strlen			; get string length in C
0327+  0794 7E          	dec c
0328+  0795 FD 4E       	mov si, d
0329+  0797 12          	mov a, c
0330+  0798 FD 99       	shl a
0331+  079A 3B 20 06    	mov d, table_power
0332+  079D 59          	add d, a
0333+  079E 38 00 00    	mov c, 0
0334+  07A1             strtoint_L0:
0335+  07A1 F6          	lodsb			; load ASCII to al
0336+  07A2 B9 00       	cmp al, 0
0337+  07A4 C6 B7 07    	je strtoint_end
0338+  07A7 6F 30       	sub al, $30		; make into integer
0339+  07A9 22 00       	mov ah, 0
0340+  07AB 2A          	mov b, [d]
0341+  07AC AC          	mul a, b			; result in B since it fits in 16bits
0342+  07AD 11          	mov a, b
0343+  07AE 28          	mov b, c
0344+  07AF 54          	add a, b
0345+  07B0 39          	mov c, a
0346+  07B1 63 02 00    	sub d, 2
0347+  07B4 0A A1 07    	jmp strtoint_L0
0348+  07B7             strtoint_end:
0349+  07B7 12          	mov a, c
0350+  07B8 E7          	pop d
0351+  07B9 E6          	pop c
0352+  07BA E5          	pop b
0353+  07BB EF          	pop si
0354+  07BC 09          	ret
0355+  07BD             
0356+  07BD             
0357+  07BD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0358+  07BD             ; PRINT NULL TERMINATED STRING
0359+  07BD             ; pointer in D
0360+  07BD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0361+  07BD             puts:
0362+  07BD D7          	push a
0363+  07BE DA          	push d
0364+  07BF             puts_L1:
0365+  07BF 1E          	mov al, [d]
0366+  07C0 B9 00       	cmp al, 0
0367+  07C2 C6 CE 07    	jz puts_END
0368+  07C5 23          	mov ah, al
0369+  07C6 19 00       	mov al, 0
0370+  07C8 05 03       	syscall sys_io
0371+  07CA 79          	inc d
0372+  07CB 0A BF 07    	jmp puts_L1
0373+  07CE             puts_END:
0374+  07CE E7          	pop d
0375+  07CF E4          	pop a
0376+  07D0 09          	ret
0377+  07D1             
0378+  07D1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  07D1             ; PRINT N SIZE STRING
0380+  07D1             ; pointer in D
0381+  07D1             ; size in C
0382+  07D1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0383+  07D1             putsn:
0384+  07D1 DB          	push al
0385+  07D2 DA          	push d
0386+  07D3 D9          	push c
0387+  07D4             putsn_L0:
0388+  07D4 1E          	mov al, [d]
0389+  07D5 23          	mov ah, al
0390+  07D6 19 00       	mov al, 0
0391+  07D8 05 03       	syscall sys_io
0392+  07DA 79          	inc d
0393+  07DB 7E          	dec c	
0394+  07DC C2 00 00    	cmp c, 0
0395+  07DF C7 D4 07    	jne putsn_L0
0396+  07E2             putsn_end:
0397+  07E2 E6          	pop c
0398+  07E3 E7          	pop d
0399+  07E4 E8          	pop al
0400+  07E5 09          	ret
0401+  07E6             
0402+  07E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0403+  07E6             ; print 16bit decimal number
0404+  07E6             ; input number in A
0405+  07E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  07E6             print_u16d:
0407+  07E6 D7          	push a
0408+  07E7 D8          	push b
0409+  07E8 26 10 27    	mov b, 10000
0410+  07EB AE          	div a, b			; get 10000 coeff.
0411+  07EC 07 12 08    	call print_number
0412+  07EF 11          	mov a, b
0413+  07F0 26 E8 03    	mov b, 1000
0414+  07F3 AE          	div a, b			; get 10000 coeff.
0415+  07F4 07 12 08    	call print_number
0416+  07F7 11          	mov a, b
0417+  07F8 26 64 00    	mov b, 100
0418+  07FB AE          	div a, b
0419+  07FC 07 12 08    	call print_number
0420+  07FF 11          	mov a, b
0421+  0800 26 0A 00    	mov b, 10
0422+  0803 AE          	div a, b
0423+  0804 07 12 08    	call print_number
0424+  0807 11          	mov a, b
0425+  0808 6A 30       	add al, $30
0426+  080A 23          	mov ah, al
0427+  080B 19 00       	mov al, 0
0428+  080D 05 03       	syscall sys_io	; print coeff
0429+  080F E5          	pop b
0430+  0810 E4          	pop a
0431+  0811 09          	ret
0432+  0812             
0433+  0812             
0434+  0812             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0435+  0812             ; if A == 0, print space
0436+  0812             ; else print A
0437+  0812             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0438+  0812             print_number:
0439+  0812 6A 30       	add al, $30
0440+  0814 23          	mov ah, al
0441+  0815 07 83 06    	call putchar
0442+  0818 09          	ret
0443+  0819             
0444+  0819             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  0819             ; PRINT 16BIT HEX INTEGER
0446+  0819             ; integer value in reg B
0447+  0819             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  0819             print_u16x:
0449+  0819 D7          	push a
0450+  081A D8          	push b
0451+  081B DD          	push bl
0452+  081C 30          	mov bl, bh
0453+  081D 07 4A 06    	call itoa				; convert bh to char in A
0454+  0820 2F          	mov bl, al				; save al
0455+  0821 19 00       	mov al, 0
0456+  0823 05 03       	syscall sys_io				; display AH
0457+  0825 24          	mov ah, bl				; retrieve al
0458+  0826 19 00       	mov al, 0
0459+  0828 05 03       	syscall sys_io				; display AL
0460+  082A             
0461+  082A EA          	pop bl
0462+  082B 07 4A 06    	call itoa				; convert bh to char in A
0463+  082E 2F          	mov bl, al				; save al
0464+  082F 19 00       	mov al, 0
0465+  0831 05 03       	syscall sys_io				; display AH
0466+  0833 24          	mov ah, bl				; retrieve al
0467+  0834 19 00       	mov al, 0
0468+  0836 05 03       	syscall sys_io				; display AL
0469+  0838             
0470+  0838 E5          	pop b
0471+  0839 E4          	pop a
0472+  083A 09          	ret
0473+  083B             
0474+  083B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0475+  083B             ; INPUT 16BIT HEX INTEGER
0476+  083B             ; read 16bit integer into A
0477+  083B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0478+  083B             scan_u16x:
0479+  083B F8 10 00    	enter 16
0480+  083E D8          	push b
0481+  083F DA          	push d
0482+  0840             
0483+  0840 FA F1 FF    	lea d, [bp + -15]
0484+  0843 07 8A 06    	call gets				; get number
0485+  0846             
0486+  0846 32          	mov bl, [d]
0487+  0847 37          	mov bh, bl
0488+  0848 33 01 00    	mov bl, [d + 1]
0489+  084B 07 38 06    	call atoi				; convert to int in AL
0490+  084E 23          	mov ah, al				; move to AH
0491+  084F             
0492+  084F 33 02 00    	mov bl, [d + 2]
0493+  0852 37          	mov bh, bl
0494+  0853 33 03 00    	mov bl, [d + 3]
0495+  0856 07 38 06    	call atoi				; convert to int in AL
0496+  0859             
0497+  0859 E7          	pop d
0498+  085A E5          	pop b
0499+  085B F9          	leave
0500+  085C 09          	ret
0501+  085D             
0502+  085D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0503+  085D             ; PRINT 8bit HEX INTEGER
0504+  085D             ; integer value in reg bl
0505+  085D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0506+  085D             print_u8x:
0507+  085D D7          	push a
0508+  085E DD          	push bl
0509+  085F             
0510+  085F 07 4A 06    	call itoa				; convert bl to char in A
0511+  0862 2F          	mov bl, al				; save al
0512+  0863 19 00       	mov al, 0
0513+  0865 05 03       	syscall sys_io				; display AH
0514+  0867 24          	mov ah, bl				; retrieve al
0515+  0868 19 00       	mov al, 0
0516+  086A 05 03       	syscall sys_io				; display AL
0517+  086C             
0518+  086C EA          	pop bl
0519+  086D E4          	pop a
0520+  086E 09          	ret
0521+  086F             
0522+  086F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0523+  086F             ; print 8bit decimal unsigned number
0524+  086F             ; input number in AL
0525+  086F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0526+  086F             print_u8d:
0527+  086F D7          	push a
0528+  0870 D8          	push b
0529+  0871             
0530+  0871 22 00       	mov ah, 0
0531+  0873 26 64 00    	mov b, 100
0532+  0876 AE          	div a, b
0533+  0877 D8          	push b			; save remainder
0534+  0878 B9 00       	cmp al, 0
0535+  087A C6 84 08    	je skip100
0536+  087D 6A 30       	add al, $30
0537+  087F 23          	mov ah, al
0538+  0880 19 00       	mov al, 0
0539+  0882 05 03       	syscall sys_io	; print coeff
0540+  0884             skip100:
0541+  0884 E4          	pop a
0542+  0885 22 00       	mov ah, 0
0543+  0887 26 0A 00    	mov b, 10
0544+  088A AE          	div a, b
0545+  088B D8          	push b			; save remainder
0546+  088C B9 00       	cmp al, 0
0547+  088E C6 98 08    	je skip10
0548+  0891 6A 30       	add al, $30
0549+  0893 23          	mov ah, al
0550+  0894 19 00       	mov al, 0
0551+  0896 05 03       	syscall sys_io	; print coeff
0552+  0898             skip10:
0553+  0898 E4          	pop a
0554+  0899 1B          	mov al, bl
0555+  089A 6A 30       	add al, $30
0556+  089C 23          	mov ah, al
0557+  089D 19 00       	mov al, 0
0558+  089F 05 03       	syscall sys_io	; print coeff
0559+  08A1 E5          	pop b
0560+  08A2 E4          	pop a
0561+  08A3 09          	ret
0562+  08A4             
0563+  08A4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0564+  08A4             ; INPUT 8BIT HEX INTEGER
0565+  08A4             ; read 8bit integer into AL
0566+  08A4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0567+  08A4             scan_u8x:
0568+  08A4 F8 04 00    	enter 4
0569+  08A7 D8          	push b
0570+  08A8 DA          	push d
0571+  08A9             
0572+  08A9 FA FD FF    	lea d, [bp + -3]
0573+  08AC 07 8A 06    	call gets				; get number
0574+  08AF             
0575+  08AF 32          	mov bl, [d]
0576+  08B0 37          	mov bh, bl
0577+  08B1 33 01 00    	mov bl, [d + 1]
0578+  08B4 07 38 06    	call atoi				; convert to int in AL
0579+  08B7             
0580+  08B7 E7          	pop d
0581+  08B8 E5          	pop b
0582+  08B9 F9          	leave
0583+  08BA 09          	ret
0584+  08BB             
0585+  08BB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0586+  08BB             ; input decimal number
0587+  08BB             ; result in A
0588+  08BB             ; 655'\0'
0589+  08BB             ; low--------high
0590+  08BB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0591+  08BB             scan_u16d:
0592+  08BB F8 08 00    	enter 8
0593+  08BE E2          	push si
0594+  08BF D8          	push b
0595+  08C0 D9          	push c
0596+  08C1 DA          	push d
0597+  08C2 FA F9 FF    	lea d, [bp +- 7]
0598+  08C5 07 8A 06    	call gets
0599+  08C8 07 C0 05    	call strlen			; get string length in C
0600+  08CB 7E          	dec c
0601+  08CC FD 4E       	mov si, d
0602+  08CE 12          	mov a, c
0603+  08CF FD 99       	shl a
0604+  08D1 3B 20 06    	mov d, table_power
0605+  08D4 59          	add d, a
0606+  08D5 38 00 00    	mov c, 0
0607+  08D8             mul_loop:
0608+  08D8 F6          	lodsb			; load ASCII to al
0609+  08D9 B9 00       	cmp al, 0
0610+  08DB C6 EE 08    	je mul_exit
0611+  08DE 6F 30       	sub al, $30		; make into integer
0612+  08E0 22 00       	mov ah, 0
0613+  08E2 2A          	mov b, [d]
0614+  08E3 AC          	mul a, b			; result in B since it fits in 16bits
0615+  08E4 11          	mov a, b
0616+  08E5 28          	mov b, c
0617+  08E6 54          	add a, b
0618+  08E7 39          	mov c, a
0619+  08E8 63 02 00    	sub d, 2
0620+  08EB 0A D8 08    	jmp mul_loop
0621+  08EE             mul_exit:
0622+  08EE 12          	mov a, c
0623+  08EF E7          	pop d
0624+  08F0 E6          	pop c
0625+  08F1 E5          	pop b
0626+  08F2 EF          	pop si
0627+  08F3 F9          	leave
0628+  08F4 09          	ret
0189   08F5             ; --- END INCLUDE BLOCK
0190   08F5             
0191   08F5             
0192   08F5             .end
tasm: Number of errors = 0
