0001   0000             ; --- Filename: test.c
0002   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0400             .org PROC_TEXT_ORG
0004   0400             
0005   0400             ; --- begin text block
0006   0400             main:
0007   0400 D2            push bp
0008   0401 9B            mov bp, sp
0009   0402 3B 00 00      mov d, 0
0010   0405 29 B8 04      mov b, [i3]
0011   0408 10 19 00      mov a, 25
0012   040B AC            mul a, b
0013   040C 5A            add d, b
0014   040D 29 B6 04      mov b, [i2]
0015   0410 10 05 00      mov a, 5
0016   0413 AC            mul a, b
0017   0414 5A            add d, b
0018   0415 29 B4 04      mov b, [i1]
0019   0418 5A            add d, b
0020   0419 16 36 04      mov a, [d + matrix]
0021   041C 27            mov b, a
0022   041D DD            push bl
0023   041E 07 27 04      call print
0024   0421 51 01 00      add sp, 1
0025   0424 F9            leave
0026   0425 05 0B         syscall sys_terminate_proc
0027   0427             print:
0028   0427 D2            push bp
0029   0428 9B            mov bp, sp
0030   0429             ; --- begin inline asm block
0031   0429 17 05 00        mov a, [bp + 5]
0032   042C FD AA           swp a
0033   042E 53 00 01        add a, 0100h
0034   0431 07 C4 05        call putchar
0035   0434               ; --- end inline asm block
0036   0434 F9            leave
0037   0435 09            ret
0038   0436             ; --- end text block
0039   0436             
0040   0436             ; --- begin data block
0041   0436 61 61 61 61 matrix: .fill 125, 97
0041   043A 61 61 61 61 
0041   043E 61 61 61 61 
0041   0442 61 61 61 61 
0041   0446 61 61 61 61 
0041   044A 61 61 61 61 
0041   044E 61 61 61 61 
0041   0452 61 61 61 61 
0041   0456 61 61 61 61 
0041   045A 61 61 61 61 
0041   045E 61 61 61 61 
0041   0462 61 61 61 61 
0041   0466 61 61 61 61 
0041   046A 61 61 61 61 
0041   046E 61 61 61 61 
0041   0472 61 61 61 61 
0041   0476 61 61 61 61 
0041   047A 61 61 61 61 
0041   047E 61 61 61 61 
0041   0482 61 61 61 61 
0041   0486 61 61 61 61 
0041   048A 61 61 61 61 
0041   048E 61 61 61 61 
0041   0492 61 61 61 61 
0041   0496 61 61 61 61 
0041   049A 61 61 61 61 
0041   049E 61 61 61 61 
0041   04A2 61 61 61 61 
0041   04A6 61 61 61 61 
0041   04AA 61 61 61 61 
0041   04AE 61 61 61 61 
0041   04B2 61 
0042   04B3 5A          c: .fill 1, 90
0043   04B4 02 00       i1: .dw 2
0044   04B6 01 00       i2: .dw 1
0045   04B8 00 00       i3: .dw 0
0046   04BA             ; --- end data block
0047   04BA             ; --- begin include block
0048   04BA             .include "lib/stdio.asm"
0001+  04BA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  04BA             ; stdio.s
0003+  04BA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  04BA             .include "lib/string.asm"
0001++ 04BA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 04BA             ; string.s
0003++ 04BA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 04BA             
0005++ 04BA             
0006++ 04BA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 04BA             ; strrev
0008++ 04BA             ; reverse a string
0009++ 04BA             ; D = string address
0010++ 04BA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 04BA             ; 01234
0012++ 04BA             strrev:
0013++ 04BA 4B          	pusha
0014++ 04BB 07 01 05    	call strlen	; length in C
0015++ 04BE 12          	mov a, c
0016++ 04BF AF 01 00    	cmp a, 1
0017++ 04C2 D0 DC 04    	jleu strrev_end	; check string length. string len must be > 1
0018++ 04C5 7D          	dec a
0019++ 04C6 FD 4E       	mov si, d	; beginning of string
0020++ 04C8 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 04CA 59          	add d, a	; end of string
0022++ 04CB 12          	mov a, c
0023++ 04CC FD 9B       	shr a		; divide by 2
0024++ 04CE 39          	mov c, a	; C now counts the steps
0025++ 04CF             strrev_L0:
0026++ 04CF 32          	mov bl, [d]	; save load right-side char into BL
0027++ 04D0 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 04D1 3E          	mov [d], al	; store left char into right side
0029++ 04D2 1B          	mov al, bl
0030++ 04D3 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 04D4 7E          	dec c
0032++ 04D5 7F          	dec d
0033++ 04D6 C2 00 00    	cmp c, 0
0034++ 04D9 C7 CF 04    	jne strrev_L0
0035++ 04DC             strrev_end:
0036++ 04DC 4C          	popa
0037++ 04DD 09          	ret
0038++ 04DE             	
0039++ 04DE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 04DE             ; strchr
0041++ 04DE             ; search string in D for char in AL
0042++ 04DE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 04DE             strchr:
0044++ 04DE             strchr_L0:
0045++ 04DE 32          	mov bl, [d]
0046++ 04DF C1 00       	cmp bl, 0
0047++ 04E1 C6 EC 04    	je strchr_end
0048++ 04E4 BA          	cmp al, bl
0049++ 04E5 C6 EC 04    	je strchr_end
0050++ 04E8 79          	inc d
0051++ 04E9 0A DE 04    	jmp strchr_L0
0052++ 04EC             strchr_end:
0053++ 04EC 1B          	mov al, bl
0054++ 04ED 09          	ret
0055++ 04EE             
0056++ 04EE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 04EE             ; strstr
0058++ 04EE             ; find sub-string
0059++ 04EE             ; str1 in SI
0060++ 04EE             ; str2 in DI
0061++ 04EE             ; SI points to end of source string
0062++ 04EE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 04EE             strstr:
0064++ 04EE DB          	push al
0065++ 04EF DA          	push d
0066++ 04F0 E3          	push di
0067++ 04F1             strstr_loop:
0068++ 04F1 F3          	cmpsb					; compare a byte of the strings
0069++ 04F2 C7 FD 04    	jne strstr_ret
0070++ 04F5 FC 00 00    	lea d, [di + 0]
0071++ 04F8 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 04FA C7 F1 04    	jne strstr_loop				; equal chars but not at end
0073++ 04FD             strstr_ret:
0074++ 04FD F0          	pop di
0075++ 04FE E7          	pop d
0076++ 04FF E8          	pop al
0077++ 0500 09          	ret
0078++ 0501             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0501             ; length of null terminated string
0080++ 0501             ; result in C
0081++ 0501             ; pointer in D
0082++ 0501             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0501             strlen:
0084++ 0501 DA          	push d
0085++ 0502 38 00 00    	mov c, 0
0086++ 0505             strlen_L1:
0087++ 0505 BD 00       	cmp byte [d], 0
0088++ 0507 C6 0F 05    	je strlen_ret
0089++ 050A 79          	inc d
0090++ 050B 78          	inc c
0091++ 050C 0A 05 05    	jmp strlen_L1
0092++ 050F             strlen_ret:
0093++ 050F E7          	pop d
0094++ 0510 09          	ret
0095++ 0511             
0096++ 0511             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0511             ; STRCMP
0098++ 0511             ; compare two strings
0099++ 0511             ; str1 in SI
0100++ 0511             ; str2 in DI
0101++ 0511             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0511             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0511             strcmp:
0104++ 0511 DB          	push al
0105++ 0512 DA          	push d
0106++ 0513 E3          	push di
0107++ 0514 E2          	push si
0108++ 0515             strcmp_loop:
0109++ 0515 F3          	cmpsb					; compare a byte of the strings
0110++ 0516 C7 21 05    	jne strcmp_ret
0111++ 0519 FB FF FF    	lea d, [si +- 1]
0112++ 051C BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 051E C7 15 05    	jne strcmp_loop				; equal chars but not at end
0114++ 0521             strcmp_ret:
0115++ 0521 EF          	pop si
0116++ 0522 F0          	pop di
0117++ 0523 E7          	pop d
0118++ 0524 E8          	pop al
0119++ 0525 09          	ret
0120++ 0526             
0121++ 0526             
0122++ 0526             ; STRCPY
0123++ 0526             ; copy null terminated string from SI to DI
0124++ 0526             ; source in SI
0125++ 0526             ; destination in DI
0126++ 0526             strcpy:
0127++ 0526 E2          	push si
0128++ 0527 E3          	push di
0129++ 0528 DB          	push al
0130++ 0529             strcpy_L1:
0131++ 0529 F6          	lodsb
0132++ 052A F7          	stosb
0133++ 052B B9 00       	cmp al, 0
0134++ 052D C7 29 05    	jne strcpy_L1
0135++ 0530             strcpy_end:
0136++ 0530 E8          	pop al
0137++ 0531 F0          	pop di
0138++ 0532 EF          	pop si
0139++ 0533 09          	ret
0140++ 0534             
0141++ 0534             ; STRCAT
0142++ 0534             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0534             ; source in SI
0144++ 0534             ; destination in DI
0145++ 0534             strcat:
0146++ 0534 E2          	push si
0147++ 0535 E3          	push di
0148++ 0536 D7          	push a
0149++ 0537 DA          	push d
0150++ 0538 50          	mov a, di
0151++ 0539 3C          	mov d, a
0152++ 053A             strcat_goto_end_L1:
0153++ 053A BD 00       	cmp byte[d], 0
0154++ 053C C6 43 05    	je strcat_start
0155++ 053F 79          	inc d
0156++ 0540 0A 3A 05    	jmp strcat_goto_end_L1
0157++ 0543             strcat_start:
0158++ 0543 FD 50       	mov di, d
0159++ 0545             strcat_L1:
0160++ 0545 F6          	lodsb
0161++ 0546 F7          	stosb
0162++ 0547 B9 00       	cmp al, 0
0163++ 0549 C7 45 05    	jne strcat_L1
0164++ 054C             strcat_end:
0165++ 054C E7          	pop d
0166++ 054D E4          	pop a
0167++ 054E F0          	pop di
0168++ 054F EF          	pop si
0169++ 0550 09          	ret
0005+  0551             
0006+  0551 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  0555 34 35 36 37 
0006+  0559 38 39 41 42 
0006+  055D 43 44 45 46 
0007+  0561             
0008+  0561 01 00       table_power:.dw 1
0009+  0563 0A 00       			.dw 10
0010+  0565 64 00       			.dw 100
0011+  0567 E8 03       			.dw 1000
0012+  0569 10 27       			.dw 10000
0013+  056B             
0014+  056B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0015+  056B             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0016+  056B             ; ASCII in BL
0017+  056B             ; result in AL
0018+  056B             ; ascii for F = 0100 0110
0019+  056B             ; ascii for 9 = 0011 1001
0020+  056B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0021+  056B             hex_ascii_encode:
0022+  056B 1B          	mov al, bl
0023+  056C 93 40       	test al, $40				; test if letter or number
0024+  056E C7 74 05    	jnz hex_letter
0025+  0571 87 0F       	and al, $0F				; get number
0026+  0573 09          	ret
0027+  0574             hex_letter:
0028+  0574 87 0F       	and al, $0F				; get letter
0029+  0576 6A 09       	add al, 9
0030+  0578 09          	ret
0031+  0579             
0032+  0579             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0033+  0579             ; ATOI
0034+  0579             ; 2 letter hex string in B
0035+  0579             ; 8bit integer returned in AL
0036+  0579             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0037+  0579             atoi:
0038+  0579 D8          	push b
0039+  057A 07 6B 05    	call hex_ascii_encode			; convert BL to 4bit code in AL
0040+  057D 30          	mov bl, bh
0041+  057E DB          	push al					; save a
0042+  057F 07 6B 05    	call hex_ascii_encode
0043+  0582 EA          	pop bl	
0044+  0583 FD 9E 04    	shl al, 4
0045+  0586 8C          	or al, bl
0046+  0587 E5          	pop b
0047+  0588 09          	ret	
0048+  0589             
0049+  0589             
0050+  0589             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  0589             ; printf
0052+  0589             ; no need for explanations!
0053+  0589             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0054+  0589             printf:
0055+  0589 09          	ret
0056+  058A             
0057+  058A             
0058+  058A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  058A             ; scanf
0060+  058A             ; no need for explanations!
0061+  058A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  058A             scanf:
0063+  058A 09          	ret
0064+  058B             
0065+  058B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  058B             ; ITOA
0067+  058B             ; 8bit value in BL
0068+  058B             ; 2 byte ASCII result in A
0069+  058B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0070+  058B             itoa:
0071+  058B DA          	push d
0072+  058C D8          	push b
0073+  058D A7 00       	mov bh, 0
0074+  058F FD A4 04    	shr bl, 4	
0075+  0592 74          	mov d, b
0076+  0593 1F 51 05    	mov al, [d + s_hex_digits]
0077+  0596 23          	mov ah, al
0078+  0597             	
0079+  0597 E5          	pop b
0080+  0598 D8          	push b
0081+  0599 A7 00       	mov bh, 0
0082+  059B FD 87 0F    	and bl, $0F
0083+  059E 74          	mov d, b
0084+  059F 1F 51 05    	mov al, [d + s_hex_digits]
0085+  05A2 E5          	pop b
0086+  05A3 E7          	pop d
0087+  05A4 09          	ret
0088+  05A5             
0089+  05A5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0090+  05A5             ; HEX STRING TO BINARY
0091+  05A5             ; di = destination address
0092+  05A5             ; si = source
0093+  05A5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0094+  05A5             hex_to_int:
0095+  05A5             hex_to_int_L1:
0096+  05A5 F6          	lodsb					; load from [SI] to AL
0097+  05A6 B9 00       	cmp al, 0				; check if ASCII 0
0098+  05A8 C6 B5 05    	jz hex_to_int_ret
0099+  05AB 36          	mov bh, al
0100+  05AC F6          	lodsb
0101+  05AD 2F          	mov bl, al
0102+  05AE 07 79 05    	call atoi				; convert ASCII byte in B to int (to AL)
0103+  05B1 F7          	stosb					; store AL to [DI]
0104+  05B2 0A A5 05    	jmp hex_to_int_L1
0105+  05B5             hex_to_int_ret:
0106+  05B5 09          	ret		
0107+  05B6             
0108+  05B6             
0109+  05B6             
0110+  05B6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  05B6             ; GETCHAR
0112+  05B6             ; char in ah
0113+  05B6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0114+  05B6             getchar:
0115+  05B6 DB          	push al
0116+  05B7             getchar_retry:
0117+  05B7 FD 0C       	sti
0118+  05B9 19 01       	mov al, 1
0119+  05BB 05 03       	syscall sys_io			; receive in AH
0120+  05BD B9 00       	cmp al, 0			; check if any char was receive
0121+  05BF C6 B7 05    	je getchar_retry
0122+  05C2 E8          	pop al
0123+  05C3 09          	ret
0124+  05C4             
0125+  05C4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0126+  05C4             ; PUTCHAR
0127+  05C4             ; char in ah
0128+  05C4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  05C4             putchar:
0130+  05C4 D7          	push a
0131+  05C5 19 00       	mov al, 0
0132+  05C7 05 03       	syscall sys_io			; char in AH
0133+  05C9 E4          	pop a
0134+  05CA 09          	ret
0135+  05CB             
0136+  05CB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0137+  05CB             ;; INPUT A STRING
0138+  05CB             ;; terminates with null
0139+  05CB             ;; pointer in D
0140+  05CB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  05CB             gets:
0142+  05CB D7          	push a
0143+  05CC DA          	push d
0144+  05CD             gets_loop:
0145+  05CD FD 0C       	sti
0146+  05CF 19 01       	mov al, 1
0147+  05D1 05 03       	syscall sys_io			; receive in AH
0148+  05D3 B9 00       	cmp al, 0				; check error code (AL)
0149+  05D5 C6 CD 05    	je gets_loop			; if no char received, retry
0150+  05D8             
0151+  05D8 76 1B       	cmp ah, 27
0152+  05DA C6 FB 05    	je gets_telnet_escape
0153+  05DD 76 0A       	cmp ah, $0A				; LF
0154+  05DF C6 54 06    	je gets_end
0155+  05E2 76 0D       	cmp ah, $0D				; CR
0156+  05E4 C6 54 06    	je gets_end
0157+  05E7 76 5C       	cmp ah, $5C				; '\\'
0158+  05E9 C6 2B 06    	je gets_escape
0159+  05EC             	
0160+  05EC 76 08       	cmp ah, $08			; check for backspace
0161+  05EE C6 F7 05    	je gets_backspace
0162+  05F1             
0163+  05F1 1A          	mov al, ah
0164+  05F2 3E          	mov [d], al
0165+  05F3 79          	inc d
0166+  05F4 0A CD 05    	jmp gets_loop
0167+  05F7             gets_backspace:
0168+  05F7 7F          	dec d
0169+  05F8 0A CD 05    	jmp gets_loop
0170+  05FB             gets_telnet_escape:
0171+  05FB FD 0C       	sti
0172+  05FD 19 01       	mov al, 1
0173+  05FF 05 03       	syscall sys_io				; receive in AH without echo
0174+  0601 B9 00       	cmp al, 0					; check error code (AL)
0175+  0603 C6 FB 05    	je gets_telnet_escape		; if no char received, retry
0176+  0606 76 5B       	cmp ah, '['
0177+  0608 C7 CD 05    	jne gets_loop
0178+  060B             gets_telnet_escape_phase2:
0179+  060B FD 0C       	sti
0180+  060D 19 01       	mov al, 1
0181+  060F 05 03       	syscall sys_io					; receive in AH without echo
0182+  0611 B9 00       	cmp al, 0						; check error code (AL)
0183+  0613 C6 0B 06    	je gets_telnet_escape_phase2	; if no char received, retry
0184+  0616 76 44       	cmp ah, 'D'
0185+  0618 C6 23 06    	je gets_left_arrow
0186+  061B 76 43       	cmp ah, 'C'
0187+  061D C6 27 06    	je gets_right_arrow
0188+  0620 0A CD 05    	jmp gets_loop
0189+  0623             gets_left_arrow:
0190+  0623 7F          	dec d
0191+  0624 0A CD 05    	jmp gets_loop
0192+  0627             gets_right_arrow:
0193+  0627 79          	inc d
0194+  0628 0A CD 05    	jmp gets_loop
0195+  062B             gets_escape:
0196+  062B FD 0C       	sti
0197+  062D 19 01       	mov al, 1
0198+  062F 05 03       	syscall sys_io			; receive in AH
0199+  0631 B9 00       	cmp al, 0				; check error code (AL)
0200+  0633 C6 2B 06    	je gets_escape			; if no char received, retry
0201+  0636 76 6E       	cmp ah, 'n'
0202+  0638 C6 46 06    	je gets_LF
0203+  063B 76 72       	cmp ah, 'r'
0204+  063D C6 4D 06    	je gets_CR
0205+  0640 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0206+  0641 3E          	mov [d], al
0207+  0642 79          	inc d
0208+  0643 0A CD 05    	jmp gets_loop
0209+  0646             gets_LF:
0210+  0646 19 0A       	mov al, $0A
0211+  0648 3E          	mov [d], al
0212+  0649 79          	inc d
0213+  064A 0A CD 05    	jmp gets_loop
0214+  064D             gets_CR:
0215+  064D 19 0D       	mov al, $0D
0216+  064F 3E          	mov [d], al
0217+  0650 79          	inc d
0218+  0651 0A CD 05    	jmp gets_loop
0219+  0654             gets_end:
0220+  0654 19 00       	mov al, 0
0221+  0656 3E          	mov [d], al				; terminate string
0222+  0657 E7          	pop d
0223+  0658 E4          	pop a
0224+  0659 09          	ret
0225+  065A             
0226+  065A             
0227+  065A             
0228+  065A             
0229+  065A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0230+  065A             ;; INPUT TEXT
0231+  065A             ;; terminated with CTRL+D
0232+  065A             ;; pointer in D
0233+  065A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0234+  065A             gettxt:
0235+  065A D7          	push a
0236+  065B DA          	push d
0237+  065C             gettxt_loop:
0238+  065C 19 01       	mov al, 1
0239+  065E 05 03       	syscall sys_io			; receive in AH
0240+  0660 B9 00       	cmp al, 0				; check error code (AL)
0241+  0662 C6 5C 06    	je gettxt_loop		; if no char received, retry
0242+  0665 76 04       	cmp ah, 4			; EOT
0243+  0667 C6 A5 06    	je gettxt_end
0244+  066A 76 08       	cmp ah, $08			; check for backspace
0245+  066C C6 A1 06    	je gettxt_backspace
0246+  066F 76 5C       	cmp ah, $5C				; '\\'
0247+  0671 C6 7A 06    	je gettxt_escape
0248+  0674 1A          	mov al, ah
0249+  0675 3E          	mov [d], al
0250+  0676 79          	inc d
0251+  0677 0A 5C 06    	jmp gettxt_loop
0252+  067A             gettxt_escape:
0253+  067A 19 01       	mov al, 1
0254+  067C 05 03       	syscall sys_io			; receive in AH
0255+  067E B9 00       	cmp al, 0				; check error code (AL)
0256+  0680 C6 7A 06    	je gettxt_escape		; if no char received, retry
0257+  0683 76 6E       	cmp ah, 'n'
0258+  0685 C6 93 06    	je gettxt_LF
0259+  0688 76 72       	cmp ah, 'r'
0260+  068A C6 9A 06    	je gettxt_CR
0261+  068D 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0262+  068E 3E          	mov [d], al
0263+  068F 79          	inc d
0264+  0690 0A 5C 06    	jmp gettxt_loop
0265+  0693             gettxt_LF:
0266+  0693 19 0A       	mov al, $0A
0267+  0695 3E          	mov [d], al
0268+  0696 79          	inc d
0269+  0697 0A 5C 06    	jmp gettxt_loop
0270+  069A             gettxt_CR:
0271+  069A 19 0D       	mov al, $0D
0272+  069C 3E          	mov [d], al
0273+  069D 79          	inc d
0274+  069E 0A 5C 06    	jmp gettxt_loop
0275+  06A1             gettxt_backspace:
0276+  06A1 7F          	dec d
0277+  06A2 0A 5C 06    	jmp gettxt_loop
0278+  06A5             gettxt_end:
0279+  06A5 19 00       	mov al, 0
0280+  06A7 3E          	mov [d], al				; terminate string
0281+  06A8 E7          	pop d
0282+  06A9 E4          	pop a
0283+  06AA 09          	ret
0284+  06AB             
0285+  06AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0286+  06AB             ; PRINT NEW LINE
0287+  06AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  06AB             printnl:
0289+  06AB D7          	push a
0290+  06AC 10 00 0A    	mov a, $0A00
0291+  06AF 05 03       	syscall sys_io
0292+  06B1 10 00 0D    	mov a, $0D00
0293+  06B4 05 03       	syscall sys_io
0294+  06B6 E4          	pop a
0295+  06B7 09          	ret
0296+  06B8             
0297+  06B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0298+  06B8             ; strtoint
0299+  06B8             ; 4 digit hex string number in d
0300+  06B8             ; integer returned in A
0301+  06B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0302+  06B8             strtointx:
0303+  06B8 D8          	push b
0304+  06B9 32          	mov bl, [d]
0305+  06BA 37          	mov bh, bl
0306+  06BB 33 01 00    	mov bl, [d + 1]
0307+  06BE 07 79 05    	call atoi				; convert to int in AL
0308+  06C1 23          	mov ah, al				; move to AH
0309+  06C2 33 02 00    	mov bl, [d + 2]
0310+  06C5 37          	mov bh, bl
0311+  06C6 33 03 00    	mov bl, [d + 3]
0312+  06C9 07 79 05    	call atoi				; convert to int in AL
0313+  06CC E5          	pop b
0314+  06CD 09          	ret
0315+  06CE             
0316+  06CE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0317+  06CE             ; strtoint
0318+  06CE             ; 5 digit base10 string number in d
0319+  06CE             ; integer returned in A
0320+  06CE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0321+  06CE             strtoint:
0322+  06CE E2          	push si
0323+  06CF D8          	push b
0324+  06D0 D9          	push c
0325+  06D1 DA          	push d
0326+  06D2 07 01 05    	call strlen			; get string length in C
0327+  06D5 7E          	dec c
0328+  06D6 FD 4E       	mov si, d
0329+  06D8 12          	mov a, c
0330+  06D9 FD 99       	shl a
0331+  06DB 3B 61 05    	mov d, table_power
0332+  06DE 59          	add d, a
0333+  06DF 38 00 00    	mov c, 0
0334+  06E2             strtoint_L0:
0335+  06E2 F6          	lodsb			; load ASCII to al
0336+  06E3 B9 00       	cmp al, 0
0337+  06E5 C6 F8 06    	je strtoint_end
0338+  06E8 6F 30       	sub al, $30		; make into integer
0339+  06EA 22 00       	mov ah, 0
0340+  06EC 2A          	mov b, [d]
0341+  06ED AC          	mul a, b			; result in B since it fits in 16bits
0342+  06EE 11          	mov a, b
0343+  06EF 28          	mov b, c
0344+  06F0 54          	add a, b
0345+  06F1 39          	mov c, a
0346+  06F2 63 02 00    	sub d, 2
0347+  06F5 0A E2 06    	jmp strtoint_L0
0348+  06F8             strtoint_end:
0349+  06F8 12          	mov a, c
0350+  06F9 E7          	pop d
0351+  06FA E6          	pop c
0352+  06FB E5          	pop b
0353+  06FC EF          	pop si
0354+  06FD 09          	ret
0355+  06FE             
0356+  06FE             
0357+  06FE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0358+  06FE             ; PRINT NULL TERMINATED STRING
0359+  06FE             ; pointer in D
0360+  06FE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0361+  06FE             puts:
0362+  06FE D7          	push a
0363+  06FF DA          	push d
0364+  0700             puts_L1:
0365+  0700 1E          	mov al, [d]
0366+  0701 B9 00       	cmp al, 0
0367+  0703 C6 0F 07    	jz puts_END
0368+  0706 23          	mov ah, al
0369+  0707 19 00       	mov al, 0
0370+  0709 05 03       	syscall sys_io
0371+  070B 79          	inc d
0372+  070C 0A 00 07    	jmp puts_L1
0373+  070F             puts_END:
0374+  070F E7          	pop d
0375+  0710 E4          	pop a
0376+  0711 09          	ret
0377+  0712             
0378+  0712             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  0712             ; PRINT N SIZE STRING
0380+  0712             ; pointer in D
0381+  0712             ; size in C
0382+  0712             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0383+  0712             putsn:
0384+  0712 DB          	push al
0385+  0713 DA          	push d
0386+  0714 D9          	push c
0387+  0715             putsn_L0:
0388+  0715 1E          	mov al, [d]
0389+  0716 23          	mov ah, al
0390+  0717 19 00       	mov al, 0
0391+  0719 05 03       	syscall sys_io
0392+  071B 79          	inc d
0393+  071C 7E          	dec c	
0394+  071D C2 00 00    	cmp c, 0
0395+  0720 C7 15 07    	jne putsn_L0
0396+  0723             putsn_end:
0397+  0723 E6          	pop c
0398+  0724 E7          	pop d
0399+  0725 E8          	pop al
0400+  0726 09          	ret
0401+  0727             
0402+  0727             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0403+  0727             ; print 16bit decimal number
0404+  0727             ; input number in A
0405+  0727             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  0727             print_u16d:
0407+  0727 D7          	push a
0408+  0728 D8          	push b
0409+  0729 26 10 27    	mov b, 10000
0410+  072C AE          	div a, b			; get 10000 coeff.
0411+  072D 07 53 07    	call print_number
0412+  0730 11          	mov a, b
0413+  0731 26 E8 03    	mov b, 1000
0414+  0734 AE          	div a, b			; get 10000 coeff.
0415+  0735 07 53 07    	call print_number
0416+  0738 11          	mov a, b
0417+  0739 26 64 00    	mov b, 100
0418+  073C AE          	div a, b
0419+  073D 07 53 07    	call print_number
0420+  0740 11          	mov a, b
0421+  0741 26 0A 00    	mov b, 10
0422+  0744 AE          	div a, b
0423+  0745 07 53 07    	call print_number
0424+  0748 11          	mov a, b
0425+  0749 6A 30       	add al, $30
0426+  074B 23          	mov ah, al
0427+  074C 19 00       	mov al, 0
0428+  074E 05 03       	syscall sys_io	; print coeff
0429+  0750 E5          	pop b
0430+  0751 E4          	pop a
0431+  0752 09          	ret
0432+  0753             
0433+  0753             
0434+  0753             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0435+  0753             ; if A == 0, print space
0436+  0753             ; else print A
0437+  0753             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0438+  0753             print_number:
0439+  0753 6A 30       	add al, $30
0440+  0755 23          	mov ah, al
0441+  0756 07 C4 05    	call putchar
0442+  0759 09          	ret
0443+  075A             
0444+  075A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  075A             ; PRINT 16BIT HEX INTEGER
0446+  075A             ; integer value in reg B
0447+  075A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  075A             print_u16x:
0449+  075A D7          	push a
0450+  075B D8          	push b
0451+  075C DD          	push bl
0452+  075D 30          	mov bl, bh
0453+  075E 07 8B 05    	call itoa				; convert bh to char in A
0454+  0761 2F          	mov bl, al				; save al
0455+  0762 19 00       	mov al, 0
0456+  0764 05 03       	syscall sys_io				; display AH
0457+  0766 24          	mov ah, bl				; retrieve al
0458+  0767 19 00       	mov al, 0
0459+  0769 05 03       	syscall sys_io				; display AL
0460+  076B             
0461+  076B EA          	pop bl
0462+  076C 07 8B 05    	call itoa				; convert bh to char in A
0463+  076F 2F          	mov bl, al				; save al
0464+  0770 19 00       	mov al, 0
0465+  0772 05 03       	syscall sys_io				; display AH
0466+  0774 24          	mov ah, bl				; retrieve al
0467+  0775 19 00       	mov al, 0
0468+  0777 05 03       	syscall sys_io				; display AL
0469+  0779             
0470+  0779 E5          	pop b
0471+  077A E4          	pop a
0472+  077B 09          	ret
0473+  077C             
0474+  077C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0475+  077C             ; INPUT 16BIT HEX INTEGER
0476+  077C             ; read 16bit integer into A
0477+  077C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0478+  077C             scan_u16x:
0479+  077C F8 10 00    	enter 16
0480+  077F D8          	push b
0481+  0780 DA          	push d
0482+  0781             
0483+  0781 FA F1 FF    	lea d, [bp + -15]
0484+  0784 07 CB 05    	call gets				; get number
0485+  0787             
0486+  0787 32          	mov bl, [d]
0487+  0788 37          	mov bh, bl
0488+  0789 33 01 00    	mov bl, [d + 1]
0489+  078C 07 79 05    	call atoi				; convert to int in AL
0490+  078F 23          	mov ah, al				; move to AH
0491+  0790             
0492+  0790 33 02 00    	mov bl, [d + 2]
0493+  0793 37          	mov bh, bl
0494+  0794 33 03 00    	mov bl, [d + 3]
0495+  0797 07 79 05    	call atoi				; convert to int in AL
0496+  079A             
0497+  079A E7          	pop d
0498+  079B E5          	pop b
0499+  079C F9          	leave
0500+  079D 09          	ret
0501+  079E             
0502+  079E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0503+  079E             ; PRINT 8bit HEX INTEGER
0504+  079E             ; integer value in reg bl
0505+  079E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0506+  079E             print_u8x:
0507+  079E D7          	push a
0508+  079F DD          	push bl
0509+  07A0             
0510+  07A0 07 8B 05    	call itoa				; convert bl to char in A
0511+  07A3 2F          	mov bl, al				; save al
0512+  07A4 19 00       	mov al, 0
0513+  07A6 05 03       	syscall sys_io				; display AH
0514+  07A8 24          	mov ah, bl				; retrieve al
0515+  07A9 19 00       	mov al, 0
0516+  07AB 05 03       	syscall sys_io				; display AL
0517+  07AD             
0518+  07AD EA          	pop bl
0519+  07AE E4          	pop a
0520+  07AF 09          	ret
0521+  07B0             
0522+  07B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0523+  07B0             ; print 8bit decimal unsigned number
0524+  07B0             ; input number in AL
0525+  07B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0526+  07B0             print_u8d:
0527+  07B0 D7          	push a
0528+  07B1 D8          	push b
0529+  07B2             
0530+  07B2 22 00       	mov ah, 0
0531+  07B4 26 64 00    	mov b, 100
0532+  07B7 AE          	div a, b
0533+  07B8 D8          	push b			; save remainder
0534+  07B9 B9 00       	cmp al, 0
0535+  07BB C6 C5 07    	je skip100
0536+  07BE 6A 30       	add al, $30
0537+  07C0 23          	mov ah, al
0538+  07C1 19 00       	mov al, 0
0539+  07C3 05 03       	syscall sys_io	; print coeff
0540+  07C5             skip100:
0541+  07C5 E4          	pop a
0542+  07C6 22 00       	mov ah, 0
0543+  07C8 26 0A 00    	mov b, 10
0544+  07CB AE          	div a, b
0545+  07CC D8          	push b			; save remainder
0546+  07CD B9 00       	cmp al, 0
0547+  07CF C6 D9 07    	je skip10
0548+  07D2 6A 30       	add al, $30
0549+  07D4 23          	mov ah, al
0550+  07D5 19 00       	mov al, 0
0551+  07D7 05 03       	syscall sys_io	; print coeff
0552+  07D9             skip10:
0553+  07D9 E4          	pop a
0554+  07DA 1B          	mov al, bl
0555+  07DB 6A 30       	add al, $30
0556+  07DD 23          	mov ah, al
0557+  07DE 19 00       	mov al, 0
0558+  07E0 05 03       	syscall sys_io	; print coeff
0559+  07E2 E5          	pop b
0560+  07E3 E4          	pop a
0561+  07E4 09          	ret
0562+  07E5             
0563+  07E5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0564+  07E5             ; INPUT 8BIT HEX INTEGER
0565+  07E5             ; read 8bit integer into AL
0566+  07E5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0567+  07E5             scan_u8x:
0568+  07E5 F8 04 00    	enter 4
0569+  07E8 D8          	push b
0570+  07E9 DA          	push d
0571+  07EA             
0572+  07EA FA FD FF    	lea d, [bp + -3]
0573+  07ED 07 CB 05    	call gets				; get number
0574+  07F0             
0575+  07F0 32          	mov bl, [d]
0576+  07F1 37          	mov bh, bl
0577+  07F2 33 01 00    	mov bl, [d + 1]
0578+  07F5 07 79 05    	call atoi				; convert to int in AL
0579+  07F8             
0580+  07F8 E7          	pop d
0581+  07F9 E5          	pop b
0582+  07FA F9          	leave
0583+  07FB 09          	ret
0584+  07FC             
0585+  07FC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0586+  07FC             ; input decimal number
0587+  07FC             ; result in A
0588+  07FC             ; 655'\0'
0589+  07FC             ; low--------high
0590+  07FC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0591+  07FC             scan_u16d:
0592+  07FC F8 08 00    	enter 8
0593+  07FF E2          	push si
0594+  0800 D8          	push b
0595+  0801 D9          	push c
0596+  0802 DA          	push d
0597+  0803 FA F9 FF    	lea d, [bp +- 7]
0598+  0806 07 CB 05    	call gets
0599+  0809 07 01 05    	call strlen			; get string length in C
0600+  080C 7E          	dec c
0601+  080D FD 4E       	mov si, d
0602+  080F 12          	mov a, c
0603+  0810 FD 99       	shl a
0604+  0812 3B 61 05    	mov d, table_power
0605+  0815 59          	add d, a
0606+  0816 38 00 00    	mov c, 0
0607+  0819             mul_loop:
0608+  0819 F6          	lodsb			; load ASCII to al
0609+  081A B9 00       	cmp al, 0
0610+  081C C6 2F 08    	je mul_exit
0611+  081F 6F 30       	sub al, $30		; make into integer
0612+  0821 22 00       	mov ah, 0
0613+  0823 2A          	mov b, [d]
0614+  0824 AC          	mul a, b			; result in B since it fits in 16bits
0615+  0825 11          	mov a, b
0616+  0826 28          	mov b, c
0617+  0827 54          	add a, b
0618+  0828 39          	mov c, a
0619+  0829 63 02 00    	sub d, 2
0620+  082C 0A 19 08    	jmp mul_loop
0621+  082F             mul_exit:
0622+  082F 12          	mov a, c
0623+  0830 E7          	pop d
0624+  0831 E6          	pop c
0625+  0832 E5          	pop b
0626+  0833 EF          	pop si
0627+  0834 F9          	leave
0628+  0835 09          	ret
0049   0836             ; --- end include block
0050   0836             
0051   0836             .end
tasm: Number of errors = 0
