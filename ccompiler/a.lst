0001   0000             ; --- FILENAME: strcat.c
0002   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0400             .org PROC_TEXT_ORG
0004   0400             
0005   0400             ; --- BEGIN TEXT BLOCK
0006   0400             main:
0007   0400 D2            push bp
0008   0401 9B            mov bp, sp
0009   0402 29 73 05      mov b, [p]
0010   0405 74            mov d, b
0011   0406 26 01 00      mov b, 1
0012   0409 1B            mov al, bl
0013   040A 3E            mov [d], al
0014   040B 26 00 00      mov b, 0
0015   040E F9            leave
0016   040F 05 0B         syscall sys_terminate_proc
0017   0411             _strlen:
0018   0411 D2            push bp
0019   0412 9B            mov bp, sp
0020   0413 52 02 00      sub sp, 2 ; length
0021   0416 26 00 00      mov b, 0
0022   0419 D7            push a
0023   041A 11            mov a, b
0024   041B 45 FF FF      mov [bp + -1], a ; length
0025   041E E4            pop a
0026   041F             _while1_cond:
0027   041F FA 05 00      lea d, [bp + 5] ; str
0028   0422 2A            mov b, [d]
0029   0423 D7            push a
0030   0424 11            mov a, b
0031   0425 2C FF FF      mov b, [bp + -1] ; length
0032   0428 54            add a, b
0033   0429 27            mov b, a
0034   042A E4            pop a
0035   042B 74            mov d, b
0036   042C D7            push a
0037   042D 11            mov a, b
0038   042E 26 00 00      mov b, 0
0039   0431 B0            cmp a, b
0040   0432 0E            lodflgs
0041   0433 87 01         and al, %00000001
0042   0435 8F 01         xor al, %00000001 ; !=
0043   0437 B9 00         cmp al, 0
0044   0439 0E            lodflgs
0045   043A 96            not al
0046   043B 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0047   043D 22 00         mov ah, 0
0048   043F 27            mov b, a
0049   0440 E4            pop a
0050   0441 C0 00 00      cmp b, 0
0051   0444 C6 55 04      je _while1_exit
0052   0447             _while1_block:
0053   0447 2C FF FF      mov b, [bp + -1] ; length
0054   044A FD 77         inc b
0055   044C D7            push a
0056   044D 11            mov a, b
0057   044E 45 FF FF      mov [bp + -1], a ; length
0058   0451 E4            pop a
0059   0452 0A 1F 04      jmp _while1_cond
0060   0455             _while1_exit:
0061   0455 2C FF FF      mov b, [bp + -1] ; length
0062   0458 F9            leave
0063   0459 09            ret
0064   045A             _strcat:
0065   045A D2            push bp
0066   045B 9B            mov bp, sp
0067   045C 52 02 00      sub sp, 2 ; dest_len
0068   045F 52 02 00      sub sp, 2 ; i
0069   0462 FA 07 00      lea d, [bp + 7] ; dest
0070   0465 2A            mov b, [d]
0071   0466 FD AB         swp b
0072   0468 D8            push b
0073   0469 07 11 04      call _strlen
0074   046C 51 02 00      add sp, 2
0075   046F D7            push a
0076   0470 11            mov a, b
0077   0471 45 FF FF      mov [bp + -1], a ; dest_len
0078   0474 E4            pop a
0079   0475             _for2_init:
0080   0475 26 00 00      mov b, 0
0081   0478 D7            push a
0082   0479 11            mov a, b
0083   047A 45 FD FF      mov [bp + -3], a ; i
0084   047D E4            pop a
0085   047E             _for2_cond:
0086   047E FA 05 00      lea d, [bp + 5] ; src
0087   0481 2A            mov b, [d]
0088   0482 D7            push a
0089   0483 11            mov a, b
0090   0484 2C FD FF      mov b, [bp + -3] ; i
0091   0487 54            add a, b
0092   0488 27            mov b, a
0093   0489 E4            pop a
0094   048A 74            mov d, b
0095   048B 32            mov bl, [d]
0096   048C A7 00         mov bh, 0
0097   048E D7            push a
0098   048F 11            mov a, b
0099   0490 26 00 00      mov b, 0
0100   0493 B0            cmp a, b
0101   0494 0E            lodflgs
0102   0495 87 01         and al, %00000001
0103   0497 8F 01         xor al, %00000001 ; !=
0104   0499 B9 00         cmp al, 0
0105   049B 0E            lodflgs
0106   049C 96            not al
0107   049D 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0108   049F 22 00         mov ah, 0
0109   04A1 27            mov b, a
0110   04A2 E4            pop a
0111   04A3 C0 00 00      cmp b, 0
0112   04A6 C6 D9 04      je _for2_exit
0113   04A9             _for2_block:
0114   04A9 FA 07 00      lea d, [bp + 7] ; dest
0115   04AC 2A            mov b, [d]
0116   04AD D7            push a
0117   04AE 11            mov a, b
0118   04AF 2C FF FF      mov b, [bp + -1] ; dest_len
0119   04B2 54            add a, b
0120   04B3 27            mov b, a
0121   04B4 11            mov a, b
0122   04B5 2C FD FF      mov b, [bp + -3] ; i
0123   04B8 54            add a, b
0124   04B9 27            mov b, a
0125   04BA E4            pop a
0126   04BB 74            mov d, b
0127   04BC FA 05 00      lea d, [bp + 5] ; src
0128   04BF 2A            mov b, [d]
0129   04C0 D7            push a
0130   04C1 11            mov a, b
0131   04C2 2C FD FF      mov b, [bp + -3] ; i
0132   04C5 54            add a, b
0133   04C6 27            mov b, a
0134   04C7 E4            pop a
0135   04C8 74            mov d, b
0136   04C9 11            mov a, b
0137   04CA 43            mov [d], a
0138   04CB             _for2_update:
0139   04CB 2C FD FF      mov b, [bp + -3] ; i
0140   04CE FD 77         inc b
0141   04D0 D7            push a
0142   04D1 11            mov a, b
0143   04D2 45 FD FF      mov [bp + -3], a ; i
0144   04D5 E4            pop a
0145   04D6 0A 7E 04      jmp _for2_cond
0146   04D9             _for2_exit:
0147   04D9 FA 07 00      lea d, [bp + 7] ; dest
0148   04DC 2A            mov b, [d]
0149   04DD D7            push a
0150   04DE 11            mov a, b
0151   04DF 2C FF FF      mov b, [bp + -1] ; dest_len
0152   04E2 54            add a, b
0153   04E3 27            mov b, a
0154   04E4 11            mov a, b
0155   04E5 2C FD FF      mov b, [bp + -3] ; i
0156   04E8 54            add a, b
0157   04E9 27            mov b, a
0158   04EA E4            pop a
0159   04EB 74            mov d, b
0160   04EC 26 00 00      mov b, 0
0161   04EF 11            mov a, b
0162   04F0 43            mov [d], a
0163   04F1 FA 07 00      lea d, [bp + 7] ; dest
0164   04F4 2A            mov b, [d]
0165   04F5 F9            leave
0166   04F6 09            ret
0167   04F7             scann:
0168   04F7 D2            push bp
0169   04F8 9B            mov bp, sp
0170   04F9 52 02 00      sub sp, 2 ; m
0171   04FC             
0172   04FC             ; --- BEGIN INLINE ASM BLOCK
0173   04FC 07 BF 08      call scan_u16d
0174   04FF 45 FF FF      mov [bp + -1], a
0175   0502             ; --- END INLINE ASM BLOCK
0176   0502             
0177   0502 FA 05 00      lea d, [bp + 5] ; n
0178   0505 2A            mov b, [d]
0179   0506 74            mov d, b
0180   0507 2C FF FF      mov b, [bp + -1] ; m
0181   050A 11            mov a, b
0182   050B 43            mov [d], a
0183   050C F9            leave
0184   050D 09            ret
0185   050E             printn:
0186   050E D2            push bp
0187   050F 9B            mov bp, sp
0188   0510             
0189   0510             ; --- BEGIN INLINE ASM BLOCK
0190   0510 17 05 00      mov a, [bp + 5]
0191   0513 07 EA 07      call print_u16d
0192   0516             ; --- END INLINE ASM BLOCK
0193   0516             
0194   0516 F9            leave
0195   0517 09            ret
0196   0518             print:
0197   0518 D2            push bp
0198   0519 9B            mov bp, sp
0199   051A             
0200   051A             ; --- BEGIN INLINE ASM BLOCK
0201   051A 17 05 00      mov a, [bp + 5]
0202   051D 3C            mov d, a
0203   051E 07 C1 07      call puts
0204   0521             ; --- END INLINE ASM BLOCK
0205   0521             
0206   0521 F9            leave
0207   0522 09            ret
0208   0523             ; --- END TEXT BLOCK
0209   0523             
0210   0523             ; --- BEGIN DATA BLOCK
0211   0523             s1_data: 
0212   0523 48 00 65 00 .dw 'H', 'e', 'l', 'l', 'o', 0,
0212   0527 6C 00 6C 00 
0212   052B 6F 00 00 00 
0213   052F 00 00 00 00 .fill 44, 0
0213   0533 00 00 00 00 
0213   0537 00 00 00 00 
0213   053B 00 00 00 00 
0213   053F 00 00 00 00 
0213   0543 00 00 00 00 
0213   0547 00 00 00 00 
0213   054B 00 00 00 00 
0213   054F 00 00 00 00 
0213   0553 00 00 00 00 
0213   0557 00 00 00 00 
0214   055B 23 05       s1: .dw s1_data
0215   055D 2E 20 4D 79 s2_data: .db ". My name is Sol-1.", 0
0215   0561 20 6E 61 6D 
0215   0565 65 20 69 73 
0215   0569 20 53 6F 6C 
0215   056D 2D 31 2E 00 
0216   0571 5D 05       s2: .dw s2_data
0217   0573 00 00       p: .fill 2, 0
0218   0575             ; --- END DATA BLOCK
0219   0575             
0220   0575             ; --- BEGIN INCLUDE BLOCK
0221   0575             .include "lib/stdio.asm"
0001+  0575             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0575             ; stdio.s
0003+  0575             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0575             .include "lib/string.asm"
0001++ 0575             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0575             ; string.s
0003++ 0575             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0575             
0005++ 0575             
0006++ 0575             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0575             ; strrev
0008++ 0575             ; reverse a string
0009++ 0575             ; D = string address
0010++ 0575             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0575             ; 01234
0012++ 0575             strrev:
0013++ 0575 4B          	pusha
0014++ 0576 07 BC 05    	call strlen	; length in C
0015++ 0579 12          	mov a, c
0016++ 057A AF 01 00    	cmp a, 1
0017++ 057D D0 97 05    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0580 7D          	dec a
0019++ 0581 FD 4E       	mov si, d	; beginning of string
0020++ 0583 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0585 59          	add d, a	; end of string
0022++ 0586 12          	mov a, c
0023++ 0587 FD 9B       	shr a		; divide by 2
0024++ 0589 39          	mov c, a	; C now counts the steps
0025++ 058A             strrev_L0:
0026++ 058A 32          	mov bl, [d]	; save load right-side char into BL
0027++ 058B F6          	lodsb		; load left-side char into AL; increase SI
0028++ 058C 3E          	mov [d], al	; store left char into right side
0029++ 058D 1B          	mov al, bl
0030++ 058E F7          	stosb		; store right-side char into left-side; increase DI
0031++ 058F 7E          	dec c
0032++ 0590 7F          	dec d
0033++ 0591 C2 00 00    	cmp c, 0
0034++ 0594 C7 8A 05    	jne strrev_L0
0035++ 0597             strrev_end:
0036++ 0597 4C          	popa
0037++ 0598 09          	ret
0038++ 0599             	
0039++ 0599             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0599             ; strchr
0041++ 0599             ; search string in D for char in AL
0042++ 0599             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0599             strchr:
0044++ 0599             strchr_L0:
0045++ 0599 32          	mov bl, [d]
0046++ 059A C1 00       	cmp bl, 0
0047++ 059C C6 A7 05    	je strchr_end
0048++ 059F BA          	cmp al, bl
0049++ 05A0 C6 A7 05    	je strchr_end
0050++ 05A3 79          	inc d
0051++ 05A4 0A 99 05    	jmp strchr_L0
0052++ 05A7             strchr_end:
0053++ 05A7 1B          	mov al, bl
0054++ 05A8 09          	ret
0055++ 05A9             
0056++ 05A9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 05A9             ; strstr
0058++ 05A9             ; find sub-string
0059++ 05A9             ; str1 in SI
0060++ 05A9             ; str2 in DI
0061++ 05A9             ; SI points to end of source string
0062++ 05A9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 05A9             strstr:
0064++ 05A9 DB          	push al
0065++ 05AA DA          	push d
0066++ 05AB E3          	push di
0067++ 05AC             strstr_loop:
0068++ 05AC F3          	cmpsb					; compare a byte of the strings
0069++ 05AD C7 B8 05    	jne strstr_ret
0070++ 05B0 FC 00 00    	lea d, [di + 0]
0071++ 05B3 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 05B5 C7 AC 05    	jne strstr_loop				; equal chars but not at end
0073++ 05B8             strstr_ret:
0074++ 05B8 F0          	pop di
0075++ 05B9 E7          	pop d
0076++ 05BA E8          	pop al
0077++ 05BB 09          	ret
0078++ 05BC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 05BC             ; length of null terminated string
0080++ 05BC             ; result in C
0081++ 05BC             ; pointer in D
0082++ 05BC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 05BC             strlen:
0084++ 05BC DA          	push d
0085++ 05BD 38 00 00    	mov c, 0
0086++ 05C0             strlen_L1:
0087++ 05C0 BD 00       	cmp byte [d], 0
0088++ 05C2 C6 CA 05    	je strlen_ret
0089++ 05C5 79          	inc d
0090++ 05C6 78          	inc c
0091++ 05C7 0A C0 05    	jmp strlen_L1
0092++ 05CA             strlen_ret:
0093++ 05CA E7          	pop d
0094++ 05CB 09          	ret
0095++ 05CC             
0096++ 05CC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 05CC             ; STRCMP
0098++ 05CC             ; compare two strings
0099++ 05CC             ; str1 in SI
0100++ 05CC             ; str2 in DI
0101++ 05CC             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 05CC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 05CC             strcmp:
0104++ 05CC DB          	push al
0105++ 05CD DA          	push d
0106++ 05CE E3          	push di
0107++ 05CF E2          	push si
0108++ 05D0             strcmp_loop:
0109++ 05D0 F3          	cmpsb					; compare a byte of the strings
0110++ 05D1 C7 DC 05    	jne strcmp_ret
0111++ 05D4 FB FF FF    	lea d, [si +- 1]
0112++ 05D7 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 05D9 C7 D0 05    	jne strcmp_loop				; equal chars but not at end
0114++ 05DC             strcmp_ret:
0115++ 05DC EF          	pop si
0116++ 05DD F0          	pop di
0117++ 05DE E7          	pop d
0118++ 05DF E8          	pop al
0119++ 05E0 09          	ret
0120++ 05E1             
0121++ 05E1             
0122++ 05E1             ; STRCPY
0123++ 05E1             ; copy null terminated string from SI to DI
0124++ 05E1             ; source in SI
0125++ 05E1             ; destination in DI
0126++ 05E1             strcpy:
0127++ 05E1 E2          	push si
0128++ 05E2 E3          	push di
0129++ 05E3 DB          	push al
0130++ 05E4             strcpy_L1:
0131++ 05E4 F6          	lodsb
0132++ 05E5 F7          	stosb
0133++ 05E6 B9 00       	cmp al, 0
0134++ 05E8 C7 E4 05    	jne strcpy_L1
0135++ 05EB             strcpy_end:
0136++ 05EB E8          	pop al
0137++ 05EC F0          	pop di
0138++ 05ED EF          	pop si
0139++ 05EE 09          	ret
0140++ 05EF             
0141++ 05EF             ; STRCAT
0142++ 05EF             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 05EF             ; source in SI
0144++ 05EF             ; destination in DI
0145++ 05EF             strcat:
0146++ 05EF E2          	push si
0147++ 05F0 E3          	push di
0148++ 05F1 D7          	push a
0149++ 05F2 DA          	push d
0150++ 05F3 50          	mov a, di
0151++ 05F4 3C          	mov d, a
0152++ 05F5             strcat_goto_end_L1:
0153++ 05F5 BD 00       	cmp byte[d], 0
0154++ 05F7 C6 FE 05    	je strcat_start
0155++ 05FA 79          	inc d
0156++ 05FB 0A F5 05    	jmp strcat_goto_end_L1
0157++ 05FE             strcat_start:
0158++ 05FE FD 50       	mov di, d
0159++ 0600             strcat_L1:
0160++ 0600 F6          	lodsb
0161++ 0601 F7          	stosb
0162++ 0602 B9 00       	cmp al, 0
0163++ 0604 C7 00 06    	jne strcat_L1
0164++ 0607             strcat_end:
0165++ 0607 E7          	pop d
0166++ 0608 E4          	pop a
0167++ 0609 F0          	pop di
0168++ 060A EF          	pop si
0169++ 060B 09          	ret
0005+  060C             
0006+  060C 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  0610 34 35 36 37 
0006+  0614 38 39 41 42 
0006+  0618 43 44 45 46 
0007+  061C 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  0620 1B 5B 48 00 
0008+  0624             
0009+  0624 01 00       table_power:.dw 1
0010+  0626 0A 00       			.dw 10
0011+  0628 64 00       			.dw 100
0012+  062A E8 03       			.dw 1000
0013+  062C 10 27       			.dw 10000
0014+  062E             
0015+  062E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  062E             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  062E             ; ASCII in BL
0018+  062E             ; result in AL
0019+  062E             ; ascii for F = 0100 0110
0020+  062E             ; ascii for 9 = 0011 1001
0021+  062E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  062E             hex_ascii_encode:
0023+  062E 1B          	mov al, bl
0024+  062F 93 40       	test al, $40				; test if letter or number
0025+  0631 C7 37 06    	jnz hex_letter
0026+  0634 87 0F       	and al, $0F				; get number
0027+  0636 09          	ret
0028+  0637             hex_letter:
0029+  0637 87 0F       	and al, $0F				; get letter
0030+  0639 6A 09       	add al, 9
0031+  063B 09          	ret
0032+  063C             
0033+  063C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  063C             ; ATOI
0035+  063C             ; 2 letter hex string in B
0036+  063C             ; 8bit integer returned in AL
0037+  063C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  063C             atoi:
0039+  063C D8          	push b
0040+  063D 07 2E 06    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  0640 30          	mov bl, bh
0042+  0641 DB          	push al					; save a
0043+  0642 07 2E 06    	call hex_ascii_encode
0044+  0645 EA          	pop bl	
0045+  0646 FD 9E 04    	shl al, 4
0046+  0649 8C          	or al, bl
0047+  064A E5          	pop b
0048+  064B 09          	ret	
0049+  064C             
0050+  064C             
0051+  064C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  064C             ; printf
0053+  064C             ; no need for explanations!
0054+  064C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  064C             printf:
0056+  064C 09          	ret
0057+  064D             
0058+  064D             
0059+  064D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  064D             ; scanf
0061+  064D             ; no need for explanations!
0062+  064D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  064D             scanf:
0064+  064D 09          	ret
0065+  064E             
0066+  064E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  064E             ; ITOA
0068+  064E             ; 8bit value in BL
0069+  064E             ; 2 byte ASCII result in A
0070+  064E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  064E             itoa:
0072+  064E DA          	push d
0073+  064F D8          	push b
0074+  0650 A7 00       	mov bh, 0
0075+  0652 FD A4 04    	shr bl, 4	
0076+  0655 74          	mov d, b
0077+  0656 1F 0C 06    	mov al, [d + s_hex_digits]
0078+  0659 23          	mov ah, al
0079+  065A             	
0080+  065A E5          	pop b
0081+  065B D8          	push b
0082+  065C A7 00       	mov bh, 0
0083+  065E FD 87 0F    	and bl, $0F
0084+  0661 74          	mov d, b
0085+  0662 1F 0C 06    	mov al, [d + s_hex_digits]
0086+  0665 E5          	pop b
0087+  0666 E7          	pop d
0088+  0667 09          	ret
0089+  0668             
0090+  0668             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  0668             ; HEX STRING TO BINARY
0092+  0668             ; di = destination address
0093+  0668             ; si = source
0094+  0668             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  0668             hex_to_int:
0096+  0668             hex_to_int_L1:
0097+  0668 F6          	lodsb					; load from [SI] to AL
0098+  0669 B9 00       	cmp al, 0				; check if ASCII 0
0099+  066B C6 78 06    	jz hex_to_int_ret
0100+  066E 36          	mov bh, al
0101+  066F F6          	lodsb
0102+  0670 2F          	mov bl, al
0103+  0671 07 3C 06    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  0674 F7          	stosb					; store AL to [DI]
0105+  0675 0A 68 06    	jmp hex_to_int_L1
0106+  0678             hex_to_int_ret:
0107+  0678 09          	ret		
0108+  0679             
0109+  0679             
0110+  0679             
0111+  0679             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  0679             ; GETCHAR
0113+  0679             ; char in ah
0114+  0679             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  0679             getchar:
0116+  0679 DB          	push al
0117+  067A             getchar_retry:
0118+  067A FD 0C       	sti
0119+  067C 19 01       	mov al, 1
0120+  067E 05 03       	syscall sys_io			; receive in AH
0121+  0680 B9 00       	cmp al, 0			; check if any char was receive
0122+  0682 C6 7A 06    	je getchar_retry
0123+  0685 E8          	pop al
0124+  0686 09          	ret
0125+  0687             
0126+  0687             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  0687             ; PUTCHAR
0128+  0687             ; char in ah
0129+  0687             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0687             putchar:
0131+  0687 D7          	push a
0132+  0688 19 00       	mov al, 0
0133+  068A 05 03       	syscall sys_io			; char in AH
0134+  068C E4          	pop a
0135+  068D 09          	ret
0136+  068E             
0137+  068E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  068E             ;; INPUT A STRING
0139+  068E             ;; terminates with null
0140+  068E             ;; pointer in D
0141+  068E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  068E             gets:
0143+  068E D7          	push a
0144+  068F DA          	push d
0145+  0690             gets_loop:
0146+  0690 FD 0C       	sti
0147+  0692 19 01       	mov al, 1
0148+  0694 05 03       	syscall sys_io			; receive in AH
0149+  0696 B9 00       	cmp al, 0				; check error code (AL)
0150+  0698 C6 90 06    	je gets_loop			; if no char received, retry
0151+  069B             
0152+  069B 76 1B       	cmp ah, 27
0153+  069D C6 BE 06    	je gets_telnet_escape
0154+  06A0 76 0A       	cmp ah, $0A				; LF
0155+  06A2 C6 17 07    	je gets_end
0156+  06A5 76 0D       	cmp ah, $0D				; CR
0157+  06A7 C6 17 07    	je gets_end
0158+  06AA 76 5C       	cmp ah, $5C				; '\\'
0159+  06AC C6 EE 06    	je gets_escape
0160+  06AF             	
0161+  06AF 76 08       	cmp ah, $08			; check for backspace
0162+  06B1 C6 BA 06    	je gets_backspace
0163+  06B4             
0164+  06B4 1A          	mov al, ah
0165+  06B5 3E          	mov [d], al
0166+  06B6 79          	inc d
0167+  06B7 0A 90 06    	jmp gets_loop
0168+  06BA             gets_backspace:
0169+  06BA 7F          	dec d
0170+  06BB 0A 90 06    	jmp gets_loop
0171+  06BE             gets_telnet_escape:
0172+  06BE FD 0C       	sti
0173+  06C0 19 01       	mov al, 1
0174+  06C2 05 03       	syscall sys_io				; receive in AH without echo
0175+  06C4 B9 00       	cmp al, 0					; check error code (AL)
0176+  06C6 C6 BE 06    	je gets_telnet_escape		; if no char received, retry
0177+  06C9 76 5B       	cmp ah, '['
0178+  06CB C7 90 06    	jne gets_loop
0179+  06CE             gets_telnet_escape_phase2:
0180+  06CE FD 0C       	sti
0181+  06D0 19 01       	mov al, 1
0182+  06D2 05 03       	syscall sys_io					; receive in AH without echo
0183+  06D4 B9 00       	cmp al, 0						; check error code (AL)
0184+  06D6 C6 CE 06    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  06D9 76 44       	cmp ah, 'D'
0186+  06DB C6 E6 06    	je gets_left_arrow
0187+  06DE 76 43       	cmp ah, 'C'
0188+  06E0 C6 EA 06    	je gets_right_arrow
0189+  06E3 0A 90 06    	jmp gets_loop
0190+  06E6             gets_left_arrow:
0191+  06E6 7F          	dec d
0192+  06E7 0A 90 06    	jmp gets_loop
0193+  06EA             gets_right_arrow:
0194+  06EA 79          	inc d
0195+  06EB 0A 90 06    	jmp gets_loop
0196+  06EE             gets_escape:
0197+  06EE FD 0C       	sti
0198+  06F0 19 01       	mov al, 1
0199+  06F2 05 03       	syscall sys_io			; receive in AH
0200+  06F4 B9 00       	cmp al, 0				; check error code (AL)
0201+  06F6 C6 EE 06    	je gets_escape			; if no char received, retry
0202+  06F9 76 6E       	cmp ah, 'n'
0203+  06FB C6 09 07    	je gets_LF
0204+  06FE 76 72       	cmp ah, 'r'
0205+  0700 C6 10 07    	je gets_CR
0206+  0703 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  0704 3E          	mov [d], al
0208+  0705 79          	inc d
0209+  0706 0A 90 06    	jmp gets_loop
0210+  0709             gets_LF:
0211+  0709 19 0A       	mov al, $0A
0212+  070B 3E          	mov [d], al
0213+  070C 79          	inc d
0214+  070D 0A 90 06    	jmp gets_loop
0215+  0710             gets_CR:
0216+  0710 19 0D       	mov al, $0D
0217+  0712 3E          	mov [d], al
0218+  0713 79          	inc d
0219+  0714 0A 90 06    	jmp gets_loop
0220+  0717             gets_end:
0221+  0717 19 00       	mov al, 0
0222+  0719 3E          	mov [d], al				; terminate string
0223+  071A E7          	pop d
0224+  071B E4          	pop a
0225+  071C 09          	ret
0226+  071D             
0227+  071D             
0228+  071D             
0229+  071D             
0230+  071D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  071D             ;; INPUT TEXT
0232+  071D             ;; terminated with CTRL+D
0233+  071D             ;; pointer in D
0234+  071D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  071D             gettxt:
0236+  071D D7          	push a
0237+  071E DA          	push d
0238+  071F             gettxt_loop:
0239+  071F 19 01       	mov al, 1
0240+  0721 05 03       	syscall sys_io			; receive in AH
0241+  0723 B9 00       	cmp al, 0				; check error code (AL)
0242+  0725 C6 1F 07    	je gettxt_loop		; if no char received, retry
0243+  0728 76 04       	cmp ah, 4			; EOT
0244+  072A C6 68 07    	je gettxt_end
0245+  072D 76 08       	cmp ah, $08			; check for backspace
0246+  072F C6 64 07    	je gettxt_backspace
0247+  0732 76 5C       	cmp ah, $5C				; '\\'
0248+  0734 C6 3D 07    	je gettxt_escape
0249+  0737 1A          	mov al, ah
0250+  0738 3E          	mov [d], al
0251+  0739 79          	inc d
0252+  073A 0A 1F 07    	jmp gettxt_loop
0253+  073D             gettxt_escape:
0254+  073D 19 01       	mov al, 1
0255+  073F 05 03       	syscall sys_io			; receive in AH
0256+  0741 B9 00       	cmp al, 0				; check error code (AL)
0257+  0743 C6 3D 07    	je gettxt_escape		; if no char received, retry
0258+  0746 76 6E       	cmp ah, 'n'
0259+  0748 C6 56 07    	je gettxt_LF
0260+  074B 76 72       	cmp ah, 'r'
0261+  074D C6 5D 07    	je gettxt_CR
0262+  0750 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  0751 3E          	mov [d], al
0264+  0752 79          	inc d
0265+  0753 0A 1F 07    	jmp gettxt_loop
0266+  0756             gettxt_LF:
0267+  0756 19 0A       	mov al, $0A
0268+  0758 3E          	mov [d], al
0269+  0759 79          	inc d
0270+  075A 0A 1F 07    	jmp gettxt_loop
0271+  075D             gettxt_CR:
0272+  075D 19 0D       	mov al, $0D
0273+  075F 3E          	mov [d], al
0274+  0760 79          	inc d
0275+  0761 0A 1F 07    	jmp gettxt_loop
0276+  0764             gettxt_backspace:
0277+  0764 7F          	dec d
0278+  0765 0A 1F 07    	jmp gettxt_loop
0279+  0768             gettxt_end:
0280+  0768 19 00       	mov al, 0
0281+  076A 3E          	mov [d], al				; terminate string
0282+  076B E7          	pop d
0283+  076C E4          	pop a
0284+  076D 09          	ret
0285+  076E             
0286+  076E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  076E             ; PRINT NEW LINE
0288+  076E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  076E             printnl:
0290+  076E D7          	push a
0291+  076F 10 00 0A    	mov a, $0A00
0292+  0772 05 03       	syscall sys_io
0293+  0774 10 00 0D    	mov a, $0D00
0294+  0777 05 03       	syscall sys_io
0295+  0779 E4          	pop a
0296+  077A 09          	ret
0297+  077B             
0298+  077B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  077B             ; strtoint
0300+  077B             ; 4 digit hex string number in d
0301+  077B             ; integer returned in A
0302+  077B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  077B             strtointx:
0304+  077B D8          	push b
0305+  077C 32          	mov bl, [d]
0306+  077D 37          	mov bh, bl
0307+  077E 33 01 00    	mov bl, [d + 1]
0308+  0781 07 3C 06    	call atoi				; convert to int in AL
0309+  0784 23          	mov ah, al				; move to AH
0310+  0785 33 02 00    	mov bl, [d + 2]
0311+  0788 37          	mov bh, bl
0312+  0789 33 03 00    	mov bl, [d + 3]
0313+  078C 07 3C 06    	call atoi				; convert to int in AL
0314+  078F E5          	pop b
0315+  0790 09          	ret
0316+  0791             
0317+  0791             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  0791             ; strtoint
0319+  0791             ; 5 digit base10 string number in d
0320+  0791             ; integer returned in A
0321+  0791             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  0791             strtoint:
0323+  0791 E2          	push si
0324+  0792 D8          	push b
0325+  0793 D9          	push c
0326+  0794 DA          	push d
0327+  0795 07 BC 05    	call strlen			; get string length in C
0328+  0798 7E          	dec c
0329+  0799 FD 4E       	mov si, d
0330+  079B 12          	mov a, c
0331+  079C FD 99       	shl a
0332+  079E 3B 24 06    	mov d, table_power
0333+  07A1 59          	add d, a
0334+  07A2 38 00 00    	mov c, 0
0335+  07A5             strtoint_L0:
0336+  07A5 F6          	lodsb			; load ASCII to al
0337+  07A6 B9 00       	cmp al, 0
0338+  07A8 C6 BB 07    	je strtoint_end
0339+  07AB 6F 30       	sub al, $30		; make into integer
0340+  07AD 22 00       	mov ah, 0
0341+  07AF 2A          	mov b, [d]
0342+  07B0 AC          	mul a, b			; result in B since it fits in 16bits
0343+  07B1 11          	mov a, b
0344+  07B2 28          	mov b, c
0345+  07B3 54          	add a, b
0346+  07B4 39          	mov c, a
0347+  07B5 63 02 00    	sub d, 2
0348+  07B8 0A A5 07    	jmp strtoint_L0
0349+  07BB             strtoint_end:
0350+  07BB 12          	mov a, c
0351+  07BC E7          	pop d
0352+  07BD E6          	pop c
0353+  07BE E5          	pop b
0354+  07BF EF          	pop si
0355+  07C0 09          	ret
0356+  07C1             
0357+  07C1             
0358+  07C1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  07C1             ; PRINT NULL TERMINATED STRING
0360+  07C1             ; pointer in D
0361+  07C1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  07C1             puts:
0363+  07C1 D7          	push a
0364+  07C2 DA          	push d
0365+  07C3             puts_L1:
0366+  07C3 1E          	mov al, [d]
0367+  07C4 B9 00       	cmp al, 0
0368+  07C6 C6 D2 07    	jz puts_END
0369+  07C9 23          	mov ah, al
0370+  07CA 19 00       	mov al, 0
0371+  07CC 05 03       	syscall sys_io
0372+  07CE 79          	inc d
0373+  07CF 0A C3 07    	jmp puts_L1
0374+  07D2             puts_END:
0375+  07D2 E7          	pop d
0376+  07D3 E4          	pop a
0377+  07D4 09          	ret
0378+  07D5             
0379+  07D5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  07D5             ; PRINT N SIZE STRING
0381+  07D5             ; pointer in D
0382+  07D5             ; size in C
0383+  07D5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  07D5             putsn:
0385+  07D5 DB          	push al
0386+  07D6 DA          	push d
0387+  07D7 D9          	push c
0388+  07D8             putsn_L0:
0389+  07D8 1E          	mov al, [d]
0390+  07D9 23          	mov ah, al
0391+  07DA 19 00       	mov al, 0
0392+  07DC 05 03       	syscall sys_io
0393+  07DE 79          	inc d
0394+  07DF 7E          	dec c	
0395+  07E0 C2 00 00    	cmp c, 0
0396+  07E3 C7 D8 07    	jne putsn_L0
0397+  07E6             putsn_end:
0398+  07E6 E6          	pop c
0399+  07E7 E7          	pop d
0400+  07E8 E8          	pop al
0401+  07E9 09          	ret
0402+  07EA             
0403+  07EA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  07EA             ; print 16bit decimal number
0405+  07EA             ; input number in A
0406+  07EA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  07EA             print_u16d:
0408+  07EA D7          	push a
0409+  07EB D8          	push b
0410+  07EC 26 10 27    	mov b, 10000
0411+  07EF AE          	div a, b			; get 10000 coeff.
0412+  07F0 07 16 08    	call print_number
0413+  07F3 11          	mov a, b
0414+  07F4 26 E8 03    	mov b, 1000
0415+  07F7 AE          	div a, b			; get 10000 coeff.
0416+  07F8 07 16 08    	call print_number
0417+  07FB 11          	mov a, b
0418+  07FC 26 64 00    	mov b, 100
0419+  07FF AE          	div a, b
0420+  0800 07 16 08    	call print_number
0421+  0803 11          	mov a, b
0422+  0804 26 0A 00    	mov b, 10
0423+  0807 AE          	div a, b
0424+  0808 07 16 08    	call print_number
0425+  080B 11          	mov a, b
0426+  080C 6A 30       	add al, $30
0427+  080E 23          	mov ah, al
0428+  080F 19 00       	mov al, 0
0429+  0811 05 03       	syscall sys_io	; print coeff
0430+  0813 E5          	pop b
0431+  0814 E4          	pop a
0432+  0815 09          	ret
0433+  0816             
0434+  0816             
0435+  0816             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  0816             ; if A == 0, print space
0437+  0816             ; else print A
0438+  0816             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0439+  0816             print_number:
0440+  0816 6A 30       	add al, $30
0441+  0818 23          	mov ah, al
0442+  0819 07 87 06    	call putchar
0443+  081C 09          	ret
0444+  081D             
0445+  081D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0446+  081D             ; PRINT 16BIT HEX INTEGER
0447+  081D             ; integer value in reg B
0448+  081D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  081D             print_u16x:
0450+  081D D7          	push a
0451+  081E D8          	push b
0452+  081F DD          	push bl
0453+  0820 30          	mov bl, bh
0454+  0821 07 4E 06    	call itoa				; convert bh to char in A
0455+  0824 2F          	mov bl, al				; save al
0456+  0825 19 00       	mov al, 0
0457+  0827 05 03       	syscall sys_io				; display AH
0458+  0829 24          	mov ah, bl				; retrieve al
0459+  082A 19 00       	mov al, 0
0460+  082C 05 03       	syscall sys_io				; display AL
0461+  082E             
0462+  082E EA          	pop bl
0463+  082F 07 4E 06    	call itoa				; convert bh to char in A
0464+  0832 2F          	mov bl, al				; save al
0465+  0833 19 00       	mov al, 0
0466+  0835 05 03       	syscall sys_io				; display AH
0467+  0837 24          	mov ah, bl				; retrieve al
0468+  0838 19 00       	mov al, 0
0469+  083A 05 03       	syscall sys_io				; display AL
0470+  083C             
0471+  083C E5          	pop b
0472+  083D E4          	pop a
0473+  083E 09          	ret
0474+  083F             
0475+  083F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  083F             ; INPUT 16BIT HEX INTEGER
0477+  083F             ; read 16bit integer into A
0478+  083F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  083F             scan_u16x:
0480+  083F F8 10 00    	enter 16
0481+  0842 D8          	push b
0482+  0843 DA          	push d
0483+  0844             
0484+  0844 FA F1 FF    	lea d, [bp + -15]
0485+  0847 07 8E 06    	call gets				; get number
0486+  084A             
0487+  084A 32          	mov bl, [d]
0488+  084B 37          	mov bh, bl
0489+  084C 33 01 00    	mov bl, [d + 1]
0490+  084F 07 3C 06    	call atoi				; convert to int in AL
0491+  0852 23          	mov ah, al				; move to AH
0492+  0853             
0493+  0853 33 02 00    	mov bl, [d + 2]
0494+  0856 37          	mov bh, bl
0495+  0857 33 03 00    	mov bl, [d + 3]
0496+  085A 07 3C 06    	call atoi				; convert to int in AL
0497+  085D             
0498+  085D E7          	pop d
0499+  085E E5          	pop b
0500+  085F F9          	leave
0501+  0860 09          	ret
0502+  0861             
0503+  0861             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0504+  0861             ; PRINT 8bit HEX INTEGER
0505+  0861             ; integer value in reg bl
0506+  0861             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  0861             print_u8x:
0508+  0861 D7          	push a
0509+  0862 DD          	push bl
0510+  0863             
0511+  0863 07 4E 06    	call itoa				; convert bl to char in A
0512+  0866 2F          	mov bl, al				; save al
0513+  0867 19 00       	mov al, 0
0514+  0869 05 03       	syscall sys_io				; display AH
0515+  086B 24          	mov ah, bl				; retrieve al
0516+  086C 19 00       	mov al, 0
0517+  086E 05 03       	syscall sys_io				; display AL
0518+  0870             
0519+  0870 EA          	pop bl
0520+  0871 E4          	pop a
0521+  0872 09          	ret
0522+  0873             
0523+  0873             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0524+  0873             ; print 8bit decimal unsigned number
0525+  0873             ; input number in AL
0526+  0873             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  0873             print_u8d:
0528+  0873 D7          	push a
0529+  0874 D8          	push b
0530+  0875             
0531+  0875 22 00       	mov ah, 0
0532+  0877 26 64 00    	mov b, 100
0533+  087A AE          	div a, b
0534+  087B D8          	push b			; save remainder
0535+  087C B9 00       	cmp al, 0
0536+  087E C6 88 08    	je skip100
0537+  0881 6A 30       	add al, $30
0538+  0883 23          	mov ah, al
0539+  0884 19 00       	mov al, 0
0540+  0886 05 03       	syscall sys_io	; print coeff
0541+  0888             skip100:
0542+  0888 E4          	pop a
0543+  0889 22 00       	mov ah, 0
0544+  088B 26 0A 00    	mov b, 10
0545+  088E AE          	div a, b
0546+  088F D8          	push b			; save remainder
0547+  0890 B9 00       	cmp al, 0
0548+  0892 C6 9C 08    	je skip10
0549+  0895 6A 30       	add al, $30
0550+  0897 23          	mov ah, al
0551+  0898 19 00       	mov al, 0
0552+  089A 05 03       	syscall sys_io	; print coeff
0553+  089C             skip10:
0554+  089C E4          	pop a
0555+  089D 1B          	mov al, bl
0556+  089E 6A 30       	add al, $30
0557+  08A0 23          	mov ah, al
0558+  08A1 19 00       	mov al, 0
0559+  08A3 05 03       	syscall sys_io	; print coeff
0560+  08A5 E5          	pop b
0561+  08A6 E4          	pop a
0562+  08A7 09          	ret
0563+  08A8             
0564+  08A8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0565+  08A8             ; INPUT 8BIT HEX INTEGER
0566+  08A8             ; read 8bit integer into AL
0567+  08A8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  08A8             scan_u8x:
0569+  08A8 F8 04 00    	enter 4
0570+  08AB D8          	push b
0571+  08AC DA          	push d
0572+  08AD             
0573+  08AD FA FD FF    	lea d, [bp + -3]
0574+  08B0 07 8E 06    	call gets				; get number
0575+  08B3             
0576+  08B3 32          	mov bl, [d]
0577+  08B4 37          	mov bh, bl
0578+  08B5 33 01 00    	mov bl, [d + 1]
0579+  08B8 07 3C 06    	call atoi				; convert to int in AL
0580+  08BB             
0581+  08BB E7          	pop d
0582+  08BC E5          	pop b
0583+  08BD F9          	leave
0584+  08BE 09          	ret
0585+  08BF             
0586+  08BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  08BF             ; input decimal number
0588+  08BF             ; result in A
0589+  08BF             ; 655'\0'
0590+  08BF             ; low--------high
0591+  08BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0592+  08BF             scan_u16d:
0593+  08BF F8 08 00    	enter 8
0594+  08C2 E2          	push si
0595+  08C3 D8          	push b
0596+  08C4 D9          	push c
0597+  08C5 DA          	push d
0598+  08C6 FA F9 FF    	lea d, [bp +- 7]
0599+  08C9 07 8E 06    	call gets
0600+  08CC 07 BC 05    	call strlen			; get string length in C
0601+  08CF 7E          	dec c
0602+  08D0 FD 4E       	mov si, d
0603+  08D2 12          	mov a, c
0604+  08D3 FD 99       	shl a
0605+  08D5 3B 24 06    	mov d, table_power
0606+  08D8 59          	add d, a
0607+  08D9 38 00 00    	mov c, 0
0608+  08DC             mul_loop:
0609+  08DC F6          	lodsb			; load ASCII to al
0610+  08DD B9 00       	cmp al, 0
0611+  08DF C6 F2 08    	je mul_exit
0612+  08E2 6F 30       	sub al, $30		; make into integer
0613+  08E4 22 00       	mov ah, 0
0614+  08E6 2A          	mov b, [d]
0615+  08E7 AC          	mul a, b			; result in B since it fits in 16bits
0616+  08E8 11          	mov a, b
0617+  08E9 28          	mov b, c
0618+  08EA 54          	add a, b
0619+  08EB 39          	mov c, a
0620+  08EC 63 02 00    	sub d, 2
0621+  08EF 0A DC 08    	jmp mul_loop
0622+  08F2             mul_exit:
0623+  08F2 12          	mov a, c
0624+  08F3 E7          	pop d
0625+  08F4 E6          	pop c
0626+  08F5 E5          	pop b
0627+  08F6 EF          	pop si
0628+  08F7 F9          	leave
0629+  08F8 09          	ret
0222   08F9             ; --- END INCLUDE BLOCK
0223   08F9             
0224   08F9             
0225   08F9             .end
tasm: Number of errors = 0
