0001   0000             ; --- Filename: test.c
0002   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0400             .org PROC_TEXT_ORG
0004   0400             
0005   0400             ; --- begin text block
0006   0400             main:
0007   0400 D2            push bp
0008   0401 9B            mov bp, sp
0009   0402 FD DB 41      push byte 'A'
0010   0405 FD DB 41      push byte 'A'
0011   0408 FA FF FF      lea d, [bp + -1] ; c1
0012   040B 2D            mov b, d
0013   040C FD AB         swp b
0014   040E D8            push b
0015   040F 07 18 04      call f1
0016   0412 51 02 00      add sp, 2
0017   0415 F9            leave
0018   0416 05 0B         syscall sys_terminate_proc
0019   0418             f1:
0020   0418 D2            push bp
0021   0419 9B            mov bp, sp
0022   041A FD DB 41      push byte 'A'
0023   041D FA 05 00      lea d, [bp + 5]
0024   0420 15            mov a, [d]
0025   0421 3C            mov d, a
0026   0422 26 00 00      mov b, 0
0027   0425 5A            add d, b
0028   0426 32            mov bl, [d]
0029   0427 1B            mov al, bl
0030   0428 40 00 00      mov [bp + 0], al ; cc
0031   042B             ; --- begin inline asm block
0032   042B 17 00 00        mov a, [bp + 0];
0033   042E FD AA           swp a
0034   0430 07 3F 05        call putchar
0035   0433               ; --- end inline asm block
0036   0433 F9            leave
0037   0434 09            ret
0038   0435             ; --- end text block
0039   0435             
0040   0435             ; --- begin data block
0041   0435             ; --- end data block
0042   0435             ; --- begin include block
0043   0435             .include "lib/stdio.asm"
0001+  0435             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0435             ; stdio.s
0003+  0435             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0435             .include "lib/string.asm"
0001++ 0435             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0435             ; string.s
0003++ 0435             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0435             
0005++ 0435             
0006++ 0435             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0435             ; strrev
0008++ 0435             ; reverse a string
0009++ 0435             ; D = string address
0010++ 0435             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0435             ; 01234
0012++ 0435             strrev:
0013++ 0435 4B          	pusha
0014++ 0436 07 7C 04    	call strlen	; length in C
0015++ 0439 12          	mov a, c
0016++ 043A AF 01 00    	cmp a, 1
0017++ 043D D0 57 04    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0440 7D          	dec a
0019++ 0441 FD 4E       	mov si, d	; beginning of string
0020++ 0443 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0445 59          	add d, a	; end of string
0022++ 0446 12          	mov a, c
0023++ 0447 FD 9B       	shr a		; divide by 2
0024++ 0449 39          	mov c, a	; C now counts the steps
0025++ 044A             strrev_L0:
0026++ 044A 32          	mov bl, [d]	; save load right-side char into BL
0027++ 044B F6          	lodsb		; load left-side char into AL; increase SI
0028++ 044C 3E          	mov [d], al	; store left char into right side
0029++ 044D 1B          	mov al, bl
0030++ 044E F7          	stosb		; store right-side char into left-side; increase DI
0031++ 044F 7E          	dec c
0032++ 0450 7F          	dec d
0033++ 0451 C2 00 00    	cmp c, 0
0034++ 0454 C7 4A 04    	jne strrev_L0
0035++ 0457             strrev_end:
0036++ 0457 4C          	popa
0037++ 0458 09          	ret
0038++ 0459             	
0039++ 0459             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0459             ; strchr
0041++ 0459             ; search string in D for char in AL
0042++ 0459             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0459             strchr:
0044++ 0459             strchr_L0:
0045++ 0459 32          	mov bl, [d]
0046++ 045A C1 00       	cmp bl, 0
0047++ 045C C6 67 04    	je strchr_end
0048++ 045F BA          	cmp al, bl
0049++ 0460 C6 67 04    	je strchr_end
0050++ 0463 79          	inc d
0051++ 0464 0A 59 04    	jmp strchr_L0
0052++ 0467             strchr_end:
0053++ 0467 1B          	mov al, bl
0054++ 0468 09          	ret
0055++ 0469             
0056++ 0469             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0469             ; strstr
0058++ 0469             ; find sub-string
0059++ 0469             ; str1 in SI
0060++ 0469             ; str2 in DI
0061++ 0469             ; SI points to end of source string
0062++ 0469             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0469             strstr:
0064++ 0469 DB          	push al
0065++ 046A DA          	push d
0066++ 046B E3          	push di
0067++ 046C             strstr_loop:
0068++ 046C F3          	cmpsb					; compare a byte of the strings
0069++ 046D C7 78 04    	jne strstr_ret
0070++ 0470 FC 00 00    	lea d, [di + 0]
0071++ 0473 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0475 C7 6C 04    	jne strstr_loop				; equal chars but not at end
0073++ 0478             strstr_ret:
0074++ 0478 F0          	pop di
0075++ 0479 E7          	pop d
0076++ 047A E8          	pop al
0077++ 047B 09          	ret
0078++ 047C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 047C             ; length of null terminated string
0080++ 047C             ; result in C
0081++ 047C             ; pointer in D
0082++ 047C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 047C             strlen:
0084++ 047C DA          	push d
0085++ 047D 38 00 00    	mov c, 0
0086++ 0480             strlen_L1:
0087++ 0480 BD 00       	cmp byte [d], 0
0088++ 0482 C6 8A 04    	je strlen_ret
0089++ 0485 79          	inc d
0090++ 0486 78          	inc c
0091++ 0487 0A 80 04    	jmp strlen_L1
0092++ 048A             strlen_ret:
0093++ 048A E7          	pop d
0094++ 048B 09          	ret
0095++ 048C             
0096++ 048C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 048C             ; STRCMP
0098++ 048C             ; compare two strings
0099++ 048C             ; str1 in SI
0100++ 048C             ; str2 in DI
0101++ 048C             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 048C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 048C             strcmp:
0104++ 048C DB          	push al
0105++ 048D DA          	push d
0106++ 048E E3          	push di
0107++ 048F E2          	push si
0108++ 0490             strcmp_loop:
0109++ 0490 F3          	cmpsb					; compare a byte of the strings
0110++ 0491 C7 9C 04    	jne strcmp_ret
0111++ 0494 FB FF FF    	lea d, [si +- 1]
0112++ 0497 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0499 C7 90 04    	jne strcmp_loop				; equal chars but not at end
0114++ 049C             strcmp_ret:
0115++ 049C EF          	pop si
0116++ 049D F0          	pop di
0117++ 049E E7          	pop d
0118++ 049F E8          	pop al
0119++ 04A0 09          	ret
0120++ 04A1             
0121++ 04A1             
0122++ 04A1             ; STRCPY
0123++ 04A1             ; copy null terminated string from SI to DI
0124++ 04A1             ; source in SI
0125++ 04A1             ; destination in DI
0126++ 04A1             strcpy:
0127++ 04A1 E2          	push si
0128++ 04A2 E3          	push di
0129++ 04A3 DB          	push al
0130++ 04A4             strcpy_L1:
0131++ 04A4 F6          	lodsb
0132++ 04A5 F7          	stosb
0133++ 04A6 B9 00       	cmp al, 0
0134++ 04A8 C7 A4 04    	jne strcpy_L1
0135++ 04AB             strcpy_end:
0136++ 04AB E8          	pop al
0137++ 04AC F0          	pop di
0138++ 04AD EF          	pop si
0139++ 04AE 09          	ret
0140++ 04AF             
0141++ 04AF             ; STRCAT
0142++ 04AF             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 04AF             ; source in SI
0144++ 04AF             ; destination in DI
0145++ 04AF             strcat:
0146++ 04AF E2          	push si
0147++ 04B0 E3          	push di
0148++ 04B1 D7          	push a
0149++ 04B2 DA          	push d
0150++ 04B3 50          	mov a, di
0151++ 04B4 3C          	mov d, a
0152++ 04B5             strcat_goto_end_L1:
0153++ 04B5 BD 00       	cmp byte[d], 0
0154++ 04B7 C6 BE 04    	je strcat_start
0155++ 04BA 79          	inc d
0156++ 04BB 0A B5 04    	jmp strcat_goto_end_L1
0157++ 04BE             strcat_start:
0158++ 04BE FD 50       	mov di, d
0159++ 04C0             strcat_L1:
0160++ 04C0 F6          	lodsb
0161++ 04C1 F7          	stosb
0162++ 04C2 B9 00       	cmp al, 0
0163++ 04C4 C7 C0 04    	jne strcat_L1
0164++ 04C7             strcat_end:
0165++ 04C7 E7          	pop d
0166++ 04C8 E4          	pop a
0167++ 04C9 F0          	pop di
0168++ 04CA EF          	pop si
0169++ 04CB 09          	ret
0005+  04CC             
0006+  04CC 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  04D0 34 35 36 37 
0006+  04D4 38 39 41 42 
0006+  04D8 43 44 45 46 
0007+  04DC             
0008+  04DC 01 00       table_power:.dw 1
0009+  04DE 0A 00       			.dw 10
0010+  04E0 64 00       			.dw 100
0011+  04E2 E8 03       			.dw 1000
0012+  04E4 10 27       			.dw 10000
0013+  04E6             
0014+  04E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0015+  04E6             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0016+  04E6             ; ASCII in BL
0017+  04E6             ; result in AL
0018+  04E6             ; ascii for F = 0100 0110
0019+  04E6             ; ascii for 9 = 0011 1001
0020+  04E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0021+  04E6             hex_ascii_encode:
0022+  04E6 1B          	mov al, bl
0023+  04E7 93 40       	test al, $40				; test if letter or number
0024+  04E9 C7 EF 04    	jnz hex_letter
0025+  04EC 87 0F       	and al, $0F				; get number
0026+  04EE 09          	ret
0027+  04EF             hex_letter:
0028+  04EF 87 0F       	and al, $0F				; get letter
0029+  04F1 6A 09       	add al, 9
0030+  04F3 09          	ret
0031+  04F4             
0032+  04F4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0033+  04F4             ; ATOI
0034+  04F4             ; 2 letter hex string in B
0035+  04F4             ; 8bit integer returned in AL
0036+  04F4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0037+  04F4             atoi:
0038+  04F4 D8          	push b
0039+  04F5 07 E6 04    	call hex_ascii_encode			; convert BL to 4bit code in AL
0040+  04F8 30          	mov bl, bh
0041+  04F9 DB          	push al					; save a
0042+  04FA 07 E6 04    	call hex_ascii_encode
0043+  04FD EA          	pop bl	
0044+  04FE FD 9E 04    	shl al, 4
0045+  0501 8C          	or al, bl
0046+  0502 E5          	pop b
0047+  0503 09          	ret	
0048+  0504             
0049+  0504             
0050+  0504             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  0504             ; printf
0052+  0504             ; no need for explanations!
0053+  0504             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0054+  0504             printf:
0055+  0504 09          	ret
0056+  0505             
0057+  0505             
0058+  0505             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  0505             ; scanf
0060+  0505             ; no need for explanations!
0061+  0505             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  0505             scanf:
0063+  0505 09          	ret
0064+  0506             
0065+  0506             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  0506             ; ITOA
0067+  0506             ; 8bit value in BL
0068+  0506             ; 2 byte ASCII result in A
0069+  0506             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0070+  0506             itoa:
0071+  0506 DA          	push d
0072+  0507 D8          	push b
0073+  0508 A7 00       	mov bh, 0
0074+  050A FD A4 04    	shr bl, 4	
0075+  050D 74          	mov d, b
0076+  050E 1F CC 04    	mov al, [d + s_hex_digits]
0077+  0511 23          	mov ah, al
0078+  0512             	
0079+  0512 E5          	pop b
0080+  0513 D8          	push b
0081+  0514 A7 00       	mov bh, 0
0082+  0516 FD 87 0F    	and bl, $0F
0083+  0519 74          	mov d, b
0084+  051A 1F CC 04    	mov al, [d + s_hex_digits]
0085+  051D E5          	pop b
0086+  051E E7          	pop d
0087+  051F 09          	ret
0088+  0520             
0089+  0520             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0090+  0520             ; HEX STRING TO BINARY
0091+  0520             ; di = destination address
0092+  0520             ; si = source
0093+  0520             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0094+  0520             hex_to_int:
0095+  0520             hex_to_int_L1:
0096+  0520 F6          	lodsb					; load from [SI] to AL
0097+  0521 B9 00       	cmp al, 0				; check if ASCII 0
0098+  0523 C6 30 05    	jz hex_to_int_ret
0099+  0526 36          	mov bh, al
0100+  0527 F6          	lodsb
0101+  0528 2F          	mov bl, al
0102+  0529 07 F4 04    	call atoi				; convert ASCII byte in B to int (to AL)
0103+  052C F7          	stosb					; store AL to [DI]
0104+  052D 0A 20 05    	jmp hex_to_int_L1
0105+  0530             hex_to_int_ret:
0106+  0530 09          	ret		
0107+  0531             
0108+  0531             
0109+  0531             
0110+  0531             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  0531             ; GETCHAR
0112+  0531             ; char in ah
0113+  0531             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0114+  0531             getchar:
0115+  0531 DB          	push al
0116+  0532             getchar_retry:
0117+  0532 FD 0C       	sti
0118+  0534 19 01       	mov al, 1
0119+  0536 05 03       	syscall sys_io			; receive in AH
0120+  0538 B9 00       	cmp al, 0			; check if any char was receive
0121+  053A C6 32 05    	je getchar_retry
0122+  053D E8          	pop al
0123+  053E 09          	ret
0124+  053F             
0125+  053F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0126+  053F             ; PUTCHAR
0127+  053F             ; char in ah
0128+  053F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  053F             putchar:
0130+  053F D7          	push a
0131+  0540 19 00       	mov al, 0
0132+  0542 05 03       	syscall sys_io			; char in AH
0133+  0544 E4          	pop a
0134+  0545 09          	ret
0135+  0546             
0136+  0546             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0137+  0546             ;; INPUT A STRING
0138+  0546             ;; terminates with null
0139+  0546             ;; pointer in D
0140+  0546             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  0546             gets:
0142+  0546 D7          	push a
0143+  0547 DA          	push d
0144+  0548             gets_loop:
0145+  0548 FD 0C       	sti
0146+  054A 19 01       	mov al, 1
0147+  054C 05 03       	syscall sys_io			; receive in AH
0148+  054E B9 00       	cmp al, 0				; check error code (AL)
0149+  0550 C6 48 05    	je gets_loop			; if no char received, retry
0150+  0553             
0151+  0553 76 1B       	cmp ah, 27
0152+  0555 C6 76 05    	je gets_telnet_escape
0153+  0558 76 0A       	cmp ah, $0A				; LF
0154+  055A C6 CF 05    	je gets_end
0155+  055D 76 0D       	cmp ah, $0D				; CR
0156+  055F C6 CF 05    	je gets_end
0157+  0562 76 5C       	cmp ah, $5C				; '\\'
0158+  0564 C6 A6 05    	je gets_escape
0159+  0567             	
0160+  0567 76 08       	cmp ah, $08			; check for backspace
0161+  0569 C6 72 05    	je gets_backspace
0162+  056C             
0163+  056C 1A          	mov al, ah
0164+  056D 3E          	mov [d], al
0165+  056E 79          	inc d
0166+  056F 0A 48 05    	jmp gets_loop
0167+  0572             gets_backspace:
0168+  0572 7F          	dec d
0169+  0573 0A 48 05    	jmp gets_loop
0170+  0576             gets_telnet_escape:
0171+  0576 FD 0C       	sti
0172+  0578 19 01       	mov al, 1
0173+  057A 05 03       	syscall sys_io				; receive in AH without echo
0174+  057C B9 00       	cmp al, 0					; check error code (AL)
0175+  057E C6 76 05    	je gets_telnet_escape		; if no char received, retry
0176+  0581 76 5B       	cmp ah, '['
0177+  0583 C7 48 05    	jne gets_loop
0178+  0586             gets_telnet_escape_phase2:
0179+  0586 FD 0C       	sti
0180+  0588 19 01       	mov al, 1
0181+  058A 05 03       	syscall sys_io					; receive in AH without echo
0182+  058C B9 00       	cmp al, 0						; check error code (AL)
0183+  058E C6 86 05    	je gets_telnet_escape_phase2	; if no char received, retry
0184+  0591 76 44       	cmp ah, 'D'
0185+  0593 C6 9E 05    	je gets_left_arrow
0186+  0596 76 43       	cmp ah, 'C'
0187+  0598 C6 A2 05    	je gets_right_arrow
0188+  059B 0A 48 05    	jmp gets_loop
0189+  059E             gets_left_arrow:
0190+  059E 7F          	dec d
0191+  059F 0A 48 05    	jmp gets_loop
0192+  05A2             gets_right_arrow:
0193+  05A2 79          	inc d
0194+  05A3 0A 48 05    	jmp gets_loop
0195+  05A6             gets_escape:
0196+  05A6 FD 0C       	sti
0197+  05A8 19 01       	mov al, 1
0198+  05AA 05 03       	syscall sys_io			; receive in AH
0199+  05AC B9 00       	cmp al, 0				; check error code (AL)
0200+  05AE C6 A6 05    	je gets_escape			; if no char received, retry
0201+  05B1 76 6E       	cmp ah, 'n'
0202+  05B3 C6 C1 05    	je gets_LF
0203+  05B6 76 72       	cmp ah, 'r'
0204+  05B8 C6 C8 05    	je gets_CR
0205+  05BB 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0206+  05BC 3E          	mov [d], al
0207+  05BD 79          	inc d
0208+  05BE 0A 48 05    	jmp gets_loop
0209+  05C1             gets_LF:
0210+  05C1 19 0A       	mov al, $0A
0211+  05C3 3E          	mov [d], al
0212+  05C4 79          	inc d
0213+  05C5 0A 48 05    	jmp gets_loop
0214+  05C8             gets_CR:
0215+  05C8 19 0D       	mov al, $0D
0216+  05CA 3E          	mov [d], al
0217+  05CB 79          	inc d
0218+  05CC 0A 48 05    	jmp gets_loop
0219+  05CF             gets_end:
0220+  05CF 19 00       	mov al, 0
0221+  05D1 3E          	mov [d], al				; terminate string
0222+  05D2 E7          	pop d
0223+  05D3 E4          	pop a
0224+  05D4 09          	ret
0225+  05D5             
0226+  05D5             
0227+  05D5             
0228+  05D5             
0229+  05D5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0230+  05D5             ;; INPUT TEXT
0231+  05D5             ;; terminated with CTRL+D
0232+  05D5             ;; pointer in D
0233+  05D5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0234+  05D5             gettxt:
0235+  05D5 D7          	push a
0236+  05D6 DA          	push d
0237+  05D7             gettxt_loop:
0238+  05D7 19 01       	mov al, 1
0239+  05D9 05 03       	syscall sys_io			; receive in AH
0240+  05DB B9 00       	cmp al, 0				; check error code (AL)
0241+  05DD C6 D7 05    	je gettxt_loop		; if no char received, retry
0242+  05E0 76 04       	cmp ah, 4			; EOT
0243+  05E2 C6 20 06    	je gettxt_end
0244+  05E5 76 08       	cmp ah, $08			; check for backspace
0245+  05E7 C6 1C 06    	je gettxt_backspace
0246+  05EA 76 5C       	cmp ah, $5C				; '\\'
0247+  05EC C6 F5 05    	je gettxt_escape
0248+  05EF 1A          	mov al, ah
0249+  05F0 3E          	mov [d], al
0250+  05F1 79          	inc d
0251+  05F2 0A D7 05    	jmp gettxt_loop
0252+  05F5             gettxt_escape:
0253+  05F5 19 01       	mov al, 1
0254+  05F7 05 03       	syscall sys_io			; receive in AH
0255+  05F9 B9 00       	cmp al, 0				; check error code (AL)
0256+  05FB C6 F5 05    	je gettxt_escape		; if no char received, retry
0257+  05FE 76 6E       	cmp ah, 'n'
0258+  0600 C6 0E 06    	je gettxt_LF
0259+  0603 76 72       	cmp ah, 'r'
0260+  0605 C6 15 06    	je gettxt_CR
0261+  0608 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0262+  0609 3E          	mov [d], al
0263+  060A 79          	inc d
0264+  060B 0A D7 05    	jmp gettxt_loop
0265+  060E             gettxt_LF:
0266+  060E 19 0A       	mov al, $0A
0267+  0610 3E          	mov [d], al
0268+  0611 79          	inc d
0269+  0612 0A D7 05    	jmp gettxt_loop
0270+  0615             gettxt_CR:
0271+  0615 19 0D       	mov al, $0D
0272+  0617 3E          	mov [d], al
0273+  0618 79          	inc d
0274+  0619 0A D7 05    	jmp gettxt_loop
0275+  061C             gettxt_backspace:
0276+  061C 7F          	dec d
0277+  061D 0A D7 05    	jmp gettxt_loop
0278+  0620             gettxt_end:
0279+  0620 19 00       	mov al, 0
0280+  0622 3E          	mov [d], al				; terminate string
0281+  0623 E7          	pop d
0282+  0624 E4          	pop a
0283+  0625 09          	ret
0284+  0626             
0285+  0626             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0286+  0626             ; PRINT NEW LINE
0287+  0626             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  0626             printnl:
0289+  0626 D7          	push a
0290+  0627 10 00 0A    	mov a, $0A00
0291+  062A 05 03       	syscall sys_io
0292+  062C 10 00 0D    	mov a, $0D00
0293+  062F 05 03       	syscall sys_io
0294+  0631 E4          	pop a
0295+  0632 09          	ret
0296+  0633             
0297+  0633             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0298+  0633             ; strtoint
0299+  0633             ; 4 digit hex string number in d
0300+  0633             ; integer returned in A
0301+  0633             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0302+  0633             strtointx:
0303+  0633 D8          	push b
0304+  0634 32          	mov bl, [d]
0305+  0635 37          	mov bh, bl
0306+  0636 33 01 00    	mov bl, [d + 1]
0307+  0639 07 F4 04    	call atoi				; convert to int in AL
0308+  063C 23          	mov ah, al				; move to AH
0309+  063D 33 02 00    	mov bl, [d + 2]
0310+  0640 37          	mov bh, bl
0311+  0641 33 03 00    	mov bl, [d + 3]
0312+  0644 07 F4 04    	call atoi				; convert to int in AL
0313+  0647 E5          	pop b
0314+  0648 09          	ret
0315+  0649             
0316+  0649             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0317+  0649             ; strtoint
0318+  0649             ; 5 digit base10 string number in d
0319+  0649             ; integer returned in A
0320+  0649             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0321+  0649             strtoint:
0322+  0649 E2          	push si
0323+  064A D8          	push b
0324+  064B D9          	push c
0325+  064C DA          	push d
0326+  064D 07 7C 04    	call strlen			; get string length in C
0327+  0650 7E          	dec c
0328+  0651 FD 4E       	mov si, d
0329+  0653 12          	mov a, c
0330+  0654 FD 99       	shl a
0331+  0656 3B DC 04    	mov d, table_power
0332+  0659 59          	add d, a
0333+  065A 38 00 00    	mov c, 0
0334+  065D             strtoint_L0:
0335+  065D F6          	lodsb			; load ASCII to al
0336+  065E B9 00       	cmp al, 0
0337+  0660 C6 73 06    	je strtoint_end
0338+  0663 6F 30       	sub al, $30		; make into integer
0339+  0665 22 00       	mov ah, 0
0340+  0667 2A          	mov b, [d]
0341+  0668 AC          	mul a, b			; result in B since it fits in 16bits
0342+  0669 11          	mov a, b
0343+  066A 28          	mov b, c
0344+  066B 54          	add a, b
0345+  066C 39          	mov c, a
0346+  066D 63 02 00    	sub d, 2
0347+  0670 0A 5D 06    	jmp strtoint_L0
0348+  0673             strtoint_end:
0349+  0673 12          	mov a, c
0350+  0674 E7          	pop d
0351+  0675 E6          	pop c
0352+  0676 E5          	pop b
0353+  0677 EF          	pop si
0354+  0678 09          	ret
0355+  0679             
0356+  0679             
0357+  0679             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0358+  0679             ; PRINT NULL TERMINATED STRING
0359+  0679             ; pointer in D
0360+  0679             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0361+  0679             puts:
0362+  0679 D7          	push a
0363+  067A DA          	push d
0364+  067B             puts_L1:
0365+  067B 1E          	mov al, [d]
0366+  067C B9 00       	cmp al, 0
0367+  067E C6 8A 06    	jz puts_END
0368+  0681 23          	mov ah, al
0369+  0682 19 00       	mov al, 0
0370+  0684 05 03       	syscall sys_io
0371+  0686 79          	inc d
0372+  0687 0A 7B 06    	jmp puts_L1
0373+  068A             puts_END:
0374+  068A E7          	pop d
0375+  068B E4          	pop a
0376+  068C 09          	ret
0377+  068D             
0378+  068D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  068D             ; PRINT N SIZE STRING
0380+  068D             ; pointer in D
0381+  068D             ; size in C
0382+  068D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0383+  068D             putsn:
0384+  068D DB          	push al
0385+  068E DA          	push d
0386+  068F D9          	push c
0387+  0690             putsn_L0:
0388+  0690 1E          	mov al, [d]
0389+  0691 23          	mov ah, al
0390+  0692 19 00       	mov al, 0
0391+  0694 05 03       	syscall sys_io
0392+  0696 79          	inc d
0393+  0697 7E          	dec c	
0394+  0698 C2 00 00    	cmp c, 0
0395+  069B C7 90 06    	jne putsn_L0
0396+  069E             putsn_end:
0397+  069E E6          	pop c
0398+  069F E7          	pop d
0399+  06A0 E8          	pop al
0400+  06A1 09          	ret
0401+  06A2             
0402+  06A2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0403+  06A2             ; print 16bit decimal number
0404+  06A2             ; input number in A
0405+  06A2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  06A2             print_u16d:
0407+  06A2 D7          	push a
0408+  06A3 D8          	push b
0409+  06A4 26 10 27    	mov b, 10000
0410+  06A7 AE          	div a, b			; get 10000 coeff.
0411+  06A8 07 CE 06    	call print_number
0412+  06AB 11          	mov a, b
0413+  06AC 26 E8 03    	mov b, 1000
0414+  06AF AE          	div a, b			; get 10000 coeff.
0415+  06B0 07 CE 06    	call print_number
0416+  06B3 11          	mov a, b
0417+  06B4 26 64 00    	mov b, 100
0418+  06B7 AE          	div a, b
0419+  06B8 07 CE 06    	call print_number
0420+  06BB 11          	mov a, b
0421+  06BC 26 0A 00    	mov b, 10
0422+  06BF AE          	div a, b
0423+  06C0 07 CE 06    	call print_number
0424+  06C3 11          	mov a, b
0425+  06C4 6A 30       	add al, $30
0426+  06C6 23          	mov ah, al
0427+  06C7 19 00       	mov al, 0
0428+  06C9 05 03       	syscall sys_io	; print coeff
0429+  06CB E5          	pop b
0430+  06CC E4          	pop a
0431+  06CD 09          	ret
0432+  06CE             
0433+  06CE             
0434+  06CE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0435+  06CE             ; if A == 0, print space
0436+  06CE             ; else print A
0437+  06CE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0438+  06CE             print_number:
0439+  06CE 6A 30       	add al, $30
0440+  06D0 23          	mov ah, al
0441+  06D1 07 3F 05    	call putchar
0442+  06D4 09          	ret
0443+  06D5             
0444+  06D5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  06D5             ; PRINT 16BIT HEX INTEGER
0446+  06D5             ; integer value in reg B
0447+  06D5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  06D5             print_u16x:
0449+  06D5 D7          	push a
0450+  06D6 D8          	push b
0451+  06D7 DD          	push bl
0452+  06D8 30          	mov bl, bh
0453+  06D9 07 06 05    	call itoa				; convert bh to char in A
0454+  06DC 2F          	mov bl, al				; save al
0455+  06DD 19 00       	mov al, 0
0456+  06DF 05 03       	syscall sys_io				; display AH
0457+  06E1 24          	mov ah, bl				; retrieve al
0458+  06E2 19 00       	mov al, 0
0459+  06E4 05 03       	syscall sys_io				; display AL
0460+  06E6             
0461+  06E6 EA          	pop bl
0462+  06E7 07 06 05    	call itoa				; convert bh to char in A
0463+  06EA 2F          	mov bl, al				; save al
0464+  06EB 19 00       	mov al, 0
0465+  06ED 05 03       	syscall sys_io				; display AH
0466+  06EF 24          	mov ah, bl				; retrieve al
0467+  06F0 19 00       	mov al, 0
0468+  06F2 05 03       	syscall sys_io				; display AL
0469+  06F4             
0470+  06F4 E5          	pop b
0471+  06F5 E4          	pop a
0472+  06F6 09          	ret
0473+  06F7             
0474+  06F7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0475+  06F7             ; INPUT 16BIT HEX INTEGER
0476+  06F7             ; read 16bit integer into A
0477+  06F7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0478+  06F7             scan_u16x:
0479+  06F7 F8 10 00    	enter 16
0480+  06FA D8          	push b
0481+  06FB DA          	push d
0482+  06FC             
0483+  06FC FA F1 FF    	lea d, [bp + -15]
0484+  06FF 07 46 05    	call gets				; get number
0485+  0702             
0486+  0702 32          	mov bl, [d]
0487+  0703 37          	mov bh, bl
0488+  0704 33 01 00    	mov bl, [d + 1]
0489+  0707 07 F4 04    	call atoi				; convert to int in AL
0490+  070A 23          	mov ah, al				; move to AH
0491+  070B             
0492+  070B 33 02 00    	mov bl, [d + 2]
0493+  070E 37          	mov bh, bl
0494+  070F 33 03 00    	mov bl, [d + 3]
0495+  0712 07 F4 04    	call atoi				; convert to int in AL
0496+  0715             
0497+  0715 E7          	pop d
0498+  0716 E5          	pop b
0499+  0717 F9          	leave
0500+  0718 09          	ret
0501+  0719             
0502+  0719             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0503+  0719             ; PRINT 8bit HEX INTEGER
0504+  0719             ; integer value in reg bl
0505+  0719             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0506+  0719             print_u8x:
0507+  0719 D7          	push a
0508+  071A DD          	push bl
0509+  071B             
0510+  071B 07 06 05    	call itoa				; convert bl to char in A
0511+  071E 2F          	mov bl, al				; save al
0512+  071F 19 00       	mov al, 0
0513+  0721 05 03       	syscall sys_io				; display AH
0514+  0723 24          	mov ah, bl				; retrieve al
0515+  0724 19 00       	mov al, 0
0516+  0726 05 03       	syscall sys_io				; display AL
0517+  0728             
0518+  0728 EA          	pop bl
0519+  0729 E4          	pop a
0520+  072A 09          	ret
0521+  072B             
0522+  072B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0523+  072B             ; print 8bit decimal unsigned number
0524+  072B             ; input number in AL
0525+  072B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0526+  072B             print_u8d:
0527+  072B D7          	push a
0528+  072C D8          	push b
0529+  072D             
0530+  072D 22 00       	mov ah, 0
0531+  072F 26 64 00    	mov b, 100
0532+  0732 AE          	div a, b
0533+  0733 D8          	push b			; save remainder
0534+  0734 B9 00       	cmp al, 0
0535+  0736 C6 40 07    	je skip100
0536+  0739 6A 30       	add al, $30
0537+  073B 23          	mov ah, al
0538+  073C 19 00       	mov al, 0
0539+  073E 05 03       	syscall sys_io	; print coeff
0540+  0740             skip100:
0541+  0740 E4          	pop a
0542+  0741 22 00       	mov ah, 0
0543+  0743 26 0A 00    	mov b, 10
0544+  0746 AE          	div a, b
0545+  0747 D8          	push b			; save remainder
0546+  0748 B9 00       	cmp al, 0
0547+  074A C6 54 07    	je skip10
0548+  074D 6A 30       	add al, $30
0549+  074F 23          	mov ah, al
0550+  0750 19 00       	mov al, 0
0551+  0752 05 03       	syscall sys_io	; print coeff
0552+  0754             skip10:
0553+  0754 E4          	pop a
0554+  0755 1B          	mov al, bl
0555+  0756 6A 30       	add al, $30
0556+  0758 23          	mov ah, al
0557+  0759 19 00       	mov al, 0
0558+  075B 05 03       	syscall sys_io	; print coeff
0559+  075D E5          	pop b
0560+  075E E4          	pop a
0561+  075F 09          	ret
0562+  0760             
0563+  0760             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0564+  0760             ; INPUT 8BIT HEX INTEGER
0565+  0760             ; read 8bit integer into AL
0566+  0760             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0567+  0760             scan_u8x:
0568+  0760 F8 04 00    	enter 4
0569+  0763 D8          	push b
0570+  0764 DA          	push d
0571+  0765             
0572+  0765 FA FD FF    	lea d, [bp + -3]
0573+  0768 07 46 05    	call gets				; get number
0574+  076B             
0575+  076B 32          	mov bl, [d]
0576+  076C 37          	mov bh, bl
0577+  076D 33 01 00    	mov bl, [d + 1]
0578+  0770 07 F4 04    	call atoi				; convert to int in AL
0579+  0773             
0580+  0773 E7          	pop d
0581+  0774 E5          	pop b
0582+  0775 F9          	leave
0583+  0776 09          	ret
0584+  0777             
0585+  0777             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0586+  0777             ; input decimal number
0587+  0777             ; result in A
0588+  0777             ; 655'\0'
0589+  0777             ; low--------high
0590+  0777             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0591+  0777             scan_u16d:
0592+  0777 F8 08 00    	enter 8
0593+  077A E2          	push si
0594+  077B D8          	push b
0595+  077C D9          	push c
0596+  077D DA          	push d
0597+  077E FA F9 FF    	lea d, [bp +- 7]
0598+  0781 07 46 05    	call gets
0599+  0784 07 7C 04    	call strlen			; get string length in C
0600+  0787 7E          	dec c
0601+  0788 FD 4E       	mov si, d
0602+  078A 12          	mov a, c
0603+  078B FD 99       	shl a
0604+  078D 3B DC 04    	mov d, table_power
0605+  0790 59          	add d, a
0606+  0791 38 00 00    	mov c, 0
0607+  0794             mul_loop:
0608+  0794 F6          	lodsb			; load ASCII to al
0609+  0795 B9 00       	cmp al, 0
0610+  0797 C6 AA 07    	je mul_exit
0611+  079A 6F 30       	sub al, $30		; make into integer
0612+  079C 22 00       	mov ah, 0
0613+  079E 2A          	mov b, [d]
0614+  079F AC          	mul a, b			; result in B since it fits in 16bits
0615+  07A0 11          	mov a, b
0616+  07A1 28          	mov b, c
0617+  07A2 54          	add a, b
0618+  07A3 39          	mov c, a
0619+  07A4 63 02 00    	sub d, 2
0620+  07A7 0A 94 07    	jmp mul_loop
0621+  07AA             mul_exit:
0622+  07AA 12          	mov a, c
0623+  07AB E7          	pop d
0624+  07AC E6          	pop c
0625+  07AD E5          	pop b
0626+  07AE EF          	pop si
0627+  07AF F9          	leave
0628+  07B0 09          	ret
0044   07B1             ; --- end include block
0045   07B1             
0046   07B1             .end
tasm: Number of errors = 0
