0001   0000             ; --- FILENAME: polish.c
0002   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0400             .org PROC_TEXT_ORG
0004   0400             
0005   0400             ; --- BEGIN TEXT BLOCK
0006   0400             
0007   0400             main:
0008   0400 D2            push bp
0009   0401 9B            mov bp, sp
0010   0402 52 02 00      sub sp, 2 ; type
0011   0405 52 02 00      sub sp, 2 ; op2
0012   0408 52 64 00      sub sp, 100 ; s
0013   040B             _while1_cond:
0014   040B FA 99 FF      lea d, [bp + -103] ; s_data
0015   040E 2D            mov b, d
0016   040F FD AB         swp b
0017   0411 D8            push b
0018   0412 07 1E 06      call getop
0019   0415 51 02 00      add sp, 2
0020   0418 D7            push a
0021   0419 11            mov a, b
0022   041A 45 FF FF      mov [bp + -1], a ; type
0023   041D E4            pop a
0024   041E D7            push a
0025   041F 11            mov a, b
0026   0420 26 24 00      mov b, '$'
0027   0423 B0            cmp a, b
0028   0424 0E            lodflgs
0029   0425 87 01         and al, %00000001
0030   0427 8F 01         xor al, %00000001 ; !=
0031   0429 B9 00         cmp al, 0
0032   042B 0E            lodflgs
0033   042C 96            not al
0034   042D 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0035   042F 22 00         mov ah, 0
0036   0431 27            mov b, a
0037   0432 E4            pop a
0038   0433 C0 00 00      cmp b, 0
0039   0436 C6 5C 05      je _while1_exit
0040   0439             _while1_block:
0041   0439             _switch2_expr:
0042   0439 2C FF FF      mov b, [bp + -1] ; type
0043   043C             _switch2_comparisons:
0044   043C C0 E7 03      cmp b, 999
0045   043F C6 5F 04      je _switch2_case0
0046   0442 C1 2B         cmp bl, '+'
0047   0444 C6 78 04      je _switch2_case1
0048   0447 C1 2A         cmp bl, '*'
0049   0449 C6 8F 04      je _switch2_case2
0050   044C C1 2D         cmp bl, '-'
0051   044E C6 A5 04      je _switch2_case3
0052   0451 C1 2F         cmp bl, '/'
0053   0453 C6 C5 04      je _switch2_case4
0054   0456 C0 0A 00      cmp b, 10
0055   0459 C6 16 05      je _switch2_case5
0056   045C 0A 31 05      jmp _switch2_default
0057   045F             _switch2_case0:
0058   045F FA 99 FF      lea d, [bp + -103] ; s_data
0059   0462 2D            mov b, d
0060   0463 FD AB         swp b
0061   0465 D8            push b
0062   0466 07 62 05      call _atoi
0063   0469 51 02 00      add sp, 2
0064   046C FD AB         swp b
0065   046E D8            push b
0066   046F 07 75 05      call push
0067   0472 51 02 00      add sp, 2
0068   0475 0A 59 05      jmp _switch2_exit ; case break
0069   0478             _switch2_case1:
0070   0478 07 CB 05      call pop
0071   047B D7            push a
0072   047C 11            mov a, b
0073   047D 07 CB 05      call pop
0074   0480 54            add a, b
0075   0481 27            mov b, a
0076   0482 E4            pop a
0077   0483 FD AB         swp b
0078   0485 D8            push b
0079   0486 07 75 05      call push
0080   0489 51 02 00      add sp, 2
0081   048C 0A 59 05      jmp _switch2_exit ; case break
0082   048F             _switch2_case2:
0083   048F 07 CB 05      call pop
0084   0492 D7            push a
0085   0493 11            mov a, b
0086   0494 07 CB 05      call pop
0087   0497 AC            mul a, b
0088   0498 E4            pop a
0089   0499 FD AB         swp b
0090   049B D8            push b
0091   049C 07 75 05      call push
0092   049F 51 02 00      add sp, 2
0093   04A2 0A 59 05      jmp _switch2_exit ; case break
0094   04A5             _switch2_case3:
0095   04A5 07 CB 05      call pop
0096   04A8 D7            push a
0097   04A9 11            mov a, b
0098   04AA 45 FD FF      mov [bp + -3], a ; op2
0099   04AD E4            pop a
0100   04AE 07 CB 05      call pop
0101   04B1 D7            push a
0102   04B2 11            mov a, b
0103   04B3 2C FD FF      mov b, [bp + -3] ; op2
0104   04B6 60            sub a, b
0105   04B7 27            mov b, a
0106   04B8 E4            pop a
0107   04B9 FD AB         swp b
0108   04BB D8            push b
0109   04BC 07 75 05      call push
0110   04BF 51 02 00      add sp, 2
0111   04C2 0A 59 05      jmp _switch2_exit ; case break
0112   04C5             _switch2_case4:
0113   04C5 07 CB 05      call pop
0114   04C8 D7            push a
0115   04C9 11            mov a, b
0116   04CA 45 FD FF      mov [bp + -3], a ; op2
0117   04CD E4            pop a
0118   04CE             _if3_cond:
0119   04CE 2C FD FF      mov b, [bp + -3] ; op2
0120   04D1 D7            push a
0121   04D2 11            mov a, b
0122   04D3 26 00 00      mov b, 0
0123   04D6 B0            cmp a, b
0124   04D7 0E            lodflgs
0125   04D8 87 01         and al, %00000001
0126   04DA 8F 01         xor al, %00000001 ; !=
0127   04DC B9 00         cmp al, 0
0128   04DE 0E            lodflgs
0129   04DF 96            not al
0130   04E0 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0131   04E2 22 00         mov ah, 0
0132   04E4 27            mov b, a
0133   04E5 E4            pop a
0134   04E6 C0 00 00      cmp b, 0
0135   04E9 C6 07 05      je _if3_else
0136   04EC             _if3_true:
0137   04EC 07 CB 05      call pop
0138   04EF D7            push a
0139   04F0 11            mov a, b
0140   04F1 2C FD FF      mov b, [bp + -3] ; op2
0141   04F4 AE            div a, b
0142   04F5 FD 78         mov g, a
0143   04F7 11            mov a, b
0144   04F8 FD 27         mov b, g
0145   04FA E4            pop a
0146   04FB FD AB         swp b
0147   04FD D8            push b
0148   04FE 07 75 05      call push
0149   0501 51 02 00      add sp, 2
0150   0504 0A 13 05      jmp _if3_exit
0151   0507             _if3_else:
0152   0507 26 A3 09      mov b, _string_0 ; "Divide by zero error\n"
0153   050A FD AB         swp b
0154   050C D8            push b
0155   050D 07 64 08      call print
0156   0510 51 02 00      add sp, 2
0157   0513             _if3_exit:
0158   0513 0A 59 05      jmp _switch2_exit ; case break
0159   0516             _switch2_case5:
0160   0516 07 CB 05      call pop
0161   0519 FD AB         swp b
0162   051B D8            push b
0163   051C 07 5A 08      call printn
0164   051F 51 02 00      add sp, 2
0165   0522 26 B9 09      mov b, _string_1 ; "\n"
0166   0525 FD AB         swp b
0167   0527 D8            push b
0168   0528 07 64 08      call print
0169   052B 51 02 00      add sp, 2
0170   052E 0A 59 05      jmp _switch2_exit ; case break
0171   0531             _switch2_default:
0172   0531 26 BB 09      mov b, _string_2 ; "Unknown input: "
0173   0534 FD AB         swp b
0174   0536 D8            push b
0175   0537 07 64 08      call print
0176   053A 51 02 00      add sp, 2
0177   053D FA 99 FF      lea d, [bp + -103] ; s_data
0178   0540 2D            mov b, d
0179   0541 FD AB         swp b
0180   0543 D8            push b
0181   0544 07 64 08      call print
0182   0547 51 02 00      add sp, 2
0183   054A 26 B9 09      mov b, _string_1 ; "\n"
0184   054D FD AB         swp b
0185   054F D8            push b
0186   0550 07 64 08      call print
0187   0553 51 02 00      add sp, 2
0188   0556 0A 59 05      jmp _switch2_exit ; case break
0189   0559             _switch2_exit:
0190   0559 0A 0B 04      jmp _while1_cond
0191   055C             _while1_exit:
0192   055C 26 00 00      mov b, 0
0193   055F F9            leave
0194   0560 05 0B         syscall sys_terminate_proc
0195   0562             
0196   0562             _atoi:
0197   0562 D2            push bp
0198   0563 9B            mov bp, sp
0199   0564 52 02 00      sub sp, 2 ; n
0200   0567             
0201   0567             ; --- BEGIN INLINE ASM BLOCK
0202   0567 FA 05 00      lea d, [bp + 5]
0203   056A 07 38 0C      call strtoint
0204   056D 45 FF FF      mov [bp + -1], a
0205   0570             ; --- END INLINE ASM BLOCK
0206   0570             
0207   0570 2C FF FF      mov b, [bp + -1] ; n
0208   0573 F9            leave
0209   0574 09            ret
0210   0575             
0211   0575             push:
0212   0575 D2            push bp
0213   0576 9B            mov bp, sp
0214   0577             _if4_cond:
0215   0577 29 6F 08      mov b, [sp] ; sp
0216   057A D7            push a
0217   057B 11            mov a, b
0218   057C 26 64 00      mov b, 100
0219   057F B0            cmp a, b
0220   0580 0E            lodflgs
0221   0581 87 02         and al, %00000010 ; <
0222   0583 B9 00         cmp al, 0
0223   0585 0E            lodflgs
0224   0586 96            not al
0225   0587 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0226   0589 22 00         mov ah, 0
0227   058B 27            mov b, a
0228   058C E4            pop a
0229   058D C0 00 00      cmp b, 0
0230   0590 C6 B1 05      je _if4_else
0231   0593             _if4_true:
0232   0593 29 39 09      mov b, [val]
0233   0596 74            mov d, b
0234   0597 DA            push d
0235   0598 29 6F 08      mov b, [sp] ; sp
0236   059B FD 77         inc b
0237   059D FD 42 6F 08   mov [sp], b
0238   05A1 E7            pop d
0239   05A2 10 02 00      mov a, 2
0240   05A5 AC            mul a, b
0241   05A6 5A            add d, b
0242   05A7 DA            push d
0243   05A8 2C 05 00      mov b, [bp + 5] ; f
0244   05AB E7            pop d
0245   05AC 11            mov a, b
0246   05AD 43            mov [d], a
0247   05AE 0A BD 05      jmp _if4_exit
0248   05B1             _if4_else:
0249   05B1 26 CB 09      mov b, _string_3 ; "Error: stack full, can't push: "
0250   05B4 FD AB         swp b
0251   05B6 D8            push b
0252   05B7 07 64 08      call print
0253   05BA 51 02 00      add sp, 2
0254   05BD             _if4_exit:
0255   05BD 2C 05 00      mov b, [bp + 5] ; f
0256   05C0 FD AB         swp b
0257   05C2 D8            push b
0258   05C3 07 5A 08      call printn
0259   05C6 51 02 00      add sp, 2
0260   05C9 F9            leave
0261   05CA 09            ret
0262   05CB             
0263   05CB             pop:
0264   05CB D2            push bp
0265   05CC 9B            mov bp, sp
0266   05CD             _if5_cond:
0267   05CD 29 6F 08      mov b, [sp] ; sp
0268   05D0 D7            push a
0269   05D1 11            mov a, b
0270   05D2 26 00 00      mov b, 0
0271   05D5 B0            cmp a, b
0272   05D6 0E            lodflgs
0273   05D7 87 03         and al, %00000011
0274   05D9 B9 00         cmp al, %00000000
0275   05DB 0E            lodflgs
0276   05DC 87 01         and al, %00000001 ; >
0277   05DE B9 00         cmp al, 0
0278   05E0 0E            lodflgs
0279   05E1 96            not al
0280   05E2 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0281   05E4 22 00         mov ah, 0
0282   05E6 27            mov b, a
0283   05E7 E4            pop a
0284   05E8 C0 00 00      cmp b, 0
0285   05EB C6 0D 06      je _if5_else
0286   05EE             _if5_true:
0287   05EE 29 6F 08      mov b, [sp] ; sp
0288   05F1 FD 7D         dec b
0289   05F3 FD 42 6F 08   mov [sp], b
0290   05F7 29 39 09      mov b, [val]
0291   05FA D7            push a
0292   05FB 74            mov d, b
0293   05FC DA            push d
0294   05FD 29 6F 08      mov b, [sp] ; sp
0295   0600 E7            pop d
0296   0601 10 02 00      mov a, 2
0297   0604 AC            mul a, b
0298   0605 5A            add d, b
0299   0606 2A            mov b, [d]
0300   0607 E4            pop a
0301   0608 F9            leave
0302   0609 09            ret
0303   060A 0A 1E 06      jmp _if5_exit
0304   060D             _if5_else:
0305   060D 26 EA 09      mov b, _string_4 ; "Error: stack empty.\n"
0306   0610 FD AB         swp b
0307   0612 D8            push b
0308   0613 07 64 08      call print
0309   0616 51 02 00      add sp, 2
0310   0619 26 00 00      mov b, 0
0311   061C F9            leave
0312   061D 09            ret
0313   061E             _if5_exit:
0314   061E             
0315   061E             getop:
0316   061E D2            push bp
0317   061F 9B            mov bp, sp
0318   0620 52 02 00      sub sp, 2 ; i
0319   0623 52 01 00      sub sp, 1 ; c
0320   0626             _while6_cond:
0321   0626 FA 05 00      lea d, [bp + 5] ; s
0322   0629 2A            mov b, [d]
0323   062A 74            mov d, b
0324   062B DA            push d
0325   062C 26 00 00      mov b, 0
0326   062F E7            pop d
0327   0630 10 01 00      mov a, 1
0328   0633 AC            mul a, b
0329   0634 5A            add d, b
0330   0635 DA            push d
0331   0636 07 39 07      call getch
0332   0639 DB            push al
0333   063A 1B            mov al, bl
0334   063B 40 FE FF      mov [bp + -2], al ; c
0335   063E E8            pop al
0336   063F E7            pop d
0337   0640 1B            mov al, bl
0338   0641 3E            mov [d], al
0339   0642 D7            push a
0340   0643 11            mov a, b
0341   0644 26 20 00      mov b, ' '
0342   0647 B0            cmp a, b
0343   0648 0E            lodflgs
0344   0649 87 01         and al, %00000001 ; ==
0345   064B B9 00         cmp al, 0
0346   064D 0E            lodflgs
0347   064E 96            not al
0348   064F 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0349   0651 22 00         mov ah, 0
0350   0653 27            mov b, a
0351   0654 E4            pop a
0352   0655 C0 00 00      cmp b, 0
0353   0658 C6 5E 06      je _while6_exit
0354   065B             _while6_block:
0355   065B 0A 26 06      jmp _while6_cond
0356   065E             _while6_exit:
0357   065E FA 05 00      lea d, [bp + 5] ; s
0358   0661 2A            mov b, [d]
0359   0662 74            mov d, b
0360   0663 DA            push d
0361   0664 26 01 00      mov b, 1
0362   0667 E7            pop d
0363   0668 10 01 00      mov a, 1
0364   066B AC            mul a, b
0365   066C 5A            add d, b
0366   066D DA            push d
0367   066E 26 00 00      mov b, 0
0368   0671 E7            pop d
0369   0672 1B            mov al, bl
0370   0673 3E            mov [d], al
0371   0674             _if7_cond:
0372   0674 34 FE FF      mov bl, [bp + -2] ; c
0373   0677 A7 00         mov bh, 0
0374   0679 DD            push bl
0375   067A 07 D1 07      call isdigit
0376   067D 51 01 00      add sp, 1
0377   0680 DB            push al
0378   0681 C0 00 00      cmp b, 0
0379   0684 0E            lodflgs
0380   0685 87 01         and al, %00000001 ; transform logical not condition result into a single bit
0381   0687 2F            mov bl, al
0382   0688 A7 00         mov bh, 0
0383   068A E8            pop al
0384   068B C0 00 00      cmp b, 0
0385   068E C6 9B 06      je _if7_exit
0386   0691             _if7_true:
0387   0691 34 FE FF      mov bl, [bp + -2] ; c
0388   0694 A7 00         mov bh, 0
0389   0696 F9            leave
0390   0697 09            ret
0391   0698 0A 9B 06      jmp _if7_exit
0392   069B             _if7_exit:
0393   069B 26 00 00      mov b, 0
0394   069E D7            push a
0395   069F 11            mov a, b
0396   06A0 45 FF FF      mov [bp + -1], a ; i
0397   06A3 E4            pop a
0398   06A4             _if8_cond:
0399   06A4 34 FE FF      mov bl, [bp + -2] ; c
0400   06A7 A7 00         mov bh, 0
0401   06A9 DD            push bl
0402   06AA 07 D1 07      call isdigit
0403   06AD 51 01 00      add sp, 1
0404   06B0 C0 00 00      cmp b, 0
0405   06B3 C6 ED 06      je _if8_exit
0406   06B6             _if8_true:
0407   06B6             _while9_cond:
0408   06B6 FA 05 00      lea d, [bp + 5] ; s
0409   06B9 2A            mov b, [d]
0410   06BA 74            mov d, b
0411   06BB DA            push d
0412   06BC 2C FF FF      mov b, [bp + -1] ; i
0413   06BF FD 77         inc b
0414   06C1 D7            push a
0415   06C2 11            mov a, b
0416   06C3 45 FF FF      mov [bp + -1], a ; i
0417   06C6 E4            pop a
0418   06C7 E7            pop d
0419   06C8 10 01 00      mov a, 1
0420   06CB AC            mul a, b
0421   06CC 5A            add d, b
0422   06CD DA            push d
0423   06CE 07 39 07      call getch
0424   06D1 DB            push al
0425   06D2 1B            mov al, bl
0426   06D3 40 FE FF      mov [bp + -2], al ; c
0427   06D6 E8            pop al
0428   06D7 E7            pop d
0429   06D8 1B            mov al, bl
0430   06D9 3E            mov [d], al
0431   06DA DD            push bl
0432   06DB 07 D1 07      call isdigit
0433   06DE 51 01 00      add sp, 1
0434   06E1 C0 00 00      cmp b, 0
0435   06E4 C6 EA 06      je _while9_exit
0436   06E7             _while9_block:
0437   06E7 0A B6 06      jmp _while9_cond
0438   06EA             _while9_exit:
0439   06EA 0A ED 06      jmp _if8_exit
0440   06ED             _if8_exit:
0441   06ED FA 05 00      lea d, [bp + 5] ; s
0442   06F0 2A            mov b, [d]
0443   06F1 74            mov d, b
0444   06F2 DA            push d
0445   06F3 2C FF FF      mov b, [bp + -1] ; i
0446   06F6 E7            pop d
0447   06F7 10 01 00      mov a, 1
0448   06FA AC            mul a, b
0449   06FB 5A            add d, b
0450   06FC DA            push d
0451   06FD 26 00 00      mov b, 0
0452   0700 E7            pop d
0453   0701 1B            mov al, bl
0454   0702 3E            mov [d], al
0455   0703             _if10_cond:
0456   0703 34 FE FF      mov bl, [bp + -2] ; c
0457   0706 A7 00         mov bh, 0
0458   0708 D7            push a
0459   0709 11            mov a, b
0460   070A 26 24 00      mov b, '$'
0461   070D B0            cmp a, b
0462   070E 0E            lodflgs
0463   070F 87 01         and al, %00000001
0464   0711 8F 01         xor al, %00000001 ; !=
0465   0713 B9 00         cmp al, 0
0466   0715 0E            lodflgs
0467   0716 96            not al
0468   0717 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0469   0719 22 00         mov ah, 0
0470   071B 27            mov b, a
0471   071C E4            pop a
0472   071D C0 00 00      cmp b, 0
0473   0720 C6 34 07      je _if10_exit
0474   0723             _if10_true:
0475   0723 34 FE FF      mov bl, [bp + -2] ; c
0476   0726 A7 00         mov bh, 0
0477   0728 FD AB         swp b
0478   072A D8            push b
0479   072B 07 82 07      call ungetch
0480   072E 51 02 00      add sp, 2
0481   0731 0A 34 07      jmp _if10_exit
0482   0734             _if10_exit:
0483   0734 26 E7 03      mov b, 999
0484   0737 F9            leave
0485   0738 09            ret
0486   0739             
0487   0739             getch:
0488   0739 D2            push bp
0489   073A 9B            mov bp, sp
0490   073B             _if11_cond:
0491   073B 29 A1 09      mov b, [bufp] ; bufp
0492   073E D7            push a
0493   073F 11            mov a, b
0494   0740 26 00 00      mov b, 0
0495   0743 B0            cmp a, b
0496   0744 0E            lodflgs
0497   0745 87 03         and al, %00000011
0498   0747 B9 00         cmp al, %00000000
0499   0749 0E            lodflgs
0500   074A 87 01         and al, %00000001 ; >
0501   074C B9 00         cmp al, 0
0502   074E 0E            lodflgs
0503   074F 96            not al
0504   0750 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0505   0752 22 00         mov ah, 0
0506   0754 27            mov b, a
0507   0755 E4            pop a
0508   0756 C0 00 00      cmp b, 0
0509   0759 C6 7D 07      je _if11_else
0510   075C             _if11_true:
0511   075C 29 A1 09      mov b, [bufp] ; bufp
0512   075F FD 7D         dec b
0513   0761 FD 42 A1 09   mov [bufp], b
0514   0765 29 9F 09      mov b, [buf]
0515   0768 D7            push a
0516   0769 74            mov d, b
0517   076A DA            push d
0518   076B 29 A1 09      mov b, [bufp] ; bufp
0519   076E E7            pop d
0520   076F 10 01 00      mov a, 1
0521   0772 AC            mul a, b
0522   0773 5A            add d, b
0523   0774 32            mov bl, [d]
0524   0775 A7 00         mov bh, 0
0525   0777 E4            pop a
0526   0778 F9            leave
0527   0779 09            ret
0528   077A 0A 82 07      jmp _if11_exit
0529   077D             _if11_else:
0530   077D 07 2F 08      call _getchar
0531   0780 F9            leave
0532   0781 09            ret
0533   0782             _if11_exit:
0534   0782             
0535   0782             ungetch:
0536   0782 D2            push bp
0537   0783 9B            mov bp, sp
0538   0784             _if12_cond:
0539   0784 29 A1 09      mov b, [bufp] ; bufp
0540   0787 D7            push a
0541   0788 11            mov a, b
0542   0789 26 64 00      mov b, 100
0543   078C B0            cmp a, b
0544   078D 0E            lodflgs
0545   078E 87 03         and al, %00000011
0546   0790 8F 02         xor al, %00000010 ; >=
0547   0792 B9 00         cmp al, 0
0548   0794 0E            lodflgs
0549   0795 96            not al
0550   0796 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0551   0798 22 00         mov ah, 0
0552   079A 27            mov b, a
0553   079B E4            pop a
0554   079C C0 00 00      cmp b, 0
0555   079F C6 B1 07      je _if12_else
0556   07A2             _if12_true:
0557   07A2 26 FF 09      mov b, _string_5 ; "Error: too many characters.\n"
0558   07A5 FD AB         swp b
0559   07A7 D8            push b
0560   07A8 07 64 08      call print
0561   07AB 51 02 00      add sp, 2
0562   07AE 0A CF 07      jmp _if12_exit
0563   07B1             _if12_else:
0564   07B1 29 9F 09      mov b, [buf]
0565   07B4 74            mov d, b
0566   07B5 DA            push d
0567   07B6 29 A1 09      mov b, [bufp] ; bufp
0568   07B9 E7            pop d
0569   07BA 10 01 00      mov a, 1
0570   07BD AC            mul a, b
0571   07BE 5A            add d, b
0572   07BF DA            push d
0573   07C0 2C 05 00      mov b, [bp + 5] ; c
0574   07C3 E7            pop d
0575   07C4 1B            mov al, bl
0576   07C5 3E            mov [d], al
0577   07C6 29 A1 09      mov b, [bufp] ; bufp
0578   07C9 FD 77         inc b
0579   07CB FD 42 A1 09   mov [bufp], b
0580   07CF             _if12_exit:
0581   07CF F9            leave
0582   07D0 09            ret
0583   07D1             
0584   07D1             isdigit:
0585   07D1 D2            push bp
0586   07D2 9B            mov bp, sp
0587   07D3             _if13_cond:
0588   07D3 34 05 00      mov bl, [bp + 5] ; c
0589   07D6 A7 00         mov bh, 0
0590   07D8 D7            push a
0591   07D9 11            mov a, b
0592   07DA 26 30 00      mov b, '0'
0593   07DD B0            cmp a, b
0594   07DE 0E            lodflgs
0595   07DF 87 03         and al, %00000011
0596   07E1 8F 02         xor al, %00000010 ; >=
0597   07E3 B9 00         cmp al, 0
0598   07E5 0E            lodflgs
0599   07E6 96            not al
0600   07E7 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0601   07E9 22 00         mov ah, 0
0602   07EB 27            mov b, a
0603   07EC E4            pop a
0604   07ED D7            push a
0605   07EE 11            mov a, b
0606   07EF AF 00 00      cmp a, 0
0607   07F2 0E            lodflgs
0608   07F3 96            not al
0609   07F4 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
0610   07F6 34 05 00      mov bl, [bp + 5] ; c
0611   07F9 A7 00         mov bh, 0
0612   07FB D7            push a
0613   07FC 11            mov a, b
0614   07FD 26 39 00      mov b, '9'
0615   0800 B0            cmp a, b
0616   0801 0E            lodflgs
0617   0802 87 03         and al, %00000011 ; <=
0618   0804 B9 00         cmp al, 0
0619   0806 0E            lodflgs
0620   0807 96            not al
0621   0808 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0622   080A 22 00         mov ah, 0
0623   080C 27            mov b, a
0624   080D E4            pop a
0625   080E DB            push al
0626   080F C0 00 00      cmp b, 0
0627   0812 0E            lodflgs
0628   0813 96            not al
0629   0814 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
0630   0816 EA            pop bl
0631   0817 88            and al, bl
0632   0818 2F            mov bl, al
0633   0819 A7 00         mov bh, 0
0634   081B E4            pop a
0635   081C C0 00 00      cmp b, 0
0636   081F C6 2A 08      je _if13_else
0637   0822             _if13_true:
0638   0822 26 01 00      mov b, 1
0639   0825 F9            leave
0640   0826 09            ret
0641   0827 0A 2F 08      jmp _if13_exit
0642   082A             _if13_else:
0643   082A 26 00 00      mov b, 0
0644   082D F9            leave
0645   082E 09            ret
0646   082F             _if13_exit:
0647   082F             
0648   082F             _getchar:
0649   082F D2            push bp
0650   0830 9B            mov bp, sp
0651   0831 52 01 00      sub sp, 1 ; c
0652   0834             
0653   0834             ; --- BEGIN INLINE ASM BLOCK
0654   0834 07 20 0B      call getchar
0655   0837 1A            mov al, ah
0656   0838 40 00 00      mov [bp + 0], al
0657   083B             ; --- END INLINE ASM BLOCK
0658   083B             
0659   083B 34 00 00      mov bl, [bp + 0] ; c
0660   083E A7 00         mov bh, 0
0661   0840 F9            leave
0662   0841 09            ret
0663   0842             
0664   0842             scann:
0665   0842 D2            push bp
0666   0843 9B            mov bp, sp
0667   0844 52 02 00      sub sp, 2 ; m
0668   0847             
0669   0847             ; --- BEGIN INLINE ASM BLOCK
0670   0847 07 66 0D      call scan_u16d
0671   084A 45 FF FF      mov [bp + -1], a
0672   084D             ; --- END INLINE ASM BLOCK
0673   084D             
0674   084D FA 05 00      lea d, [bp + 5] ; n
0675   0850 2A            mov b, [d]
0676   0851 D8            push b
0677   0852 2C FF FF      mov b, [bp + -1] ; m
0678   0855 E7            pop d
0679   0856 11            mov a, b
0680   0857 43            mov [d], a
0681   0858 F9            leave
0682   0859 09            ret
0683   085A             
0684   085A             printn:
0685   085A D2            push bp
0686   085B 9B            mov bp, sp
0687   085C             
0688   085C             ; --- BEGIN INLINE ASM BLOCK
0689   085C 17 05 00      mov a, [bp + 5]
0690   085F 07 91 0C      call print_u16d
0691   0862             ; --- END INLINE ASM BLOCK
0692   0862             
0693   0862 F9            leave
0694   0863 09            ret
0695   0864             
0696   0864             print:
0697   0864 D2            push bp
0698   0865 9B            mov bp, sp
0699   0866             
0700   0866             ; --- BEGIN INLINE ASM BLOCK
0701   0866 17 05 00      mov a, [bp + 5]
0702   0869 3C            mov d, a
0703   086A 07 68 0C      call puts
0704   086D             ; --- END INLINE ASM BLOCK
0705   086D             
0706   086D F9            leave
0707   086E 09            ret
0708   086F             ; --- END TEXT BLOCK
0709   086F             
0710   086F             ; --- BEGIN DATA BLOCK
0711   086F 00 00       sp: .dw 0
0712   0871 00 00 00 00 val_data: .fill 200, 0
0712   0875 00 00 00 00 
0712   0879 00 00 00 00 
0712   087D 00 00 00 00 
0712   0881 00 00 00 00 
0712   0885 00 00 00 00 
0712   0889 00 00 00 00 
0712   088D 00 00 00 00 
0712   0891 00 00 00 00 
0712   0895 00 00 00 00 
0712   0899 00 00 00 00 
0712   089D 00 00 00 00 
0712   08A1 00 00 00 00 
0712   08A5 00 00 00 00 
0712   08A9 00 00 00 00 
0712   08AD 00 00 00 00 
0712   08B1 00 00 00 00 
0712   08B5 00 00 00 00 
0712   08B9 00 00 00 00 
0712   08BD 00 00 00 00 
0712   08C1 00 00 00 00 
0712   08C5 00 00 00 00 
0712   08C9 00 00 00 00 
0712   08CD 00 00 00 00 
0712   08D1 00 00 00 00 
0712   08D5 00 00 00 00 
0712   08D9 00 00 00 00 
0712   08DD 00 00 00 00 
0712   08E1 00 00 00 00 
0712   08E5 00 00 00 00 
0712   08E9 00 00 00 00 
0712   08ED 00 00 00 00 
0712   08F1 00 00 00 00 
0712   08F5 00 00 00 00 
0712   08F9 00 00 00 00 
0712   08FD 00 00 00 00 
0712   0901 00 00 00 00 
0712   0905 00 00 00 00 
0712   0909 00 00 00 00 
0712   090D 00 00 00 00 
0712   0911 00 00 00 00 
0712   0915 00 00 00 00 
0712   0919 00 00 00 00 
0712   091D 00 00 00 00 
0712   0921 00 00 00 00 
0712   0925 00 00 00 00 
0712   0929 00 00 00 00 
0712   092D 00 00 00 00 
0712   0931 00 00 00 00 
0712   0935 00 00 00 00 
0713   0939 71 08       val: .dw val_data
0714   093B 00 00 00 00 buf_data: .fill 100, 0
0714   093F 00 00 00 00 
0714   0943 00 00 00 00 
0714   0947 00 00 00 00 
0714   094B 00 00 00 00 
0714   094F 00 00 00 00 
0714   0953 00 00 00 00 
0714   0957 00 00 00 00 
0714   095B 00 00 00 00 
0714   095F 00 00 00 00 
0714   0963 00 00 00 00 
0714   0967 00 00 00 00 
0714   096B 00 00 00 00 
0714   096F 00 00 00 00 
0714   0973 00 00 00 00 
0714   0977 00 00 00 00 
0714   097B 00 00 00 00 
0714   097F 00 00 00 00 
0714   0983 00 00 00 00 
0714   0987 00 00 00 00 
0714   098B 00 00 00 00 
0714   098F 00 00 00 00 
0714   0993 00 00 00 00 
0714   0997 00 00 00 00 
0714   099B 00 00 00 00 
0715   099F 3B 09       buf: .dw buf_data
0716   09A1 00 00       bufp: .dw 0
0717   09A3 44 69 76 69 _string_0: .db "Divide by zero error\n", 0
0717   09A7 64 65 20 62 
0717   09AB 79 20 7A 65 
0717   09AF 72 6F 20 65 
0717   09B3 72 72 6F 72 
0717   09B7 0A 00 
0718   09B9 0A 00       _string_1: .db "\n", 0
0719   09BB 55 6E 6B 6E _string_2: .db "Unknown input: ", 0
0719   09BF 6F 77 6E 20 
0719   09C3 69 6E 70 75 
0719   09C7 74 3A 20 00 
0720   09CB 45 72 72 6F _string_3: .db "Error: stack full, can't push: ", 0
0720   09CF 72 3A 20 73 
0720   09D3 74 61 63 6B 
0720   09D7 20 66 75 6C 
0720   09DB 6C 2C 20 63 
0720   09DF 61 6E 27 74 
0720   09E3 20 70 75 73 
0720   09E7 68 3A 20 
0721   09EA 45 72 72 6F _string_4: .db "Error: stack empty.\n", 0
0721   09EE 72 3A 20 73 
0721   09F2 74 61 63 6B 
0721   09F6 20 65 6D 70 
0721   09FA 74 79 2E 0A 
0721   09FE 00 
0722   09FF 45 72 72 6F _string_5: .db "Error: too many characters.\n", 0
0722   0A03 72 3A 20 74 
0722   0A07 6F 6F 20 6D 
0722   0A0B 61 6E 79 20 
0722   0A0F 63 68 61 72 
0722   0A13 61 63 74 65 
0722   0A17 72 73 2E 0A 
0722   0A1B 00 
0723   0A1C             ; --- END DATA BLOCK
0724   0A1C             
0725   0A1C             ; --- BEGIN INCLUDE BLOCK
0726   0A1C             .include "lib/stdio.asm"
0001+  0A1C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0A1C             ; stdio.s
0003+  0A1C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0A1C             .include "lib/string.asm"
0001++ 0A1C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0A1C             ; string.s
0003++ 0A1C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0A1C             
0005++ 0A1C             
0006++ 0A1C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0A1C             ; strrev
0008++ 0A1C             ; reverse a string
0009++ 0A1C             ; D = string address
0010++ 0A1C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0A1C             ; 01234
0012++ 0A1C             strrev:
0013++ 0A1C 4B          	pusha
0014++ 0A1D 07 63 0A    	call strlen	; length in C
0015++ 0A20 12          	mov a, c
0016++ 0A21 AF 01 00    	cmp a, 1
0017++ 0A24 D0 3E 0A    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0A27 7D          	dec a
0019++ 0A28 FD 4E       	mov si, d	; beginning of string
0020++ 0A2A FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0A2C 59          	add d, a	; end of string
0022++ 0A2D 12          	mov a, c
0023++ 0A2E FD 9B       	shr a		; divide by 2
0024++ 0A30 39          	mov c, a	; C now counts the steps
0025++ 0A31             strrev_L0:
0026++ 0A31 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0A32 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0A33 3E          	mov [d], al	; store left char into right side
0029++ 0A34 1B          	mov al, bl
0030++ 0A35 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0A36 7E          	dec c
0032++ 0A37 7F          	dec d
0033++ 0A38 C2 00 00    	cmp c, 0
0034++ 0A3B C7 31 0A    	jne strrev_L0
0035++ 0A3E             strrev_end:
0036++ 0A3E 4C          	popa
0037++ 0A3F 09          	ret
0038++ 0A40             	
0039++ 0A40             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0A40             ; strchr
0041++ 0A40             ; search string in D for char in AL
0042++ 0A40             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0A40             strchr:
0044++ 0A40             strchr_L0:
0045++ 0A40 32          	mov bl, [d]
0046++ 0A41 C1 00       	cmp bl, 0
0047++ 0A43 C6 4E 0A    	je strchr_end
0048++ 0A46 BA          	cmp al, bl
0049++ 0A47 C6 4E 0A    	je strchr_end
0050++ 0A4A 79          	inc d
0051++ 0A4B 0A 40 0A    	jmp strchr_L0
0052++ 0A4E             strchr_end:
0053++ 0A4E 1B          	mov al, bl
0054++ 0A4F 09          	ret
0055++ 0A50             
0056++ 0A50             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0A50             ; strstr
0058++ 0A50             ; find sub-string
0059++ 0A50             ; str1 in SI
0060++ 0A50             ; str2 in DI
0061++ 0A50             ; SI points to end of source string
0062++ 0A50             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0A50             strstr:
0064++ 0A50 DB          	push al
0065++ 0A51 DA          	push d
0066++ 0A52 E3          	push di
0067++ 0A53             strstr_loop:
0068++ 0A53 F3          	cmpsb					; compare a byte of the strings
0069++ 0A54 C7 5F 0A    	jne strstr_ret
0070++ 0A57 FC 00 00    	lea d, [di + 0]
0071++ 0A5A BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0A5C C7 53 0A    	jne strstr_loop				; equal chars but not at end
0073++ 0A5F             strstr_ret:
0074++ 0A5F F0          	pop di
0075++ 0A60 E7          	pop d
0076++ 0A61 E8          	pop al
0077++ 0A62 09          	ret
0078++ 0A63             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0A63             ; length of null terminated string
0080++ 0A63             ; result in C
0081++ 0A63             ; pointer in D
0082++ 0A63             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0A63             strlen:
0084++ 0A63 DA          	push d
0085++ 0A64 38 00 00    	mov c, 0
0086++ 0A67             strlen_L1:
0087++ 0A67 BD 00       	cmp byte [d], 0
0088++ 0A69 C6 71 0A    	je strlen_ret
0089++ 0A6C 79          	inc d
0090++ 0A6D 78          	inc c
0091++ 0A6E 0A 67 0A    	jmp strlen_L1
0092++ 0A71             strlen_ret:
0093++ 0A71 E7          	pop d
0094++ 0A72 09          	ret
0095++ 0A73             
0096++ 0A73             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0A73             ; STRCMP
0098++ 0A73             ; compare two strings
0099++ 0A73             ; str1 in SI
0100++ 0A73             ; str2 in DI
0101++ 0A73             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0A73             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0A73             strcmp:
0104++ 0A73 DB          	push al
0105++ 0A74 DA          	push d
0106++ 0A75 E3          	push di
0107++ 0A76 E2          	push si
0108++ 0A77             strcmp_loop:
0109++ 0A77 F3          	cmpsb					; compare a byte of the strings
0110++ 0A78 C7 83 0A    	jne strcmp_ret
0111++ 0A7B FB FF FF    	lea d, [si +- 1]
0112++ 0A7E BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0A80 C7 77 0A    	jne strcmp_loop				; equal chars but not at end
0114++ 0A83             strcmp_ret:
0115++ 0A83 EF          	pop si
0116++ 0A84 F0          	pop di
0117++ 0A85 E7          	pop d
0118++ 0A86 E8          	pop al
0119++ 0A87 09          	ret
0120++ 0A88             
0121++ 0A88             
0122++ 0A88             ; STRCPY
0123++ 0A88             ; copy null terminated string from SI to DI
0124++ 0A88             ; source in SI
0125++ 0A88             ; destination in DI
0126++ 0A88             strcpy:
0127++ 0A88 E2          	push si
0128++ 0A89 E3          	push di
0129++ 0A8A DB          	push al
0130++ 0A8B             strcpy_L1:
0131++ 0A8B F6          	lodsb
0132++ 0A8C F7          	stosb
0133++ 0A8D B9 00       	cmp al, 0
0134++ 0A8F C7 8B 0A    	jne strcpy_L1
0135++ 0A92             strcpy_end:
0136++ 0A92 E8          	pop al
0137++ 0A93 F0          	pop di
0138++ 0A94 EF          	pop si
0139++ 0A95 09          	ret
0140++ 0A96             
0141++ 0A96             ; STRCAT
0142++ 0A96             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0A96             ; source in SI
0144++ 0A96             ; destination in DI
0145++ 0A96             strcat:
0146++ 0A96 E2          	push si
0147++ 0A97 E3          	push di
0148++ 0A98 D7          	push a
0149++ 0A99 DA          	push d
0150++ 0A9A 50          	mov a, di
0151++ 0A9B 3C          	mov d, a
0152++ 0A9C             strcat_goto_end_L1:
0153++ 0A9C BD 00       	cmp byte[d], 0
0154++ 0A9E C6 A5 0A    	je strcat_start
0155++ 0AA1 79          	inc d
0156++ 0AA2 0A 9C 0A    	jmp strcat_goto_end_L1
0157++ 0AA5             strcat_start:
0158++ 0AA5 FD 50       	mov di, d
0159++ 0AA7             strcat_L1:
0160++ 0AA7 F6          	lodsb
0161++ 0AA8 F7          	stosb
0162++ 0AA9 B9 00       	cmp al, 0
0163++ 0AAB C7 A7 0A    	jne strcat_L1
0164++ 0AAE             strcat_end:
0165++ 0AAE E7          	pop d
0166++ 0AAF E4          	pop a
0167++ 0AB0 F0          	pop di
0168++ 0AB1 EF          	pop si
0169++ 0AB2 09          	ret
0005+  0AB3             
0006+  0AB3 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  0AB7 34 35 36 37 
0006+  0ABB 38 39 41 42 
0006+  0ABF 43 44 45 46 
0007+  0AC3 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  0AC7 1B 5B 48 00 
0008+  0ACB             
0009+  0ACB 01 00       table_power:.dw 1
0010+  0ACD 0A 00       			.dw 10
0011+  0ACF 64 00       			.dw 100
0012+  0AD1 E8 03       			.dw 1000
0013+  0AD3 10 27       			.dw 10000
0014+  0AD5             
0015+  0AD5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  0AD5             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  0AD5             ; ASCII in BL
0018+  0AD5             ; result in AL
0019+  0AD5             ; ascii for F = 0100 0110
0020+  0AD5             ; ascii for 9 = 0011 1001
0021+  0AD5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  0AD5             hex_ascii_encode:
0023+  0AD5 1B          	mov al, bl
0024+  0AD6 93 40       	test al, $40				; test if letter or number
0025+  0AD8 C7 DE 0A    	jnz hex_letter
0026+  0ADB 87 0F       	and al, $0F				; get number
0027+  0ADD 09          	ret
0028+  0ADE             hex_letter:
0029+  0ADE 87 0F       	and al, $0F				; get letter
0030+  0AE0 6A 09       	add al, 9
0031+  0AE2 09          	ret
0032+  0AE3             
0033+  0AE3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  0AE3             ; ATOI
0035+  0AE3             ; 2 letter hex string in B
0036+  0AE3             ; 8bit integer returned in AL
0037+  0AE3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0AE3             atoi:
0039+  0AE3 D8          	push b
0040+  0AE4 07 D5 0A    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  0AE7 30          	mov bl, bh
0042+  0AE8 DB          	push al					; save a
0043+  0AE9 07 D5 0A    	call hex_ascii_encode
0044+  0AEC EA          	pop bl	
0045+  0AED FD 9E 04    	shl al, 4
0046+  0AF0 8C          	or al, bl
0047+  0AF1 E5          	pop b
0048+  0AF2 09          	ret	
0049+  0AF3             
0050+  0AF3             
0051+  0AF3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  0AF3             ; printf
0053+  0AF3             ; no need for explanations!
0054+  0AF3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0AF3             printf:
0056+  0AF3 09          	ret
0057+  0AF4             
0058+  0AF4             
0059+  0AF4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  0AF4             ; scanf
0061+  0AF4             ; no need for explanations!
0062+  0AF4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  0AF4             scanf:
0064+  0AF4 09          	ret
0065+  0AF5             
0066+  0AF5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  0AF5             ; ITOA
0068+  0AF5             ; 8bit value in BL
0069+  0AF5             ; 2 byte ASCII result in A
0070+  0AF5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  0AF5             itoa:
0072+  0AF5 DA          	push d
0073+  0AF6 D8          	push b
0074+  0AF7 A7 00       	mov bh, 0
0075+  0AF9 FD A4 04    	shr bl, 4	
0076+  0AFC 74          	mov d, b
0077+  0AFD 1F B3 0A    	mov al, [d + s_hex_digits]
0078+  0B00 23          	mov ah, al
0079+  0B01             	
0080+  0B01 E5          	pop b
0081+  0B02 D8          	push b
0082+  0B03 A7 00       	mov bh, 0
0083+  0B05 FD 87 0F    	and bl, $0F
0084+  0B08 74          	mov d, b
0085+  0B09 1F B3 0A    	mov al, [d + s_hex_digits]
0086+  0B0C E5          	pop b
0087+  0B0D E7          	pop d
0088+  0B0E 09          	ret
0089+  0B0F             
0090+  0B0F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  0B0F             ; HEX STRING TO BINARY
0092+  0B0F             ; di = destination address
0093+  0B0F             ; si = source
0094+  0B0F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  0B0F             hex_to_int:
0096+  0B0F             hex_to_int_L1:
0097+  0B0F F6          	lodsb					; load from [SI] to AL
0098+  0B10 B9 00       	cmp al, 0				; check if ASCII 0
0099+  0B12 C6 1F 0B    	jz hex_to_int_ret
0100+  0B15 36          	mov bh, al
0101+  0B16 F6          	lodsb
0102+  0B17 2F          	mov bl, al
0103+  0B18 07 E3 0A    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  0B1B F7          	stosb					; store AL to [DI]
0105+  0B1C 0A 0F 0B    	jmp hex_to_int_L1
0106+  0B1F             hex_to_int_ret:
0107+  0B1F 09          	ret		
0108+  0B20             
0109+  0B20             
0110+  0B20             
0111+  0B20             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  0B20             ; GETCHAR
0113+  0B20             ; char in ah
0114+  0B20             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  0B20             getchar:
0116+  0B20 DB          	push al
0117+  0B21             getchar_retry:
0118+  0B21 FD 0C       	sti
0119+  0B23 19 01       	mov al, 1
0120+  0B25 05 03       	syscall sys_io			; receive in AH
0121+  0B27 B9 00       	cmp al, 0			; check if any char was receive
0122+  0B29 C6 21 0B    	je getchar_retry
0123+  0B2C E8          	pop al
0124+  0B2D 09          	ret
0125+  0B2E             
0126+  0B2E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  0B2E             ; PUTCHAR
0128+  0B2E             ; char in ah
0129+  0B2E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0B2E             putchar:
0131+  0B2E D7          	push a
0132+  0B2F 19 00       	mov al, 0
0133+  0B31 05 03       	syscall sys_io			; char in AH
0134+  0B33 E4          	pop a
0135+  0B34 09          	ret
0136+  0B35             
0137+  0B35             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  0B35             ;; INPUT A STRING
0139+  0B35             ;; terminates with null
0140+  0B35             ;; pointer in D
0141+  0B35             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  0B35             gets:
0143+  0B35 D7          	push a
0144+  0B36 DA          	push d
0145+  0B37             gets_loop:
0146+  0B37 FD 0C       	sti
0147+  0B39 19 01       	mov al, 1
0148+  0B3B 05 03       	syscall sys_io			; receive in AH
0149+  0B3D B9 00       	cmp al, 0				; check error code (AL)
0150+  0B3F C6 37 0B    	je gets_loop			; if no char received, retry
0151+  0B42             
0152+  0B42 76 1B       	cmp ah, 27
0153+  0B44 C6 65 0B    	je gets_telnet_escape
0154+  0B47 76 0A       	cmp ah, $0A				; LF
0155+  0B49 C6 BE 0B    	je gets_end
0156+  0B4C 76 0D       	cmp ah, $0D				; CR
0157+  0B4E C6 BE 0B    	je gets_end
0158+  0B51 76 5C       	cmp ah, $5C				; '\\'
0159+  0B53 C6 95 0B    	je gets_escape
0160+  0B56             	
0161+  0B56 76 08       	cmp ah, $08			; check for backspace
0162+  0B58 C6 61 0B    	je gets_backspace
0163+  0B5B             
0164+  0B5B 1A          	mov al, ah
0165+  0B5C 3E          	mov [d], al
0166+  0B5D 79          	inc d
0167+  0B5E 0A 37 0B    	jmp gets_loop
0168+  0B61             gets_backspace:
0169+  0B61 7F          	dec d
0170+  0B62 0A 37 0B    	jmp gets_loop
0171+  0B65             gets_telnet_escape:
0172+  0B65 FD 0C       	sti
0173+  0B67 19 01       	mov al, 1
0174+  0B69 05 03       	syscall sys_io				; receive in AH without echo
0175+  0B6B B9 00       	cmp al, 0					; check error code (AL)
0176+  0B6D C6 65 0B    	je gets_telnet_escape		; if no char received, retry
0177+  0B70 76 5B       	cmp ah, '['
0178+  0B72 C7 37 0B    	jne gets_loop
0179+  0B75             gets_telnet_escape_phase2:
0180+  0B75 FD 0C       	sti
0181+  0B77 19 01       	mov al, 1
0182+  0B79 05 03       	syscall sys_io					; receive in AH without echo
0183+  0B7B B9 00       	cmp al, 0						; check error code (AL)
0184+  0B7D C6 75 0B    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  0B80 76 44       	cmp ah, 'D'
0186+  0B82 C6 8D 0B    	je gets_left_arrow
0187+  0B85 76 43       	cmp ah, 'C'
0188+  0B87 C6 91 0B    	je gets_right_arrow
0189+  0B8A 0A 37 0B    	jmp gets_loop
0190+  0B8D             gets_left_arrow:
0191+  0B8D 7F          	dec d
0192+  0B8E 0A 37 0B    	jmp gets_loop
0193+  0B91             gets_right_arrow:
0194+  0B91 79          	inc d
0195+  0B92 0A 37 0B    	jmp gets_loop
0196+  0B95             gets_escape:
0197+  0B95 FD 0C       	sti
0198+  0B97 19 01       	mov al, 1
0199+  0B99 05 03       	syscall sys_io			; receive in AH
0200+  0B9B B9 00       	cmp al, 0				; check error code (AL)
0201+  0B9D C6 95 0B    	je gets_escape			; if no char received, retry
0202+  0BA0 76 6E       	cmp ah, 'n'
0203+  0BA2 C6 B0 0B    	je gets_LF
0204+  0BA5 76 72       	cmp ah, 'r'
0205+  0BA7 C6 B7 0B    	je gets_CR
0206+  0BAA 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  0BAB 3E          	mov [d], al
0208+  0BAC 79          	inc d
0209+  0BAD 0A 37 0B    	jmp gets_loop
0210+  0BB0             gets_LF:
0211+  0BB0 19 0A       	mov al, $0A
0212+  0BB2 3E          	mov [d], al
0213+  0BB3 79          	inc d
0214+  0BB4 0A 37 0B    	jmp gets_loop
0215+  0BB7             gets_CR:
0216+  0BB7 19 0D       	mov al, $0D
0217+  0BB9 3E          	mov [d], al
0218+  0BBA 79          	inc d
0219+  0BBB 0A 37 0B    	jmp gets_loop
0220+  0BBE             gets_end:
0221+  0BBE 19 00       	mov al, 0
0222+  0BC0 3E          	mov [d], al				; terminate string
0223+  0BC1 E7          	pop d
0224+  0BC2 E4          	pop a
0225+  0BC3 09          	ret
0226+  0BC4             
0227+  0BC4             
0228+  0BC4             
0229+  0BC4             
0230+  0BC4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  0BC4             ;; INPUT TEXT
0232+  0BC4             ;; terminated with CTRL+D
0233+  0BC4             ;; pointer in D
0234+  0BC4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  0BC4             gettxt:
0236+  0BC4 D7          	push a
0237+  0BC5 DA          	push d
0238+  0BC6             gettxt_loop:
0239+  0BC6 19 01       	mov al, 1
0240+  0BC8 05 03       	syscall sys_io			; receive in AH
0241+  0BCA B9 00       	cmp al, 0				; check error code (AL)
0242+  0BCC C6 C6 0B    	je gettxt_loop		; if no char received, retry
0243+  0BCF 76 04       	cmp ah, 4			; EOT
0244+  0BD1 C6 0F 0C    	je gettxt_end
0245+  0BD4 76 08       	cmp ah, $08			; check for backspace
0246+  0BD6 C6 0B 0C    	je gettxt_backspace
0247+  0BD9 76 5C       	cmp ah, $5C				; '\\'
0248+  0BDB C6 E4 0B    	je gettxt_escape
0249+  0BDE 1A          	mov al, ah
0250+  0BDF 3E          	mov [d], al
0251+  0BE0 79          	inc d
0252+  0BE1 0A C6 0B    	jmp gettxt_loop
0253+  0BE4             gettxt_escape:
0254+  0BE4 19 01       	mov al, 1
0255+  0BE6 05 03       	syscall sys_io			; receive in AH
0256+  0BE8 B9 00       	cmp al, 0				; check error code (AL)
0257+  0BEA C6 E4 0B    	je gettxt_escape		; if no char received, retry
0258+  0BED 76 6E       	cmp ah, 'n'
0259+  0BEF C6 FD 0B    	je gettxt_LF
0260+  0BF2 76 72       	cmp ah, 'r'
0261+  0BF4 C6 04 0C    	je gettxt_CR
0262+  0BF7 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  0BF8 3E          	mov [d], al
0264+  0BF9 79          	inc d
0265+  0BFA 0A C6 0B    	jmp gettxt_loop
0266+  0BFD             gettxt_LF:
0267+  0BFD 19 0A       	mov al, $0A
0268+  0BFF 3E          	mov [d], al
0269+  0C00 79          	inc d
0270+  0C01 0A C6 0B    	jmp gettxt_loop
0271+  0C04             gettxt_CR:
0272+  0C04 19 0D       	mov al, $0D
0273+  0C06 3E          	mov [d], al
0274+  0C07 79          	inc d
0275+  0C08 0A C6 0B    	jmp gettxt_loop
0276+  0C0B             gettxt_backspace:
0277+  0C0B 7F          	dec d
0278+  0C0C 0A C6 0B    	jmp gettxt_loop
0279+  0C0F             gettxt_end:
0280+  0C0F 19 00       	mov al, 0
0281+  0C11 3E          	mov [d], al				; terminate string
0282+  0C12 E7          	pop d
0283+  0C13 E4          	pop a
0284+  0C14 09          	ret
0285+  0C15             
0286+  0C15             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  0C15             ; PRINT NEW LINE
0288+  0C15             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  0C15             printnl:
0290+  0C15 D7          	push a
0291+  0C16 10 00 0A    	mov a, $0A00
0292+  0C19 05 03       	syscall sys_io
0293+  0C1B 10 00 0D    	mov a, $0D00
0294+  0C1E 05 03       	syscall sys_io
0295+  0C20 E4          	pop a
0296+  0C21 09          	ret
0297+  0C22             
0298+  0C22             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  0C22             ; strtoint
0300+  0C22             ; 4 digit hex string number in d
0301+  0C22             ; integer returned in A
0302+  0C22             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  0C22             strtointx:
0304+  0C22 D8          	push b
0305+  0C23 32          	mov bl, [d]
0306+  0C24 37          	mov bh, bl
0307+  0C25 33 01 00    	mov bl, [d + 1]
0308+  0C28 07 E3 0A    	call atoi				; convert to int in AL
0309+  0C2B 23          	mov ah, al				; move to AH
0310+  0C2C 33 02 00    	mov bl, [d + 2]
0311+  0C2F 37          	mov bh, bl
0312+  0C30 33 03 00    	mov bl, [d + 3]
0313+  0C33 07 E3 0A    	call atoi				; convert to int in AL
0314+  0C36 E5          	pop b
0315+  0C37 09          	ret
0316+  0C38             
0317+  0C38             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  0C38             ; strtoint
0319+  0C38             ; 5 digit base10 string number in d
0320+  0C38             ; integer returned in A
0321+  0C38             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  0C38             strtoint:
0323+  0C38 E2          	push si
0324+  0C39 D8          	push b
0325+  0C3A D9          	push c
0326+  0C3B DA          	push d
0327+  0C3C 07 63 0A    	call strlen			; get string length in C
0328+  0C3F 7E          	dec c
0329+  0C40 FD 4E       	mov si, d
0330+  0C42 12          	mov a, c
0331+  0C43 FD 99       	shl a
0332+  0C45 3B CB 0A    	mov d, table_power
0333+  0C48 59          	add d, a
0334+  0C49 38 00 00    	mov c, 0
0335+  0C4C             strtoint_L0:
0336+  0C4C F6          	lodsb			; load ASCII to al
0337+  0C4D B9 00       	cmp al, 0
0338+  0C4F C6 62 0C    	je strtoint_end
0339+  0C52 6F 30       	sub al, $30		; make into integer
0340+  0C54 22 00       	mov ah, 0
0341+  0C56 2A          	mov b, [d]
0342+  0C57 AC          	mul a, b			; result in B since it fits in 16bits
0343+  0C58 11          	mov a, b
0344+  0C59 28          	mov b, c
0345+  0C5A 54          	add a, b
0346+  0C5B 39          	mov c, a
0347+  0C5C 63 02 00    	sub d, 2
0348+  0C5F 0A 4C 0C    	jmp strtoint_L0
0349+  0C62             strtoint_end:
0350+  0C62 12          	mov a, c
0351+  0C63 E7          	pop d
0352+  0C64 E6          	pop c
0353+  0C65 E5          	pop b
0354+  0C66 EF          	pop si
0355+  0C67 09          	ret
0356+  0C68             
0357+  0C68             
0358+  0C68             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  0C68             ; PRINT NULL TERMINATED STRING
0360+  0C68             ; pointer in D
0361+  0C68             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  0C68             puts:
0363+  0C68 D7          	push a
0364+  0C69 DA          	push d
0365+  0C6A             puts_L1:
0366+  0C6A 1E          	mov al, [d]
0367+  0C6B B9 00       	cmp al, 0
0368+  0C6D C6 79 0C    	jz puts_END
0369+  0C70 23          	mov ah, al
0370+  0C71 19 00       	mov al, 0
0371+  0C73 05 03       	syscall sys_io
0372+  0C75 79          	inc d
0373+  0C76 0A 6A 0C    	jmp puts_L1
0374+  0C79             puts_END:
0375+  0C79 E7          	pop d
0376+  0C7A E4          	pop a
0377+  0C7B 09          	ret
0378+  0C7C             
0379+  0C7C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  0C7C             ; PRINT N SIZE STRING
0381+  0C7C             ; pointer in D
0382+  0C7C             ; size in C
0383+  0C7C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  0C7C             putsn:
0385+  0C7C DB          	push al
0386+  0C7D DA          	push d
0387+  0C7E D9          	push c
0388+  0C7F             putsn_L0:
0389+  0C7F 1E          	mov al, [d]
0390+  0C80 23          	mov ah, al
0391+  0C81 19 00       	mov al, 0
0392+  0C83 05 03       	syscall sys_io
0393+  0C85 79          	inc d
0394+  0C86 7E          	dec c	
0395+  0C87 C2 00 00    	cmp c, 0
0396+  0C8A C7 7F 0C    	jne putsn_L0
0397+  0C8D             putsn_end:
0398+  0C8D E6          	pop c
0399+  0C8E E7          	pop d
0400+  0C8F E8          	pop al
0401+  0C90 09          	ret
0402+  0C91             
0403+  0C91             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  0C91             ; print 16bit decimal number
0405+  0C91             ; input number in A
0406+  0C91             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  0C91             print_u16d:
0408+  0C91 D7          	push a
0409+  0C92 D8          	push b
0410+  0C93 26 10 27    	mov b, 10000
0411+  0C96 AE          	div a, b			; get 10000 coeff.
0412+  0C97 07 BD 0C    	call print_number
0413+  0C9A 11          	mov a, b
0414+  0C9B 26 E8 03    	mov b, 1000
0415+  0C9E AE          	div a, b			; get 10000 coeff.
0416+  0C9F 07 BD 0C    	call print_number
0417+  0CA2 11          	mov a, b
0418+  0CA3 26 64 00    	mov b, 100
0419+  0CA6 AE          	div a, b
0420+  0CA7 07 BD 0C    	call print_number
0421+  0CAA 11          	mov a, b
0422+  0CAB 26 0A 00    	mov b, 10
0423+  0CAE AE          	div a, b
0424+  0CAF 07 BD 0C    	call print_number
0425+  0CB2 11          	mov a, b
0426+  0CB3 6A 30       	add al, $30
0427+  0CB5 23          	mov ah, al
0428+  0CB6 19 00       	mov al, 0
0429+  0CB8 05 03       	syscall sys_io	; print coeff
0430+  0CBA E5          	pop b
0431+  0CBB E4          	pop a
0432+  0CBC 09          	ret
0433+  0CBD             
0434+  0CBD             
0435+  0CBD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  0CBD             ; if A == 0, print space
0437+  0CBD             ; else print A
0438+  0CBD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0439+  0CBD             print_number:
0440+  0CBD 6A 30       	add al, $30
0441+  0CBF 23          	mov ah, al
0442+  0CC0 07 2E 0B    	call putchar
0443+  0CC3 09          	ret
0444+  0CC4             
0445+  0CC4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0446+  0CC4             ; PRINT 16BIT HEX INTEGER
0447+  0CC4             ; integer value in reg B
0448+  0CC4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  0CC4             print_u16x:
0450+  0CC4 D7          	push a
0451+  0CC5 D8          	push b
0452+  0CC6 DD          	push bl
0453+  0CC7 30          	mov bl, bh
0454+  0CC8 07 F5 0A    	call itoa				; convert bh to char in A
0455+  0CCB 2F          	mov bl, al				; save al
0456+  0CCC 19 00       	mov al, 0
0457+  0CCE 05 03       	syscall sys_io				; display AH
0458+  0CD0 24          	mov ah, bl				; retrieve al
0459+  0CD1 19 00       	mov al, 0
0460+  0CD3 05 03       	syscall sys_io				; display AL
0461+  0CD5             
0462+  0CD5 EA          	pop bl
0463+  0CD6 07 F5 0A    	call itoa				; convert bh to char in A
0464+  0CD9 2F          	mov bl, al				; save al
0465+  0CDA 19 00       	mov al, 0
0466+  0CDC 05 03       	syscall sys_io				; display AH
0467+  0CDE 24          	mov ah, bl				; retrieve al
0468+  0CDF 19 00       	mov al, 0
0469+  0CE1 05 03       	syscall sys_io				; display AL
0470+  0CE3             
0471+  0CE3 E5          	pop b
0472+  0CE4 E4          	pop a
0473+  0CE5 09          	ret
0474+  0CE6             
0475+  0CE6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  0CE6             ; INPUT 16BIT HEX INTEGER
0477+  0CE6             ; read 16bit integer into A
0478+  0CE6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  0CE6             scan_u16x:
0480+  0CE6 F8 10 00    	enter 16
0481+  0CE9 D8          	push b
0482+  0CEA DA          	push d
0483+  0CEB             
0484+  0CEB FA F1 FF    	lea d, [bp + -15]
0485+  0CEE 07 35 0B    	call gets				; get number
0486+  0CF1             
0487+  0CF1 32          	mov bl, [d]
0488+  0CF2 37          	mov bh, bl
0489+  0CF3 33 01 00    	mov bl, [d + 1]
0490+  0CF6 07 E3 0A    	call atoi				; convert to int in AL
0491+  0CF9 23          	mov ah, al				; move to AH
0492+  0CFA             
0493+  0CFA 33 02 00    	mov bl, [d + 2]
0494+  0CFD 37          	mov bh, bl
0495+  0CFE 33 03 00    	mov bl, [d + 3]
0496+  0D01 07 E3 0A    	call atoi				; convert to int in AL
0497+  0D04             
0498+  0D04 E7          	pop d
0499+  0D05 E5          	pop b
0500+  0D06 F9          	leave
0501+  0D07 09          	ret
0502+  0D08             
0503+  0D08             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0504+  0D08             ; PRINT 8bit HEX INTEGER
0505+  0D08             ; integer value in reg bl
0506+  0D08             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  0D08             print_u8x:
0508+  0D08 D7          	push a
0509+  0D09 DD          	push bl
0510+  0D0A             
0511+  0D0A 07 F5 0A    	call itoa				; convert bl to char in A
0512+  0D0D 2F          	mov bl, al				; save al
0513+  0D0E 19 00       	mov al, 0
0514+  0D10 05 03       	syscall sys_io				; display AH
0515+  0D12 24          	mov ah, bl				; retrieve al
0516+  0D13 19 00       	mov al, 0
0517+  0D15 05 03       	syscall sys_io				; display AL
0518+  0D17             
0519+  0D17 EA          	pop bl
0520+  0D18 E4          	pop a
0521+  0D19 09          	ret
0522+  0D1A             
0523+  0D1A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0524+  0D1A             ; print 8bit decimal unsigned number
0525+  0D1A             ; input number in AL
0526+  0D1A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  0D1A             print_u8d:
0528+  0D1A D7          	push a
0529+  0D1B D8          	push b
0530+  0D1C             
0531+  0D1C 22 00       	mov ah, 0
0532+  0D1E 26 64 00    	mov b, 100
0533+  0D21 AE          	div a, b
0534+  0D22 D8          	push b			; save remainder
0535+  0D23 B9 00       	cmp al, 0
0536+  0D25 C6 2F 0D    	je skip100
0537+  0D28 6A 30       	add al, $30
0538+  0D2A 23          	mov ah, al
0539+  0D2B 19 00       	mov al, 0
0540+  0D2D 05 03       	syscall sys_io	; print coeff
0541+  0D2F             skip100:
0542+  0D2F E4          	pop a
0543+  0D30 22 00       	mov ah, 0
0544+  0D32 26 0A 00    	mov b, 10
0545+  0D35 AE          	div a, b
0546+  0D36 D8          	push b			; save remainder
0547+  0D37 B9 00       	cmp al, 0
0548+  0D39 C6 43 0D    	je skip10
0549+  0D3C 6A 30       	add al, $30
0550+  0D3E 23          	mov ah, al
0551+  0D3F 19 00       	mov al, 0
0552+  0D41 05 03       	syscall sys_io	; print coeff
0553+  0D43             skip10:
0554+  0D43 E4          	pop a
0555+  0D44 1B          	mov al, bl
0556+  0D45 6A 30       	add al, $30
0557+  0D47 23          	mov ah, al
0558+  0D48 19 00       	mov al, 0
0559+  0D4A 05 03       	syscall sys_io	; print coeff
0560+  0D4C E5          	pop b
0561+  0D4D E4          	pop a
0562+  0D4E 09          	ret
0563+  0D4F             
0564+  0D4F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0565+  0D4F             ; INPUT 8BIT HEX INTEGER
0566+  0D4F             ; read 8bit integer into AL
0567+  0D4F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  0D4F             scan_u8x:
0569+  0D4F F8 04 00    	enter 4
0570+  0D52 D8          	push b
0571+  0D53 DA          	push d
0572+  0D54             
0573+  0D54 FA FD FF    	lea d, [bp + -3]
0574+  0D57 07 35 0B    	call gets				; get number
0575+  0D5A             
0576+  0D5A 32          	mov bl, [d]
0577+  0D5B 37          	mov bh, bl
0578+  0D5C 33 01 00    	mov bl, [d + 1]
0579+  0D5F 07 E3 0A    	call atoi				; convert to int in AL
0580+  0D62             
0581+  0D62 E7          	pop d
0582+  0D63 E5          	pop b
0583+  0D64 F9          	leave
0584+  0D65 09          	ret
0585+  0D66             
0586+  0D66             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  0D66             ; input decimal number
0588+  0D66             ; result in A
0589+  0D66             ; 655'\0'
0590+  0D66             ; low--------high
0591+  0D66             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0592+  0D66             scan_u16d:
0593+  0D66 F8 08 00    	enter 8
0594+  0D69 E2          	push si
0595+  0D6A D8          	push b
0596+  0D6B D9          	push c
0597+  0D6C DA          	push d
0598+  0D6D FA F9 FF    	lea d, [bp +- 7]
0599+  0D70 07 35 0B    	call gets
0600+  0D73 07 63 0A    	call strlen			; get string length in C
0601+  0D76 7E          	dec c
0602+  0D77 FD 4E       	mov si, d
0603+  0D79 12          	mov a, c
0604+  0D7A FD 99       	shl a
0605+  0D7C 3B CB 0A    	mov d, table_power
0606+  0D7F 59          	add d, a
0607+  0D80 38 00 00    	mov c, 0
0608+  0D83             mul_loop:
0609+  0D83 F6          	lodsb			; load ASCII to al
0610+  0D84 B9 00       	cmp al, 0
0611+  0D86 C6 99 0D    	je mul_exit
0612+  0D89 6F 30       	sub al, $30		; make into integer
0613+  0D8B 22 00       	mov ah, 0
0614+  0D8D 2A          	mov b, [d]
0615+  0D8E AC          	mul a, b			; result in B since it fits in 16bits
0616+  0D8F 11          	mov a, b
0617+  0D90 28          	mov b, c
0618+  0D91 54          	add a, b
0619+  0D92 39          	mov c, a
0620+  0D93 63 02 00    	sub d, 2
0621+  0D96 0A 83 0D    	jmp mul_loop
0622+  0D99             mul_exit:
0623+  0D99 12          	mov a, c
0624+  0D9A E7          	pop d
0625+  0D9B E6          	pop c
0626+  0D9C E5          	pop b
0627+  0D9D EF          	pop si
0628+  0D9E F9          	leave
0629+  0D9F 09          	ret
0727   0DA0             ; --- END INCLUDE BLOCK
0728   0DA0             
0729   0DA0             
0730   0DA0             .end
tasm: Number of errors = 0
