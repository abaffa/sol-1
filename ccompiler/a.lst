0001   0000             ; --- FILENAME: strcat.c
0002   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0400             .org PROC_TEXT_ORG
0004   0400             
0005   0400             ; --- BEGIN TEXT BLOCK
0006   0400             main:
0007   0400 D2            push bp
0008   0401 9B            mov bp, sp
0009   0402 26 EE 05      mov b, _string_0
0010   0405 FD AB         swp b
0011   0407 D8            push b
0012   0408 07 99 05      call print
0013   040B 51 02 00      add sp, 2
0014   040E 29 D6 05      mov b, [s1]
0015   0411 FD AB         swp b
0016   0413 D8            push b
0017   0414 07 99 05      call print
0018   0417 51 02 00      add sp, 2
0019   041A 26 FC 05      mov b, _string_1
0020   041D FD AB         swp b
0021   041F D8            push b
0022   0420 07 99 05      call print
0023   0423 51 02 00      add sp, 2
0024   0426 26 FE 05      mov b, _string_2
0025   0429 FD AB         swp b
0026   042B D8            push b
0027   042C 07 99 05      call print
0028   042F 51 02 00      add sp, 2
0029   0432 29 EC 05      mov b, [s2]
0030   0435 FD AB         swp b
0031   0437 D8            push b
0032   0438 07 99 05      call print
0033   043B 51 02 00      add sp, 2
0034   043E 26 FC 05      mov b, _string_1
0035   0441 FD AB         swp b
0036   0443 D8            push b
0037   0444 07 99 05      call print
0038   0447 51 02 00      add sp, 2
0039   044A 26 07 06      mov b, _string_3
0040   044D FD AB         swp b
0041   044F D8            push b
0042   0450 07 99 05      call print
0043   0453 51 02 00      add sp, 2
0044   0456 29 D6 05      mov b, [s1]
0045   0459 FD AB         swp b
0046   045B D8            push b
0047   045C 29 EC 05      mov b, [s2]
0048   045F FD AB         swp b
0049   0461 D8            push b
0050   0462 07 D2 04      call _strcat
0051   0465 51 04 00      add sp, 4
0052   0468 29 D6 05      mov b, [s1]
0053   046B FD AB         swp b
0054   046D D8            push b
0055   046E 07 99 05      call print
0056   0471 51 02 00      add sp, 2
0057   0474 26 FC 05      mov b, _string_1
0058   0477 FD AB         swp b
0059   0479 D8            push b
0060   047A 07 99 05      call print
0061   047D 51 02 00      add sp, 2
0062   0480 26 00 00      mov b, 0
0063   0483 F9            leave
0064   0484 05 0B         syscall sys_terminate_proc
0065   0486             _strlen:
0066   0486 D2            push bp
0067   0487 9B            mov bp, sp
0068   0488 52 02 00      sub sp, 2 ; length
0069   048B 26 00 00      mov b, 0
0070   048E D7            push a
0071   048F 11            mov a, b
0072   0490 45 FF FF      mov [bp + -1], a ; length
0073   0493 E4            pop a
0074   0494             _while1_cond:
0075   0494 FA 05 00      lea d, [bp + 5] ; str
0076   0497 2A            mov b, [d]
0077   0498 D7            push a
0078   0499 11            mov a, b
0079   049A 2C FF FF      mov b, [bp + -1] ; length
0080   049D 54            add a, b
0081   049E 27            mov b, a
0082   049F E4            pop a
0083   04A0 74            mov d, b
0084   04A1 32            mov bl, [d]
0085   04A2 A7 00         mov bh, 0
0086   04A4 D7            push a
0087   04A5 11            mov a, b
0088   04A6 26 00 00      mov b, 0
0089   04A9 B0            cmp a, b
0090   04AA 0E            lodflgs
0091   04AB 87 01         and al, %00000001
0092   04AD 8F 01         xor al, %00000001 ; !=
0093   04AF B9 00         cmp al, 0
0094   04B1 0E            lodflgs
0095   04B2 96            not al
0096   04B3 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0097   04B5 22 00         mov ah, 0
0098   04B7 27            mov b, a
0099   04B8 E4            pop a
0100   04B9 C0 00 00      cmp b, 0
0101   04BC C6 CD 04      je _while1_exit
0102   04BF             _while1_block:
0103   04BF 2C FF FF      mov b, [bp + -1] ; length
0104   04C2 FD 77         inc b
0105   04C4 D7            push a
0106   04C5 11            mov a, b
0107   04C6 45 FF FF      mov [bp + -1], a ; length
0108   04C9 E4            pop a
0109   04CA 0A 94 04      jmp _while1_cond
0110   04CD             _while1_exit:
0111   04CD 2C FF FF      mov b, [bp + -1] ; length
0112   04D0 F9            leave
0113   04D1 09            ret
0114   04D2             _strcat:
0115   04D2 D2            push bp
0116   04D3 9B            mov bp, sp
0117   04D4 52 02 00      sub sp, 2 ; dest_len
0118   04D7 52 02 00      sub sp, 2 ; i
0119   04DA FA 07 00      lea d, [bp + 7] ; dest
0120   04DD 2A            mov b, [d]
0121   04DE FD AB         swp b
0122   04E0 D8            push b
0123   04E1 07 86 04      call _strlen
0124   04E4 51 02 00      add sp, 2
0125   04E7 D7            push a
0126   04E8 11            mov a, b
0127   04E9 45 FF FF      mov [bp + -1], a ; dest_len
0128   04EC E4            pop a
0129   04ED             _for2_init:
0130   04ED 26 00 00      mov b, 0
0131   04F0 D7            push a
0132   04F1 11            mov a, b
0133   04F2 45 FD FF      mov [bp + -3], a ; i
0134   04F5 E4            pop a
0135   04F6             _for2_cond:
0136   04F6 FA 05 00      lea d, [bp + 5] ; src
0137   04F9 2A            mov b, [d]
0138   04FA D7            push a
0139   04FB 11            mov a, b
0140   04FC 2C FD FF      mov b, [bp + -3] ; i
0141   04FF 54            add a, b
0142   0500 27            mov b, a
0143   0501 E4            pop a
0144   0502 74            mov d, b
0145   0503 32            mov bl, [d]
0146   0504 A7 00         mov bh, 0
0147   0506 D7            push a
0148   0507 11            mov a, b
0149   0508 26 00 00      mov b, 0
0150   050B B0            cmp a, b
0151   050C 0E            lodflgs
0152   050D 87 01         and al, %00000001
0153   050F 8F 01         xor al, %00000001 ; !=
0154   0511 B9 00         cmp al, 0
0155   0513 0E            lodflgs
0156   0514 96            not al
0157   0515 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0158   0517 22 00         mov ah, 0
0159   0519 27            mov b, a
0160   051A E4            pop a
0161   051B C0 00 00      cmp b, 0
0162   051E C6 56 05      je _for2_exit
0163   0521             _for2_block:
0164   0521 FA 07 00      lea d, [bp + 7] ; dest
0165   0524 2A            mov b, [d]
0166   0525 D7            push a
0167   0526 11            mov a, b
0168   0527 2C FF FF      mov b, [bp + -1] ; dest_len
0169   052A 54            add a, b
0170   052B 27            mov b, a
0171   052C 11            mov a, b
0172   052D 2C FD FF      mov b, [bp + -3] ; i
0173   0530 54            add a, b
0174   0531 27            mov b, a
0175   0532 E4            pop a
0176   0533 74            mov d, b
0177   0534 DA            push d
0178   0535 FA 05 00      lea d, [bp + 5] ; src
0179   0538 2A            mov b, [d]
0180   0539 D7            push a
0181   053A 11            mov a, b
0182   053B 2C FD FF      mov b, [bp + -3] ; i
0183   053E 54            add a, b
0184   053F 27            mov b, a
0185   0540 E4            pop a
0186   0541 74            mov d, b
0187   0542 32            mov bl, [d]
0188   0543 A7 00         mov bh, 0
0189   0545 E7            pop d
0190   0546 1B            mov al, bl
0191   0547 3E            mov [d], al
0192   0548             _for2_update:
0193   0548 2C FD FF      mov b, [bp + -3] ; i
0194   054B FD 77         inc b
0195   054D D7            push a
0196   054E 11            mov a, b
0197   054F 45 FD FF      mov [bp + -3], a ; i
0198   0552 E4            pop a
0199   0553 0A F6 04      jmp _for2_cond
0200   0556             _for2_exit:
0201   0556 FA 07 00      lea d, [bp + 7] ; dest
0202   0559 2A            mov b, [d]
0203   055A D7            push a
0204   055B 11            mov a, b
0205   055C 2C FF FF      mov b, [bp + -1] ; dest_len
0206   055F 54            add a, b
0207   0560 27            mov b, a
0208   0561 11            mov a, b
0209   0562 2C FD FF      mov b, [bp + -3] ; i
0210   0565 54            add a, b
0211   0566 27            mov b, a
0212   0567 E4            pop a
0213   0568 74            mov d, b
0214   0569 DA            push d
0215   056A 26 00 00      mov b, 0
0216   056D E7            pop d
0217   056E 1B            mov al, bl
0218   056F 3E            mov [d], al
0219   0570 FA 07 00      lea d, [bp + 7] ; dest
0220   0573 2A            mov b, [d]
0221   0574 F9            leave
0222   0575 09            ret
0223   0576             scann:
0224   0576 D2            push bp
0225   0577 9B            mov bp, sp
0226   0578 52 02 00      sub sp, 2 ; m
0227   057B             
0228   057B             ; --- BEGIN INLINE ASM BLOCK
0229   057B 07 61 09      call scan_u16d
0230   057E 45 FF FF      mov [bp + -1], a
0231   0581             ; --- END INLINE ASM BLOCK
0232   0581             
0233   0581 FA 05 00      lea d, [bp + 5] ; n
0234   0584 2A            mov b, [d]
0235   0585 74            mov d, b
0236   0586 DA            push d
0237   0587 2C FF FF      mov b, [bp + -1] ; m
0238   058A E7            pop d
0239   058B 11            mov a, b
0240   058C 43            mov [d], a
0241   058D F9            leave
0242   058E 09            ret
0243   058F             printn:
0244   058F D2            push bp
0245   0590 9B            mov bp, sp
0246   0591             
0247   0591             ; --- BEGIN INLINE ASM BLOCK
0248   0591 17 05 00      mov a, [bp + 5]
0249   0594 07 8C 08      call print_u16d
0250   0597             ; --- END INLINE ASM BLOCK
0251   0597             
0252   0597 F9            leave
0253   0598 09            ret
0254   0599             print:
0255   0599 D2            push bp
0256   059A 9B            mov bp, sp
0257   059B             
0258   059B             ; --- BEGIN INLINE ASM BLOCK
0259   059B 17 05 00      mov a, [bp + 5]
0260   059E 3C            mov d, a
0261   059F 07 63 08      call puts
0262   05A2             ; --- END INLINE ASM BLOCK
0263   05A2             
0264   05A2 F9            leave
0265   05A3 09            ret
0266   05A4             ; --- END TEXT BLOCK
0267   05A4             
0268   05A4             ; --- BEGIN DATA BLOCK
0269   05A4             s1_data: 
0270   05A4 48 65 6C 6C .db 'H', 'e', 'l', 'l', 'o', 0,
0270   05A8 6F 00 
0271   05AA 00 00 00 00 .fill 44, 0
0271   05AE 00 00 00 00 
0271   05B2 00 00 00 00 
0271   05B6 00 00 00 00 
0271   05BA 00 00 00 00 
0271   05BE 00 00 00 00 
0271   05C2 00 00 00 00 
0271   05C6 00 00 00 00 
0271   05CA 00 00 00 00 
0271   05CE 00 00 00 00 
0271   05D2 00 00 00 00 
0272   05D6 A4 05       s1: .dw s1_data
0273   05D8 2E 20 4D 79 s2_data: .db ". My name is Sol-1.", 0
0273   05DC 20 6E 61 6D 
0273   05E0 65 20 69 73 
0273   05E4 20 53 6F 6C 
0273   05E8 2D 31 2E 00 
0274   05EC D8 05       s2: .dw s2_data
0275   05EE 44 65 73 74 _string_0: .db "Destination: ", 0
0275   05F2 69 6E 61 74 
0275   05F6 69 6F 6E 3A 
0275   05FA 20 00 
0276   05FC 0A 00       _string_1: .db "\n", 0
0277   05FE 53 6F 75 72 _string_2: .db "Source: ", 0
0277   0602 63 65 3A 20 
0277   0606 00 
0278   0607 43 6F 6E 63 _string_3: .db "Concatenation: ", 0
0278   060B 61 74 65 6E 
0278   060F 61 74 69 6F 
0278   0613 6E 3A 20 00 
0279   0617             ; --- END DATA BLOCK
0280   0617             
0281   0617             ; --- BEGIN INCLUDE BLOCK
0282   0617             .include "lib/stdio.asm"
0001+  0617             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0617             ; stdio.s
0003+  0617             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0617             .include "lib/string.asm"
0001++ 0617             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0617             ; string.s
0003++ 0617             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0617             
0005++ 0617             
0006++ 0617             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0617             ; strrev
0008++ 0617             ; reverse a string
0009++ 0617             ; D = string address
0010++ 0617             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0617             ; 01234
0012++ 0617             strrev:
0013++ 0617 4B          	pusha
0014++ 0618 07 5E 06    	call strlen	; length in C
0015++ 061B 12          	mov a, c
0016++ 061C AF 01 00    	cmp a, 1
0017++ 061F D0 39 06    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0622 7D          	dec a
0019++ 0623 FD 4E       	mov si, d	; beginning of string
0020++ 0625 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0627 59          	add d, a	; end of string
0022++ 0628 12          	mov a, c
0023++ 0629 FD 9B       	shr a		; divide by 2
0024++ 062B 39          	mov c, a	; C now counts the steps
0025++ 062C             strrev_L0:
0026++ 062C 32          	mov bl, [d]	; save load right-side char into BL
0027++ 062D F6          	lodsb		; load left-side char into AL; increase SI
0028++ 062E 3E          	mov [d], al	; store left char into right side
0029++ 062F 1B          	mov al, bl
0030++ 0630 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0631 7E          	dec c
0032++ 0632 7F          	dec d
0033++ 0633 C2 00 00    	cmp c, 0
0034++ 0636 C7 2C 06    	jne strrev_L0
0035++ 0639             strrev_end:
0036++ 0639 4C          	popa
0037++ 063A 09          	ret
0038++ 063B             	
0039++ 063B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 063B             ; strchr
0041++ 063B             ; search string in D for char in AL
0042++ 063B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 063B             strchr:
0044++ 063B             strchr_L0:
0045++ 063B 32          	mov bl, [d]
0046++ 063C C1 00       	cmp bl, 0
0047++ 063E C6 49 06    	je strchr_end
0048++ 0641 BA          	cmp al, bl
0049++ 0642 C6 49 06    	je strchr_end
0050++ 0645 79          	inc d
0051++ 0646 0A 3B 06    	jmp strchr_L0
0052++ 0649             strchr_end:
0053++ 0649 1B          	mov al, bl
0054++ 064A 09          	ret
0055++ 064B             
0056++ 064B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 064B             ; strstr
0058++ 064B             ; find sub-string
0059++ 064B             ; str1 in SI
0060++ 064B             ; str2 in DI
0061++ 064B             ; SI points to end of source string
0062++ 064B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 064B             strstr:
0064++ 064B DB          	push al
0065++ 064C DA          	push d
0066++ 064D E3          	push di
0067++ 064E             strstr_loop:
0068++ 064E F3          	cmpsb					; compare a byte of the strings
0069++ 064F C7 5A 06    	jne strstr_ret
0070++ 0652 FC 00 00    	lea d, [di + 0]
0071++ 0655 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0657 C7 4E 06    	jne strstr_loop				; equal chars but not at end
0073++ 065A             strstr_ret:
0074++ 065A F0          	pop di
0075++ 065B E7          	pop d
0076++ 065C E8          	pop al
0077++ 065D 09          	ret
0078++ 065E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 065E             ; length of null terminated string
0080++ 065E             ; result in C
0081++ 065E             ; pointer in D
0082++ 065E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 065E             strlen:
0084++ 065E DA          	push d
0085++ 065F 38 00 00    	mov c, 0
0086++ 0662             strlen_L1:
0087++ 0662 BD 00       	cmp byte [d], 0
0088++ 0664 C6 6C 06    	je strlen_ret
0089++ 0667 79          	inc d
0090++ 0668 78          	inc c
0091++ 0669 0A 62 06    	jmp strlen_L1
0092++ 066C             strlen_ret:
0093++ 066C E7          	pop d
0094++ 066D 09          	ret
0095++ 066E             
0096++ 066E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 066E             ; STRCMP
0098++ 066E             ; compare two strings
0099++ 066E             ; str1 in SI
0100++ 066E             ; str2 in DI
0101++ 066E             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 066E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 066E             strcmp:
0104++ 066E DB          	push al
0105++ 066F DA          	push d
0106++ 0670 E3          	push di
0107++ 0671 E2          	push si
0108++ 0672             strcmp_loop:
0109++ 0672 F3          	cmpsb					; compare a byte of the strings
0110++ 0673 C7 7E 06    	jne strcmp_ret
0111++ 0676 FB FF FF    	lea d, [si +- 1]
0112++ 0679 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 067B C7 72 06    	jne strcmp_loop				; equal chars but not at end
0114++ 067E             strcmp_ret:
0115++ 067E EF          	pop si
0116++ 067F F0          	pop di
0117++ 0680 E7          	pop d
0118++ 0681 E8          	pop al
0119++ 0682 09          	ret
0120++ 0683             
0121++ 0683             
0122++ 0683             ; STRCPY
0123++ 0683             ; copy null terminated string from SI to DI
0124++ 0683             ; source in SI
0125++ 0683             ; destination in DI
0126++ 0683             strcpy:
0127++ 0683 E2          	push si
0128++ 0684 E3          	push di
0129++ 0685 DB          	push al
0130++ 0686             strcpy_L1:
0131++ 0686 F6          	lodsb
0132++ 0687 F7          	stosb
0133++ 0688 B9 00       	cmp al, 0
0134++ 068A C7 86 06    	jne strcpy_L1
0135++ 068D             strcpy_end:
0136++ 068D E8          	pop al
0137++ 068E F0          	pop di
0138++ 068F EF          	pop si
0139++ 0690 09          	ret
0140++ 0691             
0141++ 0691             ; STRCAT
0142++ 0691             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0691             ; source in SI
0144++ 0691             ; destination in DI
0145++ 0691             strcat:
0146++ 0691 E2          	push si
0147++ 0692 E3          	push di
0148++ 0693 D7          	push a
0149++ 0694 DA          	push d
0150++ 0695 50          	mov a, di
0151++ 0696 3C          	mov d, a
0152++ 0697             strcat_goto_end_L1:
0153++ 0697 BD 00       	cmp byte[d], 0
0154++ 0699 C6 A0 06    	je strcat_start
0155++ 069C 79          	inc d
0156++ 069D 0A 97 06    	jmp strcat_goto_end_L1
0157++ 06A0             strcat_start:
0158++ 06A0 FD 50       	mov di, d
0159++ 06A2             strcat_L1:
0160++ 06A2 F6          	lodsb
0161++ 06A3 F7          	stosb
0162++ 06A4 B9 00       	cmp al, 0
0163++ 06A6 C7 A2 06    	jne strcat_L1
0164++ 06A9             strcat_end:
0165++ 06A9 E7          	pop d
0166++ 06AA E4          	pop a
0167++ 06AB F0          	pop di
0168++ 06AC EF          	pop si
0169++ 06AD 09          	ret
0005+  06AE             
0006+  06AE 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  06B2 34 35 36 37 
0006+  06B6 38 39 41 42 
0006+  06BA 43 44 45 46 
0007+  06BE 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  06C2 1B 5B 48 00 
0008+  06C6             
0009+  06C6 01 00       table_power:.dw 1
0010+  06C8 0A 00       			.dw 10
0011+  06CA 64 00       			.dw 100
0012+  06CC E8 03       			.dw 1000
0013+  06CE 10 27       			.dw 10000
0014+  06D0             
0015+  06D0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  06D0             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  06D0             ; ASCII in BL
0018+  06D0             ; result in AL
0019+  06D0             ; ascii for F = 0100 0110
0020+  06D0             ; ascii for 9 = 0011 1001
0021+  06D0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  06D0             hex_ascii_encode:
0023+  06D0 1B          	mov al, bl
0024+  06D1 93 40       	test al, $40				; test if letter or number
0025+  06D3 C7 D9 06    	jnz hex_letter
0026+  06D6 87 0F       	and al, $0F				; get number
0027+  06D8 09          	ret
0028+  06D9             hex_letter:
0029+  06D9 87 0F       	and al, $0F				; get letter
0030+  06DB 6A 09       	add al, 9
0031+  06DD 09          	ret
0032+  06DE             
0033+  06DE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  06DE             ; ATOI
0035+  06DE             ; 2 letter hex string in B
0036+  06DE             ; 8bit integer returned in AL
0037+  06DE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  06DE             atoi:
0039+  06DE D8          	push b
0040+  06DF 07 D0 06    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  06E2 30          	mov bl, bh
0042+  06E3 DB          	push al					; save a
0043+  06E4 07 D0 06    	call hex_ascii_encode
0044+  06E7 EA          	pop bl	
0045+  06E8 FD 9E 04    	shl al, 4
0046+  06EB 8C          	or al, bl
0047+  06EC E5          	pop b
0048+  06ED 09          	ret	
0049+  06EE             
0050+  06EE             
0051+  06EE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  06EE             ; printf
0053+  06EE             ; no need for explanations!
0054+  06EE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  06EE             printf:
0056+  06EE 09          	ret
0057+  06EF             
0058+  06EF             
0059+  06EF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  06EF             ; scanf
0061+  06EF             ; no need for explanations!
0062+  06EF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  06EF             scanf:
0064+  06EF 09          	ret
0065+  06F0             
0066+  06F0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  06F0             ; ITOA
0068+  06F0             ; 8bit value in BL
0069+  06F0             ; 2 byte ASCII result in A
0070+  06F0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  06F0             itoa:
0072+  06F0 DA          	push d
0073+  06F1 D8          	push b
0074+  06F2 A7 00       	mov bh, 0
0075+  06F4 FD A4 04    	shr bl, 4	
0076+  06F7 74          	mov d, b
0077+  06F8 1F AE 06    	mov al, [d + s_hex_digits]
0078+  06FB 23          	mov ah, al
0079+  06FC             	
0080+  06FC E5          	pop b
0081+  06FD D8          	push b
0082+  06FE A7 00       	mov bh, 0
0083+  0700 FD 87 0F    	and bl, $0F
0084+  0703 74          	mov d, b
0085+  0704 1F AE 06    	mov al, [d + s_hex_digits]
0086+  0707 E5          	pop b
0087+  0708 E7          	pop d
0088+  0709 09          	ret
0089+  070A             
0090+  070A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  070A             ; HEX STRING TO BINARY
0092+  070A             ; di = destination address
0093+  070A             ; si = source
0094+  070A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  070A             hex_to_int:
0096+  070A             hex_to_int_L1:
0097+  070A F6          	lodsb					; load from [SI] to AL
0098+  070B B9 00       	cmp al, 0				; check if ASCII 0
0099+  070D C6 1A 07    	jz hex_to_int_ret
0100+  0710 36          	mov bh, al
0101+  0711 F6          	lodsb
0102+  0712 2F          	mov bl, al
0103+  0713 07 DE 06    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  0716 F7          	stosb					; store AL to [DI]
0105+  0717 0A 0A 07    	jmp hex_to_int_L1
0106+  071A             hex_to_int_ret:
0107+  071A 09          	ret		
0108+  071B             
0109+  071B             
0110+  071B             
0111+  071B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  071B             ; GETCHAR
0113+  071B             ; char in ah
0114+  071B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  071B             getchar:
0116+  071B DB          	push al
0117+  071C             getchar_retry:
0118+  071C FD 0C       	sti
0119+  071E 19 01       	mov al, 1
0120+  0720 05 03       	syscall sys_io			; receive in AH
0121+  0722 B9 00       	cmp al, 0			; check if any char was receive
0122+  0724 C6 1C 07    	je getchar_retry
0123+  0727 E8          	pop al
0124+  0728 09          	ret
0125+  0729             
0126+  0729             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  0729             ; PUTCHAR
0128+  0729             ; char in ah
0129+  0729             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0729             putchar:
0131+  0729 D7          	push a
0132+  072A 19 00       	mov al, 0
0133+  072C 05 03       	syscall sys_io			; char in AH
0134+  072E E4          	pop a
0135+  072F 09          	ret
0136+  0730             
0137+  0730             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  0730             ;; INPUT A STRING
0139+  0730             ;; terminates with null
0140+  0730             ;; pointer in D
0141+  0730             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  0730             gets:
0143+  0730 D7          	push a
0144+  0731 DA          	push d
0145+  0732             gets_loop:
0146+  0732 FD 0C       	sti
0147+  0734 19 01       	mov al, 1
0148+  0736 05 03       	syscall sys_io			; receive in AH
0149+  0738 B9 00       	cmp al, 0				; check error code (AL)
0150+  073A C6 32 07    	je gets_loop			; if no char received, retry
0151+  073D             
0152+  073D 76 1B       	cmp ah, 27
0153+  073F C6 60 07    	je gets_telnet_escape
0154+  0742 76 0A       	cmp ah, $0A				; LF
0155+  0744 C6 B9 07    	je gets_end
0156+  0747 76 0D       	cmp ah, $0D				; CR
0157+  0749 C6 B9 07    	je gets_end
0158+  074C 76 5C       	cmp ah, $5C				; '\\'
0159+  074E C6 90 07    	je gets_escape
0160+  0751             	
0161+  0751 76 08       	cmp ah, $08			; check for backspace
0162+  0753 C6 5C 07    	je gets_backspace
0163+  0756             
0164+  0756 1A          	mov al, ah
0165+  0757 3E          	mov [d], al
0166+  0758 79          	inc d
0167+  0759 0A 32 07    	jmp gets_loop
0168+  075C             gets_backspace:
0169+  075C 7F          	dec d
0170+  075D 0A 32 07    	jmp gets_loop
0171+  0760             gets_telnet_escape:
0172+  0760 FD 0C       	sti
0173+  0762 19 01       	mov al, 1
0174+  0764 05 03       	syscall sys_io				; receive in AH without echo
0175+  0766 B9 00       	cmp al, 0					; check error code (AL)
0176+  0768 C6 60 07    	je gets_telnet_escape		; if no char received, retry
0177+  076B 76 5B       	cmp ah, '['
0178+  076D C7 32 07    	jne gets_loop
0179+  0770             gets_telnet_escape_phase2:
0180+  0770 FD 0C       	sti
0181+  0772 19 01       	mov al, 1
0182+  0774 05 03       	syscall sys_io					; receive in AH without echo
0183+  0776 B9 00       	cmp al, 0						; check error code (AL)
0184+  0778 C6 70 07    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  077B 76 44       	cmp ah, 'D'
0186+  077D C6 88 07    	je gets_left_arrow
0187+  0780 76 43       	cmp ah, 'C'
0188+  0782 C6 8C 07    	je gets_right_arrow
0189+  0785 0A 32 07    	jmp gets_loop
0190+  0788             gets_left_arrow:
0191+  0788 7F          	dec d
0192+  0789 0A 32 07    	jmp gets_loop
0193+  078C             gets_right_arrow:
0194+  078C 79          	inc d
0195+  078D 0A 32 07    	jmp gets_loop
0196+  0790             gets_escape:
0197+  0790 FD 0C       	sti
0198+  0792 19 01       	mov al, 1
0199+  0794 05 03       	syscall sys_io			; receive in AH
0200+  0796 B9 00       	cmp al, 0				; check error code (AL)
0201+  0798 C6 90 07    	je gets_escape			; if no char received, retry
0202+  079B 76 6E       	cmp ah, 'n'
0203+  079D C6 AB 07    	je gets_LF
0204+  07A0 76 72       	cmp ah, 'r'
0205+  07A2 C6 B2 07    	je gets_CR
0206+  07A5 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  07A6 3E          	mov [d], al
0208+  07A7 79          	inc d
0209+  07A8 0A 32 07    	jmp gets_loop
0210+  07AB             gets_LF:
0211+  07AB 19 0A       	mov al, $0A
0212+  07AD 3E          	mov [d], al
0213+  07AE 79          	inc d
0214+  07AF 0A 32 07    	jmp gets_loop
0215+  07B2             gets_CR:
0216+  07B2 19 0D       	mov al, $0D
0217+  07B4 3E          	mov [d], al
0218+  07B5 79          	inc d
0219+  07B6 0A 32 07    	jmp gets_loop
0220+  07B9             gets_end:
0221+  07B9 19 00       	mov al, 0
0222+  07BB 3E          	mov [d], al				; terminate string
0223+  07BC E7          	pop d
0224+  07BD E4          	pop a
0225+  07BE 09          	ret
0226+  07BF             
0227+  07BF             
0228+  07BF             
0229+  07BF             
0230+  07BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  07BF             ;; INPUT TEXT
0232+  07BF             ;; terminated with CTRL+D
0233+  07BF             ;; pointer in D
0234+  07BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  07BF             gettxt:
0236+  07BF D7          	push a
0237+  07C0 DA          	push d
0238+  07C1             gettxt_loop:
0239+  07C1 19 01       	mov al, 1
0240+  07C3 05 03       	syscall sys_io			; receive in AH
0241+  07C5 B9 00       	cmp al, 0				; check error code (AL)
0242+  07C7 C6 C1 07    	je gettxt_loop		; if no char received, retry
0243+  07CA 76 04       	cmp ah, 4			; EOT
0244+  07CC C6 0A 08    	je gettxt_end
0245+  07CF 76 08       	cmp ah, $08			; check for backspace
0246+  07D1 C6 06 08    	je gettxt_backspace
0247+  07D4 76 5C       	cmp ah, $5C				; '\\'
0248+  07D6 C6 DF 07    	je gettxt_escape
0249+  07D9 1A          	mov al, ah
0250+  07DA 3E          	mov [d], al
0251+  07DB 79          	inc d
0252+  07DC 0A C1 07    	jmp gettxt_loop
0253+  07DF             gettxt_escape:
0254+  07DF 19 01       	mov al, 1
0255+  07E1 05 03       	syscall sys_io			; receive in AH
0256+  07E3 B9 00       	cmp al, 0				; check error code (AL)
0257+  07E5 C6 DF 07    	je gettxt_escape		; if no char received, retry
0258+  07E8 76 6E       	cmp ah, 'n'
0259+  07EA C6 F8 07    	je gettxt_LF
0260+  07ED 76 72       	cmp ah, 'r'
0261+  07EF C6 FF 07    	je gettxt_CR
0262+  07F2 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  07F3 3E          	mov [d], al
0264+  07F4 79          	inc d
0265+  07F5 0A C1 07    	jmp gettxt_loop
0266+  07F8             gettxt_LF:
0267+  07F8 19 0A       	mov al, $0A
0268+  07FA 3E          	mov [d], al
0269+  07FB 79          	inc d
0270+  07FC 0A C1 07    	jmp gettxt_loop
0271+  07FF             gettxt_CR:
0272+  07FF 19 0D       	mov al, $0D
0273+  0801 3E          	mov [d], al
0274+  0802 79          	inc d
0275+  0803 0A C1 07    	jmp gettxt_loop
0276+  0806             gettxt_backspace:
0277+  0806 7F          	dec d
0278+  0807 0A C1 07    	jmp gettxt_loop
0279+  080A             gettxt_end:
0280+  080A 19 00       	mov al, 0
0281+  080C 3E          	mov [d], al				; terminate string
0282+  080D E7          	pop d
0283+  080E E4          	pop a
0284+  080F 09          	ret
0285+  0810             
0286+  0810             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  0810             ; PRINT NEW LINE
0288+  0810             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  0810             printnl:
0290+  0810 D7          	push a
0291+  0811 10 00 0A    	mov a, $0A00
0292+  0814 05 03       	syscall sys_io
0293+  0816 10 00 0D    	mov a, $0D00
0294+  0819 05 03       	syscall sys_io
0295+  081B E4          	pop a
0296+  081C 09          	ret
0297+  081D             
0298+  081D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  081D             ; strtoint
0300+  081D             ; 4 digit hex string number in d
0301+  081D             ; integer returned in A
0302+  081D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  081D             strtointx:
0304+  081D D8          	push b
0305+  081E 32          	mov bl, [d]
0306+  081F 37          	mov bh, bl
0307+  0820 33 01 00    	mov bl, [d + 1]
0308+  0823 07 DE 06    	call atoi				; convert to int in AL
0309+  0826 23          	mov ah, al				; move to AH
0310+  0827 33 02 00    	mov bl, [d + 2]
0311+  082A 37          	mov bh, bl
0312+  082B 33 03 00    	mov bl, [d + 3]
0313+  082E 07 DE 06    	call atoi				; convert to int in AL
0314+  0831 E5          	pop b
0315+  0832 09          	ret
0316+  0833             
0317+  0833             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  0833             ; strtoint
0319+  0833             ; 5 digit base10 string number in d
0320+  0833             ; integer returned in A
0321+  0833             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  0833             strtoint:
0323+  0833 E2          	push si
0324+  0834 D8          	push b
0325+  0835 D9          	push c
0326+  0836 DA          	push d
0327+  0837 07 5E 06    	call strlen			; get string length in C
0328+  083A 7E          	dec c
0329+  083B FD 4E       	mov si, d
0330+  083D 12          	mov a, c
0331+  083E FD 99       	shl a
0332+  0840 3B C6 06    	mov d, table_power
0333+  0843 59          	add d, a
0334+  0844 38 00 00    	mov c, 0
0335+  0847             strtoint_L0:
0336+  0847 F6          	lodsb			; load ASCII to al
0337+  0848 B9 00       	cmp al, 0
0338+  084A C6 5D 08    	je strtoint_end
0339+  084D 6F 30       	sub al, $30		; make into integer
0340+  084F 22 00       	mov ah, 0
0341+  0851 2A          	mov b, [d]
0342+  0852 AC          	mul a, b			; result in B since it fits in 16bits
0343+  0853 11          	mov a, b
0344+  0854 28          	mov b, c
0345+  0855 54          	add a, b
0346+  0856 39          	mov c, a
0347+  0857 63 02 00    	sub d, 2
0348+  085A 0A 47 08    	jmp strtoint_L0
0349+  085D             strtoint_end:
0350+  085D 12          	mov a, c
0351+  085E E7          	pop d
0352+  085F E6          	pop c
0353+  0860 E5          	pop b
0354+  0861 EF          	pop si
0355+  0862 09          	ret
0356+  0863             
0357+  0863             
0358+  0863             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  0863             ; PRINT NULL TERMINATED STRING
0360+  0863             ; pointer in D
0361+  0863             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  0863             puts:
0363+  0863 D7          	push a
0364+  0864 DA          	push d
0365+  0865             puts_L1:
0366+  0865 1E          	mov al, [d]
0367+  0866 B9 00       	cmp al, 0
0368+  0868 C6 74 08    	jz puts_END
0369+  086B 23          	mov ah, al
0370+  086C 19 00       	mov al, 0
0371+  086E 05 03       	syscall sys_io
0372+  0870 79          	inc d
0373+  0871 0A 65 08    	jmp puts_L1
0374+  0874             puts_END:
0375+  0874 E7          	pop d
0376+  0875 E4          	pop a
0377+  0876 09          	ret
0378+  0877             
0379+  0877             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  0877             ; PRINT N SIZE STRING
0381+  0877             ; pointer in D
0382+  0877             ; size in C
0383+  0877             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  0877             putsn:
0385+  0877 DB          	push al
0386+  0878 DA          	push d
0387+  0879 D9          	push c
0388+  087A             putsn_L0:
0389+  087A 1E          	mov al, [d]
0390+  087B 23          	mov ah, al
0391+  087C 19 00       	mov al, 0
0392+  087E 05 03       	syscall sys_io
0393+  0880 79          	inc d
0394+  0881 7E          	dec c	
0395+  0882 C2 00 00    	cmp c, 0
0396+  0885 C7 7A 08    	jne putsn_L0
0397+  0888             putsn_end:
0398+  0888 E6          	pop c
0399+  0889 E7          	pop d
0400+  088A E8          	pop al
0401+  088B 09          	ret
0402+  088C             
0403+  088C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  088C             ; print 16bit decimal number
0405+  088C             ; input number in A
0406+  088C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  088C             print_u16d:
0408+  088C D7          	push a
0409+  088D D8          	push b
0410+  088E 26 10 27    	mov b, 10000
0411+  0891 AE          	div a, b			; get 10000 coeff.
0412+  0892 07 B8 08    	call print_number
0413+  0895 11          	mov a, b
0414+  0896 26 E8 03    	mov b, 1000
0415+  0899 AE          	div a, b			; get 10000 coeff.
0416+  089A 07 B8 08    	call print_number
0417+  089D 11          	mov a, b
0418+  089E 26 64 00    	mov b, 100
0419+  08A1 AE          	div a, b
0420+  08A2 07 B8 08    	call print_number
0421+  08A5 11          	mov a, b
0422+  08A6 26 0A 00    	mov b, 10
0423+  08A9 AE          	div a, b
0424+  08AA 07 B8 08    	call print_number
0425+  08AD 11          	mov a, b
0426+  08AE 6A 30       	add al, $30
0427+  08B0 23          	mov ah, al
0428+  08B1 19 00       	mov al, 0
0429+  08B3 05 03       	syscall sys_io	; print coeff
0430+  08B5 E5          	pop b
0431+  08B6 E4          	pop a
0432+  08B7 09          	ret
0433+  08B8             
0434+  08B8             
0435+  08B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  08B8             ; if A == 0, print space
0437+  08B8             ; else print A
0438+  08B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0439+  08B8             print_number:
0440+  08B8 6A 30       	add al, $30
0441+  08BA 23          	mov ah, al
0442+  08BB 07 29 07    	call putchar
0443+  08BE 09          	ret
0444+  08BF             
0445+  08BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0446+  08BF             ; PRINT 16BIT HEX INTEGER
0447+  08BF             ; integer value in reg B
0448+  08BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  08BF             print_u16x:
0450+  08BF D7          	push a
0451+  08C0 D8          	push b
0452+  08C1 DD          	push bl
0453+  08C2 30          	mov bl, bh
0454+  08C3 07 F0 06    	call itoa				; convert bh to char in A
0455+  08C6 2F          	mov bl, al				; save al
0456+  08C7 19 00       	mov al, 0
0457+  08C9 05 03       	syscall sys_io				; display AH
0458+  08CB 24          	mov ah, bl				; retrieve al
0459+  08CC 19 00       	mov al, 0
0460+  08CE 05 03       	syscall sys_io				; display AL
0461+  08D0             
0462+  08D0 EA          	pop bl
0463+  08D1 07 F0 06    	call itoa				; convert bh to char in A
0464+  08D4 2F          	mov bl, al				; save al
0465+  08D5 19 00       	mov al, 0
0466+  08D7 05 03       	syscall sys_io				; display AH
0467+  08D9 24          	mov ah, bl				; retrieve al
0468+  08DA 19 00       	mov al, 0
0469+  08DC 05 03       	syscall sys_io				; display AL
0470+  08DE             
0471+  08DE E5          	pop b
0472+  08DF E4          	pop a
0473+  08E0 09          	ret
0474+  08E1             
0475+  08E1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  08E1             ; INPUT 16BIT HEX INTEGER
0477+  08E1             ; read 16bit integer into A
0478+  08E1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  08E1             scan_u16x:
0480+  08E1 F8 10 00    	enter 16
0481+  08E4 D8          	push b
0482+  08E5 DA          	push d
0483+  08E6             
0484+  08E6 FA F1 FF    	lea d, [bp + -15]
0485+  08E9 07 30 07    	call gets				; get number
0486+  08EC             
0487+  08EC 32          	mov bl, [d]
0488+  08ED 37          	mov bh, bl
0489+  08EE 33 01 00    	mov bl, [d + 1]
0490+  08F1 07 DE 06    	call atoi				; convert to int in AL
0491+  08F4 23          	mov ah, al				; move to AH
0492+  08F5             
0493+  08F5 33 02 00    	mov bl, [d + 2]
0494+  08F8 37          	mov bh, bl
0495+  08F9 33 03 00    	mov bl, [d + 3]
0496+  08FC 07 DE 06    	call atoi				; convert to int in AL
0497+  08FF             
0498+  08FF E7          	pop d
0499+  0900 E5          	pop b
0500+  0901 F9          	leave
0501+  0902 09          	ret
0502+  0903             
0503+  0903             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0504+  0903             ; PRINT 8bit HEX INTEGER
0505+  0903             ; integer value in reg bl
0506+  0903             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  0903             print_u8x:
0508+  0903 D7          	push a
0509+  0904 DD          	push bl
0510+  0905             
0511+  0905 07 F0 06    	call itoa				; convert bl to char in A
0512+  0908 2F          	mov bl, al				; save al
0513+  0909 19 00       	mov al, 0
0514+  090B 05 03       	syscall sys_io				; display AH
0515+  090D 24          	mov ah, bl				; retrieve al
0516+  090E 19 00       	mov al, 0
0517+  0910 05 03       	syscall sys_io				; display AL
0518+  0912             
0519+  0912 EA          	pop bl
0520+  0913 E4          	pop a
0521+  0914 09          	ret
0522+  0915             
0523+  0915             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0524+  0915             ; print 8bit decimal unsigned number
0525+  0915             ; input number in AL
0526+  0915             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  0915             print_u8d:
0528+  0915 D7          	push a
0529+  0916 D8          	push b
0530+  0917             
0531+  0917 22 00       	mov ah, 0
0532+  0919 26 64 00    	mov b, 100
0533+  091C AE          	div a, b
0534+  091D D8          	push b			; save remainder
0535+  091E B9 00       	cmp al, 0
0536+  0920 C6 2A 09    	je skip100
0537+  0923 6A 30       	add al, $30
0538+  0925 23          	mov ah, al
0539+  0926 19 00       	mov al, 0
0540+  0928 05 03       	syscall sys_io	; print coeff
0541+  092A             skip100:
0542+  092A E4          	pop a
0543+  092B 22 00       	mov ah, 0
0544+  092D 26 0A 00    	mov b, 10
0545+  0930 AE          	div a, b
0546+  0931 D8          	push b			; save remainder
0547+  0932 B9 00       	cmp al, 0
0548+  0934 C6 3E 09    	je skip10
0549+  0937 6A 30       	add al, $30
0550+  0939 23          	mov ah, al
0551+  093A 19 00       	mov al, 0
0552+  093C 05 03       	syscall sys_io	; print coeff
0553+  093E             skip10:
0554+  093E E4          	pop a
0555+  093F 1B          	mov al, bl
0556+  0940 6A 30       	add al, $30
0557+  0942 23          	mov ah, al
0558+  0943 19 00       	mov al, 0
0559+  0945 05 03       	syscall sys_io	; print coeff
0560+  0947 E5          	pop b
0561+  0948 E4          	pop a
0562+  0949 09          	ret
0563+  094A             
0564+  094A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0565+  094A             ; INPUT 8BIT HEX INTEGER
0566+  094A             ; read 8bit integer into AL
0567+  094A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  094A             scan_u8x:
0569+  094A F8 04 00    	enter 4
0570+  094D D8          	push b
0571+  094E DA          	push d
0572+  094F             
0573+  094F FA FD FF    	lea d, [bp + -3]
0574+  0952 07 30 07    	call gets				; get number
0575+  0955             
0576+  0955 32          	mov bl, [d]
0577+  0956 37          	mov bh, bl
0578+  0957 33 01 00    	mov bl, [d + 1]
0579+  095A 07 DE 06    	call atoi				; convert to int in AL
0580+  095D             
0581+  095D E7          	pop d
0582+  095E E5          	pop b
0583+  095F F9          	leave
0584+  0960 09          	ret
0585+  0961             
0586+  0961             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  0961             ; input decimal number
0588+  0961             ; result in A
0589+  0961             ; 655'\0'
0590+  0961             ; low--------high
0591+  0961             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0592+  0961             scan_u16d:
0593+  0961 F8 08 00    	enter 8
0594+  0964 E2          	push si
0595+  0965 D8          	push b
0596+  0966 D9          	push c
0597+  0967 DA          	push d
0598+  0968 FA F9 FF    	lea d, [bp +- 7]
0599+  096B 07 30 07    	call gets
0600+  096E 07 5E 06    	call strlen			; get string length in C
0601+  0971 7E          	dec c
0602+  0972 FD 4E       	mov si, d
0603+  0974 12          	mov a, c
0604+  0975 FD 99       	shl a
0605+  0977 3B C6 06    	mov d, table_power
0606+  097A 59          	add d, a
0607+  097B 38 00 00    	mov c, 0
0608+  097E             mul_loop:
0609+  097E F6          	lodsb			; load ASCII to al
0610+  097F B9 00       	cmp al, 0
0611+  0981 C6 94 09    	je mul_exit
0612+  0984 6F 30       	sub al, $30		; make into integer
0613+  0986 22 00       	mov ah, 0
0614+  0988 2A          	mov b, [d]
0615+  0989 AC          	mul a, b			; result in B since it fits in 16bits
0616+  098A 11          	mov a, b
0617+  098B 28          	mov b, c
0618+  098C 54          	add a, b
0619+  098D 39          	mov c, a
0620+  098E 63 02 00    	sub d, 2
0621+  0991 0A 7E 09    	jmp mul_loop
0622+  0994             mul_exit:
0623+  0994 12          	mov a, c
0624+  0995 E7          	pop d
0625+  0996 E6          	pop c
0626+  0997 E5          	pop b
0627+  0998 EF          	pop si
0628+  0999 F9          	leave
0629+  099A 09          	ret
0283   099B             ; --- END INCLUDE BLOCK
0284   099B             
0285   099B             
0286   099B             .end
tasm: Number of errors = 0
