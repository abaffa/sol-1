0001   0000             ; --- FILENAME: snake.c
0002   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0400             .org PROC_TEXT_ORG
0004   0400             
0005   0400             ; --- BEGIN TEXT BLOCK
0006   0400             
0007   0400             main:
0008   0400 D2            push bp
0009   0401 9B            mov bp, sp
0010   0402 52 02 00      sub sp, 2 ; i
0011   0405             _for1_init:
0012   0405 26 00 00      mov b, 0
0013   0408 D7            push a
0014   0409 11            mov a, b
0015   040A 45 FF FF      mov [bp + -1], a ; i
0016   040D E4            pop a
0017   040E             _for1_cond:
0018   040E 2C FF FF      mov b, [bp + -1] ; i
0019   0411 D7            push a
0020   0412 11            mov a, b
0021   0413 26 08 00      mov b, 8
0022   0416 B0            cmp a, b
0023   0417 0E            lodflgs
0024   0418 2F            mov bl, al
0025   0419 FD A2 03      shr al, 3
0026   041C FD A4 02      shr bl, 2
0027   041F FD 87 01      and bl, %00000001
0028   0422 90            xor al, bl ; < (signed)
0029   0423 22 00         mov ah, 0
0030   0425 27            mov b, a
0031   0426 E4            pop a
0032   0427 C0 00 00      cmp b, 0
0033   042A C6 75 04      je _for1_exit
0034   042D             _for1_block:
0035   042D 29 CF 0A      mov b, [__snake_x] ; snake_x
0036   0430 D7            push a
0037   0431 74            mov d, b
0038   0432 DA            push d
0039   0433 2C FF FF      mov b, [bp + -1] ; i
0040   0436 E7            pop d
0041   0437 10 02 00      mov a, 2
0042   043A AC            mul a, b
0043   043B 5A            add d, b
0044   043C E4            pop a
0045   043D DA            push d
0046   043E 26 14 00      mov b, 20
0047   0441 D7            push a
0048   0442 11            mov a, b
0049   0443 2C FF FF      mov b, [bp + -1] ; i
0050   0446 60            sub a, b
0051   0447 27            mov b, a
0052   0448 E4            pop a
0053   0449 E7            pop d
0054   044A FD 43         mov [d], b
0055   044C 29 E1 0A      mov b, [__snake_y] ; snake_y
0056   044F D7            push a
0057   0450 74            mov d, b
0058   0451 DA            push d
0059   0452 2C FF FF      mov b, [bp + -1] ; i
0060   0455 E7            pop d
0061   0456 10 02 00      mov a, 2
0062   0459 AC            mul a, b
0063   045A 5A            add d, b
0064   045B E4            pop a
0065   045C DA            push d
0066   045D 26 0A 00      mov b, 10
0067   0460 E7            pop d
0068   0461 FD 43         mov [d], b
0069   0463             _for1_update:
0070   0463 2C FF FF      mov b, [bp + -1] ; i
0071   0466 D7            push a
0072   0467 11            mov a, b
0073   0468 FD 77         inc b
0074   046A D7            push a
0075   046B 11            mov a, b
0076   046C 45 FF FF      mov [bp + -1], a ; i
0077   046F E4            pop a
0078   0470 27            mov b, a
0079   0471 E4            pop a
0080   0472 0A 0E 04      jmp _for1_cond
0081   0475             _for1_exit:
0082   0475             _while2_cond:
0083   0475 26 01 00      mov b, 1
0084   0478 C0 00 00      cmp b, 0
0085   047B C6 87 04      je _while2_exit
0086   047E             _while2_block:
0087   047E 07 8D 04      call draw_board
0088   0481 07 52 06      call update_snake
0089   0484 0A 75 04      jmp _while2_cond
0090   0487             _while2_exit:
0091   0487 26 00 00      mov b, 0
0092   048A F9            leave
0093   048B 05 0B         syscall sys_terminate_proc
0094   048D             
0095   048D             draw_board:
0096   048D D2            push bp
0097   048E 9B            mov bp, sp
0098   048F 52 02 00      sub sp, 2 ; x
0099   0492 52 02 00      sub sp, 2 ; y
0100   0495 52 02 00      sub sp, 2 ; i
0101   0498 52 01 00      sub sp, 1 ; c
0102   049B 29 BD 0A      mov b, [__s] ; s
0103   049E FD AB         swp b
0104   04A0 D8            push b
0105   04A1 07 9F 0A      call print
0106   04A4 51 02 00      add sp, 2
0107   04A7 07 8B 0A      call rand
0108   04AA FD AB         swp b
0109   04AC D8            push b
0110   04AD 07 86 09      call print_num
0111   04B0 51 02 00      add sp, 2
0112   04B3 26 E7 0A      mov b, __string_0 ; "\n"
0113   04B6 FD AB         swp b
0114   04B8 D8            push b
0115   04B9 07 9F 0A      call print
0116   04BC 51 02 00      add sp, 2
0117   04BF             _for3_init:
0118   04BF 26 00 00      mov b, 0
0119   04C2 D7            push a
0120   04C3 11            mov a, b
0121   04C4 45 FD FF      mov [bp + -3], a ; y
0122   04C7 E4            pop a
0123   04C8             _for3_cond:
0124   04C8 2C FD FF      mov b, [bp + -3] ; y
0125   04CB D7            push a
0126   04CC 11            mov a, b
0127   04CD 26 14 00      mov b, 20
0128   04D0 B0            cmp a, b
0129   04D1 0E            lodflgs
0130   04D2 2F            mov bl, al
0131   04D3 FD A2 03      shr al, 3
0132   04D6 FD A4 02      shr bl, 2
0133   04D9 FD 87 01      and bl, %00000001
0134   04DC 90            xor al, bl ; < (signed)
0135   04DD 22 00         mov ah, 0
0136   04DF 27            mov b, a
0137   04E0 E4            pop a
0138   04E1 C0 00 00      cmp b, 0
0139   04E4 C6 50 06      je _for3_exit
0140   04E7             _for3_block:
0141   04E7             _for4_init:
0142   04E7 26 00 00      mov b, 0
0143   04EA D7            push a
0144   04EB 11            mov a, b
0145   04EC 45 FF FF      mov [bp + -1], a ; x
0146   04EF E4            pop a
0147   04F0             _for4_cond:
0148   04F0 2C FF FF      mov b, [bp + -1] ; x
0149   04F3 D7            push a
0150   04F4 11            mov a, b
0151   04F5 26 28 00      mov b, 40
0152   04F8 B0            cmp a, b
0153   04F9 0E            lodflgs
0154   04FA 2F            mov bl, al
0155   04FB FD A2 03      shr al, 3
0156   04FE FD A4 02      shr bl, 2
0157   0501 FD 87 01      and bl, %00000001
0158   0504 90            xor al, bl ; < (signed)
0159   0505 22 00         mov ah, 0
0160   0507 27            mov b, a
0161   0508 E4            pop a
0162   0509 C0 00 00      cmp b, 0
0163   050C C6 34 06      je _for4_exit
0164   050F             _for4_block:
0165   050F 26 20 00      mov b, $20
0166   0512 DB            push al
0167   0513 1B            mov al, bl
0168   0514 40 FA FF      mov [bp + -6], al ; c
0169   0517 E8            pop al
0170   0518             _if5_cond:
0171   0518 2C FF FF      mov b, [bp + -1] ; x
0172   051B D7            push a
0173   051C 11            mov a, b
0174   051D 26 00 00      mov b, 0
0175   0520 B0            cmp a, b
0176   0521 0E            lodflgs
0177   0522 87 01         and al, %00000001 ; ==
0178   0524 22 00         mov ah, 0
0179   0526 27            mov b, a
0180   0527 E4            pop a
0181   0528 D7            push a
0182   0529 11            mov a, b
0183   052A 2C FF FF      mov b, [bp + -1] ; x
0184   052D D7            push a
0185   052E 11            mov a, b
0186   052F 26 27 00      mov b, 39
0187   0532 B0            cmp a, b
0188   0533 0E            lodflgs
0189   0534 87 01         and al, %00000001 ; ==
0190   0536 22 00         mov ah, 0
0191   0538 27            mov b, a
0192   0539 E4            pop a
0193   053A 8A            or a, b
0194   053B 27            mov b, a
0195   053C E4            pop a
0196   053D D7            push a
0197   053E 11            mov a, b
0198   053F 2C FD FF      mov b, [bp + -3] ; y
0199   0542 D7            push a
0200   0543 11            mov a, b
0201   0544 26 00 00      mov b, 0
0202   0547 B0            cmp a, b
0203   0548 0E            lodflgs
0204   0549 87 01         and al, %00000001 ; ==
0205   054B 22 00         mov ah, 0
0206   054D 27            mov b, a
0207   054E E4            pop a
0208   054F 8A            or a, b
0209   0550 27            mov b, a
0210   0551 E4            pop a
0211   0552 D7            push a
0212   0553 11            mov a, b
0213   0554 2C FD FF      mov b, [bp + -3] ; y
0214   0557 D7            push a
0215   0558 11            mov a, b
0216   0559 26 13 00      mov b, 19
0217   055C B0            cmp a, b
0218   055D 0E            lodflgs
0219   055E 87 01         and al, %00000001 ; ==
0220   0560 22 00         mov ah, 0
0221   0562 27            mov b, a
0222   0563 E4            pop a
0223   0564 8A            or a, b
0224   0565 27            mov b, a
0225   0566 E4            pop a
0226   0567 C0 00 00      cmp b, 0
0227   056A C6 79 05      je _if5_else
0228   056D             _if5_true:
0229   056D 26 23 00      mov b, $23
0230   0570 DB            push al
0231   0571 1B            mov al, bl
0232   0572 40 FA FF      mov [bp + -6], al ; c
0233   0575 E8            pop al
0234   0576 0A 16 06      jmp _if5_exit
0235   0579             _if5_else:
0236   0579             _for6_init:
0237   0579 26 00 00      mov b, 0
0238   057C D7            push a
0239   057D 11            mov a, b
0240   057E 45 FB FF      mov [bp + -5], a ; i
0241   0581 E4            pop a
0242   0582             _for6_cond:
0243   0582 2C FB FF      mov b, [bp + -5] ; i
0244   0585 D7            push a
0245   0586 11            mov a, b
0246   0587 26 08 00      mov b, 8
0247   058A B0            cmp a, b
0248   058B 0E            lodflgs
0249   058C 2F            mov bl, al
0250   058D FD A2 03      shr al, 3
0251   0590 FD A4 02      shr bl, 2
0252   0593 FD 87 01      and bl, %00000001
0253   0596 90            xor al, bl ; < (signed)
0254   0597 22 00         mov ah, 0
0255   0599 27            mov b, a
0256   059A E4            pop a
0257   059B C0 00 00      cmp b, 0
0258   059E C6 16 06      je _for6_exit
0259   05A1             _for6_block:
0260   05A1             _if7_cond:
0261   05A1 2C FF FF      mov b, [bp + -1] ; x
0262   05A4 D7            push a
0263   05A5 11            mov a, b
0264   05A6 29 CF 0A      mov b, [__snake_x] ; snake_x
0265   05A9 D7            push a
0266   05AA 74            mov d, b
0267   05AB DA            push d
0268   05AC 2C FB FF      mov b, [bp + -5] ; i
0269   05AF E7            pop d
0270   05B0 10 02 00      mov a, 2
0271   05B3 AC            mul a, b
0272   05B4 5A            add d, b
0273   05B5 E4            pop a
0274   05B6 2A            mov b, [d]
0275   05B7 B0            cmp a, b
0276   05B8 0E            lodflgs
0277   05B9 87 01         and al, %00000001 ; ==
0278   05BB 22 00         mov ah, 0
0279   05BD 27            mov b, a
0280   05BE E4            pop a
0281   05BF DB            push al
0282   05C0 C0 00 00      cmp b, 0
0283   05C3 0E            lodflgs ; transform condition into a single bit
0284   05C4 2C FD FF      mov b, [bp + -3] ; y
0285   05C7 D7            push a
0286   05C8 11            mov a, b
0287   05C9 29 E1 0A      mov b, [__snake_y] ; snake_y
0288   05CC D7            push a
0289   05CD 74            mov d, b
0290   05CE DA            push d
0291   05CF 2C FB FF      mov b, [bp + -5] ; i
0292   05D2 E7            pop d
0293   05D3 10 02 00      mov a, 2
0294   05D6 AC            mul a, b
0295   05D7 5A            add d, b
0296   05D8 E4            pop a
0297   05D9 2A            mov b, [d]
0298   05DA B0            cmp a, b
0299   05DB 0E            lodflgs
0300   05DC 87 01         and al, %00000001 ; ==
0301   05DE 22 00         mov ah, 0
0302   05E0 27            mov b, a
0303   05E1 E4            pop a
0304   05E2 DB            push al
0305   05E3 C0 00 00      cmp b, 0
0306   05E6 0E            lodflgs
0307   05E7 EA            pop bl ; matches previous 'push al'
0308   05E8 8C            or al, bl
0309   05E9 8F 01         xor al, %00000001
0310   05EB 2F            mov bl, al
0311   05EC A7 00         mov bh, 0
0312   05EE E8            pop al
0313   05EF C0 00 00      cmp b, 0
0314   05F2 C6 04 06      je _if7_exit
0315   05F5             _if7_true:
0316   05F5 26 6F 00      mov b, $6f
0317   05F8 DB            push al
0318   05F9 1B            mov al, bl
0319   05FA 40 FA FF      mov [bp + -6], al ; c
0320   05FD E8            pop al
0321   05FE 0A 16 06      jmp _for6_exit ; for break
0322   0601 0A 04 06      jmp _if7_exit
0323   0604             _if7_exit:
0324   0604             _for6_update:
0325   0604 2C FB FF      mov b, [bp + -5] ; i
0326   0607 D7            push a
0327   0608 11            mov a, b
0328   0609 FD 77         inc b
0329   060B D7            push a
0330   060C 11            mov a, b
0331   060D 45 FB FF      mov [bp + -5], a ; i
0332   0610 E4            pop a
0333   0611 27            mov b, a
0334   0612 E4            pop a
0335   0613 0A 82 05      jmp _for6_cond
0336   0616             _for6_exit:
0337   0616             _if5_exit:
0338   0616 34 FA FF      mov bl, [bp + -6] ; c
0339   0619 A7 00         mov bh, 0
0340   061B DD            push bl
0341   061C 07 AA 0A      call _putchar
0342   061F 51 01 00      add sp, 1
0343   0622             _for4_update:
0344   0622 2C FF FF      mov b, [bp + -1] ; x
0345   0625 D7            push a
0346   0626 11            mov a, b
0347   0627 FD 77         inc b
0348   0629 D7            push a
0349   062A 11            mov a, b
0350   062B 45 FF FF      mov [bp + -1], a ; x
0351   062E E4            pop a
0352   062F 27            mov b, a
0353   0630 E4            pop a
0354   0631 0A F0 04      jmp _for4_cond
0355   0634             _for4_exit:
0356   0634 26 0A 00      mov b, $a
0357   0637 DD            push bl
0358   0638 07 AA 0A      call _putchar
0359   063B 51 01 00      add sp, 1
0360   063E             _for3_update:
0361   063E 2C FD FF      mov b, [bp + -3] ; y
0362   0641 D7            push a
0363   0642 11            mov a, b
0364   0643 FD 77         inc b
0365   0645 D7            push a
0366   0646 11            mov a, b
0367   0647 45 FD FF      mov [bp + -3], a ; y
0368   064A E4            pop a
0369   064B 27            mov b, a
0370   064C E4            pop a
0371   064D 0A C8 04      jmp _for3_cond
0372   0650             _for3_exit:
0373   0650 F9            leave
0374   0651 09            ret
0375   0652             
0376   0652             update_snake:
0377   0652 D2            push bp
0378   0653 9B            mov bp, sp
0379   0654 52 02 00      sub sp, 2 ; i
0380   0657 52 02 00      sub sp, 2 ; snkx
0381   065A 52 02 00      sub sp, 2 ; snky
0382   065D             _for8_init:
0383   065D 26 08 00      mov b, 8
0384   0660 D7            push a
0385   0661 11            mov a, b
0386   0662 26 01 00      mov b, 1
0387   0665 60            sub a, b
0388   0666 27            mov b, a
0389   0667 E4            pop a
0390   0668 D7            push a
0391   0669 11            mov a, b
0392   066A 45 FF FF      mov [bp + -1], a ; i
0393   066D E4            pop a
0394   066E             _for8_cond:
0395   066E 2C FF FF      mov b, [bp + -1] ; i
0396   0671 D7            push a
0397   0672 11            mov a, b
0398   0673 26 00 00      mov b, 0
0399   0676 B0            cmp a, b
0400   0677 0E            lodflgs
0401   0678 2F            mov bl, al
0402   0679 FD 78         mov g, a
0403   067B FD A2 03      shr al, 3
0404   067E FD A4 02      shr bl, 2
0405   0681 FD 87 01      and bl, %00000001
0406   0684 90            xor al, bl
0407   0685 FD 27         mov b, g
0408   0687 FD 87 01      and bl, %00000001
0409   068A 8C            or al, bl
0410   068B 8F 01         xor al, %00000001 ; > (signed)
0411   068D 22 00         mov ah, 0
0412   068F 27            mov b, a
0413   0690 E4            pop a
0414   0691 C0 00 00      cmp b, 0
0415   0694 C6 03 07      je _for8_exit
0416   0697             _for8_block:
0417   0697 29 CF 0A      mov b, [__snake_x] ; snake_x
0418   069A D7            push a
0419   069B 74            mov d, b
0420   069C DA            push d
0421   069D 2C FF FF      mov b, [bp + -1] ; i
0422   06A0 E7            pop d
0423   06A1 10 02 00      mov a, 2
0424   06A4 AC            mul a, b
0425   06A5 5A            add d, b
0426   06A6 E4            pop a
0427   06A7 DA            push d
0428   06A8 29 CF 0A      mov b, [__snake_x] ; snake_x
0429   06AB D7            push a
0430   06AC 74            mov d, b
0431   06AD DA            push d
0432   06AE 2C FF FF      mov b, [bp + -1] ; i
0433   06B1 D7            push a
0434   06B2 11            mov a, b
0435   06B3 26 01 00      mov b, 1
0436   06B6 60            sub a, b
0437   06B7 27            mov b, a
0438   06B8 E4            pop a
0439   06B9 E7            pop d
0440   06BA 10 02 00      mov a, 2
0441   06BD AC            mul a, b
0442   06BE 5A            add d, b
0443   06BF E4            pop a
0444   06C0 2A            mov b, [d]
0445   06C1 E7            pop d
0446   06C2 FD 43         mov [d], b
0447   06C4 29 E1 0A      mov b, [__snake_y] ; snake_y
0448   06C7 D7            push a
0449   06C8 74            mov d, b
0450   06C9 DA            push d
0451   06CA 2C FF FF      mov b, [bp + -1] ; i
0452   06CD E7            pop d
0453   06CE 10 02 00      mov a, 2
0454   06D1 AC            mul a, b
0455   06D2 5A            add d, b
0456   06D3 E4            pop a
0457   06D4 DA            push d
0458   06D5 29 E1 0A      mov b, [__snake_y] ; snake_y
0459   06D8 D7            push a
0460   06D9 74            mov d, b
0461   06DA DA            push d
0462   06DB 2C FF FF      mov b, [bp + -1] ; i
0463   06DE D7            push a
0464   06DF 11            mov a, b
0465   06E0 26 01 00      mov b, 1
0466   06E3 60            sub a, b
0467   06E4 27            mov b, a
0468   06E5 E4            pop a
0469   06E6 E7            pop d
0470   06E7 10 02 00      mov a, 2
0471   06EA AC            mul a, b
0472   06EB 5A            add d, b
0473   06EC E4            pop a
0474   06ED 2A            mov b, [d]
0475   06EE E7            pop d
0476   06EF FD 43         mov [d], b
0477   06F1             _for8_update:
0478   06F1 2C FF FF      mov b, [bp + -1] ; i
0479   06F4 D7            push a
0480   06F5 11            mov a, b
0481   06F6 FD 7D         dec b
0482   06F8 D7            push a
0483   06F9 11            mov a, b
0484   06FA 45 FF FF      mov [bp + -1], a ; i
0485   06FD E4            pop a
0486   06FE 27            mov b, a
0487   06FF E4            pop a
0488   0700 0A 6E 06      jmp _for8_cond
0489   0703             _for8_exit:
0490   0703 29 CF 0A      mov b, [__snake_x] ; snake_x
0491   0706 D7            push a
0492   0707 74            mov d, b
0493   0708 DA            push d
0494   0709 26 00 00      mov b, 0
0495   070C E7            pop d
0496   070D 10 02 00      mov a, 2
0497   0710 AC            mul a, b
0498   0711 5A            add d, b
0499   0712 E4            pop a
0500   0713 DA            push d
0501   0714 29 CF 0A      mov b, [__snake_x] ; snake_x
0502   0717 D7            push a
0503   0718 74            mov d, b
0504   0719 DA            push d
0505   071A 26 00 00      mov b, 0
0506   071D E7            pop d
0507   071E 10 02 00      mov a, 2
0508   0721 AC            mul a, b
0509   0722 5A            add d, b
0510   0723 E4            pop a
0511   0724 2A            mov b, [d]
0512   0725 D7            push a
0513   0726 11            mov a, b
0514   0727 29 E3 0A      mov b, [__dx] ; dx
0515   072A 54            add a, b
0516   072B 27            mov b, a
0517   072C E4            pop a
0518   072D E7            pop d
0519   072E FD 43         mov [d], b
0520   0730 29 E1 0A      mov b, [__snake_y] ; snake_y
0521   0733 D7            push a
0522   0734 74            mov d, b
0523   0735 DA            push d
0524   0736 26 00 00      mov b, 0
0525   0739 E7            pop d
0526   073A 10 02 00      mov a, 2
0527   073D AC            mul a, b
0528   073E 5A            add d, b
0529   073F E4            pop a
0530   0740 DA            push d
0531   0741 29 E1 0A      mov b, [__snake_y] ; snake_y
0532   0744 D7            push a
0533   0745 74            mov d, b
0534   0746 DA            push d
0535   0747 26 00 00      mov b, 0
0536   074A E7            pop d
0537   074B 10 02 00      mov a, 2
0538   074E AC            mul a, b
0539   074F 5A            add d, b
0540   0750 E4            pop a
0541   0751 2A            mov b, [d]
0542   0752 D7            push a
0543   0753 11            mov a, b
0544   0754 29 E5 0A      mov b, [__dy] ; dy
0545   0757 54            add a, b
0546   0758 27            mov b, a
0547   0759 E4            pop a
0548   075A E7            pop d
0549   075B FD 43         mov [d], b
0550   075D             _if9_cond:
0551   075D 07 8B 0A      call rand
0552   0760 D7            push a
0553   0761 11            mov a, b
0554   0762 26 0A 00      mov b, 10
0555   0765 AE            div a, b
0556   0766 E4            pop a
0557   0767 D7            push a
0558   0768 11            mov a, b
0559   0769 26 02 00      mov b, 2
0560   076C B0            cmp a, b
0561   076D 0E            lodflgs
0562   076E 2F            mov bl, al
0563   076F FD A2 03      shr al, 3
0564   0772 FD A4 02      shr bl, 2
0565   0775 FD 87 01      and bl, %00000001
0566   0778 90            xor al, bl ; < (signed)
0567   0779 22 00         mov ah, 0
0568   077B 27            mov b, a
0569   077C E4            pop a
0570   077D C0 00 00      cmp b, 0
0571   0780 C6 22 08      je _if9_exit
0572   0783             _if9_true:
0573   0783             _if10_cond:
0574   0783 29 E3 0A      mov b, [__dx] ; dx
0575   0786 D7            push a
0576   0787 11            mov a, b
0577   0788 26 00 00      mov b, 0
0578   078B B0            cmp a, b
0579   078C 0E            lodflgs
0580   078D 87 01         and al, %00000001
0581   078F 8F 01         xor al, %00000001 ; !=
0582   0791 22 00         mov ah, 0
0583   0793 27            mov b, a
0584   0794 E4            pop a
0585   0795 C0 00 00      cmp b, 0
0586   0798 C6 D1 07      je _if10_else
0587   079B             _if10_true:
0588   079B             _ternary11_cond:
0589   079B 07 8B 0A      call rand
0590   079E D7            push a
0591   079F 11            mov a, b
0592   07A0 26 02 00      mov b, 2
0593   07A3 AE            div a, b
0594   07A4 E4            pop a
0595   07A5 D7            push a
0596   07A6 11            mov a, b
0597   07A7 26 00 00      mov b, 0
0598   07AA B0            cmp a, b
0599   07AB 0E            lodflgs
0600   07AC 87 01         and al, %00000001 ; ==
0601   07AE 22 00         mov ah, 0
0602   07B0 27            mov b, a
0603   07B1 E4            pop a
0604   07B2 C0 00 00      cmp b, 0
0605   07B5 C6 BE 07      je _ternary11_false
0606   07B8             _ternary11_true:
0607   07B8 26 01 00      mov b, 1
0608   07BB 0A C3 07      jmp _ternary11_exit
0609   07BE             _ternary11_false:
0610   07BE 26 01 00      mov b, 1
0611   07C1 FD 97         neg b
0612   07C3             _ternary11_exit:
0613   07C3 FD 42 E5 0A   mov [__dy], b
0614   07C7 26 00 00      mov b, 0
0615   07CA FD 42 E3 0A   mov [__dx], b
0616   07CE 0A 1F 08      jmp _if10_exit
0617   07D1             _if10_else:
0618   07D1             _if12_cond:
0619   07D1 29 E5 0A      mov b, [__dy] ; dy
0620   07D4 D7            push a
0621   07D5 11            mov a, b
0622   07D6 26 00 00      mov b, 0
0623   07D9 B0            cmp a, b
0624   07DA 0E            lodflgs
0625   07DB 87 01         and al, %00000001
0626   07DD 8F 01         xor al, %00000001 ; !=
0627   07DF 22 00         mov ah, 0
0628   07E1 27            mov b, a
0629   07E2 E4            pop a
0630   07E3 C0 00 00      cmp b, 0
0631   07E6 C6 1F 08      je _if12_exit
0632   07E9             _if12_true:
0633   07E9             _ternary13_cond:
0634   07E9 07 8B 0A      call rand
0635   07EC D7            push a
0636   07ED 11            mov a, b
0637   07EE 26 02 00      mov b, 2
0638   07F1 AE            div a, b
0639   07F2 E4            pop a
0640   07F3 D7            push a
0641   07F4 11            mov a, b
0642   07F5 26 00 00      mov b, 0
0643   07F8 B0            cmp a, b
0644   07F9 0E            lodflgs
0645   07FA 87 01         and al, %00000001 ; ==
0646   07FC 22 00         mov ah, 0
0647   07FE 27            mov b, a
0648   07FF E4            pop a
0649   0800 C0 00 00      cmp b, 0
0650   0803 C6 0C 08      je _ternary13_false
0651   0806             _ternary13_true:
0652   0806 26 01 00      mov b, 1
0653   0809 0A 11 08      jmp _ternary13_exit
0654   080C             _ternary13_false:
0655   080C 26 01 00      mov b, 1
0656   080F FD 97         neg b
0657   0811             _ternary13_exit:
0658   0811 FD 42 E3 0A   mov [__dx], b
0659   0815 26 00 00      mov b, 0
0660   0818 FD 42 E5 0A   mov [__dy], b
0661   081C 0A 1F 08      jmp _if12_exit
0662   081F             _if12_exit:
0663   081F             _if10_exit:
0664   081F 0A 22 08      jmp _if9_exit
0665   0822             _if9_exit:
0666   0822 29 CF 0A      mov b, [__snake_x] ; snake_x
0667   0825 D7            push a
0668   0826 74            mov d, b
0669   0827 DA            push d
0670   0828 26 00 00      mov b, 0
0671   082B E7            pop d
0672   082C 10 02 00      mov a, 2
0673   082F AC            mul a, b
0674   0830 5A            add d, b
0675   0831 E4            pop a
0676   0832 2A            mov b, [d]
0677   0833 D7            push a
0678   0834 11            mov a, b
0679   0835 45 FD FF      mov [bp + -3], a ; snkx
0680   0838 E4            pop a
0681   0839 29 E1 0A      mov b, [__snake_y] ; snake_y
0682   083C D7            push a
0683   083D 74            mov d, b
0684   083E DA            push d
0685   083F 26 00 00      mov b, 0
0686   0842 E7            pop d
0687   0843 10 02 00      mov a, 2
0688   0846 AC            mul a, b
0689   0847 5A            add d, b
0690   0848 E4            pop a
0691   0849 2A            mov b, [d]
0692   084A D7            push a
0693   084B 11            mov a, b
0694   084C 45 FB FF      mov [bp + -5], a ; snky
0695   084F E4            pop a
0696   0850             _if14_cond:
0697   0850 2C FD FF      mov b, [bp + -3] ; snkx
0698   0853 D7            push a
0699   0854 11            mov a, b
0700   0855 26 00 00      mov b, 0
0701   0858 B0            cmp a, b
0702   0859 0E            lodflgs
0703   085A 2F            mov bl, al
0704   085B FD 78         mov g, a
0705   085D FD A2 03      shr al, 3
0706   0860 FD A4 02      shr bl, 2
0707   0863 FD 87 01      and bl, %00000001
0708   0866 90            xor al, bl
0709   0867 FD 27         mov b, g
0710   0869 FD 87 01      and bl, %00000001
0711   086C 8C            or al, bl ; <= (signed)
0712   086D 22 00         mov ah, 0
0713   086F 27            mov b, a
0714   0870 E4            pop a
0715   0871 C0 00 00      cmp b, 0
0716   0874 C6 9F 08      je _if14_else
0717   0877             _if14_true:
0718   0877 29 CF 0A      mov b, [__snake_x] ; snake_x
0719   087A D7            push a
0720   087B 74            mov d, b
0721   087C DA            push d
0722   087D 26 00 00      mov b, 0
0723   0880 E7            pop d
0724   0881 10 02 00      mov a, 2
0725   0884 AC            mul a, b
0726   0885 5A            add d, b
0727   0886 E4            pop a
0728   0887 DA            push d
0729   0888 26 01 00      mov b, 1
0730   088B E7            pop d
0731   088C FD 43         mov [d], b
0732   088E 26 01 00      mov b, 1
0733   0891 FD 42 E3 0A   mov [__dx], b
0734   0895 26 00 00      mov b, 0
0735   0898 FD 42 E5 0A   mov [__dy], b
0736   089C 0A 84 09      jmp _if14_exit
0737   089F             _if14_else:
0738   089F             _if15_cond:
0739   089F 2C FD FF      mov b, [bp + -3] ; snkx
0740   08A2 D7            push a
0741   08A3 11            mov a, b
0742   08A4 26 27 00      mov b, 39
0743   08A7 B0            cmp a, b
0744   08A8 0E            lodflgs
0745   08A9 2F            mov bl, al
0746   08AA FD A2 03      shr al, 3
0747   08AD FD A4 02      shr bl, 2
0748   08B0 FD 87 01      and bl, %00000001
0749   08B3 90            xor al, bl
0750   08B4 8F 01         xor al, %00000001 ; >= (signed)
0751   08B6 22 00         mov ah, 0
0752   08B8 27            mov b, a
0753   08B9 E4            pop a
0754   08BA C0 00 00      cmp b, 0
0755   08BD C6 EA 08      je _if15_else
0756   08C0             _if15_true:
0757   08C0 29 CF 0A      mov b, [__snake_x] ; snake_x
0758   08C3 D7            push a
0759   08C4 74            mov d, b
0760   08C5 DA            push d
0761   08C6 26 00 00      mov b, 0
0762   08C9 E7            pop d
0763   08CA 10 02 00      mov a, 2
0764   08CD AC            mul a, b
0765   08CE 5A            add d, b
0766   08CF E4            pop a
0767   08D0 DA            push d
0768   08D1 26 26 00      mov b, 38
0769   08D4 E7            pop d
0770   08D5 FD 43         mov [d], b
0771   08D7 26 01 00      mov b, 1
0772   08DA FD 97         neg b
0773   08DC FD 42 E3 0A   mov [__dx], b
0774   08E0 26 00 00      mov b, 0
0775   08E3 FD 42 E5 0A   mov [__dy], b
0776   08E7 0A 84 09      jmp _if15_exit
0777   08EA             _if15_else:
0778   08EA             _if16_cond:
0779   08EA 2C FB FF      mov b, [bp + -5] ; snky
0780   08ED D7            push a
0781   08EE 11            mov a, b
0782   08EF 26 00 00      mov b, 0
0783   08F2 B0            cmp a, b
0784   08F3 0E            lodflgs
0785   08F4 2F            mov bl, al
0786   08F5 FD 78         mov g, a
0787   08F7 FD A2 03      shr al, 3
0788   08FA FD A4 02      shr bl, 2
0789   08FD FD 87 01      and bl, %00000001
0790   0900 90            xor al, bl
0791   0901 FD 27         mov b, g
0792   0903 FD 87 01      and bl, %00000001
0793   0906 8C            or al, bl ; <= (signed)
0794   0907 22 00         mov ah, 0
0795   0909 27            mov b, a
0796   090A E4            pop a
0797   090B C0 00 00      cmp b, 0
0798   090E C6 39 09      je _if16_else
0799   0911             _if16_true:
0800   0911 29 E1 0A      mov b, [__snake_y] ; snake_y
0801   0914 D7            push a
0802   0915 74            mov d, b
0803   0916 DA            push d
0804   0917 26 00 00      mov b, 0
0805   091A E7            pop d
0806   091B 10 02 00      mov a, 2
0807   091E AC            mul a, b
0808   091F 5A            add d, b
0809   0920 E4            pop a
0810   0921 DA            push d
0811   0922 26 01 00      mov b, 1
0812   0925 E7            pop d
0813   0926 FD 43         mov [d], b
0814   0928 26 01 00      mov b, 1
0815   092B FD 42 E5 0A   mov [__dy], b
0816   092F 26 00 00      mov b, 0
0817   0932 FD 42 E3 0A   mov [__dx], b
0818   0936 0A 84 09      jmp _if16_exit
0819   0939             _if16_else:
0820   0939             _if17_cond:
0821   0939 2C FB FF      mov b, [bp + -5] ; snky
0822   093C D7            push a
0823   093D 11            mov a, b
0824   093E 26 13 00      mov b, 19
0825   0941 B0            cmp a, b
0826   0942 0E            lodflgs
0827   0943 2F            mov bl, al
0828   0944 FD A2 03      shr al, 3
0829   0947 FD A4 02      shr bl, 2
0830   094A FD 87 01      and bl, %00000001
0831   094D 90            xor al, bl
0832   094E 8F 01         xor al, %00000001 ; >= (signed)
0833   0950 22 00         mov ah, 0
0834   0952 27            mov b, a
0835   0953 E4            pop a
0836   0954 C0 00 00      cmp b, 0
0837   0957 C6 84 09      je _if17_exit
0838   095A             _if17_true:
0839   095A 29 E1 0A      mov b, [__snake_y] ; snake_y
0840   095D D7            push a
0841   095E 74            mov d, b
0842   095F DA            push d
0843   0960 26 00 00      mov b, 0
0844   0963 E7            pop d
0845   0964 10 02 00      mov a, 2
0846   0967 AC            mul a, b
0847   0968 5A            add d, b
0848   0969 E4            pop a
0849   096A DA            push d
0850   096B 26 12 00      mov b, 18
0851   096E E7            pop d
0852   096F FD 43         mov [d], b
0853   0971 26 01 00      mov b, 1
0854   0974 FD 97         neg b
0855   0976 FD 42 E5 0A   mov [__dy], b
0856   097A 26 00 00      mov b, 0
0857   097D FD 42 E3 0A   mov [__dx], b
0858   0981 0A 84 09      jmp _if17_exit
0859   0984             _if17_exit:
0860   0984             _if16_exit:
0861   0984             _if15_exit:
0862   0984             _if14_exit:
0863   0984 F9            leave
0864   0985 09            ret
0865   0986             
0866   0986             print_num:
0867   0986 D2            push bp
0868   0987 9B            mov bp, sp
0869   0988 52 05 00      sub sp, 5 ; digits
0870   098B 52 02 00      sub sp, 2 ; i
0871   098E 26 00 00      mov b, 0
0872   0991 D7            push a
0873   0992 11            mov a, b
0874   0993 45 FA FF      mov [bp + -6], a ; i
0875   0996 E4            pop a
0876   0997             _if18_cond:
0877   0997 2C 05 00      mov b, [bp + 5] ; num
0878   099A D7            push a
0879   099B 11            mov a, b
0880   099C 26 00 00      mov b, 0
0881   099F B0            cmp a, b
0882   09A0 0E            lodflgs
0883   09A1 87 01         and al, %00000001 ; ==
0884   09A3 22 00         mov ah, 0
0885   09A5 27            mov b, a
0886   09A6 E4            pop a
0887   09A7 C0 00 00      cmp b, 0
0888   09AA C6 BC 09      je _if18_exit
0889   09AD             _if18_true:
0890   09AD 26 30 00      mov b, $30
0891   09B0 DD            push bl
0892   09B1 07 AA 0A      call _putchar
0893   09B4 51 01 00      add sp, 1
0894   09B7 F9            leave
0895   09B8 09            ret
0896   09B9 0A BC 09      jmp _if18_exit
0897   09BC             _if18_exit:
0898   09BC             _while19_cond:
0899   09BC 2C 05 00      mov b, [bp + 5] ; num
0900   09BF D7            push a
0901   09C0 11            mov a, b
0902   09C1 26 00 00      mov b, 0
0903   09C4 B0            cmp a, b
0904   09C5 0E            lodflgs
0905   09C6 2F            mov bl, al
0906   09C7 FD 78         mov g, a
0907   09C9 FD A2 03      shr al, 3
0908   09CC FD A4 02      shr bl, 2
0909   09CF FD 87 01      and bl, %00000001
0910   09D2 90            xor al, bl
0911   09D3 FD 27         mov b, g
0912   09D5 FD 87 01      and bl, %00000001
0913   09D8 8C            or al, bl
0914   09D9 8F 01         xor al, %00000001 ; > (signed)
0915   09DB 22 00         mov ah, 0
0916   09DD 27            mov b, a
0917   09DE E4            pop a
0918   09DF C0 00 00      cmp b, 0
0919   09E2 C6 33 0A      je _while19_exit
0920   09E5             _while19_block:
0921   09E5 FA FC FF      lea d, [bp + -4] ; digits beginning on the stack
0922   09E8 2D            mov b, d
0923   09E9 D7            push a
0924   09EA 74            mov d, b
0925   09EB DA            push d
0926   09EC 2C FA FF      mov b, [bp + -6] ; i
0927   09EF E7            pop d
0928   09F0 10 01 00      mov a, 1
0929   09F3 AC            mul a, b
0930   09F4 5A            add d, b
0931   09F5 E4            pop a
0932   09F6 DA            push d
0933   09F7 26 30 00      mov b, $30
0934   09FA D7            push a
0935   09FB 11            mov a, b
0936   09FC 2C 05 00      mov b, [bp + 5] ; num
0937   09FF D7            push a
0938   0A00 11            mov a, b
0939   0A01 26 0A 00      mov b, 10
0940   0A04 AE            div a, b
0941   0A05 E4            pop a
0942   0A06 54            add a, b
0943   0A07 27            mov b, a
0944   0A08 E4            pop a
0945   0A09 E7            pop d
0946   0A0A FD 3E         mov [d], bl
0947   0A0C 2C 05 00      mov b, [bp + 5] ; num
0948   0A0F D7            push a
0949   0A10 11            mov a, b
0950   0A11 26 0A 00      mov b, 10
0951   0A14 AE            div a, b
0952   0A15 FD 78         mov g, a
0953   0A17 11            mov a, b
0954   0A18 FD 27         mov b, g
0955   0A1A E4            pop a
0956   0A1B D7            push a
0957   0A1C 11            mov a, b
0958   0A1D 45 05 00      mov [bp + 5], a ; num
0959   0A20 E4            pop a
0960   0A21 2C FA FF      mov b, [bp + -6] ; i
0961   0A24 D7            push a
0962   0A25 11            mov a, b
0963   0A26 FD 77         inc b
0964   0A28 D7            push a
0965   0A29 11            mov a, b
0966   0A2A 45 FA FF      mov [bp + -6], a ; i
0967   0A2D E4            pop a
0968   0A2E 27            mov b, a
0969   0A2F E4            pop a
0970   0A30 0A BC 09      jmp _while19_cond
0971   0A33             _while19_exit:
0972   0A33             _while20_cond:
0973   0A33 2C FA FF      mov b, [bp + -6] ; i
0974   0A36 D7            push a
0975   0A37 11            mov a, b
0976   0A38 26 00 00      mov b, 0
0977   0A3B B0            cmp a, b
0978   0A3C 0E            lodflgs
0979   0A3D 2F            mov bl, al
0980   0A3E FD 78         mov g, a
0981   0A40 FD A2 03      shr al, 3
0982   0A43 FD A4 02      shr bl, 2
0983   0A46 FD 87 01      and bl, %00000001
0984   0A49 90            xor al, bl
0985   0A4A FD 27         mov b, g
0986   0A4C FD 87 01      and bl, %00000001
0987   0A4F 8C            or al, bl
0988   0A50 8F 01         xor al, %00000001 ; > (signed)
0989   0A52 22 00         mov ah, 0
0990   0A54 27            mov b, a
0991   0A55 E4            pop a
0992   0A56 C0 00 00      cmp b, 0
0993   0A59 C6 89 0A      je _while20_exit
0994   0A5C             _while20_block:
0995   0A5C 2C FA FF      mov b, [bp + -6] ; i
0996   0A5F D7            push a
0997   0A60 11            mov a, b
0998   0A61 FD 7D         dec b
0999   0A63 D7            push a
1000   0A64 11            mov a, b
1001   0A65 45 FA FF      mov [bp + -6], a ; i
1002   0A68 E4            pop a
1003   0A69 27            mov b, a
1004   0A6A E4            pop a
1005   0A6B FA FC FF      lea d, [bp + -4] ; digits beginning on the stack
1006   0A6E 2D            mov b, d
1007   0A6F D7            push a
1008   0A70 74            mov d, b
1009   0A71 DA            push d
1010   0A72 2C FA FF      mov b, [bp + -6] ; i
1011   0A75 E7            pop d
1012   0A76 10 01 00      mov a, 1
1013   0A79 AC            mul a, b
1014   0A7A 5A            add d, b
1015   0A7B E4            pop a
1016   0A7C 32            mov bl, [d]
1017   0A7D A7 00         mov bh, 0
1018   0A7F DD            push bl
1019   0A80 07 AA 0A      call _putchar
1020   0A83 51 01 00      add sp, 1
1021   0A86 0A 33 0A      jmp _while20_cond
1022   0A89             _while20_exit:
1023   0A89 F9            leave
1024   0A8A 09            ret
1025   0A8B             
1026   0A8B             rand:
1027   0A8B D2            push bp
1028   0A8C 9B            mov bp, sp
1029   0A8D 52 01 00      sub sp, 1 ; sec
1030   0A90             
1031   0A90             ; --- BEGIN INLINE ASM BLOCK
1032   0A90 19 00         mov al, 0
1033   0A92 05 01         syscall sys_rtc					; get seconds
1034   0A94 1A            mov al, ah
1035   0A95 40 00 00      mov [bp + 0], al
1036   0A98             ; --- END INLINE ASM BLOCK
1037   0A98             
1038   0A98 34 00 00      mov bl, [bp + 0] ; sec
1039   0A9B A7 00         mov bh, 0
1040   0A9D F9            leave
1041   0A9E 09            ret
1042   0A9F             
1043   0A9F             print:
1044   0A9F D2            push bp
1045   0AA0 9B            mov bp, sp
1046   0AA1             
1047   0AA1             ; --- BEGIN INLINE ASM BLOCK
1048   0AA1 17 05 00      mov a, [bp + 5]
1049   0AA4 3C            mov d, a
1050   0AA5 07 35 0D      call puts
1051   0AA8             ; --- END INLINE ASM BLOCK
1052   0AA8             
1053   0AA8 F9            leave
1054   0AA9 09            ret
1055   0AAA             
1056   0AAA             _putchar:
1057   0AAA D2            push bp
1058   0AAB 9B            mov bp, sp
1059   0AAC             
1060   0AAC             ; --- BEGIN INLINE ASM BLOCK
1061   0AAC 20 05 00      mov al, [bp + 5]
1062   0AAF 23            mov ah, al
1063   0AB0 07 FB 0B      call putchar
1064   0AB3             ; --- END INLINE ASM BLOCK
1065   0AB3             
1066   0AB3 F9            leave
1067   0AB4 09            ret
1068   0AB5             ; --- END TEXT BLOCK
1069   0AB5             
1070   0AB5             ; --- BEGIN DATA BLOCK
1071   0AB5             __s_data: 
1072   0AB5 1B 5B 32 4A .db 27,$5b,$32,$4a,27,$5b,$48,0,
1072   0AB9 1B 5B 48 00 
1073   0ABD             .fill 0, 0
1074   0ABD B5 0A       __s: .dw __s_data
1075   0ABF 00 00 00 00 __snake_x_data: .fill 16, 0
1075   0AC3 00 00 00 00 
1075   0AC7 00 00 00 00 
1075   0ACB 00 00 00 00 
1076   0ACF BF 0A       __snake_x: .dw __snake_x_data
1077   0AD1 00 00 00 00 __snake_y_data: .fill 16, 0
1077   0AD5 00 00 00 00 
1077   0AD9 00 00 00 00 
1077   0ADD 00 00 00 00 
1078   0AE1 D1 0A       __snake_y: .dw __snake_y_data
1079   0AE3 01 00       __dx: .dw 1
1080   0AE5 00 00       __dy: .dw 0
1081   0AE7 0A 00       __string_0: .db "\n", 0
1082   0AE9             ; --- END DATA BLOCK
1083   0AE9             
1084   0AE9             ; --- BEGIN INCLUDE BLOCK
1085   0AE9             .include "lib/stdio.asm"
0001+  0AE9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0AE9             ; stdio.s
0003+  0AE9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0AE9             .include "lib/string.asm"
0001++ 0AE9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0AE9             ; string.s
0003++ 0AE9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0AE9             
0005++ 0AE9             
0006++ 0AE9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0AE9             ; strrev
0008++ 0AE9             ; reverse a string
0009++ 0AE9             ; D = string address
0010++ 0AE9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0AE9             ; 01234
0012++ 0AE9             strrev:
0013++ 0AE9 4B          	pusha
0014++ 0AEA 07 30 0B    	call strlen	; length in C
0015++ 0AED 12          	mov a, c
0016++ 0AEE AF 01 00    	cmp a, 1
0017++ 0AF1 D0 0B 0B    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0AF4 7D          	dec a
0019++ 0AF5 FD 4E       	mov si, d	; beginning of string
0020++ 0AF7 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0AF9 59          	add d, a	; end of string
0022++ 0AFA 12          	mov a, c
0023++ 0AFB FD 9B       	shr a		; divide by 2
0024++ 0AFD 39          	mov c, a	; C now counts the steps
0025++ 0AFE             strrev_L0:
0026++ 0AFE 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0AFF F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0B00 3E          	mov [d], al	; store left char into right side
0029++ 0B01 1B          	mov al, bl
0030++ 0B02 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0B03 7E          	dec c
0032++ 0B04 7F          	dec d
0033++ 0B05 C2 00 00    	cmp c, 0
0034++ 0B08 C7 FE 0A    	jne strrev_L0
0035++ 0B0B             strrev_end:
0036++ 0B0B 4C          	popa
0037++ 0B0C 09          	ret
0038++ 0B0D             	
0039++ 0B0D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0B0D             ; strchr
0041++ 0B0D             ; search string in D for char in AL
0042++ 0B0D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0B0D             strchr:
0044++ 0B0D             strchr_L0:
0045++ 0B0D 32          	mov bl, [d]
0046++ 0B0E C1 00       	cmp bl, 0
0047++ 0B10 C6 1B 0B    	je strchr_end
0048++ 0B13 BA          	cmp al, bl
0049++ 0B14 C6 1B 0B    	je strchr_end
0050++ 0B17 79          	inc d
0051++ 0B18 0A 0D 0B    	jmp strchr_L0
0052++ 0B1B             strchr_end:
0053++ 0B1B 1B          	mov al, bl
0054++ 0B1C 09          	ret
0055++ 0B1D             
0056++ 0B1D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0B1D             ; strstr
0058++ 0B1D             ; find sub-string
0059++ 0B1D             ; str1 in SI
0060++ 0B1D             ; str2 in DI
0061++ 0B1D             ; SI points to end of source string
0062++ 0B1D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0B1D             strstr:
0064++ 0B1D DB          	push al
0065++ 0B1E DA          	push d
0066++ 0B1F E3          	push di
0067++ 0B20             strstr_loop:
0068++ 0B20 F3          	cmpsb					; compare a byte of the strings
0069++ 0B21 C7 2C 0B    	jne strstr_ret
0070++ 0B24 FC 00 00    	lea d, [di + 0]
0071++ 0B27 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0B29 C7 20 0B    	jne strstr_loop				; equal chars but not at end
0073++ 0B2C             strstr_ret:
0074++ 0B2C F0          	pop di
0075++ 0B2D E7          	pop d
0076++ 0B2E E8          	pop al
0077++ 0B2F 09          	ret
0078++ 0B30             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0B30             ; length of null terminated string
0080++ 0B30             ; result in C
0081++ 0B30             ; pointer in D
0082++ 0B30             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0B30             strlen:
0084++ 0B30 DA          	push d
0085++ 0B31 38 00 00    	mov c, 0
0086++ 0B34             strlen_L1:
0087++ 0B34 BD 00       	cmp byte [d], 0
0088++ 0B36 C6 3E 0B    	je strlen_ret
0089++ 0B39 79          	inc d
0090++ 0B3A 78          	inc c
0091++ 0B3B 0A 34 0B    	jmp strlen_L1
0092++ 0B3E             strlen_ret:
0093++ 0B3E E7          	pop d
0094++ 0B3F 09          	ret
0095++ 0B40             
0096++ 0B40             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0B40             ; STRCMP
0098++ 0B40             ; compare two strings
0099++ 0B40             ; str1 in SI
0100++ 0B40             ; str2 in DI
0101++ 0B40             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0B40             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0B40             strcmp:
0104++ 0B40 DB          	push al
0105++ 0B41 DA          	push d
0106++ 0B42 E3          	push di
0107++ 0B43 E2          	push si
0108++ 0B44             strcmp_loop:
0109++ 0B44 F3          	cmpsb					; compare a byte of the strings
0110++ 0B45 C7 50 0B    	jne strcmp_ret
0111++ 0B48 FB FF FF    	lea d, [si +- 1]
0112++ 0B4B BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0B4D C7 44 0B    	jne strcmp_loop				; equal chars but not at end
0114++ 0B50             strcmp_ret:
0115++ 0B50 EF          	pop si
0116++ 0B51 F0          	pop di
0117++ 0B52 E7          	pop d
0118++ 0B53 E8          	pop al
0119++ 0B54 09          	ret
0120++ 0B55             
0121++ 0B55             
0122++ 0B55             ; STRCPY
0123++ 0B55             ; copy null terminated string from SI to DI
0124++ 0B55             ; source in SI
0125++ 0B55             ; destination in DI
0126++ 0B55             strcpy:
0127++ 0B55 E2          	push si
0128++ 0B56 E3          	push di
0129++ 0B57 DB          	push al
0130++ 0B58             strcpy_L1:
0131++ 0B58 F6          	lodsb
0132++ 0B59 F7          	stosb
0133++ 0B5A B9 00       	cmp al, 0
0134++ 0B5C C7 58 0B    	jne strcpy_L1
0135++ 0B5F             strcpy_end:
0136++ 0B5F E8          	pop al
0137++ 0B60 F0          	pop di
0138++ 0B61 EF          	pop si
0139++ 0B62 09          	ret
0140++ 0B63             
0141++ 0B63             ; STRCAT
0142++ 0B63             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0B63             ; source in SI
0144++ 0B63             ; destination in DI
0145++ 0B63             strcat:
0146++ 0B63 E2          	push si
0147++ 0B64 E3          	push di
0148++ 0B65 D7          	push a
0149++ 0B66 DA          	push d
0150++ 0B67 50          	mov a, di
0151++ 0B68 3C          	mov d, a
0152++ 0B69             strcat_goto_end_L1:
0153++ 0B69 BD 00       	cmp byte[d], 0
0154++ 0B6B C6 72 0B    	je strcat_start
0155++ 0B6E 79          	inc d
0156++ 0B6F 0A 69 0B    	jmp strcat_goto_end_L1
0157++ 0B72             strcat_start:
0158++ 0B72 FD 50       	mov di, d
0159++ 0B74             strcat_L1:
0160++ 0B74 F6          	lodsb
0161++ 0B75 F7          	stosb
0162++ 0B76 B9 00       	cmp al, 0
0163++ 0B78 C7 74 0B    	jne strcat_L1
0164++ 0B7B             strcat_end:
0165++ 0B7B E7          	pop d
0166++ 0B7C E4          	pop a
0167++ 0B7D F0          	pop di
0168++ 0B7E EF          	pop si
0169++ 0B7F 09          	ret
0005+  0B80             
0006+  0B80 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  0B84 34 35 36 37 
0006+  0B88 38 39 41 42 
0006+  0B8C 43 44 45 46 
0007+  0B90 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  0B94 1B 5B 48 00 
0008+  0B98             
0009+  0B98 01 00       table_power:.dw 1
0010+  0B9A 0A 00       			.dw 10
0011+  0B9C 64 00       			.dw 100
0012+  0B9E E8 03       			.dw 1000
0013+  0BA0 10 27       			.dw 10000
0014+  0BA2             
0015+  0BA2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  0BA2             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  0BA2             ; ASCII in BL
0018+  0BA2             ; result in AL
0019+  0BA2             ; ascii for F = 0100 0110
0020+  0BA2             ; ascii for 9 = 0011 1001
0021+  0BA2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  0BA2             hex_ascii_encode:
0023+  0BA2 1B          	mov al, bl
0024+  0BA3 93 40       	test al, $40				; test if letter or number
0025+  0BA5 C7 AB 0B    	jnz hex_letter
0026+  0BA8 87 0F       	and al, $0F				; get number
0027+  0BAA 09          	ret
0028+  0BAB             hex_letter:
0029+  0BAB 87 0F       	and al, $0F				; get letter
0030+  0BAD 6A 09       	add al, 9
0031+  0BAF 09          	ret
0032+  0BB0             
0033+  0BB0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  0BB0             ; ATOI
0035+  0BB0             ; 2 letter hex string in B
0036+  0BB0             ; 8bit integer returned in AL
0037+  0BB0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0BB0             atoi:
0039+  0BB0 D8          	push b
0040+  0BB1 07 A2 0B    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  0BB4 30          	mov bl, bh
0042+  0BB5 DB          	push al					; save a
0043+  0BB6 07 A2 0B    	call hex_ascii_encode
0044+  0BB9 EA          	pop bl	
0045+  0BBA FD 9E 04    	shl al, 4
0046+  0BBD 8C          	or al, bl
0047+  0BBE E5          	pop b
0048+  0BBF 09          	ret	
0049+  0BC0             
0050+  0BC0             
0051+  0BC0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  0BC0             ; printf
0053+  0BC0             ; no need for explanations!
0054+  0BC0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0BC0             printf:
0056+  0BC0 09          	ret
0057+  0BC1             
0058+  0BC1             
0059+  0BC1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  0BC1             ; scanf
0061+  0BC1             ; no need for explanations!
0062+  0BC1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  0BC1             scanf:
0064+  0BC1 09          	ret
0065+  0BC2             
0066+  0BC2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  0BC2             ; ITOA
0068+  0BC2             ; 8bit value in BL
0069+  0BC2             ; 2 byte ASCII result in A
0070+  0BC2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  0BC2             itoa:
0072+  0BC2 DA          	push d
0073+  0BC3 D8          	push b
0074+  0BC4 A7 00       	mov bh, 0
0075+  0BC6 FD A4 04    	shr bl, 4	
0076+  0BC9 74          	mov d, b
0077+  0BCA 1F 80 0B    	mov al, [d + s_hex_digits]
0078+  0BCD 23          	mov ah, al
0079+  0BCE             	
0080+  0BCE E5          	pop b
0081+  0BCF D8          	push b
0082+  0BD0 A7 00       	mov bh, 0
0083+  0BD2 FD 87 0F    	and bl, $0F
0084+  0BD5 74          	mov d, b
0085+  0BD6 1F 80 0B    	mov al, [d + s_hex_digits]
0086+  0BD9 E5          	pop b
0087+  0BDA E7          	pop d
0088+  0BDB 09          	ret
0089+  0BDC             
0090+  0BDC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  0BDC             ; HEX STRING TO BINARY
0092+  0BDC             ; di = destination address
0093+  0BDC             ; si = source
0094+  0BDC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  0BDC             hex_to_int:
0096+  0BDC             hex_to_int_L1:
0097+  0BDC F6          	lodsb					; load from [SI] to AL
0098+  0BDD B9 00       	cmp al, 0				; check if ASCII 0
0099+  0BDF C6 EC 0B    	jz hex_to_int_ret
0100+  0BE2 36          	mov bh, al
0101+  0BE3 F6          	lodsb
0102+  0BE4 2F          	mov bl, al
0103+  0BE5 07 B0 0B    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  0BE8 F7          	stosb					; store AL to [DI]
0105+  0BE9 0A DC 0B    	jmp hex_to_int_L1
0106+  0BEC             hex_to_int_ret:
0107+  0BEC 09          	ret		
0108+  0BED             
0109+  0BED             
0110+  0BED             
0111+  0BED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  0BED             ; GETCHAR
0113+  0BED             ; char in ah
0114+  0BED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  0BED             getchar:
0116+  0BED DB          	push al
0117+  0BEE             getchar_retry:
0118+  0BEE FD 0C       	sti
0119+  0BF0 19 01       	mov al, 1
0120+  0BF2 05 03       	syscall sys_io			; receive in AH
0121+  0BF4 B9 00       	cmp al, 0			; check if any char was receive
0122+  0BF6 C6 EE 0B    	je getchar_retry
0123+  0BF9 E8          	pop al
0124+  0BFA 09          	ret
0125+  0BFB             
0126+  0BFB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  0BFB             ; PUTCHAR
0128+  0BFB             ; char in ah
0129+  0BFB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0BFB             putchar:
0131+  0BFB D7          	push a
0132+  0BFC 19 00       	mov al, 0
0133+  0BFE 05 03       	syscall sys_io			; char in AH
0134+  0C00 E4          	pop a
0135+  0C01 09          	ret
0136+  0C02             
0137+  0C02             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  0C02             ;; INPUT A STRING
0139+  0C02             ;; terminates with null
0140+  0C02             ;; pointer in D
0141+  0C02             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  0C02             gets:
0143+  0C02 D7          	push a
0144+  0C03 DA          	push d
0145+  0C04             gets_loop:
0146+  0C04 FD 0C       	sti
0147+  0C06 19 01       	mov al, 1
0148+  0C08 05 03       	syscall sys_io			; receive in AH
0149+  0C0A B9 00       	cmp al, 0				; check error code (AL)
0150+  0C0C C6 04 0C    	je gets_loop			; if no char received, retry
0151+  0C0F             
0152+  0C0F 76 1B       	cmp ah, 27
0153+  0C11 C6 32 0C    	je gets_telnet_escape
0154+  0C14 76 0A       	cmp ah, $0A				; LF
0155+  0C16 C6 8B 0C    	je gets_end
0156+  0C19 76 0D       	cmp ah, $0D				; CR
0157+  0C1B C6 8B 0C    	je gets_end
0158+  0C1E 76 5C       	cmp ah, $5C				; '\\'
0159+  0C20 C6 62 0C    	je gets_escape
0160+  0C23             	
0161+  0C23 76 08       	cmp ah, $08			; check for backspace
0162+  0C25 C6 2E 0C    	je gets_backspace
0163+  0C28             
0164+  0C28 1A          	mov al, ah
0165+  0C29 3E          	mov [d], al
0166+  0C2A 79          	inc d
0167+  0C2B 0A 04 0C    	jmp gets_loop
0168+  0C2E             gets_backspace:
0169+  0C2E 7F          	dec d
0170+  0C2F 0A 04 0C    	jmp gets_loop
0171+  0C32             gets_telnet_escape:
0172+  0C32 FD 0C       	sti
0173+  0C34 19 01       	mov al, 1
0174+  0C36 05 03       	syscall sys_io				; receive in AH without echo
0175+  0C38 B9 00       	cmp al, 0					; check error code (AL)
0176+  0C3A C6 32 0C    	je gets_telnet_escape		; if no char received, retry
0177+  0C3D 76 5B       	cmp ah, '['
0178+  0C3F C7 04 0C    	jne gets_loop
0179+  0C42             gets_telnet_escape_phase2:
0180+  0C42 FD 0C       	sti
0181+  0C44 19 01       	mov al, 1
0182+  0C46 05 03       	syscall sys_io					; receive in AH without echo
0183+  0C48 B9 00       	cmp al, 0						; check error code (AL)
0184+  0C4A C6 42 0C    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  0C4D 76 44       	cmp ah, 'D'
0186+  0C4F C6 5A 0C    	je gets_left_arrow
0187+  0C52 76 43       	cmp ah, 'C'
0188+  0C54 C6 5E 0C    	je gets_right_arrow
0189+  0C57 0A 04 0C    	jmp gets_loop
0190+  0C5A             gets_left_arrow:
0191+  0C5A 7F          	dec d
0192+  0C5B 0A 04 0C    	jmp gets_loop
0193+  0C5E             gets_right_arrow:
0194+  0C5E 79          	inc d
0195+  0C5F 0A 04 0C    	jmp gets_loop
0196+  0C62             gets_escape:
0197+  0C62 FD 0C       	sti
0198+  0C64 19 01       	mov al, 1
0199+  0C66 05 03       	syscall sys_io			; receive in AH
0200+  0C68 B9 00       	cmp al, 0				; check error code (AL)
0201+  0C6A C6 62 0C    	je gets_escape			; if no char received, retry
0202+  0C6D 76 6E       	cmp ah, 'n'
0203+  0C6F C6 7D 0C    	je gets_LF
0204+  0C72 76 72       	cmp ah, 'r'
0205+  0C74 C6 84 0C    	je gets_CR
0206+  0C77 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  0C78 3E          	mov [d], al
0208+  0C79 79          	inc d
0209+  0C7A 0A 04 0C    	jmp gets_loop
0210+  0C7D             gets_LF:
0211+  0C7D 19 0A       	mov al, $0A
0212+  0C7F 3E          	mov [d], al
0213+  0C80 79          	inc d
0214+  0C81 0A 04 0C    	jmp gets_loop
0215+  0C84             gets_CR:
0216+  0C84 19 0D       	mov al, $0D
0217+  0C86 3E          	mov [d], al
0218+  0C87 79          	inc d
0219+  0C88 0A 04 0C    	jmp gets_loop
0220+  0C8B             gets_end:
0221+  0C8B 19 00       	mov al, 0
0222+  0C8D 3E          	mov [d], al				; terminate string
0223+  0C8E E7          	pop d
0224+  0C8F E4          	pop a
0225+  0C90 09          	ret
0226+  0C91             
0227+  0C91             
0228+  0C91             
0229+  0C91             
0230+  0C91             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  0C91             ;; INPUT TEXT
0232+  0C91             ;; terminated with CTRL+D
0233+  0C91             ;; pointer in D
0234+  0C91             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  0C91             gettxt:
0236+  0C91 D7          	push a
0237+  0C92 DA          	push d
0238+  0C93             gettxt_loop:
0239+  0C93 19 01       	mov al, 1
0240+  0C95 05 03       	syscall sys_io			; receive in AH
0241+  0C97 B9 00       	cmp al, 0				; check error code (AL)
0242+  0C99 C6 93 0C    	je gettxt_loop		; if no char received, retry
0243+  0C9C 76 04       	cmp ah, 4			; EOT
0244+  0C9E C6 DC 0C    	je gettxt_end
0245+  0CA1 76 08       	cmp ah, $08			; check for backspace
0246+  0CA3 C6 D8 0C    	je gettxt_backspace
0247+  0CA6 76 5C       	cmp ah, $5C				; '\\'
0248+  0CA8 C6 B1 0C    	je gettxt_escape
0249+  0CAB 1A          	mov al, ah
0250+  0CAC 3E          	mov [d], al
0251+  0CAD 79          	inc d
0252+  0CAE 0A 93 0C    	jmp gettxt_loop
0253+  0CB1             gettxt_escape:
0254+  0CB1 19 01       	mov al, 1
0255+  0CB3 05 03       	syscall sys_io			; receive in AH
0256+  0CB5 B9 00       	cmp al, 0				; check error code (AL)
0257+  0CB7 C6 B1 0C    	je gettxt_escape		; if no char received, retry
0258+  0CBA 76 6E       	cmp ah, 'n'
0259+  0CBC C6 CA 0C    	je gettxt_LF
0260+  0CBF 76 72       	cmp ah, 'r'
0261+  0CC1 C6 D1 0C    	je gettxt_CR
0262+  0CC4 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  0CC5 3E          	mov [d], al
0264+  0CC6 79          	inc d
0265+  0CC7 0A 93 0C    	jmp gettxt_loop
0266+  0CCA             gettxt_LF:
0267+  0CCA 19 0A       	mov al, $0A
0268+  0CCC 3E          	mov [d], al
0269+  0CCD 79          	inc d
0270+  0CCE 0A 93 0C    	jmp gettxt_loop
0271+  0CD1             gettxt_CR:
0272+  0CD1 19 0D       	mov al, $0D
0273+  0CD3 3E          	mov [d], al
0274+  0CD4 79          	inc d
0275+  0CD5 0A 93 0C    	jmp gettxt_loop
0276+  0CD8             gettxt_backspace:
0277+  0CD8 7F          	dec d
0278+  0CD9 0A 93 0C    	jmp gettxt_loop
0279+  0CDC             gettxt_end:
0280+  0CDC 19 00       	mov al, 0
0281+  0CDE 3E          	mov [d], al				; terminate string
0282+  0CDF E7          	pop d
0283+  0CE0 E4          	pop a
0284+  0CE1 09          	ret
0285+  0CE2             
0286+  0CE2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  0CE2             ; PRINT NEW LINE
0288+  0CE2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  0CE2             printnl:
0290+  0CE2 D7          	push a
0291+  0CE3 10 00 0A    	mov a, $0A00
0292+  0CE6 05 03       	syscall sys_io
0293+  0CE8 10 00 0D    	mov a, $0D00
0294+  0CEB 05 03       	syscall sys_io
0295+  0CED E4          	pop a
0296+  0CEE 09          	ret
0297+  0CEF             
0298+  0CEF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  0CEF             ; strtoint
0300+  0CEF             ; 4 digit hex string number in d
0301+  0CEF             ; integer returned in A
0302+  0CEF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  0CEF             strtointx:
0304+  0CEF D8          	push b
0305+  0CF0 32          	mov bl, [d]
0306+  0CF1 37          	mov bh, bl
0307+  0CF2 33 01 00    	mov bl, [d + 1]
0308+  0CF5 07 B0 0B    	call atoi				; convert to int in AL
0309+  0CF8 23          	mov ah, al				; move to AH
0310+  0CF9 33 02 00    	mov bl, [d + 2]
0311+  0CFC 37          	mov bh, bl
0312+  0CFD 33 03 00    	mov bl, [d + 3]
0313+  0D00 07 B0 0B    	call atoi				; convert to int in AL
0314+  0D03 E5          	pop b
0315+  0D04 09          	ret
0316+  0D05             
0317+  0D05             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  0D05             ; strtoint
0319+  0D05             ; 5 digit base10 string number in d
0320+  0D05             ; integer returned in A
0321+  0D05             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  0D05             strtoint:
0323+  0D05 E2          	push si
0324+  0D06 D8          	push b
0325+  0D07 D9          	push c
0326+  0D08 DA          	push d
0327+  0D09 07 30 0B    	call strlen			; get string length in C
0328+  0D0C 7E          	dec c
0329+  0D0D FD 4E       	mov si, d
0330+  0D0F 12          	mov a, c
0331+  0D10 FD 99       	shl a
0332+  0D12 3B 98 0B    	mov d, table_power
0333+  0D15 59          	add d, a
0334+  0D16 38 00 00    	mov c, 0
0335+  0D19             strtoint_L0:
0336+  0D19 F6          	lodsb			; load ASCII to al
0337+  0D1A B9 00       	cmp al, 0
0338+  0D1C C6 2F 0D    	je strtoint_end
0339+  0D1F 6F 30       	sub al, $30		; make into integer
0340+  0D21 22 00       	mov ah, 0
0341+  0D23 2A          	mov b, [d]
0342+  0D24 AC          	mul a, b			; result in B since it fits in 16bits
0343+  0D25 11          	mov a, b
0344+  0D26 28          	mov b, c
0345+  0D27 54          	add a, b
0346+  0D28 39          	mov c, a
0347+  0D29 63 02 00    	sub d, 2
0348+  0D2C 0A 19 0D    	jmp strtoint_L0
0349+  0D2F             strtoint_end:
0350+  0D2F 12          	mov a, c
0351+  0D30 E7          	pop d
0352+  0D31 E6          	pop c
0353+  0D32 E5          	pop b
0354+  0D33 EF          	pop si
0355+  0D34 09          	ret
0356+  0D35             
0357+  0D35             
0358+  0D35             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  0D35             ; PRINT NULL TERMINATED STRING
0360+  0D35             ; pointer in D
0361+  0D35             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  0D35             puts:
0363+  0D35 D7          	push a
0364+  0D36 DA          	push d
0365+  0D37             puts_L1:
0366+  0D37 1E          	mov al, [d]
0367+  0D38 B9 00       	cmp al, 0
0368+  0D3A C6 46 0D    	jz puts_END
0369+  0D3D 23          	mov ah, al
0370+  0D3E 19 00       	mov al, 0
0371+  0D40 05 03       	syscall sys_io
0372+  0D42 79          	inc d
0373+  0D43 0A 37 0D    	jmp puts_L1
0374+  0D46             puts_END:
0375+  0D46 E7          	pop d
0376+  0D47 E4          	pop a
0377+  0D48 09          	ret
0378+  0D49             
0379+  0D49             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  0D49             ; PRINT N SIZE STRING
0381+  0D49             ; pointer in D
0382+  0D49             ; size in C
0383+  0D49             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  0D49             putsn:
0385+  0D49 DB          	push al
0386+  0D4A DA          	push d
0387+  0D4B D9          	push c
0388+  0D4C             putsn_L0:
0389+  0D4C 1E          	mov al, [d]
0390+  0D4D 23          	mov ah, al
0391+  0D4E 19 00       	mov al, 0
0392+  0D50 05 03       	syscall sys_io
0393+  0D52 79          	inc d
0394+  0D53 7E          	dec c	
0395+  0D54 C2 00 00    	cmp c, 0
0396+  0D57 C7 4C 0D    	jne putsn_L0
0397+  0D5A             putsn_end:
0398+  0D5A E6          	pop c
0399+  0D5B E7          	pop d
0400+  0D5C E8          	pop al
0401+  0D5D 09          	ret
0402+  0D5E             
0403+  0D5E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  0D5E             ; print 16bit decimal number
0405+  0D5E             ; input number in A
0406+  0D5E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  0D5E             print_u16d:
0408+  0D5E D7          	push a
0409+  0D5F D8          	push b
0410+  0D60 26 10 27    	mov b, 10000
0411+  0D63 AE          	div a, b			; get 10000 coeff.
0412+  0D64 07 8A 0D    	call print_number
0413+  0D67 11          	mov a, b
0414+  0D68 26 E8 03    	mov b, 1000
0415+  0D6B AE          	div a, b			; get 10000 coeff.
0416+  0D6C 07 8A 0D    	call print_number
0417+  0D6F 11          	mov a, b
0418+  0D70 26 64 00    	mov b, 100
0419+  0D73 AE          	div a, b
0420+  0D74 07 8A 0D    	call print_number
0421+  0D77 11          	mov a, b
0422+  0D78 26 0A 00    	mov b, 10
0423+  0D7B AE          	div a, b
0424+  0D7C 07 8A 0D    	call print_number
0425+  0D7F 11          	mov a, b
0426+  0D80 6A 30       	add al, $30
0427+  0D82 23          	mov ah, al
0428+  0D83 19 00       	mov al, 0
0429+  0D85 05 03       	syscall sys_io	; print coeff
0430+  0D87 E5          	pop b
0431+  0D88 E4          	pop a
0432+  0D89 09          	ret
0433+  0D8A             
0434+  0D8A             
0435+  0D8A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  0D8A             ; if A == 0, print space
0437+  0D8A             ; else print A
0438+  0D8A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0439+  0D8A             print_number:
0440+  0D8A 6A 30       	add al, $30
0441+  0D8C 23          	mov ah, al
0442+  0D8D 07 FB 0B    	call putchar
0443+  0D90 09          	ret
0444+  0D91             
0445+  0D91             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0446+  0D91             ; PRINT 16BIT HEX INTEGER
0447+  0D91             ; integer value in reg B
0448+  0D91             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  0D91             print_u16x:
0450+  0D91 D7          	push a
0451+  0D92 D8          	push b
0452+  0D93 DD          	push bl
0453+  0D94 30          	mov bl, bh
0454+  0D95 07 C2 0B    	call itoa				; convert bh to char in A
0455+  0D98 2F          	mov bl, al				; save al
0456+  0D99 19 00       	mov al, 0
0457+  0D9B 05 03       	syscall sys_io				; display AH
0458+  0D9D 24          	mov ah, bl				; retrieve al
0459+  0D9E 19 00       	mov al, 0
0460+  0DA0 05 03       	syscall sys_io				; display AL
0461+  0DA2             
0462+  0DA2 EA          	pop bl
0463+  0DA3 07 C2 0B    	call itoa				; convert bh to char in A
0464+  0DA6 2F          	mov bl, al				; save al
0465+  0DA7 19 00       	mov al, 0
0466+  0DA9 05 03       	syscall sys_io				; display AH
0467+  0DAB 24          	mov ah, bl				; retrieve al
0468+  0DAC 19 00       	mov al, 0
0469+  0DAE 05 03       	syscall sys_io				; display AL
0470+  0DB0             
0471+  0DB0 E5          	pop b
0472+  0DB1 E4          	pop a
0473+  0DB2 09          	ret
0474+  0DB3             
0475+  0DB3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  0DB3             ; INPUT 16BIT HEX INTEGER
0477+  0DB3             ; read 16bit integer into A
0478+  0DB3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  0DB3             scan_u16x:
0480+  0DB3 F8 10 00    	enter 16
0481+  0DB6 D8          	push b
0482+  0DB7 DA          	push d
0483+  0DB8             
0484+  0DB8 FA F1 FF    	lea d, [bp + -15]
0485+  0DBB 07 02 0C    	call gets				; get number
0486+  0DBE             
0487+  0DBE 32          	mov bl, [d]
0488+  0DBF 37          	mov bh, bl
0489+  0DC0 33 01 00    	mov bl, [d + 1]
0490+  0DC3 07 B0 0B    	call atoi				; convert to int in AL
0491+  0DC6 23          	mov ah, al				; move to AH
0492+  0DC7             
0493+  0DC7 33 02 00    	mov bl, [d + 2]
0494+  0DCA 37          	mov bh, bl
0495+  0DCB 33 03 00    	mov bl, [d + 3]
0496+  0DCE 07 B0 0B    	call atoi				; convert to int in AL
0497+  0DD1             
0498+  0DD1 E7          	pop d
0499+  0DD2 E5          	pop b
0500+  0DD3 F9          	leave
0501+  0DD4 09          	ret
0502+  0DD5             
0503+  0DD5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0504+  0DD5             ; PRINT 8bit HEX INTEGER
0505+  0DD5             ; integer value in reg bl
0506+  0DD5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  0DD5             print_u8x:
0508+  0DD5 D7          	push a
0509+  0DD6 DD          	push bl
0510+  0DD7             
0511+  0DD7 07 C2 0B    	call itoa				; convert bl to char in A
0512+  0DDA 2F          	mov bl, al				; save al
0513+  0DDB 19 00       	mov al, 0
0514+  0DDD 05 03       	syscall sys_io				; display AH
0515+  0DDF 24          	mov ah, bl				; retrieve al
0516+  0DE0 19 00       	mov al, 0
0517+  0DE2 05 03       	syscall sys_io				; display AL
0518+  0DE4             
0519+  0DE4 EA          	pop bl
0520+  0DE5 E4          	pop a
0521+  0DE6 09          	ret
0522+  0DE7             
0523+  0DE7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0524+  0DE7             ; print 8bit decimal unsigned number
0525+  0DE7             ; input number in AL
0526+  0DE7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  0DE7             print_u8d:
0528+  0DE7 D7          	push a
0529+  0DE8 D8          	push b
0530+  0DE9             
0531+  0DE9 22 00       	mov ah, 0
0532+  0DEB 26 64 00    	mov b, 100
0533+  0DEE AE          	div a, b
0534+  0DEF D8          	push b			; save remainder
0535+  0DF0 B9 00       	cmp al, 0
0536+  0DF2 C6 FC 0D    	je skip100
0537+  0DF5 6A 30       	add al, $30
0538+  0DF7 23          	mov ah, al
0539+  0DF8 19 00       	mov al, 0
0540+  0DFA 05 03       	syscall sys_io	; print coeff
0541+  0DFC             skip100:
0542+  0DFC E4          	pop a
0543+  0DFD 22 00       	mov ah, 0
0544+  0DFF 26 0A 00    	mov b, 10
0545+  0E02 AE          	div a, b
0546+  0E03 D8          	push b			; save remainder
0547+  0E04 B9 00       	cmp al, 0
0548+  0E06 C6 10 0E    	je skip10
0549+  0E09 6A 30       	add al, $30
0550+  0E0B 23          	mov ah, al
0551+  0E0C 19 00       	mov al, 0
0552+  0E0E 05 03       	syscall sys_io	; print coeff
0553+  0E10             skip10:
0554+  0E10 E4          	pop a
0555+  0E11 1B          	mov al, bl
0556+  0E12 6A 30       	add al, $30
0557+  0E14 23          	mov ah, al
0558+  0E15 19 00       	mov al, 0
0559+  0E17 05 03       	syscall sys_io	; print coeff
0560+  0E19 E5          	pop b
0561+  0E1A E4          	pop a
0562+  0E1B 09          	ret
0563+  0E1C             
0564+  0E1C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0565+  0E1C             ; INPUT 8BIT HEX INTEGER
0566+  0E1C             ; read 8bit integer into AL
0567+  0E1C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  0E1C             scan_u8x:
0569+  0E1C F8 04 00    	enter 4
0570+  0E1F D8          	push b
0571+  0E20 DA          	push d
0572+  0E21             
0573+  0E21 FA FD FF    	lea d, [bp + -3]
0574+  0E24 07 02 0C    	call gets				; get number
0575+  0E27             
0576+  0E27 32          	mov bl, [d]
0577+  0E28 37          	mov bh, bl
0578+  0E29 33 01 00    	mov bl, [d + 1]
0579+  0E2C 07 B0 0B    	call atoi				; convert to int in AL
0580+  0E2F             
0581+  0E2F E7          	pop d
0582+  0E30 E5          	pop b
0583+  0E31 F9          	leave
0584+  0E32 09          	ret
0585+  0E33             
0586+  0E33             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  0E33             ; input decimal number
0588+  0E33             ; result in A
0589+  0E33             ; 655'\0'
0590+  0E33             ; low--------high
0591+  0E33             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0592+  0E33             scan_u16d:
0593+  0E33 F8 08 00    	enter 8
0594+  0E36 E2          	push si
0595+  0E37 D8          	push b
0596+  0E38 D9          	push c
0597+  0E39 DA          	push d
0598+  0E3A FA F9 FF    	lea d, [bp +- 7]
0599+  0E3D 07 02 0C    	call gets
0600+  0E40 07 30 0B    	call strlen			; get string length in C
0601+  0E43 7E          	dec c
0602+  0E44 FD 4E       	mov si, d
0603+  0E46 12          	mov a, c
0604+  0E47 FD 99       	shl a
0605+  0E49 3B 98 0B    	mov d, table_power
0606+  0E4C 59          	add d, a
0607+  0E4D 38 00 00    	mov c, 0
0608+  0E50             mul_loop:
0609+  0E50 F6          	lodsb			; load ASCII to al
0610+  0E51 B9 00       	cmp al, 0
0611+  0E53 C6 66 0E    	je mul_exit
0612+  0E56 6F 30       	sub al, $30		; make into integer
0613+  0E58 22 00       	mov ah, 0
0614+  0E5A 2A          	mov b, [d]
0615+  0E5B AC          	mul a, b			; result in B since it fits in 16bits
0616+  0E5C 11          	mov a, b
0617+  0E5D 28          	mov b, c
0618+  0E5E 54          	add a, b
0619+  0E5F 39          	mov c, a
0620+  0E60 63 02 00    	sub d, 2
0621+  0E63 0A 50 0E    	jmp mul_loop
0622+  0E66             mul_exit:
0623+  0E66 12          	mov a, c
0624+  0E67 E7          	pop d
0625+  0E68 E6          	pop c
0626+  0E69 E5          	pop b
0627+  0E6A EF          	pop si
0628+  0E6B F9          	leave
0629+  0E6C 09          	ret
1086   0E6D             ; --- END INCLUDE BLOCK
1087   0E6D             
1088   0E6D             
1089   0E6D             .end
tasm: Number of errors = 0
