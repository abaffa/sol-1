0001   0000             ; --- Filename: pascal.c
0002   0000             
0003   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0004   0000             
0005   0400             .org PROC_TEXT_ORG
0006   0400             
0007   0400             ; --- begin text block
0008   0400             main:
0009   0400 D2            push bp
0010   0401 9B            mov bp, sp
0011   0402 FD DB 00      push byte 0 ; c
0012   0405 26 7D 05      mov b, s
0013   0408 FD 42 95 05   mov [pp], b
0014   040C 29 95 05      mov b, [pp]
0015   040F 74            mov d, b
0016   0410 2A            mov b, [d]
0017   0411 74            mov d, b
0018   0412 2A            mov b, [d]
0019   0413 1B            mov al, bl
0020   0414 40 00 00      mov [bp + 0], al ; c
0021   0417             ; --- begin asm block
0022   0417 14 7D 05        mov a, [s]
0023   041A 3C              mov d, a
0024   041B 07 DB 07        call puts
0025   041E 07 D9 08        call scan_u16d
0026   0421 42 88 05        mov [rows], a
0027   0424               ; --- end asm block
0028   0424             _for1_init:
0029   0424 26 00 00      mov b, 0
0030   0427 FD 42 8C 05   mov [i], b
0031   042B             _for1_cond:
0032   042B 29 8C 05      mov b, [i]
0033   042E D7            push a
0034   042F 11            mov a, b
0035   0430 29 88 05      mov b, [rows]
0036   0433 B0            cmp a, b
0037   0434 0E            lodflgs
0038   0435 87 02         and al, %00000010
0039   0437 22 00         mov ah, 0
0040   0439 27            mov b, a
0041   043A E4            pop a
0042   043B 11            mov a, b
0043   043C AF 00 00      cmp a, 0
0044   043F C6 48 05      je _for1_exit
0045   0442             _for1_block:
0046   0442             _for2_init:
0047   0442 26 01 00      mov b, 1
0048   0445 FD 42 8A 05   mov [space], b
0049   0449             _for2_cond:
0050   0449 29 8A 05      mov b, [space]
0051   044C D7            push a
0052   044D 11            mov a, b
0053   044E 29 88 05      mov b, [rows]
0054   0451 D7            push a
0055   0452 11            mov a, b
0056   0453 29 8C 05      mov b, [i]
0057   0456 60            sub a, b
0058   0457 27            mov b, a
0059   0458 E4            pop a
0060   0459 B0            cmp a, b
0061   045A 0E            lodflgs
0062   045B 87 03         and al, %00000011
0063   045D 22 00         mov ah, 0
0064   045F 27            mov b, a
0065   0460 E4            pop a
0066   0461 11            mov a, b
0067   0462 AF 00 00      cmp a, 0
0068   0465 C6 7D 04      je _for2_exit
0069   0468             _for2_block:
0070   0468 07 57 05      call print
0071   046B             _for2_update:
0072   046B 29 8A 05      mov b, [space]
0073   046E D7            push a
0074   046F 11            mov a, b
0075   0470 26 01 00      mov b, 1
0076   0473 54            add a, b
0077   0474 27            mov b, a
0078   0475 E4            pop a
0079   0476 FD 42 8A 05   mov [space], b
0080   047A 0A 49 04      jmp _for2_cond
0081   047D             _for2_exit:
0082   047D             _for3_init:
0083   047D 26 00 00      mov b, 0
0084   0480 FD 42 8E 05   mov [j], b
0085   0484             _for3_cond:
0086   0484 29 8E 05      mov b, [j]
0087   0487 D7            push a
0088   0488 11            mov a, b
0089   0489 29 8C 05      mov b, [i]
0090   048C B0            cmp a, b
0091   048D 0E            lodflgs
0092   048E 87 03         and al, %00000011
0093   0490 22 00         mov ah, 0
0094   0492 27            mov b, a
0095   0493 E4            pop a
0096   0494 11            mov a, b
0097   0495 AF 00 00      cmp a, 0
0098   0498 C6 2F 05      je _for3_exit
0099   049B             _for3_block:
0100   049B             _if4_cond:
0101   049B 29 8E 05      mov b, [j]
0102   049E D7            push a
0103   049F 11            mov a, b
0104   04A0 26 00 00      mov b, 0
0105   04A3 B0            cmp a, b
0106   04A4 0E            lodflgs
0107   04A5 87 01         and al, %00000001
0108   04A7 22 00         mov ah, 0
0109   04A9 27            mov b, a
0110   04AA E4            pop a
0111   04AB D7            push a
0112   04AC 11            mov a, b
0113   04AD 29 8C 05      mov b, [i]
0114   04B0 D7            push a
0115   04B1 11            mov a, b
0116   04B2 26 00 00      mov b, 0
0117   04B5 B0            cmp a, b
0118   04B6 0E            lodflgs
0119   04B7 87 01         and al, %00000001
0120   04B9 22 00         mov ah, 0
0121   04BB 27            mov b, a
0122   04BC E4            pop a
0123   04BD C0 00 00      cmp b, 0
0124   04C0 D7            push a
0125   04C1 0E            lodflgs
0126   04C2 27            mov b, a
0127   04C3 E4            pop a
0128   04C4 98            not bl
0129   04C5 FD 87 01      and bl, %00000001
0130   04C8 A7 00         mov bh, 0
0131   04CA AF 00 00      cmp a, 0
0132   04CD 0E            lodflgs
0133   04CE 96            not al
0134   04CF 87 01         and al, %00000001
0135   04D1 22 00         mov ah, 0
0136   04D3 8A            or a, b
0137   04D4 27            mov b, a
0138   04D5 E4            pop a
0139   04D6 C0 00 00      cmp b, 0
0140   04D9 C6 E6 04      je _if4_else_block
0141   04DC             _if4_block:
0142   04DC 26 01 00      mov b, 1
0143   04DF FD 42 86 05   mov [coef], b
0144   04E3 0A 10 05      jmp _if4_exit
0145   04E6             _if4_else_block:
0146   04E6 29 86 05      mov b, [coef]
0147   04E9 D7            push a
0148   04EA 11            mov a, b
0149   04EB 29 8C 05      mov b, [i]
0150   04EE D7            push a
0151   04EF 11            mov a, b
0152   04F0 29 8E 05      mov b, [j]
0153   04F3 60            sub a, b
0154   04F4 27            mov b, a
0155   04F5 E4            pop a
0156   04F6 D7            push a
0157   04F7 11            mov a, b
0158   04F8 26 01 00      mov b, 1
0159   04FB 54            add a, b
0160   04FC 27            mov b, a
0161   04FD E4            pop a
0162   04FE AC            mul a, b
0163   04FF E4            pop a
0164   0500 D7            push a
0165   0501 11            mov a, b
0166   0502 29 8E 05      mov b, [j]
0167   0505 AE            div a, b
0168   0506 FD 78         mov g, a
0169   0508 11            mov a, b
0170   0509 FD 27         mov b, g
0171   050B E4            pop a
0172   050C FD 42 86 05   mov [coef], b
0173   0510             _if4_exit:
0174   0510 07 57 05      call print
0175   0513 29 86 05      mov b, [coef]
0176   0516 D8            push b
0177   0517 07 4B 05      call print_nbr
0178   051A 51 02 00      add sp, 2
0179   051D             _for3_update:
0180   051D 29 8E 05      mov b, [j]
0181   0520 D7            push a
0182   0521 11            mov a, b
0183   0522 26 01 00      mov b, 1
0184   0525 54            add a, b
0185   0526 27            mov b, a
0186   0527 E4            pop a
0187   0528 FD 42 8E 05   mov [j], b
0188   052C 0A 84 04      jmp _for3_cond
0189   052F             _for3_exit:
0190   052F             ; --- begin asm block
0191   052F 14 93 05          mov a, [nl]
0192   0532 3C                mov d, a
0193   0533 07 DB 07          call puts
0194   0536                 ; --- end asm block
0195   0536             _for1_update:
0196   0536 29 8C 05      mov b, [i]
0197   0539 D7            push a
0198   053A 11            mov a, b
0199   053B 26 01 00      mov b, 1
0200   053E 54            add a, b
0201   053F 27            mov b, a
0202   0540 E4            pop a
0203   0541 FD 42 8C 05   mov [i], b
0204   0545 0A 2B 04      jmp _for1_cond
0205   0548             _for1_exit:
0206   0548 F9            leave
0207   0549 05 0B         syscall sys_terminate_proc
0208   054B             print_nbr:
0209   054B D2            push bp
0210   054C 9B            mov bp, sp
0211   054D             ; --- begin asm block
0212   054D 17 05 00      mov a, [bp + 5]
0213   0550 FD AA         swp a ; swap to make up for stack weirdness
0214   0552 07 04 08      call print_u16d
0215   0555               ; --- end asm block
0216   0555 F9            leave
0217   0556 09            ret
0218   0557             print:
0219   0557 D2            push bp
0220   0558 9B            mov bp, sp
0221   0559             ; --- begin asm block
0222   0559 14 7D 05        mov a, [s]
0223   055C 3C              mov d, a
0224   055D 07 DB 07        call puts
0225   0560               ; --- end asm block
0226   0560 F9            leave
0227   0561 09            ret
0228   0562             ; --- end text block
0229   0562             
0230   0562             ; --- begin data block
0231   0562 45 6E 74 65 s_data: .db "Enter the number of rows: ", 0
0231   0566 72 20 74 68 
0231   056A 65 20 6E 75 
0231   056E 6D 62 65 72 
0231   0572 20 6F 66 20 
0231   0576 72 6F 77 73 
0231   057A 3A 20 00 
0232   057D 62 05       s: .dw s_data
0233   057F 20 20 20 20 ss_data: .db "    ", 0
0233   0583 00 
0234   0584 7F 05       ss: .dw ss_data
0235   0586 01 00       coef: .dw 1
0236   0588 00 00       rows: .dw 0
0237   058A 00 00       space: .dw 0
0238   058C 00 00       i: .dw 0
0239   058E 00 00       j: .dw 0
0240   0590 0A 0D 00    nl_data: .db "\n\r", 0
0241   0593 90 05       nl: .dw nl_data
0242   0595 00 00       pp: .dw 0
0243   0597             ; --- end data block
0244   0597             ; --- begin include block
0245   0597             .include "lib/stdio.asm"
0001+  0597             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0597             ; stdio.s
0003+  0597             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0597             .include "lib/string.asm"
0001++ 0597             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0597             ; string.s
0003++ 0597             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0597             
0005++ 0597             
0006++ 0597             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0597             ; strrev
0008++ 0597             ; reverse a string
0009++ 0597             ; D = string address
0010++ 0597             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0597             ; 01234
0012++ 0597             strrev:
0013++ 0597 4B          	pusha
0014++ 0598 07 DE 05    	call strlen	; length in C
0015++ 059B 12          	mov a, c
0016++ 059C AF 01 00    	cmp a, 1
0017++ 059F D0 B9 05    	jleu strrev_end	; check string length. string len must be > 1
0018++ 05A2 7D          	dec a
0019++ 05A3 FD 4E       	mov si, d	; beginning of string
0020++ 05A5 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 05A7 59          	add d, a	; end of string
0022++ 05A8 12          	mov a, c
0023++ 05A9 FD 9B       	shr a		; divide by 2
0024++ 05AB 39          	mov c, a	; C now counts the steps
0025++ 05AC             strrev_L0:
0026++ 05AC 32          	mov bl, [d]	; save load right-side char into BL
0027++ 05AD F6          	lodsb		; load left-side char into AL; increase SI
0028++ 05AE 3E          	mov [d], al	; store left char into right side
0029++ 05AF 1B          	mov al, bl
0030++ 05B0 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 05B1 7E          	dec c
0032++ 05B2 7F          	dec d
0033++ 05B3 C2 00 00    	cmp c, 0
0034++ 05B6 C7 AC 05    	jne strrev_L0
0035++ 05B9             strrev_end:
0036++ 05B9 4C          	popa
0037++ 05BA 09          	ret
0038++ 05BB             	
0039++ 05BB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 05BB             ; strchr
0041++ 05BB             ; search string in D for char in AL
0042++ 05BB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 05BB             strchr:
0044++ 05BB             strchr_L0:
0045++ 05BB 32          	mov bl, [d]
0046++ 05BC C1 00       	cmp bl, 0
0047++ 05BE C6 C9 05    	je strchr_end
0048++ 05C1 BA          	cmp al, bl
0049++ 05C2 C6 C9 05    	je strchr_end
0050++ 05C5 79          	inc d
0051++ 05C6 0A BB 05    	jmp strchr_L0
0052++ 05C9             strchr_end:
0053++ 05C9 1B          	mov al, bl
0054++ 05CA 09          	ret
0055++ 05CB             
0056++ 05CB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 05CB             ; strstr
0058++ 05CB             ; find sub-string
0059++ 05CB             ; str1 in SI
0060++ 05CB             ; str2 in DI
0061++ 05CB             ; SI points to end of source string
0062++ 05CB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 05CB             strstr:
0064++ 05CB DB          	push al
0065++ 05CC DA          	push d
0066++ 05CD E3          	push di
0067++ 05CE             strstr_loop:
0068++ 05CE F3          	cmpsb					; compare a byte of the strings
0069++ 05CF C7 DA 05    	jne strstr_ret
0070++ 05D2 FC 00 00    	lea d, [di + 0]
0071++ 05D5 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 05D7 C7 CE 05    	jne strstr_loop				; equal chars but not at end
0073++ 05DA             strstr_ret:
0074++ 05DA F0          	pop di
0075++ 05DB E7          	pop d
0076++ 05DC E8          	pop al
0077++ 05DD 09          	ret
0078++ 05DE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 05DE             ; length of null terminated string
0080++ 05DE             ; result in C
0081++ 05DE             ; pointer in D
0082++ 05DE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 05DE             strlen:
0084++ 05DE DA          	push d
0085++ 05DF 38 00 00    	mov c, 0
0086++ 05E2             strlen_L1:
0087++ 05E2 BD 00       	cmp byte [d], 0
0088++ 05E4 C6 EC 05    	je strlen_ret
0089++ 05E7 79          	inc d
0090++ 05E8 78          	inc c
0091++ 05E9 0A E2 05    	jmp strlen_L1
0092++ 05EC             strlen_ret:
0093++ 05EC E7          	pop d
0094++ 05ED 09          	ret
0095++ 05EE             
0096++ 05EE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 05EE             ; STRCMP
0098++ 05EE             ; compare two strings
0099++ 05EE             ; str1 in SI
0100++ 05EE             ; str2 in DI
0101++ 05EE             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 05EE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 05EE             strcmp:
0104++ 05EE DB          	push al
0105++ 05EF DA          	push d
0106++ 05F0 E3          	push di
0107++ 05F1 E2          	push si
0108++ 05F2             strcmp_loop:
0109++ 05F2 F3          	cmpsb					; compare a byte of the strings
0110++ 05F3 C7 FE 05    	jne strcmp_ret
0111++ 05F6 FB FF FF    	lea d, [si +- 1]
0112++ 05F9 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 05FB C7 F2 05    	jne strcmp_loop				; equal chars but not at end
0114++ 05FE             strcmp_ret:
0115++ 05FE EF          	pop si
0116++ 05FF F0          	pop di
0117++ 0600 E7          	pop d
0118++ 0601 E8          	pop al
0119++ 0602 09          	ret
0120++ 0603             
0121++ 0603             
0122++ 0603             ; STRCPY
0123++ 0603             ; copy null terminated string from SI to DI
0124++ 0603             ; source in SI
0125++ 0603             ; destination in DI
0126++ 0603             strcpy:
0127++ 0603 E2          	push si
0128++ 0604 E3          	push di
0129++ 0605 DB          	push al
0130++ 0606             strcpy_L1:
0131++ 0606 F6          	lodsb
0132++ 0607 F7          	stosb
0133++ 0608 B9 00       	cmp al, 0
0134++ 060A C7 06 06    	jne strcpy_L1
0135++ 060D             strcpy_end:
0136++ 060D E8          	pop al
0137++ 060E F0          	pop di
0138++ 060F EF          	pop si
0139++ 0610 09          	ret
0140++ 0611             
0141++ 0611             ; STRCAT
0142++ 0611             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0611             ; source in SI
0144++ 0611             ; destination in DI
0145++ 0611             strcat:
0146++ 0611 E2          	push si
0147++ 0612 E3          	push di
0148++ 0613 D7          	push a
0149++ 0614 DA          	push d
0150++ 0615 50          	mov a, di
0151++ 0616 3C          	mov d, a
0152++ 0617             strcat_goto_end_L1:
0153++ 0617 BD 00       	cmp byte[d], 0
0154++ 0619 C6 20 06    	je strcat_start
0155++ 061C 79          	inc d
0156++ 061D 0A 17 06    	jmp strcat_goto_end_L1
0157++ 0620             strcat_start:
0158++ 0620 FD 50       	mov di, d
0159++ 0622             strcat_L1:
0160++ 0622 F6          	lodsb
0161++ 0623 F7          	stosb
0162++ 0624 B9 00       	cmp al, 0
0163++ 0626 C7 22 06    	jne strcat_L1
0164++ 0629             strcat_end:
0165++ 0629 E7          	pop d
0166++ 062A E4          	pop a
0167++ 062B F0          	pop di
0168++ 062C EF          	pop si
0169++ 062D 09          	ret
0005+  062E             
0006+  062E 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  0632 34 35 36 37 
0006+  0636 38 39 41 42 
0006+  063A 43 44 45 46 
0007+  063E             
0008+  063E 01 00       table_power:.dw 1
0009+  0640 0A 00       			.dw 10
0010+  0642 64 00       			.dw 100
0011+  0644 E8 03       			.dw 1000
0012+  0646 10 27       			.dw 10000
0013+  0648             
0014+  0648             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0015+  0648             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0016+  0648             ; ASCII in BL
0017+  0648             ; result in AL
0018+  0648             ; ascii for F = 0100 0110
0019+  0648             ; ascii for 9 = 0011 1001
0020+  0648             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0021+  0648             hex_ascii_encode:
0022+  0648 1B          	mov al, bl
0023+  0649 93 40       	test al, $40				; test if letter or number
0024+  064B C7 51 06    	jnz hex_letter
0025+  064E 87 0F       	and al, $0F				; get number
0026+  0650 09          	ret
0027+  0651             hex_letter:
0028+  0651 87 0F       	and al, $0F				; get letter
0029+  0653 6A 09       	add al, 9
0030+  0655 09          	ret
0031+  0656             
0032+  0656             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0033+  0656             ; ATOI
0034+  0656             ; 2 letter hex string in B
0035+  0656             ; 8bit integer returned in AL
0036+  0656             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0037+  0656             atoi:
0038+  0656 D8          	push b
0039+  0657 07 48 06    	call hex_ascii_encode			; convert BL to 4bit code in AL
0040+  065A 30          	mov bl, bh
0041+  065B DB          	push al					; save a
0042+  065C 07 48 06    	call hex_ascii_encode
0043+  065F EA          	pop bl	
0044+  0660 FD 9E 04    	shl al, 4
0045+  0663 8C          	or al, bl
0046+  0664 E5          	pop b
0047+  0665 09          	ret	
0048+  0666             
0049+  0666             
0050+  0666             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  0666             ; printf
0052+  0666             ; no need for explanations!
0053+  0666             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0054+  0666             printf:
0055+  0666 09          	ret
0056+  0667             
0057+  0667             
0058+  0667             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  0667             ; scanf
0060+  0667             ; no need for explanations!
0061+  0667             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  0667             scanf:
0063+  0667 09          	ret
0064+  0668             
0065+  0668             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  0668             ; ITOA
0067+  0668             ; 8bit value in BL
0068+  0668             ; 2 byte ASCII result in A
0069+  0668             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0070+  0668             itoa:
0071+  0668 DA          	push d
0072+  0669 D8          	push b
0073+  066A A7 00       	mov bh, 0
0074+  066C FD A4 04    	shr bl, 4	
0075+  066F 74          	mov d, b
0076+  0670 1F 2E 06    	mov al, [d + s_hex_digits]
0077+  0673 23          	mov ah, al
0078+  0674             	
0079+  0674 E5          	pop b
0080+  0675 D8          	push b
0081+  0676 A7 00       	mov bh, 0
0082+  0678 FD 87 0F    	and bl, $0F
0083+  067B 74          	mov d, b
0084+  067C 1F 2E 06    	mov al, [d + s_hex_digits]
0085+  067F E5          	pop b
0086+  0680 E7          	pop d
0087+  0681 09          	ret
0088+  0682             
0089+  0682             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0090+  0682             ; HEX STRING TO BINARY
0091+  0682             ; di = destination address
0092+  0682             ; si = source
0093+  0682             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0094+  0682             hex_to_int:
0095+  0682             hex_to_int_L1:
0096+  0682 F6          	lodsb					; load from [SI] to AL
0097+  0683 B9 00       	cmp al, 0				; check if ASCII 0
0098+  0685 C6 92 06    	jz hex_to_int_ret
0099+  0688 36          	mov bh, al
0100+  0689 F6          	lodsb
0101+  068A 2F          	mov bl, al
0102+  068B 07 56 06    	call atoi				; convert ASCII byte in B to int (to AL)
0103+  068E F7          	stosb					; store AL to [DI]
0104+  068F 0A 82 06    	jmp hex_to_int_L1
0105+  0692             hex_to_int_ret:
0106+  0692 09          	ret		
0107+  0693             
0108+  0693             
0109+  0693             
0110+  0693             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  0693             ; GETCHAR
0112+  0693             ; char in ah
0113+  0693             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0114+  0693             getchar:
0115+  0693 DB          	push al
0116+  0694             getchar_retry:
0117+  0694 FD 0C       	sti
0118+  0696 19 01       	mov al, 1
0119+  0698 05 03       	syscall sys_io			; receive in AH
0120+  069A B9 00       	cmp al, 0			; check if any char was receive
0121+  069C C6 94 06    	je getchar_retry
0122+  069F E8          	pop al
0123+  06A0 09          	ret
0124+  06A1             
0125+  06A1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0126+  06A1             ; PUTCHAR
0127+  06A1             ; char in ah
0128+  06A1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  06A1             putchar:
0130+  06A1 D7          	push a
0131+  06A2 19 00       	mov al, 0
0132+  06A4 05 03       	syscall sys_io			; char in AH
0133+  06A6 E4          	pop a
0134+  06A7 09          	ret
0135+  06A8             
0136+  06A8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0137+  06A8             ;; INPUT A STRING
0138+  06A8             ;; terminates with null
0139+  06A8             ;; pointer in D
0140+  06A8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  06A8             gets:
0142+  06A8 D7          	push a
0143+  06A9 DA          	push d
0144+  06AA             gets_loop:
0145+  06AA FD 0C       	sti
0146+  06AC 19 01       	mov al, 1
0147+  06AE 05 03       	syscall sys_io			; receive in AH
0148+  06B0 B9 00       	cmp al, 0				; check error code (AL)
0149+  06B2 C6 AA 06    	je gets_loop			; if no char received, retry
0150+  06B5             
0151+  06B5 76 1B       	cmp ah, 27
0152+  06B7 C6 D8 06    	je gets_telnet_escape
0153+  06BA 76 0A       	cmp ah, $0A				; LF
0154+  06BC C6 31 07    	je gets_end
0155+  06BF 76 0D       	cmp ah, $0D				; CR
0156+  06C1 C6 31 07    	je gets_end
0157+  06C4 76 5C       	cmp ah, $5C				; '\\'
0158+  06C6 C6 08 07    	je gets_escape
0159+  06C9             	
0160+  06C9 76 08       	cmp ah, $08			; check for backspace
0161+  06CB C6 D4 06    	je gets_backspace
0162+  06CE             
0163+  06CE 1A          	mov al, ah
0164+  06CF 3E          	mov [d], al
0165+  06D0 79          	inc d
0166+  06D1 0A AA 06    	jmp gets_loop
0167+  06D4             gets_backspace:
0168+  06D4 7F          	dec d
0169+  06D5 0A AA 06    	jmp gets_loop
0170+  06D8             gets_telnet_escape:
0171+  06D8 FD 0C       	sti
0172+  06DA 19 01       	mov al, 1
0173+  06DC 05 03       	syscall sys_io				; receive in AH without echo
0174+  06DE B9 00       	cmp al, 0					; check error code (AL)
0175+  06E0 C6 D8 06    	je gets_telnet_escape		; if no char received, retry
0176+  06E3 76 5B       	cmp ah, '['
0177+  06E5 C7 AA 06    	jne gets_loop
0178+  06E8             gets_telnet_escape_phase2:
0179+  06E8 FD 0C       	sti
0180+  06EA 19 01       	mov al, 1
0181+  06EC 05 03       	syscall sys_io					; receive in AH without echo
0182+  06EE B9 00       	cmp al, 0						; check error code (AL)
0183+  06F0 C6 E8 06    	je gets_telnet_escape_phase2	; if no char received, retry
0184+  06F3 76 44       	cmp ah, 'D'
0185+  06F5 C6 00 07    	je gets_left_arrow
0186+  06F8 76 43       	cmp ah, 'C'
0187+  06FA C6 04 07    	je gets_right_arrow
0188+  06FD 0A AA 06    	jmp gets_loop
0189+  0700             gets_left_arrow:
0190+  0700 7F          	dec d
0191+  0701 0A AA 06    	jmp gets_loop
0192+  0704             gets_right_arrow:
0193+  0704 79          	inc d
0194+  0705 0A AA 06    	jmp gets_loop
0195+  0708             gets_escape:
0196+  0708 FD 0C       	sti
0197+  070A 19 01       	mov al, 1
0198+  070C 05 03       	syscall sys_io			; receive in AH
0199+  070E B9 00       	cmp al, 0				; check error code (AL)
0200+  0710 C6 08 07    	je gets_escape			; if no char received, retry
0201+  0713 76 6E       	cmp ah, 'n'
0202+  0715 C6 23 07    	je gets_LF
0203+  0718 76 72       	cmp ah, 'r'
0204+  071A C6 2A 07    	je gets_CR
0205+  071D 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0206+  071E 3E          	mov [d], al
0207+  071F 79          	inc d
0208+  0720 0A AA 06    	jmp gets_loop
0209+  0723             gets_LF:
0210+  0723 19 0A       	mov al, $0A
0211+  0725 3E          	mov [d], al
0212+  0726 79          	inc d
0213+  0727 0A AA 06    	jmp gets_loop
0214+  072A             gets_CR:
0215+  072A 19 0D       	mov al, $0D
0216+  072C 3E          	mov [d], al
0217+  072D 79          	inc d
0218+  072E 0A AA 06    	jmp gets_loop
0219+  0731             gets_end:
0220+  0731 19 00       	mov al, 0
0221+  0733 3E          	mov [d], al				; terminate string
0222+  0734 E7          	pop d
0223+  0735 E4          	pop a
0224+  0736 09          	ret
0225+  0737             
0226+  0737             
0227+  0737             
0228+  0737             
0229+  0737             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0230+  0737             ;; INPUT TEXT
0231+  0737             ;; terminated with CTRL+D
0232+  0737             ;; pointer in D
0233+  0737             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0234+  0737             gettxt:
0235+  0737 D7          	push a
0236+  0738 DA          	push d
0237+  0739             gettxt_loop:
0238+  0739 19 01       	mov al, 1
0239+  073B 05 03       	syscall sys_io			; receive in AH
0240+  073D B9 00       	cmp al, 0				; check error code (AL)
0241+  073F C6 39 07    	je gettxt_loop		; if no char received, retry
0242+  0742 76 04       	cmp ah, 4			; EOT
0243+  0744 C6 82 07    	je gettxt_end
0244+  0747 76 08       	cmp ah, $08			; check for backspace
0245+  0749 C6 7E 07    	je gettxt_backspace
0246+  074C 76 5C       	cmp ah, $5C				; '\\'
0247+  074E C6 57 07    	je gettxt_escape
0248+  0751 1A          	mov al, ah
0249+  0752 3E          	mov [d], al
0250+  0753 79          	inc d
0251+  0754 0A 39 07    	jmp gettxt_loop
0252+  0757             gettxt_escape:
0253+  0757 19 01       	mov al, 1
0254+  0759 05 03       	syscall sys_io			; receive in AH
0255+  075B B9 00       	cmp al, 0				; check error code (AL)
0256+  075D C6 57 07    	je gettxt_escape		; if no char received, retry
0257+  0760 76 6E       	cmp ah, 'n'
0258+  0762 C6 70 07    	je gettxt_LF
0259+  0765 76 72       	cmp ah, 'r'
0260+  0767 C6 77 07    	je gettxt_CR
0261+  076A 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0262+  076B 3E          	mov [d], al
0263+  076C 79          	inc d
0264+  076D 0A 39 07    	jmp gettxt_loop
0265+  0770             gettxt_LF:
0266+  0770 19 0A       	mov al, $0A
0267+  0772 3E          	mov [d], al
0268+  0773 79          	inc d
0269+  0774 0A 39 07    	jmp gettxt_loop
0270+  0777             gettxt_CR:
0271+  0777 19 0D       	mov al, $0D
0272+  0779 3E          	mov [d], al
0273+  077A 79          	inc d
0274+  077B 0A 39 07    	jmp gettxt_loop
0275+  077E             gettxt_backspace:
0276+  077E 7F          	dec d
0277+  077F 0A 39 07    	jmp gettxt_loop
0278+  0782             gettxt_end:
0279+  0782 19 00       	mov al, 0
0280+  0784 3E          	mov [d], al				; terminate string
0281+  0785 E7          	pop d
0282+  0786 E4          	pop a
0283+  0787 09          	ret
0284+  0788             
0285+  0788             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0286+  0788             ; PRINT NEW LINE
0287+  0788             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  0788             printnl:
0289+  0788 D7          	push a
0290+  0789 10 00 0A    	mov a, $0A00
0291+  078C 05 03       	syscall sys_io
0292+  078E 10 00 0D    	mov a, $0D00
0293+  0791 05 03       	syscall sys_io
0294+  0793 E4          	pop a
0295+  0794 09          	ret
0296+  0795             
0297+  0795             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0298+  0795             ; strtoint
0299+  0795             ; 4 digit hex string number in d
0300+  0795             ; integer returned in A
0301+  0795             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0302+  0795             strtointx:
0303+  0795 D8          	push b
0304+  0796 32          	mov bl, [d]
0305+  0797 37          	mov bh, bl
0306+  0798 33 01 00    	mov bl, [d + 1]
0307+  079B 07 56 06    	call atoi				; convert to int in AL
0308+  079E 23          	mov ah, al				; move to AH
0309+  079F 33 02 00    	mov bl, [d + 2]
0310+  07A2 37          	mov bh, bl
0311+  07A3 33 03 00    	mov bl, [d + 3]
0312+  07A6 07 56 06    	call atoi				; convert to int in AL
0313+  07A9 E5          	pop b
0314+  07AA 09          	ret
0315+  07AB             
0316+  07AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0317+  07AB             ; strtoint
0318+  07AB             ; 5 digit base10 string number in d
0319+  07AB             ; integer returned in A
0320+  07AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0321+  07AB             strtoint:
0322+  07AB E2          	push si
0323+  07AC D8          	push b
0324+  07AD D9          	push c
0325+  07AE DA          	push d
0326+  07AF 07 DE 05    	call strlen			; get string length in C
0327+  07B2 7E          	dec c
0328+  07B3 FD 4E       	mov si, d
0329+  07B5 12          	mov a, c
0330+  07B6 FD 99       	shl a
0331+  07B8 3B 3E 06    	mov d, table_power
0332+  07BB 59          	add d, a
0333+  07BC 38 00 00    	mov c, 0
0334+  07BF             strtoint_L0:
0335+  07BF F6          	lodsb			; load ASCII to al
0336+  07C0 B9 00       	cmp al, 0
0337+  07C2 C6 D5 07    	je strtoint_end
0338+  07C5 6F 30       	sub al, $30		; make into integer
0339+  07C7 22 00       	mov ah, 0
0340+  07C9 2A          	mov b, [d]
0341+  07CA AC          	mul a, b			; result in B since it fits in 16bits
0342+  07CB 11          	mov a, b
0343+  07CC 28          	mov b, c
0344+  07CD 54          	add a, b
0345+  07CE 39          	mov c, a
0346+  07CF 63 02 00    	sub d, 2
0347+  07D2 0A BF 07    	jmp strtoint_L0
0348+  07D5             strtoint_end:
0349+  07D5 12          	mov a, c
0350+  07D6 E7          	pop d
0351+  07D7 E6          	pop c
0352+  07D8 E5          	pop b
0353+  07D9 EF          	pop si
0354+  07DA 09          	ret
0355+  07DB             
0356+  07DB             
0357+  07DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0358+  07DB             ; PRINT NULL TERMINATED STRING
0359+  07DB             ; pointer in D
0360+  07DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0361+  07DB             puts:
0362+  07DB D7          	push a
0363+  07DC DA          	push d
0364+  07DD             puts_L1:
0365+  07DD 1E          	mov al, [d]
0366+  07DE B9 00       	cmp al, 0
0367+  07E0 C6 EC 07    	jz puts_END
0368+  07E3 23          	mov ah, al
0369+  07E4 19 00       	mov al, 0
0370+  07E6 05 03       	syscall sys_io
0371+  07E8 79          	inc d
0372+  07E9 0A DD 07    	jmp puts_L1
0373+  07EC             puts_END:
0374+  07EC E7          	pop d
0375+  07ED E4          	pop a
0376+  07EE 09          	ret
0377+  07EF             
0378+  07EF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  07EF             ; PRINT N SIZE STRING
0380+  07EF             ; pointer in D
0381+  07EF             ; size in C
0382+  07EF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0383+  07EF             putsn:
0384+  07EF DB          	push al
0385+  07F0 DA          	push d
0386+  07F1 D9          	push c
0387+  07F2             putsn_L0:
0388+  07F2 1E          	mov al, [d]
0389+  07F3 23          	mov ah, al
0390+  07F4 19 00       	mov al, 0
0391+  07F6 05 03       	syscall sys_io
0392+  07F8 79          	inc d
0393+  07F9 7E          	dec c	
0394+  07FA C2 00 00    	cmp c, 0
0395+  07FD C7 F2 07    	jne putsn_L0
0396+  0800             putsn_end:
0397+  0800 E6          	pop c
0398+  0801 E7          	pop d
0399+  0802 E8          	pop al
0400+  0803 09          	ret
0401+  0804             
0402+  0804             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0403+  0804             ; print 16bit decimal number
0404+  0804             ; input number in A
0405+  0804             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  0804             print_u16d:
0407+  0804 D7          	push a
0408+  0805 D8          	push b
0409+  0806 26 10 27    	mov b, 10000
0410+  0809 AE          	div a, b			; get 10000 coeff.
0411+  080A 07 30 08    	call print_number
0412+  080D 11          	mov a, b
0413+  080E 26 E8 03    	mov b, 1000
0414+  0811 AE          	div a, b			; get 10000 coeff.
0415+  0812 07 30 08    	call print_number
0416+  0815 11          	mov a, b
0417+  0816 26 64 00    	mov b, 100
0418+  0819 AE          	div a, b
0419+  081A 07 30 08    	call print_number
0420+  081D 11          	mov a, b
0421+  081E 26 0A 00    	mov b, 10
0422+  0821 AE          	div a, b
0423+  0822 07 30 08    	call print_number
0424+  0825 11          	mov a, b
0425+  0826 6A 30       	add al, $30
0426+  0828 23          	mov ah, al
0427+  0829 19 00       	mov al, 0
0428+  082B 05 03       	syscall sys_io	; print coeff
0429+  082D E5          	pop b
0430+  082E E4          	pop a
0431+  082F 09          	ret
0432+  0830             
0433+  0830             
0434+  0830             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0435+  0830             ; if A == 0, print space
0436+  0830             ; else print A
0437+  0830             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0438+  0830             print_number:
0439+  0830 6A 30       	add al, $30
0440+  0832 23          	mov ah, al
0441+  0833 07 A1 06    	call putchar
0442+  0836 09          	ret
0443+  0837             
0444+  0837             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  0837             ; PRINT 16BIT HEX INTEGER
0446+  0837             ; integer value in reg B
0447+  0837             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  0837             print_u16x:
0449+  0837 D7          	push a
0450+  0838 D8          	push b
0451+  0839 DD          	push bl
0452+  083A 30          	mov bl, bh
0453+  083B 07 68 06    	call itoa				; convert bh to char in A
0454+  083E 2F          	mov bl, al				; save al
0455+  083F 19 00       	mov al, 0
0456+  0841 05 03       	syscall sys_io				; display AH
0457+  0843 24          	mov ah, bl				; retrieve al
0458+  0844 19 00       	mov al, 0
0459+  0846 05 03       	syscall sys_io				; display AL
0460+  0848             
0461+  0848 EA          	pop bl
0462+  0849 07 68 06    	call itoa				; convert bh to char in A
0463+  084C 2F          	mov bl, al				; save al
0464+  084D 19 00       	mov al, 0
0465+  084F 05 03       	syscall sys_io				; display AH
0466+  0851 24          	mov ah, bl				; retrieve al
0467+  0852 19 00       	mov al, 0
0468+  0854 05 03       	syscall sys_io				; display AL
0469+  0856             
0470+  0856 E5          	pop b
0471+  0857 E4          	pop a
0472+  0858 09          	ret
0473+  0859             
0474+  0859             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0475+  0859             ; INPUT 16BIT HEX INTEGER
0476+  0859             ; read 16bit integer into A
0477+  0859             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0478+  0859             scan_u16x:
0479+  0859 F8 10 00    	enter 16
0480+  085C D8          	push b
0481+  085D DA          	push d
0482+  085E             
0483+  085E FA F1 FF    	lea d, [bp + -15]
0484+  0861 07 A8 06    	call gets				; get number
0485+  0864             
0486+  0864 32          	mov bl, [d]
0487+  0865 37          	mov bh, bl
0488+  0866 33 01 00    	mov bl, [d + 1]
0489+  0869 07 56 06    	call atoi				; convert to int in AL
0490+  086C 23          	mov ah, al				; move to AH
0491+  086D             
0492+  086D 33 02 00    	mov bl, [d + 2]
0493+  0870 37          	mov bh, bl
0494+  0871 33 03 00    	mov bl, [d + 3]
0495+  0874 07 56 06    	call atoi				; convert to int in AL
0496+  0877             
0497+  0877 E7          	pop d
0498+  0878 E5          	pop b
0499+  0879 F9          	leave
0500+  087A 09          	ret
0501+  087B             
0502+  087B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0503+  087B             ; PRINT 8bit HEX INTEGER
0504+  087B             ; integer value in reg bl
0505+  087B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0506+  087B             print_u8x:
0507+  087B D7          	push a
0508+  087C DD          	push bl
0509+  087D             
0510+  087D 07 68 06    	call itoa				; convert bl to char in A
0511+  0880 2F          	mov bl, al				; save al
0512+  0881 19 00       	mov al, 0
0513+  0883 05 03       	syscall sys_io				; display AH
0514+  0885 24          	mov ah, bl				; retrieve al
0515+  0886 19 00       	mov al, 0
0516+  0888 05 03       	syscall sys_io				; display AL
0517+  088A             
0518+  088A EA          	pop bl
0519+  088B E4          	pop a
0520+  088C 09          	ret
0521+  088D             
0522+  088D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0523+  088D             ; print 8bit decimal unsigned number
0524+  088D             ; input number in AL
0525+  088D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0526+  088D             print_u8d:
0527+  088D D7          	push a
0528+  088E D8          	push b
0529+  088F             
0530+  088F 22 00       	mov ah, 0
0531+  0891 26 64 00    	mov b, 100
0532+  0894 AE          	div a, b
0533+  0895 D8          	push b			; save remainder
0534+  0896 B9 00       	cmp al, 0
0535+  0898 C6 A2 08    	je skip100
0536+  089B 6A 30       	add al, $30
0537+  089D 23          	mov ah, al
0538+  089E 19 00       	mov al, 0
0539+  08A0 05 03       	syscall sys_io	; print coeff
0540+  08A2             skip100:
0541+  08A2 E4          	pop a
0542+  08A3 22 00       	mov ah, 0
0543+  08A5 26 0A 00    	mov b, 10
0544+  08A8 AE          	div a, b
0545+  08A9 D8          	push b			; save remainder
0546+  08AA B9 00       	cmp al, 0
0547+  08AC C6 B6 08    	je skip10
0548+  08AF 6A 30       	add al, $30
0549+  08B1 23          	mov ah, al
0550+  08B2 19 00       	mov al, 0
0551+  08B4 05 03       	syscall sys_io	; print coeff
0552+  08B6             skip10:
0553+  08B6 E4          	pop a
0554+  08B7 1B          	mov al, bl
0555+  08B8 6A 30       	add al, $30
0556+  08BA 23          	mov ah, al
0557+  08BB 19 00       	mov al, 0
0558+  08BD 05 03       	syscall sys_io	; print coeff
0559+  08BF E5          	pop b
0560+  08C0 E4          	pop a
0561+  08C1 09          	ret
0562+  08C2             
0563+  08C2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0564+  08C2             ; INPUT 8BIT HEX INTEGER
0565+  08C2             ; read 8bit integer into AL
0566+  08C2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0567+  08C2             scan_u8x:
0568+  08C2 F8 04 00    	enter 4
0569+  08C5 D8          	push b
0570+  08C6 DA          	push d
0571+  08C7             
0572+  08C7 FA FD FF    	lea d, [bp + -3]
0573+  08CA 07 A8 06    	call gets				; get number
0574+  08CD             
0575+  08CD 32          	mov bl, [d]
0576+  08CE 37          	mov bh, bl
0577+  08CF 33 01 00    	mov bl, [d + 1]
0578+  08D2 07 56 06    	call atoi				; convert to int in AL
0579+  08D5             
0580+  08D5 E7          	pop d
0581+  08D6 E5          	pop b
0582+  08D7 F9          	leave
0583+  08D8 09          	ret
0584+  08D9             
0585+  08D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0586+  08D9             ; input decimal number
0587+  08D9             ; result in A
0588+  08D9             ; 655'\0'
0589+  08D9             ; low--------high
0590+  08D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0591+  08D9             scan_u16d:
0592+  08D9 F8 08 00    	enter 8
0593+  08DC E2          	push si
0594+  08DD D8          	push b
0595+  08DE D9          	push c
0596+  08DF DA          	push d
0597+  08E0 FA F9 FF    	lea d, [bp +- 7]
0598+  08E3 07 A8 06    	call gets
0599+  08E6 07 DE 05    	call strlen			; get string length in C
0600+  08E9 7E          	dec c
0601+  08EA FD 4E       	mov si, d
0602+  08EC 12          	mov a, c
0603+  08ED FD 99       	shl a
0604+  08EF 3B 3E 06    	mov d, table_power
0605+  08F2 59          	add d, a
0606+  08F3 38 00 00    	mov c, 0
0607+  08F6             mul_loop:
0608+  08F6 F6          	lodsb			; load ASCII to al
0609+  08F7 B9 00       	cmp al, 0
0610+  08F9 C6 0C 09    	je mul_exit
0611+  08FC 6F 30       	sub al, $30		; make into integer
0612+  08FE 22 00       	mov ah, 0
0613+  0900 2A          	mov b, [d]
0614+  0901 AC          	mul a, b			; result in B since it fits in 16bits
0615+  0902 11          	mov a, b
0616+  0903 28          	mov b, c
0617+  0904 54          	add a, b
0618+  0905 39          	mov c, a
0619+  0906 63 02 00    	sub d, 2
0620+  0909 0A F6 08    	jmp mul_loop
0621+  090C             mul_exit:
0622+  090C 12          	mov a, c
0623+  090D E7          	pop d
0624+  090E E6          	pop c
0625+  090F E5          	pop b
0626+  0910 EF          	pop si
0627+  0911 F9          	leave
0628+  0912 09          	ret
0246   0913             ; --- end include block
0247   0913             
0248   0913             .end
tasm: Number of errors = 0
