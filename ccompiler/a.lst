0001   0000             ; --- FILENAME: auto.c
0002   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0400             .org PROC_TEXT_ORG
0004   0400             
0005   0400             ; --- BEGIN TEXT BLOCK
0006   0400             main:
0007   0400 D2            push bp
0008   0401 9B            mov bp, sp
0009   0402 52 02 00      sub sp, 2 ; i
0010   0405             _while1_cond:
0011   0405 26 01 00      mov b, 1
0012   0408 C0 00 00      cmp b, 0
0013   040B C6 4A 04      je _while1_exit
0014   040E             _while1_block:
0015   040E 07 58 04      call initialize
0016   0411             _for2_init:
0017   0411 26 00 00      mov b, 0
0018   0414 D7            push a
0019   0415 11            mov a, b
0020   0416 45 FF FF      mov [bp + -1], a ; i
0021   0419 E4            pop a
0022   041A             _for2_cond:
0023   041A 2C FF FF      mov b, [bp + -1] ; i
0024   041D D7            push a
0025   041E 11            mov a, b
0026   041F 29 57 06      mov b, [SIZE]
0027   0422 B0            cmp a, b
0028   0423 0E            lodflgs
0029   0424 87 02         and al, %00000010
0030   0426 22 00         mov ah, 0
0031   0428 27            mov b, a
0032   0429 E4            pop a
0033   042A C0 00 00      cmp b, 0
0034   042D C6 47 04      je _for2_exit
0035   0430             _for2_block:
0036   0430 07 7B 04      call compute_next
0037   0433 07 86 05      call update_current
0038   0436 07 D7 05      call display
0039   0439             _for2_update:
0040   0439 2C FF FF      mov b, [bp + -1] ; i
0041   043C FD 77         inc b
0042   043E D7            push a
0043   043F 11            mov a, b
0044   0440 45 FF FF      mov [bp + -1], a ; i
0045   0443 E4            pop a
0046   0444 0A 1A 04      jmp _for2_cond
0047   0447             _for2_exit:
0048   0447 0A 05 04      jmp _while1_cond
0049   044A             _while1_exit:
0050   044A F9            leave
0051   044B 05 0B         syscall sys_terminate_proc
0052   044D             print:
0053   044D D2            push bp
0054   044E 9B            mov bp, sp
0055   044F             
0056   044F             ; --- BEGIN INLINE ASM BLOCK
0057   044F 17 05 00      mov a, [bp + 5]
0058   0452 3C            mov d, a
0059   0453 07 3D 0A      call puts
0060   0456             ; --- END INLINE ASM BLOCK
0061   0456             
0062   0456 F9            leave
0063   0457 09            ret
0064   0458             initialize:
0065   0458 D2            push bp
0066   0459 9B            mov bp, sp
0067   045A 29 2D 07      mov b, [current]
0068   045D 74            mov d, b
0069   045E 29 57 06      mov b, [SIZE]
0070   0461 D7            push a
0071   0462 11            mov a, b
0072   0463 26 02 00      mov b, 2
0073   0466 AE            div a, b
0074   0467 FD 78         mov g, a
0075   0469 11            mov a, b
0076   046A FD 27         mov b, g
0077   046C E4            pop a
0078   046D 10 02 00      mov a, 2
0079   0470 AC            mul a, b
0080   0471 5A            add d, b
0081   0472 DA            push d
0082   0473 26 01 00      mov b, 1
0083   0476 E7            pop d
0084   0477 11            mov a, b
0085   0478 43            mov [d], a
0086   0479 F9            leave
0087   047A 09            ret
0088   047B             compute_next:
0089   047B D2            push bp
0090   047C 9B            mov bp, sp
0091   047D 52 02 00      sub sp, 2 ; left
0092   0480 52 02 00      sub sp, 2 ; right
0093   0483 52 02 00      sub sp, 2 ; i
0094   0486             _for3_init:
0095   0486 26 00 00      mov b, 0
0096   0489 D7            push a
0097   048A 11            mov a, b
0098   048B 45 FB FF      mov [bp + -5], a ; i
0099   048E E4            pop a
0100   048F             _for3_cond:
0101   048F 2C FB FF      mov b, [bp + -5] ; i
0102   0492 D7            push a
0103   0493 11            mov a, b
0104   0494 29 57 06      mov b, [SIZE]
0105   0497 B0            cmp a, b
0106   0498 0E            lodflgs
0107   0499 87 02         and al, %00000010
0108   049B 22 00         mov ah, 0
0109   049D 27            mov b, a
0110   049E E4            pop a
0111   049F C0 00 00      cmp b, 0
0112   04A2 C6 84 05      je _for3_exit
0113   04A5             _for3_block:
0114   04A5             _ternary4_cond:
0115   04A5 2C FB FF      mov b, [bp + -5] ; i
0116   04A8 D7            push a
0117   04A9 11            mov a, b
0118   04AA 26 00 00      mov b, 0
0119   04AD B0            cmp a, b
0120   04AE 0E            lodflgs
0121   04AF 87 01         and al, %00000001
0122   04B1 22 00         mov ah, 0
0123   04B3 27            mov b, a
0124   04B4 E4            pop a
0125   04B5 C0 00 00      cmp b, 0
0126   04B8 C6 D3 04      je _ternary4_false
0127   04BB             _ternary4_true:
0128   04BB 29 2D 07      mov b, [current]
0129   04BE 74            mov d, b
0130   04BF 29 57 06      mov b, [SIZE]
0131   04C2 D7            push a
0132   04C3 11            mov a, b
0133   04C4 26 01 00      mov b, 1
0134   04C7 60            sub a, b
0135   04C8 27            mov b, a
0136   04C9 E4            pop a
0137   04CA 10 02 00      mov a, 2
0138   04CD AC            mul a, b
0139   04CE 5A            add d, b
0140   04CF 2A            mov b, [d]
0141   04D0 0A E8 04      jmp _ternary4_exit
0142   04D3             _ternary4_false:
0143   04D3 29 2D 07      mov b, [current]
0144   04D6 74            mov d, b
0145   04D7 2C FB FF      mov b, [bp + -5] ; i
0146   04DA D7            push a
0147   04DB 11            mov a, b
0148   04DC 26 01 00      mov b, 1
0149   04DF 60            sub a, b
0150   04E0 27            mov b, a
0151   04E1 E4            pop a
0152   04E2 10 02 00      mov a, 2
0153   04E5 AC            mul a, b
0154   04E6 5A            add d, b
0155   04E7 2A            mov b, [d]
0156   04E8             _ternary4_exit:
0157   04E8 D7            push a
0158   04E9 11            mov a, b
0159   04EA 45 FF FF      mov [bp + -1], a ; left
0160   04ED E4            pop a
0161   04EE             _ternary5_cond:
0162   04EE 2C FB FF      mov b, [bp + -5] ; i
0163   04F1 D7            push a
0164   04F2 11            mov a, b
0165   04F3 29 57 06      mov b, [SIZE]
0166   04F6 D7            push a
0167   04F7 11            mov a, b
0168   04F8 26 01 00      mov b, 1
0169   04FB 60            sub a, b
0170   04FC 27            mov b, a
0171   04FD E4            pop a
0172   04FE B0            cmp a, b
0173   04FF 0E            lodflgs
0174   0500 87 01         and al, %00000001
0175   0502 22 00         mov ah, 0
0176   0504 27            mov b, a
0177   0505 E4            pop a
0178   0506 C0 00 00      cmp b, 0
0179   0509 C6 1C 05      je _ternary5_false
0180   050C             _ternary5_true:
0181   050C 29 2D 07      mov b, [current]
0182   050F 74            mov d, b
0183   0510 26 00 00      mov b, 0
0184   0513 10 02 00      mov a, 2
0185   0516 AC            mul a, b
0186   0517 5A            add d, b
0187   0518 2A            mov b, [d]
0188   0519 0A 31 05      jmp _ternary5_exit
0189   051C             _ternary5_false:
0190   051C 29 2D 07      mov b, [current]
0191   051F 74            mov d, b
0192   0520 2C FB FF      mov b, [bp + -5] ; i
0193   0523 D7            push a
0194   0524 11            mov a, b
0195   0525 26 01 00      mov b, 1
0196   0528 54            add a, b
0197   0529 27            mov b, a
0198   052A E4            pop a
0199   052B 10 02 00      mov a, 2
0200   052E AC            mul a, b
0201   052F 5A            add d, b
0202   0530 2A            mov b, [d]
0203   0531             _ternary5_exit:
0204   0531 D7            push a
0205   0532 11            mov a, b
0206   0533 45 FD FF      mov [bp + -3], a ; right
0207   0536 E4            pop a
0208   0537             _if6_cond:
0209   0537 2C FF FF      mov b, [bp + -1] ; left
0210   053A D7            push a
0211   053B 11            mov a, b
0212   053C 2C FD FF      mov b, [bp + -3] ; right
0213   053F B0            cmp a, b
0214   0540 0E            lodflgs
0215   0541 87 01         and al, %00000001
0216   0543 22 00         mov ah, 0
0217   0545 27            mov b, a
0218   0546 E4            pop a
0219   0547 C0 00 00      cmp b, 0
0220   054A C6 63 05      je _if6_else
0221   054D             _if6_true:
0222   054D 29 F7 07      mov b, [next]
0223   0550 74            mov d, b
0224   0551 2C FB FF      mov b, [bp + -5] ; i
0225   0554 10 02 00      mov a, 2
0226   0557 AC            mul a, b
0227   0558 5A            add d, b
0228   0559 DA            push d
0229   055A 26 00 00      mov b, 0
0230   055D E7            pop d
0231   055E 11            mov a, b
0232   055F 43            mov [d], a
0233   0560 0A 76 05      jmp _if6_exit
0234   0563             _if6_else:
0235   0563 29 F7 07      mov b, [next]
0236   0566 74            mov d, b
0237   0567 2C FB FF      mov b, [bp + -5] ; i
0238   056A 10 02 00      mov a, 2
0239   056D AC            mul a, b
0240   056E 5A            add d, b
0241   056F DA            push d
0242   0570 26 01 00      mov b, 1
0243   0573 E7            pop d
0244   0574 11            mov a, b
0245   0575 43            mov [d], a
0246   0576             _if6_exit:
0247   0576             _for3_update:
0248   0576 2C FB FF      mov b, [bp + -5] ; i
0249   0579 FD 77         inc b
0250   057B D7            push a
0251   057C 11            mov a, b
0252   057D 45 FB FF      mov [bp + -5], a ; i
0253   0580 E4            pop a
0254   0581 0A 8F 04      jmp _for3_cond
0255   0584             _for3_exit:
0256   0584 F9            leave
0257   0585 09            ret
0258   0586             update_current:
0259   0586 D2            push bp
0260   0587 9B            mov bp, sp
0261   0588 52 02 00      sub sp, 2 ; i
0262   058B             _for7_init:
0263   058B 26 00 00      mov b, 0
0264   058E D7            push a
0265   058F 11            mov a, b
0266   0590 45 FF FF      mov [bp + -1], a ; i
0267   0593 E4            pop a
0268   0594             _for7_cond:
0269   0594 2C FF FF      mov b, [bp + -1] ; i
0270   0597 D7            push a
0271   0598 11            mov a, b
0272   0599 29 57 06      mov b, [SIZE]
0273   059C B0            cmp a, b
0274   059D 0E            lodflgs
0275   059E 87 02         and al, %00000010
0276   05A0 22 00         mov ah, 0
0277   05A2 27            mov b, a
0278   05A3 E4            pop a
0279   05A4 C0 00 00      cmp b, 0
0280   05A7 C6 D5 05      je _for7_exit
0281   05AA             _for7_block:
0282   05AA 29 2D 07      mov b, [current]
0283   05AD 74            mov d, b
0284   05AE 2C FF FF      mov b, [bp + -1] ; i
0285   05B1 10 02 00      mov a, 2
0286   05B4 AC            mul a, b
0287   05B5 5A            add d, b
0288   05B6 DA            push d
0289   05B7 29 F7 07      mov b, [next]
0290   05BA 74            mov d, b
0291   05BB 2C FF FF      mov b, [bp + -1] ; i
0292   05BE 10 02 00      mov a, 2
0293   05C1 AC            mul a, b
0294   05C2 5A            add d, b
0295   05C3 2A            mov b, [d]
0296   05C4 E7            pop d
0297   05C5 11            mov a, b
0298   05C6 43            mov [d], a
0299   05C7             _for7_update:
0300   05C7 2C FF FF      mov b, [bp + -1] ; i
0301   05CA FD 77         inc b
0302   05CC D7            push a
0303   05CD 11            mov a, b
0304   05CE 45 FF FF      mov [bp + -1], a ; i
0305   05D1 E4            pop a
0306   05D2 0A 94 05      jmp _for7_cond
0307   05D5             _for7_exit:
0308   05D5 F9            leave
0309   05D6 09            ret
0310   05D7             display:
0311   05D7 D2            push bp
0312   05D8 9B            mov bp, sp
0313   05D9 52 01 00      sub sp, 1 ; c
0314   05DC 52 02 00      sub sp, 2 ; i
0315   05DF             _for8_init:
0316   05DF 26 00 00      mov b, 0
0317   05E2 D7            push a
0318   05E3 11            mov a, b
0319   05E4 45 FE FF      mov [bp + -2], a ; i
0320   05E7 E4            pop a
0321   05E8             _for8_cond:
0322   05E8 2C FE FF      mov b, [bp + -2] ; i
0323   05EB D7            push a
0324   05EC 11            mov a, b
0325   05ED 29 57 06      mov b, [SIZE]
0326   05F0 B0            cmp a, b
0327   05F1 0E            lodflgs
0328   05F2 87 02         and al, %00000010
0329   05F4 22 00         mov ah, 0
0330   05F6 27            mov b, a
0331   05F7 E4            pop a
0332   05F8 C0 00 00      cmp b, 0
0333   05FB C6 49 06      je _for8_exit
0334   05FE             _for8_block:
0335   05FE             _if9_cond:
0336   05FE 29 2D 07      mov b, [current]
0337   0601 74            mov d, b
0338   0602 2C FE FF      mov b, [bp + -2] ; i
0339   0605 10 02 00      mov a, 2
0340   0608 AC            mul a, b
0341   0609 5A            add d, b
0342   060A 2A            mov b, [d]
0343   060B D7            push a
0344   060C 11            mov a, b
0345   060D 26 00 00      mov b, 0
0346   0610 B0            cmp a, b
0347   0611 0E            lodflgs
0348   0612 87 01         and al, %00000001
0349   0614 8F 01         xor al, %00000001
0350   0616 22 00         mov ah, 0
0351   0618 27            mov b, a
0352   0619 E4            pop a
0353   061A C0 00 00      cmp b, 0
0354   061D C6 2F 06      je _if9_else
0355   0620             _if9_true:
0356   0620 29 5F 06      mov b, [ast]
0357   0623 FD AB         swp b
0358   0625 D8            push b
0359   0626 07 4D 04      call print
0360   0629 51 02 00      add sp, 2
0361   062C 0A 3B 06      jmp _if9_exit
0362   062F             _if9_else:
0363   062F 29 63 06      mov b, [space]
0364   0632 FD AB         swp b
0365   0634 D8            push b
0366   0635 07 4D 04      call print
0367   0638 51 02 00      add sp, 2
0368   063B             _if9_exit:
0369   063B             _for8_update:
0370   063B 2C FE FF      mov b, [bp + -2] ; i
0371   063E FD 77         inc b
0372   0640 D7            push a
0373   0641 11            mov a, b
0374   0642 45 FE FF      mov [bp + -2], a ; i
0375   0645 E4            pop a
0376   0646 0A E8 05      jmp _for8_cond
0377   0649             _for8_exit:
0378   0649 29 5B 06      mov b, [line]
0379   064C FD AB         swp b
0380   064E D8            push b
0381   064F 07 4D 04      call print
0382   0652 51 02 00      add sp, 2
0383   0655 F9            leave
0384   0656 09            ret
0385   0657             ; --- END TEXT BLOCK
0386   0657             
0387   0657             ; --- BEGIN DATA BLOCK
0388   0657 64 00       SIZE: .dw 100
0389   0659 0A 00       line_data: .db "\n", 0
0390   065B 59 06       line: .dw line_data
0391   065D 2A 00       ast_data: .db "*", 0
0392   065F 5D 06       ast: .dw ast_data
0393   0661 20 00       space_data: .db " ", 0
0394   0663 61 06       space: .dw space_data
0395   0665 00 00 00 00 current_data: .dw 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
0395   0669 00 00 00 00 
0395   066D 00 00 00 00 
0395   0671 00 00 00 00 
0395   0675 00 00 00 00 
0395   0679 00 00 00 00 
0395   067D 00 00 00 00 
0395   0681 00 00 00 00 
0395   0685 00 00 00 00 
0395   0689 00 00 00 00 
0395   068D 00 00 00 00 
0395   0691 00 00 00 00 
0395   0695 00 00 00 00 
0395   0699 00 00 00 00 
0395   069D 00 00 00 00 
0395   06A1 00 00 00 00 
0395   06A5 00 00 00 00 
0395   06A9 00 00 00 00 
0395   06AD 00 00 00 00 
0395   06B1 00 00 00 00 
0395   06B5 00 00 00 00 
0395   06B9 00 00 00 00 
0395   06BD 00 00 00 00 
0395   06C1 00 00 00 00 
0395   06C5 00 00 00 00 
0395   06C9 00 00 00 00 
0395   06CD 00 00 00 00 
0395   06D1 00 00 00 00 
0395   06D5 00 00 00 00 
0395   06D9 00 00 00 00 
0395   06DD 00 00 00 00 
0395   06E1 00 00 00 00 
0395   06E5 00 00 00 00 
0395   06E9 00 00 00 00 
0395   06ED 00 00 00 00 
0395   06F1 00 00 00 00 
0395   06F5 00 00 00 00 
0395   06F9 00 00 00 00 
0395   06FD 00 00 00 00 
0395   0701 00 00 00 00 
0395   0705 00 00 00 00 
0395   0709 00 00 00 00 
0395   070D 00 00 00 00 
0395   0711 00 00 00 00 
0395   0715 00 00 00 00 
0395   0719 00 00 00 00 
0395   071D 00 00 00 00 
0395   0721 00 00 00 00 
0395   0725 00 00 00 00 
0395   0729 00 00 00 00 
0396   072D 65 06       current: .dw current_data
0397   072F 00 00 00 00 next_data: .dw 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
0397   0733 00 00 00 00 
0397   0737 00 00 00 00 
0397   073B 00 00 00 00 
0397   073F 00 00 00 00 
0397   0743 00 00 00 00 
0397   0747 00 00 00 00 
0397   074B 00 00 00 00 
0397   074F 00 00 00 00 
0397   0753 00 00 00 00 
0397   0757 00 00 00 00 
0397   075B 00 00 00 00 
0397   075F 00 00 00 00 
0397   0763 00 00 00 00 
0397   0767 00 00 00 00 
0397   076B 00 00 00 00 
0397   076F 00 00 00 00 
0397   0773 00 00 00 00 
0397   0777 00 00 00 00 
0397   077B 00 00 00 00 
0397   077F 00 00 00 00 
0397   0783 00 00 00 00 
0397   0787 00 00 00 00 
0397   078B 00 00 00 00 
0397   078F 00 00 00 00 
0397   0793 00 00 00 00 
0397   0797 00 00 00 00 
0397   079B 00 00 00 00 
0397   079F 00 00 00 00 
0397   07A3 00 00 00 00 
0397   07A7 00 00 00 00 
0397   07AB 00 00 00 00 
0397   07AF 00 00 00 00 
0397   07B3 00 00 00 00 
0397   07B7 00 00 00 00 
0397   07BB 00 00 00 00 
0397   07BF 00 00 00 00 
0397   07C3 00 00 00 00 
0397   07C7 00 00 00 00 
0397   07CB 00 00 00 00 
0397   07CF 00 00 00 00 
0397   07D3 00 00 00 00 
0397   07D7 00 00 00 00 
0397   07DB 00 00 00 00 
0397   07DF 00 00 00 00 
0397   07E3 00 00 00 00 
0397   07E7 00 00 00 00 
0397   07EB 00 00 00 00 
0397   07EF 00 00 00 00 
0397   07F3 00 00 00 00 
0398   07F7 2F 07       next: .dw next_data
0399   07F9             ; --- END DATA BLOCK
0400   07F9             
0401   07F9             ; --- BEGIN INCLUDE BLOCK
0402   07F9             .include "lib/stdio.asm"
0001+  07F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  07F9             ; stdio.s
0003+  07F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  07F9             .include "lib/string.asm"
0001++ 07F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 07F9             ; string.s
0003++ 07F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 07F9             
0005++ 07F9             
0006++ 07F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 07F9             ; strrev
0008++ 07F9             ; reverse a string
0009++ 07F9             ; D = string address
0010++ 07F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 07F9             ; 01234
0012++ 07F9             strrev:
0013++ 07F9 4B          	pusha
0014++ 07FA 07 40 08    	call strlen	; length in C
0015++ 07FD 12          	mov a, c
0016++ 07FE AF 01 00    	cmp a, 1
0017++ 0801 D0 1B 08    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0804 7D          	dec a
0019++ 0805 FD 4E       	mov si, d	; beginning of string
0020++ 0807 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0809 59          	add d, a	; end of string
0022++ 080A 12          	mov a, c
0023++ 080B FD 9B       	shr a		; divide by 2
0024++ 080D 39          	mov c, a	; C now counts the steps
0025++ 080E             strrev_L0:
0026++ 080E 32          	mov bl, [d]	; save load right-side char into BL
0027++ 080F F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0810 3E          	mov [d], al	; store left char into right side
0029++ 0811 1B          	mov al, bl
0030++ 0812 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0813 7E          	dec c
0032++ 0814 7F          	dec d
0033++ 0815 C2 00 00    	cmp c, 0
0034++ 0818 C7 0E 08    	jne strrev_L0
0035++ 081B             strrev_end:
0036++ 081B 4C          	popa
0037++ 081C 09          	ret
0038++ 081D             	
0039++ 081D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 081D             ; strchr
0041++ 081D             ; search string in D for char in AL
0042++ 081D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 081D             strchr:
0044++ 081D             strchr_L0:
0045++ 081D 32          	mov bl, [d]
0046++ 081E C1 00       	cmp bl, 0
0047++ 0820 C6 2B 08    	je strchr_end
0048++ 0823 BA          	cmp al, bl
0049++ 0824 C6 2B 08    	je strchr_end
0050++ 0827 79          	inc d
0051++ 0828 0A 1D 08    	jmp strchr_L0
0052++ 082B             strchr_end:
0053++ 082B 1B          	mov al, bl
0054++ 082C 09          	ret
0055++ 082D             
0056++ 082D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 082D             ; strstr
0058++ 082D             ; find sub-string
0059++ 082D             ; str1 in SI
0060++ 082D             ; str2 in DI
0061++ 082D             ; SI points to end of source string
0062++ 082D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 082D             strstr:
0064++ 082D DB          	push al
0065++ 082E DA          	push d
0066++ 082F E3          	push di
0067++ 0830             strstr_loop:
0068++ 0830 F3          	cmpsb					; compare a byte of the strings
0069++ 0831 C7 3C 08    	jne strstr_ret
0070++ 0834 FC 00 00    	lea d, [di + 0]
0071++ 0837 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0839 C7 30 08    	jne strstr_loop				; equal chars but not at end
0073++ 083C             strstr_ret:
0074++ 083C F0          	pop di
0075++ 083D E7          	pop d
0076++ 083E E8          	pop al
0077++ 083F 09          	ret
0078++ 0840             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0840             ; length of null terminated string
0080++ 0840             ; result in C
0081++ 0840             ; pointer in D
0082++ 0840             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0840             strlen:
0084++ 0840 DA          	push d
0085++ 0841 38 00 00    	mov c, 0
0086++ 0844             strlen_L1:
0087++ 0844 BD 00       	cmp byte [d], 0
0088++ 0846 C6 4E 08    	je strlen_ret
0089++ 0849 79          	inc d
0090++ 084A 78          	inc c
0091++ 084B 0A 44 08    	jmp strlen_L1
0092++ 084E             strlen_ret:
0093++ 084E E7          	pop d
0094++ 084F 09          	ret
0095++ 0850             
0096++ 0850             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0850             ; STRCMP
0098++ 0850             ; compare two strings
0099++ 0850             ; str1 in SI
0100++ 0850             ; str2 in DI
0101++ 0850             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0850             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0850             strcmp:
0104++ 0850 DB          	push al
0105++ 0851 DA          	push d
0106++ 0852 E3          	push di
0107++ 0853 E2          	push si
0108++ 0854             strcmp_loop:
0109++ 0854 F3          	cmpsb					; compare a byte of the strings
0110++ 0855 C7 60 08    	jne strcmp_ret
0111++ 0858 FB FF FF    	lea d, [si +- 1]
0112++ 085B BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 085D C7 54 08    	jne strcmp_loop				; equal chars but not at end
0114++ 0860             strcmp_ret:
0115++ 0860 EF          	pop si
0116++ 0861 F0          	pop di
0117++ 0862 E7          	pop d
0118++ 0863 E8          	pop al
0119++ 0864 09          	ret
0120++ 0865             
0121++ 0865             
0122++ 0865             ; STRCPY
0123++ 0865             ; copy null terminated string from SI to DI
0124++ 0865             ; source in SI
0125++ 0865             ; destination in DI
0126++ 0865             strcpy:
0127++ 0865 E2          	push si
0128++ 0866 E3          	push di
0129++ 0867 DB          	push al
0130++ 0868             strcpy_L1:
0131++ 0868 F6          	lodsb
0132++ 0869 F7          	stosb
0133++ 086A B9 00       	cmp al, 0
0134++ 086C C7 68 08    	jne strcpy_L1
0135++ 086F             strcpy_end:
0136++ 086F E8          	pop al
0137++ 0870 F0          	pop di
0138++ 0871 EF          	pop si
0139++ 0872 09          	ret
0140++ 0873             
0141++ 0873             ; STRCAT
0142++ 0873             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0873             ; source in SI
0144++ 0873             ; destination in DI
0145++ 0873             strcat:
0146++ 0873 E2          	push si
0147++ 0874 E3          	push di
0148++ 0875 D7          	push a
0149++ 0876 DA          	push d
0150++ 0877 50          	mov a, di
0151++ 0878 3C          	mov d, a
0152++ 0879             strcat_goto_end_L1:
0153++ 0879 BD 00       	cmp byte[d], 0
0154++ 087B C6 82 08    	je strcat_start
0155++ 087E 79          	inc d
0156++ 087F 0A 79 08    	jmp strcat_goto_end_L1
0157++ 0882             strcat_start:
0158++ 0882 FD 50       	mov di, d
0159++ 0884             strcat_L1:
0160++ 0884 F6          	lodsb
0161++ 0885 F7          	stosb
0162++ 0886 B9 00       	cmp al, 0
0163++ 0888 C7 84 08    	jne strcat_L1
0164++ 088B             strcat_end:
0165++ 088B E7          	pop d
0166++ 088C E4          	pop a
0167++ 088D F0          	pop di
0168++ 088E EF          	pop si
0169++ 088F 09          	ret
0005+  0890             
0006+  0890 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  0894 34 35 36 37 
0006+  0898 38 39 41 42 
0006+  089C 43 44 45 46 
0007+  08A0             
0008+  08A0 01 00       table_power:.dw 1
0009+  08A2 0A 00       			.dw 10
0010+  08A4 64 00       			.dw 100
0011+  08A6 E8 03       			.dw 1000
0012+  08A8 10 27       			.dw 10000
0013+  08AA             
0014+  08AA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0015+  08AA             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0016+  08AA             ; ASCII in BL
0017+  08AA             ; result in AL
0018+  08AA             ; ascii for F = 0100 0110
0019+  08AA             ; ascii for 9 = 0011 1001
0020+  08AA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0021+  08AA             hex_ascii_encode:
0022+  08AA 1B          	mov al, bl
0023+  08AB 93 40       	test al, $40				; test if letter or number
0024+  08AD C7 B3 08    	jnz hex_letter
0025+  08B0 87 0F       	and al, $0F				; get number
0026+  08B2 09          	ret
0027+  08B3             hex_letter:
0028+  08B3 87 0F       	and al, $0F				; get letter
0029+  08B5 6A 09       	add al, 9
0030+  08B7 09          	ret
0031+  08B8             
0032+  08B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0033+  08B8             ; ATOI
0034+  08B8             ; 2 letter hex string in B
0035+  08B8             ; 8bit integer returned in AL
0036+  08B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0037+  08B8             atoi:
0038+  08B8 D8          	push b
0039+  08B9 07 AA 08    	call hex_ascii_encode			; convert BL to 4bit code in AL
0040+  08BC 30          	mov bl, bh
0041+  08BD DB          	push al					; save a
0042+  08BE 07 AA 08    	call hex_ascii_encode
0043+  08C1 EA          	pop bl	
0044+  08C2 FD 9E 04    	shl al, 4
0045+  08C5 8C          	or al, bl
0046+  08C6 E5          	pop b
0047+  08C7 09          	ret	
0048+  08C8             
0049+  08C8             
0050+  08C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  08C8             ; printf
0052+  08C8             ; no need for explanations!
0053+  08C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0054+  08C8             printf:
0055+  08C8 09          	ret
0056+  08C9             
0057+  08C9             
0058+  08C9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  08C9             ; scanf
0060+  08C9             ; no need for explanations!
0061+  08C9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  08C9             scanf:
0063+  08C9 09          	ret
0064+  08CA             
0065+  08CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  08CA             ; ITOA
0067+  08CA             ; 8bit value in BL
0068+  08CA             ; 2 byte ASCII result in A
0069+  08CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0070+  08CA             itoa:
0071+  08CA DA          	push d
0072+  08CB D8          	push b
0073+  08CC A7 00       	mov bh, 0
0074+  08CE FD A4 04    	shr bl, 4	
0075+  08D1 74          	mov d, b
0076+  08D2 1F 90 08    	mov al, [d + s_hex_digits]
0077+  08D5 23          	mov ah, al
0078+  08D6             	
0079+  08D6 E5          	pop b
0080+  08D7 D8          	push b
0081+  08D8 A7 00       	mov bh, 0
0082+  08DA FD 87 0F    	and bl, $0F
0083+  08DD 74          	mov d, b
0084+  08DE 1F 90 08    	mov al, [d + s_hex_digits]
0085+  08E1 E5          	pop b
0086+  08E2 E7          	pop d
0087+  08E3 09          	ret
0088+  08E4             
0089+  08E4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0090+  08E4             ; HEX STRING TO BINARY
0091+  08E4             ; di = destination address
0092+  08E4             ; si = source
0093+  08E4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0094+  08E4             hex_to_int:
0095+  08E4             hex_to_int_L1:
0096+  08E4 F6          	lodsb					; load from [SI] to AL
0097+  08E5 B9 00       	cmp al, 0				; check if ASCII 0
0098+  08E7 C6 F4 08    	jz hex_to_int_ret
0099+  08EA 36          	mov bh, al
0100+  08EB F6          	lodsb
0101+  08EC 2F          	mov bl, al
0102+  08ED 07 B8 08    	call atoi				; convert ASCII byte in B to int (to AL)
0103+  08F0 F7          	stosb					; store AL to [DI]
0104+  08F1 0A E4 08    	jmp hex_to_int_L1
0105+  08F4             hex_to_int_ret:
0106+  08F4 09          	ret		
0107+  08F5             
0108+  08F5             
0109+  08F5             
0110+  08F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  08F5             ; GETCHAR
0112+  08F5             ; char in ah
0113+  08F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0114+  08F5             getchar:
0115+  08F5 DB          	push al
0116+  08F6             getchar_retry:
0117+  08F6 FD 0C       	sti
0118+  08F8 19 01       	mov al, 1
0119+  08FA 05 03       	syscall sys_io			; receive in AH
0120+  08FC B9 00       	cmp al, 0			; check if any char was receive
0121+  08FE C6 F6 08    	je getchar_retry
0122+  0901 E8          	pop al
0123+  0902 09          	ret
0124+  0903             
0125+  0903             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0126+  0903             ; PUTCHAR
0127+  0903             ; char in ah
0128+  0903             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  0903             putchar:
0130+  0903 D7          	push a
0131+  0904 19 00       	mov al, 0
0132+  0906 05 03       	syscall sys_io			; char in AH
0133+  0908 E4          	pop a
0134+  0909 09          	ret
0135+  090A             
0136+  090A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0137+  090A             ;; INPUT A STRING
0138+  090A             ;; terminates with null
0139+  090A             ;; pointer in D
0140+  090A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  090A             gets:
0142+  090A D7          	push a
0143+  090B DA          	push d
0144+  090C             gets_loop:
0145+  090C FD 0C       	sti
0146+  090E 19 01       	mov al, 1
0147+  0910 05 03       	syscall sys_io			; receive in AH
0148+  0912 B9 00       	cmp al, 0				; check error code (AL)
0149+  0914 C6 0C 09    	je gets_loop			; if no char received, retry
0150+  0917             
0151+  0917 76 1B       	cmp ah, 27
0152+  0919 C6 3A 09    	je gets_telnet_escape
0153+  091C 76 0A       	cmp ah, $0A				; LF
0154+  091E C6 93 09    	je gets_end
0155+  0921 76 0D       	cmp ah, $0D				; CR
0156+  0923 C6 93 09    	je gets_end
0157+  0926 76 5C       	cmp ah, $5C				; '\\'
0158+  0928 C6 6A 09    	je gets_escape
0159+  092B             	
0160+  092B 76 08       	cmp ah, $08			; check for backspace
0161+  092D C6 36 09    	je gets_backspace
0162+  0930             
0163+  0930 1A          	mov al, ah
0164+  0931 3E          	mov [d], al
0165+  0932 79          	inc d
0166+  0933 0A 0C 09    	jmp gets_loop
0167+  0936             gets_backspace:
0168+  0936 7F          	dec d
0169+  0937 0A 0C 09    	jmp gets_loop
0170+  093A             gets_telnet_escape:
0171+  093A FD 0C       	sti
0172+  093C 19 01       	mov al, 1
0173+  093E 05 03       	syscall sys_io				; receive in AH without echo
0174+  0940 B9 00       	cmp al, 0					; check error code (AL)
0175+  0942 C6 3A 09    	je gets_telnet_escape		; if no char received, retry
0176+  0945 76 5B       	cmp ah, '['
0177+  0947 C7 0C 09    	jne gets_loop
0178+  094A             gets_telnet_escape_phase2:
0179+  094A FD 0C       	sti
0180+  094C 19 01       	mov al, 1
0181+  094E 05 03       	syscall sys_io					; receive in AH without echo
0182+  0950 B9 00       	cmp al, 0						; check error code (AL)
0183+  0952 C6 4A 09    	je gets_telnet_escape_phase2	; if no char received, retry
0184+  0955 76 44       	cmp ah, 'D'
0185+  0957 C6 62 09    	je gets_left_arrow
0186+  095A 76 43       	cmp ah, 'C'
0187+  095C C6 66 09    	je gets_right_arrow
0188+  095F 0A 0C 09    	jmp gets_loop
0189+  0962             gets_left_arrow:
0190+  0962 7F          	dec d
0191+  0963 0A 0C 09    	jmp gets_loop
0192+  0966             gets_right_arrow:
0193+  0966 79          	inc d
0194+  0967 0A 0C 09    	jmp gets_loop
0195+  096A             gets_escape:
0196+  096A FD 0C       	sti
0197+  096C 19 01       	mov al, 1
0198+  096E 05 03       	syscall sys_io			; receive in AH
0199+  0970 B9 00       	cmp al, 0				; check error code (AL)
0200+  0972 C6 6A 09    	je gets_escape			; if no char received, retry
0201+  0975 76 6E       	cmp ah, 'n'
0202+  0977 C6 85 09    	je gets_LF
0203+  097A 76 72       	cmp ah, 'r'
0204+  097C C6 8C 09    	je gets_CR
0205+  097F 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0206+  0980 3E          	mov [d], al
0207+  0981 79          	inc d
0208+  0982 0A 0C 09    	jmp gets_loop
0209+  0985             gets_LF:
0210+  0985 19 0A       	mov al, $0A
0211+  0987 3E          	mov [d], al
0212+  0988 79          	inc d
0213+  0989 0A 0C 09    	jmp gets_loop
0214+  098C             gets_CR:
0215+  098C 19 0D       	mov al, $0D
0216+  098E 3E          	mov [d], al
0217+  098F 79          	inc d
0218+  0990 0A 0C 09    	jmp gets_loop
0219+  0993             gets_end:
0220+  0993 19 00       	mov al, 0
0221+  0995 3E          	mov [d], al				; terminate string
0222+  0996 E7          	pop d
0223+  0997 E4          	pop a
0224+  0998 09          	ret
0225+  0999             
0226+  0999             
0227+  0999             
0228+  0999             
0229+  0999             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0230+  0999             ;; INPUT TEXT
0231+  0999             ;; terminated with CTRL+D
0232+  0999             ;; pointer in D
0233+  0999             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0234+  0999             gettxt:
0235+  0999 D7          	push a
0236+  099A DA          	push d
0237+  099B             gettxt_loop:
0238+  099B 19 01       	mov al, 1
0239+  099D 05 03       	syscall sys_io			; receive in AH
0240+  099F B9 00       	cmp al, 0				; check error code (AL)
0241+  09A1 C6 9B 09    	je gettxt_loop		; if no char received, retry
0242+  09A4 76 04       	cmp ah, 4			; EOT
0243+  09A6 C6 E4 09    	je gettxt_end
0244+  09A9 76 08       	cmp ah, $08			; check for backspace
0245+  09AB C6 E0 09    	je gettxt_backspace
0246+  09AE 76 5C       	cmp ah, $5C				; '\\'
0247+  09B0 C6 B9 09    	je gettxt_escape
0248+  09B3 1A          	mov al, ah
0249+  09B4 3E          	mov [d], al
0250+  09B5 79          	inc d
0251+  09B6 0A 9B 09    	jmp gettxt_loop
0252+  09B9             gettxt_escape:
0253+  09B9 19 01       	mov al, 1
0254+  09BB 05 03       	syscall sys_io			; receive in AH
0255+  09BD B9 00       	cmp al, 0				; check error code (AL)
0256+  09BF C6 B9 09    	je gettxt_escape		; if no char received, retry
0257+  09C2 76 6E       	cmp ah, 'n'
0258+  09C4 C6 D2 09    	je gettxt_LF
0259+  09C7 76 72       	cmp ah, 'r'
0260+  09C9 C6 D9 09    	je gettxt_CR
0261+  09CC 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0262+  09CD 3E          	mov [d], al
0263+  09CE 79          	inc d
0264+  09CF 0A 9B 09    	jmp gettxt_loop
0265+  09D2             gettxt_LF:
0266+  09D2 19 0A       	mov al, $0A
0267+  09D4 3E          	mov [d], al
0268+  09D5 79          	inc d
0269+  09D6 0A 9B 09    	jmp gettxt_loop
0270+  09D9             gettxt_CR:
0271+  09D9 19 0D       	mov al, $0D
0272+  09DB 3E          	mov [d], al
0273+  09DC 79          	inc d
0274+  09DD 0A 9B 09    	jmp gettxt_loop
0275+  09E0             gettxt_backspace:
0276+  09E0 7F          	dec d
0277+  09E1 0A 9B 09    	jmp gettxt_loop
0278+  09E4             gettxt_end:
0279+  09E4 19 00       	mov al, 0
0280+  09E6 3E          	mov [d], al				; terminate string
0281+  09E7 E7          	pop d
0282+  09E8 E4          	pop a
0283+  09E9 09          	ret
0284+  09EA             
0285+  09EA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0286+  09EA             ; PRINT NEW LINE
0287+  09EA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  09EA             printnl:
0289+  09EA D7          	push a
0290+  09EB 10 00 0A    	mov a, $0A00
0291+  09EE 05 03       	syscall sys_io
0292+  09F0 10 00 0D    	mov a, $0D00
0293+  09F3 05 03       	syscall sys_io
0294+  09F5 E4          	pop a
0295+  09F6 09          	ret
0296+  09F7             
0297+  09F7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0298+  09F7             ; strtoint
0299+  09F7             ; 4 digit hex string number in d
0300+  09F7             ; integer returned in A
0301+  09F7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0302+  09F7             strtointx:
0303+  09F7 D8          	push b
0304+  09F8 32          	mov bl, [d]
0305+  09F9 37          	mov bh, bl
0306+  09FA 33 01 00    	mov bl, [d + 1]
0307+  09FD 07 B8 08    	call atoi				; convert to int in AL
0308+  0A00 23          	mov ah, al				; move to AH
0309+  0A01 33 02 00    	mov bl, [d + 2]
0310+  0A04 37          	mov bh, bl
0311+  0A05 33 03 00    	mov bl, [d + 3]
0312+  0A08 07 B8 08    	call atoi				; convert to int in AL
0313+  0A0B E5          	pop b
0314+  0A0C 09          	ret
0315+  0A0D             
0316+  0A0D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0317+  0A0D             ; strtoint
0318+  0A0D             ; 5 digit base10 string number in d
0319+  0A0D             ; integer returned in A
0320+  0A0D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0321+  0A0D             strtoint:
0322+  0A0D E2          	push si
0323+  0A0E D8          	push b
0324+  0A0F D9          	push c
0325+  0A10 DA          	push d
0326+  0A11 07 40 08    	call strlen			; get string length in C
0327+  0A14 7E          	dec c
0328+  0A15 FD 4E       	mov si, d
0329+  0A17 12          	mov a, c
0330+  0A18 FD 99       	shl a
0331+  0A1A 3B A0 08    	mov d, table_power
0332+  0A1D 59          	add d, a
0333+  0A1E 38 00 00    	mov c, 0
0334+  0A21             strtoint_L0:
0335+  0A21 F6          	lodsb			; load ASCII to al
0336+  0A22 B9 00       	cmp al, 0
0337+  0A24 C6 37 0A    	je strtoint_end
0338+  0A27 6F 30       	sub al, $30		; make into integer
0339+  0A29 22 00       	mov ah, 0
0340+  0A2B 2A          	mov b, [d]
0341+  0A2C AC          	mul a, b			; result in B since it fits in 16bits
0342+  0A2D 11          	mov a, b
0343+  0A2E 28          	mov b, c
0344+  0A2F 54          	add a, b
0345+  0A30 39          	mov c, a
0346+  0A31 63 02 00    	sub d, 2
0347+  0A34 0A 21 0A    	jmp strtoint_L0
0348+  0A37             strtoint_end:
0349+  0A37 12          	mov a, c
0350+  0A38 E7          	pop d
0351+  0A39 E6          	pop c
0352+  0A3A E5          	pop b
0353+  0A3B EF          	pop si
0354+  0A3C 09          	ret
0355+  0A3D             
0356+  0A3D             
0357+  0A3D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0358+  0A3D             ; PRINT NULL TERMINATED STRING
0359+  0A3D             ; pointer in D
0360+  0A3D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0361+  0A3D             puts:
0362+  0A3D D7          	push a
0363+  0A3E DA          	push d
0364+  0A3F             puts_L1:
0365+  0A3F 1E          	mov al, [d]
0366+  0A40 B9 00       	cmp al, 0
0367+  0A42 C6 4E 0A    	jz puts_END
0368+  0A45 23          	mov ah, al
0369+  0A46 19 00       	mov al, 0
0370+  0A48 05 03       	syscall sys_io
0371+  0A4A 79          	inc d
0372+  0A4B 0A 3F 0A    	jmp puts_L1
0373+  0A4E             puts_END:
0374+  0A4E E7          	pop d
0375+  0A4F E4          	pop a
0376+  0A50 09          	ret
0377+  0A51             
0378+  0A51             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  0A51             ; PRINT N SIZE STRING
0380+  0A51             ; pointer in D
0381+  0A51             ; size in C
0382+  0A51             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0383+  0A51             putsn:
0384+  0A51 DB          	push al
0385+  0A52 DA          	push d
0386+  0A53 D9          	push c
0387+  0A54             putsn_L0:
0388+  0A54 1E          	mov al, [d]
0389+  0A55 23          	mov ah, al
0390+  0A56 19 00       	mov al, 0
0391+  0A58 05 03       	syscall sys_io
0392+  0A5A 79          	inc d
0393+  0A5B 7E          	dec c	
0394+  0A5C C2 00 00    	cmp c, 0
0395+  0A5F C7 54 0A    	jne putsn_L0
0396+  0A62             putsn_end:
0397+  0A62 E6          	pop c
0398+  0A63 E7          	pop d
0399+  0A64 E8          	pop al
0400+  0A65 09          	ret
0401+  0A66             
0402+  0A66             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0403+  0A66             ; print 16bit decimal number
0404+  0A66             ; input number in A
0405+  0A66             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  0A66             print_u16d:
0407+  0A66 D7          	push a
0408+  0A67 D8          	push b
0409+  0A68 26 10 27    	mov b, 10000
0410+  0A6B AE          	div a, b			; get 10000 coeff.
0411+  0A6C 07 92 0A    	call print_number
0412+  0A6F 11          	mov a, b
0413+  0A70 26 E8 03    	mov b, 1000
0414+  0A73 AE          	div a, b			; get 10000 coeff.
0415+  0A74 07 92 0A    	call print_number
0416+  0A77 11          	mov a, b
0417+  0A78 26 64 00    	mov b, 100
0418+  0A7B AE          	div a, b
0419+  0A7C 07 92 0A    	call print_number
0420+  0A7F 11          	mov a, b
0421+  0A80 26 0A 00    	mov b, 10
0422+  0A83 AE          	div a, b
0423+  0A84 07 92 0A    	call print_number
0424+  0A87 11          	mov a, b
0425+  0A88 6A 30       	add al, $30
0426+  0A8A 23          	mov ah, al
0427+  0A8B 19 00       	mov al, 0
0428+  0A8D 05 03       	syscall sys_io	; print coeff
0429+  0A8F E5          	pop b
0430+  0A90 E4          	pop a
0431+  0A91 09          	ret
0432+  0A92             
0433+  0A92             
0434+  0A92             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0435+  0A92             ; if A == 0, print space
0436+  0A92             ; else print A
0437+  0A92             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0438+  0A92             print_number:
0439+  0A92 6A 30       	add al, $30
0440+  0A94 23          	mov ah, al
0441+  0A95 07 03 09    	call putchar
0442+  0A98 09          	ret
0443+  0A99             
0444+  0A99             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  0A99             ; PRINT 16BIT HEX INTEGER
0446+  0A99             ; integer value in reg B
0447+  0A99             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  0A99             print_u16x:
0449+  0A99 D7          	push a
0450+  0A9A D8          	push b
0451+  0A9B DD          	push bl
0452+  0A9C 30          	mov bl, bh
0453+  0A9D 07 CA 08    	call itoa				; convert bh to char in A
0454+  0AA0 2F          	mov bl, al				; save al
0455+  0AA1 19 00       	mov al, 0
0456+  0AA3 05 03       	syscall sys_io				; display AH
0457+  0AA5 24          	mov ah, bl				; retrieve al
0458+  0AA6 19 00       	mov al, 0
0459+  0AA8 05 03       	syscall sys_io				; display AL
0460+  0AAA             
0461+  0AAA EA          	pop bl
0462+  0AAB 07 CA 08    	call itoa				; convert bh to char in A
0463+  0AAE 2F          	mov bl, al				; save al
0464+  0AAF 19 00       	mov al, 0
0465+  0AB1 05 03       	syscall sys_io				; display AH
0466+  0AB3 24          	mov ah, bl				; retrieve al
0467+  0AB4 19 00       	mov al, 0
0468+  0AB6 05 03       	syscall sys_io				; display AL
0469+  0AB8             
0470+  0AB8 E5          	pop b
0471+  0AB9 E4          	pop a
0472+  0ABA 09          	ret
0473+  0ABB             
0474+  0ABB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0475+  0ABB             ; INPUT 16BIT HEX INTEGER
0476+  0ABB             ; read 16bit integer into A
0477+  0ABB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0478+  0ABB             scan_u16x:
0479+  0ABB F8 10 00    	enter 16
0480+  0ABE D8          	push b
0481+  0ABF DA          	push d
0482+  0AC0             
0483+  0AC0 FA F1 FF    	lea d, [bp + -15]
0484+  0AC3 07 0A 09    	call gets				; get number
0485+  0AC6             
0486+  0AC6 32          	mov bl, [d]
0487+  0AC7 37          	mov bh, bl
0488+  0AC8 33 01 00    	mov bl, [d + 1]
0489+  0ACB 07 B8 08    	call atoi				; convert to int in AL
0490+  0ACE 23          	mov ah, al				; move to AH
0491+  0ACF             
0492+  0ACF 33 02 00    	mov bl, [d + 2]
0493+  0AD2 37          	mov bh, bl
0494+  0AD3 33 03 00    	mov bl, [d + 3]
0495+  0AD6 07 B8 08    	call atoi				; convert to int in AL
0496+  0AD9             
0497+  0AD9 E7          	pop d
0498+  0ADA E5          	pop b
0499+  0ADB F9          	leave
0500+  0ADC 09          	ret
0501+  0ADD             
0502+  0ADD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0503+  0ADD             ; PRINT 8bit HEX INTEGER
0504+  0ADD             ; integer value in reg bl
0505+  0ADD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0506+  0ADD             print_u8x:
0507+  0ADD D7          	push a
0508+  0ADE DD          	push bl
0509+  0ADF             
0510+  0ADF 07 CA 08    	call itoa				; convert bl to char in A
0511+  0AE2 2F          	mov bl, al				; save al
0512+  0AE3 19 00       	mov al, 0
0513+  0AE5 05 03       	syscall sys_io				; display AH
0514+  0AE7 24          	mov ah, bl				; retrieve al
0515+  0AE8 19 00       	mov al, 0
0516+  0AEA 05 03       	syscall sys_io				; display AL
0517+  0AEC             
0518+  0AEC EA          	pop bl
0519+  0AED E4          	pop a
0520+  0AEE 09          	ret
0521+  0AEF             
0522+  0AEF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0523+  0AEF             ; print 8bit decimal unsigned number
0524+  0AEF             ; input number in AL
0525+  0AEF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0526+  0AEF             print_u8d:
0527+  0AEF D7          	push a
0528+  0AF0 D8          	push b
0529+  0AF1             
0530+  0AF1 22 00       	mov ah, 0
0531+  0AF3 26 64 00    	mov b, 100
0532+  0AF6 AE          	div a, b
0533+  0AF7 D8          	push b			; save remainder
0534+  0AF8 B9 00       	cmp al, 0
0535+  0AFA C6 04 0B    	je skip100
0536+  0AFD 6A 30       	add al, $30
0537+  0AFF 23          	mov ah, al
0538+  0B00 19 00       	mov al, 0
0539+  0B02 05 03       	syscall sys_io	; print coeff
0540+  0B04             skip100:
0541+  0B04 E4          	pop a
0542+  0B05 22 00       	mov ah, 0
0543+  0B07 26 0A 00    	mov b, 10
0544+  0B0A AE          	div a, b
0545+  0B0B D8          	push b			; save remainder
0546+  0B0C B9 00       	cmp al, 0
0547+  0B0E C6 18 0B    	je skip10
0548+  0B11 6A 30       	add al, $30
0549+  0B13 23          	mov ah, al
0550+  0B14 19 00       	mov al, 0
0551+  0B16 05 03       	syscall sys_io	; print coeff
0552+  0B18             skip10:
0553+  0B18 E4          	pop a
0554+  0B19 1B          	mov al, bl
0555+  0B1A 6A 30       	add al, $30
0556+  0B1C 23          	mov ah, al
0557+  0B1D 19 00       	mov al, 0
0558+  0B1F 05 03       	syscall sys_io	; print coeff
0559+  0B21 E5          	pop b
0560+  0B22 E4          	pop a
0561+  0B23 09          	ret
0562+  0B24             
0563+  0B24             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0564+  0B24             ; INPUT 8BIT HEX INTEGER
0565+  0B24             ; read 8bit integer into AL
0566+  0B24             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0567+  0B24             scan_u8x:
0568+  0B24 F8 04 00    	enter 4
0569+  0B27 D8          	push b
0570+  0B28 DA          	push d
0571+  0B29             
0572+  0B29 FA FD FF    	lea d, [bp + -3]
0573+  0B2C 07 0A 09    	call gets				; get number
0574+  0B2F             
0575+  0B2F 32          	mov bl, [d]
0576+  0B30 37          	mov bh, bl
0577+  0B31 33 01 00    	mov bl, [d + 1]
0578+  0B34 07 B8 08    	call atoi				; convert to int in AL
0579+  0B37             
0580+  0B37 E7          	pop d
0581+  0B38 E5          	pop b
0582+  0B39 F9          	leave
0583+  0B3A 09          	ret
0584+  0B3B             
0585+  0B3B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0586+  0B3B             ; input decimal number
0587+  0B3B             ; result in A
0588+  0B3B             ; 655'\0'
0589+  0B3B             ; low--------high
0590+  0B3B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0591+  0B3B             scan_u16d:
0592+  0B3B F8 08 00    	enter 8
0593+  0B3E E2          	push si
0594+  0B3F D8          	push b
0595+  0B40 D9          	push c
0596+  0B41 DA          	push d
0597+  0B42 FA F9 FF    	lea d, [bp +- 7]
0598+  0B45 07 0A 09    	call gets
0599+  0B48 07 40 08    	call strlen			; get string length in C
0600+  0B4B 7E          	dec c
0601+  0B4C FD 4E       	mov si, d
0602+  0B4E 12          	mov a, c
0603+  0B4F FD 99       	shl a
0604+  0B51 3B A0 08    	mov d, table_power
0605+  0B54 59          	add d, a
0606+  0B55 38 00 00    	mov c, 0
0607+  0B58             mul_loop:
0608+  0B58 F6          	lodsb			; load ASCII to al
0609+  0B59 B9 00       	cmp al, 0
0610+  0B5B C6 6E 0B    	je mul_exit
0611+  0B5E 6F 30       	sub al, $30		; make into integer
0612+  0B60 22 00       	mov ah, 0
0613+  0B62 2A          	mov b, [d]
0614+  0B63 AC          	mul a, b			; result in B since it fits in 16bits
0615+  0B64 11          	mov a, b
0616+  0B65 28          	mov b, c
0617+  0B66 54          	add a, b
0618+  0B67 39          	mov c, a
0619+  0B68 63 02 00    	sub d, 2
0620+  0B6B 0A 58 0B    	jmp mul_loop
0621+  0B6E             mul_exit:
0622+  0B6E 12          	mov a, c
0623+  0B6F E7          	pop d
0624+  0B70 E6          	pop c
0625+  0B71 E5          	pop b
0626+  0B72 EF          	pop si
0627+  0B73 F9          	leave
0628+  0B74 09          	ret
0403   0B75             ; --- END INCLUDE BLOCK
0404   0B75             
0405   0B75             
0406   0B75             .end
tasm: Number of errors = 0
