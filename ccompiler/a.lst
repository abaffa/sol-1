0001   0000             ; --- FILENAME: test.c
0002   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0400             .org PROC_TEXT_ORG
0004   0400             
0005   0400             ; --- BEGIN TEXT BLOCK
0006   0400             main:
0007   0400 D2            push bp
0008   0401 9B            mov bp, sp
0009   0402 29 76 05      mov b, [s1]
0010   0405 FD AB         swp b
0011   0407 D8            push b
0012   0408 29 8C 05      mov b, [s2]
0013   040B FD AB         swp b
0014   040D D8            push b
0015   040E 07 78 04      call _strcat
0016   0411 51 04 00      add sp, 4
0017   0414 29 76 05      mov b, [s1]
0018   0417 FD AB         swp b
0019   0419 D8            push b
0020   041A 07 2F 04      call _strlen
0021   041D 51 02 00      add sp, 2
0022   0420 FD AB         swp b
0023   0422 D8            push b
0024   0423 07 29 05      call printn
0025   0426 51 02 00      add sp, 2
0026   0429 26 00 00      mov b, 0
0027   042C F9            leave
0028   042D 05 0B         syscall sys_terminate_proc
0029   042F             _strlen:
0030   042F D2            push bp
0031   0430 9B            mov bp, sp
0032   0431 52 02 00      sub sp, 2 ; length
0033   0434 26 00 00      mov b, 0
0034   0437 D7            push a
0035   0438 11            mov a, b
0036   0439 45 FF FF      mov [bp + -1], a ; length
0037   043C E4            pop a
0038   043D             _while1_cond:
0039   043D FA 05 00      lea d, [bp + 5] ; str
0040   0440 2A            mov b, [d]
0041   0441 D7            push a
0042   0442 11            mov a, b
0043   0443 2C FF FF      mov b, [bp + -1] ; length
0044   0446 54            add a, b
0045   0447 27            mov b, a
0046   0448 E4            pop a
0047   0449 74            mov d, b
0048   044A D7            push a
0049   044B 11            mov a, b
0050   044C 26 00 00      mov b, 0
0051   044F B0            cmp a, b
0052   0450 0E            lodflgs
0053   0451 87 01         and al, %00000001
0054   0453 8F 01         xor al, %00000001 ; !=
0055   0455 B9 00         cmp al, 0
0056   0457 0E            lodflgs
0057   0458 96            not al
0058   0459 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0059   045B 22 00         mov ah, 0
0060   045D 27            mov b, a
0061   045E E4            pop a
0062   045F C0 00 00      cmp b, 0
0063   0462 C6 73 04      je _while1_exit
0064   0465             _while1_block:
0065   0465 2C FF FF      mov b, [bp + -1] ; length
0066   0468 FD 77         inc b
0067   046A D7            push a
0068   046B 11            mov a, b
0069   046C 45 FF FF      mov [bp + -1], a ; length
0070   046F E4            pop a
0071   0470 0A 3D 04      jmp _while1_cond
0072   0473             _while1_exit:
0073   0473 2C FF FF      mov b, [bp + -1] ; length
0074   0476 F9            leave
0075   0477 09            ret
0076   0478             _strcat:
0077   0478 D2            push bp
0078   0479 9B            mov bp, sp
0079   047A 52 02 00      sub sp, 2 ; dest_len
0080   047D 52 02 00      sub sp, 2 ; i
0081   0480 FA 07 00      lea d, [bp + 7] ; dest
0082   0483 2A            mov b, [d]
0083   0484 FD AB         swp b
0084   0486 D8            push b
0085   0487 07 2F 04      call _strlen
0086   048A 51 02 00      add sp, 2
0087   048D D7            push a
0088   048E 11            mov a, b
0089   048F 45 FF FF      mov [bp + -1], a ; dest_len
0090   0492 E4            pop a
0091   0493             _for2_init:
0092   0493 26 00 00      mov b, 0
0093   0496 D7            push a
0094   0497 11            mov a, b
0095   0498 45 FD FF      mov [bp + -3], a ; i
0096   049B E4            pop a
0097   049C             _for2_cond:
0098   049C FA 05 00      lea d, [bp + 5] ; src
0099   049F 2A            mov b, [d]
0100   04A0 D7            push a
0101   04A1 11            mov a, b
0102   04A2 2C FD FF      mov b, [bp + -3] ; i
0103   04A5 54            add a, b
0104   04A6 27            mov b, a
0105   04A7 E4            pop a
0106   04A8 74            mov d, b
0107   04A9 D7            push a
0108   04AA 11            mov a, b
0109   04AB 26 00 00      mov b, 0
0110   04AE B0            cmp a, b
0111   04AF 0E            lodflgs
0112   04B0 87 01         and al, %00000001
0113   04B2 8F 01         xor al, %00000001 ; !=
0114   04B4 B9 00         cmp al, 0
0115   04B6 0E            lodflgs
0116   04B7 96            not al
0117   04B8 87 01         and al, %00000001 ; transform relational logical condition result into a single bit
0118   04BA 22 00         mov ah, 0
0119   04BC 27            mov b, a
0120   04BD E4            pop a
0121   04BE C0 00 00      cmp b, 0
0122   04C1 C6 F4 04      je _for2_exit
0123   04C4             _for2_block:
0124   04C4 FA 07 00      lea d, [bp + 7] ; dest
0125   04C7 2A            mov b, [d]
0126   04C8 D7            push a
0127   04C9 11            mov a, b
0128   04CA 2C FF FF      mov b, [bp + -1] ; dest_len
0129   04CD 54            add a, b
0130   04CE 27            mov b, a
0131   04CF 11            mov a, b
0132   04D0 2C FD FF      mov b, [bp + -3] ; i
0133   04D3 54            add a, b
0134   04D4 27            mov b, a
0135   04D5 E4            pop a
0136   04D6 74            mov d, b
0137   04D7 FA 05 00      lea d, [bp + 5] ; src
0138   04DA 2A            mov b, [d]
0139   04DB D7            push a
0140   04DC 11            mov a, b
0141   04DD 2C FD FF      mov b, [bp + -3] ; i
0142   04E0 54            add a, b
0143   04E1 27            mov b, a
0144   04E2 E4            pop a
0145   04E3 74            mov d, b
0146   04E4 11            mov a, b
0147   04E5 43            mov [d], a
0148   04E6             _for2_update:
0149   04E6 2C FD FF      mov b, [bp + -3] ; i
0150   04E9 FD 77         inc b
0151   04EB D7            push a
0152   04EC 11            mov a, b
0153   04ED 45 FD FF      mov [bp + -3], a ; i
0154   04F0 E4            pop a
0155   04F1 0A 9C 04      jmp _for2_cond
0156   04F4             _for2_exit:
0157   04F4 FA 07 00      lea d, [bp + 7] ; dest
0158   04F7 2A            mov b, [d]
0159   04F8 D7            push a
0160   04F9 11            mov a, b
0161   04FA 2C FF FF      mov b, [bp + -1] ; dest_len
0162   04FD 54            add a, b
0163   04FE 27            mov b, a
0164   04FF 11            mov a, b
0165   0500 2C FD FF      mov b, [bp + -3] ; i
0166   0503 54            add a, b
0167   0504 27            mov b, a
0168   0505 E4            pop a
0169   0506 74            mov d, b
0170   0507 26 00 00      mov b, 0
0171   050A 11            mov a, b
0172   050B 43            mov [d], a
0173   050C FA 07 00      lea d, [bp + 7] ; dest
0174   050F 2A            mov b, [d]
0175   0510 F9            leave
0176   0511 09            ret
0177   0512             scann:
0178   0512 D2            push bp
0179   0513 9B            mov bp, sp
0180   0514 52 02 00      sub sp, 2 ; m
0181   0517             
0182   0517             ; --- BEGIN INLINE ASM BLOCK
0183   0517 07 D8 08      call scan_u16d
0184   051A 45 FF FF      mov [bp + -1], a
0185   051D             ; --- END INLINE ASM BLOCK
0186   051D             
0187   051D FA 05 00      lea d, [bp + 5] ; n
0188   0520 2A            mov b, [d]
0189   0521 74            mov d, b
0190   0522 2C FF FF      mov b, [bp + -1] ; m
0191   0525 11            mov a, b
0192   0526 43            mov [d], a
0193   0527 F9            leave
0194   0528 09            ret
0195   0529             printn:
0196   0529 D2            push bp
0197   052A 9B            mov bp, sp
0198   052B             
0199   052B             ; --- BEGIN INLINE ASM BLOCK
0200   052B 17 05 00      mov a, [bp + 5]
0201   052E 07 03 08      call print_u16d
0202   0531             ; --- END INLINE ASM BLOCK
0203   0531             
0204   0531 F9            leave
0205   0532 09            ret
0206   0533             print:
0207   0533 D2            push bp
0208   0534 9B            mov bp, sp
0209   0535             
0210   0535             ; --- BEGIN INLINE ASM BLOCK
0211   0535 17 05 00      mov a, [bp + 5]
0212   0538 3C            mov d, a
0213   0539 07 DA 07      call puts
0214   053C             ; --- END INLINE ASM BLOCK
0215   053C             
0216   053C F9            leave
0217   053D 09            ret
0218   053E             ; --- END TEXT BLOCK
0219   053E             
0220   053E             ; --- BEGIN DATA BLOCK
0221   053E             s1_data: 
0222   053E 48 00 65 00 .dw 'H', 'e', 'l', 'l', 'o', 0,
0222   0542 6C 00 6C 00 
0222   0546 6F 00 00 00 
0223   054A 00 00 00 00 .fill 44, 0
0223   054E 00 00 00 00 
0223   0552 00 00 00 00 
0223   0556 00 00 00 00 
0223   055A 00 00 00 00 
0223   055E 00 00 00 00 
0223   0562 00 00 00 00 
0223   0566 00 00 00 00 
0223   056A 00 00 00 00 
0223   056E 00 00 00 00 
0223   0572 00 00 00 00 
0224   0576 3E 05       s1: .dw s1_data
0225   0578 2E 20 4D 79 s2_data: .db ". My name is Sol-1.", 0
0225   057C 20 6E 61 6D 
0225   0580 65 20 69 73 
0225   0584 20 53 6F 6C 
0225   0588 2D 31 2E 00 
0226   058C 78 05       s2: .dw s2_data
0227   058E             ; --- END DATA BLOCK
0228   058E             
0229   058E             ; --- BEGIN INCLUDE BLOCK
0230   058E             .include "lib/stdio.asm"
0001+  058E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  058E             ; stdio.s
0003+  058E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  058E             .include "lib/string.asm"
0001++ 058E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 058E             ; string.s
0003++ 058E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 058E             
0005++ 058E             
0006++ 058E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 058E             ; strrev
0008++ 058E             ; reverse a string
0009++ 058E             ; D = string address
0010++ 058E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 058E             ; 01234
0012++ 058E             strrev:
0013++ 058E 4B          	pusha
0014++ 058F 07 D5 05    	call strlen	; length in C
0015++ 0592 12          	mov a, c
0016++ 0593 AF 01 00    	cmp a, 1
0017++ 0596 D0 B0 05    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0599 7D          	dec a
0019++ 059A FD 4E       	mov si, d	; beginning of string
0020++ 059C FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 059E 59          	add d, a	; end of string
0022++ 059F 12          	mov a, c
0023++ 05A0 FD 9B       	shr a		; divide by 2
0024++ 05A2 39          	mov c, a	; C now counts the steps
0025++ 05A3             strrev_L0:
0026++ 05A3 32          	mov bl, [d]	; save load right-side char into BL
0027++ 05A4 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 05A5 3E          	mov [d], al	; store left char into right side
0029++ 05A6 1B          	mov al, bl
0030++ 05A7 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 05A8 7E          	dec c
0032++ 05A9 7F          	dec d
0033++ 05AA C2 00 00    	cmp c, 0
0034++ 05AD C7 A3 05    	jne strrev_L0
0035++ 05B0             strrev_end:
0036++ 05B0 4C          	popa
0037++ 05B1 09          	ret
0038++ 05B2             	
0039++ 05B2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 05B2             ; strchr
0041++ 05B2             ; search string in D for char in AL
0042++ 05B2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 05B2             strchr:
0044++ 05B2             strchr_L0:
0045++ 05B2 32          	mov bl, [d]
0046++ 05B3 C1 00       	cmp bl, 0
0047++ 05B5 C6 C0 05    	je strchr_end
0048++ 05B8 BA          	cmp al, bl
0049++ 05B9 C6 C0 05    	je strchr_end
0050++ 05BC 79          	inc d
0051++ 05BD 0A B2 05    	jmp strchr_L0
0052++ 05C0             strchr_end:
0053++ 05C0 1B          	mov al, bl
0054++ 05C1 09          	ret
0055++ 05C2             
0056++ 05C2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 05C2             ; strstr
0058++ 05C2             ; find sub-string
0059++ 05C2             ; str1 in SI
0060++ 05C2             ; str2 in DI
0061++ 05C2             ; SI points to end of source string
0062++ 05C2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 05C2             strstr:
0064++ 05C2 DB          	push al
0065++ 05C3 DA          	push d
0066++ 05C4 E3          	push di
0067++ 05C5             strstr_loop:
0068++ 05C5 F3          	cmpsb					; compare a byte of the strings
0069++ 05C6 C7 D1 05    	jne strstr_ret
0070++ 05C9 FC 00 00    	lea d, [di + 0]
0071++ 05CC BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 05CE C7 C5 05    	jne strstr_loop				; equal chars but not at end
0073++ 05D1             strstr_ret:
0074++ 05D1 F0          	pop di
0075++ 05D2 E7          	pop d
0076++ 05D3 E8          	pop al
0077++ 05D4 09          	ret
0078++ 05D5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 05D5             ; length of null terminated string
0080++ 05D5             ; result in C
0081++ 05D5             ; pointer in D
0082++ 05D5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 05D5             strlen:
0084++ 05D5 DA          	push d
0085++ 05D6 38 00 00    	mov c, 0
0086++ 05D9             strlen_L1:
0087++ 05D9 BD 00       	cmp byte [d], 0
0088++ 05DB C6 E3 05    	je strlen_ret
0089++ 05DE 79          	inc d
0090++ 05DF 78          	inc c
0091++ 05E0 0A D9 05    	jmp strlen_L1
0092++ 05E3             strlen_ret:
0093++ 05E3 E7          	pop d
0094++ 05E4 09          	ret
0095++ 05E5             
0096++ 05E5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 05E5             ; STRCMP
0098++ 05E5             ; compare two strings
0099++ 05E5             ; str1 in SI
0100++ 05E5             ; str2 in DI
0101++ 05E5             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 05E5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 05E5             strcmp:
0104++ 05E5 DB          	push al
0105++ 05E6 DA          	push d
0106++ 05E7 E3          	push di
0107++ 05E8 E2          	push si
0108++ 05E9             strcmp_loop:
0109++ 05E9 F3          	cmpsb					; compare a byte of the strings
0110++ 05EA C7 F5 05    	jne strcmp_ret
0111++ 05ED FB FF FF    	lea d, [si +- 1]
0112++ 05F0 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 05F2 C7 E9 05    	jne strcmp_loop				; equal chars but not at end
0114++ 05F5             strcmp_ret:
0115++ 05F5 EF          	pop si
0116++ 05F6 F0          	pop di
0117++ 05F7 E7          	pop d
0118++ 05F8 E8          	pop al
0119++ 05F9 09          	ret
0120++ 05FA             
0121++ 05FA             
0122++ 05FA             ; STRCPY
0123++ 05FA             ; copy null terminated string from SI to DI
0124++ 05FA             ; source in SI
0125++ 05FA             ; destination in DI
0126++ 05FA             strcpy:
0127++ 05FA E2          	push si
0128++ 05FB E3          	push di
0129++ 05FC DB          	push al
0130++ 05FD             strcpy_L1:
0131++ 05FD F6          	lodsb
0132++ 05FE F7          	stosb
0133++ 05FF B9 00       	cmp al, 0
0134++ 0601 C7 FD 05    	jne strcpy_L1
0135++ 0604             strcpy_end:
0136++ 0604 E8          	pop al
0137++ 0605 F0          	pop di
0138++ 0606 EF          	pop si
0139++ 0607 09          	ret
0140++ 0608             
0141++ 0608             ; STRCAT
0142++ 0608             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0608             ; source in SI
0144++ 0608             ; destination in DI
0145++ 0608             strcat:
0146++ 0608 E2          	push si
0147++ 0609 E3          	push di
0148++ 060A D7          	push a
0149++ 060B DA          	push d
0150++ 060C 50          	mov a, di
0151++ 060D 3C          	mov d, a
0152++ 060E             strcat_goto_end_L1:
0153++ 060E BD 00       	cmp byte[d], 0
0154++ 0610 C6 17 06    	je strcat_start
0155++ 0613 79          	inc d
0156++ 0614 0A 0E 06    	jmp strcat_goto_end_L1
0157++ 0617             strcat_start:
0158++ 0617 FD 50       	mov di, d
0159++ 0619             strcat_L1:
0160++ 0619 F6          	lodsb
0161++ 061A F7          	stosb
0162++ 061B B9 00       	cmp al, 0
0163++ 061D C7 19 06    	jne strcat_L1
0164++ 0620             strcat_end:
0165++ 0620 E7          	pop d
0166++ 0621 E4          	pop a
0167++ 0622 F0          	pop di
0168++ 0623 EF          	pop si
0169++ 0624 09          	ret
0005+  0625             
0006+  0625 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  0629 34 35 36 37 
0006+  062D 38 39 41 42 
0006+  0631 43 44 45 46 
0007+  0635 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  0639 1B 5B 48 00 
0008+  063D             
0009+  063D 01 00       table_power:.dw 1
0010+  063F 0A 00       			.dw 10
0011+  0641 64 00       			.dw 100
0012+  0643 E8 03       			.dw 1000
0013+  0645 10 27       			.dw 10000
0014+  0647             
0015+  0647             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  0647             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  0647             ; ASCII in BL
0018+  0647             ; result in AL
0019+  0647             ; ascii for F = 0100 0110
0020+  0647             ; ascii for 9 = 0011 1001
0021+  0647             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  0647             hex_ascii_encode:
0023+  0647 1B          	mov al, bl
0024+  0648 93 40       	test al, $40				; test if letter or number
0025+  064A C7 50 06    	jnz hex_letter
0026+  064D 87 0F       	and al, $0F				; get number
0027+  064F 09          	ret
0028+  0650             hex_letter:
0029+  0650 87 0F       	and al, $0F				; get letter
0030+  0652 6A 09       	add al, 9
0031+  0654 09          	ret
0032+  0655             
0033+  0655             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  0655             ; ATOI
0035+  0655             ; 2 letter hex string in B
0036+  0655             ; 8bit integer returned in AL
0037+  0655             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0655             atoi:
0039+  0655 D8          	push b
0040+  0656 07 47 06    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  0659 30          	mov bl, bh
0042+  065A DB          	push al					; save a
0043+  065B 07 47 06    	call hex_ascii_encode
0044+  065E EA          	pop bl	
0045+  065F FD 9E 04    	shl al, 4
0046+  0662 8C          	or al, bl
0047+  0663 E5          	pop b
0048+  0664 09          	ret	
0049+  0665             
0050+  0665             
0051+  0665             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  0665             ; printf
0053+  0665             ; no need for explanations!
0054+  0665             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0665             printf:
0056+  0665 09          	ret
0057+  0666             
0058+  0666             
0059+  0666             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  0666             ; scanf
0061+  0666             ; no need for explanations!
0062+  0666             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  0666             scanf:
0064+  0666 09          	ret
0065+  0667             
0066+  0667             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  0667             ; ITOA
0068+  0667             ; 8bit value in BL
0069+  0667             ; 2 byte ASCII result in A
0070+  0667             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  0667             itoa:
0072+  0667 DA          	push d
0073+  0668 D8          	push b
0074+  0669 A7 00       	mov bh, 0
0075+  066B FD A4 04    	shr bl, 4	
0076+  066E 74          	mov d, b
0077+  066F 1F 25 06    	mov al, [d + s_hex_digits]
0078+  0672 23          	mov ah, al
0079+  0673             	
0080+  0673 E5          	pop b
0081+  0674 D8          	push b
0082+  0675 A7 00       	mov bh, 0
0083+  0677 FD 87 0F    	and bl, $0F
0084+  067A 74          	mov d, b
0085+  067B 1F 25 06    	mov al, [d + s_hex_digits]
0086+  067E E5          	pop b
0087+  067F E7          	pop d
0088+  0680 09          	ret
0089+  0681             
0090+  0681             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  0681             ; HEX STRING TO BINARY
0092+  0681             ; di = destination address
0093+  0681             ; si = source
0094+  0681             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  0681             hex_to_int:
0096+  0681             hex_to_int_L1:
0097+  0681 F6          	lodsb					; load from [SI] to AL
0098+  0682 B9 00       	cmp al, 0				; check if ASCII 0
0099+  0684 C6 91 06    	jz hex_to_int_ret
0100+  0687 36          	mov bh, al
0101+  0688 F6          	lodsb
0102+  0689 2F          	mov bl, al
0103+  068A 07 55 06    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  068D F7          	stosb					; store AL to [DI]
0105+  068E 0A 81 06    	jmp hex_to_int_L1
0106+  0691             hex_to_int_ret:
0107+  0691 09          	ret		
0108+  0692             
0109+  0692             
0110+  0692             
0111+  0692             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  0692             ; GETCHAR
0113+  0692             ; char in ah
0114+  0692             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  0692             getchar:
0116+  0692 DB          	push al
0117+  0693             getchar_retry:
0118+  0693 FD 0C       	sti
0119+  0695 19 01       	mov al, 1
0120+  0697 05 03       	syscall sys_io			; receive in AH
0121+  0699 B9 00       	cmp al, 0			; check if any char was receive
0122+  069B C6 93 06    	je getchar_retry
0123+  069E E8          	pop al
0124+  069F 09          	ret
0125+  06A0             
0126+  06A0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  06A0             ; PUTCHAR
0128+  06A0             ; char in ah
0129+  06A0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  06A0             putchar:
0131+  06A0 D7          	push a
0132+  06A1 19 00       	mov al, 0
0133+  06A3 05 03       	syscall sys_io			; char in AH
0134+  06A5 E4          	pop a
0135+  06A6 09          	ret
0136+  06A7             
0137+  06A7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  06A7             ;; INPUT A STRING
0139+  06A7             ;; terminates with null
0140+  06A7             ;; pointer in D
0141+  06A7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  06A7             gets:
0143+  06A7 D7          	push a
0144+  06A8 DA          	push d
0145+  06A9             gets_loop:
0146+  06A9 FD 0C       	sti
0147+  06AB 19 01       	mov al, 1
0148+  06AD 05 03       	syscall sys_io			; receive in AH
0149+  06AF B9 00       	cmp al, 0				; check error code (AL)
0150+  06B1 C6 A9 06    	je gets_loop			; if no char received, retry
0151+  06B4             
0152+  06B4 76 1B       	cmp ah, 27
0153+  06B6 C6 D7 06    	je gets_telnet_escape
0154+  06B9 76 0A       	cmp ah, $0A				; LF
0155+  06BB C6 30 07    	je gets_end
0156+  06BE 76 0D       	cmp ah, $0D				; CR
0157+  06C0 C6 30 07    	je gets_end
0158+  06C3 76 5C       	cmp ah, $5C				; '\\'
0159+  06C5 C6 07 07    	je gets_escape
0160+  06C8             	
0161+  06C8 76 08       	cmp ah, $08			; check for backspace
0162+  06CA C6 D3 06    	je gets_backspace
0163+  06CD             
0164+  06CD 1A          	mov al, ah
0165+  06CE 3E          	mov [d], al
0166+  06CF 79          	inc d
0167+  06D0 0A A9 06    	jmp gets_loop
0168+  06D3             gets_backspace:
0169+  06D3 7F          	dec d
0170+  06D4 0A A9 06    	jmp gets_loop
0171+  06D7             gets_telnet_escape:
0172+  06D7 FD 0C       	sti
0173+  06D9 19 01       	mov al, 1
0174+  06DB 05 03       	syscall sys_io				; receive in AH without echo
0175+  06DD B9 00       	cmp al, 0					; check error code (AL)
0176+  06DF C6 D7 06    	je gets_telnet_escape		; if no char received, retry
0177+  06E2 76 5B       	cmp ah, '['
0178+  06E4 C7 A9 06    	jne gets_loop
0179+  06E7             gets_telnet_escape_phase2:
0180+  06E7 FD 0C       	sti
0181+  06E9 19 01       	mov al, 1
0182+  06EB 05 03       	syscall sys_io					; receive in AH without echo
0183+  06ED B9 00       	cmp al, 0						; check error code (AL)
0184+  06EF C6 E7 06    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  06F2 76 44       	cmp ah, 'D'
0186+  06F4 C6 FF 06    	je gets_left_arrow
0187+  06F7 76 43       	cmp ah, 'C'
0188+  06F9 C6 03 07    	je gets_right_arrow
0189+  06FC 0A A9 06    	jmp gets_loop
0190+  06FF             gets_left_arrow:
0191+  06FF 7F          	dec d
0192+  0700 0A A9 06    	jmp gets_loop
0193+  0703             gets_right_arrow:
0194+  0703 79          	inc d
0195+  0704 0A A9 06    	jmp gets_loop
0196+  0707             gets_escape:
0197+  0707 FD 0C       	sti
0198+  0709 19 01       	mov al, 1
0199+  070B 05 03       	syscall sys_io			; receive in AH
0200+  070D B9 00       	cmp al, 0				; check error code (AL)
0201+  070F C6 07 07    	je gets_escape			; if no char received, retry
0202+  0712 76 6E       	cmp ah, 'n'
0203+  0714 C6 22 07    	je gets_LF
0204+  0717 76 72       	cmp ah, 'r'
0205+  0719 C6 29 07    	je gets_CR
0206+  071C 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  071D 3E          	mov [d], al
0208+  071E 79          	inc d
0209+  071F 0A A9 06    	jmp gets_loop
0210+  0722             gets_LF:
0211+  0722 19 0A       	mov al, $0A
0212+  0724 3E          	mov [d], al
0213+  0725 79          	inc d
0214+  0726 0A A9 06    	jmp gets_loop
0215+  0729             gets_CR:
0216+  0729 19 0D       	mov al, $0D
0217+  072B 3E          	mov [d], al
0218+  072C 79          	inc d
0219+  072D 0A A9 06    	jmp gets_loop
0220+  0730             gets_end:
0221+  0730 19 00       	mov al, 0
0222+  0732 3E          	mov [d], al				; terminate string
0223+  0733 E7          	pop d
0224+  0734 E4          	pop a
0225+  0735 09          	ret
0226+  0736             
0227+  0736             
0228+  0736             
0229+  0736             
0230+  0736             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  0736             ;; INPUT TEXT
0232+  0736             ;; terminated with CTRL+D
0233+  0736             ;; pointer in D
0234+  0736             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  0736             gettxt:
0236+  0736 D7          	push a
0237+  0737 DA          	push d
0238+  0738             gettxt_loop:
0239+  0738 19 01       	mov al, 1
0240+  073A 05 03       	syscall sys_io			; receive in AH
0241+  073C B9 00       	cmp al, 0				; check error code (AL)
0242+  073E C6 38 07    	je gettxt_loop		; if no char received, retry
0243+  0741 76 04       	cmp ah, 4			; EOT
0244+  0743 C6 81 07    	je gettxt_end
0245+  0746 76 08       	cmp ah, $08			; check for backspace
0246+  0748 C6 7D 07    	je gettxt_backspace
0247+  074B 76 5C       	cmp ah, $5C				; '\\'
0248+  074D C6 56 07    	je gettxt_escape
0249+  0750 1A          	mov al, ah
0250+  0751 3E          	mov [d], al
0251+  0752 79          	inc d
0252+  0753 0A 38 07    	jmp gettxt_loop
0253+  0756             gettxt_escape:
0254+  0756 19 01       	mov al, 1
0255+  0758 05 03       	syscall sys_io			; receive in AH
0256+  075A B9 00       	cmp al, 0				; check error code (AL)
0257+  075C C6 56 07    	je gettxt_escape		; if no char received, retry
0258+  075F 76 6E       	cmp ah, 'n'
0259+  0761 C6 6F 07    	je gettxt_LF
0260+  0764 76 72       	cmp ah, 'r'
0261+  0766 C6 76 07    	je gettxt_CR
0262+  0769 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  076A 3E          	mov [d], al
0264+  076B 79          	inc d
0265+  076C 0A 38 07    	jmp gettxt_loop
0266+  076F             gettxt_LF:
0267+  076F 19 0A       	mov al, $0A
0268+  0771 3E          	mov [d], al
0269+  0772 79          	inc d
0270+  0773 0A 38 07    	jmp gettxt_loop
0271+  0776             gettxt_CR:
0272+  0776 19 0D       	mov al, $0D
0273+  0778 3E          	mov [d], al
0274+  0779 79          	inc d
0275+  077A 0A 38 07    	jmp gettxt_loop
0276+  077D             gettxt_backspace:
0277+  077D 7F          	dec d
0278+  077E 0A 38 07    	jmp gettxt_loop
0279+  0781             gettxt_end:
0280+  0781 19 00       	mov al, 0
0281+  0783 3E          	mov [d], al				; terminate string
0282+  0784 E7          	pop d
0283+  0785 E4          	pop a
0284+  0786 09          	ret
0285+  0787             
0286+  0787             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  0787             ; PRINT NEW LINE
0288+  0787             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  0787             printnl:
0290+  0787 D7          	push a
0291+  0788 10 00 0A    	mov a, $0A00
0292+  078B 05 03       	syscall sys_io
0293+  078D 10 00 0D    	mov a, $0D00
0294+  0790 05 03       	syscall sys_io
0295+  0792 E4          	pop a
0296+  0793 09          	ret
0297+  0794             
0298+  0794             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  0794             ; strtoint
0300+  0794             ; 4 digit hex string number in d
0301+  0794             ; integer returned in A
0302+  0794             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  0794             strtointx:
0304+  0794 D8          	push b
0305+  0795 32          	mov bl, [d]
0306+  0796 37          	mov bh, bl
0307+  0797 33 01 00    	mov bl, [d + 1]
0308+  079A 07 55 06    	call atoi				; convert to int in AL
0309+  079D 23          	mov ah, al				; move to AH
0310+  079E 33 02 00    	mov bl, [d + 2]
0311+  07A1 37          	mov bh, bl
0312+  07A2 33 03 00    	mov bl, [d + 3]
0313+  07A5 07 55 06    	call atoi				; convert to int in AL
0314+  07A8 E5          	pop b
0315+  07A9 09          	ret
0316+  07AA             
0317+  07AA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  07AA             ; strtoint
0319+  07AA             ; 5 digit base10 string number in d
0320+  07AA             ; integer returned in A
0321+  07AA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  07AA             strtoint:
0323+  07AA E2          	push si
0324+  07AB D8          	push b
0325+  07AC D9          	push c
0326+  07AD DA          	push d
0327+  07AE 07 D5 05    	call strlen			; get string length in C
0328+  07B1 7E          	dec c
0329+  07B2 FD 4E       	mov si, d
0330+  07B4 12          	mov a, c
0331+  07B5 FD 99       	shl a
0332+  07B7 3B 3D 06    	mov d, table_power
0333+  07BA 59          	add d, a
0334+  07BB 38 00 00    	mov c, 0
0335+  07BE             strtoint_L0:
0336+  07BE F6          	lodsb			; load ASCII to al
0337+  07BF B9 00       	cmp al, 0
0338+  07C1 C6 D4 07    	je strtoint_end
0339+  07C4 6F 30       	sub al, $30		; make into integer
0340+  07C6 22 00       	mov ah, 0
0341+  07C8 2A          	mov b, [d]
0342+  07C9 AC          	mul a, b			; result in B since it fits in 16bits
0343+  07CA 11          	mov a, b
0344+  07CB 28          	mov b, c
0345+  07CC 54          	add a, b
0346+  07CD 39          	mov c, a
0347+  07CE 63 02 00    	sub d, 2
0348+  07D1 0A BE 07    	jmp strtoint_L0
0349+  07D4             strtoint_end:
0350+  07D4 12          	mov a, c
0351+  07D5 E7          	pop d
0352+  07D6 E6          	pop c
0353+  07D7 E5          	pop b
0354+  07D8 EF          	pop si
0355+  07D9 09          	ret
0356+  07DA             
0357+  07DA             
0358+  07DA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  07DA             ; PRINT NULL TERMINATED STRING
0360+  07DA             ; pointer in D
0361+  07DA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  07DA             puts:
0363+  07DA D7          	push a
0364+  07DB DA          	push d
0365+  07DC             puts_L1:
0366+  07DC 1E          	mov al, [d]
0367+  07DD B9 00       	cmp al, 0
0368+  07DF C6 EB 07    	jz puts_END
0369+  07E2 23          	mov ah, al
0370+  07E3 19 00       	mov al, 0
0371+  07E5 05 03       	syscall sys_io
0372+  07E7 79          	inc d
0373+  07E8 0A DC 07    	jmp puts_L1
0374+  07EB             puts_END:
0375+  07EB E7          	pop d
0376+  07EC E4          	pop a
0377+  07ED 09          	ret
0378+  07EE             
0379+  07EE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  07EE             ; PRINT N SIZE STRING
0381+  07EE             ; pointer in D
0382+  07EE             ; size in C
0383+  07EE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  07EE             putsn:
0385+  07EE DB          	push al
0386+  07EF DA          	push d
0387+  07F0 D9          	push c
0388+  07F1             putsn_L0:
0389+  07F1 1E          	mov al, [d]
0390+  07F2 23          	mov ah, al
0391+  07F3 19 00       	mov al, 0
0392+  07F5 05 03       	syscall sys_io
0393+  07F7 79          	inc d
0394+  07F8 7E          	dec c	
0395+  07F9 C2 00 00    	cmp c, 0
0396+  07FC C7 F1 07    	jne putsn_L0
0397+  07FF             putsn_end:
0398+  07FF E6          	pop c
0399+  0800 E7          	pop d
0400+  0801 E8          	pop al
0401+  0802 09          	ret
0402+  0803             
0403+  0803             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  0803             ; print 16bit decimal number
0405+  0803             ; input number in A
0406+  0803             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  0803             print_u16d:
0408+  0803 D7          	push a
0409+  0804 D8          	push b
0410+  0805 26 10 27    	mov b, 10000
0411+  0808 AE          	div a, b			; get 10000 coeff.
0412+  0809 07 2F 08    	call print_number
0413+  080C 11          	mov a, b
0414+  080D 26 E8 03    	mov b, 1000
0415+  0810 AE          	div a, b			; get 10000 coeff.
0416+  0811 07 2F 08    	call print_number
0417+  0814 11          	mov a, b
0418+  0815 26 64 00    	mov b, 100
0419+  0818 AE          	div a, b
0420+  0819 07 2F 08    	call print_number
0421+  081C 11          	mov a, b
0422+  081D 26 0A 00    	mov b, 10
0423+  0820 AE          	div a, b
0424+  0821 07 2F 08    	call print_number
0425+  0824 11          	mov a, b
0426+  0825 6A 30       	add al, $30
0427+  0827 23          	mov ah, al
0428+  0828 19 00       	mov al, 0
0429+  082A 05 03       	syscall sys_io	; print coeff
0430+  082C E5          	pop b
0431+  082D E4          	pop a
0432+  082E 09          	ret
0433+  082F             
0434+  082F             
0435+  082F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  082F             ; if A == 0, print space
0437+  082F             ; else print A
0438+  082F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0439+  082F             print_number:
0440+  082F 6A 30       	add al, $30
0441+  0831 23          	mov ah, al
0442+  0832 07 A0 06    	call putchar
0443+  0835 09          	ret
0444+  0836             
0445+  0836             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0446+  0836             ; PRINT 16BIT HEX INTEGER
0447+  0836             ; integer value in reg B
0448+  0836             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  0836             print_u16x:
0450+  0836 D7          	push a
0451+  0837 D8          	push b
0452+  0838 DD          	push bl
0453+  0839 30          	mov bl, bh
0454+  083A 07 67 06    	call itoa				; convert bh to char in A
0455+  083D 2F          	mov bl, al				; save al
0456+  083E 19 00       	mov al, 0
0457+  0840 05 03       	syscall sys_io				; display AH
0458+  0842 24          	mov ah, bl				; retrieve al
0459+  0843 19 00       	mov al, 0
0460+  0845 05 03       	syscall sys_io				; display AL
0461+  0847             
0462+  0847 EA          	pop bl
0463+  0848 07 67 06    	call itoa				; convert bh to char in A
0464+  084B 2F          	mov bl, al				; save al
0465+  084C 19 00       	mov al, 0
0466+  084E 05 03       	syscall sys_io				; display AH
0467+  0850 24          	mov ah, bl				; retrieve al
0468+  0851 19 00       	mov al, 0
0469+  0853 05 03       	syscall sys_io				; display AL
0470+  0855             
0471+  0855 E5          	pop b
0472+  0856 E4          	pop a
0473+  0857 09          	ret
0474+  0858             
0475+  0858             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  0858             ; INPUT 16BIT HEX INTEGER
0477+  0858             ; read 16bit integer into A
0478+  0858             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  0858             scan_u16x:
0480+  0858 F8 10 00    	enter 16
0481+  085B D8          	push b
0482+  085C DA          	push d
0483+  085D             
0484+  085D FA F1 FF    	lea d, [bp + -15]
0485+  0860 07 A7 06    	call gets				; get number
0486+  0863             
0487+  0863 32          	mov bl, [d]
0488+  0864 37          	mov bh, bl
0489+  0865 33 01 00    	mov bl, [d + 1]
0490+  0868 07 55 06    	call atoi				; convert to int in AL
0491+  086B 23          	mov ah, al				; move to AH
0492+  086C             
0493+  086C 33 02 00    	mov bl, [d + 2]
0494+  086F 37          	mov bh, bl
0495+  0870 33 03 00    	mov bl, [d + 3]
0496+  0873 07 55 06    	call atoi				; convert to int in AL
0497+  0876             
0498+  0876 E7          	pop d
0499+  0877 E5          	pop b
0500+  0878 F9          	leave
0501+  0879 09          	ret
0502+  087A             
0503+  087A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0504+  087A             ; PRINT 8bit HEX INTEGER
0505+  087A             ; integer value in reg bl
0506+  087A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  087A             print_u8x:
0508+  087A D7          	push a
0509+  087B DD          	push bl
0510+  087C             
0511+  087C 07 67 06    	call itoa				; convert bl to char in A
0512+  087F 2F          	mov bl, al				; save al
0513+  0880 19 00       	mov al, 0
0514+  0882 05 03       	syscall sys_io				; display AH
0515+  0884 24          	mov ah, bl				; retrieve al
0516+  0885 19 00       	mov al, 0
0517+  0887 05 03       	syscall sys_io				; display AL
0518+  0889             
0519+  0889 EA          	pop bl
0520+  088A E4          	pop a
0521+  088B 09          	ret
0522+  088C             
0523+  088C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0524+  088C             ; print 8bit decimal unsigned number
0525+  088C             ; input number in AL
0526+  088C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  088C             print_u8d:
0528+  088C D7          	push a
0529+  088D D8          	push b
0530+  088E             
0531+  088E 22 00       	mov ah, 0
0532+  0890 26 64 00    	mov b, 100
0533+  0893 AE          	div a, b
0534+  0894 D8          	push b			; save remainder
0535+  0895 B9 00       	cmp al, 0
0536+  0897 C6 A1 08    	je skip100
0537+  089A 6A 30       	add al, $30
0538+  089C 23          	mov ah, al
0539+  089D 19 00       	mov al, 0
0540+  089F 05 03       	syscall sys_io	; print coeff
0541+  08A1             skip100:
0542+  08A1 E4          	pop a
0543+  08A2 22 00       	mov ah, 0
0544+  08A4 26 0A 00    	mov b, 10
0545+  08A7 AE          	div a, b
0546+  08A8 D8          	push b			; save remainder
0547+  08A9 B9 00       	cmp al, 0
0548+  08AB C6 B5 08    	je skip10
0549+  08AE 6A 30       	add al, $30
0550+  08B0 23          	mov ah, al
0551+  08B1 19 00       	mov al, 0
0552+  08B3 05 03       	syscall sys_io	; print coeff
0553+  08B5             skip10:
0554+  08B5 E4          	pop a
0555+  08B6 1B          	mov al, bl
0556+  08B7 6A 30       	add al, $30
0557+  08B9 23          	mov ah, al
0558+  08BA 19 00       	mov al, 0
0559+  08BC 05 03       	syscall sys_io	; print coeff
0560+  08BE E5          	pop b
0561+  08BF E4          	pop a
0562+  08C0 09          	ret
0563+  08C1             
0564+  08C1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0565+  08C1             ; INPUT 8BIT HEX INTEGER
0566+  08C1             ; read 8bit integer into AL
0567+  08C1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  08C1             scan_u8x:
0569+  08C1 F8 04 00    	enter 4
0570+  08C4 D8          	push b
0571+  08C5 DA          	push d
0572+  08C6             
0573+  08C6 FA FD FF    	lea d, [bp + -3]
0574+  08C9 07 A7 06    	call gets				; get number
0575+  08CC             
0576+  08CC 32          	mov bl, [d]
0577+  08CD 37          	mov bh, bl
0578+  08CE 33 01 00    	mov bl, [d + 1]
0579+  08D1 07 55 06    	call atoi				; convert to int in AL
0580+  08D4             
0581+  08D4 E7          	pop d
0582+  08D5 E5          	pop b
0583+  08D6 F9          	leave
0584+  08D7 09          	ret
0585+  08D8             
0586+  08D8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  08D8             ; input decimal number
0588+  08D8             ; result in A
0589+  08D8             ; 655'\0'
0590+  08D8             ; low--------high
0591+  08D8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0592+  08D8             scan_u16d:
0593+  08D8 F8 08 00    	enter 8
0594+  08DB E2          	push si
0595+  08DC D8          	push b
0596+  08DD D9          	push c
0597+  08DE DA          	push d
0598+  08DF FA F9 FF    	lea d, [bp +- 7]
0599+  08E2 07 A7 06    	call gets
0600+  08E5 07 D5 05    	call strlen			; get string length in C
0601+  08E8 7E          	dec c
0602+  08E9 FD 4E       	mov si, d
0603+  08EB 12          	mov a, c
0604+  08EC FD 99       	shl a
0605+  08EE 3B 3D 06    	mov d, table_power
0606+  08F1 59          	add d, a
0607+  08F2 38 00 00    	mov c, 0
0608+  08F5             mul_loop:
0609+  08F5 F6          	lodsb			; load ASCII to al
0610+  08F6 B9 00       	cmp al, 0
0611+  08F8 C6 0B 09    	je mul_exit
0612+  08FB 6F 30       	sub al, $30		; make into integer
0613+  08FD 22 00       	mov ah, 0
0614+  08FF 2A          	mov b, [d]
0615+  0900 AC          	mul a, b			; result in B since it fits in 16bits
0616+  0901 11          	mov a, b
0617+  0902 28          	mov b, c
0618+  0903 54          	add a, b
0619+  0904 39          	mov c, a
0620+  0905 63 02 00    	sub d, 2
0621+  0908 0A F5 08    	jmp mul_loop
0622+  090B             mul_exit:
0623+  090B 12          	mov a, c
0624+  090C E7          	pop d
0625+  090D E6          	pop c
0626+  090E E5          	pop b
0627+  090F EF          	pop si
0628+  0910 F9          	leave
0629+  0911 09          	ret
0231   0912             ; --- END INCLUDE BLOCK
0232   0912             
0233   0912             
0234   0912             .end
tasm: Number of errors = 0
