0001   0000             ; --- FILENAME: test.c
0002   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0400             .org PROC_TEXT_ORG
0004   0400             
0005   0400             ; --- BEGIN TEXT BLOCK
0006   0400             
0007   0400             main:
0008   0400 D2            push bp
0009   0401 9B            mov bp, sp
0010   0402 52 02 00      sub sp, 2 ; a
0011   0405 52 02 00      sub sp, 2 ; b
0012   0408 52 02 00      sub sp, 2 ; c
0013   040B 26 01 00      mov b, 1
0014   040E D7            push a
0015   040F 11            mov a, b
0016   0410 45 FF FF      mov [bp + -1], a ; a
0017   0413 E4            pop a
0018   0414 26 64 00      mov b, 100
0019   0417 D7            push a
0020   0418 11            mov a, b
0021   0419 45 FD FF      mov [bp + -3], a ; b
0022   041C E4            pop a
0023   041D 2C FD FF      mov b, [bp + -3] ; b
0024   0420 D7            push a
0025   0421 11            mov a, b
0026   0422 2C FF FF      mov b, [bp + -1] ; a
0027   0425 D7            push a
0028   0426 11            mov a, b
0029   0427 26 0A 00      mov b, 10
0030   042A AC            mul a, b
0031   042B E4            pop a
0032   042C 60            sub a, b
0033   042D 27            mov b, a
0034   042E E4            pop a
0035   042F D7            push a
0036   0430 11            mov a, b
0037   0431 45 FB FF      mov [bp + -5], a ; c
0038   0434 E4            pop a
0039   0435 2C FB FF      mov b, [bp + -5] ; c
0040   0438 FD AB         swp b
0041   043A D8            push b
0042   043B 07 5C 04      call printn
0043   043E 51 02 00      add sp, 2
0044   0441 F9            leave
0045   0442 05 0B         syscall sys_terminate_proc
0046   0444             
0047   0444             scann:
0048   0444 D2            push bp
0049   0445 9B            mov bp, sp
0050   0446 52 02 00      sub sp, 2 ; m
0051   0449             
0052   0449             ; --- BEGIN INLINE ASM BLOCK
0053   0449 07 E7 07      call scan_u16d
0054   044C 45 FF FF      mov [bp + -1], a
0055   044F             ; --- END INLINE ASM BLOCK
0056   044F             
0057   044F FA 05 00      lea d, [bp + 5] ; n
0058   0452 2A            mov b, [d]
0059   0453 D8            push b
0060   0454 2C FF FF      mov b, [bp + -1] ; m
0061   0457 E7            pop d
0062   0458 11            mov a, b
0063   0459 43            mov [d], a
0064   045A F9            leave
0065   045B 09            ret
0066   045C             
0067   045C             printn:
0068   045C D2            push bp
0069   045D 9B            mov bp, sp
0070   045E             
0071   045E             ; --- BEGIN INLINE ASM BLOCK
0072   045E 17 05 00      mov a, [bp + 5]
0073   0461 07 12 07      call print_u16d
0074   0464             ; --- END INLINE ASM BLOCK
0075   0464             
0076   0464 F9            leave
0077   0465 09            ret
0078   0466             
0079   0466             print:
0080   0466 D2            push bp
0081   0467 9B            mov bp, sp
0082   0468             
0083   0468             ; --- BEGIN INLINE ASM BLOCK
0084   0468 17 05 00      mov a, [bp + 5]
0085   046B 3C            mov d, a
0086   046C 07 E9 06      call puts
0087   046F             ; --- END INLINE ASM BLOCK
0088   046F             
0089   046F F9            leave
0090   0470 09            ret
0091   0471             ; --- END TEXT BLOCK
0092   0471             
0093   0471             ; --- BEGIN DATA BLOCK
0094   0471             __aarr_data: 
0095   0471 01 00 01 00 .dw 1,1,1,1,1,1,1,1,1,1,
0095   0475 01 00 01 00 
0095   0479 01 00 01 00 
0095   047D 01 00 01 00 
0095   0481 01 00 01 00 
0096   0485             .fill 0, 0
0097   0485 71 04       __aarr: .dw __aarr_data
0098   0487             __barr_data: 
0099   0487 02 00 02 00 .dw 2,2,2,2,2,2,2,2,2,2,
0099   048B 02 00 02 00 
0099   048F 02 00 02 00 
0099   0493 02 00 02 00 
0099   0497 02 00 02 00 
0100   049B             .fill 0, 0
0101   049B 87 04       __barr: .dw __barr_data
0102   049D             ; --- END DATA BLOCK
0103   049D             
0104   049D             ; --- BEGIN INCLUDE BLOCK
0105   049D             .include "lib/stdio.asm"
0001+  049D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  049D             ; stdio.s
0003+  049D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  049D             .include "lib/string.asm"
0001++ 049D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 049D             ; string.s
0003++ 049D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 049D             
0005++ 049D             
0006++ 049D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 049D             ; strrev
0008++ 049D             ; reverse a string
0009++ 049D             ; D = string address
0010++ 049D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 049D             ; 01234
0012++ 049D             strrev:
0013++ 049D 4B          	pusha
0014++ 049E 07 E4 04    	call strlen	; length in C
0015++ 04A1 12          	mov a, c
0016++ 04A2 AF 01 00    	cmp a, 1
0017++ 04A5 D0 BF 04    	jleu strrev_end	; check string length. string len must be > 1
0018++ 04A8 7D          	dec a
0019++ 04A9 FD 4E       	mov si, d	; beginning of string
0020++ 04AB FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 04AD 59          	add d, a	; end of string
0022++ 04AE 12          	mov a, c
0023++ 04AF FD 9B       	shr a		; divide by 2
0024++ 04B1 39          	mov c, a	; C now counts the steps
0025++ 04B2             strrev_L0:
0026++ 04B2 32          	mov bl, [d]	; save load right-side char into BL
0027++ 04B3 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 04B4 3E          	mov [d], al	; store left char into right side
0029++ 04B5 1B          	mov al, bl
0030++ 04B6 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 04B7 7E          	dec c
0032++ 04B8 7F          	dec d
0033++ 04B9 C2 00 00    	cmp c, 0
0034++ 04BC C7 B2 04    	jne strrev_L0
0035++ 04BF             strrev_end:
0036++ 04BF 4C          	popa
0037++ 04C0 09          	ret
0038++ 04C1             	
0039++ 04C1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 04C1             ; strchr
0041++ 04C1             ; search string in D for char in AL
0042++ 04C1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 04C1             strchr:
0044++ 04C1             strchr_L0:
0045++ 04C1 32          	mov bl, [d]
0046++ 04C2 C1 00       	cmp bl, 0
0047++ 04C4 C6 CF 04    	je strchr_end
0048++ 04C7 BA          	cmp al, bl
0049++ 04C8 C6 CF 04    	je strchr_end
0050++ 04CB 79          	inc d
0051++ 04CC 0A C1 04    	jmp strchr_L0
0052++ 04CF             strchr_end:
0053++ 04CF 1B          	mov al, bl
0054++ 04D0 09          	ret
0055++ 04D1             
0056++ 04D1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 04D1             ; strstr
0058++ 04D1             ; find sub-string
0059++ 04D1             ; str1 in SI
0060++ 04D1             ; str2 in DI
0061++ 04D1             ; SI points to end of source string
0062++ 04D1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 04D1             strstr:
0064++ 04D1 DB          	push al
0065++ 04D2 DA          	push d
0066++ 04D3 E3          	push di
0067++ 04D4             strstr_loop:
0068++ 04D4 F3          	cmpsb					; compare a byte of the strings
0069++ 04D5 C7 E0 04    	jne strstr_ret
0070++ 04D8 FC 00 00    	lea d, [di + 0]
0071++ 04DB BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 04DD C7 D4 04    	jne strstr_loop				; equal chars but not at end
0073++ 04E0             strstr_ret:
0074++ 04E0 F0          	pop di
0075++ 04E1 E7          	pop d
0076++ 04E2 E8          	pop al
0077++ 04E3 09          	ret
0078++ 04E4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 04E4             ; length of null terminated string
0080++ 04E4             ; result in C
0081++ 04E4             ; pointer in D
0082++ 04E4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 04E4             strlen:
0084++ 04E4 DA          	push d
0085++ 04E5 38 00 00    	mov c, 0
0086++ 04E8             strlen_L1:
0087++ 04E8 BD 00       	cmp byte [d], 0
0088++ 04EA C6 F2 04    	je strlen_ret
0089++ 04ED 79          	inc d
0090++ 04EE 78          	inc c
0091++ 04EF 0A E8 04    	jmp strlen_L1
0092++ 04F2             strlen_ret:
0093++ 04F2 E7          	pop d
0094++ 04F3 09          	ret
0095++ 04F4             
0096++ 04F4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 04F4             ; STRCMP
0098++ 04F4             ; compare two strings
0099++ 04F4             ; str1 in SI
0100++ 04F4             ; str2 in DI
0101++ 04F4             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 04F4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 04F4             strcmp:
0104++ 04F4 DB          	push al
0105++ 04F5 DA          	push d
0106++ 04F6 E3          	push di
0107++ 04F7 E2          	push si
0108++ 04F8             strcmp_loop:
0109++ 04F8 F3          	cmpsb					; compare a byte of the strings
0110++ 04F9 C7 04 05    	jne strcmp_ret
0111++ 04FC FB FF FF    	lea d, [si +- 1]
0112++ 04FF BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0501 C7 F8 04    	jne strcmp_loop				; equal chars but not at end
0114++ 0504             strcmp_ret:
0115++ 0504 EF          	pop si
0116++ 0505 F0          	pop di
0117++ 0506 E7          	pop d
0118++ 0507 E8          	pop al
0119++ 0508 09          	ret
0120++ 0509             
0121++ 0509             
0122++ 0509             ; STRCPY
0123++ 0509             ; copy null terminated string from SI to DI
0124++ 0509             ; source in SI
0125++ 0509             ; destination in DI
0126++ 0509             strcpy:
0127++ 0509 E2          	push si
0128++ 050A E3          	push di
0129++ 050B DB          	push al
0130++ 050C             strcpy_L1:
0131++ 050C F6          	lodsb
0132++ 050D F7          	stosb
0133++ 050E B9 00       	cmp al, 0
0134++ 0510 C7 0C 05    	jne strcpy_L1
0135++ 0513             strcpy_end:
0136++ 0513 E8          	pop al
0137++ 0514 F0          	pop di
0138++ 0515 EF          	pop si
0139++ 0516 09          	ret
0140++ 0517             
0141++ 0517             ; STRCAT
0142++ 0517             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0517             ; source in SI
0144++ 0517             ; destination in DI
0145++ 0517             strcat:
0146++ 0517 E2          	push si
0147++ 0518 E3          	push di
0148++ 0519 D7          	push a
0149++ 051A DA          	push d
0150++ 051B 50          	mov a, di
0151++ 051C 3C          	mov d, a
0152++ 051D             strcat_goto_end_L1:
0153++ 051D BD 00       	cmp byte[d], 0
0154++ 051F C6 26 05    	je strcat_start
0155++ 0522 79          	inc d
0156++ 0523 0A 1D 05    	jmp strcat_goto_end_L1
0157++ 0526             strcat_start:
0158++ 0526 FD 50       	mov di, d
0159++ 0528             strcat_L1:
0160++ 0528 F6          	lodsb
0161++ 0529 F7          	stosb
0162++ 052A B9 00       	cmp al, 0
0163++ 052C C7 28 05    	jne strcat_L1
0164++ 052F             strcat_end:
0165++ 052F E7          	pop d
0166++ 0530 E4          	pop a
0167++ 0531 F0          	pop di
0168++ 0532 EF          	pop si
0169++ 0533 09          	ret
0005+  0534             
0006+  0534 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  0538 34 35 36 37 
0006+  053C 38 39 41 42 
0006+  0540 43 44 45 46 
0007+  0544 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  0548 1B 5B 48 00 
0008+  054C             
0009+  054C 01 00       table_power:.dw 1
0010+  054E 0A 00       			.dw 10
0011+  0550 64 00       			.dw 100
0012+  0552 E8 03       			.dw 1000
0013+  0554 10 27       			.dw 10000
0014+  0556             
0015+  0556             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  0556             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  0556             ; ASCII in BL
0018+  0556             ; result in AL
0019+  0556             ; ascii for F = 0100 0110
0020+  0556             ; ascii for 9 = 0011 1001
0021+  0556             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  0556             hex_ascii_encode:
0023+  0556 1B          	mov al, bl
0024+  0557 93 40       	test al, $40				; test if letter or number
0025+  0559 C7 5F 05    	jnz hex_letter
0026+  055C 87 0F       	and al, $0F				; get number
0027+  055E 09          	ret
0028+  055F             hex_letter:
0029+  055F 87 0F       	and al, $0F				; get letter
0030+  0561 6A 09       	add al, 9
0031+  0563 09          	ret
0032+  0564             
0033+  0564             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  0564             ; ATOI
0035+  0564             ; 2 letter hex string in B
0036+  0564             ; 8bit integer returned in AL
0037+  0564             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0564             atoi:
0039+  0564 D8          	push b
0040+  0565 07 56 05    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  0568 30          	mov bl, bh
0042+  0569 DB          	push al					; save a
0043+  056A 07 56 05    	call hex_ascii_encode
0044+  056D EA          	pop bl	
0045+  056E FD 9E 04    	shl al, 4
0046+  0571 8C          	or al, bl
0047+  0572 E5          	pop b
0048+  0573 09          	ret	
0049+  0574             
0050+  0574             
0051+  0574             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  0574             ; printf
0053+  0574             ; no need for explanations!
0054+  0574             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0574             printf:
0056+  0574 09          	ret
0057+  0575             
0058+  0575             
0059+  0575             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  0575             ; scanf
0061+  0575             ; no need for explanations!
0062+  0575             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  0575             scanf:
0064+  0575 09          	ret
0065+  0576             
0066+  0576             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  0576             ; ITOA
0068+  0576             ; 8bit value in BL
0069+  0576             ; 2 byte ASCII result in A
0070+  0576             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  0576             itoa:
0072+  0576 DA          	push d
0073+  0577 D8          	push b
0074+  0578 A7 00       	mov bh, 0
0075+  057A FD A4 04    	shr bl, 4	
0076+  057D 74          	mov d, b
0077+  057E 1F 34 05    	mov al, [d + s_hex_digits]
0078+  0581 23          	mov ah, al
0079+  0582             	
0080+  0582 E5          	pop b
0081+  0583 D8          	push b
0082+  0584 A7 00       	mov bh, 0
0083+  0586 FD 87 0F    	and bl, $0F
0084+  0589 74          	mov d, b
0085+  058A 1F 34 05    	mov al, [d + s_hex_digits]
0086+  058D E5          	pop b
0087+  058E E7          	pop d
0088+  058F 09          	ret
0089+  0590             
0090+  0590             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  0590             ; HEX STRING TO BINARY
0092+  0590             ; di = destination address
0093+  0590             ; si = source
0094+  0590             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  0590             hex_to_int:
0096+  0590             hex_to_int_L1:
0097+  0590 F6          	lodsb					; load from [SI] to AL
0098+  0591 B9 00       	cmp al, 0				; check if ASCII 0
0099+  0593 C6 A0 05    	jz hex_to_int_ret
0100+  0596 36          	mov bh, al
0101+  0597 F6          	lodsb
0102+  0598 2F          	mov bl, al
0103+  0599 07 64 05    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  059C F7          	stosb					; store AL to [DI]
0105+  059D 0A 90 05    	jmp hex_to_int_L1
0106+  05A0             hex_to_int_ret:
0107+  05A0 09          	ret		
0108+  05A1             
0109+  05A1             
0110+  05A1             
0111+  05A1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  05A1             ; GETCHAR
0113+  05A1             ; char in ah
0114+  05A1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  05A1             getchar:
0116+  05A1 DB          	push al
0117+  05A2             getchar_retry:
0118+  05A2 FD 0C       	sti
0119+  05A4 19 01       	mov al, 1
0120+  05A6 05 03       	syscall sys_io			; receive in AH
0121+  05A8 B9 00       	cmp al, 0			; check if any char was receive
0122+  05AA C6 A2 05    	je getchar_retry
0123+  05AD E8          	pop al
0124+  05AE 09          	ret
0125+  05AF             
0126+  05AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  05AF             ; PUTCHAR
0128+  05AF             ; char in ah
0129+  05AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  05AF             putchar:
0131+  05AF D7          	push a
0132+  05B0 19 00       	mov al, 0
0133+  05B2 05 03       	syscall sys_io			; char in AH
0134+  05B4 E4          	pop a
0135+  05B5 09          	ret
0136+  05B6             
0137+  05B6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  05B6             ;; INPUT A STRING
0139+  05B6             ;; terminates with null
0140+  05B6             ;; pointer in D
0141+  05B6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  05B6             gets:
0143+  05B6 D7          	push a
0144+  05B7 DA          	push d
0145+  05B8             gets_loop:
0146+  05B8 FD 0C       	sti
0147+  05BA 19 01       	mov al, 1
0148+  05BC 05 03       	syscall sys_io			; receive in AH
0149+  05BE B9 00       	cmp al, 0				; check error code (AL)
0150+  05C0 C6 B8 05    	je gets_loop			; if no char received, retry
0151+  05C3             
0152+  05C3 76 1B       	cmp ah, 27
0153+  05C5 C6 E6 05    	je gets_telnet_escape
0154+  05C8 76 0A       	cmp ah, $0A				; LF
0155+  05CA C6 3F 06    	je gets_end
0156+  05CD 76 0D       	cmp ah, $0D				; CR
0157+  05CF C6 3F 06    	je gets_end
0158+  05D2 76 5C       	cmp ah, $5C				; '\\'
0159+  05D4 C6 16 06    	je gets_escape
0160+  05D7             	
0161+  05D7 76 08       	cmp ah, $08			; check for backspace
0162+  05D9 C6 E2 05    	je gets_backspace
0163+  05DC             
0164+  05DC 1A          	mov al, ah
0165+  05DD 3E          	mov [d], al
0166+  05DE 79          	inc d
0167+  05DF 0A B8 05    	jmp gets_loop
0168+  05E2             gets_backspace:
0169+  05E2 7F          	dec d
0170+  05E3 0A B8 05    	jmp gets_loop
0171+  05E6             gets_telnet_escape:
0172+  05E6 FD 0C       	sti
0173+  05E8 19 01       	mov al, 1
0174+  05EA 05 03       	syscall sys_io				; receive in AH without echo
0175+  05EC B9 00       	cmp al, 0					; check error code (AL)
0176+  05EE C6 E6 05    	je gets_telnet_escape		; if no char received, retry
0177+  05F1 76 5B       	cmp ah, '['
0178+  05F3 C7 B8 05    	jne gets_loop
0179+  05F6             gets_telnet_escape_phase2:
0180+  05F6 FD 0C       	sti
0181+  05F8 19 01       	mov al, 1
0182+  05FA 05 03       	syscall sys_io					; receive in AH without echo
0183+  05FC B9 00       	cmp al, 0						; check error code (AL)
0184+  05FE C6 F6 05    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  0601 76 44       	cmp ah, 'D'
0186+  0603 C6 0E 06    	je gets_left_arrow
0187+  0606 76 43       	cmp ah, 'C'
0188+  0608 C6 12 06    	je gets_right_arrow
0189+  060B 0A B8 05    	jmp gets_loop
0190+  060E             gets_left_arrow:
0191+  060E 7F          	dec d
0192+  060F 0A B8 05    	jmp gets_loop
0193+  0612             gets_right_arrow:
0194+  0612 79          	inc d
0195+  0613 0A B8 05    	jmp gets_loop
0196+  0616             gets_escape:
0197+  0616 FD 0C       	sti
0198+  0618 19 01       	mov al, 1
0199+  061A 05 03       	syscall sys_io			; receive in AH
0200+  061C B9 00       	cmp al, 0				; check error code (AL)
0201+  061E C6 16 06    	je gets_escape			; if no char received, retry
0202+  0621 76 6E       	cmp ah, 'n'
0203+  0623 C6 31 06    	je gets_LF
0204+  0626 76 72       	cmp ah, 'r'
0205+  0628 C6 38 06    	je gets_CR
0206+  062B 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  062C 3E          	mov [d], al
0208+  062D 79          	inc d
0209+  062E 0A B8 05    	jmp gets_loop
0210+  0631             gets_LF:
0211+  0631 19 0A       	mov al, $0A
0212+  0633 3E          	mov [d], al
0213+  0634 79          	inc d
0214+  0635 0A B8 05    	jmp gets_loop
0215+  0638             gets_CR:
0216+  0638 19 0D       	mov al, $0D
0217+  063A 3E          	mov [d], al
0218+  063B 79          	inc d
0219+  063C 0A B8 05    	jmp gets_loop
0220+  063F             gets_end:
0221+  063F 19 00       	mov al, 0
0222+  0641 3E          	mov [d], al				; terminate string
0223+  0642 E7          	pop d
0224+  0643 E4          	pop a
0225+  0644 09          	ret
0226+  0645             
0227+  0645             
0228+  0645             
0229+  0645             
0230+  0645             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  0645             ;; INPUT TEXT
0232+  0645             ;; terminated with CTRL+D
0233+  0645             ;; pointer in D
0234+  0645             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  0645             gettxt:
0236+  0645 D7          	push a
0237+  0646 DA          	push d
0238+  0647             gettxt_loop:
0239+  0647 19 01       	mov al, 1
0240+  0649 05 03       	syscall sys_io			; receive in AH
0241+  064B B9 00       	cmp al, 0				; check error code (AL)
0242+  064D C6 47 06    	je gettxt_loop		; if no char received, retry
0243+  0650 76 04       	cmp ah, 4			; EOT
0244+  0652 C6 90 06    	je gettxt_end
0245+  0655 76 08       	cmp ah, $08			; check for backspace
0246+  0657 C6 8C 06    	je gettxt_backspace
0247+  065A 76 5C       	cmp ah, $5C				; '\\'
0248+  065C C6 65 06    	je gettxt_escape
0249+  065F 1A          	mov al, ah
0250+  0660 3E          	mov [d], al
0251+  0661 79          	inc d
0252+  0662 0A 47 06    	jmp gettxt_loop
0253+  0665             gettxt_escape:
0254+  0665 19 01       	mov al, 1
0255+  0667 05 03       	syscall sys_io			; receive in AH
0256+  0669 B9 00       	cmp al, 0				; check error code (AL)
0257+  066B C6 65 06    	je gettxt_escape		; if no char received, retry
0258+  066E 76 6E       	cmp ah, 'n'
0259+  0670 C6 7E 06    	je gettxt_LF
0260+  0673 76 72       	cmp ah, 'r'
0261+  0675 C6 85 06    	je gettxt_CR
0262+  0678 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  0679 3E          	mov [d], al
0264+  067A 79          	inc d
0265+  067B 0A 47 06    	jmp gettxt_loop
0266+  067E             gettxt_LF:
0267+  067E 19 0A       	mov al, $0A
0268+  0680 3E          	mov [d], al
0269+  0681 79          	inc d
0270+  0682 0A 47 06    	jmp gettxt_loop
0271+  0685             gettxt_CR:
0272+  0685 19 0D       	mov al, $0D
0273+  0687 3E          	mov [d], al
0274+  0688 79          	inc d
0275+  0689 0A 47 06    	jmp gettxt_loop
0276+  068C             gettxt_backspace:
0277+  068C 7F          	dec d
0278+  068D 0A 47 06    	jmp gettxt_loop
0279+  0690             gettxt_end:
0280+  0690 19 00       	mov al, 0
0281+  0692 3E          	mov [d], al				; terminate string
0282+  0693 E7          	pop d
0283+  0694 E4          	pop a
0284+  0695 09          	ret
0285+  0696             
0286+  0696             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  0696             ; PRINT NEW LINE
0288+  0696             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  0696             printnl:
0290+  0696 D7          	push a
0291+  0697 10 00 0A    	mov a, $0A00
0292+  069A 05 03       	syscall sys_io
0293+  069C 10 00 0D    	mov a, $0D00
0294+  069F 05 03       	syscall sys_io
0295+  06A1 E4          	pop a
0296+  06A2 09          	ret
0297+  06A3             
0298+  06A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  06A3             ; strtoint
0300+  06A3             ; 4 digit hex string number in d
0301+  06A3             ; integer returned in A
0302+  06A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  06A3             strtointx:
0304+  06A3 D8          	push b
0305+  06A4 32          	mov bl, [d]
0306+  06A5 37          	mov bh, bl
0307+  06A6 33 01 00    	mov bl, [d + 1]
0308+  06A9 07 64 05    	call atoi				; convert to int in AL
0309+  06AC 23          	mov ah, al				; move to AH
0310+  06AD 33 02 00    	mov bl, [d + 2]
0311+  06B0 37          	mov bh, bl
0312+  06B1 33 03 00    	mov bl, [d + 3]
0313+  06B4 07 64 05    	call atoi				; convert to int in AL
0314+  06B7 E5          	pop b
0315+  06B8 09          	ret
0316+  06B9             
0317+  06B9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  06B9             ; strtoint
0319+  06B9             ; 5 digit base10 string number in d
0320+  06B9             ; integer returned in A
0321+  06B9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  06B9             strtoint:
0323+  06B9 E2          	push si
0324+  06BA D8          	push b
0325+  06BB D9          	push c
0326+  06BC DA          	push d
0327+  06BD 07 E4 04    	call strlen			; get string length in C
0328+  06C0 7E          	dec c
0329+  06C1 FD 4E       	mov si, d
0330+  06C3 12          	mov a, c
0331+  06C4 FD 99       	shl a
0332+  06C6 3B 4C 05    	mov d, table_power
0333+  06C9 59          	add d, a
0334+  06CA 38 00 00    	mov c, 0
0335+  06CD             strtoint_L0:
0336+  06CD F6          	lodsb			; load ASCII to al
0337+  06CE B9 00       	cmp al, 0
0338+  06D0 C6 E3 06    	je strtoint_end
0339+  06D3 6F 30       	sub al, $30		; make into integer
0340+  06D5 22 00       	mov ah, 0
0341+  06D7 2A          	mov b, [d]
0342+  06D8 AC          	mul a, b			; result in B since it fits in 16bits
0343+  06D9 11          	mov a, b
0344+  06DA 28          	mov b, c
0345+  06DB 54          	add a, b
0346+  06DC 39          	mov c, a
0347+  06DD 63 02 00    	sub d, 2
0348+  06E0 0A CD 06    	jmp strtoint_L0
0349+  06E3             strtoint_end:
0350+  06E3 12          	mov a, c
0351+  06E4 E7          	pop d
0352+  06E5 E6          	pop c
0353+  06E6 E5          	pop b
0354+  06E7 EF          	pop si
0355+  06E8 09          	ret
0356+  06E9             
0357+  06E9             
0358+  06E9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  06E9             ; PRINT NULL TERMINATED STRING
0360+  06E9             ; pointer in D
0361+  06E9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  06E9             puts:
0363+  06E9 D7          	push a
0364+  06EA DA          	push d
0365+  06EB             puts_L1:
0366+  06EB 1E          	mov al, [d]
0367+  06EC B9 00       	cmp al, 0
0368+  06EE C6 FA 06    	jz puts_END
0369+  06F1 23          	mov ah, al
0370+  06F2 19 00       	mov al, 0
0371+  06F4 05 03       	syscall sys_io
0372+  06F6 79          	inc d
0373+  06F7 0A EB 06    	jmp puts_L1
0374+  06FA             puts_END:
0375+  06FA E7          	pop d
0376+  06FB E4          	pop a
0377+  06FC 09          	ret
0378+  06FD             
0379+  06FD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  06FD             ; PRINT N SIZE STRING
0381+  06FD             ; pointer in D
0382+  06FD             ; size in C
0383+  06FD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  06FD             putsn:
0385+  06FD DB          	push al
0386+  06FE DA          	push d
0387+  06FF D9          	push c
0388+  0700             putsn_L0:
0389+  0700 1E          	mov al, [d]
0390+  0701 23          	mov ah, al
0391+  0702 19 00       	mov al, 0
0392+  0704 05 03       	syscall sys_io
0393+  0706 79          	inc d
0394+  0707 7E          	dec c	
0395+  0708 C2 00 00    	cmp c, 0
0396+  070B C7 00 07    	jne putsn_L0
0397+  070E             putsn_end:
0398+  070E E6          	pop c
0399+  070F E7          	pop d
0400+  0710 E8          	pop al
0401+  0711 09          	ret
0402+  0712             
0403+  0712             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  0712             ; print 16bit decimal number
0405+  0712             ; input number in A
0406+  0712             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  0712             print_u16d:
0408+  0712 D7          	push a
0409+  0713 D8          	push b
0410+  0714 26 10 27    	mov b, 10000
0411+  0717 AE          	div a, b			; get 10000 coeff.
0412+  0718 07 3E 07    	call print_number
0413+  071B 11          	mov a, b
0414+  071C 26 E8 03    	mov b, 1000
0415+  071F AE          	div a, b			; get 10000 coeff.
0416+  0720 07 3E 07    	call print_number
0417+  0723 11          	mov a, b
0418+  0724 26 64 00    	mov b, 100
0419+  0727 AE          	div a, b
0420+  0728 07 3E 07    	call print_number
0421+  072B 11          	mov a, b
0422+  072C 26 0A 00    	mov b, 10
0423+  072F AE          	div a, b
0424+  0730 07 3E 07    	call print_number
0425+  0733 11          	mov a, b
0426+  0734 6A 30       	add al, $30
0427+  0736 23          	mov ah, al
0428+  0737 19 00       	mov al, 0
0429+  0739 05 03       	syscall sys_io	; print coeff
0430+  073B E5          	pop b
0431+  073C E4          	pop a
0432+  073D 09          	ret
0433+  073E             
0434+  073E             
0435+  073E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  073E             ; if A == 0, print space
0437+  073E             ; else print A
0438+  073E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0439+  073E             print_number:
0440+  073E 6A 30       	add al, $30
0441+  0740 23          	mov ah, al
0442+  0741 07 AF 05    	call putchar
0443+  0744 09          	ret
0444+  0745             
0445+  0745             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0446+  0745             ; PRINT 16BIT HEX INTEGER
0447+  0745             ; integer value in reg B
0448+  0745             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  0745             print_u16x:
0450+  0745 D7          	push a
0451+  0746 D8          	push b
0452+  0747 DD          	push bl
0453+  0748 30          	mov bl, bh
0454+  0749 07 76 05    	call itoa				; convert bh to char in A
0455+  074C 2F          	mov bl, al				; save al
0456+  074D 19 00       	mov al, 0
0457+  074F 05 03       	syscall sys_io				; display AH
0458+  0751 24          	mov ah, bl				; retrieve al
0459+  0752 19 00       	mov al, 0
0460+  0754 05 03       	syscall sys_io				; display AL
0461+  0756             
0462+  0756 EA          	pop bl
0463+  0757 07 76 05    	call itoa				; convert bh to char in A
0464+  075A 2F          	mov bl, al				; save al
0465+  075B 19 00       	mov al, 0
0466+  075D 05 03       	syscall sys_io				; display AH
0467+  075F 24          	mov ah, bl				; retrieve al
0468+  0760 19 00       	mov al, 0
0469+  0762 05 03       	syscall sys_io				; display AL
0470+  0764             
0471+  0764 E5          	pop b
0472+  0765 E4          	pop a
0473+  0766 09          	ret
0474+  0767             
0475+  0767             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  0767             ; INPUT 16BIT HEX INTEGER
0477+  0767             ; read 16bit integer into A
0478+  0767             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  0767             scan_u16x:
0480+  0767 F8 10 00    	enter 16
0481+  076A D8          	push b
0482+  076B DA          	push d
0483+  076C             
0484+  076C FA F1 FF    	lea d, [bp + -15]
0485+  076F 07 B6 05    	call gets				; get number
0486+  0772             
0487+  0772 32          	mov bl, [d]
0488+  0773 37          	mov bh, bl
0489+  0774 33 01 00    	mov bl, [d + 1]
0490+  0777 07 64 05    	call atoi				; convert to int in AL
0491+  077A 23          	mov ah, al				; move to AH
0492+  077B             
0493+  077B 33 02 00    	mov bl, [d + 2]
0494+  077E 37          	mov bh, bl
0495+  077F 33 03 00    	mov bl, [d + 3]
0496+  0782 07 64 05    	call atoi				; convert to int in AL
0497+  0785             
0498+  0785 E7          	pop d
0499+  0786 E5          	pop b
0500+  0787 F9          	leave
0501+  0788 09          	ret
0502+  0789             
0503+  0789             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0504+  0789             ; PRINT 8bit HEX INTEGER
0505+  0789             ; integer value in reg bl
0506+  0789             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  0789             print_u8x:
0508+  0789 D7          	push a
0509+  078A DD          	push bl
0510+  078B             
0511+  078B 07 76 05    	call itoa				; convert bl to char in A
0512+  078E 2F          	mov bl, al				; save al
0513+  078F 19 00       	mov al, 0
0514+  0791 05 03       	syscall sys_io				; display AH
0515+  0793 24          	mov ah, bl				; retrieve al
0516+  0794 19 00       	mov al, 0
0517+  0796 05 03       	syscall sys_io				; display AL
0518+  0798             
0519+  0798 EA          	pop bl
0520+  0799 E4          	pop a
0521+  079A 09          	ret
0522+  079B             
0523+  079B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0524+  079B             ; print 8bit decimal unsigned number
0525+  079B             ; input number in AL
0526+  079B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  079B             print_u8d:
0528+  079B D7          	push a
0529+  079C D8          	push b
0530+  079D             
0531+  079D 22 00       	mov ah, 0
0532+  079F 26 64 00    	mov b, 100
0533+  07A2 AE          	div a, b
0534+  07A3 D8          	push b			; save remainder
0535+  07A4 B9 00       	cmp al, 0
0536+  07A6 C6 B0 07    	je skip100
0537+  07A9 6A 30       	add al, $30
0538+  07AB 23          	mov ah, al
0539+  07AC 19 00       	mov al, 0
0540+  07AE 05 03       	syscall sys_io	; print coeff
0541+  07B0             skip100:
0542+  07B0 E4          	pop a
0543+  07B1 22 00       	mov ah, 0
0544+  07B3 26 0A 00    	mov b, 10
0545+  07B6 AE          	div a, b
0546+  07B7 D8          	push b			; save remainder
0547+  07B8 B9 00       	cmp al, 0
0548+  07BA C6 C4 07    	je skip10
0549+  07BD 6A 30       	add al, $30
0550+  07BF 23          	mov ah, al
0551+  07C0 19 00       	mov al, 0
0552+  07C2 05 03       	syscall sys_io	; print coeff
0553+  07C4             skip10:
0554+  07C4 E4          	pop a
0555+  07C5 1B          	mov al, bl
0556+  07C6 6A 30       	add al, $30
0557+  07C8 23          	mov ah, al
0558+  07C9 19 00       	mov al, 0
0559+  07CB 05 03       	syscall sys_io	; print coeff
0560+  07CD E5          	pop b
0561+  07CE E4          	pop a
0562+  07CF 09          	ret
0563+  07D0             
0564+  07D0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0565+  07D0             ; INPUT 8BIT HEX INTEGER
0566+  07D0             ; read 8bit integer into AL
0567+  07D0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  07D0             scan_u8x:
0569+  07D0 F8 04 00    	enter 4
0570+  07D3 D8          	push b
0571+  07D4 DA          	push d
0572+  07D5             
0573+  07D5 FA FD FF    	lea d, [bp + -3]
0574+  07D8 07 B6 05    	call gets				; get number
0575+  07DB             
0576+  07DB 32          	mov bl, [d]
0577+  07DC 37          	mov bh, bl
0578+  07DD 33 01 00    	mov bl, [d + 1]
0579+  07E0 07 64 05    	call atoi				; convert to int in AL
0580+  07E3             
0581+  07E3 E7          	pop d
0582+  07E4 E5          	pop b
0583+  07E5 F9          	leave
0584+  07E6 09          	ret
0585+  07E7             
0586+  07E7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  07E7             ; input decimal number
0588+  07E7             ; result in A
0589+  07E7             ; 655'\0'
0590+  07E7             ; low--------high
0591+  07E7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0592+  07E7             scan_u16d:
0593+  07E7 F8 08 00    	enter 8
0594+  07EA E2          	push si
0595+  07EB D8          	push b
0596+  07EC D9          	push c
0597+  07ED DA          	push d
0598+  07EE FA F9 FF    	lea d, [bp +- 7]
0599+  07F1 07 B6 05    	call gets
0600+  07F4 07 E4 04    	call strlen			; get string length in C
0601+  07F7 7E          	dec c
0602+  07F8 FD 4E       	mov si, d
0603+  07FA 12          	mov a, c
0604+  07FB FD 99       	shl a
0605+  07FD 3B 4C 05    	mov d, table_power
0606+  0800 59          	add d, a
0607+  0801 38 00 00    	mov c, 0
0608+  0804             mul_loop:
0609+  0804 F6          	lodsb			; load ASCII to al
0610+  0805 B9 00       	cmp al, 0
0611+  0807 C6 1A 08    	je mul_exit
0612+  080A 6F 30       	sub al, $30		; make into integer
0613+  080C 22 00       	mov ah, 0
0614+  080E 2A          	mov b, [d]
0615+  080F AC          	mul a, b			; result in B since it fits in 16bits
0616+  0810 11          	mov a, b
0617+  0811 28          	mov b, c
0618+  0812 54          	add a, b
0619+  0813 39          	mov c, a
0620+  0814 63 02 00    	sub d, 2
0621+  0817 0A 04 08    	jmp mul_loop
0622+  081A             mul_exit:
0623+  081A 12          	mov a, c
0624+  081B E7          	pop d
0625+  081C E6          	pop c
0626+  081D E5          	pop b
0627+  081E EF          	pop si
0628+  081F F9          	leave
0629+  0820 09          	ret
0106   0821             ; --- END INCLUDE BLOCK
0107   0821             
0108   0821             
0109   0821             .end
tasm: Number of errors = 0
