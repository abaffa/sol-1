0001   0000             ; --- FILENAME: test.c
0002   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0400             .org PROC_TEXT_ORG
0004   0400             
0005   0400             ; --- BEGIN TEXT BLOCK
0006   0400             
0007   0400             main:
0008   0400 D2            push bp
0009   0401 9B            mov bp, sp
0010   0402 52 02 00      sub sp, 2 ; i
0011   0405 52 02 00      sub sp, 2 ; j
0012   0408 52 02 00      sub sp, 2 ; k
0013   040B 29 08 0B      mov b, [__matrix1]
0014   040E D7            push a
0015   040F 74            mov d, b
0016   0410 DA            push d
0017   0411 26 00 00      mov b, 0
0018   0414 E7            pop d
0019   0415 10 06 00      mov a, 6
0020   0418 AC            mul a, b
0021   0419 5A            add d, b
0022   041A E4            pop a
0023   041B 2D            mov b, d
0024   041C 26 5A 0B      mov b, __string_0 ; "Matrix1:\n"
0025   041F FD AB         swp b
0026   0421 D8            push b
0027   0422 07 E9 0A      call print
0028   0425 51 02 00      add sp, 2
0029   0428             _for1_init:
0030   0428 26 00 00      mov b, 0
0031   042B D7            push a
0032   042C 11            mov a, b
0033   042D 45 FF FF      mov [bp + -1], a ; i
0034   0430 E4            pop a
0035   0431             _for1_cond:
0036   0431 2C FF FF      mov b, [bp + -1] ; i
0037   0434 D7            push a
0038   0435 11            mov a, b
0039   0436 26 03 00      mov b, 3
0040   0439 B0            cmp a, b
0041   043A 0E            lodflgs
0042   043B 87 02         and al, %00000010 ; <
0043   043D FD 9C         shr al
0044   043F 22 00         mov ah, 0
0045   0441 27            mov b, a
0046   0442 E4            pop a
0047   0443 C0 00 00      cmp b, 0
0048   0446 C6 C4 04      je _for1_exit
0049   0449             _for1_block:
0050   0449             _for2_init:
0051   0449 26 00 00      mov b, 0
0052   044C D7            push a
0053   044D 11            mov a, b
0054   044E 45 FD FF      mov [bp + -3], a ; j
0055   0451 E4            pop a
0056   0452             _for2_cond:
0057   0452 2C FD FF      mov b, [bp + -3] ; j
0058   0455 D7            push a
0059   0456 11            mov a, b
0060   0457 26 03 00      mov b, 3
0061   045A B0            cmp a, b
0062   045B 0E            lodflgs
0063   045C 87 02         and al, %00000010 ; <
0064   045E FD 9C         shr al
0065   0460 22 00         mov ah, 0
0066   0462 27            mov b, a
0067   0463 E4            pop a
0068   0464 C0 00 00      cmp b, 0
0069   0467 C6 A6 04      je _for2_exit
0070   046A             _for2_block:
0071   046A 26 64 0B      mov b, __string_1 ; " "
0072   046D FD AB         swp b
0073   046F D8            push b
0074   0470 29 08 0B      mov b, [__matrix1]
0075   0473 D7            push a
0076   0474 74            mov d, b
0077   0475 DA            push d
0078   0476 2C FF FF      mov b, [bp + -1] ; i
0079   0479 E7            pop d
0080   047A 10 06 00      mov a, 6
0081   047D AC            mul a, b
0082   047E 5A            add d, b
0083   047F DA            push d
0084   0480 2C FD FF      mov b, [bp + -3] ; j
0085   0483 E7            pop d
0086   0484 10 02 00      mov a, 2
0087   0487 AC            mul a, b
0088   0488 5A            add d, b
0089   0489 E4            pop a
0090   048A 2A            mov b, [d]
0091   048B FD AB         swp b
0092   048D D8            push b
0093   048E 07 D2 0A      call printn
0094   0491 51 04 00      add sp, 4
0095   0494             _for2_update:
0096   0494 2C FD FF      mov b, [bp + -3] ; j
0097   0497 D7            push a
0098   0498 11            mov a, b
0099   0499 FD 77         inc b
0100   049B D7            push a
0101   049C 11            mov a, b
0102   049D 45 FD FF      mov [bp + -3], a ; j
0103   04A0 E4            pop a
0104   04A1 27            mov b, a
0105   04A2 E4            pop a
0106   04A3 0A 52 04      jmp _for2_cond
0107   04A6             _for2_exit:
0108   04A6 26 66 0B      mov b, __string_2 ; "\n"
0109   04A9 FD AB         swp b
0110   04AB D8            push b
0111   04AC 07 E9 0A      call print
0112   04AF 51 02 00      add sp, 2
0113   04B2             _for1_update:
0114   04B2 2C FF FF      mov b, [bp + -1] ; i
0115   04B5 D7            push a
0116   04B6 11            mov a, b
0117   04B7 FD 77         inc b
0118   04B9 D7            push a
0119   04BA 11            mov a, b
0120   04BB 45 FF FF      mov [bp + -1], a ; i
0121   04BE E4            pop a
0122   04BF 27            mov b, a
0123   04C0 E4            pop a
0124   04C1 0A 31 04      jmp _for1_cond
0125   04C4             _for1_exit:
0126   04C4 26 66 0B      mov b, __string_2 ; "\n"
0127   04C7 FD AB         swp b
0128   04C9 D8            push b
0129   04CA 07 E9 0A      call print
0130   04CD 51 02 00      add sp, 2
0131   04D0 26 68 0B      mov b, __string_3 ; "Matrix2:\n"
0132   04D3 FD AB         swp b
0133   04D5 D8            push b
0134   04D6 07 E9 0A      call print
0135   04D9 51 02 00      add sp, 2
0136   04DC             _for3_init:
0137   04DC 26 00 00      mov b, 0
0138   04DF D7            push a
0139   04E0 11            mov a, b
0140   04E1 45 FF FF      mov [bp + -1], a ; i
0141   04E4 E4            pop a
0142   04E5             _for3_cond:
0143   04E5 2C FF FF      mov b, [bp + -1] ; i
0144   04E8 D7            push a
0145   04E9 11            mov a, b
0146   04EA 26 03 00      mov b, 3
0147   04ED B0            cmp a, b
0148   04EE 0E            lodflgs
0149   04EF 87 02         and al, %00000010 ; <
0150   04F1 FD 9C         shr al
0151   04F3 22 00         mov ah, 0
0152   04F5 27            mov b, a
0153   04F6 E4            pop a
0154   04F7 C0 00 00      cmp b, 0
0155   04FA C6 78 05      je _for3_exit
0156   04FD             _for3_block:
0157   04FD             _for4_init:
0158   04FD 26 00 00      mov b, 0
0159   0500 D7            push a
0160   0501 11            mov a, b
0161   0502 45 FD FF      mov [bp + -3], a ; j
0162   0505 E4            pop a
0163   0506             _for4_cond:
0164   0506 2C FD FF      mov b, [bp + -3] ; j
0165   0509 D7            push a
0166   050A 11            mov a, b
0167   050B 26 03 00      mov b, 3
0168   050E B0            cmp a, b
0169   050F 0E            lodflgs
0170   0510 87 02         and al, %00000010 ; <
0171   0512 FD 9C         shr al
0172   0514 22 00         mov ah, 0
0173   0516 27            mov b, a
0174   0517 E4            pop a
0175   0518 C0 00 00      cmp b, 0
0176   051B C6 5A 05      je _for4_exit
0177   051E             _for4_block:
0178   051E 26 64 0B      mov b, __string_1 ; " "
0179   0521 FD AB         swp b
0180   0523 D8            push b
0181   0524 29 1C 0B      mov b, [__matrix2]
0182   0527 D7            push a
0183   0528 74            mov d, b
0184   0529 DA            push d
0185   052A 2C FF FF      mov b, [bp + -1] ; i
0186   052D E7            pop d
0187   052E 10 06 00      mov a, 6
0188   0531 AC            mul a, b
0189   0532 5A            add d, b
0190   0533 DA            push d
0191   0534 2C FD FF      mov b, [bp + -3] ; j
0192   0537 E7            pop d
0193   0538 10 02 00      mov a, 2
0194   053B AC            mul a, b
0195   053C 5A            add d, b
0196   053D E4            pop a
0197   053E 2A            mov b, [d]
0198   053F FD AB         swp b
0199   0541 D8            push b
0200   0542 07 D2 0A      call printn
0201   0545 51 04 00      add sp, 4
0202   0548             _for4_update:
0203   0548 2C FD FF      mov b, [bp + -3] ; j
0204   054B D7            push a
0205   054C 11            mov a, b
0206   054D FD 77         inc b
0207   054F D7            push a
0208   0550 11            mov a, b
0209   0551 45 FD FF      mov [bp + -3], a ; j
0210   0554 E4            pop a
0211   0555 27            mov b, a
0212   0556 E4            pop a
0213   0557 0A 06 05      jmp _for4_cond
0214   055A             _for4_exit:
0215   055A 26 66 0B      mov b, __string_2 ; "\n"
0216   055D FD AB         swp b
0217   055F D8            push b
0218   0560 07 E9 0A      call print
0219   0563 51 02 00      add sp, 2
0220   0566             _for3_update:
0221   0566 2C FF FF      mov b, [bp + -1] ; i
0222   0569 D7            push a
0223   056A 11            mov a, b
0224   056B FD 77         inc b
0225   056D D7            push a
0226   056E 11            mov a, b
0227   056F 45 FF FF      mov [bp + -1], a ; i
0228   0572 E4            pop a
0229   0573 27            mov b, a
0230   0574 E4            pop a
0231   0575 0A E5 04      jmp _for3_cond
0232   0578             _for3_exit:
0233   0578 26 66 0B      mov b, __string_2 ; "\n"
0234   057B FD AB         swp b
0235   057D D8            push b
0236   057E 07 E9 0A      call print
0237   0581 51 02 00      add sp, 2
0238   0584             _for5_init:
0239   0584 26 00 00      mov b, 0
0240   0587 D7            push a
0241   0588 11            mov a, b
0242   0589 45 FF FF      mov [bp + -1], a ; i
0243   058C E4            pop a
0244   058D             _for5_cond:
0245   058D 2C FF FF      mov b, [bp + -1] ; i
0246   0590 D7            push a
0247   0591 11            mov a, b
0248   0592 26 03 00      mov b, 3
0249   0595 B0            cmp a, b
0250   0596 0E            lodflgs
0251   0597 87 02         and al, %00000010 ; <
0252   0599 FD 9C         shr al
0253   059B 22 00         mov ah, 0
0254   059D 27            mov b, a
0255   059E E4            pop a
0256   059F C0 00 00      cmp b, 0
0257   05A2 C6 B6 06      je _for5_exit
0258   05A5             _for5_block:
0259   05A5             _for6_init:
0260   05A5 26 00 00      mov b, 0
0261   05A8 D7            push a
0262   05A9 11            mov a, b
0263   05AA 45 FD FF      mov [bp + -3], a ; j
0264   05AD E4            pop a
0265   05AE             _for6_cond:
0266   05AE 2C FD FF      mov b, [bp + -3] ; j
0267   05B1 D7            push a
0268   05B2 11            mov a, b
0269   05B3 26 03 00      mov b, 3
0270   05B6 B0            cmp a, b
0271   05B7 0E            lodflgs
0272   05B8 87 02         and al, %00000010 ; <
0273   05BA FD 9C         shr al
0274   05BC 22 00         mov ah, 0
0275   05BE 27            mov b, a
0276   05BF E4            pop a
0277   05C0 C0 00 00      cmp b, 0
0278   05C3 C6 A4 06      je _for6_exit
0279   05C6             _for6_block:
0280   05C6 29 30 0B      mov b, [__result1]
0281   05C9 D7            push a
0282   05CA 74            mov d, b
0283   05CB DA            push d
0284   05CC 2C FF FF      mov b, [bp + -1] ; i
0285   05CF E7            pop d
0286   05D0 10 06 00      mov a, 6
0287   05D3 AC            mul a, b
0288   05D4 5A            add d, b
0289   05D5 DA            push d
0290   05D6 2C FD FF      mov b, [bp + -3] ; j
0291   05D9 E7            pop d
0292   05DA 10 02 00      mov a, 2
0293   05DD AC            mul a, b
0294   05DE 5A            add d, b
0295   05DF E4            pop a
0296   05E0 DA            push d
0297   05E1 26 00 00      mov b, 0
0298   05E4 E7            pop d
0299   05E5 FD 43         mov [d], b
0300   05E7             _for7_init:
0301   05E7 26 00 00      mov b, 0
0302   05EA D7            push a
0303   05EB 11            mov a, b
0304   05EC 45 FB FF      mov [bp + -5], a ; k
0305   05EF E4            pop a
0306   05F0             _for7_cond:
0307   05F0 2C FB FF      mov b, [bp + -5] ; k
0308   05F3 D7            push a
0309   05F4 11            mov a, b
0310   05F5 26 03 00      mov b, 3
0311   05F8 B0            cmp a, b
0312   05F9 0E            lodflgs
0313   05FA 87 02         and al, %00000010 ; <
0314   05FC FD 9C         shr al
0315   05FE 22 00         mov ah, 0
0316   0600 27            mov b, a
0317   0601 E4            pop a
0318   0602 C0 00 00      cmp b, 0
0319   0605 C6 92 06      je _for7_exit
0320   0608             _for7_block:
0321   0608 29 30 0B      mov b, [__result1]
0322   060B D7            push a
0323   060C 74            mov d, b
0324   060D DA            push d
0325   060E 2C FF FF      mov b, [bp + -1] ; i
0326   0611 E7            pop d
0327   0612 10 06 00      mov a, 6
0328   0615 AC            mul a, b
0329   0616 5A            add d, b
0330   0617 DA            push d
0331   0618 2C FD FF      mov b, [bp + -3] ; j
0332   061B E7            pop d
0333   061C 10 02 00      mov a, 2
0334   061F AC            mul a, b
0335   0620 5A            add d, b
0336   0621 E4            pop a
0337   0622 DA            push d
0338   0623 29 30 0B      mov b, [__result1]
0339   0626 D7            push a
0340   0627 74            mov d, b
0341   0628 DA            push d
0342   0629 2C FF FF      mov b, [bp + -1] ; i
0343   062C E7            pop d
0344   062D 10 06 00      mov a, 6
0345   0630 AC            mul a, b
0346   0631 5A            add d, b
0347   0632 DA            push d
0348   0633 2C FD FF      mov b, [bp + -3] ; j
0349   0636 E7            pop d
0350   0637 10 02 00      mov a, 2
0351   063A AC            mul a, b
0352   063B 5A            add d, b
0353   063C E4            pop a
0354   063D 2A            mov b, [d]
0355   063E D7            push a
0356   063F 11            mov a, b
0357   0640 29 08 0B      mov b, [__matrix1]
0358   0643 D7            push a
0359   0644 74            mov d, b
0360   0645 DA            push d
0361   0646 2C FF FF      mov b, [bp + -1] ; i
0362   0649 E7            pop d
0363   064A 10 06 00      mov a, 6
0364   064D AC            mul a, b
0365   064E 5A            add d, b
0366   064F DA            push d
0367   0650 2C FB FF      mov b, [bp + -5] ; k
0368   0653 E7            pop d
0369   0654 10 02 00      mov a, 2
0370   0657 AC            mul a, b
0371   0658 5A            add d, b
0372   0659 E4            pop a
0373   065A 2A            mov b, [d]
0374   065B D7            push a
0375   065C 11            mov a, b
0376   065D 29 1C 0B      mov b, [__matrix2]
0377   0660 D7            push a
0378   0661 74            mov d, b
0379   0662 DA            push d
0380   0663 2C FB FF      mov b, [bp + -5] ; k
0381   0666 E7            pop d
0382   0667 10 06 00      mov a, 6
0383   066A AC            mul a, b
0384   066B 5A            add d, b
0385   066C DA            push d
0386   066D 2C FD FF      mov b, [bp + -3] ; j
0387   0670 E7            pop d
0388   0671 10 02 00      mov a, 2
0389   0674 AC            mul a, b
0390   0675 5A            add d, b
0391   0676 E4            pop a
0392   0677 2A            mov b, [d]
0393   0678 AC            mul a, b
0394   0679 E4            pop a
0395   067A 54            add a, b
0396   067B 27            mov b, a
0397   067C E4            pop a
0398   067D E7            pop d
0399   067E FD 43         mov [d], b
0400   0680             _for7_update:
0401   0680 2C FB FF      mov b, [bp + -5] ; k
0402   0683 D7            push a
0403   0684 11            mov a, b
0404   0685 FD 77         inc b
0405   0687 D7            push a
0406   0688 11            mov a, b
0407   0689 45 FB FF      mov [bp + -5], a ; k
0408   068C E4            pop a
0409   068D 27            mov b, a
0410   068E E4            pop a
0411   068F 0A F0 05      jmp _for7_cond
0412   0692             _for7_exit:
0413   0692             _for6_update:
0414   0692 2C FD FF      mov b, [bp + -3] ; j
0415   0695 D7            push a
0416   0696 11            mov a, b
0417   0697 FD 77         inc b
0418   0699 D7            push a
0419   069A 11            mov a, b
0420   069B 45 FD FF      mov [bp + -3], a ; j
0421   069E E4            pop a
0422   069F 27            mov b, a
0423   06A0 E4            pop a
0424   06A1 0A AE 05      jmp _for6_cond
0425   06A4             _for6_exit:
0426   06A4             _for5_update:
0427   06A4 2C FF FF      mov b, [bp + -1] ; i
0428   06A7 D7            push a
0429   06A8 11            mov a, b
0430   06A9 FD 77         inc b
0431   06AB D7            push a
0432   06AC 11            mov a, b
0433   06AD 45 FF FF      mov [bp + -1], a ; i
0434   06B0 E4            pop a
0435   06B1 27            mov b, a
0436   06B2 E4            pop a
0437   06B3 0A 8D 05      jmp _for5_cond
0438   06B6             _for5_exit:
0439   06B6             _for8_init:
0440   06B6 26 00 00      mov b, 0
0441   06B9 D7            push a
0442   06BA 11            mov a, b
0443   06BB 45 FF FF      mov [bp + -1], a ; i
0444   06BE E4            pop a
0445   06BF             _for8_cond:
0446   06BF 2C FF FF      mov b, [bp + -1] ; i
0447   06C2 D7            push a
0448   06C3 11            mov a, b
0449   06C4 26 03 00      mov b, 3
0450   06C7 B0            cmp a, b
0451   06C8 0E            lodflgs
0452   06C9 87 02         and al, %00000010 ; <
0453   06CB FD 9C         shr al
0454   06CD 22 00         mov ah, 0
0455   06CF 27            mov b, a
0456   06D0 E4            pop a
0457   06D1 C0 00 00      cmp b, 0
0458   06D4 C6 75 07      je _for8_exit
0459   06D7             _for8_block:
0460   06D7             _for9_init:
0461   06D7 26 00 00      mov b, 0
0462   06DA D7            push a
0463   06DB 11            mov a, b
0464   06DC 45 FD FF      mov [bp + -3], a ; j
0465   06DF E4            pop a
0466   06E0             _for9_cond:
0467   06E0 2C FD FF      mov b, [bp + -3] ; j
0468   06E3 D7            push a
0469   06E4 11            mov a, b
0470   06E5 26 03 00      mov b, 3
0471   06E8 B0            cmp a, b
0472   06E9 0E            lodflgs
0473   06EA 87 02         and al, %00000010 ; <
0474   06EC FD 9C         shr al
0475   06EE 22 00         mov ah, 0
0476   06F0 27            mov b, a
0477   06F1 E4            pop a
0478   06F2 C0 00 00      cmp b, 0
0479   06F5 C6 63 07      je _for9_exit
0480   06F8             _for9_block:
0481   06F8 29 44 0B      mov b, [__result2]
0482   06FB D7            push a
0483   06FC 74            mov d, b
0484   06FD DA            push d
0485   06FE 2C FF FF      mov b, [bp + -1] ; i
0486   0701 E7            pop d
0487   0702 10 06 00      mov a, 6
0488   0705 AC            mul a, b
0489   0706 5A            add d, b
0490   0707 DA            push d
0491   0708 2C FD FF      mov b, [bp + -3] ; j
0492   070B E7            pop d
0493   070C 10 02 00      mov a, 2
0494   070F AC            mul a, b
0495   0710 5A            add d, b
0496   0711 E4            pop a
0497   0712 DA            push d
0498   0713 29 08 0B      mov b, [__matrix1]
0499   0716 D7            push a
0500   0717 74            mov d, b
0501   0718 DA            push d
0502   0719 2C FF FF      mov b, [bp + -1] ; i
0503   071C E7            pop d
0504   071D 10 06 00      mov a, 6
0505   0720 AC            mul a, b
0506   0721 5A            add d, b
0507   0722 DA            push d
0508   0723 2C FD FF      mov b, [bp + -3] ; j
0509   0726 E7            pop d
0510   0727 10 02 00      mov a, 2
0511   072A AC            mul a, b
0512   072B 5A            add d, b
0513   072C E4            pop a
0514   072D 2A            mov b, [d]
0515   072E D7            push a
0516   072F 11            mov a, b
0517   0730 29 1C 0B      mov b, [__matrix2]
0518   0733 D7            push a
0519   0734 74            mov d, b
0520   0735 DA            push d
0521   0736 2C FF FF      mov b, [bp + -1] ; i
0522   0739 E7            pop d
0523   073A 10 06 00      mov a, 6
0524   073D AC            mul a, b
0525   073E 5A            add d, b
0526   073F DA            push d
0527   0740 2C FD FF      mov b, [bp + -3] ; j
0528   0743 E7            pop d
0529   0744 10 02 00      mov a, 2
0530   0747 AC            mul a, b
0531   0748 5A            add d, b
0532   0749 E4            pop a
0533   074A 2A            mov b, [d]
0534   074B 54            add a, b
0535   074C 27            mov b, a
0536   074D E4            pop a
0537   074E E7            pop d
0538   074F FD 43         mov [d], b
0539   0751             _for9_update:
0540   0751 2C FD FF      mov b, [bp + -3] ; j
0541   0754 D7            push a
0542   0755 11            mov a, b
0543   0756 FD 77         inc b
0544   0758 D7            push a
0545   0759 11            mov a, b
0546   075A 45 FD FF      mov [bp + -3], a ; j
0547   075D E4            pop a
0548   075E 27            mov b, a
0549   075F E4            pop a
0550   0760 0A E0 06      jmp _for9_cond
0551   0763             _for9_exit:
0552   0763             _for8_update:
0553   0763 2C FF FF      mov b, [bp + -1] ; i
0554   0766 D7            push a
0555   0767 11            mov a, b
0556   0768 FD 77         inc b
0557   076A D7            push a
0558   076B 11            mov a, b
0559   076C 45 FF FF      mov [bp + -1], a ; i
0560   076F E4            pop a
0561   0770 27            mov b, a
0562   0771 E4            pop a
0563   0772 0A BF 06      jmp _for8_cond
0564   0775             _for8_exit:
0565   0775             _for10_init:
0566   0775 26 00 00      mov b, 0
0567   0778 D7            push a
0568   0779 11            mov a, b
0569   077A 45 FF FF      mov [bp + -1], a ; i
0570   077D E4            pop a
0571   077E             _for10_cond:
0572   077E 2C FF FF      mov b, [bp + -1] ; i
0573   0781 D7            push a
0574   0782 11            mov a, b
0575   0783 26 03 00      mov b, 3
0576   0786 B0            cmp a, b
0577   0787 0E            lodflgs
0578   0788 87 02         and al, %00000010 ; <
0579   078A FD 9C         shr al
0580   078C 22 00         mov ah, 0
0581   078E 27            mov b, a
0582   078F E4            pop a
0583   0790 C0 00 00      cmp b, 0
0584   0793 C6 34 08      je _for10_exit
0585   0796             _for10_block:
0586   0796             _for11_init:
0587   0796 26 00 00      mov b, 0
0588   0799 D7            push a
0589   079A 11            mov a, b
0590   079B 45 FD FF      mov [bp + -3], a ; j
0591   079E E4            pop a
0592   079F             _for11_cond:
0593   079F 2C FD FF      mov b, [bp + -3] ; j
0594   07A2 D7            push a
0595   07A3 11            mov a, b
0596   07A4 26 03 00      mov b, 3
0597   07A7 B0            cmp a, b
0598   07A8 0E            lodflgs
0599   07A9 87 02         and al, %00000010 ; <
0600   07AB FD 9C         shr al
0601   07AD 22 00         mov ah, 0
0602   07AF 27            mov b, a
0603   07B0 E4            pop a
0604   07B1 C0 00 00      cmp b, 0
0605   07B4 C6 22 08      je _for11_exit
0606   07B7             _for11_block:
0607   07B7 29 58 0B      mov b, [__result3]
0608   07BA D7            push a
0609   07BB 74            mov d, b
0610   07BC DA            push d
0611   07BD 2C FF FF      mov b, [bp + -1] ; i
0612   07C0 E7            pop d
0613   07C1 10 06 00      mov a, 6
0614   07C4 AC            mul a, b
0615   07C5 5A            add d, b
0616   07C6 DA            push d
0617   07C7 2C FD FF      mov b, [bp + -3] ; j
0618   07CA E7            pop d
0619   07CB 10 02 00      mov a, 2
0620   07CE AC            mul a, b
0621   07CF 5A            add d, b
0622   07D0 E4            pop a
0623   07D1 DA            push d
0624   07D2 29 1C 0B      mov b, [__matrix2]
0625   07D5 D7            push a
0626   07D6 74            mov d, b
0627   07D7 DA            push d
0628   07D8 2C FF FF      mov b, [bp + -1] ; i
0629   07DB E7            pop d
0630   07DC 10 06 00      mov a, 6
0631   07DF AC            mul a, b
0632   07E0 5A            add d, b
0633   07E1 DA            push d
0634   07E2 2C FD FF      mov b, [bp + -3] ; j
0635   07E5 E7            pop d
0636   07E6 10 02 00      mov a, 2
0637   07E9 AC            mul a, b
0638   07EA 5A            add d, b
0639   07EB E4            pop a
0640   07EC 2A            mov b, [d]
0641   07ED D7            push a
0642   07EE 11            mov a, b
0643   07EF 29 08 0B      mov b, [__matrix1]
0644   07F2 D7            push a
0645   07F3 74            mov d, b
0646   07F4 DA            push d
0647   07F5 2C FF FF      mov b, [bp + -1] ; i
0648   07F8 E7            pop d
0649   07F9 10 06 00      mov a, 6
0650   07FC AC            mul a, b
0651   07FD 5A            add d, b
0652   07FE DA            push d
0653   07FF 2C FD FF      mov b, [bp + -3] ; j
0654   0802 E7            pop d
0655   0803 10 02 00      mov a, 2
0656   0806 AC            mul a, b
0657   0807 5A            add d, b
0658   0808 E4            pop a
0659   0809 2A            mov b, [d]
0660   080A 60            sub a, b
0661   080B 27            mov b, a
0662   080C E4            pop a
0663   080D E7            pop d
0664   080E FD 43         mov [d], b
0665   0810             _for11_update:
0666   0810 2C FD FF      mov b, [bp + -3] ; j
0667   0813 D7            push a
0668   0814 11            mov a, b
0669   0815 FD 77         inc b
0670   0817 D7            push a
0671   0818 11            mov a, b
0672   0819 45 FD FF      mov [bp + -3], a ; j
0673   081C E4            pop a
0674   081D 27            mov b, a
0675   081E E4            pop a
0676   081F 0A 9F 07      jmp _for11_cond
0677   0822             _for11_exit:
0678   0822             _for10_update:
0679   0822 2C FF FF      mov b, [bp + -1] ; i
0680   0825 D7            push a
0681   0826 11            mov a, b
0682   0827 FD 77         inc b
0683   0829 D7            push a
0684   082A 11            mov a, b
0685   082B 45 FF FF      mov [bp + -1], a ; i
0686   082E E4            pop a
0687   082F 27            mov b, a
0688   0830 E4            pop a
0689   0831 0A 7E 07      jmp _for10_cond
0690   0834             _for10_exit:
0691   0834 26 72 0B      mov b, __string_4 ; "Result1 (matrix1 * matrix2):\n"
0692   0837 FD AB         swp b
0693   0839 D8            push b
0694   083A 07 E9 0A      call print
0695   083D 51 02 00      add sp, 2
0696   0840             _for12_init:
0697   0840 26 00 00      mov b, 0
0698   0843 D7            push a
0699   0844 11            mov a, b
0700   0845 45 FF FF      mov [bp + -1], a ; i
0701   0848 E4            pop a
0702   0849             _for12_cond:
0703   0849 2C FF FF      mov b, [bp + -1] ; i
0704   084C D7            push a
0705   084D 11            mov a, b
0706   084E 26 03 00      mov b, 3
0707   0851 B0            cmp a, b
0708   0852 0E            lodflgs
0709   0853 87 02         and al, %00000010 ; <
0710   0855 FD 9C         shr al
0711   0857 22 00         mov ah, 0
0712   0859 27            mov b, a
0713   085A E4            pop a
0714   085B C0 00 00      cmp b, 0
0715   085E C6 DC 08      je _for12_exit
0716   0861             _for12_block:
0717   0861             _for13_init:
0718   0861 26 00 00      mov b, 0
0719   0864 D7            push a
0720   0865 11            mov a, b
0721   0866 45 FD FF      mov [bp + -3], a ; j
0722   0869 E4            pop a
0723   086A             _for13_cond:
0724   086A 2C FD FF      mov b, [bp + -3] ; j
0725   086D D7            push a
0726   086E 11            mov a, b
0727   086F 26 03 00      mov b, 3
0728   0872 B0            cmp a, b
0729   0873 0E            lodflgs
0730   0874 87 02         and al, %00000010 ; <
0731   0876 FD 9C         shr al
0732   0878 22 00         mov ah, 0
0733   087A 27            mov b, a
0734   087B E4            pop a
0735   087C C0 00 00      cmp b, 0
0736   087F C6 BE 08      je _for13_exit
0737   0882             _for13_block:
0738   0882 26 64 0B      mov b, __string_1 ; " "
0739   0885 FD AB         swp b
0740   0887 D8            push b
0741   0888 29 30 0B      mov b, [__result1]
0742   088B D7            push a
0743   088C 74            mov d, b
0744   088D DA            push d
0745   088E 2C FF FF      mov b, [bp + -1] ; i
0746   0891 E7            pop d
0747   0892 10 06 00      mov a, 6
0748   0895 AC            mul a, b
0749   0896 5A            add d, b
0750   0897 DA            push d
0751   0898 2C FD FF      mov b, [bp + -3] ; j
0752   089B E7            pop d
0753   089C 10 02 00      mov a, 2
0754   089F AC            mul a, b
0755   08A0 5A            add d, b
0756   08A1 E4            pop a
0757   08A2 2A            mov b, [d]
0758   08A3 FD AB         swp b
0759   08A5 D8            push b
0760   08A6 07 D2 0A      call printn
0761   08A9 51 04 00      add sp, 4
0762   08AC             _for13_update:
0763   08AC 2C FD FF      mov b, [bp + -3] ; j
0764   08AF D7            push a
0765   08B0 11            mov a, b
0766   08B1 FD 77         inc b
0767   08B3 D7            push a
0768   08B4 11            mov a, b
0769   08B5 45 FD FF      mov [bp + -3], a ; j
0770   08B8 E4            pop a
0771   08B9 27            mov b, a
0772   08BA E4            pop a
0773   08BB 0A 6A 08      jmp _for13_cond
0774   08BE             _for13_exit:
0775   08BE 26 66 0B      mov b, __string_2 ; "\n"
0776   08C1 FD AB         swp b
0777   08C3 D8            push b
0778   08C4 07 E9 0A      call print
0779   08C7 51 02 00      add sp, 2
0780   08CA             _for12_update:
0781   08CA 2C FF FF      mov b, [bp + -1] ; i
0782   08CD D7            push a
0783   08CE 11            mov a, b
0784   08CF FD 77         inc b
0785   08D1 D7            push a
0786   08D2 11            mov a, b
0787   08D3 45 FF FF      mov [bp + -1], a ; i
0788   08D6 E4            pop a
0789   08D7 27            mov b, a
0790   08D8 E4            pop a
0791   08D9 0A 49 08      jmp _for12_cond
0792   08DC             _for12_exit:
0793   08DC 26 66 0B      mov b, __string_2 ; "\n"
0794   08DF FD AB         swp b
0795   08E1 D8            push b
0796   08E2 07 E9 0A      call print
0797   08E5 51 02 00      add sp, 2
0798   08E8 26 90 0B      mov b, __string_5 ; "Result2 (matrix1 + matrix2):\n"
0799   08EB FD AB         swp b
0800   08ED D8            push b
0801   08EE 07 E9 0A      call print
0802   08F1 51 02 00      add sp, 2
0803   08F4             _for14_init:
0804   08F4 26 00 00      mov b, 0
0805   08F7 D7            push a
0806   08F8 11            mov a, b
0807   08F9 45 FF FF      mov [bp + -1], a ; i
0808   08FC E4            pop a
0809   08FD             _for14_cond:
0810   08FD 2C FF FF      mov b, [bp + -1] ; i
0811   0900 D7            push a
0812   0901 11            mov a, b
0813   0902 26 03 00      mov b, 3
0814   0905 B0            cmp a, b
0815   0906 0E            lodflgs
0816   0907 87 02         and al, %00000010 ; <
0817   0909 FD 9C         shr al
0818   090B 22 00         mov ah, 0
0819   090D 27            mov b, a
0820   090E E4            pop a
0821   090F C0 00 00      cmp b, 0
0822   0912 C6 90 09      je _for14_exit
0823   0915             _for14_block:
0824   0915             _for15_init:
0825   0915 26 00 00      mov b, 0
0826   0918 D7            push a
0827   0919 11            mov a, b
0828   091A 45 FD FF      mov [bp + -3], a ; j
0829   091D E4            pop a
0830   091E             _for15_cond:
0831   091E 2C FD FF      mov b, [bp + -3] ; j
0832   0921 D7            push a
0833   0922 11            mov a, b
0834   0923 26 03 00      mov b, 3
0835   0926 B0            cmp a, b
0836   0927 0E            lodflgs
0837   0928 87 02         and al, %00000010 ; <
0838   092A FD 9C         shr al
0839   092C 22 00         mov ah, 0
0840   092E 27            mov b, a
0841   092F E4            pop a
0842   0930 C0 00 00      cmp b, 0
0843   0933 C6 72 09      je _for15_exit
0844   0936             _for15_block:
0845   0936 26 64 0B      mov b, __string_1 ; " "
0846   0939 FD AB         swp b
0847   093B D8            push b
0848   093C 29 44 0B      mov b, [__result2]
0849   093F D7            push a
0850   0940 74            mov d, b
0851   0941 DA            push d
0852   0942 2C FF FF      mov b, [bp + -1] ; i
0853   0945 E7            pop d
0854   0946 10 06 00      mov a, 6
0855   0949 AC            mul a, b
0856   094A 5A            add d, b
0857   094B DA            push d
0858   094C 2C FD FF      mov b, [bp + -3] ; j
0859   094F E7            pop d
0860   0950 10 02 00      mov a, 2
0861   0953 AC            mul a, b
0862   0954 5A            add d, b
0863   0955 E4            pop a
0864   0956 2A            mov b, [d]
0865   0957 FD AB         swp b
0866   0959 D8            push b
0867   095A 07 D2 0A      call printn
0868   095D 51 04 00      add sp, 4
0869   0960             _for15_update:
0870   0960 2C FD FF      mov b, [bp + -3] ; j
0871   0963 D7            push a
0872   0964 11            mov a, b
0873   0965 FD 77         inc b
0874   0967 D7            push a
0875   0968 11            mov a, b
0876   0969 45 FD FF      mov [bp + -3], a ; j
0877   096C E4            pop a
0878   096D 27            mov b, a
0879   096E E4            pop a
0880   096F 0A 1E 09      jmp _for15_cond
0881   0972             _for15_exit:
0882   0972 26 66 0B      mov b, __string_2 ; "\n"
0883   0975 FD AB         swp b
0884   0977 D8            push b
0885   0978 07 E9 0A      call print
0886   097B 51 02 00      add sp, 2
0887   097E             _for14_update:
0888   097E 2C FF FF      mov b, [bp + -1] ; i
0889   0981 D7            push a
0890   0982 11            mov a, b
0891   0983 FD 77         inc b
0892   0985 D7            push a
0893   0986 11            mov a, b
0894   0987 45 FF FF      mov [bp + -1], a ; i
0895   098A E4            pop a
0896   098B 27            mov b, a
0897   098C E4            pop a
0898   098D 0A FD 08      jmp _for14_cond
0899   0990             _for14_exit:
0900   0990 26 66 0B      mov b, __string_2 ; "\n"
0901   0993 FD AB         swp b
0902   0995 D8            push b
0903   0996 07 E9 0A      call print
0904   0999 51 02 00      add sp, 2
0905   099C 26 AE 0B      mov b, __string_6 ; "Result3 (matrix2 - matrix1):\n"
0906   099F FD AB         swp b
0907   09A1 D8            push b
0908   09A2 07 E9 0A      call print
0909   09A5 51 02 00      add sp, 2
0910   09A8             _for16_init:
0911   09A8 26 00 00      mov b, 0
0912   09AB D7            push a
0913   09AC 11            mov a, b
0914   09AD 45 FF FF      mov [bp + -1], a ; i
0915   09B0 E4            pop a
0916   09B1             _for16_cond:
0917   09B1 2C FF FF      mov b, [bp + -1] ; i
0918   09B4 D7            push a
0919   09B5 11            mov a, b
0920   09B6 26 03 00      mov b, 3
0921   09B9 B0            cmp a, b
0922   09BA 0E            lodflgs
0923   09BB 87 02         and al, %00000010 ; <
0924   09BD FD 9C         shr al
0925   09BF 22 00         mov ah, 0
0926   09C1 27            mov b, a
0927   09C2 E4            pop a
0928   09C3 C0 00 00      cmp b, 0
0929   09C6 C6 44 0A      je _for16_exit
0930   09C9             _for16_block:
0931   09C9             _for17_init:
0932   09C9 26 00 00      mov b, 0
0933   09CC D7            push a
0934   09CD 11            mov a, b
0935   09CE 45 FD FF      mov [bp + -3], a ; j
0936   09D1 E4            pop a
0937   09D2             _for17_cond:
0938   09D2 2C FD FF      mov b, [bp + -3] ; j
0939   09D5 D7            push a
0940   09D6 11            mov a, b
0941   09D7 26 03 00      mov b, 3
0942   09DA B0            cmp a, b
0943   09DB 0E            lodflgs
0944   09DC 87 02         and al, %00000010 ; <
0945   09DE FD 9C         shr al
0946   09E0 22 00         mov ah, 0
0947   09E2 27            mov b, a
0948   09E3 E4            pop a
0949   09E4 C0 00 00      cmp b, 0
0950   09E7 C6 26 0A      je _for17_exit
0951   09EA             _for17_block:
0952   09EA 26 64 0B      mov b, __string_1 ; " "
0953   09ED FD AB         swp b
0954   09EF D8            push b
0955   09F0 29 58 0B      mov b, [__result3]
0956   09F3 D7            push a
0957   09F4 74            mov d, b
0958   09F5 DA            push d
0959   09F6 2C FF FF      mov b, [bp + -1] ; i
0960   09F9 E7            pop d
0961   09FA 10 06 00      mov a, 6
0962   09FD AC            mul a, b
0963   09FE 5A            add d, b
0964   09FF DA            push d
0965   0A00 2C FD FF      mov b, [bp + -3] ; j
0966   0A03 E7            pop d
0967   0A04 10 02 00      mov a, 2
0968   0A07 AC            mul a, b
0969   0A08 5A            add d, b
0970   0A09 E4            pop a
0971   0A0A 2A            mov b, [d]
0972   0A0B FD AB         swp b
0973   0A0D D8            push b
0974   0A0E 07 D2 0A      call printn
0975   0A11 51 04 00      add sp, 4
0976   0A14             _for17_update:
0977   0A14 2C FD FF      mov b, [bp + -3] ; j
0978   0A17 D7            push a
0979   0A18 11            mov a, b
0980   0A19 FD 77         inc b
0981   0A1B D7            push a
0982   0A1C 11            mov a, b
0983   0A1D 45 FD FF      mov [bp + -3], a ; j
0984   0A20 E4            pop a
0985   0A21 27            mov b, a
0986   0A22 E4            pop a
0987   0A23 0A D2 09      jmp _for17_cond
0988   0A26             _for17_exit:
0989   0A26 26 66 0B      mov b, __string_2 ; "\n"
0990   0A29 FD AB         swp b
0991   0A2B D8            push b
0992   0A2C 07 E9 0A      call print
0993   0A2F 51 02 00      add sp, 2
0994   0A32             _for16_update:
0995   0A32 2C FF FF      mov b, [bp + -1] ; i
0996   0A35 D7            push a
0997   0A36 11            mov a, b
0998   0A37 FD 77         inc b
0999   0A39 D7            push a
1000   0A3A 11            mov a, b
1001   0A3B 45 FF FF      mov [bp + -1], a ; i
1002   0A3E E4            pop a
1003   0A3F 27            mov b, a
1004   0A40 E4            pop a
1005   0A41 0A B1 09      jmp _for16_cond
1006   0A44             _for16_exit:
1007   0A44 26 66 0B      mov b, __string_2 ; "\n"
1008   0A47 FD AB         swp b
1009   0A49 D8            push b
1010   0A4A 07 E9 0A      call print
1011   0A4D 51 02 00      add sp, 2
1012   0A50 26 00 00      mov b, 0
1013   0A53 F9            leave
1014   0A54 05 0B         syscall sys_terminate_proc
1015   0A56             
1016   0A56             assert:
1017   0A56 D2            push bp
1018   0A57 9B            mov bp, sp
1019   0A58             _if18_cond:
1020   0A58 2C 05 00      mov b, [bp + 5] ; i
1021   0A5B C0 00 00      cmp b, 0
1022   0A5E C6 70 0A      je _if18_else
1023   0A61             _if18_true:
1024   0A61 26 CC 0B      mov b, __string_7 ; "Passed."
1025   0A64 FD AB         swp b
1026   0A66 D8            push b
1027   0A67 07 E9 0A      call print
1028   0A6A 51 02 00      add sp, 2
1029   0A6D 0A 7C 0A      jmp _if18_exit
1030   0A70             _if18_else:
1031   0A70 26 D4 0B      mov b, __string_8 ; "FAILED."
1032   0A73 FD AB         swp b
1033   0A75 D8            push b
1034   0A76 07 E9 0A      call print
1035   0A79 51 02 00      add sp, 2
1036   0A7C             _if18_exit:
1037   0A7C 26 DC 0B      mov b, __string_9 ; "Index: "
1038   0A7F FD AB         swp b
1039   0A81 D8            push b
1040   0A82 29 F4 0A      mov b, [__index] ; index
1041   0A85 FD AB         swp b
1042   0A87 D8            push b
1043   0A88 07 D2 0A      call printn
1044   0A8B 51 04 00      add sp, 4
1045   0A8E 26 66 0B      mov b, __string_2 ; "\n"
1046   0A91 FD AB         swp b
1047   0A93 D8            push b
1048   0A94 07 E9 0A      call print
1049   0A97 51 02 00      add sp, 2
1050   0A9A 29 F4 0A      mov b, [__index] ; index
1051   0A9D D7            push a
1052   0A9E 11            mov a, b
1053   0A9F FD 77         inc b
1054   0AA1 FD 42 F4 0A   mov [__index], b
1055   0AA5 27            mov b, a
1056   0AA6 E4            pop a
1057   0AA7 F9            leave
1058   0AA8 09            ret
1059   0AA9             
1060   0AA9             add:
1061   0AA9 D2            push bp
1062   0AAA 9B            mov bp, sp
1063   0AAB 2C 07 00      mov b, [bp + 7] ; x
1064   0AAE D7            push a
1065   0AAF 11            mov a, b
1066   0AB0 2C 05 00      mov b, [bp + 5] ; y
1067   0AB3 54            add a, b
1068   0AB4 27            mov b, a
1069   0AB5 E4            pop a
1070   0AB6 F9            leave
1071   0AB7 09            ret
1072   0AB8             
1073   0AB8             scann:
1074   0AB8 D2            push bp
1075   0AB9 9B            mov bp, sp
1076   0ABA 52 02 00      sub sp, 2 ; m
1077   0ABD             
1078   0ABD             ; --- BEGIN INLINE ASM BLOCK
1079   0ABD 07 2E 0F      call scan_u16d
1080   0AC0 45 FF FF      mov [bp + -1], a
1081   0AC3             ; --- END INLINE ASM BLOCK
1082   0AC3             
1083   0AC3 FA 05 00      lea d, [bp + 5] ; n
1084   0AC6 2A            mov b, [d]
1085   0AC7 D8            push b
1086   0AC8 2C FF FF      mov b, [bp + -1] ; m
1087   0ACB E7            pop d
1088   0ACC D7            push a
1089   0ACD 11            mov a, b
1090   0ACE 43            mov [d], a
1091   0ACF E4            pop a
1092   0AD0 F9            leave
1093   0AD1 09            ret
1094   0AD2             
1095   0AD2             printn:
1096   0AD2 D2            push bp
1097   0AD3 9B            mov bp, sp
1098   0AD4 FA 07 00      lea d, [bp + 7] ; s
1099   0AD7 2A            mov b, [d]
1100   0AD8 FD AB         swp b
1101   0ADA D8            push b
1102   0ADB 07 E9 0A      call print
1103   0ADE 51 02 00      add sp, 2
1104   0AE1             
1105   0AE1             ; --- BEGIN INLINE ASM BLOCK
1106   0AE1 17 05 00      mov a, [bp + 5]
1107   0AE4 07 59 0E      call print_u16d
1108   0AE7             ; --- END INLINE ASM BLOCK
1109   0AE7             
1110   0AE7 F9            leave
1111   0AE8 09            ret
1112   0AE9             
1113   0AE9             print:
1114   0AE9 D2            push bp
1115   0AEA 9B            mov bp, sp
1116   0AEB             
1117   0AEB             ; --- BEGIN INLINE ASM BLOCK
1118   0AEB 17 05 00      mov a, [bp + 5]
1119   0AEE 3C            mov d, a
1120   0AEF 07 30 0E      call puts
1121   0AF2             ; --- END INLINE ASM BLOCK
1122   0AF2             
1123   0AF2 F9            leave
1124   0AF3 09            ret
1125   0AF4             ; --- END TEXT BLOCK
1126   0AF4             
1127   0AF4             ; --- BEGIN DATA BLOCK
1128   0AF4 00 00       __index: .dw 0
1129   0AF6             __matrix1_data: 
1130   0AF6 01 00 02 00 .dw 1,2,3,4,5,6,7,8,9,
1130   0AFA 03 00 04 00 
1130   0AFE 05 00 06 00 
1130   0B02 07 00 08 00 
1130   0B06 09 00 
1131   0B08             .fill 0, 0
1132   0B08 F6 0A       __matrix1: .dw __matrix1_data
1133   0B0A             __matrix2_data: 
1134   0B0A 09 00 08 00 .dw 9,8,7,6,5,4,3,2,1,
1134   0B0E 07 00 06 00 
1134   0B12 05 00 04 00 
1134   0B16 03 00 02 00 
1134   0B1A 01 00 
1135   0B1C             .fill 0, 0
1136   0B1C 0A 0B       __matrix2: .dw __matrix2_data
1137   0B1E 00 00 00 00 __result1_data: .fill 18, 0
1137   0B22 00 00 00 00 
1137   0B26 00 00 00 00 
1137   0B2A 00 00 00 00 
1137   0B2E 00 00 
1138   0B30 1E 0B       __result1: .dw __result1_data
1139   0B32 00 00 00 00 __result2_data: .fill 18, 0
1139   0B36 00 00 00 00 
1139   0B3A 00 00 00 00 
1139   0B3E 00 00 00 00 
1139   0B42 00 00 
1140   0B44 32 0B       __result2: .dw __result2_data
1141   0B46 00 00 00 00 __result3_data: .fill 18, 0
1141   0B4A 00 00 00 00 
1141   0B4E 00 00 00 00 
1141   0B52 00 00 00 00 
1141   0B56 00 00 
1142   0B58 46 0B       __result3: .dw __result3_data
1143   0B5A 4D 61 74 72 __string_0: .db "Matrix1:\n", 0
1143   0B5E 69 78 31 3A 
1143   0B62 0A 00 
1144   0B64 20 00       __string_1: .db " ", 0
1145   0B66 0A 00       __string_2: .db "\n", 0
1146   0B68 4D 61 74 72 __string_3: .db "Matrix2:\n", 0
1146   0B6C 69 78 32 3A 
1146   0B70 0A 00 
1147   0B72 52 65 73 75 __string_4: .db "Result1 (matrix1 * matrix2):\n", 0
1147   0B76 6C 74 31 20 
1147   0B7A 28 6D 61 74 
1147   0B7E 72 69 78 31 
1147   0B82 20 2A 20 6D 
1147   0B86 61 74 72 69 
1147   0B8A 78 32 29 3A 
1147   0B8E 0A 00 
1148   0B90 52 65 73 75 __string_5: .db "Result2 (matrix1 + matrix2):\n", 0
1148   0B94 6C 74 32 20 
1148   0B98 28 6D 61 74 
1148   0B9C 72 69 78 31 
1148   0BA0 20 2B 20 6D 
1148   0BA4 61 74 72 69 
1148   0BA8 78 32 29 3A 
1148   0BAC 0A 00 
1149   0BAE 52 65 73 75 __string_6: .db "Result3 (matrix2 - matrix1):\n", 0
1149   0BB2 6C 74 33 20 
1149   0BB6 28 6D 61 74 
1149   0BBA 72 69 78 32 
1149   0BBE 20 2D 20 6D 
1149   0BC2 61 74 72 69 
1149   0BC6 78 31 29 3A 
1149   0BCA 0A 00 
1150   0BCC 50 61 73 73 __string_7: .db "Passed.", 0
1150   0BD0 65 64 2E 00 
1151   0BD4 46 41 49 4C __string_8: .db "FAILED.", 0
1151   0BD8 45 44 2E 00 
1152   0BDC 49 6E 64 65 __string_9: .db "Index: ", 0
1152   0BE0 78 3A 20 00 
1153   0BE4             ; --- END DATA BLOCK
1154   0BE4             
1155   0BE4             ; --- BEGIN INCLUDE BLOCK
1156   0BE4             .include "lib/stdio.asm"
0001+  0BE4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0BE4             ; stdio.s
0003+  0BE4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0BE4             .include "lib/string.asm"
0001++ 0BE4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0BE4             ; string.s
0003++ 0BE4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0BE4             
0005++ 0BE4             
0006++ 0BE4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0BE4             ; strrev
0008++ 0BE4             ; reverse a string
0009++ 0BE4             ; D = string address
0010++ 0BE4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0BE4             ; 01234
0012++ 0BE4             strrev:
0013++ 0BE4 4B          	pusha
0014++ 0BE5 07 2B 0C    	call strlen	; length in C
0015++ 0BE8 12          	mov a, c
0016++ 0BE9 AF 01 00    	cmp a, 1
0017++ 0BEC D0 06 0C    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0BEF 7D          	dec a
0019++ 0BF0 FD 4E       	mov si, d	; beginning of string
0020++ 0BF2 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0BF4 59          	add d, a	; end of string
0022++ 0BF5 12          	mov a, c
0023++ 0BF6 FD 9B       	shr a		; divide by 2
0024++ 0BF8 39          	mov c, a	; C now counts the steps
0025++ 0BF9             strrev_L0:
0026++ 0BF9 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0BFA F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0BFB 3E          	mov [d], al	; store left char into right side
0029++ 0BFC 1B          	mov al, bl
0030++ 0BFD F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0BFE 7E          	dec c
0032++ 0BFF 7F          	dec d
0033++ 0C00 C2 00 00    	cmp c, 0
0034++ 0C03 C7 F9 0B    	jne strrev_L0
0035++ 0C06             strrev_end:
0036++ 0C06 4C          	popa
0037++ 0C07 09          	ret
0038++ 0C08             	
0039++ 0C08             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0C08             ; strchr
0041++ 0C08             ; search string in D for char in AL
0042++ 0C08             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0C08             strchr:
0044++ 0C08             strchr_L0:
0045++ 0C08 32          	mov bl, [d]
0046++ 0C09 C1 00       	cmp bl, 0
0047++ 0C0B C6 16 0C    	je strchr_end
0048++ 0C0E BA          	cmp al, bl
0049++ 0C0F C6 16 0C    	je strchr_end
0050++ 0C12 79          	inc d
0051++ 0C13 0A 08 0C    	jmp strchr_L0
0052++ 0C16             strchr_end:
0053++ 0C16 1B          	mov al, bl
0054++ 0C17 09          	ret
0055++ 0C18             
0056++ 0C18             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0C18             ; strstr
0058++ 0C18             ; find sub-string
0059++ 0C18             ; str1 in SI
0060++ 0C18             ; str2 in DI
0061++ 0C18             ; SI points to end of source string
0062++ 0C18             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0C18             strstr:
0064++ 0C18 DB          	push al
0065++ 0C19 DA          	push d
0066++ 0C1A E3          	push di
0067++ 0C1B             strstr_loop:
0068++ 0C1B F3          	cmpsb					; compare a byte of the strings
0069++ 0C1C C7 27 0C    	jne strstr_ret
0070++ 0C1F FC 00 00    	lea d, [di + 0]
0071++ 0C22 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0C24 C7 1B 0C    	jne strstr_loop				; equal chars but not at end
0073++ 0C27             strstr_ret:
0074++ 0C27 F0          	pop di
0075++ 0C28 E7          	pop d
0076++ 0C29 E8          	pop al
0077++ 0C2A 09          	ret
0078++ 0C2B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0C2B             ; length of null terminated string
0080++ 0C2B             ; result in C
0081++ 0C2B             ; pointer in D
0082++ 0C2B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0C2B             strlen:
0084++ 0C2B DA          	push d
0085++ 0C2C 38 00 00    	mov c, 0
0086++ 0C2F             strlen_L1:
0087++ 0C2F BD 00       	cmp byte [d], 0
0088++ 0C31 C6 39 0C    	je strlen_ret
0089++ 0C34 79          	inc d
0090++ 0C35 78          	inc c
0091++ 0C36 0A 2F 0C    	jmp strlen_L1
0092++ 0C39             strlen_ret:
0093++ 0C39 E7          	pop d
0094++ 0C3A 09          	ret
0095++ 0C3B             
0096++ 0C3B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0C3B             ; STRCMP
0098++ 0C3B             ; compare two strings
0099++ 0C3B             ; str1 in SI
0100++ 0C3B             ; str2 in DI
0101++ 0C3B             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0C3B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0C3B             strcmp:
0104++ 0C3B DB          	push al
0105++ 0C3C DA          	push d
0106++ 0C3D E3          	push di
0107++ 0C3E E2          	push si
0108++ 0C3F             strcmp_loop:
0109++ 0C3F F3          	cmpsb					; compare a byte of the strings
0110++ 0C40 C7 4B 0C    	jne strcmp_ret
0111++ 0C43 FB FF FF    	lea d, [si +- 1]
0112++ 0C46 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0C48 C7 3F 0C    	jne strcmp_loop				; equal chars but not at end
0114++ 0C4B             strcmp_ret:
0115++ 0C4B EF          	pop si
0116++ 0C4C F0          	pop di
0117++ 0C4D E7          	pop d
0118++ 0C4E E8          	pop al
0119++ 0C4F 09          	ret
0120++ 0C50             
0121++ 0C50             
0122++ 0C50             ; STRCPY
0123++ 0C50             ; copy null terminated string from SI to DI
0124++ 0C50             ; source in SI
0125++ 0C50             ; destination in DI
0126++ 0C50             strcpy:
0127++ 0C50 E2          	push si
0128++ 0C51 E3          	push di
0129++ 0C52 DB          	push al
0130++ 0C53             strcpy_L1:
0131++ 0C53 F6          	lodsb
0132++ 0C54 F7          	stosb
0133++ 0C55 B9 00       	cmp al, 0
0134++ 0C57 C7 53 0C    	jne strcpy_L1
0135++ 0C5A             strcpy_end:
0136++ 0C5A E8          	pop al
0137++ 0C5B F0          	pop di
0138++ 0C5C EF          	pop si
0139++ 0C5D 09          	ret
0140++ 0C5E             
0141++ 0C5E             ; STRCAT
0142++ 0C5E             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0C5E             ; source in SI
0144++ 0C5E             ; destination in DI
0145++ 0C5E             strcat:
0146++ 0C5E E2          	push si
0147++ 0C5F E3          	push di
0148++ 0C60 D7          	push a
0149++ 0C61 DA          	push d
0150++ 0C62 50          	mov a, di
0151++ 0C63 3C          	mov d, a
0152++ 0C64             strcat_goto_end_L1:
0153++ 0C64 BD 00       	cmp byte[d], 0
0154++ 0C66 C6 6D 0C    	je strcat_start
0155++ 0C69 79          	inc d
0156++ 0C6A 0A 64 0C    	jmp strcat_goto_end_L1
0157++ 0C6D             strcat_start:
0158++ 0C6D FD 50       	mov di, d
0159++ 0C6F             strcat_L1:
0160++ 0C6F F6          	lodsb
0161++ 0C70 F7          	stosb
0162++ 0C71 B9 00       	cmp al, 0
0163++ 0C73 C7 6F 0C    	jne strcat_L1
0164++ 0C76             strcat_end:
0165++ 0C76 E7          	pop d
0166++ 0C77 E4          	pop a
0167++ 0C78 F0          	pop di
0168++ 0C79 EF          	pop si
0169++ 0C7A 09          	ret
0005+  0C7B             
0006+  0C7B 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  0C7F 34 35 36 37 
0006+  0C83 38 39 41 42 
0006+  0C87 43 44 45 46 
0007+  0C8B 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  0C8F 1B 5B 48 00 
0008+  0C93             
0009+  0C93 01 00       table_power:.dw 1
0010+  0C95 0A 00       			.dw 10
0011+  0C97 64 00       			.dw 100
0012+  0C99 E8 03       			.dw 1000
0013+  0C9B 10 27       			.dw 10000
0014+  0C9D             
0015+  0C9D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  0C9D             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  0C9D             ; ASCII in BL
0018+  0C9D             ; result in AL
0019+  0C9D             ; ascii for F = 0100 0110
0020+  0C9D             ; ascii for 9 = 0011 1001
0021+  0C9D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  0C9D             hex_ascii_encode:
0023+  0C9D 1B          	mov al, bl
0024+  0C9E 93 40       	test al, $40				; test if letter or number
0025+  0CA0 C7 A6 0C    	jnz hex_letter
0026+  0CA3 87 0F       	and al, $0F				; get number
0027+  0CA5 09          	ret
0028+  0CA6             hex_letter:
0029+  0CA6 87 0F       	and al, $0F				; get letter
0030+  0CA8 6A 09       	add al, 9
0031+  0CAA 09          	ret
0032+  0CAB             
0033+  0CAB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  0CAB             ; ATOI
0035+  0CAB             ; 2 letter hex string in B
0036+  0CAB             ; 8bit integer returned in AL
0037+  0CAB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0CAB             atoi:
0039+  0CAB D8          	push b
0040+  0CAC 07 9D 0C    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  0CAF 30          	mov bl, bh
0042+  0CB0 DB          	push al					; save a
0043+  0CB1 07 9D 0C    	call hex_ascii_encode
0044+  0CB4 EA          	pop bl	
0045+  0CB5 FD 9E 04    	shl al, 4
0046+  0CB8 8C          	or al, bl
0047+  0CB9 E5          	pop b
0048+  0CBA 09          	ret	
0049+  0CBB             
0050+  0CBB             
0051+  0CBB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  0CBB             ; printf
0053+  0CBB             ; no need for explanations!
0054+  0CBB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0CBB             printf:
0056+  0CBB 09          	ret
0057+  0CBC             
0058+  0CBC             
0059+  0CBC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  0CBC             ; scanf
0061+  0CBC             ; no need for explanations!
0062+  0CBC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  0CBC             scanf:
0064+  0CBC 09          	ret
0065+  0CBD             
0066+  0CBD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  0CBD             ; ITOA
0068+  0CBD             ; 8bit value in BL
0069+  0CBD             ; 2 byte ASCII result in A
0070+  0CBD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  0CBD             itoa:
0072+  0CBD DA          	push d
0073+  0CBE D8          	push b
0074+  0CBF A7 00       	mov bh, 0
0075+  0CC1 FD A4 04    	shr bl, 4	
0076+  0CC4 74          	mov d, b
0077+  0CC5 1F 7B 0C    	mov al, [d + s_hex_digits]
0078+  0CC8 23          	mov ah, al
0079+  0CC9             	
0080+  0CC9 E5          	pop b
0081+  0CCA D8          	push b
0082+  0CCB A7 00       	mov bh, 0
0083+  0CCD FD 87 0F    	and bl, $0F
0084+  0CD0 74          	mov d, b
0085+  0CD1 1F 7B 0C    	mov al, [d + s_hex_digits]
0086+  0CD4 E5          	pop b
0087+  0CD5 E7          	pop d
0088+  0CD6 09          	ret
0089+  0CD7             
0090+  0CD7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  0CD7             ; HEX STRING TO BINARY
0092+  0CD7             ; di = destination address
0093+  0CD7             ; si = source
0094+  0CD7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  0CD7             hex_to_int:
0096+  0CD7             hex_to_int_L1:
0097+  0CD7 F6          	lodsb					; load from [SI] to AL
0098+  0CD8 B9 00       	cmp al, 0				; check if ASCII 0
0099+  0CDA C6 E7 0C    	jz hex_to_int_ret
0100+  0CDD 36          	mov bh, al
0101+  0CDE F6          	lodsb
0102+  0CDF 2F          	mov bl, al
0103+  0CE0 07 AB 0C    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  0CE3 F7          	stosb					; store AL to [DI]
0105+  0CE4 0A D7 0C    	jmp hex_to_int_L1
0106+  0CE7             hex_to_int_ret:
0107+  0CE7 09          	ret		
0108+  0CE8             
0109+  0CE8             
0110+  0CE8             
0111+  0CE8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  0CE8             ; GETCHAR
0113+  0CE8             ; char in ah
0114+  0CE8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  0CE8             getchar:
0116+  0CE8 DB          	push al
0117+  0CE9             getchar_retry:
0118+  0CE9 FD 0C       	sti
0119+  0CEB 19 01       	mov al, 1
0120+  0CED 05 03       	syscall sys_io			; receive in AH
0121+  0CEF B9 00       	cmp al, 0			; check if any char was receive
0122+  0CF1 C6 E9 0C    	je getchar_retry
0123+  0CF4 E8          	pop al
0124+  0CF5 09          	ret
0125+  0CF6             
0126+  0CF6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  0CF6             ; PUTCHAR
0128+  0CF6             ; char in ah
0129+  0CF6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0CF6             putchar:
0131+  0CF6 D7          	push a
0132+  0CF7 19 00       	mov al, 0
0133+  0CF9 05 03       	syscall sys_io			; char in AH
0134+  0CFB E4          	pop a
0135+  0CFC 09          	ret
0136+  0CFD             
0137+  0CFD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  0CFD             ;; INPUT A STRING
0139+  0CFD             ;; terminates with null
0140+  0CFD             ;; pointer in D
0141+  0CFD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  0CFD             gets:
0143+  0CFD D7          	push a
0144+  0CFE DA          	push d
0145+  0CFF             gets_loop:
0146+  0CFF FD 0C       	sti
0147+  0D01 19 01       	mov al, 1
0148+  0D03 05 03       	syscall sys_io			; receive in AH
0149+  0D05 B9 00       	cmp al, 0				; check error code (AL)
0150+  0D07 C6 FF 0C    	je gets_loop			; if no char received, retry
0151+  0D0A             
0152+  0D0A 76 1B       	cmp ah, 27
0153+  0D0C C6 2D 0D    	je gets_telnet_escape
0154+  0D0F 76 0A       	cmp ah, $0A				; LF
0155+  0D11 C6 86 0D    	je gets_end
0156+  0D14 76 0D       	cmp ah, $0D				; CR
0157+  0D16 C6 86 0D    	je gets_end
0158+  0D19 76 5C       	cmp ah, $5C				; '\\'
0159+  0D1B C6 5D 0D    	je gets_escape
0160+  0D1E             	
0161+  0D1E 76 08       	cmp ah, $08			; check for backspace
0162+  0D20 C6 29 0D    	je gets_backspace
0163+  0D23             
0164+  0D23 1A          	mov al, ah
0165+  0D24 3E          	mov [d], al
0166+  0D25 79          	inc d
0167+  0D26 0A FF 0C    	jmp gets_loop
0168+  0D29             gets_backspace:
0169+  0D29 7F          	dec d
0170+  0D2A 0A FF 0C    	jmp gets_loop
0171+  0D2D             gets_telnet_escape:
0172+  0D2D FD 0C       	sti
0173+  0D2F 19 01       	mov al, 1
0174+  0D31 05 03       	syscall sys_io				; receive in AH without echo
0175+  0D33 B9 00       	cmp al, 0					; check error code (AL)
0176+  0D35 C6 2D 0D    	je gets_telnet_escape		; if no char received, retry
0177+  0D38 76 5B       	cmp ah, '['
0178+  0D3A C7 FF 0C    	jne gets_loop
0179+  0D3D             gets_telnet_escape_phase2:
0180+  0D3D FD 0C       	sti
0181+  0D3F 19 01       	mov al, 1
0182+  0D41 05 03       	syscall sys_io					; receive in AH without echo
0183+  0D43 B9 00       	cmp al, 0						; check error code (AL)
0184+  0D45 C6 3D 0D    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  0D48 76 44       	cmp ah, 'D'
0186+  0D4A C6 55 0D    	je gets_left_arrow
0187+  0D4D 76 43       	cmp ah, 'C'
0188+  0D4F C6 59 0D    	je gets_right_arrow
0189+  0D52 0A FF 0C    	jmp gets_loop
0190+  0D55             gets_left_arrow:
0191+  0D55 7F          	dec d
0192+  0D56 0A FF 0C    	jmp gets_loop
0193+  0D59             gets_right_arrow:
0194+  0D59 79          	inc d
0195+  0D5A 0A FF 0C    	jmp gets_loop
0196+  0D5D             gets_escape:
0197+  0D5D FD 0C       	sti
0198+  0D5F 19 01       	mov al, 1
0199+  0D61 05 03       	syscall sys_io			; receive in AH
0200+  0D63 B9 00       	cmp al, 0				; check error code (AL)
0201+  0D65 C6 5D 0D    	je gets_escape			; if no char received, retry
0202+  0D68 76 6E       	cmp ah, 'n'
0203+  0D6A C6 78 0D    	je gets_LF
0204+  0D6D 76 72       	cmp ah, 'r'
0205+  0D6F C6 7F 0D    	je gets_CR
0206+  0D72 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  0D73 3E          	mov [d], al
0208+  0D74 79          	inc d
0209+  0D75 0A FF 0C    	jmp gets_loop
0210+  0D78             gets_LF:
0211+  0D78 19 0A       	mov al, $0A
0212+  0D7A 3E          	mov [d], al
0213+  0D7B 79          	inc d
0214+  0D7C 0A FF 0C    	jmp gets_loop
0215+  0D7F             gets_CR:
0216+  0D7F 19 0D       	mov al, $0D
0217+  0D81 3E          	mov [d], al
0218+  0D82 79          	inc d
0219+  0D83 0A FF 0C    	jmp gets_loop
0220+  0D86             gets_end:
0221+  0D86 19 00       	mov al, 0
0222+  0D88 3E          	mov [d], al				; terminate string
0223+  0D89 E7          	pop d
0224+  0D8A E4          	pop a
0225+  0D8B 09          	ret
0226+  0D8C             
0227+  0D8C             
0228+  0D8C             
0229+  0D8C             
0230+  0D8C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  0D8C             ;; INPUT TEXT
0232+  0D8C             ;; terminated with CTRL+D
0233+  0D8C             ;; pointer in D
0234+  0D8C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  0D8C             gettxt:
0236+  0D8C D7          	push a
0237+  0D8D DA          	push d
0238+  0D8E             gettxt_loop:
0239+  0D8E 19 01       	mov al, 1
0240+  0D90 05 03       	syscall sys_io			; receive in AH
0241+  0D92 B9 00       	cmp al, 0				; check error code (AL)
0242+  0D94 C6 8E 0D    	je gettxt_loop		; if no char received, retry
0243+  0D97 76 04       	cmp ah, 4			; EOT
0244+  0D99 C6 D7 0D    	je gettxt_end
0245+  0D9C 76 08       	cmp ah, $08			; check for backspace
0246+  0D9E C6 D3 0D    	je gettxt_backspace
0247+  0DA1 76 5C       	cmp ah, $5C				; '\\'
0248+  0DA3 C6 AC 0D    	je gettxt_escape
0249+  0DA6 1A          	mov al, ah
0250+  0DA7 3E          	mov [d], al
0251+  0DA8 79          	inc d
0252+  0DA9 0A 8E 0D    	jmp gettxt_loop
0253+  0DAC             gettxt_escape:
0254+  0DAC 19 01       	mov al, 1
0255+  0DAE 05 03       	syscall sys_io			; receive in AH
0256+  0DB0 B9 00       	cmp al, 0				; check error code (AL)
0257+  0DB2 C6 AC 0D    	je gettxt_escape		; if no char received, retry
0258+  0DB5 76 6E       	cmp ah, 'n'
0259+  0DB7 C6 C5 0D    	je gettxt_LF
0260+  0DBA 76 72       	cmp ah, 'r'
0261+  0DBC C6 CC 0D    	je gettxt_CR
0262+  0DBF 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  0DC0 3E          	mov [d], al
0264+  0DC1 79          	inc d
0265+  0DC2 0A 8E 0D    	jmp gettxt_loop
0266+  0DC5             gettxt_LF:
0267+  0DC5 19 0A       	mov al, $0A
0268+  0DC7 3E          	mov [d], al
0269+  0DC8 79          	inc d
0270+  0DC9 0A 8E 0D    	jmp gettxt_loop
0271+  0DCC             gettxt_CR:
0272+  0DCC 19 0D       	mov al, $0D
0273+  0DCE 3E          	mov [d], al
0274+  0DCF 79          	inc d
0275+  0DD0 0A 8E 0D    	jmp gettxt_loop
0276+  0DD3             gettxt_backspace:
0277+  0DD3 7F          	dec d
0278+  0DD4 0A 8E 0D    	jmp gettxt_loop
0279+  0DD7             gettxt_end:
0280+  0DD7 19 00       	mov al, 0
0281+  0DD9 3E          	mov [d], al				; terminate string
0282+  0DDA E7          	pop d
0283+  0DDB E4          	pop a
0284+  0DDC 09          	ret
0285+  0DDD             
0286+  0DDD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  0DDD             ; PRINT NEW LINE
0288+  0DDD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  0DDD             printnl:
0290+  0DDD D7          	push a
0291+  0DDE 10 00 0A    	mov a, $0A00
0292+  0DE1 05 03       	syscall sys_io
0293+  0DE3 10 00 0D    	mov a, $0D00
0294+  0DE6 05 03       	syscall sys_io
0295+  0DE8 E4          	pop a
0296+  0DE9 09          	ret
0297+  0DEA             
0298+  0DEA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  0DEA             ; strtoint
0300+  0DEA             ; 4 digit hex string number in d
0301+  0DEA             ; integer returned in A
0302+  0DEA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  0DEA             strtointx:
0304+  0DEA D8          	push b
0305+  0DEB 32          	mov bl, [d]
0306+  0DEC 37          	mov bh, bl
0307+  0DED 33 01 00    	mov bl, [d + 1]
0308+  0DF0 07 AB 0C    	call atoi				; convert to int in AL
0309+  0DF3 23          	mov ah, al				; move to AH
0310+  0DF4 33 02 00    	mov bl, [d + 2]
0311+  0DF7 37          	mov bh, bl
0312+  0DF8 33 03 00    	mov bl, [d + 3]
0313+  0DFB 07 AB 0C    	call atoi				; convert to int in AL
0314+  0DFE E5          	pop b
0315+  0DFF 09          	ret
0316+  0E00             
0317+  0E00             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  0E00             ; strtoint
0319+  0E00             ; 5 digit base10 string number in d
0320+  0E00             ; integer returned in A
0321+  0E00             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  0E00             strtoint:
0323+  0E00 E2          	push si
0324+  0E01 D8          	push b
0325+  0E02 D9          	push c
0326+  0E03 DA          	push d
0327+  0E04 07 2B 0C    	call strlen			; get string length in C
0328+  0E07 7E          	dec c
0329+  0E08 FD 4E       	mov si, d
0330+  0E0A 12          	mov a, c
0331+  0E0B FD 99       	shl a
0332+  0E0D 3B 93 0C    	mov d, table_power
0333+  0E10 59          	add d, a
0334+  0E11 38 00 00    	mov c, 0
0335+  0E14             strtoint_L0:
0336+  0E14 F6          	lodsb			; load ASCII to al
0337+  0E15 B9 00       	cmp al, 0
0338+  0E17 C6 2A 0E    	je strtoint_end
0339+  0E1A 6F 30       	sub al, $30		; make into integer
0340+  0E1C 22 00       	mov ah, 0
0341+  0E1E 2A          	mov b, [d]
0342+  0E1F AC          	mul a, b			; result in B since it fits in 16bits
0343+  0E20 11          	mov a, b
0344+  0E21 28          	mov b, c
0345+  0E22 54          	add a, b
0346+  0E23 39          	mov c, a
0347+  0E24 63 02 00    	sub d, 2
0348+  0E27 0A 14 0E    	jmp strtoint_L0
0349+  0E2A             strtoint_end:
0350+  0E2A 12          	mov a, c
0351+  0E2B E7          	pop d
0352+  0E2C E6          	pop c
0353+  0E2D E5          	pop b
0354+  0E2E EF          	pop si
0355+  0E2F 09          	ret
0356+  0E30             
0357+  0E30             
0358+  0E30             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  0E30             ; PRINT NULL TERMINATED STRING
0360+  0E30             ; pointer in D
0361+  0E30             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  0E30             puts:
0363+  0E30 D7          	push a
0364+  0E31 DA          	push d
0365+  0E32             puts_L1:
0366+  0E32 1E          	mov al, [d]
0367+  0E33 B9 00       	cmp al, 0
0368+  0E35 C6 41 0E    	jz puts_END
0369+  0E38 23          	mov ah, al
0370+  0E39 19 00       	mov al, 0
0371+  0E3B 05 03       	syscall sys_io
0372+  0E3D 79          	inc d
0373+  0E3E 0A 32 0E    	jmp puts_L1
0374+  0E41             puts_END:
0375+  0E41 E7          	pop d
0376+  0E42 E4          	pop a
0377+  0E43 09          	ret
0378+  0E44             
0379+  0E44             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  0E44             ; PRINT N SIZE STRING
0381+  0E44             ; pointer in D
0382+  0E44             ; size in C
0383+  0E44             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  0E44             putsn:
0385+  0E44 DB          	push al
0386+  0E45 DA          	push d
0387+  0E46 D9          	push c
0388+  0E47             putsn_L0:
0389+  0E47 1E          	mov al, [d]
0390+  0E48 23          	mov ah, al
0391+  0E49 19 00       	mov al, 0
0392+  0E4B 05 03       	syscall sys_io
0393+  0E4D 79          	inc d
0394+  0E4E 7E          	dec c	
0395+  0E4F C2 00 00    	cmp c, 0
0396+  0E52 C7 47 0E    	jne putsn_L0
0397+  0E55             putsn_end:
0398+  0E55 E6          	pop c
0399+  0E56 E7          	pop d
0400+  0E57 E8          	pop al
0401+  0E58 09          	ret
0402+  0E59             
0403+  0E59             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  0E59             ; print 16bit decimal number
0405+  0E59             ; input number in A
0406+  0E59             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  0E59             print_u16d:
0408+  0E59 D7          	push a
0409+  0E5A D8          	push b
0410+  0E5B 26 10 27    	mov b, 10000
0411+  0E5E AE          	div a, b			; get 10000 coeff.
0412+  0E5F 07 85 0E    	call print_number
0413+  0E62 11          	mov a, b
0414+  0E63 26 E8 03    	mov b, 1000
0415+  0E66 AE          	div a, b			; get 10000 coeff.
0416+  0E67 07 85 0E    	call print_number
0417+  0E6A 11          	mov a, b
0418+  0E6B 26 64 00    	mov b, 100
0419+  0E6E AE          	div a, b
0420+  0E6F 07 85 0E    	call print_number
0421+  0E72 11          	mov a, b
0422+  0E73 26 0A 00    	mov b, 10
0423+  0E76 AE          	div a, b
0424+  0E77 07 85 0E    	call print_number
0425+  0E7A 11          	mov a, b
0426+  0E7B 6A 30       	add al, $30
0427+  0E7D 23          	mov ah, al
0428+  0E7E 19 00       	mov al, 0
0429+  0E80 05 03       	syscall sys_io	; print coeff
0430+  0E82 E5          	pop b
0431+  0E83 E4          	pop a
0432+  0E84 09          	ret
0433+  0E85             
0434+  0E85             
0435+  0E85             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  0E85             ; if A == 0, print space
0437+  0E85             ; else print A
0438+  0E85             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0439+  0E85             print_number:
0440+  0E85 6A 30       	add al, $30
0441+  0E87 23          	mov ah, al
0442+  0E88 07 F6 0C    	call putchar
0443+  0E8B 09          	ret
0444+  0E8C             
0445+  0E8C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0446+  0E8C             ; PRINT 16BIT HEX INTEGER
0447+  0E8C             ; integer value in reg B
0448+  0E8C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  0E8C             print_u16x:
0450+  0E8C D7          	push a
0451+  0E8D D8          	push b
0452+  0E8E DD          	push bl
0453+  0E8F 30          	mov bl, bh
0454+  0E90 07 BD 0C    	call itoa				; convert bh to char in A
0455+  0E93 2F          	mov bl, al				; save al
0456+  0E94 19 00       	mov al, 0
0457+  0E96 05 03       	syscall sys_io				; display AH
0458+  0E98 24          	mov ah, bl				; retrieve al
0459+  0E99 19 00       	mov al, 0
0460+  0E9B 05 03       	syscall sys_io				; display AL
0461+  0E9D             
0462+  0E9D EA          	pop bl
0463+  0E9E 07 BD 0C    	call itoa				; convert bh to char in A
0464+  0EA1 2F          	mov bl, al				; save al
0465+  0EA2 19 00       	mov al, 0
0466+  0EA4 05 03       	syscall sys_io				; display AH
0467+  0EA6 24          	mov ah, bl				; retrieve al
0468+  0EA7 19 00       	mov al, 0
0469+  0EA9 05 03       	syscall sys_io				; display AL
0470+  0EAB             
0471+  0EAB E5          	pop b
0472+  0EAC E4          	pop a
0473+  0EAD 09          	ret
0474+  0EAE             
0475+  0EAE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  0EAE             ; INPUT 16BIT HEX INTEGER
0477+  0EAE             ; read 16bit integer into A
0478+  0EAE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  0EAE             scan_u16x:
0480+  0EAE F8 10 00    	enter 16
0481+  0EB1 D8          	push b
0482+  0EB2 DA          	push d
0483+  0EB3             
0484+  0EB3 FA F1 FF    	lea d, [bp + -15]
0485+  0EB6 07 FD 0C    	call gets				; get number
0486+  0EB9             
0487+  0EB9 32          	mov bl, [d]
0488+  0EBA 37          	mov bh, bl
0489+  0EBB 33 01 00    	mov bl, [d + 1]
0490+  0EBE 07 AB 0C    	call atoi				; convert to int in AL
0491+  0EC1 23          	mov ah, al				; move to AH
0492+  0EC2             
0493+  0EC2 33 02 00    	mov bl, [d + 2]
0494+  0EC5 37          	mov bh, bl
0495+  0EC6 33 03 00    	mov bl, [d + 3]
0496+  0EC9 07 AB 0C    	call atoi				; convert to int in AL
0497+  0ECC             
0498+  0ECC E7          	pop d
0499+  0ECD E5          	pop b
0500+  0ECE F9          	leave
0501+  0ECF 09          	ret
0502+  0ED0             
0503+  0ED0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0504+  0ED0             ; PRINT 8bit HEX INTEGER
0505+  0ED0             ; integer value in reg bl
0506+  0ED0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  0ED0             print_u8x:
0508+  0ED0 D7          	push a
0509+  0ED1 DD          	push bl
0510+  0ED2             
0511+  0ED2 07 BD 0C    	call itoa				; convert bl to char in A
0512+  0ED5 2F          	mov bl, al				; save al
0513+  0ED6 19 00       	mov al, 0
0514+  0ED8 05 03       	syscall sys_io				; display AH
0515+  0EDA 24          	mov ah, bl				; retrieve al
0516+  0EDB 19 00       	mov al, 0
0517+  0EDD 05 03       	syscall sys_io				; display AL
0518+  0EDF             
0519+  0EDF EA          	pop bl
0520+  0EE0 E4          	pop a
0521+  0EE1 09          	ret
0522+  0EE2             
0523+  0EE2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0524+  0EE2             ; print 8bit decimal unsigned number
0525+  0EE2             ; input number in AL
0526+  0EE2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  0EE2             print_u8d:
0528+  0EE2 D7          	push a
0529+  0EE3 D8          	push b
0530+  0EE4             
0531+  0EE4 22 00       	mov ah, 0
0532+  0EE6 26 64 00    	mov b, 100
0533+  0EE9 AE          	div a, b
0534+  0EEA D8          	push b			; save remainder
0535+  0EEB B9 00       	cmp al, 0
0536+  0EED C6 F7 0E    	je skip100
0537+  0EF0 6A 30       	add al, $30
0538+  0EF2 23          	mov ah, al
0539+  0EF3 19 00       	mov al, 0
0540+  0EF5 05 03       	syscall sys_io	; print coeff
0541+  0EF7             skip100:
0542+  0EF7 E4          	pop a
0543+  0EF8 22 00       	mov ah, 0
0544+  0EFA 26 0A 00    	mov b, 10
0545+  0EFD AE          	div a, b
0546+  0EFE D8          	push b			; save remainder
0547+  0EFF B9 00       	cmp al, 0
0548+  0F01 C6 0B 0F    	je skip10
0549+  0F04 6A 30       	add al, $30
0550+  0F06 23          	mov ah, al
0551+  0F07 19 00       	mov al, 0
0552+  0F09 05 03       	syscall sys_io	; print coeff
0553+  0F0B             skip10:
0554+  0F0B E4          	pop a
0555+  0F0C 1B          	mov al, bl
0556+  0F0D 6A 30       	add al, $30
0557+  0F0F 23          	mov ah, al
0558+  0F10 19 00       	mov al, 0
0559+  0F12 05 03       	syscall sys_io	; print coeff
0560+  0F14 E5          	pop b
0561+  0F15 E4          	pop a
0562+  0F16 09          	ret
0563+  0F17             
0564+  0F17             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0565+  0F17             ; INPUT 8BIT HEX INTEGER
0566+  0F17             ; read 8bit integer into AL
0567+  0F17             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  0F17             scan_u8x:
0569+  0F17 F8 04 00    	enter 4
0570+  0F1A D8          	push b
0571+  0F1B DA          	push d
0572+  0F1C             
0573+  0F1C FA FD FF    	lea d, [bp + -3]
0574+  0F1F 07 FD 0C    	call gets				; get number
0575+  0F22             
0576+  0F22 32          	mov bl, [d]
0577+  0F23 37          	mov bh, bl
0578+  0F24 33 01 00    	mov bl, [d + 1]
0579+  0F27 07 AB 0C    	call atoi				; convert to int in AL
0580+  0F2A             
0581+  0F2A E7          	pop d
0582+  0F2B E5          	pop b
0583+  0F2C F9          	leave
0584+  0F2D 09          	ret
0585+  0F2E             
0586+  0F2E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  0F2E             ; input decimal number
0588+  0F2E             ; result in A
0589+  0F2E             ; 655'\0'
0590+  0F2E             ; low--------high
0591+  0F2E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0592+  0F2E             scan_u16d:
0593+  0F2E F8 08 00    	enter 8
0594+  0F31 E2          	push si
0595+  0F32 D8          	push b
0596+  0F33 D9          	push c
0597+  0F34 DA          	push d
0598+  0F35 FA F9 FF    	lea d, [bp +- 7]
0599+  0F38 07 FD 0C    	call gets
0600+  0F3B 07 2B 0C    	call strlen			; get string length in C
0601+  0F3E 7E          	dec c
0602+  0F3F FD 4E       	mov si, d
0603+  0F41 12          	mov a, c
0604+  0F42 FD 99       	shl a
0605+  0F44 3B 93 0C    	mov d, table_power
0606+  0F47 59          	add d, a
0607+  0F48 38 00 00    	mov c, 0
0608+  0F4B             mul_loop:
0609+  0F4B F6          	lodsb			; load ASCII to al
0610+  0F4C B9 00       	cmp al, 0
0611+  0F4E C6 61 0F    	je mul_exit
0612+  0F51 6F 30       	sub al, $30		; make into integer
0613+  0F53 22 00       	mov ah, 0
0614+  0F55 2A          	mov b, [d]
0615+  0F56 AC          	mul a, b			; result in B since it fits in 16bits
0616+  0F57 11          	mov a, b
0617+  0F58 28          	mov b, c
0618+  0F59 54          	add a, b
0619+  0F5A 39          	mov c, a
0620+  0F5B 63 02 00    	sub d, 2
0621+  0F5E 0A 4B 0F    	jmp mul_loop
0622+  0F61             mul_exit:
0623+  0F61 12          	mov a, c
0624+  0F62 E7          	pop d
0625+  0F63 E6          	pop c
0626+  0F64 E5          	pop b
0627+  0F65 EF          	pop si
0628+  0F66 F9          	leave
0629+  0F67 09          	ret
1157   0F68             ; --- END INCLUDE BLOCK
1158   0F68             
1159   0F68             
1160   0F68             .end
tasm: Number of errors = 0
