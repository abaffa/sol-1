0001   0000             ; --- FILENAME: polish.c
0002   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0400             .org PROC_TEXT_ORG
0004   0400             
0005   0400             ; --- BEGIN TEXT BLOCK
0006   0400             
0007   0400             main:
0008   0400 D2            push bp
0009   0401 9B            mov bp, sp
0010   0402 52 02 00      sub sp, 2 ; type
0011   0405 52 02 00      sub sp, 2 ; op2
0012   0408 52 64 00      sub sp, 100 ; s
0013   040B             _while1_cond:
0014   040B FA 99 FF      lea d, [bp + -103] ; s_data
0015   040E 2D            mov b, d
0016   040F FD AB         swp b
0017   0411 D8            push b
0018   0412 07 0B 06      call getop
0019   0415 51 02 00      add sp, 2
0020   0418 D7            push a
0021   0419 11            mov a, b
0022   041A 45 FF FF      mov [bp + -1], a ; type
0023   041D E4            pop a
0024   041E D7            push a
0025   041F 11            mov a, b
0026   0420 26 24 00      mov b, '$'
0027   0423 B0            cmp a, b
0028   0424 0E            lodflgs
0029   0425 87 01         and al, %00000001
0030   0427 8F 01         xor al, %00000001 ; !=
0031   0429 22 00         mov ah, 0
0032   042B 27            mov b, a
0033   042C E4            pop a
0034   042D C0 00 00      cmp b, 0
0035   0430 C6 50 05      je _while1_exit
0036   0433             _while1_block:
0037   0433             _switch2_expr:
0038   0433 2C FF FF      mov b, [bp + -1] ; type
0039   0436             _switch2_comparisons:
0040   0436 C0 E7 03      cmp b, 999
0041   0439 C6 59 04      je _switch2_case0
0042   043C C1 2B         cmp bl, '+'
0043   043E C6 72 04      je _switch2_case1
0044   0441 C1 2A         cmp bl, '*'
0045   0443 C6 89 04      je _switch2_case2
0046   0446 C1 2D         cmp bl, '-'
0047   0448 C6 9F 04      je _switch2_case3
0048   044B C1 2F         cmp bl, '/'
0049   044D C6 BF 04      je _switch2_case4
0050   0450 C0 0A 00      cmp b, 10
0051   0453 C6 0A 05      je _switch2_case5
0052   0456 0A 25 05      jmp _switch2_default
0053   0459             _switch2_case0:
0054   0459 FA 99 FF      lea d, [bp + -103] ; s_data
0055   045C 2D            mov b, d
0056   045D FD AB         swp b
0057   045F D8            push b
0058   0460 07 56 05      call _atoi
0059   0463 51 02 00      add sp, 2
0060   0466 FD AB         swp b
0061   0468 D8            push b
0062   0469 07 6B 05      call _push
0063   046C 51 02 00      add sp, 2
0064   046F 0A 4D 05      jmp _switch2_exit ; case break
0065   0472             _switch2_case1:
0066   0472 07 C0 05      call _pop
0067   0475 D7            push a
0068   0476 11            mov a, b
0069   0477 07 C0 05      call _pop
0070   047A 54            add a, b
0071   047B 27            mov b, a
0072   047C E4            pop a
0073   047D FD AB         swp b
0074   047F D8            push b
0075   0480 07 6B 05      call _push
0076   0483 51 02 00      add sp, 2
0077   0486 0A 4D 05      jmp _switch2_exit ; case break
0078   0489             _switch2_case2:
0079   0489 07 C0 05      call _pop
0080   048C D7            push a
0081   048D 11            mov a, b
0082   048E 07 C0 05      call _pop
0083   0491 AC            mul a, b
0084   0492 E4            pop a
0085   0493 FD AB         swp b
0086   0495 D8            push b
0087   0496 07 6B 05      call _push
0088   0499 51 02 00      add sp, 2
0089   049C 0A 4D 05      jmp _switch2_exit ; case break
0090   049F             _switch2_case3:
0091   049F 07 C0 05      call _pop
0092   04A2 D7            push a
0093   04A3 11            mov a, b
0094   04A4 45 FD FF      mov [bp + -3], a ; op2
0095   04A7 E4            pop a
0096   04A8 07 C0 05      call _pop
0097   04AB D7            push a
0098   04AC 11            mov a, b
0099   04AD 2C FD FF      mov b, [bp + -3] ; op2
0100   04B0 60            sub a, b
0101   04B1 27            mov b, a
0102   04B2 E4            pop a
0103   04B3 FD AB         swp b
0104   04B5 D8            push b
0105   04B6 07 6B 05      call _push
0106   04B9 51 02 00      add sp, 2
0107   04BC 0A 4D 05      jmp _switch2_exit ; case break
0108   04BF             _switch2_case4:
0109   04BF 07 C0 05      call _pop
0110   04C2 D7            push a
0111   04C3 11            mov a, b
0112   04C4 45 FD FF      mov [bp + -3], a ; op2
0113   04C7 E4            pop a
0114   04C8             _if3_cond:
0115   04C8 2C FD FF      mov b, [bp + -3] ; op2
0116   04CB D7            push a
0117   04CC 11            mov a, b
0118   04CD 26 00 00      mov b, 0
0119   04D0 B0            cmp a, b
0120   04D1 0E            lodflgs
0121   04D2 87 01         and al, %00000001
0122   04D4 8F 01         xor al, %00000001 ; !=
0123   04D6 22 00         mov ah, 0
0124   04D8 27            mov b, a
0125   04D9 E4            pop a
0126   04DA C0 00 00      cmp b, 0
0127   04DD C6 FB 04      je _if3_else
0128   04E0             _if3_true:
0129   04E0 07 C0 05      call _pop
0130   04E3 D7            push a
0131   04E4 11            mov a, b
0132   04E5 2C FD FF      mov b, [bp + -3] ; op2
0133   04E8 AE            div a, b
0134   04E9 FD 78         mov g, a
0135   04EB 11            mov a, b
0136   04EC FD 27         mov b, g
0137   04EE E4            pop a
0138   04EF FD AB         swp b
0139   04F1 D8            push b
0140   04F2 07 6B 05      call _push
0141   04F5 51 02 00      add sp, 2
0142   04F8 0A 07 05      jmp _if3_exit
0143   04FB             _if3_else:
0144   04FB 26 7B 09      mov b, _string_0 ; "Divide by zero error\n"
0145   04FE FD AB         swp b
0146   0500 D8            push b
0147   0501 07 3C 08      call print
0148   0504 51 02 00      add sp, 2
0149   0507             _if3_exit:
0150   0507 0A 4D 05      jmp _switch2_exit ; case break
0151   050A             _switch2_case5:
0152   050A 07 C0 05      call _pop
0153   050D FD AB         swp b
0154   050F D8            push b
0155   0510 07 32 08      call printn
0156   0513 51 02 00      add sp, 2
0157   0516 26 91 09      mov b, _string_1 ; "\n"
0158   0519 FD AB         swp b
0159   051B D8            push b
0160   051C 07 3C 08      call print
0161   051F 51 02 00      add sp, 2
0162   0522 0A 4D 05      jmp _switch2_exit ; case break
0163   0525             _switch2_default:
0164   0525 26 93 09      mov b, _string_2 ; "Unknown input: "
0165   0528 FD AB         swp b
0166   052A D8            push b
0167   052B 07 3C 08      call print
0168   052E 51 02 00      add sp, 2
0169   0531 FA 99 FF      lea d, [bp + -103] ; s_data
0170   0534 2D            mov b, d
0171   0535 FD AB         swp b
0172   0537 D8            push b
0173   0538 07 3C 08      call print
0174   053B 51 02 00      add sp, 2
0175   053E 26 91 09      mov b, _string_1 ; "\n"
0176   0541 FD AB         swp b
0177   0543 D8            push b
0178   0544 07 3C 08      call print
0179   0547 51 02 00      add sp, 2
0180   054A 0A 4D 05      jmp _switch2_exit ; case break
0181   054D             _switch2_exit:
0182   054D 0A 0B 04      jmp _while1_cond
0183   0550             _while1_exit:
0184   0550 26 00 00      mov b, 0
0185   0553 F9            leave
0186   0554 05 0B         syscall sys_terminate_proc
0187   0556             
0188   0556             _atoi:
0189   0556 D2            push bp
0190   0557 9B            mov bp, sp
0191   0558 52 02 00      sub sp, 2 ; n
0192   055B             
0193   055B             ; --- BEGIN INLINE ASM BLOCK
0194   055B FA 05 00      lea d, [bp + 5]
0195   055E 15            mov a, [d]
0196   055F 3C            mov d, a
0197   0560 07 11 0C      call strtoint
0198   0563 45 FF FF      mov [bp + -1], a
0199   0566             ; --- END INLINE ASM BLOCK
0200   0566             
0201   0566 2C FF FF      mov b, [bp + -1] ; n
0202   0569 F9            leave
0203   056A 09            ret
0204   056B             
0205   056B             _push:
0206   056B D2            push bp
0207   056C 9B            mov bp, sp
0208   056D             _if4_cond:
0209   056D 29 47 08      mov b, [_sp] ; _sp
0210   0570 D7            push a
0211   0571 11            mov a, b
0212   0572 26 64 00      mov b, 100
0213   0575 B0            cmp a, b
0214   0576 0E            lodflgs
0215   0577 87 02         and al, %00000010 ; <
0216   0579 FD 9C         shr al
0217   057B 22 00         mov ah, 0
0218   057D 27            mov b, a
0219   057E E4            pop a
0220   057F C0 00 00      cmp b, 0
0221   0582 C6 A6 05      je _if4_else
0222   0585             _if4_true:
0223   0585 29 11 09      mov b, [val]
0224   0588 74            mov d, b
0225   0589 DA            push d
0226   058A 29 47 08      mov b, [_sp] ; _sp
0227   058D E7            pop d
0228   058E 10 02 00      mov a, 2
0229   0591 AC            mul a, b
0230   0592 5A            add d, b
0231   0593 DA            push d
0232   0594 2C 05 00      mov b, [bp + 5] ; f
0233   0597 E7            pop d
0234   0598 11            mov a, b
0235   0599 43            mov [d], a
0236   059A 29 47 08      mov b, [_sp] ; _sp
0237   059D FD 77         inc b
0238   059F FD 42 47 08   mov [_sp], b
0239   05A3 0A BE 05      jmp _if4_exit
0240   05A6             _if4_else:
0241   05A6 26 A3 09      mov b, _string_3 ; "Error: stack full, can't _push: "
0242   05A9 FD AB         swp b
0243   05AB D8            push b
0244   05AC 07 3C 08      call print
0245   05AF 51 02 00      add sp, 2
0246   05B2 2C 05 00      mov b, [bp + 5] ; f
0247   05B5 FD AB         swp b
0248   05B7 D8            push b
0249   05B8 07 32 08      call printn
0250   05BB 51 02 00      add sp, 2
0251   05BE             _if4_exit:
0252   05BE F9            leave
0253   05BF 09            ret
0254   05C0             
0255   05C0             _pop:
0256   05C0 D2            push bp
0257   05C1 9B            mov bp, sp
0258   05C2             _if5_cond:
0259   05C2 29 47 08      mov b, [_sp] ; _sp
0260   05C5 D7            push a
0261   05C6 11            mov a, b
0262   05C7 26 00 00      mov b, 0
0263   05CA B0            cmp a, b
0264   05CB 0E            lodflgs
0265   05CC 87 03         and al, %00000011
0266   05CE B9 00         cmp al, %00000000
0267   05D0 0E            lodflgs
0268   05D1 22 00         mov ah, 0
0269   05D3 27            mov b, a
0270   05D4 E4            pop a
0271   05D5 C0 00 00      cmp b, 0
0272   05D8 C6 FA 05      je _if5_else
0273   05DB             _if5_true:
0274   05DB 29 47 08      mov b, [_sp] ; _sp
0275   05DE FD 7D         dec b
0276   05E0 FD 42 47 08   mov [_sp], b
0277   05E4 29 11 09      mov b, [val]
0278   05E7 D7            push a
0279   05E8 74            mov d, b
0280   05E9 DA            push d
0281   05EA 29 47 08      mov b, [_sp] ; _sp
0282   05ED E7            pop d
0283   05EE 10 02 00      mov a, 2
0284   05F1 AC            mul a, b
0285   05F2 5A            add d, b
0286   05F3 2A            mov b, [d]
0287   05F4 E4            pop a
0288   05F5 F9            leave
0289   05F6 09            ret
0290   05F7 0A 0B 06      jmp _if5_exit
0291   05FA             _if5_else:
0292   05FA 26 C3 09      mov b, _string_4 ; "Error: stack empty.\n"
0293   05FD FD AB         swp b
0294   05FF D8            push b
0295   0600 07 3C 08      call print
0296   0603 51 02 00      add sp, 2
0297   0606 26 00 00      mov b, 0
0298   0609 F9            leave
0299   060A 09            ret
0300   060B             _if5_exit:
0301   060B             
0302   060B             getop:
0303   060B D2            push bp
0304   060C 9B            mov bp, sp
0305   060D 52 02 00      sub sp, 2 ; i
0306   0610 52 01 00      sub sp, 1 ; c
0307   0613             _while6_cond:
0308   0613 FA 05 00      lea d, [bp + 5] ; s
0309   0616 2A            mov b, [d]
0310   0617 74            mov d, b
0311   0618 DA            push d
0312   0619 26 00 00      mov b, 0
0313   061C E7            pop d
0314   061D 10 01 00      mov a, 1
0315   0620 AC            mul a, b
0316   0621 5A            add d, b
0317   0622 DA            push d
0318   0623 07 18 07      call getch
0319   0626 DB            push al
0320   0627 1B            mov al, bl
0321   0628 40 FE FF      mov [bp + -2], al ; c
0322   062B E8            pop al
0323   062C E7            pop d
0324   062D 1B            mov al, bl
0325   062E 3E            mov [d], al
0326   062F D7            push a
0327   0630 11            mov a, b
0328   0631 26 20 00      mov b, ' '
0329   0634 B0            cmp a, b
0330   0635 0E            lodflgs
0331   0636 87 01         and al, %00000001 ; ==
0332   0638 22 00         mov ah, 0
0333   063A 27            mov b, a
0334   063B E4            pop a
0335   063C C0 00 00      cmp b, 0
0336   063F C6 45 06      je _while6_exit
0337   0642             _while6_block:
0338   0642 0A 13 06      jmp _while6_cond
0339   0645             _while6_exit:
0340   0645 FA 05 00      lea d, [bp + 5] ; s
0341   0648 2A            mov b, [d]
0342   0649 74            mov d, b
0343   064A DA            push d
0344   064B 26 01 00      mov b, 1
0345   064E E7            pop d
0346   064F 10 01 00      mov a, 1
0347   0652 AC            mul a, b
0348   0653 5A            add d, b
0349   0654 DA            push d
0350   0655 26 00 00      mov b, 0
0351   0658 E7            pop d
0352   0659 1B            mov al, bl
0353   065A 3E            mov [d], al
0354   065B             _if7_cond:
0355   065B 34 FE FF      mov bl, [bp + -2] ; c
0356   065E A7 00         mov bh, 0
0357   0660 DD            push bl
0358   0661 07 A9 07      call isdigit
0359   0664 51 01 00      add sp, 1
0360   0667 DB            push al
0361   0668 C0 00 00      cmp b, 0
0362   066B 0E            lodflgs
0363   066C 87 01         and al, %00000001 ; transform logical not condition result into a single bit
0364   066E 2F            mov bl, al
0365   066F A7 00         mov bh, 0
0366   0671 E8            pop al
0367   0672 C0 00 00      cmp b, 0
0368   0675 C6 82 06      je _if7_exit
0369   0678             _if7_true:
0370   0678 34 FE FF      mov bl, [bp + -2] ; c
0371   067B A7 00         mov bh, 0
0372   067D F9            leave
0373   067E 09            ret
0374   067F 0A 82 06      jmp _if7_exit
0375   0682             _if7_exit:
0376   0682 26 00 00      mov b, 0
0377   0685 D7            push a
0378   0686 11            mov a, b
0379   0687 45 FF FF      mov [bp + -1], a ; i
0380   068A E4            pop a
0381   068B             _if8_cond:
0382   068B 34 FE FF      mov bl, [bp + -2] ; c
0383   068E A7 00         mov bh, 0
0384   0690 DD            push bl
0385   0691 07 A9 07      call isdigit
0386   0694 51 01 00      add sp, 1
0387   0697 C0 00 00      cmp b, 0
0388   069A C6 D4 06      je _if8_exit
0389   069D             _if8_true:
0390   069D             _while9_cond:
0391   069D FA 05 00      lea d, [bp + 5] ; s
0392   06A0 2A            mov b, [d]
0393   06A1 74            mov d, b
0394   06A2 DA            push d
0395   06A3 2C FF FF      mov b, [bp + -1] ; i
0396   06A6 FD 77         inc b
0397   06A8 D7            push a
0398   06A9 11            mov a, b
0399   06AA 45 FF FF      mov [bp + -1], a ; i
0400   06AD E4            pop a
0401   06AE E7            pop d
0402   06AF 10 01 00      mov a, 1
0403   06B2 AC            mul a, b
0404   06B3 5A            add d, b
0405   06B4 DA            push d
0406   06B5 07 18 07      call getch
0407   06B8 DB            push al
0408   06B9 1B            mov al, bl
0409   06BA 40 FE FF      mov [bp + -2], al ; c
0410   06BD E8            pop al
0411   06BE E7            pop d
0412   06BF 1B            mov al, bl
0413   06C0 3E            mov [d], al
0414   06C1 DD            push bl
0415   06C2 07 A9 07      call isdigit
0416   06C5 51 01 00      add sp, 1
0417   06C8 C0 00 00      cmp b, 0
0418   06CB C6 D1 06      je _while9_exit
0419   06CE             _while9_block:
0420   06CE 0A 9D 06      jmp _while9_cond
0421   06D1             _while9_exit:
0422   06D1 0A D4 06      jmp _if8_exit
0423   06D4             _if8_exit:
0424   06D4 FA 05 00      lea d, [bp + 5] ; s
0425   06D7 2A            mov b, [d]
0426   06D8 74            mov d, b
0427   06D9 DA            push d
0428   06DA 2C FF FF      mov b, [bp + -1] ; i
0429   06DD E7            pop d
0430   06DE 10 01 00      mov a, 1
0431   06E1 AC            mul a, b
0432   06E2 5A            add d, b
0433   06E3 DA            push d
0434   06E4 26 00 00      mov b, 0
0435   06E7 E7            pop d
0436   06E8 1B            mov al, bl
0437   06E9 3E            mov [d], al
0438   06EA             _if10_cond:
0439   06EA 34 FE FF      mov bl, [bp + -2] ; c
0440   06ED A7 00         mov bh, 0
0441   06EF D7            push a
0442   06F0 11            mov a, b
0443   06F1 26 24 00      mov b, '$'
0444   06F4 B0            cmp a, b
0445   06F5 0E            lodflgs
0446   06F6 87 01         and al, %00000001
0447   06F8 8F 01         xor al, %00000001 ; !=
0448   06FA 22 00         mov ah, 0
0449   06FC 27            mov b, a
0450   06FD E4            pop a
0451   06FE C0 00 00      cmp b, 0
0452   0701 C6 13 07      je _if10_exit
0453   0704             _if10_true:
0454   0704 34 FE FF      mov bl, [bp + -2] ; c
0455   0707 A7 00         mov bh, 0
0456   0709 DD            push bl
0457   070A 07 59 07      call ungetch
0458   070D 51 01 00      add sp, 1
0459   0710 0A 13 07      jmp _if10_exit
0460   0713             _if10_exit:
0461   0713 26 E7 03      mov b, 999
0462   0716 F9            leave
0463   0717 09            ret
0464   0718             
0465   0718             getch:
0466   0718 D2            push bp
0467   0719 9B            mov bp, sp
0468   071A             _if11_cond:
0469   071A 29 79 09      mov b, [bufp] ; bufp
0470   071D D7            push a
0471   071E 11            mov a, b
0472   071F 26 00 00      mov b, 0
0473   0722 B0            cmp a, b
0474   0723 0E            lodflgs
0475   0724 87 03         and al, %00000011
0476   0726 B9 00         cmp al, %00000000
0477   0728 0E            lodflgs
0478   0729 22 00         mov ah, 0
0479   072B 27            mov b, a
0480   072C E4            pop a
0481   072D C0 00 00      cmp b, 0
0482   0730 C6 54 07      je _if11_else
0483   0733             _if11_true:
0484   0733 29 79 09      mov b, [bufp] ; bufp
0485   0736 FD 7D         dec b
0486   0738 FD 42 79 09   mov [bufp], b
0487   073C 29 77 09      mov b, [buf]
0488   073F D7            push a
0489   0740 74            mov d, b
0490   0741 DA            push d
0491   0742 29 79 09      mov b, [bufp] ; bufp
0492   0745 E7            pop d
0493   0746 10 01 00      mov a, 1
0494   0749 AC            mul a, b
0495   074A 5A            add d, b
0496   074B 32            mov bl, [d]
0497   074C A7 00         mov bh, 0
0498   074E E4            pop a
0499   074F F9            leave
0500   0750 09            ret
0501   0751 0A 59 07      jmp _if11_exit
0502   0754             _if11_else:
0503   0754 07 07 08      call _getchar
0504   0757 F9            leave
0505   0758 09            ret
0506   0759             _if11_exit:
0507   0759             
0508   0759             ungetch:
0509   0759 D2            push bp
0510   075A 9B            mov bp, sp
0511   075B             _if12_cond:
0512   075B 29 79 09      mov b, [bufp] ; bufp
0513   075E D7            push a
0514   075F 11            mov a, b
0515   0760 26 64 00      mov b, 100
0516   0763 B0            cmp a, b
0517   0764 0E            lodflgs
0518   0765 87 03         and al, %00000011
0519   0767 8F 02         xor al, %00000010 ; >=
0520   0769 B9 00         cmp al, 0
0521   076B 0E            lodflgs
0522   076C 8F 01         xor al, %00000001
0523   076E 22 00         mov ah, 0
0524   0770 27            mov b, a
0525   0771 E4            pop a
0526   0772 C0 00 00      cmp b, 0
0527   0775 C6 87 07      je _if12_else
0528   0778             _if12_true:
0529   0778 26 D8 09      mov b, _string_5 ; "Error: too many characters.\n"
0530   077B FD AB         swp b
0531   077D D8            push b
0532   077E 07 3C 08      call print
0533   0781 51 02 00      add sp, 2
0534   0784 0A A7 07      jmp _if12_exit
0535   0787             _if12_else:
0536   0787 29 77 09      mov b, [buf]
0537   078A 74            mov d, b
0538   078B DA            push d
0539   078C 29 79 09      mov b, [bufp] ; bufp
0540   078F E7            pop d
0541   0790 10 01 00      mov a, 1
0542   0793 AC            mul a, b
0543   0794 5A            add d, b
0544   0795 DA            push d
0545   0796 34 05 00      mov bl, [bp + 5] ; c
0546   0799 A7 00         mov bh, 0
0547   079B E7            pop d
0548   079C 1B            mov al, bl
0549   079D 3E            mov [d], al
0550   079E 29 79 09      mov b, [bufp] ; bufp
0551   07A1 FD 77         inc b
0552   07A3 FD 42 79 09   mov [bufp], b
0553   07A7             _if12_exit:
0554   07A7 F9            leave
0555   07A8 09            ret
0556   07A9             
0557   07A9             isdigit:
0558   07A9 D2            push bp
0559   07AA 9B            mov bp, sp
0560   07AB             _if13_cond:
0561   07AB 34 05 00      mov bl, [bp + 5] ; c
0562   07AE A7 00         mov bh, 0
0563   07B0 D7            push a
0564   07B1 11            mov a, b
0565   07B2 26 30 00      mov b, '0'
0566   07B5 B0            cmp a, b
0567   07B6 0E            lodflgs
0568   07B7 87 03         and al, %00000011
0569   07B9 8F 02         xor al, %00000010 ; >=
0570   07BB B9 00         cmp al, 0
0571   07BD 0E            lodflgs
0572   07BE 8F 01         xor al, %00000001
0573   07C0 22 00         mov ah, 0
0574   07C2 27            mov b, a
0575   07C3 E4            pop a
0576   07C4 D7            push a
0577   07C5 11            mov a, b
0578   07C6 AF 00 00      cmp a, 0
0579   07C9 0E            lodflgs
0580   07CA 96            not al
0581   07CB 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
0582   07CD 34 05 00      mov bl, [bp + 5] ; c
0583   07D0 A7 00         mov bh, 0
0584   07D2 D7            push a
0585   07D3 11            mov a, b
0586   07D4 26 39 00      mov b, '9'
0587   07D7 B0            cmp a, b
0588   07D8 0E            lodflgs
0589   07D9 87 03         and al, %00000011 ; <=
0590   07DB B9 00         cmp al, 0
0591   07DD 0E            lodflgs
0592   07DE 8F 01         xor al, %00000001
0593   07E0 22 00         mov ah, 0
0594   07E2 22 00         mov ah, 0
0595   07E4 27            mov b, a
0596   07E5 E4            pop a
0597   07E6 DB            push al
0598   07E7 C0 00 00      cmp b, 0
0599   07EA 0E            lodflgs
0600   07EB 96            not al
0601   07EC 87 01         and al, %00000001 ; transform logical AND condition result into a single bit
0602   07EE EA            pop bl
0603   07EF 88            and al, bl
0604   07F0 2F            mov bl, al
0605   07F1 A7 00         mov bh, 0
0606   07F3 E4            pop a
0607   07F4 C0 00 00      cmp b, 0
0608   07F7 C6 02 08      je _if13_else
0609   07FA             _if13_true:
0610   07FA 26 01 00      mov b, 1
0611   07FD F9            leave
0612   07FE 09            ret
0613   07FF 0A 07 08      jmp _if13_exit
0614   0802             _if13_else:
0615   0802 26 00 00      mov b, 0
0616   0805 F9            leave
0617   0806 09            ret
0618   0807             _if13_exit:
0619   0807             
0620   0807             _getchar:
0621   0807 D2            push bp
0622   0808 9B            mov bp, sp
0623   0809 52 01 00      sub sp, 1 ; c
0624   080C             
0625   080C             ; --- BEGIN INLINE ASM BLOCK
0626   080C 07 F9 0A      call getchar
0627   080F 1A            mov al, ah
0628   0810 40 00 00      mov [bp + 0], al
0629   0813             ; --- END INLINE ASM BLOCK
0630   0813             
0631   0813 34 00 00      mov bl, [bp + 0] ; c
0632   0816 A7 00         mov bh, 0
0633   0818 F9            leave
0634   0819 09            ret
0635   081A             
0636   081A             scann:
0637   081A D2            push bp
0638   081B 9B            mov bp, sp
0639   081C 52 02 00      sub sp, 2 ; m
0640   081F             
0641   081F             ; --- BEGIN INLINE ASM BLOCK
0642   081F 07 3F 0D      call scan_u16d
0643   0822 45 FF FF      mov [bp + -1], a
0644   0825             ; --- END INLINE ASM BLOCK
0645   0825             
0646   0825 FA 05 00      lea d, [bp + 5] ; n
0647   0828 2A            mov b, [d]
0648   0829 D8            push b
0649   082A 2C FF FF      mov b, [bp + -1] ; m
0650   082D E7            pop d
0651   082E 11            mov a, b
0652   082F 43            mov [d], a
0653   0830 F9            leave
0654   0831 09            ret
0655   0832             
0656   0832             printn:
0657   0832 D2            push bp
0658   0833 9B            mov bp, sp
0659   0834             
0660   0834             ; --- BEGIN INLINE ASM BLOCK
0661   0834 17 05 00      mov a, [bp + 5]
0662   0837 07 6A 0C      call print_u16d
0663   083A             ; --- END INLINE ASM BLOCK
0664   083A             
0665   083A F9            leave
0666   083B 09            ret
0667   083C             
0668   083C             print:
0669   083C D2            push bp
0670   083D 9B            mov bp, sp
0671   083E             
0672   083E             ; --- BEGIN INLINE ASM BLOCK
0673   083E 17 05 00      mov a, [bp + 5]
0674   0841 3C            mov d, a
0675   0842 07 41 0C      call puts
0676   0845             ; --- END INLINE ASM BLOCK
0677   0845             
0678   0845 F9            leave
0679   0846 09            ret
0680   0847             ; --- END TEXT BLOCK
0681   0847             
0682   0847             ; --- BEGIN DATA BLOCK
0683   0847 00 00       _sp: .dw 0
0684   0849 00 00 00 00 val_data: .fill 200, 0
0684   084D 00 00 00 00 
0684   0851 00 00 00 00 
0684   0855 00 00 00 00 
0684   0859 00 00 00 00 
0684   085D 00 00 00 00 
0684   0861 00 00 00 00 
0684   0865 00 00 00 00 
0684   0869 00 00 00 00 
0684   086D 00 00 00 00 
0684   0871 00 00 00 00 
0684   0875 00 00 00 00 
0684   0879 00 00 00 00 
0684   087D 00 00 00 00 
0684   0881 00 00 00 00 
0684   0885 00 00 00 00 
0684   0889 00 00 00 00 
0684   088D 00 00 00 00 
0684   0891 00 00 00 00 
0684   0895 00 00 00 00 
0684   0899 00 00 00 00 
0684   089D 00 00 00 00 
0684   08A1 00 00 00 00 
0684   08A5 00 00 00 00 
0684   08A9 00 00 00 00 
0684   08AD 00 00 00 00 
0684   08B1 00 00 00 00 
0684   08B5 00 00 00 00 
0684   08B9 00 00 00 00 
0684   08BD 00 00 00 00 
0684   08C1 00 00 00 00 
0684   08C5 00 00 00 00 
0684   08C9 00 00 00 00 
0684   08CD 00 00 00 00 
0684   08D1 00 00 00 00 
0684   08D5 00 00 00 00 
0684   08D9 00 00 00 00 
0684   08DD 00 00 00 00 
0684   08E1 00 00 00 00 
0684   08E5 00 00 00 00 
0684   08E9 00 00 00 00 
0684   08ED 00 00 00 00 
0684   08F1 00 00 00 00 
0684   08F5 00 00 00 00 
0684   08F9 00 00 00 00 
0684   08FD 00 00 00 00 
0684   0901 00 00 00 00 
0684   0905 00 00 00 00 
0684   0909 00 00 00 00 
0684   090D 00 00 00 00 
0685   0911 49 08       val: .dw val_data
0686   0913 00 00 00 00 buf_data: .fill 100, 0
0686   0917 00 00 00 00 
0686   091B 00 00 00 00 
0686   091F 00 00 00 00 
0686   0923 00 00 00 00 
0686   0927 00 00 00 00 
0686   092B 00 00 00 00 
0686   092F 00 00 00 00 
0686   0933 00 00 00 00 
0686   0937 00 00 00 00 
0686   093B 00 00 00 00 
0686   093F 00 00 00 00 
0686   0943 00 00 00 00 
0686   0947 00 00 00 00 
0686   094B 00 00 00 00 
0686   094F 00 00 00 00 
0686   0953 00 00 00 00 
0686   0957 00 00 00 00 
0686   095B 00 00 00 00 
0686   095F 00 00 00 00 
0686   0963 00 00 00 00 
0686   0967 00 00 00 00 
0686   096B 00 00 00 00 
0686   096F 00 00 00 00 
0686   0973 00 00 00 00 
0687   0977 13 09       buf: .dw buf_data
0688   0979 00 00       bufp: .dw 0
0689   097B 44 69 76 69 _string_0: .db "Divide by zero error\n", 0
0689   097F 64 65 20 62 
0689   0983 79 20 7A 65 
0689   0987 72 6F 20 65 
0689   098B 72 72 6F 72 
0689   098F 0A 00 
0690   0991 0A 00       _string_1: .db "\n", 0
0691   0993 55 6E 6B 6E _string_2: .db "Unknown input: ", 0
0691   0997 6F 77 6E 20 
0691   099B 69 6E 70 75 
0691   099F 74 3A 20 00 
0692   09A3 45 72 72 6F _string_3: .db "Error: stack full, can't _push: ", 0
0692   09A7 72 3A 20 73 
0692   09AB 74 61 63 6B 
0692   09AF 20 66 75 6C 
0692   09B3 6C 2C 20 63 
0692   09B7 61 6E 27 74 
0692   09BB 20 5F 70 75 
0692   09BF 73 68 3A 20 
0693   09C3 45 72 72 6F _string_4: .db "Error: stack empty.\n", 0
0693   09C7 72 3A 20 73 
0693   09CB 74 61 63 6B 
0693   09CF 20 65 6D 70 
0693   09D3 74 79 2E 0A 
0693   09D7 00 
0694   09D8 45 72 72 6F _string_5: .db "Error: too many characters.\n", 0
0694   09DC 72 3A 20 74 
0694   09E0 6F 6F 20 6D 
0694   09E4 61 6E 79 20 
0694   09E8 63 68 61 72 
0694   09EC 61 63 74 65 
0694   09F0 72 73 2E 0A 
0694   09F4 00 
0695   09F5             ; --- END DATA BLOCK
0696   09F5             
0697   09F5             ; --- BEGIN INCLUDE BLOCK
0698   09F5             .include "lib/stdio.asm"
0001+  09F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  09F5             ; stdio.s
0003+  09F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  09F5             .include "lib/string.asm"
0001++ 09F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 09F5             ; string.s
0003++ 09F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 09F5             
0005++ 09F5             
0006++ 09F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 09F5             ; strrev
0008++ 09F5             ; reverse a string
0009++ 09F5             ; D = string address
0010++ 09F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 09F5             ; 01234
0012++ 09F5             strrev:
0013++ 09F5 4B          	pusha
0014++ 09F6 07 3C 0A    	call strlen	; length in C
0015++ 09F9 12          	mov a, c
0016++ 09FA AF 01 00    	cmp a, 1
0017++ 09FD D0 17 0A    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0A00 7D          	dec a
0019++ 0A01 FD 4E       	mov si, d	; beginning of string
0020++ 0A03 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0A05 59          	add d, a	; end of string
0022++ 0A06 12          	mov a, c
0023++ 0A07 FD 9B       	shr a		; divide by 2
0024++ 0A09 39          	mov c, a	; C now counts the steps
0025++ 0A0A             strrev_L0:
0026++ 0A0A 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0A0B F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0A0C 3E          	mov [d], al	; store left char into right side
0029++ 0A0D 1B          	mov al, bl
0030++ 0A0E F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0A0F 7E          	dec c
0032++ 0A10 7F          	dec d
0033++ 0A11 C2 00 00    	cmp c, 0
0034++ 0A14 C7 0A 0A    	jne strrev_L0
0035++ 0A17             strrev_end:
0036++ 0A17 4C          	popa
0037++ 0A18 09          	ret
0038++ 0A19             	
0039++ 0A19             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0A19             ; strchr
0041++ 0A19             ; search string in D for char in AL
0042++ 0A19             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0A19             strchr:
0044++ 0A19             strchr_L0:
0045++ 0A19 32          	mov bl, [d]
0046++ 0A1A C1 00       	cmp bl, 0
0047++ 0A1C C6 27 0A    	je strchr_end
0048++ 0A1F BA          	cmp al, bl
0049++ 0A20 C6 27 0A    	je strchr_end
0050++ 0A23 79          	inc d
0051++ 0A24 0A 19 0A    	jmp strchr_L0
0052++ 0A27             strchr_end:
0053++ 0A27 1B          	mov al, bl
0054++ 0A28 09          	ret
0055++ 0A29             
0056++ 0A29             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0A29             ; strstr
0058++ 0A29             ; find sub-string
0059++ 0A29             ; str1 in SI
0060++ 0A29             ; str2 in DI
0061++ 0A29             ; SI points to end of source string
0062++ 0A29             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0A29             strstr:
0064++ 0A29 DB          	push al
0065++ 0A2A DA          	push d
0066++ 0A2B E3          	push di
0067++ 0A2C             strstr_loop:
0068++ 0A2C F3          	cmpsb					; compare a byte of the strings
0069++ 0A2D C7 38 0A    	jne strstr_ret
0070++ 0A30 FC 00 00    	lea d, [di + 0]
0071++ 0A33 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0A35 C7 2C 0A    	jne strstr_loop				; equal chars but not at end
0073++ 0A38             strstr_ret:
0074++ 0A38 F0          	pop di
0075++ 0A39 E7          	pop d
0076++ 0A3A E8          	pop al
0077++ 0A3B 09          	ret
0078++ 0A3C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0A3C             ; length of null terminated string
0080++ 0A3C             ; result in C
0081++ 0A3C             ; pointer in D
0082++ 0A3C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0A3C             strlen:
0084++ 0A3C DA          	push d
0085++ 0A3D 38 00 00    	mov c, 0
0086++ 0A40             strlen_L1:
0087++ 0A40 BD 00       	cmp byte [d], 0
0088++ 0A42 C6 4A 0A    	je strlen_ret
0089++ 0A45 79          	inc d
0090++ 0A46 78          	inc c
0091++ 0A47 0A 40 0A    	jmp strlen_L1
0092++ 0A4A             strlen_ret:
0093++ 0A4A E7          	pop d
0094++ 0A4B 09          	ret
0095++ 0A4C             
0096++ 0A4C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0A4C             ; STRCMP
0098++ 0A4C             ; compare two strings
0099++ 0A4C             ; str1 in SI
0100++ 0A4C             ; str2 in DI
0101++ 0A4C             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0A4C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0A4C             strcmp:
0104++ 0A4C DB          	push al
0105++ 0A4D DA          	push d
0106++ 0A4E E3          	push di
0107++ 0A4F E2          	push si
0108++ 0A50             strcmp_loop:
0109++ 0A50 F3          	cmpsb					; compare a byte of the strings
0110++ 0A51 C7 5C 0A    	jne strcmp_ret
0111++ 0A54 FB FF FF    	lea d, [si +- 1]
0112++ 0A57 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0A59 C7 50 0A    	jne strcmp_loop				; equal chars but not at end
0114++ 0A5C             strcmp_ret:
0115++ 0A5C EF          	pop si
0116++ 0A5D F0          	pop di
0117++ 0A5E E7          	pop d
0118++ 0A5F E8          	pop al
0119++ 0A60 09          	ret
0120++ 0A61             
0121++ 0A61             
0122++ 0A61             ; STRCPY
0123++ 0A61             ; copy null terminated string from SI to DI
0124++ 0A61             ; source in SI
0125++ 0A61             ; destination in DI
0126++ 0A61             strcpy:
0127++ 0A61 E2          	push si
0128++ 0A62 E3          	push di
0129++ 0A63 DB          	push al
0130++ 0A64             strcpy_L1:
0131++ 0A64 F6          	lodsb
0132++ 0A65 F7          	stosb
0133++ 0A66 B9 00       	cmp al, 0
0134++ 0A68 C7 64 0A    	jne strcpy_L1
0135++ 0A6B             strcpy_end:
0136++ 0A6B E8          	pop al
0137++ 0A6C F0          	pop di
0138++ 0A6D EF          	pop si
0139++ 0A6E 09          	ret
0140++ 0A6F             
0141++ 0A6F             ; STRCAT
0142++ 0A6F             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0A6F             ; source in SI
0144++ 0A6F             ; destination in DI
0145++ 0A6F             strcat:
0146++ 0A6F E2          	push si
0147++ 0A70 E3          	push di
0148++ 0A71 D7          	push a
0149++ 0A72 DA          	push d
0150++ 0A73 50          	mov a, di
0151++ 0A74 3C          	mov d, a
0152++ 0A75             strcat_goto_end_L1:
0153++ 0A75 BD 00       	cmp byte[d], 0
0154++ 0A77 C6 7E 0A    	je strcat_start
0155++ 0A7A 79          	inc d
0156++ 0A7B 0A 75 0A    	jmp strcat_goto_end_L1
0157++ 0A7E             strcat_start:
0158++ 0A7E FD 50       	mov di, d
0159++ 0A80             strcat_L1:
0160++ 0A80 F6          	lodsb
0161++ 0A81 F7          	stosb
0162++ 0A82 B9 00       	cmp al, 0
0163++ 0A84 C7 80 0A    	jne strcat_L1
0164++ 0A87             strcat_end:
0165++ 0A87 E7          	pop d
0166++ 0A88 E4          	pop a
0167++ 0A89 F0          	pop di
0168++ 0A8A EF          	pop si
0169++ 0A8B 09          	ret
0005+  0A8C             
0006+  0A8C 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  0A90 34 35 36 37 
0006+  0A94 38 39 41 42 
0006+  0A98 43 44 45 46 
0007+  0A9C 1B 5B 32 4A s_telnet_clear:	.db 27, "[2J", 27, "[H", 0
0007+  0AA0 1B 5B 48 00 
0008+  0AA4             
0009+  0AA4 01 00       table_power:.dw 1
0010+  0AA6 0A 00       			.dw 10
0011+  0AA8 64 00       			.dw 100
0012+  0AAA E8 03       			.dw 1000
0013+  0AAC 10 27       			.dw 10000
0014+  0AAE             
0015+  0AAE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0016+  0AAE             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0017+  0AAE             ; ASCII in BL
0018+  0AAE             ; result in AL
0019+  0AAE             ; ascii for F = 0100 0110
0020+  0AAE             ; ascii for 9 = 0011 1001
0021+  0AAE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0022+  0AAE             hex_ascii_encode:
0023+  0AAE 1B          	mov al, bl
0024+  0AAF 93 40       	test al, $40				; test if letter or number
0025+  0AB1 C7 B7 0A    	jnz hex_letter
0026+  0AB4 87 0F       	and al, $0F				; get number
0027+  0AB6 09          	ret
0028+  0AB7             hex_letter:
0029+  0AB7 87 0F       	and al, $0F				; get letter
0030+  0AB9 6A 09       	add al, 9
0031+  0ABB 09          	ret
0032+  0ABC             
0033+  0ABC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0034+  0ABC             ; ATOI
0035+  0ABC             ; 2 letter hex string in B
0036+  0ABC             ; 8bit integer returned in AL
0037+  0ABC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0ABC             atoi:
0039+  0ABC D8          	push b
0040+  0ABD 07 AE 0A    	call hex_ascii_encode			; convert BL to 4bit code in AL
0041+  0AC0 30          	mov bl, bh
0042+  0AC1 DB          	push al					; save a
0043+  0AC2 07 AE 0A    	call hex_ascii_encode
0044+  0AC5 EA          	pop bl	
0045+  0AC6 FD 9E 04    	shl al, 4
0046+  0AC9 8C          	or al, bl
0047+  0ACA E5          	pop b
0048+  0ACB 09          	ret	
0049+  0ACC             
0050+  0ACC             
0051+  0ACC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0052+  0ACC             ; printf
0053+  0ACC             ; no need for explanations!
0054+  0ACC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0ACC             printf:
0056+  0ACC 09          	ret
0057+  0ACD             
0058+  0ACD             
0059+  0ACD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0060+  0ACD             ; scanf
0061+  0ACD             ; no need for explanations!
0062+  0ACD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063+  0ACD             scanf:
0064+  0ACD 09          	ret
0065+  0ACE             
0066+  0ACE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0067+  0ACE             ; ITOA
0068+  0ACE             ; 8bit value in BL
0069+  0ACE             ; 2 byte ASCII result in A
0070+  0ACE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0071+  0ACE             itoa:
0072+  0ACE DA          	push d
0073+  0ACF D8          	push b
0074+  0AD0 A7 00       	mov bh, 0
0075+  0AD2 FD A4 04    	shr bl, 4	
0076+  0AD5 74          	mov d, b
0077+  0AD6 1F 8C 0A    	mov al, [d + s_hex_digits]
0078+  0AD9 23          	mov ah, al
0079+  0ADA             	
0080+  0ADA E5          	pop b
0081+  0ADB D8          	push b
0082+  0ADC A7 00       	mov bh, 0
0083+  0ADE FD 87 0F    	and bl, $0F
0084+  0AE1 74          	mov d, b
0085+  0AE2 1F 8C 0A    	mov al, [d + s_hex_digits]
0086+  0AE5 E5          	pop b
0087+  0AE6 E7          	pop d
0088+  0AE7 09          	ret
0089+  0AE8             
0090+  0AE8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0091+  0AE8             ; HEX STRING TO BINARY
0092+  0AE8             ; di = destination address
0093+  0AE8             ; si = source
0094+  0AE8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095+  0AE8             hex_to_int:
0096+  0AE8             hex_to_int_L1:
0097+  0AE8 F6          	lodsb					; load from [SI] to AL
0098+  0AE9 B9 00       	cmp al, 0				; check if ASCII 0
0099+  0AEB C6 F8 0A    	jz hex_to_int_ret
0100+  0AEE 36          	mov bh, al
0101+  0AEF F6          	lodsb
0102+  0AF0 2F          	mov bl, al
0103+  0AF1 07 BC 0A    	call atoi				; convert ASCII byte in B to int (to AL)
0104+  0AF4 F7          	stosb					; store AL to [DI]
0105+  0AF5 0A E8 0A    	jmp hex_to_int_L1
0106+  0AF8             hex_to_int_ret:
0107+  0AF8 09          	ret		
0108+  0AF9             
0109+  0AF9             
0110+  0AF9             
0111+  0AF9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112+  0AF9             ; GETCHAR
0113+  0AF9             ; char in ah
0114+  0AF9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0115+  0AF9             getchar:
0116+  0AF9 DB          	push al
0117+  0AFA             getchar_retry:
0118+  0AFA FD 0C       	sti
0119+  0AFC 19 01       	mov al, 1
0120+  0AFE 05 03       	syscall sys_io			; receive in AH
0121+  0B00 B9 00       	cmp al, 0			; check if any char was receive
0122+  0B02 C6 FA 0A    	je getchar_retry
0123+  0B05 E8          	pop al
0124+  0B06 09          	ret
0125+  0B07             
0126+  0B07             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  0B07             ; PUTCHAR
0128+  0B07             ; char in ah
0129+  0B07             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0B07             putchar:
0131+  0B07 D7          	push a
0132+  0B08 19 00       	mov al, 0
0133+  0B0A 05 03       	syscall sys_io			; char in AH
0134+  0B0C E4          	pop a
0135+  0B0D 09          	ret
0136+  0B0E             
0137+  0B0E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0138+  0B0E             ;; INPUT A STRING
0139+  0B0E             ;; terminates with null
0140+  0B0E             ;; pointer in D
0141+  0B0E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0142+  0B0E             gets:
0143+  0B0E D7          	push a
0144+  0B0F DA          	push d
0145+  0B10             gets_loop:
0146+  0B10 FD 0C       	sti
0147+  0B12 19 01       	mov al, 1
0148+  0B14 05 03       	syscall sys_io			; receive in AH
0149+  0B16 B9 00       	cmp al, 0				; check error code (AL)
0150+  0B18 C6 10 0B    	je gets_loop			; if no char received, retry
0151+  0B1B             
0152+  0B1B 76 1B       	cmp ah, 27
0153+  0B1D C6 3E 0B    	je gets_telnet_escape
0154+  0B20 76 0A       	cmp ah, $0A				; LF
0155+  0B22 C6 97 0B    	je gets_end
0156+  0B25 76 0D       	cmp ah, $0D				; CR
0157+  0B27 C6 97 0B    	je gets_end
0158+  0B2A 76 5C       	cmp ah, $5C				; '\\'
0159+  0B2C C6 6E 0B    	je gets_escape
0160+  0B2F             	
0161+  0B2F 76 08       	cmp ah, $08			; check for backspace
0162+  0B31 C6 3A 0B    	je gets_backspace
0163+  0B34             
0164+  0B34 1A          	mov al, ah
0165+  0B35 3E          	mov [d], al
0166+  0B36 79          	inc d
0167+  0B37 0A 10 0B    	jmp gets_loop
0168+  0B3A             gets_backspace:
0169+  0B3A 7F          	dec d
0170+  0B3B 0A 10 0B    	jmp gets_loop
0171+  0B3E             gets_telnet_escape:
0172+  0B3E FD 0C       	sti
0173+  0B40 19 01       	mov al, 1
0174+  0B42 05 03       	syscall sys_io				; receive in AH without echo
0175+  0B44 B9 00       	cmp al, 0					; check error code (AL)
0176+  0B46 C6 3E 0B    	je gets_telnet_escape		; if no char received, retry
0177+  0B49 76 5B       	cmp ah, '['
0178+  0B4B C7 10 0B    	jne gets_loop
0179+  0B4E             gets_telnet_escape_phase2:
0180+  0B4E FD 0C       	sti
0181+  0B50 19 01       	mov al, 1
0182+  0B52 05 03       	syscall sys_io					; receive in AH without echo
0183+  0B54 B9 00       	cmp al, 0						; check error code (AL)
0184+  0B56 C6 4E 0B    	je gets_telnet_escape_phase2	; if no char received, retry
0185+  0B59 76 44       	cmp ah, 'D'
0186+  0B5B C6 66 0B    	je gets_left_arrow
0187+  0B5E 76 43       	cmp ah, 'C'
0188+  0B60 C6 6A 0B    	je gets_right_arrow
0189+  0B63 0A 10 0B    	jmp gets_loop
0190+  0B66             gets_left_arrow:
0191+  0B66 7F          	dec d
0192+  0B67 0A 10 0B    	jmp gets_loop
0193+  0B6A             gets_right_arrow:
0194+  0B6A 79          	inc d
0195+  0B6B 0A 10 0B    	jmp gets_loop
0196+  0B6E             gets_escape:
0197+  0B6E FD 0C       	sti
0198+  0B70 19 01       	mov al, 1
0199+  0B72 05 03       	syscall sys_io			; receive in AH
0200+  0B74 B9 00       	cmp al, 0				; check error code (AL)
0201+  0B76 C6 6E 0B    	je gets_escape			; if no char received, retry
0202+  0B79 76 6E       	cmp ah, 'n'
0203+  0B7B C6 89 0B    	je gets_LF
0204+  0B7E 76 72       	cmp ah, 'r'
0205+  0B80 C6 90 0B    	je gets_CR
0206+  0B83 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0207+  0B84 3E          	mov [d], al
0208+  0B85 79          	inc d
0209+  0B86 0A 10 0B    	jmp gets_loop
0210+  0B89             gets_LF:
0211+  0B89 19 0A       	mov al, $0A
0212+  0B8B 3E          	mov [d], al
0213+  0B8C 79          	inc d
0214+  0B8D 0A 10 0B    	jmp gets_loop
0215+  0B90             gets_CR:
0216+  0B90 19 0D       	mov al, $0D
0217+  0B92 3E          	mov [d], al
0218+  0B93 79          	inc d
0219+  0B94 0A 10 0B    	jmp gets_loop
0220+  0B97             gets_end:
0221+  0B97 19 00       	mov al, 0
0222+  0B99 3E          	mov [d], al				; terminate string
0223+  0B9A E7          	pop d
0224+  0B9B E4          	pop a
0225+  0B9C 09          	ret
0226+  0B9D             
0227+  0B9D             
0228+  0B9D             
0229+  0B9D             
0230+  0B9D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0231+  0B9D             ;; INPUT TEXT
0232+  0B9D             ;; terminated with CTRL+D
0233+  0B9D             ;; pointer in D
0234+  0B9D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0235+  0B9D             gettxt:
0236+  0B9D D7          	push a
0237+  0B9E DA          	push d
0238+  0B9F             gettxt_loop:
0239+  0B9F 19 01       	mov al, 1
0240+  0BA1 05 03       	syscall sys_io			; receive in AH
0241+  0BA3 B9 00       	cmp al, 0				; check error code (AL)
0242+  0BA5 C6 9F 0B    	je gettxt_loop		; if no char received, retry
0243+  0BA8 76 04       	cmp ah, 4			; EOT
0244+  0BAA C6 E8 0B    	je gettxt_end
0245+  0BAD 76 08       	cmp ah, $08			; check for backspace
0246+  0BAF C6 E4 0B    	je gettxt_backspace
0247+  0BB2 76 5C       	cmp ah, $5C				; '\\'
0248+  0BB4 C6 BD 0B    	je gettxt_escape
0249+  0BB7 1A          	mov al, ah
0250+  0BB8 3E          	mov [d], al
0251+  0BB9 79          	inc d
0252+  0BBA 0A 9F 0B    	jmp gettxt_loop
0253+  0BBD             gettxt_escape:
0254+  0BBD 19 01       	mov al, 1
0255+  0BBF 05 03       	syscall sys_io			; receive in AH
0256+  0BC1 B9 00       	cmp al, 0				; check error code (AL)
0257+  0BC3 C6 BD 0B    	je gettxt_escape		; if no char received, retry
0258+  0BC6 76 6E       	cmp ah, 'n'
0259+  0BC8 C6 D6 0B    	je gettxt_LF
0260+  0BCB 76 72       	cmp ah, 'r'
0261+  0BCD C6 DD 0B    	je gettxt_CR
0262+  0BD0 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0263+  0BD1 3E          	mov [d], al
0264+  0BD2 79          	inc d
0265+  0BD3 0A 9F 0B    	jmp gettxt_loop
0266+  0BD6             gettxt_LF:
0267+  0BD6 19 0A       	mov al, $0A
0268+  0BD8 3E          	mov [d], al
0269+  0BD9 79          	inc d
0270+  0BDA 0A 9F 0B    	jmp gettxt_loop
0271+  0BDD             gettxt_CR:
0272+  0BDD 19 0D       	mov al, $0D
0273+  0BDF 3E          	mov [d], al
0274+  0BE0 79          	inc d
0275+  0BE1 0A 9F 0B    	jmp gettxt_loop
0276+  0BE4             gettxt_backspace:
0277+  0BE4 7F          	dec d
0278+  0BE5 0A 9F 0B    	jmp gettxt_loop
0279+  0BE8             gettxt_end:
0280+  0BE8 19 00       	mov al, 0
0281+  0BEA 3E          	mov [d], al				; terminate string
0282+  0BEB E7          	pop d
0283+  0BEC E4          	pop a
0284+  0BED 09          	ret
0285+  0BEE             
0286+  0BEE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0287+  0BEE             ; PRINT NEW LINE
0288+  0BEE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0289+  0BEE             printnl:
0290+  0BEE D7          	push a
0291+  0BEF 10 00 0A    	mov a, $0A00
0292+  0BF2 05 03       	syscall sys_io
0293+  0BF4 10 00 0D    	mov a, $0D00
0294+  0BF7 05 03       	syscall sys_io
0295+  0BF9 E4          	pop a
0296+  0BFA 09          	ret
0297+  0BFB             
0298+  0BFB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0299+  0BFB             ; strtoint
0300+  0BFB             ; 4 digit hex string number in d
0301+  0BFB             ; integer returned in A
0302+  0BFB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303+  0BFB             strtointx:
0304+  0BFB D8          	push b
0305+  0BFC 32          	mov bl, [d]
0306+  0BFD 37          	mov bh, bl
0307+  0BFE 33 01 00    	mov bl, [d + 1]
0308+  0C01 07 BC 0A    	call atoi				; convert to int in AL
0309+  0C04 23          	mov ah, al				; move to AH
0310+  0C05 33 02 00    	mov bl, [d + 2]
0311+  0C08 37          	mov bh, bl
0312+  0C09 33 03 00    	mov bl, [d + 3]
0313+  0C0C 07 BC 0A    	call atoi				; convert to int in AL
0314+  0C0F E5          	pop b
0315+  0C10 09          	ret
0316+  0C11             
0317+  0C11             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0318+  0C11             ; strtoint
0319+  0C11             ; 5 digit base10 string number in d
0320+  0C11             ; integer returned in A
0321+  0C11             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0322+  0C11             strtoint:
0323+  0C11 E2          	push si
0324+  0C12 D8          	push b
0325+  0C13 D9          	push c
0326+  0C14 DA          	push d
0327+  0C15 07 3C 0A    	call strlen			; get string length in C
0328+  0C18 7E          	dec c
0329+  0C19 FD 4E       	mov si, d
0330+  0C1B 12          	mov a, c
0331+  0C1C FD 99       	shl a
0332+  0C1E 3B A4 0A    	mov d, table_power
0333+  0C21 59          	add d, a
0334+  0C22 38 00 00    	mov c, 0
0335+  0C25             strtoint_L0:
0336+  0C25 F6          	lodsb			; load ASCII to al
0337+  0C26 B9 00       	cmp al, 0
0338+  0C28 C6 3B 0C    	je strtoint_end
0339+  0C2B 6F 30       	sub al, $30		; make into integer
0340+  0C2D 22 00       	mov ah, 0
0341+  0C2F 2A          	mov b, [d]
0342+  0C30 AC          	mul a, b			; result in B since it fits in 16bits
0343+  0C31 11          	mov a, b
0344+  0C32 28          	mov b, c
0345+  0C33 54          	add a, b
0346+  0C34 39          	mov c, a
0347+  0C35 63 02 00    	sub d, 2
0348+  0C38 0A 25 0C    	jmp strtoint_L0
0349+  0C3B             strtoint_end:
0350+  0C3B 12          	mov a, c
0351+  0C3C E7          	pop d
0352+  0C3D E6          	pop c
0353+  0C3E E5          	pop b
0354+  0C3F EF          	pop si
0355+  0C40 09          	ret
0356+  0C41             
0357+  0C41             
0358+  0C41             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  0C41             ; PRINT NULL TERMINATED STRING
0360+  0C41             ; pointer in D
0361+  0C41             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362+  0C41             puts:
0363+  0C41 D7          	push a
0364+  0C42 DA          	push d
0365+  0C43             puts_L1:
0366+  0C43 1E          	mov al, [d]
0367+  0C44 B9 00       	cmp al, 0
0368+  0C46 C6 52 0C    	jz puts_END
0369+  0C49 23          	mov ah, al
0370+  0C4A 19 00       	mov al, 0
0371+  0C4C 05 03       	syscall sys_io
0372+  0C4E 79          	inc d
0373+  0C4F 0A 43 0C    	jmp puts_L1
0374+  0C52             puts_END:
0375+  0C52 E7          	pop d
0376+  0C53 E4          	pop a
0377+  0C54 09          	ret
0378+  0C55             
0379+  0C55             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380+  0C55             ; PRINT N SIZE STRING
0381+  0C55             ; pointer in D
0382+  0C55             ; size in C
0383+  0C55             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384+  0C55             putsn:
0385+  0C55 DB          	push al
0386+  0C56 DA          	push d
0387+  0C57 D9          	push c
0388+  0C58             putsn_L0:
0389+  0C58 1E          	mov al, [d]
0390+  0C59 23          	mov ah, al
0391+  0C5A 19 00       	mov al, 0
0392+  0C5C 05 03       	syscall sys_io
0393+  0C5E 79          	inc d
0394+  0C5F 7E          	dec c	
0395+  0C60 C2 00 00    	cmp c, 0
0396+  0C63 C7 58 0C    	jne putsn_L0
0397+  0C66             putsn_end:
0398+  0C66 E6          	pop c
0399+  0C67 E7          	pop d
0400+  0C68 E8          	pop al
0401+  0C69 09          	ret
0402+  0C6A             
0403+  0C6A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  0C6A             ; print 16bit decimal number
0405+  0C6A             ; input number in A
0406+  0C6A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407+  0C6A             print_u16d:
0408+  0C6A D7          	push a
0409+  0C6B D8          	push b
0410+  0C6C 26 10 27    	mov b, 10000
0411+  0C6F AE          	div a, b			; get 10000 coeff.
0412+  0C70 07 96 0C    	call print_number
0413+  0C73 11          	mov a, b
0414+  0C74 26 E8 03    	mov b, 1000
0415+  0C77 AE          	div a, b			; get 10000 coeff.
0416+  0C78 07 96 0C    	call print_number
0417+  0C7B 11          	mov a, b
0418+  0C7C 26 64 00    	mov b, 100
0419+  0C7F AE          	div a, b
0420+  0C80 07 96 0C    	call print_number
0421+  0C83 11          	mov a, b
0422+  0C84 26 0A 00    	mov b, 10
0423+  0C87 AE          	div a, b
0424+  0C88 07 96 0C    	call print_number
0425+  0C8B 11          	mov a, b
0426+  0C8C 6A 30       	add al, $30
0427+  0C8E 23          	mov ah, al
0428+  0C8F 19 00       	mov al, 0
0429+  0C91 05 03       	syscall sys_io	; print coeff
0430+  0C93 E5          	pop b
0431+  0C94 E4          	pop a
0432+  0C95 09          	ret
0433+  0C96             
0434+  0C96             
0435+  0C96             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  0C96             ; if A == 0, print space
0437+  0C96             ; else print A
0438+  0C96             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0439+  0C96             print_number:
0440+  0C96 6A 30       	add al, $30
0441+  0C98 23          	mov ah, al
0442+  0C99 07 07 0B    	call putchar
0443+  0C9C 09          	ret
0444+  0C9D             
0445+  0C9D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0446+  0C9D             ; PRINT 16BIT HEX INTEGER
0447+  0C9D             ; integer value in reg B
0448+  0C9D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  0C9D             print_u16x:
0450+  0C9D D7          	push a
0451+  0C9E D8          	push b
0452+  0C9F DD          	push bl
0453+  0CA0 30          	mov bl, bh
0454+  0CA1 07 CE 0A    	call itoa				; convert bh to char in A
0455+  0CA4 2F          	mov bl, al				; save al
0456+  0CA5 19 00       	mov al, 0
0457+  0CA7 05 03       	syscall sys_io				; display AH
0458+  0CA9 24          	mov ah, bl				; retrieve al
0459+  0CAA 19 00       	mov al, 0
0460+  0CAC 05 03       	syscall sys_io				; display AL
0461+  0CAE             
0462+  0CAE EA          	pop bl
0463+  0CAF 07 CE 0A    	call itoa				; convert bh to char in A
0464+  0CB2 2F          	mov bl, al				; save al
0465+  0CB3 19 00       	mov al, 0
0466+  0CB5 05 03       	syscall sys_io				; display AH
0467+  0CB7 24          	mov ah, bl				; retrieve al
0468+  0CB8 19 00       	mov al, 0
0469+  0CBA 05 03       	syscall sys_io				; display AL
0470+  0CBC             
0471+  0CBC E5          	pop b
0472+  0CBD E4          	pop a
0473+  0CBE 09          	ret
0474+  0CBF             
0475+  0CBF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  0CBF             ; INPUT 16BIT HEX INTEGER
0477+  0CBF             ; read 16bit integer into A
0478+  0CBF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  0CBF             scan_u16x:
0480+  0CBF F8 10 00    	enter 16
0481+  0CC2 D8          	push b
0482+  0CC3 DA          	push d
0483+  0CC4             
0484+  0CC4 FA F1 FF    	lea d, [bp + -15]
0485+  0CC7 07 0E 0B    	call gets				; get number
0486+  0CCA             
0487+  0CCA 32          	mov bl, [d]
0488+  0CCB 37          	mov bh, bl
0489+  0CCC 33 01 00    	mov bl, [d + 1]
0490+  0CCF 07 BC 0A    	call atoi				; convert to int in AL
0491+  0CD2 23          	mov ah, al				; move to AH
0492+  0CD3             
0493+  0CD3 33 02 00    	mov bl, [d + 2]
0494+  0CD6 37          	mov bh, bl
0495+  0CD7 33 03 00    	mov bl, [d + 3]
0496+  0CDA 07 BC 0A    	call atoi				; convert to int in AL
0497+  0CDD             
0498+  0CDD E7          	pop d
0499+  0CDE E5          	pop b
0500+  0CDF F9          	leave
0501+  0CE0 09          	ret
0502+  0CE1             
0503+  0CE1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0504+  0CE1             ; PRINT 8bit HEX INTEGER
0505+  0CE1             ; integer value in reg bl
0506+  0CE1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  0CE1             print_u8x:
0508+  0CE1 D7          	push a
0509+  0CE2 DD          	push bl
0510+  0CE3             
0511+  0CE3 07 CE 0A    	call itoa				; convert bl to char in A
0512+  0CE6 2F          	mov bl, al				; save al
0513+  0CE7 19 00       	mov al, 0
0514+  0CE9 05 03       	syscall sys_io				; display AH
0515+  0CEB 24          	mov ah, bl				; retrieve al
0516+  0CEC 19 00       	mov al, 0
0517+  0CEE 05 03       	syscall sys_io				; display AL
0518+  0CF0             
0519+  0CF0 EA          	pop bl
0520+  0CF1 E4          	pop a
0521+  0CF2 09          	ret
0522+  0CF3             
0523+  0CF3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0524+  0CF3             ; print 8bit decimal unsigned number
0525+  0CF3             ; input number in AL
0526+  0CF3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  0CF3             print_u8d:
0528+  0CF3 D7          	push a
0529+  0CF4 D8          	push b
0530+  0CF5             
0531+  0CF5 22 00       	mov ah, 0
0532+  0CF7 26 64 00    	mov b, 100
0533+  0CFA AE          	div a, b
0534+  0CFB D8          	push b			; save remainder
0535+  0CFC B9 00       	cmp al, 0
0536+  0CFE C6 08 0D    	je skip100
0537+  0D01 6A 30       	add al, $30
0538+  0D03 23          	mov ah, al
0539+  0D04 19 00       	mov al, 0
0540+  0D06 05 03       	syscall sys_io	; print coeff
0541+  0D08             skip100:
0542+  0D08 E4          	pop a
0543+  0D09 22 00       	mov ah, 0
0544+  0D0B 26 0A 00    	mov b, 10
0545+  0D0E AE          	div a, b
0546+  0D0F D8          	push b			; save remainder
0547+  0D10 B9 00       	cmp al, 0
0548+  0D12 C6 1C 0D    	je skip10
0549+  0D15 6A 30       	add al, $30
0550+  0D17 23          	mov ah, al
0551+  0D18 19 00       	mov al, 0
0552+  0D1A 05 03       	syscall sys_io	; print coeff
0553+  0D1C             skip10:
0554+  0D1C E4          	pop a
0555+  0D1D 1B          	mov al, bl
0556+  0D1E 6A 30       	add al, $30
0557+  0D20 23          	mov ah, al
0558+  0D21 19 00       	mov al, 0
0559+  0D23 05 03       	syscall sys_io	; print coeff
0560+  0D25 E5          	pop b
0561+  0D26 E4          	pop a
0562+  0D27 09          	ret
0563+  0D28             
0564+  0D28             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0565+  0D28             ; INPUT 8BIT HEX INTEGER
0566+  0D28             ; read 8bit integer into AL
0567+  0D28             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  0D28             scan_u8x:
0569+  0D28 F8 04 00    	enter 4
0570+  0D2B D8          	push b
0571+  0D2C DA          	push d
0572+  0D2D             
0573+  0D2D FA FD FF    	lea d, [bp + -3]
0574+  0D30 07 0E 0B    	call gets				; get number
0575+  0D33             
0576+  0D33 32          	mov bl, [d]
0577+  0D34 37          	mov bh, bl
0578+  0D35 33 01 00    	mov bl, [d + 1]
0579+  0D38 07 BC 0A    	call atoi				; convert to int in AL
0580+  0D3B             
0581+  0D3B E7          	pop d
0582+  0D3C E5          	pop b
0583+  0D3D F9          	leave
0584+  0D3E 09          	ret
0585+  0D3F             
0586+  0D3F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0587+  0D3F             ; input decimal number
0588+  0D3F             ; result in A
0589+  0D3F             ; 655'\0'
0590+  0D3F             ; low--------high
0591+  0D3F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0592+  0D3F             scan_u16d:
0593+  0D3F F8 08 00    	enter 8
0594+  0D42 E2          	push si
0595+  0D43 D8          	push b
0596+  0D44 D9          	push c
0597+  0D45 DA          	push d
0598+  0D46 FA F9 FF    	lea d, [bp +- 7]
0599+  0D49 07 0E 0B    	call gets
0600+  0D4C 07 3C 0A    	call strlen			; get string length in C
0601+  0D4F 7E          	dec c
0602+  0D50 FD 4E       	mov si, d
0603+  0D52 12          	mov a, c
0604+  0D53 FD 99       	shl a
0605+  0D55 3B A4 0A    	mov d, table_power
0606+  0D58 59          	add d, a
0607+  0D59 38 00 00    	mov c, 0
0608+  0D5C             mul_loop:
0609+  0D5C F6          	lodsb			; load ASCII to al
0610+  0D5D B9 00       	cmp al, 0
0611+  0D5F C6 72 0D    	je mul_exit
0612+  0D62 6F 30       	sub al, $30		; make into integer
0613+  0D64 22 00       	mov ah, 0
0614+  0D66 2A          	mov b, [d]
0615+  0D67 AC          	mul a, b			; result in B since it fits in 16bits
0616+  0D68 11          	mov a, b
0617+  0D69 28          	mov b, c
0618+  0D6A 54          	add a, b
0619+  0D6B 39          	mov c, a
0620+  0D6C 63 02 00    	sub d, 2
0621+  0D6F 0A 5C 0D    	jmp mul_loop
0622+  0D72             mul_exit:
0623+  0D72 12          	mov a, c
0624+  0D73 E7          	pop d
0625+  0D74 E6          	pop c
0626+  0D75 E5          	pop b
0627+  0D76 EF          	pop si
0628+  0D77 F9          	leave
0629+  0D78 09          	ret
0699   0D79             ; --- END INCLUDE BLOCK
0700   0D79             
0701   0D79             
0702   0D79             .end
tasm: Number of errors = 0
