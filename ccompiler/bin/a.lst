0001   0000             
0002   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             
0004   0400             .org PROC_TEXT_ORG
0005   0400             
0006   0400             ; -----begin text block-----
0007   0400             main:
0008   0400             ; -----begin inline asm block-----
0009   0400 3B 4A 04      mov d, s_data
0010   0403 07 BC 06      call puts
0011   0406 07 BA 07      call scan_u16d
0012   0409 42 70 04      mov [rows], a
0013   040C             ; -----end inline asm block-----
0014   040C             _for1_init:
0015   040C 10 00 00      mov a, 0
0016   040F 26 00 00      mov b, 0
0017   0412 FD 42 74 04   mov [i], b
0018   0416             _for1_cond:
0019   0416 29 74 04      mov b, [i]
0020   0419 D7            push a
0021   041A 11            mov a, b
0022   041B 29 70 04      mov b, [rows]
0023   041E B0            cmp a, b
0024   041F 0E            lodflgs
0025   0420 87 02         and al, %00000010
0026   0422 22 00         mov ah, 0
0027   0424 27            mov b, a
0028   0425 E4            pop a
0029   0426 11            mov a, b
0030   0427 AF 00 00      cmp a, 0
0031   042A C6 48 04      je _for1_exit
0032   042D             _for1_block:
0033   042D             ; -----begin inline asm block-----
0034   042D 14 74 04      mov a, [i]
0035   0430 07 E5 06      call print_u16d
0036   0433             ; -----end inline asm block-----
0037   0433             _for1_update:
0038   0433 10 00 00      mov a, 0
0039   0436 29 74 04      mov b, [i]
0040   0439 D7            push a
0041   043A 11            mov a, b
0042   043B 26 01 00      mov b, 1
0043   043E 54            add a, b
0044   043F 27            mov b, a
0045   0440 E4            pop a
0046   0441 FD 42 74 04   mov [i], b
0047   0445 0A 16 04      jmp _for1_cond
0048   0448             _for1_exit:
0049   0448             ; -----begin inline asm block-----
0050   0448 05 0B         syscall sys_terminate_proc
0051   044A             ; -----end inline asm block-----
0052   044A             ; -----end text block-----
0053   044A             
0054   044A             ; -----begin data block-----
0055   044A 45 6E 74 65 s_data: .db "Enter the number of rows: ", 0
0055   044E 72 20 74 68 
0055   0452 65 20 6E 75 
0055   0456 6D 62 65 72 
0055   045A 20 6F 66 20 
0055   045E 72 6F 77 73 
0055   0462 3A 20 00 
0056   0465 4A 04       s: .dw s_data
0057   0467 20 20 20 20 ss_data: .db "    ", 0
0057   046B 00 
0058   046C 67 04       ss: .dw ss_data
0059   046E 01 00       coef: .dw 1
0060   0470 00 00       rows: .dw 0
0061   0472 00 00       space: .dw 0
0062   0474 00 00       i: .dw 0
0063   0476 00 00       j: .dw 0
0064   0478 0A 0D 00    nl_data: .db "\n\r", 0
0065   047B 78 04       nl: .dw nl_data
0066   047D             ; -----end data block-----
0067   047D             ; -----begin include block-----
0068   047D             .include "lib/stdio.asm"
0001+  047D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  047D             ; stdio.s
0003+  047D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  047D             .include "lib/string.asm"
0001++ 047D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 047D             ; string.s
0003++ 047D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 047D             
0005++ 047D             
0006++ 047D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 047D             ; strrev
0008++ 047D             ; reverse a string
0009++ 047D             ; D = string address
0010++ 047D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 047D             ; 01234
0012++ 047D             strrev:
0013++ 047D 4B          	pusha
0014++ 047E 07 C4 04    	call strlen	; length in C
0015++ 0481 12          	mov a, c
0016++ 0482 AF 01 00    	cmp a, 1
0017++ 0485 D0 9F 04    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0488 7D          	dec a
0019++ 0489 FD 4E       	mov si, d	; beginning of string
0020++ 048B FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 048D 59          	add d, a	; end of string
0022++ 048E 12          	mov a, c
0023++ 048F FD 9B       	shr a		; divide by 2
0024++ 0491 39          	mov c, a	; C now counts the steps
0025++ 0492             strrev_L0:
0026++ 0492 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0493 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0494 3E          	mov [d], al	; store left char into right side
0029++ 0495 1B          	mov al, bl
0030++ 0496 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0497 7E          	dec c
0032++ 0498 7F          	dec d
0033++ 0499 C2 00 00    	cmp c, 0
0034++ 049C C7 92 04    	jne strrev_L0
0035++ 049F             strrev_end:
0036++ 049F 4C          	popa
0037++ 04A0 09          	ret
0038++ 04A1             	
0039++ 04A1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 04A1             ; strchr
0041++ 04A1             ; search string in D for char in AL
0042++ 04A1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 04A1             strchr:
0044++ 04A1             strchr_L0:
0045++ 04A1 32          	mov bl, [d]
0046++ 04A2 C1 00       	cmp bl, 0
0047++ 04A4 C6 AF 04    	je strchr_end
0048++ 04A7 BA          	cmp al, bl
0049++ 04A8 C6 AF 04    	je strchr_end
0050++ 04AB 79          	inc d
0051++ 04AC 0A A1 04    	jmp strchr_L0
0052++ 04AF             strchr_end:
0053++ 04AF 1B          	mov al, bl
0054++ 04B0 09          	ret
0055++ 04B1             
0056++ 04B1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 04B1             ; strstr
0058++ 04B1             ; find sub-string
0059++ 04B1             ; str1 in SI
0060++ 04B1             ; str2 in DI
0061++ 04B1             ; SI points to end of source string
0062++ 04B1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 04B1             strstr:
0064++ 04B1 DB          	push al
0065++ 04B2 DA          	push d
0066++ 04B3 E3          	push di
0067++ 04B4             strstr_loop:
0068++ 04B4 F3          	cmpsb					; compare a byte of the strings
0069++ 04B5 C7 C0 04    	jne strstr_ret
0070++ 04B8 FC 00 00    	lea d, [di + 0]
0071++ 04BB BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 04BD C7 B4 04    	jne strstr_loop				; equal chars but not at end
0073++ 04C0             strstr_ret:
0074++ 04C0 F0          	pop di
0075++ 04C1 E7          	pop d
0076++ 04C2 E8          	pop al
0077++ 04C3 09          	ret
0078++ 04C4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 04C4             ; length of null terminated string
0080++ 04C4             ; result in C
0081++ 04C4             ; pointer in D
0082++ 04C4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 04C4             strlen:
0084++ 04C4 DA          	push d
0085++ 04C5 38 00 00    	mov c, 0
0086++ 04C8             strlen_L1:
0087++ 04C8 BD 00       	cmp byte [d], 0
0088++ 04CA C6 D2 04    	je strlen_ret
0089++ 04CD 79          	inc d
0090++ 04CE 78          	inc c
0091++ 04CF 0A C8 04    	jmp strlen_L1
0092++ 04D2             strlen_ret:
0093++ 04D2 E7          	pop d
0094++ 04D3 09          	ret
0095++ 04D4             
0096++ 04D4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 04D4             ; STRCMP
0098++ 04D4             ; compare two strings
0099++ 04D4             ; str1 in SI
0100++ 04D4             ; str2 in DI
0101++ 04D4             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 04D4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 04D4             strcmp:
0104++ 04D4 DB          	push al
0105++ 04D5 DA          	push d
0106++ 04D6 E3          	push di
0107++ 04D7 E2          	push si
0108++ 04D8             strcmp_loop:
0109++ 04D8 F3          	cmpsb					; compare a byte of the strings
0110++ 04D9 C7 E4 04    	jne strcmp_ret
0111++ 04DC FB FF FF    	lea d, [si +- 1]
0112++ 04DF BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 04E1 C7 D8 04    	jne strcmp_loop				; equal chars but not at end
0114++ 04E4             strcmp_ret:
0115++ 04E4 EF          	pop si
0116++ 04E5 F0          	pop di
0117++ 04E6 E7          	pop d
0118++ 04E7 E8          	pop al
0119++ 04E8 09          	ret
0120++ 04E9             
0121++ 04E9             
0122++ 04E9             ; STRCPY
0123++ 04E9             ; copy null terminated string from SI to DI
0124++ 04E9             ; source in SI
0125++ 04E9             ; destination in DI
0126++ 04E9             strcpy:
0127++ 04E9 E2          	push si
0128++ 04EA E3          	push di
0129++ 04EB DB          	push al
0130++ 04EC             strcpy_L1:
0131++ 04EC F6          	lodsb
0132++ 04ED F7          	stosb
0133++ 04EE B9 00       	cmp al, 0
0134++ 04F0 C7 EC 04    	jne strcpy_L1
0135++ 04F3             strcpy_end:
0136++ 04F3 E8          	pop al
0137++ 04F4 F0          	pop di
0138++ 04F5 EF          	pop si
0139++ 04F6 09          	ret
0140++ 04F7             
0141++ 04F7             ; STRCAT
0142++ 04F7             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 04F7             ; source in SI
0144++ 04F7             ; destination in DI
0145++ 04F7             strcat:
0146++ 04F7 E2          	push si
0147++ 04F8 E3          	push di
0148++ 04F9 D7          	push a
0149++ 04FA DA          	push d
0150++ 04FB 50          	mov a, di
0151++ 04FC 3C          	mov d, a
0152++ 04FD             strcat_goto_end_L1:
0153++ 04FD BD 00       	cmp byte[d], 0
0154++ 04FF C6 06 05    	je strcat_start
0155++ 0502 79          	inc d
0156++ 0503 0A FD 04    	jmp strcat_goto_end_L1
0157++ 0506             strcat_start:
0158++ 0506 FD 50       	mov di, d
0159++ 0508             strcat_L1:
0160++ 0508 F6          	lodsb
0161++ 0509 F7          	stosb
0162++ 050A B9 00       	cmp al, 0
0163++ 050C C7 08 05    	jne strcat_L1
0164++ 050F             strcat_end:
0165++ 050F E7          	pop d
0166++ 0510 E4          	pop a
0167++ 0511 F0          	pop di
0168++ 0512 EF          	pop si
0169++ 0513 09          	ret
0005+  0514             
0006+  0514 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  0518 34 35 36 37 
0006+  051C 38 39 41 42 
0006+  0520 43 44 45 46 
0007+  0524             
0008+  0524 01 00       table_power:.dw 1
0009+  0526 0A 00       			.dw 10
0010+  0528 64 00       			.dw 100
0011+  052A E8 03       			.dw 1000
0012+  052C 10 27       			.dw 10000
0013+  052E             
0014+  052E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0015+  052E             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0016+  052E             ; ASCII in BL
0017+  052E             ; result in AL
0018+  052E             ; ascii for F = 0100 0110
0019+  052E             ; ascii for 9 = 0011 1001
0020+  052E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0021+  052E             hex_ascii_encode:
0022+  052E 1B          	mov al, bl
0023+  052F 93 40       	test al, $40				; test if letter or number
0024+  0531 C7 37 05    	jnz hex_letter
0025+  0534 87 0F       	and al, $0F				; get number
0026+  0536 09          	ret
0027+  0537             hex_letter:
0028+  0537 87 0F       	and al, $0F				; get letter
0029+  0539 6A 09       	add al, 9
0030+  053B 09          	ret
0031+  053C             
0032+  053C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0033+  053C             ; ATOI
0034+  053C             ; 2 letter hex string in B
0035+  053C             ; 8bit integer returned in AL
0036+  053C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0037+  053C             atoi:
0038+  053C D8          	push b
0039+  053D 07 2E 05    	call hex_ascii_encode			; convert BL to 4bit code in AL
0040+  0540 30          	mov bl, bh
0041+  0541 DB          	push al					; save a
0042+  0542 07 2E 05    	call hex_ascii_encode
0043+  0545 EA          	pop bl	
0044+  0546 FD 9E 04    	shl al, 4
0045+  0549 8C          	or al, bl
0046+  054A E5          	pop b
0047+  054B 09          	ret	
0048+  054C             
0049+  054C             
0050+  054C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  054C             ; printf
0052+  054C             ; no need for explanations!
0053+  054C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0054+  054C             printf:
0055+  054C 09          	ret
0056+  054D             
0057+  054D             
0058+  054D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  054D             ; scanf
0060+  054D             ; no need for explanations!
0061+  054D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  054D             scanf:
0063+  054D 09          	ret
0064+  054E             
0065+  054E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  054E             ; ITOA
0067+  054E             ; 8bit value in BL
0068+  054E             ; 2 byte ASCII result in A
0069+  054E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0070+  054E             itoa:
0071+  054E DA          	push d
0072+  054F D8          	push b
0073+  0550 A7 00       	mov bh, 0
0074+  0552 FD A4 04    	shr bl, 4	
0075+  0555 74          	mov d, b
0076+  0556 1F 14 05    	mov al, [d + s_hex_digits]
0077+  0559 23          	mov ah, al
0078+  055A             	
0079+  055A E5          	pop b
0080+  055B D8          	push b
0081+  055C A7 00       	mov bh, 0
0082+  055E FD 87 0F    	and bl, $0F
0083+  0561 74          	mov d, b
0084+  0562 1F 14 05    	mov al, [d + s_hex_digits]
0085+  0565 E5          	pop b
0086+  0566 E7          	pop d
0087+  0567 09          	ret
0088+  0568             
0089+  0568             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0090+  0568             ; HEX STRING TO BINARY
0091+  0568             ; di = destination address
0092+  0568             ; si = source
0093+  0568             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0094+  0568             hex_to_int:
0095+  0568             hex_to_int_L1:
0096+  0568 F6          	lodsb					; load from [SI] to AL
0097+  0569 B9 00       	cmp al, 0				; check if ASCII 0
0098+  056B C6 78 05    	jz hex_to_int_ret
0099+  056E 36          	mov bh, al
0100+  056F F6          	lodsb
0101+  0570 2F          	mov bl, al
0102+  0571 07 3C 05    	call atoi				; convert ASCII byte in B to int (to AL)
0103+  0574 F7          	stosb					; store AL to [DI]
0104+  0575 0A 68 05    	jmp hex_to_int_L1
0105+  0578             hex_to_int_ret:
0106+  0578 09          	ret		
0107+  0579             
0108+  0579             
0109+  0579             
0110+  0579             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  0579             ; GETCHAR
0112+  0579             ; char in ah
0113+  0579             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0114+  0579             getchar:
0115+  0579 DB          	push al
0116+  057A             getchar_retry:
0117+  057A FD 0C       	sti
0118+  057C 19 01       	mov al, 1
0119+  057E 05 03       	syscall sys_io			; receive in AH
0120+  0580 B9 00       	cmp al, 0			; check if any char was receive
0121+  0582 C6 7A 05    	je getchar_retry
0122+  0585 E8          	pop al
0123+  0586 09          	ret
0124+  0587             
0125+  0587             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0126+  0587             ; PUTCHAR
0127+  0587             ; char in ah
0128+  0587             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  0587             putchar:
0130+  0587 D7          	push a
0131+  0588 19 00       	mov al, 0
0132+  058A 05 03       	syscall sys_io			; char in AH
0133+  058C E4          	pop a
0134+  058D 09          	ret
0135+  058E             
0136+  058E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0137+  058E             ;; INPUT A STRING
0138+  058E             ;; terminates with null
0139+  058E             ;; pointer in D
0140+  058E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  058E             gets:
0142+  058E D7          	push a
0143+  058F DA          	push d
0144+  0590             gets_loop:
0145+  0590 FD 0C       	sti
0146+  0592 19 01       	mov al, 1
0147+  0594 05 03       	syscall sys_io			; receive in AH
0148+  0596 B9 00       	cmp al, 0				; check error code (AL)
0149+  0598 C6 90 05    	je gets_loop			; if no char received, retry
0150+  059B             
0151+  059B 76 1B       	cmp ah, 27
0152+  059D C6 B9 05    	je gets_telnet_escape
0153+  05A0 76 0A       	cmp ah, $0A				; LF
0154+  05A2 C6 12 06    	je gets_end
0155+  05A5 76 5C       	cmp ah, $5C				; '\\'
0156+  05A7 C6 E9 05    	je gets_escape
0157+  05AA             	
0158+  05AA 76 08       	cmp ah, $08			; check for backspace
0159+  05AC C6 B5 05    	je gets_backspace
0160+  05AF             
0161+  05AF 1A          	mov al, ah
0162+  05B0 3E          	mov [d], al
0163+  05B1 79          	inc d
0164+  05B2 0A 90 05    	jmp gets_loop
0165+  05B5             gets_backspace:
0166+  05B5 7F          	dec d
0167+  05B6 0A 90 05    	jmp gets_loop
0168+  05B9             gets_telnet_escape:
0169+  05B9 FD 0C       	sti
0170+  05BB 19 01       	mov al, 1
0171+  05BD 05 03       	syscall sys_io				; receive in AH without echo
0172+  05BF B9 00       	cmp al, 0					; check error code (AL)
0173+  05C1 C6 B9 05    	je gets_telnet_escape		; if no char received, retry
0174+  05C4 76 5B       	cmp ah, '['
0175+  05C6 C7 90 05    	jne gets_loop
0176+  05C9             gets_telnet_escape_phase2:
0177+  05C9 FD 0C       	sti
0178+  05CB 19 01       	mov al, 1
0179+  05CD 05 03       	syscall sys_io					; receive in AH without echo
0180+  05CF B9 00       	cmp al, 0						; check error code (AL)
0181+  05D1 C6 C9 05    	je gets_telnet_escape_phase2	; if no char received, retry
0182+  05D4 76 44       	cmp ah, 'D'
0183+  05D6 C6 E1 05    	je gets_left_arrow
0184+  05D9 76 43       	cmp ah, 'C'
0185+  05DB C6 E5 05    	je gets_right_arrow
0186+  05DE 0A 90 05    	jmp gets_loop
0187+  05E1             gets_left_arrow:
0188+  05E1 7F          	dec d
0189+  05E2 0A 90 05    	jmp gets_loop
0190+  05E5             gets_right_arrow:
0191+  05E5 79          	inc d
0192+  05E6 0A 90 05    	jmp gets_loop
0193+  05E9             gets_escape:
0194+  05E9 FD 0C       	sti
0195+  05EB 19 01       	mov al, 1
0196+  05ED 05 03       	syscall sys_io			; receive in AH
0197+  05EF B9 00       	cmp al, 0				; check error code (AL)
0198+  05F1 C6 E9 05    	je gets_escape			; if no char received, retry
0199+  05F4 76 6E       	cmp ah, 'n'
0200+  05F6 C6 04 06    	je gets_LF
0201+  05F9 76 72       	cmp ah, 'r'
0202+  05FB C6 0B 06    	je gets_CR
0203+  05FE 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0204+  05FF 3E          	mov [d], al
0205+  0600 79          	inc d
0206+  0601 0A 90 05    	jmp gets_loop
0207+  0604             gets_LF:
0208+  0604 19 0A       	mov al, $0A
0209+  0606 3E          	mov [d], al
0210+  0607 79          	inc d
0211+  0608 0A 90 05    	jmp gets_loop
0212+  060B             gets_CR:
0213+  060B 19 0D       	mov al, $0D
0214+  060D 3E          	mov [d], al
0215+  060E 79          	inc d
0216+  060F 0A 90 05    	jmp gets_loop
0217+  0612             gets_end:
0218+  0612 19 00       	mov al, 0
0219+  0614 3E          	mov [d], al				; terminate string
0220+  0615 E7          	pop d
0221+  0616 E4          	pop a
0222+  0617 09          	ret
0223+  0618             
0224+  0618             
0225+  0618             
0226+  0618             
0227+  0618             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0228+  0618             ;; INPUT TEXT
0229+  0618             ;; terminated with CTRL+D
0230+  0618             ;; pointer in D
0231+  0618             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0232+  0618             gettxt:
0233+  0618 D7          	push a
0234+  0619 DA          	push d
0235+  061A             gettxt_loop:
0236+  061A 19 01       	mov al, 1
0237+  061C 05 03       	syscall sys_io			; receive in AH
0238+  061E B9 00       	cmp al, 0				; check error code (AL)
0239+  0620 C6 1A 06    	je gettxt_loop		; if no char received, retry
0240+  0623 76 04       	cmp ah, 4			; EOT
0241+  0625 C6 63 06    	je gettxt_end
0242+  0628 76 08       	cmp ah, $08			; check for backspace
0243+  062A C6 5F 06    	je gettxt_backspace
0244+  062D 76 5C       	cmp ah, $5C				; '\\'
0245+  062F C6 38 06    	je gettxt_escape
0246+  0632 1A          	mov al, ah
0247+  0633 3E          	mov [d], al
0248+  0634 79          	inc d
0249+  0635 0A 1A 06    	jmp gettxt_loop
0250+  0638             gettxt_escape:
0251+  0638 19 01       	mov al, 1
0252+  063A 05 03       	syscall sys_io			; receive in AH
0253+  063C B9 00       	cmp al, 0				; check error code (AL)
0254+  063E C6 38 06    	je gettxt_escape		; if no char received, retry
0255+  0641 76 6E       	cmp ah, 'n'
0256+  0643 C6 51 06    	je gettxt_LF
0257+  0646 76 72       	cmp ah, 'r'
0258+  0648 C6 58 06    	je gettxt_CR
0259+  064B 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0260+  064C 3E          	mov [d], al
0261+  064D 79          	inc d
0262+  064E 0A 1A 06    	jmp gettxt_loop
0263+  0651             gettxt_LF:
0264+  0651 19 0A       	mov al, $0A
0265+  0653 3E          	mov [d], al
0266+  0654 79          	inc d
0267+  0655 0A 1A 06    	jmp gettxt_loop
0268+  0658             gettxt_CR:
0269+  0658 19 0D       	mov al, $0D
0270+  065A 3E          	mov [d], al
0271+  065B 79          	inc d
0272+  065C 0A 1A 06    	jmp gettxt_loop
0273+  065F             gettxt_backspace:
0274+  065F 7F          	dec d
0275+  0660 0A 1A 06    	jmp gettxt_loop
0276+  0663             gettxt_end:
0277+  0663 19 00       	mov al, 0
0278+  0665 3E          	mov [d], al				; terminate string
0279+  0666 E7          	pop d
0280+  0667 E4          	pop a
0281+  0668 09          	ret
0282+  0669             
0283+  0669             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0284+  0669             ; PRINT NEW LINE
0285+  0669             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0286+  0669             printnl:
0287+  0669 D7          	push a
0288+  066A 10 00 0A    	mov a, $0A00
0289+  066D 05 03       	syscall sys_io
0290+  066F 10 00 0D    	mov a, $0D00
0291+  0672 05 03       	syscall sys_io
0292+  0674 E4          	pop a
0293+  0675 09          	ret
0294+  0676             
0295+  0676             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0296+  0676             ; strtoint
0297+  0676             ; 4 digit hex string number in d
0298+  0676             ; integer returned in A
0299+  0676             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0300+  0676             strtointx:
0301+  0676 D8          	push b
0302+  0677 32          	mov bl, [d]
0303+  0678 37          	mov bh, bl
0304+  0679 33 01 00    	mov bl, [d + 1]
0305+  067C 07 3C 05    	call atoi				; convert to int in AL
0306+  067F 23          	mov ah, al				; move to AH
0307+  0680 33 02 00    	mov bl, [d + 2]
0308+  0683 37          	mov bh, bl
0309+  0684 33 03 00    	mov bl, [d + 3]
0310+  0687 07 3C 05    	call atoi				; convert to int in AL
0311+  068A E5          	pop b
0312+  068B 09          	ret
0313+  068C             
0314+  068C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0315+  068C             ; strtoint
0316+  068C             ; 5 digit base10 string number in d
0317+  068C             ; integer returned in A
0318+  068C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0319+  068C             strtoint:
0320+  068C E2          	push si
0321+  068D D8          	push b
0322+  068E D9          	push c
0323+  068F DA          	push d
0324+  0690 07 C4 04    	call strlen			; get string length in C
0325+  0693 7E          	dec c
0326+  0694 FD 4E       	mov si, d
0327+  0696 12          	mov a, c
0328+  0697 FD 99       	shl a
0329+  0699 3B 24 05    	mov d, table_power
0330+  069C 59          	add d, a
0331+  069D 38 00 00    	mov c, 0
0332+  06A0             strtoint_L0:
0333+  06A0 F6          	lodsb			; load ASCII to al
0334+  06A1 B9 00       	cmp al, 0
0335+  06A3 C6 B6 06    	je strtoint_end
0336+  06A6 6F 30       	sub al, $30		; make into integer
0337+  06A8 22 00       	mov ah, 0
0338+  06AA 2A          	mov b, [d]
0339+  06AB AC          	mul a, b			; result in B since it fits in 16bits
0340+  06AC 11          	mov a, b
0341+  06AD 28          	mov b, c
0342+  06AE 54          	add a, b
0343+  06AF 39          	mov c, a
0344+  06B0 63 02 00    	sub d, 2
0345+  06B3 0A A0 06    	jmp strtoint_L0
0346+  06B6             strtoint_end:
0347+  06B6 12          	mov a, c
0348+  06B7 E7          	pop d
0349+  06B8 E6          	pop c
0350+  06B9 E5          	pop b
0351+  06BA EF          	pop si
0352+  06BB 09          	ret
0353+  06BC             
0354+  06BC             
0355+  06BC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  06BC             ; PRINT NULL TERMINATED STRING
0357+  06BC             ; pointer in D
0358+  06BC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  06BC             puts:
0360+  06BC D7          	push a
0361+  06BD DA          	push d
0362+  06BE             puts_L1:
0363+  06BE 1E          	mov al, [d]
0364+  06BF B9 00       	cmp al, 0
0365+  06C1 C6 CD 06    	jz puts_END
0366+  06C4 23          	mov ah, al
0367+  06C5 19 00       	mov al, 0
0368+  06C7 05 03       	syscall sys_io
0369+  06C9 79          	inc d
0370+  06CA 0A BE 06    	jmp puts_L1
0371+  06CD             puts_END:
0372+  06CD E7          	pop d
0373+  06CE E4          	pop a
0374+  06CF 09          	ret
0375+  06D0             
0376+  06D0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0377+  06D0             ; PRINT N SIZE STRING
0378+  06D0             ; pointer in D
0379+  06D0             ; size in C
0380+  06D0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0381+  06D0             putsn:
0382+  06D0 DB          	push al
0383+  06D1 DA          	push d
0384+  06D2 D9          	push c
0385+  06D3             putsn_L0:
0386+  06D3 1E          	mov al, [d]
0387+  06D4 23          	mov ah, al
0388+  06D5 19 00       	mov al, 0
0389+  06D7 05 03       	syscall sys_io
0390+  06D9 79          	inc d
0391+  06DA 7E          	dec c	
0392+  06DB C2 00 00    	cmp c, 0
0393+  06DE C7 D3 06    	jne putsn_L0
0394+  06E1             putsn_end:
0395+  06E1 E6          	pop c
0396+  06E2 E7          	pop d
0397+  06E3 E8          	pop al
0398+  06E4 09          	ret
0399+  06E5             
0400+  06E5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0401+  06E5             ; print 16bit decimal number
0402+  06E5             ; input number in A
0403+  06E5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  06E5             print_u16d:
0405+  06E5 D7          	push a
0406+  06E6 D8          	push b
0407+  06E7 26 10 27    	mov b, 10000
0408+  06EA AE          	div a, b			; get 10000 coeff.
0409+  06EB 07 11 07    	call print_zero_or_space
0410+  06EE 11          	mov a, b
0411+  06EF 26 E8 03    	mov b, 1000
0412+  06F2 AE          	div a, b			; get 10000 coeff.
0413+  06F3 07 11 07    	call print_zero_or_space
0414+  06F6 11          	mov a, b
0415+  06F7 26 64 00    	mov b, 100
0416+  06FA AE          	div a, b
0417+  06FB 07 11 07    	call print_zero_or_space
0418+  06FE 11          	mov a, b
0419+  06FF 26 0A 00    	mov b, 10
0420+  0702 AE          	div a, b
0421+  0703 07 11 07    	call print_zero_or_space
0422+  0706 11          	mov a, b
0423+  0707 6A 30       	add al, $30
0424+  0709 23          	mov ah, al
0425+  070A 19 00       	mov al, 0
0426+  070C 05 03       	syscall sys_io	; print coeff
0427+  070E E5          	pop b
0428+  070F E4          	pop a
0429+  0710 09          	ret
0430+  0711             
0431+  0711             
0432+  0711             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0433+  0711             ; if A == 0, print space
0434+  0711             ; else print A
0435+  0711             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  0711             print_zero_or_space:
0437+  0711             	; cmp a, 0
0438+  0711             	; jne print_number
0439+  0711             	; mov ah, $20
0440+  0711             	; call putchar
0441+  0711             	; ret
0442+  0711             print_number:
0443+  0711 6A 30       	add al, $30
0444+  0713 23          	mov ah, al
0445+  0714 07 87 05    	call putchar
0446+  0717 09          	ret
0447+  0718             
0448+  0718             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  0718             ; PRINT 16BIT HEX INTEGER
0450+  0718             ; integer value in reg B
0451+  0718             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0452+  0718             print_u16x:
0453+  0718 D7          	push a
0454+  0719 D8          	push b
0455+  071A DD          	push bl
0456+  071B 30          	mov bl, bh
0457+  071C 07 4E 05    	call itoa				; convert bh to char in A
0458+  071F 2F          	mov bl, al				; save al
0459+  0720 19 00       	mov al, 0
0460+  0722 05 03       	syscall sys_io				; display AH
0461+  0724 24          	mov ah, bl				; retrieve al
0462+  0725 19 00       	mov al, 0
0463+  0727 05 03       	syscall sys_io				; display AL
0464+  0729             
0465+  0729 EA          	pop bl
0466+  072A 07 4E 05    	call itoa				; convert bh to char in A
0467+  072D 2F          	mov bl, al				; save al
0468+  072E 19 00       	mov al, 0
0469+  0730 05 03       	syscall sys_io				; display AH
0470+  0732 24          	mov ah, bl				; retrieve al
0471+  0733 19 00       	mov al, 0
0472+  0735 05 03       	syscall sys_io				; display AL
0473+  0737             
0474+  0737 E5          	pop b
0475+  0738 E4          	pop a
0476+  0739 09          	ret
0477+  073A             
0478+  073A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  073A             ; INPUT 16BIT HEX INTEGER
0480+  073A             ; read 16bit integer into A
0481+  073A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0482+  073A             scan_u16x:
0483+  073A F8 10 00    	enter 16
0484+  073D D8          	push b
0485+  073E DA          	push d
0486+  073F             
0487+  073F FA F1 FF    	lea d, [bp + -15]
0488+  0742 07 8E 05    	call gets				; get number
0489+  0745             
0490+  0745 32          	mov bl, [d]
0491+  0746 37          	mov bh, bl
0492+  0747 33 01 00    	mov bl, [d + 1]
0493+  074A 07 3C 05    	call atoi				; convert to int in AL
0494+  074D 23          	mov ah, al				; move to AH
0495+  074E             
0496+  074E 33 02 00    	mov bl, [d + 2]
0497+  0751 37          	mov bh, bl
0498+  0752 33 03 00    	mov bl, [d + 3]
0499+  0755 07 3C 05    	call atoi				; convert to int in AL
0500+  0758             
0501+  0758 E7          	pop d
0502+  0759 E5          	pop b
0503+  075A F9          	leave
0504+  075B 09          	ret
0505+  075C             
0506+  075C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  075C             ; PRINT 8bit HEX INTEGER
0508+  075C             ; integer value in reg bl
0509+  075C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0510+  075C             print_u8x:
0511+  075C D7          	push a
0512+  075D DD          	push bl
0513+  075E             
0514+  075E 07 4E 05    	call itoa				; convert bl to char in A
0515+  0761 2F          	mov bl, al				; save al
0516+  0762 19 00       	mov al, 0
0517+  0764 05 03       	syscall sys_io				; display AH
0518+  0766 24          	mov ah, bl				; retrieve al
0519+  0767 19 00       	mov al, 0
0520+  0769 05 03       	syscall sys_io				; display AL
0521+  076B             
0522+  076B EA          	pop bl
0523+  076C E4          	pop a
0524+  076D 09          	ret
0525+  076E             
0526+  076E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  076E             ; print 8bit decimal unsigned number
0528+  076E             ; input number in AL
0529+  076E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0530+  076E             print_u8d:
0531+  076E D7          	push a
0532+  076F D8          	push b
0533+  0770             
0534+  0770 22 00       	mov ah, 0
0535+  0772 26 64 00    	mov b, 100
0536+  0775 AE          	div a, b
0537+  0776 D8          	push b			; save remainder
0538+  0777 B9 00       	cmp al, 0
0539+  0779 C6 83 07    	je skip100
0540+  077C 6A 30       	add al, $30
0541+  077E 23          	mov ah, al
0542+  077F 19 00       	mov al, 0
0543+  0781 05 03       	syscall sys_io	; print coeff
0544+  0783             skip100:
0545+  0783 E4          	pop a
0546+  0784 22 00       	mov ah, 0
0547+  0786 26 0A 00    	mov b, 10
0548+  0789 AE          	div a, b
0549+  078A D8          	push b			; save remainder
0550+  078B B9 00       	cmp al, 0
0551+  078D C6 97 07    	je skip10
0552+  0790 6A 30       	add al, $30
0553+  0792 23          	mov ah, al
0554+  0793 19 00       	mov al, 0
0555+  0795 05 03       	syscall sys_io	; print coeff
0556+  0797             skip10:
0557+  0797 E4          	pop a
0558+  0798 1B          	mov al, bl
0559+  0799 6A 30       	add al, $30
0560+  079B 23          	mov ah, al
0561+  079C 19 00       	mov al, 0
0562+  079E 05 03       	syscall sys_io	; print coeff
0563+  07A0 E5          	pop b
0564+  07A1 E4          	pop a
0565+  07A2 09          	ret
0566+  07A3             
0567+  07A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  07A3             ; INPUT 8BIT HEX INTEGER
0569+  07A3             ; read 8bit integer into AL
0570+  07A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0571+  07A3             scan_u8x:
0572+  07A3 F8 04 00    	enter 4
0573+  07A6 D8          	push b
0574+  07A7 DA          	push d
0575+  07A8             
0576+  07A8 FA FD FF    	lea d, [bp + -3]
0577+  07AB 07 8E 05    	call gets				; get number
0578+  07AE             
0579+  07AE 32          	mov bl, [d]
0580+  07AF 37          	mov bh, bl
0581+  07B0 33 01 00    	mov bl, [d + 1]
0582+  07B3 07 3C 05    	call atoi				; convert to int in AL
0583+  07B6             
0584+  07B6 E7          	pop d
0585+  07B7 E5          	pop b
0586+  07B8 F9          	leave
0587+  07B9 09          	ret
0588+  07BA             
0589+  07BA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0590+  07BA             ; input decimal number
0591+  07BA             ; result in A
0592+  07BA             ; 655'\0'
0593+  07BA             ; low--------high
0594+  07BA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0595+  07BA             scan_u16d:
0596+  07BA F8 08 00    	enter 8
0597+  07BD E2          	push si
0598+  07BE D8          	push b
0599+  07BF D9          	push c
0600+  07C0 DA          	push d
0601+  07C1 FA F9 FF    	lea d, [bp +- 7]
0602+  07C4 07 8E 05    	call gets
0603+  07C7 07 C4 04    	call strlen			; get string length in C
0604+  07CA 7E          	dec c
0605+  07CB FD 4E       	mov si, d
0606+  07CD 12          	mov a, c
0607+  07CE FD 99       	shl a
0608+  07D0 3B 24 05    	mov d, table_power
0609+  07D3 59          	add d, a
0610+  07D4 38 00 00    	mov c, 0
0611+  07D7             mul_loop:
0612+  07D7 F6          	lodsb			; load ASCII to al
0613+  07D8 B9 00       	cmp al, 0
0614+  07DA C6 ED 07    	je mul_exit
0615+  07DD 6F 30       	sub al, $30		; make into integer
0616+  07DF 22 00       	mov ah, 0
0617+  07E1 2A          	mov b, [d]
0618+  07E2 AC          	mul a, b			; result in B since it fits in 16bits
0619+  07E3 11          	mov a, b
0620+  07E4 28          	mov b, c
0621+  07E5 54          	add a, b
0622+  07E6 39          	mov c, a
0623+  07E7 63 02 00    	sub d, 2
0624+  07EA 0A D7 07    	jmp mul_loop
0625+  07ED             mul_exit:
0626+  07ED 12          	mov a, c
0627+  07EE E7          	pop d
0628+  07EF E6          	pop c
0629+  07F0 E5          	pop b
0630+  07F1 EF          	pop si
0631+  07F2 F9          	leave
0632+  07F3 09          	ret
0069   07F4             ; -----end include block-----
0070   07F4             
0071   07F4             .end
tasm: Number of errors = 0
