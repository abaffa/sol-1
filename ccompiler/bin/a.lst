0001   0000             ; -----begin include block-----
0002   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/stdio.asm"
0001+  0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0000             ; stdio.s
0003+  0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0000             .include "lib/string.asm"
0001++ 0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0000             ; string.s
0003++ 0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0000             
0005++ 0000             
0006++ 0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0000             ; strrev
0008++ 0000             ; reverse a string
0009++ 0000             ; D = string address
0010++ 0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0000             ; 01234
0012++ 0000             strrev:
0013++ 0000 4B          	pusha
0014++ 0001 07 47 00    	call strlen	; length in C
0015++ 0004 12          	mov a, c
0016++ 0005 AF 01 00    	cmp a, 1
0017++ 0008 D0 22 00    	jleu strrev_end	; check string length. string len must be > 1
0018++ 000B 7D          	dec a
0019++ 000C FD 4E       	mov si, d	; beginning of string
0020++ 000E FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0010 59          	add d, a	; end of string
0022++ 0011 12          	mov a, c
0023++ 0012 FD 9B       	shr a		; divide by 2
0024++ 0014 39          	mov c, a	; C now counts the steps
0025++ 0015             strrev_L0:
0026++ 0015 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0016 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0017 3E          	mov [d], al	; store left char into right side
0029++ 0018 1B          	mov al, bl
0030++ 0019 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 001A 7E          	dec c
0032++ 001B 7F          	dec d
0033++ 001C C2 00 00    	cmp c, 0
0034++ 001F C7 15 00    	jne strrev_L0
0035++ 0022             strrev_end:
0036++ 0022 4C          	popa
0037++ 0023 09          	ret
0038++ 0024             	
0039++ 0024             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0024             ; strchr
0041++ 0024             ; search string in D for char in AL
0042++ 0024             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0024             strchr:
0044++ 0024             strchr_L0:
0045++ 0024 32          	mov bl, [d]
0046++ 0025 C1 00       	cmp bl, 0
0047++ 0027 C6 32 00    	je strchr_end
0048++ 002A BA          	cmp al, bl
0049++ 002B C6 32 00    	je strchr_end
0050++ 002E 79          	inc d
0051++ 002F 0A 24 00    	jmp strchr_L0
0052++ 0032             strchr_end:
0053++ 0032 1B          	mov al, bl
0054++ 0033 09          	ret
0055++ 0034             
0056++ 0034             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0034             ; strstr
0058++ 0034             ; find sub-string
0059++ 0034             ; str1 in SI
0060++ 0034             ; str2 in DI
0061++ 0034             ; SI points to end of source string
0062++ 0034             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0034             strstr:
0064++ 0034 DB          	push al
0065++ 0035 DA          	push d
0066++ 0036 E3          	push di
0067++ 0037             strstr_loop:
0068++ 0037 F3          	cmpsb					; compare a byte of the strings
0069++ 0038 C7 43 00    	jne strstr_ret
0070++ 003B FC 00 00    	lea d, [di + 0]
0071++ 003E BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0040 C7 37 00    	jne strstr_loop				; equal chars but not at end
0073++ 0043             strstr_ret:
0074++ 0043 F0          	pop di
0075++ 0044 E7          	pop d
0076++ 0045 E8          	pop al
0077++ 0046 09          	ret
0078++ 0047             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0047             ; length of null terminated string
0080++ 0047             ; result in C
0081++ 0047             ; pointer in D
0082++ 0047             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0047             strlen:
0084++ 0047 DA          	push d
0085++ 0048 38 00 00    	mov c, 0
0086++ 004B             strlen_L1:
0087++ 004B BD 00       	cmp byte [d], 0
0088++ 004D C6 55 00    	je strlen_ret
0089++ 0050 79          	inc d
0090++ 0051 78          	inc c
0091++ 0052 0A 4B 00    	jmp strlen_L1
0092++ 0055             strlen_ret:
0093++ 0055 E7          	pop d
0094++ 0056 09          	ret
0095++ 0057             
0096++ 0057             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0057             ; STRCMP
0098++ 0057             ; compare two strings
0099++ 0057             ; str1 in SI
0100++ 0057             ; str2 in DI
0101++ 0057             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0057             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0057             strcmp:
0104++ 0057 DB          	push al
0105++ 0058 DA          	push d
0106++ 0059 E3          	push di
0107++ 005A E2          	push si
0108++ 005B             strcmp_loop:
0109++ 005B F3          	cmpsb					; compare a byte of the strings
0110++ 005C C7 67 00    	jne strcmp_ret
0111++ 005F FB FF FF    	lea d, [si +- 1]
0112++ 0062 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0064 C7 5B 00    	jne strcmp_loop				; equal chars but not at end
0114++ 0067             strcmp_ret:
0115++ 0067 EF          	pop si
0116++ 0068 F0          	pop di
0117++ 0069 E7          	pop d
0118++ 006A E8          	pop al
0119++ 006B 09          	ret
0120++ 006C             
0121++ 006C             
0122++ 006C             ; STRCPY
0123++ 006C             ; copy null terminated string from SI to DI
0124++ 006C             ; source in SI
0125++ 006C             ; destination in DI
0126++ 006C             strcpy:
0127++ 006C E2          	push si
0128++ 006D E3          	push di
0129++ 006E DB          	push al
0130++ 006F             strcpy_L1:
0131++ 006F F6          	lodsb
0132++ 0070 F7          	stosb
0133++ 0071 B9 00       	cmp al, 0
0134++ 0073 C7 6F 00    	jne strcpy_L1
0135++ 0076             strcpy_end:
0136++ 0076 E8          	pop al
0137++ 0077 F0          	pop di
0138++ 0078 EF          	pop si
0139++ 0079 09          	ret
0140++ 007A             
0141++ 007A             ; STRCAT
0142++ 007A             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 007A             ; source in SI
0144++ 007A             ; destination in DI
0145++ 007A             strcat:
0146++ 007A E2          	push si
0147++ 007B E3          	push di
0148++ 007C D7          	push a
0149++ 007D DA          	push d
0150++ 007E 50          	mov a, di
0151++ 007F 3C          	mov d, a
0152++ 0080             strcat_goto_end_L1:
0153++ 0080 BD 00       	cmp byte[d], 0
0154++ 0082 C6 89 00    	je strcat_start
0155++ 0085 79          	inc d
0156++ 0086 0A 80 00    	jmp strcat_goto_end_L1
0157++ 0089             strcat_start:
0158++ 0089 FD 50       	mov di, d
0159++ 008B             strcat_L1:
0160++ 008B F6          	lodsb
0161++ 008C F7          	stosb
0162++ 008D B9 00       	cmp al, 0
0163++ 008F C7 8B 00    	jne strcat_L1
0164++ 0092             strcat_end:
0165++ 0092 E7          	pop d
0166++ 0093 E4          	pop a
0167++ 0094 F0          	pop di
0168++ 0095 EF          	pop si
0169++ 0096 09          	ret
0005+  0097             
0006+  0097 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  009B 34 35 36 37 
0006+  009F 38 39 41 42 
0006+  00A3 43 44 45 46 
0007+  00A7             
0008+  00A7 01 00       table_power:.dw 1
0009+  00A9 0A 00       			.dw 10
0010+  00AB 64 00       			.dw 100
0011+  00AD E8 03       			.dw 1000
0012+  00AF 10 27       			.dw 10000
0013+  00B1             
0014+  00B1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0015+  00B1             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0016+  00B1             ; ASCII in BL
0017+  00B1             ; result in AL
0018+  00B1             ; ascii for F = 0100 0110
0019+  00B1             ; ascii for 9 = 0011 1001
0020+  00B1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0021+  00B1             hex_ascii_encode:
0022+  00B1 1B          	mov al, bl
0023+  00B2 93 40       	test al, $40				; test if letter or number
0024+  00B4 C7 BA 00    	jnz hex_letter
0025+  00B7 87 0F       	and al, $0F				; get number
0026+  00B9 09          	ret
0027+  00BA             hex_letter:
0028+  00BA 87 0F       	and al, $0F				; get letter
0029+  00BC 6A 09       	add al, 9
0030+  00BE 09          	ret
0031+  00BF             
0032+  00BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0033+  00BF             ; ATOI
0034+  00BF             ; 2 letter hex string in B
0035+  00BF             ; 8bit integer returned in AL
0036+  00BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0037+  00BF             atoi:
0038+  00BF D8          	push b
0039+  00C0 07 B1 00    	call hex_ascii_encode			; convert BL to 4bit code in AL
0040+  00C3 30          	mov bl, bh
0041+  00C4 DB          	push al					; save a
0042+  00C5 07 B1 00    	call hex_ascii_encode
0043+  00C8 EA          	pop bl	
0044+  00C9 FD 9E 04    	shl al, 4
0045+  00CC 8C          	or al, bl
0046+  00CD E5          	pop b
0047+  00CE 09          	ret	
0048+  00CF             
0049+  00CF             
0050+  00CF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  00CF             ; printf
0052+  00CF             ; no need for explanations!
0053+  00CF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0054+  00CF             printf:
0055+  00CF 09          	ret
0056+  00D0             
0057+  00D0             
0058+  00D0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  00D0             ; scanf
0060+  00D0             ; no need for explanations!
0061+  00D0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  00D0             scanf:
0063+  00D0 09          	ret
0064+  00D1             
0065+  00D1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  00D1             ; ITOA
0067+  00D1             ; 8bit value in BL
0068+  00D1             ; 2 byte ASCII result in A
0069+  00D1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0070+  00D1             itoa:
0071+  00D1 DA          	push d
0072+  00D2 D8          	push b
0073+  00D3 A7 00       	mov bh, 0
0074+  00D5 FD A4 04    	shr bl, 4	
0075+  00D8 74          	mov d, b
0076+  00D9 1F 97 00    	mov al, [d + s_hex_digits]
0077+  00DC 23          	mov ah, al
0078+  00DD             	
0079+  00DD E5          	pop b
0080+  00DE D8          	push b
0081+  00DF A7 00       	mov bh, 0
0082+  00E1 FD 87 0F    	and bl, $0F
0083+  00E4 74          	mov d, b
0084+  00E5 1F 97 00    	mov al, [d + s_hex_digits]
0085+  00E8 E5          	pop b
0086+  00E9 E7          	pop d
0087+  00EA 09          	ret
0088+  00EB             
0089+  00EB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0090+  00EB             ; HEX STRING TO BINARY
0091+  00EB             ; di = destination address
0092+  00EB             ; si = source
0093+  00EB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0094+  00EB             hex_to_int:
0095+  00EB             hex_to_int_L1:
0096+  00EB F6          	lodsb					; load from [SI] to AL
0097+  00EC B9 00       	cmp al, 0				; check if ASCII 0
0098+  00EE C6 FB 00    	jz hex_to_int_ret
0099+  00F1 36          	mov bh, al
0100+  00F2 F6          	lodsb
0101+  00F3 2F          	mov bl, al
0102+  00F4 07 BF 00    	call atoi				; convert ASCII byte in B to int (to AL)
0103+  00F7 F7          	stosb					; store AL to [DI]
0104+  00F8 0A EB 00    	jmp hex_to_int_L1
0105+  00FB             hex_to_int_ret:
0106+  00FB 09          	ret		
0107+  00FC             
0108+  00FC             
0109+  00FC             
0110+  00FC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  00FC             ; GETCHAR
0112+  00FC             ; char in ah
0113+  00FC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0114+  00FC             getchar:
0115+  00FC DB          	push al
0116+  00FD             getchar_retry:
0117+  00FD FD 0C       	sti
0118+  00FF 19 01       	mov al, 1
0119+  0101 05 03       	syscall sys_io			; receive in AH
0120+  0103 B9 00       	cmp al, 0			; check if any char was receive
0121+  0105 C6 FD 00    	je getchar_retry
0122+  0108 E8          	pop al
0123+  0109 09          	ret
0124+  010A             
0125+  010A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0126+  010A             ; PUTCHAR
0127+  010A             ; char in ah
0128+  010A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  010A             putchar:
0130+  010A D7          	push a
0131+  010B 19 00       	mov al, 0
0132+  010D 05 03       	syscall sys_io			; char in AH
0133+  010F E4          	pop a
0134+  0110 09          	ret
0135+  0111             
0136+  0111             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0137+  0111             ;; INPUT A STRING
0138+  0111             ;; terminates with null
0139+  0111             ;; pointer in D
0140+  0111             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  0111             gets:
0142+  0111 D7          	push a
0143+  0112 DA          	push d
0144+  0113             gets_loop:
0145+  0113 FD 0C       	sti
0146+  0115 19 01       	mov al, 1
0147+  0117 05 03       	syscall sys_io			; receive in AH
0148+  0119 B9 00       	cmp al, 0				; check error code (AL)
0149+  011B C6 13 01    	je gets_loop			; if no char received, retry
0150+  011E             
0151+  011E 76 1B       	cmp ah, 27
0152+  0120 C6 3C 01    	je gets_telnet_escape
0153+  0123 76 0A       	cmp ah, $0A				; LF
0154+  0125 C6 95 01    	je gets_end
0155+  0128 76 5C       	cmp ah, $5C				; '\\'
0156+  012A C6 6C 01    	je gets_escape
0157+  012D             	
0158+  012D 76 08       	cmp ah, $08			; check for backspace
0159+  012F C6 38 01    	je gets_backspace
0160+  0132             
0161+  0132 1A          	mov al, ah
0162+  0133 3E          	mov [d], al
0163+  0134 79          	inc d
0164+  0135 0A 13 01    	jmp gets_loop
0165+  0138             gets_backspace:
0166+  0138 7F          	dec d
0167+  0139 0A 13 01    	jmp gets_loop
0168+  013C             gets_telnet_escape:
0169+  013C FD 0C       	sti
0170+  013E 19 01       	mov al, 1
0171+  0140 05 03       	syscall sys_io				; receive in AH without echo
0172+  0142 B9 00       	cmp al, 0					; check error code (AL)
0173+  0144 C6 3C 01    	je gets_telnet_escape		; if no char received, retry
0174+  0147 76 5B       	cmp ah, '['
0175+  0149 C7 13 01    	jne gets_loop
0176+  014C             gets_telnet_escape_phase2:
0177+  014C FD 0C       	sti
0178+  014E 19 01       	mov al, 1
0179+  0150 05 03       	syscall sys_io					; receive in AH without echo
0180+  0152 B9 00       	cmp al, 0						; check error code (AL)
0181+  0154 C6 4C 01    	je gets_telnet_escape_phase2	; if no char received, retry
0182+  0157 76 44       	cmp ah, 'D'
0183+  0159 C6 64 01    	je gets_left_arrow
0184+  015C 76 43       	cmp ah, 'C'
0185+  015E C6 68 01    	je gets_right_arrow
0186+  0161 0A 13 01    	jmp gets_loop
0187+  0164             gets_left_arrow:
0188+  0164 7F          	dec d
0189+  0165 0A 13 01    	jmp gets_loop
0190+  0168             gets_right_arrow:
0191+  0168 79          	inc d
0192+  0169 0A 13 01    	jmp gets_loop
0193+  016C             gets_escape:
0194+  016C FD 0C       	sti
0195+  016E 19 01       	mov al, 1
0196+  0170 05 03       	syscall sys_io			; receive in AH
0197+  0172 B9 00       	cmp al, 0				; check error code (AL)
0198+  0174 C6 6C 01    	je gets_escape			; if no char received, retry
0199+  0177 76 6E       	cmp ah, 'n'
0200+  0179 C6 87 01    	je gets_LF
0201+  017C 76 72       	cmp ah, 'r'
0202+  017E C6 8E 01    	je gets_CR
0203+  0181 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0204+  0182 3E          	mov [d], al
0205+  0183 79          	inc d
0206+  0184 0A 13 01    	jmp gets_loop
0207+  0187             gets_LF:
0208+  0187 19 0A       	mov al, $0A
0209+  0189 3E          	mov [d], al
0210+  018A 79          	inc d
0211+  018B 0A 13 01    	jmp gets_loop
0212+  018E             gets_CR:
0213+  018E 19 0D       	mov al, $0D
0214+  0190 3E          	mov [d], al
0215+  0191 79          	inc d
0216+  0192 0A 13 01    	jmp gets_loop
0217+  0195             gets_end:
0218+  0195 19 00       	mov al, 0
0219+  0197 3E          	mov [d], al				; terminate string
0220+  0198 E7          	pop d
0221+  0199 E4          	pop a
0222+  019A 09          	ret
0223+  019B             
0224+  019B             
0225+  019B             
0226+  019B             
0227+  019B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0228+  019B             ;; INPUT TEXT
0229+  019B             ;; terminated with CTRL+D
0230+  019B             ;; pointer in D
0231+  019B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0232+  019B             gettxt:
0233+  019B D7          	push a
0234+  019C DA          	push d
0235+  019D             gettxt_loop:
0236+  019D 19 01       	mov al, 1
0237+  019F 05 03       	syscall sys_io			; receive in AH
0238+  01A1 B9 00       	cmp al, 0				; check error code (AL)
0239+  01A3 C6 9D 01    	je gettxt_loop		; if no char received, retry
0240+  01A6 76 04       	cmp ah, 4			; EOT
0241+  01A8 C6 E6 01    	je gettxt_end
0242+  01AB 76 08       	cmp ah, $08			; check for backspace
0243+  01AD C6 E2 01    	je gettxt_backspace
0244+  01B0 76 5C       	cmp ah, $5C				; '\\'
0245+  01B2 C6 BB 01    	je gettxt_escape
0246+  01B5 1A          	mov al, ah
0247+  01B6 3E          	mov [d], al
0248+  01B7 79          	inc d
0249+  01B8 0A 9D 01    	jmp gettxt_loop
0250+  01BB             gettxt_escape:
0251+  01BB 19 01       	mov al, 1
0252+  01BD 05 03       	syscall sys_io			; receive in AH
0253+  01BF B9 00       	cmp al, 0				; check error code (AL)
0254+  01C1 C6 BB 01    	je gettxt_escape		; if no char received, retry
0255+  01C4 76 6E       	cmp ah, 'n'
0256+  01C6 C6 D4 01    	je gettxt_LF
0257+  01C9 76 72       	cmp ah, 'r'
0258+  01CB C6 DB 01    	je gettxt_CR
0259+  01CE 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0260+  01CF 3E          	mov [d], al
0261+  01D0 79          	inc d
0262+  01D1 0A 9D 01    	jmp gettxt_loop
0263+  01D4             gettxt_LF:
0264+  01D4 19 0A       	mov al, $0A
0265+  01D6 3E          	mov [d], al
0266+  01D7 79          	inc d
0267+  01D8 0A 9D 01    	jmp gettxt_loop
0268+  01DB             gettxt_CR:
0269+  01DB 19 0D       	mov al, $0D
0270+  01DD 3E          	mov [d], al
0271+  01DE 79          	inc d
0272+  01DF 0A 9D 01    	jmp gettxt_loop
0273+  01E2             gettxt_backspace:
0274+  01E2 7F          	dec d
0275+  01E3 0A 9D 01    	jmp gettxt_loop
0276+  01E6             gettxt_end:
0277+  01E6 19 00       	mov al, 0
0278+  01E8 3E          	mov [d], al				; terminate string
0279+  01E9 E7          	pop d
0280+  01EA E4          	pop a
0281+  01EB 09          	ret
0282+  01EC             
0283+  01EC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0284+  01EC             ; PRINT NEW LINE
0285+  01EC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0286+  01EC             printnl:
0287+  01EC D7          	push a
0288+  01ED 10 00 0A    	mov a, $0A00
0289+  01F0 05 03       	syscall sys_io
0290+  01F2 10 00 0D    	mov a, $0D00
0291+  01F5 05 03       	syscall sys_io
0292+  01F7 E4          	pop a
0293+  01F8 09          	ret
0294+  01F9             
0295+  01F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0296+  01F9             ; strtoint
0297+  01F9             ; 4 digit hex string number in d
0298+  01F9             ; integer returned in A
0299+  01F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0300+  01F9             strtointx:
0301+  01F9 D8          	push b
0302+  01FA 32          	mov bl, [d]
0303+  01FB 37          	mov bh, bl
0304+  01FC 33 01 00    	mov bl, [d + 1]
0305+  01FF 07 BF 00    	call atoi				; convert to int in AL
0306+  0202 23          	mov ah, al				; move to AH
0307+  0203 33 02 00    	mov bl, [d + 2]
0308+  0206 37          	mov bh, bl
0309+  0207 33 03 00    	mov bl, [d + 3]
0310+  020A 07 BF 00    	call atoi				; convert to int in AL
0311+  020D E5          	pop b
0312+  020E 09          	ret
0313+  020F             
0314+  020F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0315+  020F             ; strtoint
0316+  020F             ; 5 digit base10 string number in d
0317+  020F             ; integer returned in A
0318+  020F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0319+  020F             strtoint:
0320+  020F E2          	push si
0321+  0210 D8          	push b
0322+  0211 D9          	push c
0323+  0212 DA          	push d
0324+  0213 07 47 00    	call strlen			; get string length in C
0325+  0216 7E          	dec c
0326+  0217 FD 4E       	mov si, d
0327+  0219 12          	mov a, c
0328+  021A FD 99       	shl a
0329+  021C 3B A7 00    	mov d, table_power
0330+  021F 59          	add d, a
0331+  0220 38 00 00    	mov c, 0
0332+  0223             strtoint_L0:
0333+  0223 F6          	lodsb			; load ASCII to al
0334+  0224 B9 00       	cmp al, 0
0335+  0226 C6 39 02    	je strtoint_end
0336+  0229 6F 30       	sub al, $30		; make into integer
0337+  022B 22 00       	mov ah, 0
0338+  022D 2A          	mov b, [d]
0339+  022E AC          	mul a, b			; result in B since it fits in 16bits
0340+  022F 11          	mov a, b
0341+  0230 28          	mov b, c
0342+  0231 54          	add a, b
0343+  0232 39          	mov c, a
0344+  0233 63 02 00    	sub d, 2
0345+  0236 0A 23 02    	jmp strtoint_L0
0346+  0239             strtoint_end:
0347+  0239 12          	mov a, c
0348+  023A E7          	pop d
0349+  023B E6          	pop c
0350+  023C E5          	pop b
0351+  023D EF          	pop si
0352+  023E 09          	ret
0353+  023F             
0354+  023F             
0355+  023F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  023F             ; PRINT NULL TERMINATED STRING
0357+  023F             ; pointer in D
0358+  023F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  023F             puts:
0360+  023F D7          	push a
0361+  0240 DA          	push d
0362+  0241             puts_L1:
0363+  0241 1E          	mov al, [d]
0364+  0242 B9 00       	cmp al, 0
0365+  0244 C6 50 02    	jz puts_END
0366+  0247 23          	mov ah, al
0367+  0248 19 00       	mov al, 0
0368+  024A 05 03       	syscall sys_io
0369+  024C 79          	inc d
0370+  024D 0A 41 02    	jmp puts_L1
0371+  0250             puts_END:
0372+  0250 E7          	pop d
0373+  0251 E4          	pop a
0374+  0252 09          	ret
0375+  0253             
0376+  0253             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0377+  0253             ; PRINT N SIZE STRING
0378+  0253             ; pointer in D
0379+  0253             ; size in C
0380+  0253             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0381+  0253             putsn:
0382+  0253 DB          	push al
0383+  0254 DA          	push d
0384+  0255 D9          	push c
0385+  0256             putsn_L0:
0386+  0256 1E          	mov al, [d]
0387+  0257 23          	mov ah, al
0388+  0258 19 00       	mov al, 0
0389+  025A 05 03       	syscall sys_io
0390+  025C 79          	inc d
0391+  025D 7E          	dec c	
0392+  025E C2 00 00    	cmp c, 0
0393+  0261 C7 56 02    	jne putsn_L0
0394+  0264             putsn_end:
0395+  0264 E6          	pop c
0396+  0265 E7          	pop d
0397+  0266 E8          	pop al
0398+  0267 09          	ret
0399+  0268             
0400+  0268             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0401+  0268             ; print 16bit decimal number
0402+  0268             ; input number in A
0403+  0268             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  0268             print_u16d:
0405+  0268 D7          	push a
0406+  0269 D8          	push b
0407+  026A 26 10 27    	mov b, 10000
0408+  026D AE          	div a, b			; get 10000 coeff.
0409+  026E 07 94 02    	call print_zero_or_space
0410+  0271 11          	mov a, b
0411+  0272 26 E8 03    	mov b, 1000
0412+  0275 AE          	div a, b			; get 10000 coeff.
0413+  0276 07 94 02    	call print_zero_or_space
0414+  0279 11          	mov a, b
0415+  027A 26 64 00    	mov b, 100
0416+  027D AE          	div a, b
0417+  027E 07 94 02    	call print_zero_or_space
0418+  0281 11          	mov a, b
0419+  0282 26 0A 00    	mov b, 10
0420+  0285 AE          	div a, b
0421+  0286 07 94 02    	call print_zero_or_space
0422+  0289 11          	mov a, b
0423+  028A 6A 30       	add al, $30
0424+  028C 23          	mov ah, al
0425+  028D 19 00       	mov al, 0
0426+  028F 05 03       	syscall sys_io	; print coeff
0427+  0291 E5          	pop b
0428+  0292 E4          	pop a
0429+  0293 09          	ret
0430+  0294             
0431+  0294             
0432+  0294             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0433+  0294             ; if A == 0, print space
0434+  0294             ; else print A
0435+  0294             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  0294             print_zero_or_space:
0437+  0294             	; cmp a, 0
0438+  0294             	; jne print_number
0439+  0294             	; mov ah, $20
0440+  0294             	; call putchar
0441+  0294             	; ret
0442+  0294             print_number:
0443+  0294 6A 30       	add al, $30
0444+  0296 23          	mov ah, al
0445+  0297 07 0A 01    	call putchar
0446+  029A 09          	ret
0447+  029B             
0448+  029B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  029B             ; PRINT 16BIT HEX INTEGER
0450+  029B             ; integer value in reg B
0451+  029B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0452+  029B             print_u16x:
0453+  029B D7          	push a
0454+  029C D8          	push b
0455+  029D DD          	push bl
0456+  029E 30          	mov bl, bh
0457+  029F 07 D1 00    	call itoa				; convert bh to char in A
0458+  02A2 2F          	mov bl, al				; save al
0459+  02A3 19 00       	mov al, 0
0460+  02A5 05 03       	syscall sys_io				; display AH
0461+  02A7 24          	mov ah, bl				; retrieve al
0462+  02A8 19 00       	mov al, 0
0463+  02AA 05 03       	syscall sys_io				; display AL
0464+  02AC             
0465+  02AC EA          	pop bl
0466+  02AD 07 D1 00    	call itoa				; convert bh to char in A
0467+  02B0 2F          	mov bl, al				; save al
0468+  02B1 19 00       	mov al, 0
0469+  02B3 05 03       	syscall sys_io				; display AH
0470+  02B5 24          	mov ah, bl				; retrieve al
0471+  02B6 19 00       	mov al, 0
0472+  02B8 05 03       	syscall sys_io				; display AL
0473+  02BA             
0474+  02BA E5          	pop b
0475+  02BB E4          	pop a
0476+  02BC 09          	ret
0477+  02BD             
0478+  02BD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  02BD             ; INPUT 16BIT HEX INTEGER
0480+  02BD             ; read 16bit integer into A
0481+  02BD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0482+  02BD             scan_u16x:
0483+  02BD F8 10 00    	enter 16
0484+  02C0 D8          	push b
0485+  02C1 DA          	push d
0486+  02C2             
0487+  02C2 FA F1 FF    	lea d, [bp + -15]
0488+  02C5 07 11 01    	call gets				; get number
0489+  02C8             
0490+  02C8 32          	mov bl, [d]
0491+  02C9 37          	mov bh, bl
0492+  02CA 33 01 00    	mov bl, [d + 1]
0493+  02CD 07 BF 00    	call atoi				; convert to int in AL
0494+  02D0 23          	mov ah, al				; move to AH
0495+  02D1             
0496+  02D1 33 02 00    	mov bl, [d + 2]
0497+  02D4 37          	mov bh, bl
0498+  02D5 33 03 00    	mov bl, [d + 3]
0499+  02D8 07 BF 00    	call atoi				; convert to int in AL
0500+  02DB             
0501+  02DB E7          	pop d
0502+  02DC E5          	pop b
0503+  02DD F9          	leave
0504+  02DE 09          	ret
0505+  02DF             
0506+  02DF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  02DF             ; PRINT 8bit HEX INTEGER
0508+  02DF             ; integer value in reg bl
0509+  02DF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0510+  02DF             print_u8x:
0511+  02DF D7          	push a
0512+  02E0 DD          	push bl
0513+  02E1             
0514+  02E1 07 D1 00    	call itoa				; convert bl to char in A
0515+  02E4 2F          	mov bl, al				; save al
0516+  02E5 19 00       	mov al, 0
0517+  02E7 05 03       	syscall sys_io				; display AH
0518+  02E9 24          	mov ah, bl				; retrieve al
0519+  02EA 19 00       	mov al, 0
0520+  02EC 05 03       	syscall sys_io				; display AL
0521+  02EE             
0522+  02EE EA          	pop bl
0523+  02EF E4          	pop a
0524+  02F0 09          	ret
0525+  02F1             
0526+  02F1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  02F1             ; print 8bit decimal unsigned number
0528+  02F1             ; input number in AL
0529+  02F1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0530+  02F1             print_u8d:
0531+  02F1 D7          	push a
0532+  02F2 D8          	push b
0533+  02F3             
0534+  02F3 22 00       	mov ah, 0
0535+  02F5 26 64 00    	mov b, 100
0536+  02F8 AE          	div a, b
0537+  02F9 D8          	push b			; save remainder
0538+  02FA B9 00       	cmp al, 0
0539+  02FC C6 06 03    	je skip100
0540+  02FF 6A 30       	add al, $30
0541+  0301 23          	mov ah, al
0542+  0302 19 00       	mov al, 0
0543+  0304 05 03       	syscall sys_io	; print coeff
0544+  0306             skip100:
0545+  0306 E4          	pop a
0546+  0307 22 00       	mov ah, 0
0547+  0309 26 0A 00    	mov b, 10
0548+  030C AE          	div a, b
0549+  030D D8          	push b			; save remainder
0550+  030E B9 00       	cmp al, 0
0551+  0310 C6 1A 03    	je skip10
0552+  0313 6A 30       	add al, $30
0553+  0315 23          	mov ah, al
0554+  0316 19 00       	mov al, 0
0555+  0318 05 03       	syscall sys_io	; print coeff
0556+  031A             skip10:
0557+  031A E4          	pop a
0558+  031B 1B          	mov al, bl
0559+  031C 6A 30       	add al, $30
0560+  031E 23          	mov ah, al
0561+  031F 19 00       	mov al, 0
0562+  0321 05 03       	syscall sys_io	; print coeff
0563+  0323 E5          	pop b
0564+  0324 E4          	pop a
0565+  0325 09          	ret
0566+  0326             
0567+  0326             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  0326             ; INPUT 8BIT HEX INTEGER
0569+  0326             ; read 8bit integer into AL
0570+  0326             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0571+  0326             scan_u8x:
0572+  0326 F8 04 00    	enter 4
0573+  0329 D8          	push b
0574+  032A DA          	push d
0575+  032B             
0576+  032B FA FD FF    	lea d, [bp + -3]
0577+  032E 07 11 01    	call gets				; get number
0578+  0331             
0579+  0331 32          	mov bl, [d]
0580+  0332 37          	mov bh, bl
0581+  0333 33 01 00    	mov bl, [d + 1]
0582+  0336 07 BF 00    	call atoi				; convert to int in AL
0583+  0339             
0584+  0339 E7          	pop d
0585+  033A E5          	pop b
0586+  033B F9          	leave
0587+  033C 09          	ret
0588+  033D             
0589+  033D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0590+  033D             ; input decimal number
0591+  033D             ; result in A
0592+  033D             ; 655'\0'
0593+  033D             ; low--------high
0594+  033D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0595+  033D             scan_u16d:
0596+  033D F8 08 00    	enter 8
0597+  0340 E2          	push si
0598+  0341 D8          	push b
0599+  0342 D9          	push c
0600+  0343 DA          	push d
0601+  0344 FA F9 FF    	lea d, [bp +- 7]
0602+  0347 07 11 01    	call gets
0603+  034A 07 47 00    	call strlen			; get string length in C
0604+  034D 7E          	dec c
0605+  034E FD 4E       	mov si, d
0606+  0350 12          	mov a, c
0607+  0351 FD 99       	shl a
0608+  0353 3B A7 00    	mov d, table_power
0609+  0356 59          	add d, a
0610+  0357 38 00 00    	mov c, 0
0611+  035A             mul_loop:
0612+  035A F6          	lodsb			; load ASCII to al
0613+  035B B9 00       	cmp al, 0
0614+  035D C6 70 03    	je mul_exit
0615+  0360 6F 30       	sub al, $30		; make into integer
0616+  0362 22 00       	mov ah, 0
0617+  0364 2A          	mov b, [d]
0618+  0365 AC          	mul a, b			; result in B since it fits in 16bits
0619+  0366 11          	mov a, b
0620+  0367 28          	mov b, c
0621+  0368 54          	add a, b
0622+  0369 39          	mov c, a
0623+  036A 63 02 00    	sub d, 2
0624+  036D 0A 5A 03    	jmp mul_loop
0625+  0370             mul_exit:
0626+  0370 12          	mov a, c
0627+  0371 E7          	pop d
0628+  0372 E6          	pop c
0629+  0373 E5          	pop b
0630+  0374 EF          	pop si
0631+  0375 F9          	leave
0632+  0376 09          	ret
0004   0377             ; -----end include block-----
0005   0377             
0006   0400             .org PROC_TEXT_ORG
0007   0400             
0008   0400             ; -----begin text block-----
0009   0400             main:
0010   0400 D2            push bp
0011   0401 9B            mov bp, sp
0012   0402 FD D7 00 00   push word 0
0013   0406 10 00 00      mov a, 0
0014   0409 26 58 04      mov b, integer
0015   040C D7            push a
0016   040D 11            mov a, b
0017   040E 26 01 00      mov b, 1
0018   0411 54            add a, b
0019   0412 27            mov b, a
0020   0413 E4            pop a
0021   0414 11            mov a, b
0022   0415 FD AA         swp a
0023   0417 45 FF FF      mov [bp + -1], a
0024   041A             ; -----begin inline asm block-----
0025   041A 05 0B         syscall sys_terminate_proc
0026   041C             ; -----end inline asm block-----
0027   041C F9            leave
0028   041D 09            ret
0029   041E             test:
0030   041E D2            push bp
0031   041F 9B            mov bp, sp
0032   0420 FD D7 00 00   push word 0
0033   0424 FD DB 00      push byte 0
0034   0427 FD D7 00 00   push word 0
0035   042B             _for1_init:
0036   042B 10 00 00      mov a, 0
0037   042E 26 00 00      mov b, 0
0038   0431 11            mov a, b
0039   0432 FD AA         swp a
0040   0434 45 07 00      mov [bp + 7], a
0041   0437             _for1_cond:
0042   0437 2C 07 00      mov b, [bp + 7]
0043   043A FD AB         swp b
0044   043C D7            push a
0045   043D 11            mov a, b
0046   043E 26 0A 00      mov b, 10
0047   0441 B0            cmp a, b
0048   0442 0E            lodflgs
0049   0443 87 02         and al, %00000010
0050   0445 22 00         mov ah, 0
0051   0447 27            mov b, a
0052   0448 E4            pop a
0053   0449 11            mov a, b
0054   044A AF 00 00      cmp a, 0
0055   044D C6 58 04      je _for1_exit
0056   0450             _for1_block:
0057   0450             _for1_update:
0058   0450 2C 07 00      mov b, [bp + 7]
0059   0453 FD AB         swp b
0060   0455 0A 37 04      jmp _for1_cond
0061   0458             _for1_exit:
0062   0458             ; -----end text block-----
0063   0458             
0064   0458             ; -----begin data block-----
0065   0458 19 00       integer: .dw 25
0066   045A 68 65 6C 6C s_data: .db "hello world", 0
0066   045E 6F 20 77 6F 
0066   0462 72 6C 64 00 
0067   0466 5A 04       s: .dw s_data
0068   0468             ; -----end data block-----
0069   0468             
0070   0468             .end
tasm: Number of errors = 0
