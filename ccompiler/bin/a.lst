0001   0000             
0002   0000             .include "lib/kernel.exp"
0001+  0000             PROC_TEXT_ORG    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_IDE          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_fileio       .EQU  $0004
0007+  0000             sys_fork         .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pauseproc    .EQU  $0009
0012+  0000             sys_resumeproc   .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             
0004   0400             .org PROC_TEXT_ORG
0005   0400             
0006   0400             ; -----begin text block-----
0007   0400             main:
0008   0400             ; -----begin inline asm block-----
0009   0400 3B 37 05      mov d, s_data
0010   0403 07 A8 07      call puts
0011   0406 07 A6 08      call scan_u16d
0012   0409 42 5D 05      mov [rows], a
0013   040C             ; -----end inline asm block-----
0014   040C             _for1_init:
0015   040C 26 00 00      mov b, 0
0016   040F FD 42 61 05   mov [i], b
0017   0413             _for1_cond:
0018   0413 29 61 05      mov b, [i]
0019   0416 D7            push a
0020   0417 11            mov a, b
0021   0418 29 5D 05      mov b, [rows]
0022   041B B0            cmp a, b
0023   041C 0E            lodflgs
0024   041D 87 02         and al, %00000010
0025   041F 22 00         mov ah, 0
0026   0421 27            mov b, a
0027   0422 E4            pop a
0028   0423 11            mov a, b
0029   0424 AF 00 00      cmp a, 0
0030   0427 C6 2B 05      je _for1_exit
0031   042A             _for1_block:
0032   042A             _for2_init:
0033   042A 26 01 00      mov b, 1
0034   042D FD 42 5F 05   mov [space], b
0035   0431             _for2_cond:
0036   0431 29 5F 05      mov b, [space]
0037   0434 D7            push a
0038   0435 11            mov a, b
0039   0436 29 5D 05      mov b, [rows]
0040   0439 D7            push a
0041   043A 11            mov a, b
0042   043B 29 61 05      mov b, [i]
0043   043E 60            sub a, b
0044   043F 27            mov b, a
0045   0440 E4            pop a
0046   0441 B0            cmp a, b
0047   0442 0E            lodflgs
0048   0443 87 03         and al, %00000011
0049   0445 22 00         mov ah, 0
0050   0447 27            mov b, a
0051   0448 E4            pop a
0052   0449 11            mov a, b
0053   044A AF 00 00      cmp a, 0
0054   044D C6 65 04      je _for2_exit
0055   0450             _for2_block:
0056   0450 07 2D 05      call print
0057   0453             _for2_update:
0058   0453 29 5F 05      mov b, [space]
0059   0456 D7            push a
0060   0457 11            mov a, b
0061   0458 26 01 00      mov b, 1
0062   045B 54            add a, b
0063   045C 27            mov b, a
0064   045D E4            pop a
0065   045E FD 42 5F 05   mov [space], b
0066   0462 0A 31 04      jmp _for2_cond
0067   0465             _for2_exit:
0068   0465             _for3_init:
0069   0465 26 00 00      mov b, 0
0070   0468 FD 42 63 05   mov [j], b
0071   046C             _for3_cond:
0072   046C 29 63 05      mov b, [j]
0073   046F D7            push a
0074   0470 11            mov a, b
0075   0471 29 61 05      mov b, [i]
0076   0474 B0            cmp a, b
0077   0475 0E            lodflgs
0078   0476 87 03         and al, %00000011
0079   0478 22 00         mov ah, 0
0080   047A 27            mov b, a
0081   047B E4            pop a
0082   047C 11            mov a, b
0083   047D AF 00 00      cmp a, 0
0084   0480 C6 13 05      je _for3_exit
0085   0483             _for3_block:
0086   0483             _if4_cond:
0087   0483 29 63 05      mov b, [j]
0088   0486 D7            push a
0089   0487 11            mov a, b
0090   0488 26 00 00      mov b, 0
0091   048B B0            cmp a, b
0092   048C 0E            lodflgs
0093   048D 87 01         and al, %00000001
0094   048F 22 00         mov ah, 0
0095   0491 27            mov b, a
0096   0492 E4            pop a
0097   0493 D7            push a
0098   0494 11            mov a, b
0099   0495 29 61 05      mov b, [i]
0100   0498 D7            push a
0101   0499 11            mov a, b
0102   049A 26 00 00      mov b, 0
0103   049D B0            cmp a, b
0104   049E 0E            lodflgs
0105   049F 87 01         and al, %00000001
0106   04A1 22 00         mov ah, 0
0107   04A3 27            mov b, a
0108   04A4 E4            pop a
0109   04A5 C0 00 00      cmp b, 0
0110   04A8 D7            push a
0111   04A9 0E            lodflgs
0112   04AA 27            mov b, a
0113   04AB E4            pop a
0114   04AC 98            not bl
0115   04AD FD 87 01      and bl, %00000001
0116   04B0 A7 00         mov bh, 0
0117   04B2 AF 00 00      cmp a, 0
0118   04B5 0E            lodflgs
0119   04B6 96            not al
0120   04B7 87 01         and al, %00000001
0121   04B9 22 00         mov ah, 0
0122   04BB 8A            or a, b
0123   04BC 27            mov b, a
0124   04BD E4            pop a
0125   04BE C0 00 00      cmp b, 0
0126   04C1 C6 CE 04      je _if4_else_block
0127   04C4             _if4_block:
0128   04C4 26 01 00      mov b, 1
0129   04C7 FD 42 5B 05   mov [coef], b
0130   04CB 0A F8 04      jmp _if4_exit
0131   04CE             _if4_else_block:
0132   04CE 29 5B 05      mov b, [coef]
0133   04D1 D7            push a
0134   04D2 11            mov a, b
0135   04D3 29 61 05      mov b, [i]
0136   04D6 D7            push a
0137   04D7 11            mov a, b
0138   04D8 29 63 05      mov b, [j]
0139   04DB 60            sub a, b
0140   04DC 27            mov b, a
0141   04DD E4            pop a
0142   04DE D7            push a
0143   04DF 11            mov a, b
0144   04E0 26 01 00      mov b, 1
0145   04E3 54            add a, b
0146   04E4 27            mov b, a
0147   04E5 E4            pop a
0148   04E6 AC            mul a, b
0149   04E7 E4            pop a
0150   04E8 D7            push a
0151   04E9 11            mov a, b
0152   04EA 29 63 05      mov b, [j]
0153   04ED AE            div a, b
0154   04EE FD 78         mov g, a
0155   04F0 11            mov a, b
0156   04F1 FD 27         mov b, g
0157   04F3 E4            pop a
0158   04F4 FD 42 5B 05   mov [coef], b
0159   04F8             _if4_exit:
0160   04F8 07 2D 05      call print
0161   04FB             ; -----begin inline asm block-----
0162   04FB 14 5B 05      mov a, [coef]
0163   04FE 07 D1 07      call print_u16d
0164   0501             ; -----end inline asm block-----
0165   0501             _for3_update:
0166   0501 29 63 05      mov b, [j]
0167   0504 D7            push a
0168   0505 11            mov a, b
0169   0506 26 01 00      mov b, 1
0170   0509 54            add a, b
0171   050A 27            mov b, a
0172   050B E4            pop a
0173   050C FD 42 63 05   mov [j], b
0174   0510 0A 6C 04      jmp _for3_cond
0175   0513             _for3_exit:
0176   0513             ; -----begin inline asm block-----
0177   0513 3B 65 05      mov d, nl_data
0178   0516 07 A8 07      call puts
0179   0519             ; -----end inline asm block-----
0180   0519             _for1_update:
0181   0519 29 61 05      mov b, [i]
0182   051C D7            push a
0183   051D 11            mov a, b
0184   051E 26 01 00      mov b, 1
0185   0521 54            add a, b
0186   0522 27            mov b, a
0187   0523 E4            pop a
0188   0524 FD 42 61 05   mov [i], b
0189   0528 0A 13 04      jmp _for1_cond
0190   052B             _for1_exit:
0191   052B             ; -----begin inline asm block-----
0192   052B 05 0B         syscall sys_terminate_proc
0193   052D             ; -----end inline asm block-----
0194   052D             print:
0195   052D D2          	push bp
0196   052E 9B          	mov bp, sp
0197   052F             ; -----begin inline asm block-----
0198   052F 3B 54 05      mov d, ss_data
0199   0532 07 A8 07      call puts
0200   0535             ; -----end inline asm block-----
0201   0535 F9            leave
0202   0536 09            ret
0203   0537             ; -----end text block-----
0204   0537             
0205   0537             ; -----begin data block-----
0206   0537 45 6E 74 65 s_data: .db "Enter the number of rows: ", 0
0206   053B 72 20 74 68 
0206   053F 65 20 6E 75 
0206   0543 6D 62 65 72 
0206   0547 20 6F 66 20 
0206   054B 72 6F 77 73 
0206   054F 3A 20 00 
0207   0552 37 05       s: .dw s_data
0208   0554 20 20 20 20 ss_data: .db "    ", 0
0208   0558 00 
0209   0559 54 05       ss: .dw ss_data
0210   055B 01 00       coef: .dw 1
0211   055D 00 00       rows: .dw 0
0212   055F 00 00       space: .dw 0
0213   0561 00 00       i: .dw 0
0214   0563 00 00       j: .dw 0
0215   0565 0A 00       nl_data: .db "\n", 0
0216   0567 65 05       nl: .dw nl_data
0217   0569             ; -----end data block-----
0218   0569             ; -----begin include block-----
0219   0569             .include "lib/stdio.asm"
0001+  0569             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0569             ; stdio.s
0003+  0569             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0569             .include "lib/string.asm"
0001++ 0569             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0569             ; string.s
0003++ 0569             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0569             
0005++ 0569             
0006++ 0569             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0569             ; strrev
0008++ 0569             ; reverse a string
0009++ 0569             ; D = string address
0010++ 0569             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0569             ; 01234
0012++ 0569             strrev:
0013++ 0569 4B          	pusha
0014++ 056A 07 B0 05    	call strlen	; length in C
0015++ 056D 12          	mov a, c
0016++ 056E AF 01 00    	cmp a, 1
0017++ 0571 D0 8B 05    	jleu strrev_end	; check string length. string len must be > 1
0018++ 0574 7D          	dec a
0019++ 0575 FD 4E       	mov si, d	; beginning of string
0020++ 0577 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0579 59          	add d, a	; end of string
0022++ 057A 12          	mov a, c
0023++ 057B FD 9B       	shr a		; divide by 2
0024++ 057D 39          	mov c, a	; C now counts the steps
0025++ 057E             strrev_L0:
0026++ 057E 32          	mov bl, [d]	; save load right-side char into BL
0027++ 057F F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0580 3E          	mov [d], al	; store left char into right side
0029++ 0581 1B          	mov al, bl
0030++ 0582 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0583 7E          	dec c
0032++ 0584 7F          	dec d
0033++ 0585 C2 00 00    	cmp c, 0
0034++ 0588 C7 7E 05    	jne strrev_L0
0035++ 058B             strrev_end:
0036++ 058B 4C          	popa
0037++ 058C 09          	ret
0038++ 058D             	
0039++ 058D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 058D             ; strchr
0041++ 058D             ; search string in D for char in AL
0042++ 058D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 058D             strchr:
0044++ 058D             strchr_L0:
0045++ 058D 32          	mov bl, [d]
0046++ 058E C1 00       	cmp bl, 0
0047++ 0590 C6 9B 05    	je strchr_end
0048++ 0593 BA          	cmp al, bl
0049++ 0594 C6 9B 05    	je strchr_end
0050++ 0597 79          	inc d
0051++ 0598 0A 8D 05    	jmp strchr_L0
0052++ 059B             strchr_end:
0053++ 059B 1B          	mov al, bl
0054++ 059C 09          	ret
0055++ 059D             
0056++ 059D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 059D             ; strstr
0058++ 059D             ; find sub-string
0059++ 059D             ; str1 in SI
0060++ 059D             ; str2 in DI
0061++ 059D             ; SI points to end of source string
0062++ 059D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 059D             strstr:
0064++ 059D DB          	push al
0065++ 059E DA          	push d
0066++ 059F E3          	push di
0067++ 05A0             strstr_loop:
0068++ 05A0 F3          	cmpsb					; compare a byte of the strings
0069++ 05A1 C7 AC 05    	jne strstr_ret
0070++ 05A4 FC 00 00    	lea d, [di + 0]
0071++ 05A7 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 05A9 C7 A0 05    	jne strstr_loop				; equal chars but not at end
0073++ 05AC             strstr_ret:
0074++ 05AC F0          	pop di
0075++ 05AD E7          	pop d
0076++ 05AE E8          	pop al
0077++ 05AF 09          	ret
0078++ 05B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 05B0             ; length of null terminated string
0080++ 05B0             ; result in C
0081++ 05B0             ; pointer in D
0082++ 05B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 05B0             strlen:
0084++ 05B0 DA          	push d
0085++ 05B1 38 00 00    	mov c, 0
0086++ 05B4             strlen_L1:
0087++ 05B4 BD 00       	cmp byte [d], 0
0088++ 05B6 C6 BE 05    	je strlen_ret
0089++ 05B9 79          	inc d
0090++ 05BA 78          	inc c
0091++ 05BB 0A B4 05    	jmp strlen_L1
0092++ 05BE             strlen_ret:
0093++ 05BE E7          	pop d
0094++ 05BF 09          	ret
0095++ 05C0             
0096++ 05C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 05C0             ; STRCMP
0098++ 05C0             ; compare two strings
0099++ 05C0             ; str1 in SI
0100++ 05C0             ; str2 in DI
0101++ 05C0             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 05C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 05C0             strcmp:
0104++ 05C0 DB          	push al
0105++ 05C1 DA          	push d
0106++ 05C2 E3          	push di
0107++ 05C3 E2          	push si
0108++ 05C4             strcmp_loop:
0109++ 05C4 F3          	cmpsb					; compare a byte of the strings
0110++ 05C5 C7 D0 05    	jne strcmp_ret
0111++ 05C8 FB FF FF    	lea d, [si +- 1]
0112++ 05CB BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 05CD C7 C4 05    	jne strcmp_loop				; equal chars but not at end
0114++ 05D0             strcmp_ret:
0115++ 05D0 EF          	pop si
0116++ 05D1 F0          	pop di
0117++ 05D2 E7          	pop d
0118++ 05D3 E8          	pop al
0119++ 05D4 09          	ret
0120++ 05D5             
0121++ 05D5             
0122++ 05D5             ; STRCPY
0123++ 05D5             ; copy null terminated string from SI to DI
0124++ 05D5             ; source in SI
0125++ 05D5             ; destination in DI
0126++ 05D5             strcpy:
0127++ 05D5 E2          	push si
0128++ 05D6 E3          	push di
0129++ 05D7 DB          	push al
0130++ 05D8             strcpy_L1:
0131++ 05D8 F6          	lodsb
0132++ 05D9 F7          	stosb
0133++ 05DA B9 00       	cmp al, 0
0134++ 05DC C7 D8 05    	jne strcpy_L1
0135++ 05DF             strcpy_end:
0136++ 05DF E8          	pop al
0137++ 05E0 F0          	pop di
0138++ 05E1 EF          	pop si
0139++ 05E2 09          	ret
0140++ 05E3             
0141++ 05E3             ; STRCAT
0142++ 05E3             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 05E3             ; source in SI
0144++ 05E3             ; destination in DI
0145++ 05E3             strcat:
0146++ 05E3 E2          	push si
0147++ 05E4 E3          	push di
0148++ 05E5 D7          	push a
0149++ 05E6 DA          	push d
0150++ 05E7 50          	mov a, di
0151++ 05E8 3C          	mov d, a
0152++ 05E9             strcat_goto_end_L1:
0153++ 05E9 BD 00       	cmp byte[d], 0
0154++ 05EB C6 F2 05    	je strcat_start
0155++ 05EE 79          	inc d
0156++ 05EF 0A E9 05    	jmp strcat_goto_end_L1
0157++ 05F2             strcat_start:
0158++ 05F2 FD 50       	mov di, d
0159++ 05F4             strcat_L1:
0160++ 05F4 F6          	lodsb
0161++ 05F5 F7          	stosb
0162++ 05F6 B9 00       	cmp al, 0
0163++ 05F8 C7 F4 05    	jne strcat_L1
0164++ 05FB             strcat_end:
0165++ 05FB E7          	pop d
0166++ 05FC E4          	pop a
0167++ 05FD F0          	pop di
0168++ 05FE EF          	pop si
0169++ 05FF 09          	ret
0005+  0600             
0006+  0600 30 31 32 33 s_hex_digits:	.db "0123456789ABCDEF"	
0006+  0604 34 35 36 37 
0006+  0608 38 39 41 42 
0006+  060C 43 44 45 46 
0007+  0610             
0008+  0610 01 00       table_power:.dw 1
0009+  0612 0A 00       			.dw 10
0010+  0614 64 00       			.dw 100
0011+  0616 E8 03       			.dw 1000
0012+  0618 10 27       			.dw 10000
0013+  061A             
0014+  061A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0015+  061A             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0016+  061A             ; ASCII in BL
0017+  061A             ; result in AL
0018+  061A             ; ascii for F = 0100 0110
0019+  061A             ; ascii for 9 = 0011 1001
0020+  061A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0021+  061A             hex_ascii_encode:
0022+  061A 1B          	mov al, bl
0023+  061B 93 40       	test al, $40				; test if letter or number
0024+  061D C7 23 06    	jnz hex_letter
0025+  0620 87 0F       	and al, $0F				; get number
0026+  0622 09          	ret
0027+  0623             hex_letter:
0028+  0623 87 0F       	and al, $0F				; get letter
0029+  0625 6A 09       	add al, 9
0030+  0627 09          	ret
0031+  0628             
0032+  0628             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0033+  0628             ; ATOI
0034+  0628             ; 2 letter hex string in B
0035+  0628             ; 8bit integer returned in AL
0036+  0628             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0037+  0628             atoi:
0038+  0628 D8          	push b
0039+  0629 07 1A 06    	call hex_ascii_encode			; convert BL to 4bit code in AL
0040+  062C 30          	mov bl, bh
0041+  062D DB          	push al					; save a
0042+  062E 07 1A 06    	call hex_ascii_encode
0043+  0631 EA          	pop bl	
0044+  0632 FD 9E 04    	shl al, 4
0045+  0635 8C          	or al, bl
0046+  0636 E5          	pop b
0047+  0637 09          	ret	
0048+  0638             
0049+  0638             
0050+  0638             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  0638             ; printf
0052+  0638             ; no need for explanations!
0053+  0638             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0054+  0638             printf:
0055+  0638 09          	ret
0056+  0639             
0057+  0639             
0058+  0639             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  0639             ; scanf
0060+  0639             ; no need for explanations!
0061+  0639             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  0639             scanf:
0063+  0639 09          	ret
0064+  063A             
0065+  063A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  063A             ; ITOA
0067+  063A             ; 8bit value in BL
0068+  063A             ; 2 byte ASCII result in A
0069+  063A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0070+  063A             itoa:
0071+  063A DA          	push d
0072+  063B D8          	push b
0073+  063C A7 00       	mov bh, 0
0074+  063E FD A4 04    	shr bl, 4	
0075+  0641 74          	mov d, b
0076+  0642 1F 00 06    	mov al, [d + s_hex_digits]
0077+  0645 23          	mov ah, al
0078+  0646             	
0079+  0646 E5          	pop b
0080+  0647 D8          	push b
0081+  0648 A7 00       	mov bh, 0
0082+  064A FD 87 0F    	and bl, $0F
0083+  064D 74          	mov d, b
0084+  064E 1F 00 06    	mov al, [d + s_hex_digits]
0085+  0651 E5          	pop b
0086+  0652 E7          	pop d
0087+  0653 09          	ret
0088+  0654             
0089+  0654             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0090+  0654             ; HEX STRING TO BINARY
0091+  0654             ; di = destination address
0092+  0654             ; si = source
0093+  0654             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0094+  0654             hex_to_int:
0095+  0654             hex_to_int_L1:
0096+  0654 F6          	lodsb					; load from [SI] to AL
0097+  0655 B9 00       	cmp al, 0				; check if ASCII 0
0098+  0657 C6 64 06    	jz hex_to_int_ret
0099+  065A 36          	mov bh, al
0100+  065B F6          	lodsb
0101+  065C 2F          	mov bl, al
0102+  065D 07 28 06    	call atoi				; convert ASCII byte in B to int (to AL)
0103+  0660 F7          	stosb					; store AL to [DI]
0104+  0661 0A 54 06    	jmp hex_to_int_L1
0105+  0664             hex_to_int_ret:
0106+  0664 09          	ret		
0107+  0665             
0108+  0665             
0109+  0665             
0110+  0665             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  0665             ; GETCHAR
0112+  0665             ; char in ah
0113+  0665             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0114+  0665             getchar:
0115+  0665 DB          	push al
0116+  0666             getchar_retry:
0117+  0666 FD 0C       	sti
0118+  0668 19 01       	mov al, 1
0119+  066A 05 03       	syscall sys_io			; receive in AH
0120+  066C B9 00       	cmp al, 0			; check if any char was receive
0121+  066E C6 66 06    	je getchar_retry
0122+  0671 E8          	pop al
0123+  0672 09          	ret
0124+  0673             
0125+  0673             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0126+  0673             ; PUTCHAR
0127+  0673             ; char in ah
0128+  0673             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  0673             putchar:
0130+  0673 D7          	push a
0131+  0674 19 00       	mov al, 0
0132+  0676 05 03       	syscall sys_io			; char in AH
0133+  0678 E4          	pop a
0134+  0679 09          	ret
0135+  067A             
0136+  067A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0137+  067A             ;; INPUT A STRING
0138+  067A             ;; terminates with null
0139+  067A             ;; pointer in D
0140+  067A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  067A             gets:
0142+  067A D7          	push a
0143+  067B DA          	push d
0144+  067C             gets_loop:
0145+  067C FD 0C       	sti
0146+  067E 19 01       	mov al, 1
0147+  0680 05 03       	syscall sys_io			; receive in AH
0148+  0682 B9 00       	cmp al, 0				; check error code (AL)
0149+  0684 C6 7C 06    	je gets_loop			; if no char received, retry
0150+  0687             
0151+  0687 76 1B       	cmp ah, 27
0152+  0689 C6 A5 06    	je gets_telnet_escape
0153+  068C 76 0A       	cmp ah, $0A				; LF
0154+  068E C6 FE 06    	je gets_end
0155+  0691 76 5C       	cmp ah, $5C				; '\\'
0156+  0693 C6 D5 06    	je gets_escape
0157+  0696             	
0158+  0696 76 08       	cmp ah, $08			; check for backspace
0159+  0698 C6 A1 06    	je gets_backspace
0160+  069B             
0161+  069B 1A          	mov al, ah
0162+  069C 3E          	mov [d], al
0163+  069D 79          	inc d
0164+  069E 0A 7C 06    	jmp gets_loop
0165+  06A1             gets_backspace:
0166+  06A1 7F          	dec d
0167+  06A2 0A 7C 06    	jmp gets_loop
0168+  06A5             gets_telnet_escape:
0169+  06A5 FD 0C       	sti
0170+  06A7 19 01       	mov al, 1
0171+  06A9 05 03       	syscall sys_io				; receive in AH without echo
0172+  06AB B9 00       	cmp al, 0					; check error code (AL)
0173+  06AD C6 A5 06    	je gets_telnet_escape		; if no char received, retry
0174+  06B0 76 5B       	cmp ah, '['
0175+  06B2 C7 7C 06    	jne gets_loop
0176+  06B5             gets_telnet_escape_phase2:
0177+  06B5 FD 0C       	sti
0178+  06B7 19 01       	mov al, 1
0179+  06B9 05 03       	syscall sys_io					; receive in AH without echo
0180+  06BB B9 00       	cmp al, 0						; check error code (AL)
0181+  06BD C6 B5 06    	je gets_telnet_escape_phase2	; if no char received, retry
0182+  06C0 76 44       	cmp ah, 'D'
0183+  06C2 C6 CD 06    	je gets_left_arrow
0184+  06C5 76 43       	cmp ah, 'C'
0185+  06C7 C6 D1 06    	je gets_right_arrow
0186+  06CA 0A 7C 06    	jmp gets_loop
0187+  06CD             gets_left_arrow:
0188+  06CD 7F          	dec d
0189+  06CE 0A 7C 06    	jmp gets_loop
0190+  06D1             gets_right_arrow:
0191+  06D1 79          	inc d
0192+  06D2 0A 7C 06    	jmp gets_loop
0193+  06D5             gets_escape:
0194+  06D5 FD 0C       	sti
0195+  06D7 19 01       	mov al, 1
0196+  06D9 05 03       	syscall sys_io			; receive in AH
0197+  06DB B9 00       	cmp al, 0				; check error code (AL)
0198+  06DD C6 D5 06    	je gets_escape			; if no char received, retry
0199+  06E0 76 6E       	cmp ah, 'n'
0200+  06E2 C6 F0 06    	je gets_LF
0201+  06E5 76 72       	cmp ah, 'r'
0202+  06E7 C6 F7 06    	je gets_CR
0203+  06EA 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0204+  06EB 3E          	mov [d], al
0205+  06EC 79          	inc d
0206+  06ED 0A 7C 06    	jmp gets_loop
0207+  06F0             gets_LF:
0208+  06F0 19 0A       	mov al, $0A
0209+  06F2 3E          	mov [d], al
0210+  06F3 79          	inc d
0211+  06F4 0A 7C 06    	jmp gets_loop
0212+  06F7             gets_CR:
0213+  06F7 19 0D       	mov al, $0D
0214+  06F9 3E          	mov [d], al
0215+  06FA 79          	inc d
0216+  06FB 0A 7C 06    	jmp gets_loop
0217+  06FE             gets_end:
0218+  06FE 19 00       	mov al, 0
0219+  0700 3E          	mov [d], al				; terminate string
0220+  0701 E7          	pop d
0221+  0702 E4          	pop a
0222+  0703 09          	ret
0223+  0704             
0224+  0704             
0225+  0704             
0226+  0704             
0227+  0704             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0228+  0704             ;; INPUT TEXT
0229+  0704             ;; terminated with CTRL+D
0230+  0704             ;; pointer in D
0231+  0704             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0232+  0704             gettxt:
0233+  0704 D7          	push a
0234+  0705 DA          	push d
0235+  0706             gettxt_loop:
0236+  0706 19 01       	mov al, 1
0237+  0708 05 03       	syscall sys_io			; receive in AH
0238+  070A B9 00       	cmp al, 0				; check error code (AL)
0239+  070C C6 06 07    	je gettxt_loop		; if no char received, retry
0240+  070F 76 04       	cmp ah, 4			; EOT
0241+  0711 C6 4F 07    	je gettxt_end
0242+  0714 76 08       	cmp ah, $08			; check for backspace
0243+  0716 C6 4B 07    	je gettxt_backspace
0244+  0719 76 5C       	cmp ah, $5C				; '\\'
0245+  071B C6 24 07    	je gettxt_escape
0246+  071E 1A          	mov al, ah
0247+  071F 3E          	mov [d], al
0248+  0720 79          	inc d
0249+  0721 0A 06 07    	jmp gettxt_loop
0250+  0724             gettxt_escape:
0251+  0724 19 01       	mov al, 1
0252+  0726 05 03       	syscall sys_io			; receive in AH
0253+  0728 B9 00       	cmp al, 0				; check error code (AL)
0254+  072A C6 24 07    	je gettxt_escape		; if no char received, retry
0255+  072D 76 6E       	cmp ah, 'n'
0256+  072F C6 3D 07    	je gettxt_LF
0257+  0732 76 72       	cmp ah, 'r'
0258+  0734 C6 44 07    	je gettxt_CR
0259+  0737 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0260+  0738 3E          	mov [d], al
0261+  0739 79          	inc d
0262+  073A 0A 06 07    	jmp gettxt_loop
0263+  073D             gettxt_LF:
0264+  073D 19 0A       	mov al, $0A
0265+  073F 3E          	mov [d], al
0266+  0740 79          	inc d
0267+  0741 0A 06 07    	jmp gettxt_loop
0268+  0744             gettxt_CR:
0269+  0744 19 0D       	mov al, $0D
0270+  0746 3E          	mov [d], al
0271+  0747 79          	inc d
0272+  0748 0A 06 07    	jmp gettxt_loop
0273+  074B             gettxt_backspace:
0274+  074B 7F          	dec d
0275+  074C 0A 06 07    	jmp gettxt_loop
0276+  074F             gettxt_end:
0277+  074F 19 00       	mov al, 0
0278+  0751 3E          	mov [d], al				; terminate string
0279+  0752 E7          	pop d
0280+  0753 E4          	pop a
0281+  0754 09          	ret
0282+  0755             
0283+  0755             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0284+  0755             ; PRINT NEW LINE
0285+  0755             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0286+  0755             printnl:
0287+  0755 D7          	push a
0288+  0756 10 00 0A    	mov a, $0A00
0289+  0759 05 03       	syscall sys_io
0290+  075B 10 00 0D    	mov a, $0D00
0291+  075E 05 03       	syscall sys_io
0292+  0760 E4          	pop a
0293+  0761 09          	ret
0294+  0762             
0295+  0762             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0296+  0762             ; strtoint
0297+  0762             ; 4 digit hex string number in d
0298+  0762             ; integer returned in A
0299+  0762             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0300+  0762             strtointx:
0301+  0762 D8          	push b
0302+  0763 32          	mov bl, [d]
0303+  0764 37          	mov bh, bl
0304+  0765 33 01 00    	mov bl, [d + 1]
0305+  0768 07 28 06    	call atoi				; convert to int in AL
0306+  076B 23          	mov ah, al				; move to AH
0307+  076C 33 02 00    	mov bl, [d + 2]
0308+  076F 37          	mov bh, bl
0309+  0770 33 03 00    	mov bl, [d + 3]
0310+  0773 07 28 06    	call atoi				; convert to int in AL
0311+  0776 E5          	pop b
0312+  0777 09          	ret
0313+  0778             
0314+  0778             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0315+  0778             ; strtoint
0316+  0778             ; 5 digit base10 string number in d
0317+  0778             ; integer returned in A
0318+  0778             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0319+  0778             strtoint:
0320+  0778 E2          	push si
0321+  0779 D8          	push b
0322+  077A D9          	push c
0323+  077B DA          	push d
0324+  077C 07 B0 05    	call strlen			; get string length in C
0325+  077F 7E          	dec c
0326+  0780 FD 4E       	mov si, d
0327+  0782 12          	mov a, c
0328+  0783 FD 99       	shl a
0329+  0785 3B 10 06    	mov d, table_power
0330+  0788 59          	add d, a
0331+  0789 38 00 00    	mov c, 0
0332+  078C             strtoint_L0:
0333+  078C F6          	lodsb			; load ASCII to al
0334+  078D B9 00       	cmp al, 0
0335+  078F C6 A2 07    	je strtoint_end
0336+  0792 6F 30       	sub al, $30		; make into integer
0337+  0794 22 00       	mov ah, 0
0338+  0796 2A          	mov b, [d]
0339+  0797 AC          	mul a, b			; result in B since it fits in 16bits
0340+  0798 11          	mov a, b
0341+  0799 28          	mov b, c
0342+  079A 54          	add a, b
0343+  079B 39          	mov c, a
0344+  079C 63 02 00    	sub d, 2
0345+  079F 0A 8C 07    	jmp strtoint_L0
0346+  07A2             strtoint_end:
0347+  07A2 12          	mov a, c
0348+  07A3 E7          	pop d
0349+  07A4 E6          	pop c
0350+  07A5 E5          	pop b
0351+  07A6 EF          	pop si
0352+  07A7 09          	ret
0353+  07A8             
0354+  07A8             
0355+  07A8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  07A8             ; PRINT NULL TERMINATED STRING
0357+  07A8             ; pointer in D
0358+  07A8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359+  07A8             puts:
0360+  07A8 D7          	push a
0361+  07A9 DA          	push d
0362+  07AA             puts_L1:
0363+  07AA 1E          	mov al, [d]
0364+  07AB B9 00       	cmp al, 0
0365+  07AD C6 B9 07    	jz puts_END
0366+  07B0 23          	mov ah, al
0367+  07B1 19 00       	mov al, 0
0368+  07B3 05 03       	syscall sys_io
0369+  07B5 79          	inc d
0370+  07B6 0A AA 07    	jmp puts_L1
0371+  07B9             puts_END:
0372+  07B9 E7          	pop d
0373+  07BA E4          	pop a
0374+  07BB 09          	ret
0375+  07BC             
0376+  07BC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0377+  07BC             ; PRINT N SIZE STRING
0378+  07BC             ; pointer in D
0379+  07BC             ; size in C
0380+  07BC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0381+  07BC             putsn:
0382+  07BC DB          	push al
0383+  07BD DA          	push d
0384+  07BE D9          	push c
0385+  07BF             putsn_L0:
0386+  07BF 1E          	mov al, [d]
0387+  07C0 23          	mov ah, al
0388+  07C1 19 00       	mov al, 0
0389+  07C3 05 03       	syscall sys_io
0390+  07C5 79          	inc d
0391+  07C6 7E          	dec c	
0392+  07C7 C2 00 00    	cmp c, 0
0393+  07CA C7 BF 07    	jne putsn_L0
0394+  07CD             putsn_end:
0395+  07CD E6          	pop c
0396+  07CE E7          	pop d
0397+  07CF E8          	pop al
0398+  07D0 09          	ret
0399+  07D1             
0400+  07D1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0401+  07D1             ; print 16bit decimal number
0402+  07D1             ; input number in A
0403+  07D1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404+  07D1             print_u16d:
0405+  07D1 D7          	push a
0406+  07D2 D8          	push b
0407+  07D3 26 10 27    	mov b, 10000
0408+  07D6 AE          	div a, b			; get 10000 coeff.
0409+  07D7 07 FD 07    	call print_zero_or_space
0410+  07DA 11          	mov a, b
0411+  07DB 26 E8 03    	mov b, 1000
0412+  07DE AE          	div a, b			; get 10000 coeff.
0413+  07DF 07 FD 07    	call print_zero_or_space
0414+  07E2 11          	mov a, b
0415+  07E3 26 64 00    	mov b, 100
0416+  07E6 AE          	div a, b
0417+  07E7 07 FD 07    	call print_zero_or_space
0418+  07EA 11          	mov a, b
0419+  07EB 26 0A 00    	mov b, 10
0420+  07EE AE          	div a, b
0421+  07EF 07 FD 07    	call print_zero_or_space
0422+  07F2 11          	mov a, b
0423+  07F3 6A 30       	add al, $30
0424+  07F5 23          	mov ah, al
0425+  07F6 19 00       	mov al, 0
0426+  07F8 05 03       	syscall sys_io	; print coeff
0427+  07FA E5          	pop b
0428+  07FB E4          	pop a
0429+  07FC 09          	ret
0430+  07FD             
0431+  07FD             
0432+  07FD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0433+  07FD             ; if A == 0, print space
0434+  07FD             ; else print A
0435+  07FD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0436+  07FD             print_zero_or_space:
0437+  07FD             	; cmp a, 0
0438+  07FD             	; jne print_number
0439+  07FD             	; mov ah, $20
0440+  07FD             	; call putchar
0441+  07FD             	; ret
0442+  07FD             print_number:
0443+  07FD 6A 30       	add al, $30
0444+  07FF 23          	mov ah, al
0445+  0800 07 73 06    	call putchar
0446+  0803 09          	ret
0447+  0804             
0448+  0804             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0449+  0804             ; PRINT 16BIT HEX INTEGER
0450+  0804             ; integer value in reg B
0451+  0804             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0452+  0804             print_u16x:
0453+  0804 D7          	push a
0454+  0805 D8          	push b
0455+  0806 DD          	push bl
0456+  0807 30          	mov bl, bh
0457+  0808 07 3A 06    	call itoa				; convert bh to char in A
0458+  080B 2F          	mov bl, al				; save al
0459+  080C 19 00       	mov al, 0
0460+  080E 05 03       	syscall sys_io				; display AH
0461+  0810 24          	mov ah, bl				; retrieve al
0462+  0811 19 00       	mov al, 0
0463+  0813 05 03       	syscall sys_io				; display AL
0464+  0815             
0465+  0815 EA          	pop bl
0466+  0816 07 3A 06    	call itoa				; convert bh to char in A
0467+  0819 2F          	mov bl, al				; save al
0468+  081A 19 00       	mov al, 0
0469+  081C 05 03       	syscall sys_io				; display AH
0470+  081E 24          	mov ah, bl				; retrieve al
0471+  081F 19 00       	mov al, 0
0472+  0821 05 03       	syscall sys_io				; display AL
0473+  0823             
0474+  0823 E5          	pop b
0475+  0824 E4          	pop a
0476+  0825 09          	ret
0477+  0826             
0478+  0826             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479+  0826             ; INPUT 16BIT HEX INTEGER
0480+  0826             ; read 16bit integer into A
0481+  0826             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0482+  0826             scan_u16x:
0483+  0826 F8 10 00    	enter 16
0484+  0829 D8          	push b
0485+  082A DA          	push d
0486+  082B             
0487+  082B FA F1 FF    	lea d, [bp + -15]
0488+  082E 07 7A 06    	call gets				; get number
0489+  0831             
0490+  0831 32          	mov bl, [d]
0491+  0832 37          	mov bh, bl
0492+  0833 33 01 00    	mov bl, [d + 1]
0493+  0836 07 28 06    	call atoi				; convert to int in AL
0494+  0839 23          	mov ah, al				; move to AH
0495+  083A             
0496+  083A 33 02 00    	mov bl, [d + 2]
0497+  083D 37          	mov bh, bl
0498+  083E 33 03 00    	mov bl, [d + 3]
0499+  0841 07 28 06    	call atoi				; convert to int in AL
0500+  0844             
0501+  0844 E7          	pop d
0502+  0845 E5          	pop b
0503+  0846 F9          	leave
0504+  0847 09          	ret
0505+  0848             
0506+  0848             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0507+  0848             ; PRINT 8bit HEX INTEGER
0508+  0848             ; integer value in reg bl
0509+  0848             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0510+  0848             print_u8x:
0511+  0848 D7          	push a
0512+  0849 DD          	push bl
0513+  084A             
0514+  084A 07 3A 06    	call itoa				; convert bl to char in A
0515+  084D 2F          	mov bl, al				; save al
0516+  084E 19 00       	mov al, 0
0517+  0850 05 03       	syscall sys_io				; display AH
0518+  0852 24          	mov ah, bl				; retrieve al
0519+  0853 19 00       	mov al, 0
0520+  0855 05 03       	syscall sys_io				; display AL
0521+  0857             
0522+  0857 EA          	pop bl
0523+  0858 E4          	pop a
0524+  0859 09          	ret
0525+  085A             
0526+  085A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0527+  085A             ; print 8bit decimal unsigned number
0528+  085A             ; input number in AL
0529+  085A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0530+  085A             print_u8d:
0531+  085A D7          	push a
0532+  085B D8          	push b
0533+  085C             
0534+  085C 22 00       	mov ah, 0
0535+  085E 26 64 00    	mov b, 100
0536+  0861 AE          	div a, b
0537+  0862 D8          	push b			; save remainder
0538+  0863 B9 00       	cmp al, 0
0539+  0865 C6 6F 08    	je skip100
0540+  0868 6A 30       	add al, $30
0541+  086A 23          	mov ah, al
0542+  086B 19 00       	mov al, 0
0543+  086D 05 03       	syscall sys_io	; print coeff
0544+  086F             skip100:
0545+  086F E4          	pop a
0546+  0870 22 00       	mov ah, 0
0547+  0872 26 0A 00    	mov b, 10
0548+  0875 AE          	div a, b
0549+  0876 D8          	push b			; save remainder
0550+  0877 B9 00       	cmp al, 0
0551+  0879 C6 83 08    	je skip10
0552+  087C 6A 30       	add al, $30
0553+  087E 23          	mov ah, al
0554+  087F 19 00       	mov al, 0
0555+  0881 05 03       	syscall sys_io	; print coeff
0556+  0883             skip10:
0557+  0883 E4          	pop a
0558+  0884 1B          	mov al, bl
0559+  0885 6A 30       	add al, $30
0560+  0887 23          	mov ah, al
0561+  0888 19 00       	mov al, 0
0562+  088A 05 03       	syscall sys_io	; print coeff
0563+  088C E5          	pop b
0564+  088D E4          	pop a
0565+  088E 09          	ret
0566+  088F             
0567+  088F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568+  088F             ; INPUT 8BIT HEX INTEGER
0569+  088F             ; read 8bit integer into AL
0570+  088F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0571+  088F             scan_u8x:
0572+  088F F8 04 00    	enter 4
0573+  0892 D8          	push b
0574+  0893 DA          	push d
0575+  0894             
0576+  0894 FA FD FF    	lea d, [bp + -3]
0577+  0897 07 7A 06    	call gets				; get number
0578+  089A             
0579+  089A 32          	mov bl, [d]
0580+  089B 37          	mov bh, bl
0581+  089C 33 01 00    	mov bl, [d + 1]
0582+  089F 07 28 06    	call atoi				; convert to int in AL
0583+  08A2             
0584+  08A2 E7          	pop d
0585+  08A3 E5          	pop b
0586+  08A4 F9          	leave
0587+  08A5 09          	ret
0588+  08A6             
0589+  08A6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0590+  08A6             ; input decimal number
0591+  08A6             ; result in A
0592+  08A6             ; 655'\0'
0593+  08A6             ; low--------high
0594+  08A6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0595+  08A6             scan_u16d:
0596+  08A6 F8 08 00    	enter 8
0597+  08A9 E2          	push si
0598+  08AA D8          	push b
0599+  08AB D9          	push c
0600+  08AC DA          	push d
0601+  08AD FA F9 FF    	lea d, [bp +- 7]
0602+  08B0 07 7A 06    	call gets
0603+  08B3 07 B0 05    	call strlen			; get string length in C
0604+  08B6 7E          	dec c
0605+  08B7 FD 4E       	mov si, d
0606+  08B9 12          	mov a, c
0607+  08BA FD 99       	shl a
0608+  08BC 3B 10 06    	mov d, table_power
0609+  08BF 59          	add d, a
0610+  08C0 38 00 00    	mov c, 0
0611+  08C3             mul_loop:
0612+  08C3 F6          	lodsb			; load ASCII to al
0613+  08C4 B9 00       	cmp al, 0
0614+  08C6 C6 D9 08    	je mul_exit
0615+  08C9 6F 30       	sub al, $30		; make into integer
0616+  08CB 22 00       	mov ah, 0
0617+  08CD 2A          	mov b, [d]
0618+  08CE AC          	mul a, b			; result in B since it fits in 16bits
0619+  08CF 11          	mov a, b
0620+  08D0 28          	mov b, c
0621+  08D1 54          	add a, b
0622+  08D2 39          	mov c, a
0623+  08D3 63 02 00    	sub d, 2
0624+  08D6 0A C3 08    	jmp mul_loop
0625+  08D9             mul_exit:
0626+  08D9 12          	mov a, c
0627+  08DA E7          	pop d
0628+  08DB E6          	pop c
0629+  08DC E5          	pop b
0630+  08DD EF          	pop si
0631+  08DE F9          	leave
0632+  08DF 09          	ret
0220   08E0             ; -----end include block-----
0221   08E0             
0222   08E0             .end
tasm: Number of errors = 0
