!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/home/pconst/Desktop/sol-1/ccompiler/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	5.9.0	//
<C-Del>	session_win.vim	/^vmap <C-Del> "*d$/;"	m
<C-H>	session_win.vim	/^map <C-H> h$/;"	m
<C-Insert>	session_win.vim	/^vmap <C-Insert> "*y$/;"	m
<C-J>	session_win.vim	/^map <C-J> j$/;"	m
<C-K>	session_win.vim	/^map <C-K> k$/;"	m
<C-L>	session_win.vim	/^map <C-L> l$/;"	m
<C-U>	Session.vim	/^inoremap <C-U> u$/;"	m
<C-X>	session_win.vim	/^vmap <C-X> "*d$/;"	m
<NL>	session_win.vim	/^map <NL> j$/;"	m
<Plug>(lazysync-do)	session_win.vim	/^inoremap <silent> <Plug>(lazysync-do) =minimap#_lazysync_do()$/;"	m
<Plug>(lazysync-do)	session_win.vim	/^nnoremap <silent> <Plug>(lazysync-do) :call minimap#_lazysync_do()$/;"	m
<Plug>NetrwBrowseX	Session.vim	/^nnoremap <silent> <Plug>NetrwBrowseX :call netrw#BrowseX(expand((exists("g:netrw_gx")? g:netrw_g/;"	m
<Plug>NetrwBrowseX	session_win.vim	/^nnoremap <silent> <Plug>NetrwBrowseX :call netrw#BrowseX(netrw#GX(),netrw#CheckIfRemote(netrw#GX/;"	m
<Plug>NetrwBrowseXVis	Session.vim	/^vnoremap <silent> <Plug>NetrwBrowseXVis :call netrw#BrowseXVis()$/;"	m
<Plug>NetrwBrowseXVis	session_win.vim	/^xnoremap <silent> <Plug>NetrwBrowseXVis :call netrw#BrowseXVis()$/;"	m
<S-Del>	session_win.vim	/^vmap <S-Del> "*d$/;"	m
<S-Insert>	Session.vim	/^map <S-Insert> <MiddleMouse>$/;"	m
<S-Insert>	Session.vim	/^map! <S-Insert> <MiddleMouse>$/;"	m
<S-Insert>	session_win.vim	/^map! <S-Insert> *$/;"	m
<S-Insert>	session_win.vim	/^nmap <S-Insert> "*P$/;"	m
<S-Insert>	session_win.vim	/^vmap <S-Insert> "-d"*P$/;"	m
AMPERSAND	def.h	/^  BITWISE_AND, AMPERSAND = BITWISE_AND, BITWISE_OR, BITWISE_NOT, BITWISE_SL, BITWISE_SR,$/;"	e	enum:__anon0f49ad0a0103
ASM	def.h	/^  ASM$/;"	e	enum:__anon0f49ad0a0103
ASM_output	def.h	/^char ASM_output[64*1024]; \/\/ ASM output $/;"	v	typeref:typename:char[]
ASSIGNMENT	def.h	/^  ASSIGNMENT,$/;"	e	enum:__anon0f49ad0a0103
BITWISE_AND	def.h	/^  BITWISE_AND, AMPERSAND = BITWISE_AND, BITWISE_OR, BITWISE_NOT, BITWISE_SL, BITWISE_SR,$/;"	e	enum:__anon0f49ad0a0103
BITWISE_NOT	def.h	/^  BITWISE_AND, AMPERSAND = BITWISE_AND, BITWISE_OR, BITWISE_NOT, BITWISE_SL, BITWISE_SR,$/;"	e	enum:__anon0f49ad0a0103
BITWISE_OR	def.h	/^  BITWISE_AND, AMPERSAND = BITWISE_AND, BITWISE_OR, BITWISE_NOT, BITWISE_SL, BITWISE_SR,$/;"	e	enum:__anon0f49ad0a0103
BITWISE_SL	def.h	/^  BITWISE_AND, AMPERSAND = BITWISE_AND, BITWISE_OR, BITWISE_NOT, BITWISE_SL, BITWISE_SR,$/;"	e	enum:__anon0f49ad0a0103
BITWISE_SR	def.h	/^  BITWISE_AND, AMPERSAND = BITWISE_AND, BITWISE_OR, BITWISE_NOT, BITWISE_SL, BITWISE_SR,$/;"	e	enum:__anon0f49ad0a0103
BREAK	def.h	/^  IF, ELSE, FOR, DO, WHILE, BREAK, CONTINUE, SWITCH, CASE, DEFAULT, RETURN, CONST,$/;"	e	enum:__anon0f49ad0a0103
CASE	def.h	/^  IF, ELSE, FOR, DO, WHILE, BREAK, CONTINUE, SWITCH, CASE, DEFAULT, RETURN, CONST,$/;"	e	enum:__anon0f49ad0a0103
CHAR	def.h	/^  VOID, CHAR, INT, FLOAT, DOUBLE,$/;"	e	enum:__anon0f49ad0a0103
CHAR_CONST	def.h	/^  CHAR_CONST, STRING_CONST, INTEGER_CONST, FLOAT_CONST, DOUBLE_CONST,$/;"	e	enum:__anon0f49ad0a0203
CLOSING_BRACE	def.h	/^  OPENING_BRACE, CLOSING_BRACE,$/;"	e	enum:__anon0f49ad0a0103
CLOSING_BRACE_EXPECTED	def.h	/^  CLOSING_BRACE_EXPECTED,$/;"	e	enum:__anon0f49ad0a0c03
CLOSING_BRACKET	def.h	/^  OPENING_BRACKET, CLOSING_BRACKET,$/;"	e	enum:__anon0f49ad0a0103
CLOSING_BRACKET_EXPECTED	def.h	/^  CLOSING_BRACKET_EXPECTED,$/;"	e	enum:__anon0f49ad0a0c03
CLOSING_PAREN	def.h	/^  OPENING_PAREN, CLOSING_PAREN,$/;"	e	enum:__anon0f49ad0a0103
CLOSING_PAREN_EXPECTED	def.h	/^  CLOSING_PAREN_EXPECTED,$/;"	e	enum:__anon0f49ad0a0c03
COMMA	def.h	/^  SEMICOLON, COMMA,$/;"	e	enum:__anon0f49ad0a0103
COMMA_EXPECTED	def.h	/^  COMMA_EXPECTED,$/;"	e	enum:__anon0f49ad0a0c03
CONST	def.h	/^  IF, ELSE, FOR, DO, WHILE, BREAK, CONTINUE, SWITCH, CASE, DEFAULT, RETURN, CONST,$/;"	e	enum:__anon0f49ad0a0103
CONSTANT_VARIABLE_ASSIGNMENT	def.h	/^  CONSTANT_VARIABLE_ASSIGNMENT,$/;"	e	enum:__anon0f49ad0a0c03
CONST_LEN	def.h	/^#define CONST_LEN /;"	d
CONTINUE	def.h	/^  IF, ELSE, FOR, DO, WHILE, BREAK, CONTINUE, SWITCH, CASE, DEFAULT, RETURN, CONST,$/;"	e	enum:__anon0f49ad0a0103
DECREMENT	def.h	/^  PLUS, MINUS, STAR, FSLASH, INCREMENT, DECREMENT, MOD,$/;"	e	enum:__anon0f49ad0a0103
DEFAULT	def.h	/^  IF, ELSE, FOR, DO, WHILE, BREAK, CONTINUE, SWITCH, CASE, DEFAULT, RETURN, CONST,$/;"	e	enum:__anon0f49ad0a0103
DELIMITER	def.h	/^  DELIMITER = 1,$/;"	e	enum:__anon0f49ad0a0203
DIRECTIVE	def.h	/^  DIRECTIVE = 1, INCLUDE,$/;"	e	enum:__anon0f49ad0a0103
DIRECTIVE_SYNTAX	def.h	/^  DIRECTIVE_SYNTAX,$/;"	e	enum:__anon0f49ad0a0c03
DO	def.h	/^  IF, ELSE, FOR, DO, WHILE, BREAK, CONTINUE, SWITCH, CASE, DEFAULT, RETURN, CONST,$/;"	e	enum:__anon0f49ad0a0103
DOUBLE	def.h	/^  VOID, CHAR, INT, FLOAT, DOUBLE,$/;"	e	enum:__anon0f49ad0a0103
DOUBLE_CONST	def.h	/^  CHAR_CONST, STRING_CONST, INTEGER_CONST, FLOAT_CONST, DOUBLE_CONST,$/;"	e	enum:__anon0f49ad0a0203
DOUBLE_QUOTE_EXPECTED	def.h	/^  DOUBLE_QUOTE_EXPECTED,$/;"	e	enum:__anon0f49ad0a0c03
DT_CHAR	def.h	/^  DT_VOID = 1, DT_CHAR, DT_INT, DT_FLOAT, DT_DOUBLE, DT_STRUCT$/;"	e	enum:__anon0f49ad0a0503
DT_DOUBLE	def.h	/^  DT_VOID = 1, DT_CHAR, DT_INT, DT_FLOAT, DT_DOUBLE, DT_STRUCT$/;"	e	enum:__anon0f49ad0a0503
DT_FLOAT	def.h	/^  DT_VOID = 1, DT_CHAR, DT_INT, DT_FLOAT, DT_DOUBLE, DT_STRUCT$/;"	e	enum:__anon0f49ad0a0503
DT_INT	def.h	/^  DT_VOID = 1, DT_CHAR, DT_INT, DT_FLOAT, DT_DOUBLE, DT_STRUCT$/;"	e	enum:__anon0f49ad0a0503
DT_STRUCT	def.h	/^  DT_VOID = 1, DT_CHAR, DT_INT, DT_FLOAT, DT_DOUBLE, DT_STRUCT$/;"	e	enum:__anon0f49ad0a0503
DT_VOID	def.h	/^  DT_VOID = 1, DT_CHAR, DT_INT, DT_FLOAT, DT_DOUBLE, DT_STRUCT$/;"	e	enum:__anon0f49ad0a0503
DUPLICATE_GLOBAL_VARIABLE	def.h	/^  DUPLICATE_GLOBAL_VARIABLE,$/;"	e	enum:__anon0f49ad0a0c03
DUPLICATE_LOCAL_VARIABLE	def.h	/^  DUPLICATE_LOCAL_VARIABLE,$/;"	e	enum:__anon0f49ad0a0c03
ELSE	def.h	/^  IF, ELSE, FOR, DO, WHILE, BREAK, CONTINUE, SWITCH, CASE, DEFAULT, RETURN, CONST,$/;"	e	enum:__anon0f49ad0a0103
END	def.h	/^  IDENTIFIER, RESERVED, END$/;"	e	enum:__anon0f49ad0a0203
ENUM	def.h	/^  ENUM,$/;"	e	enum:__anon0f49ad0a0103
EQUAL	def.h	/^  EQUAL, NOT_EQUAL, LESS_THAN, LESS_THAN_OR_EQUAL, GREATER_THAN, GREATER_THAN_OR_EQUAL,$/;"	e	enum:__anon0f49ad0a0103
EXCEEDED_FUNC_DECL_LIMIT	def.h	/^  EXCEEDED_FUNC_DECL_LIMIT,$/;"	e	enum:__anon0f49ad0a0c03
EXCEEDED_GLOBAL_VAR_LIMIT	def.h	/^  EXCEEDED_GLOBAL_VAR_LIMIT,$/;"	e	enum:__anon0f49ad0a0c03
FALSE	def.h	/^#define FALSE /;"	d
FLOAT	def.h	/^  VOID, CHAR, INT, FLOAT, DOUBLE,$/;"	e	enum:__anon0f49ad0a0103
FLOAT_CONST	def.h	/^  CHAR_CONST, STRING_CONST, INTEGER_CONST, FLOAT_CONST, DOUBLE_CONST,$/;"	e	enum:__anon0f49ad0a0203
FOR	def.h	/^  IF, ELSE, FOR, DO, WHILE, BREAK, CONTINUE, SWITCH, CASE, DEFAULT, RETURN, CONST,$/;"	e	enum:__anon0f49ad0a0103
FSLASH	def.h	/^  PLUS, MINUS, STAR, FSLASH, INCREMENT, DECREMENT, MOD,$/;"	e	enum:__anon0f49ad0a0103
GREATER_THAN	def.h	/^  EQUAL, NOT_EQUAL, LESS_THAN, LESS_THAN_OR_EQUAL, GREATER_THAN, GREATER_THAN_OR_EQUAL,$/;"	e	enum:__anon0f49ad0a0103
GREATER_THAN_OR_EQUAL	def.h	/^  EQUAL, NOT_EQUAL, LESS_THAN, LESS_THAN_OR_EQUAL, GREATER_THAN, GREATER_THAN_OR_EQUAL,$/;"	e	enum:__anon0f49ad0a0103
IDENTIFIER	def.h	/^  IDENTIFIER, RESERVED, END$/;"	e	enum:__anon0f49ad0a0203
IDENTIFIER_EXPECTED	def.h	/^  IDENTIFIER_EXPECTED,$/;"	e	enum:__anon0f49ad0a0c03
ID_LEN	def.h	/^#define ID_LEN /;"	d
IF	def.h	/^  IF, ELSE, FOR, DO, WHILE, BREAK, CONTINUE, SWITCH, CASE, DEFAULT, RETURN, CONST,$/;"	e	enum:__anon0f49ad0a0103
INCLUDE	def.h	/^  DIRECTIVE = 1, INCLUDE,$/;"	e	enum:__anon0f49ad0a0103
INCOMPATIBLE_ARGUMENT_TYPE	def.h	/^  INCOMPATIBLE_ARGUMENT_TYPE$/;"	e	enum:__anon0f49ad0a0c03
INCOMPATIBLE_FUNCTION_ARGUMENT	def.h	/^  INCOMPATIBLE_FUNCTION_ARGUMENT,$/;"	e	enum:__anon0f49ad0a0c03
INCREMENT	def.h	/^  PLUS, MINUS, STAR, FSLASH, INCREMENT, DECREMENT, MOD,$/;"	e	enum:__anon0f49ad0a0103
INSUFFICIENT_ARGUMENTS	def.h	/^  INSUFFICIENT_ARGUMENTS,$/;"	e	enum:__anon0f49ad0a0c03
INT	def.h	/^  VOID, CHAR, INT, FLOAT, DOUBLE,$/;"	e	enum:__anon0f49ad0a0103
INTEGER_CONST	def.h	/^  CHAR_CONST, STRING_CONST, INTEGER_CONST, FLOAT_CONST, DOUBLE_CONST,$/;"	e	enum:__anon0f49ad0a0203
INVALID_ARGUMENT_FOR_BITWISE_NOT	def.h	/^  INVALID_ARGUMENT_FOR_BITWISE_NOT,$/;"	e	enum:__anon0f49ad0a0c03
INVALID_BINARY_OPERANDS	def.h	/^  INVALID_BINARY_OPERANDS,$/;"	e	enum:__anon0f49ad0a0c03
INVALID_EXPRESSION	def.h	/^  INVALID_EXPRESSION,$/;"	e	enum:__anon0f49ad0a0c03
INVALID_MATRIX_ASSIGNMENT	def.h	/^  INVALID_MATRIX_ASSIGNMENT,$/;"	e	enum:__anon0f49ad0a0c03
INVALID_MATRIX_DIMENSION	def.h	/^  INVALID_MATRIX_DIMENSION,$/;"	e	enum:__anon0f49ad0a0c03
INVALID_PRINTF_FORMAT_CODE	def.h	/^  INVALID_PRINTF_FORMAT_CODE,$/;"	e	enum:__anon0f49ad0a0c03
JF_BREAK	def.h	/^  JF_BREAK, $/;"	e	enum:__anon0f49ad0a0303
JF_CONTINUE	def.h	/^  JF_CONTINUE, $/;"	e	enum:__anon0f49ad0a0303
JF_NULL	def.h	/^  JF_NULL, $/;"	e	enum:__anon0f49ad0a0303
JF_RETURN	def.h	/^  JF_RETURN$/;"	e	enum:__anon0f49ad0a0303
LESS_THAN	def.h	/^  EQUAL, NOT_EQUAL, LESS_THAN, LESS_THAN_OR_EQUAL, GREATER_THAN, GREATER_THAN_OR_EQUAL,$/;"	e	enum:__anon0f49ad0a0103
LESS_THAN_OR_EQUAL	def.h	/^  EQUAL, NOT_EQUAL, LESS_THAN, LESS_THAN_OR_EQUAL, GREATER_THAN, GREATER_THAN_OR_EQUAL,$/;"	e	enum:__anon0f49ad0a0103
LOCAL_VAR_LIMIT_REACHED	def.h	/^  LOCAL_VAR_LIMIT_REACHED,$/;"	e	enum:__anon0f49ad0a0c03
LOGICAL_AND	def.h	/^  LOGICAL_AND, LOGICAL_OR, LOGICAL_NOT,$/;"	e	enum:__anon0f49ad0a0103
LOGICAL_NOT	def.h	/^  LOGICAL_AND, LOGICAL_OR, LOGICAL_NOT,$/;"	e	enum:__anon0f49ad0a0103
LOGICAL_OR	def.h	/^  LOGICAL_AND, LOGICAL_OR, LOGICAL_NOT,$/;"	e	enum:__anon0f49ad0a0103
LONG	def.h	/^  SHORT, LONG, SIGNED, UNSIGNED,$/;"	e	enum:__anon0f49ad0a0103
MATRIX_EXPECTED	def.h	/^  MATRIX_EXPECTED,$/;"	e	enum:__anon0f49ad0a0c03
MATRIX_INDEX_OUTSIDE_BOUNDS	def.h	/^  MATRIX_INDEX_OUTSIDE_BOUNDS,$/;"	e	enum:__anon0f49ad0a0c03
MAX_GLOBAL_VARS	def.h	/^#define MAX_GLOBAL_VARS /;"	d
MAX_LOCAL_VARS	def.h	/^#define MAX_LOCAL_VARS /;"	d
MAX_MATRIX_DIMS	def.h	/^#define MAX_MATRIX_DIMS /;"	d
MAX_PARAMS_LIMIT_REACHED	def.h	/^  MAX_PARAMS_LIMIT_REACHED,$/;"	e	enum:__anon0f49ad0a0c03
MAX_USER_FUNC	def.h	/^#define MAX_USER_FUNC /;"	d
MEMORY_ALLOCATION_FAILURE	def.h	/^  MEMORY_ALLOCATION_FAILURE,$/;"	e	enum:__anon0f49ad0a0c03
MINUS	def.h	/^  PLUS, MINUS, STAR, FSLASH, INCREMENT, DECREMENT, MOD,$/;"	e	enum:__anon0f49ad0a0103
MOD	def.h	/^  PLUS, MINUS, STAR, FSLASH, INCREMENT, DECREMENT, MOD,$/;"	e	enum:__anon0f49ad0a0103
NOT_EQUAL	def.h	/^  EQUAL, NOT_EQUAL, LESS_THAN, LESS_THAN_OR_EQUAL, GREATER_THAN, GREATER_THAN_OR_EQUAL,$/;"	e	enum:__anon0f49ad0a0103
NOT_VAR_OR_FUNC_OUTSIDE	def.h	/^  NOT_VAR_OR_FUNC_OUTSIDE,$/;"	e	enum:__anon0f49ad0a0c03
NO_MAIN_FOUND	def.h	/^  NO_MAIN_FOUND,$/;"	e	enum:__anon0f49ad0a0c03
OPENING_BRACE	def.h	/^  OPENING_BRACE, CLOSING_BRACE,$/;"	e	enum:__anon0f49ad0a0103
OPENING_BRACE_EXPECTED	def.h	/^  OPENING_BRACE_EXPECTED,$/;"	e	enum:__anon0f49ad0a0c03
OPENING_BRACKET	def.h	/^  OPENING_BRACKET, CLOSING_BRACKET,$/;"	e	enum:__anon0f49ad0a0103
OPENING_BRACKET_EXPECTED	def.h	/^  OPENING_BRACKET_EXPECTED,$/;"	e	enum:__anon0f49ad0a0c03
OPENING_PAREN	def.h	/^  OPENING_PAREN, CLOSING_PAREN,$/;"	e	enum:__anon0f49ad0a0103
OPENING_PAREN_EXPECTED	def.h	/^  OPENING_PAREN_EXPECTED, $/;"	e	enum:__anon0f49ad0a0c03
PLUS	def.h	/^  PLUS, MINUS, STAR, FSLASH, INCREMENT, DECREMENT, MOD,$/;"	e	enum:__anon0f49ad0a0103
POINTER_EXPECTED	def.h	/^  POINTER_EXPECTED,$/;"	e	enum:__anon0f49ad0a0c03
POINTER_SYNTAX	def.h	/^  POINTER_SYNTAX,$/;"	e	enum:__anon0f49ad0a0c03
PROG_SIZE	def.h	/^#define PROG_SIZE /;"	d
Q	Session.vim	/^map Q gq$/;"	m
RESERVED	def.h	/^  IDENTIFIER, RESERVED, END$/;"	e	enum:__anon0f49ad0a0203
RETURN	def.h	/^  IF, ELSE, FOR, DO, WHILE, BREAK, CONTINUE, SWITCH, CASE, DEFAULT, RETURN, CONST,$/;"	e	enum:__anon0f49ad0a0103
RETURNING_VALUE_FROM_VOID_FUNCTION	def.h	/^  RETURNING_VALUE_FROM_VOID_FUNCTION,$/;"	e	enum:__anon0f49ad0a0c03
SEMICOLON	def.h	/^  SEMICOLON, COMMA,$/;"	e	enum:__anon0f49ad0a0103
SEMICOLON_EXPECTED	def.h	/^  SEMICOLON_EXPECTED,$/;"	e	enum:__anon0f49ad0a0c03
SHORT	def.h	/^  SHORT, LONG, SIGNED, UNSIGNED,$/;"	e	enum:__anon0f49ad0a0103
SIGNED	def.h	/^  SHORT, LONG, SIGNED, UNSIGNED,$/;"	e	enum:__anon0f49ad0a0103
SINGLE_QUOTE_EXPECTED	def.h	/^  SINGLE_QUOTE_EXPECTED,$/;"	e	enum:__anon0f49ad0a0c03
SIZEOF	def.h	/^  SIZEOF,$/;"	e	enum:__anon0f49ad0a0103
STAR	def.h	/^  PLUS, MINUS, STAR, FSLASH, INCREMENT, DECREMENT, MOD,$/;"	e	enum:__anon0f49ad0a0103
STRING_CONST	def.h	/^  CHAR_CONST, STRING_CONST, INTEGER_CONST, FLOAT_CONST, DOUBLE_CONST,$/;"	e	enum:__anon0f49ad0a0203
STRING_CONSTANT_EXPECTED	def.h	/^  STRING_CONSTANT_EXPECTED,$/;"	e	enum:__anon0f49ad0a0c03
STRING_TABLE_SIZE	def.h	/^#define STRING_TABLE_SIZE /;"	d
STRUCT	def.h	/^  STRUCT, STRUCT_DOT, STRUCT_ARROW,$/;"	e	enum:__anon0f49ad0a0103
STRUCT_ARROW	def.h	/^  STRUCT, STRUCT_DOT, STRUCT_ARROW,$/;"	e	enum:__anon0f49ad0a0103
STRUCT_DOT	def.h	/^  STRUCT, STRUCT_DOT, STRUCT_ARROW,$/;"	e	enum:__anon0f49ad0a0103
STRUCT_EXPECTED	def.h	/^  STRUCT_EXPECTED,$/;"	e	enum:__anon0f49ad0a0c03
STRUCT_NAME_EXPECTED	def.h	/^  STRUCT_NAME_EXPECTED,$/;"	e	enum:__anon0f49ad0a0c03
SWITCH	def.h	/^  IF, ELSE, FOR, DO, WHILE, BREAK, CONTINUE, SWITCH, CASE, DEFAULT, RETURN, CONST,$/;"	e	enum:__anon0f49ad0a0103
SYNTAX	def.h	/^  SYNTAX,$/;"	e	enum:__anon0f49ad0a0c03
SessionLoad	Session.vim	/^let SessionLoad = 1$/;"	v
SessionLoad	session_win.vim	/^let SessionLoad = 1$/;"	v
TOKTYP_CHAR	bin/lib/token.asm	/^TOKTYP_CHAR			.equ 4$/;"	l
TOKTYP_DELIMITER	bin/lib/token.asm	/^TOKTYP_DELIMITER	.equ 2$/;"	l
TOKTYP_END	bin/lib/token.asm	/^TOKTYP_END			.equ 6$/;"	l
TOKTYP_IDENTIFIER	bin/lib/token.asm	/^TOKTYP_IDENTIFIER	.equ 0$/;"	l
TOKTYP_KEYWORD	bin/lib/token.asm	/^TOKTYP_KEYWORD		.equ 1$/;"	l
TOKTYP_NUMERIC	bin/lib/token.asm	/^TOKTYP_NUMERIC		.equ 5$/;"	l
TOKTYP_STRING	bin/lib/token.asm	/^TOKTYP_STRING		.equ 3$/;"	l
TOK_ANGLE	bin/lib/token.asm	/^TOK_ANGLE			.equ 7$/;"	l
TOK_COLON	bin/lib/token.asm	/^TOK_COLON			.equ 10$/;"	l
TOK_COMMA	bin/lib/token.asm	/^TOK_COMMA			.equ 11$/;"	l
TOK_DOT	bin/lib/token.asm	/^TOK_DOT				.equ 5$/;"	l
TOK_END	bin/lib/token.asm	/^TOK_END				.equ 20$/;"	l
TOK_EQUAL	bin/lib/token.asm	/^TOK_EQUAL			.equ 9$/;"	l
TOK_FSLASH	bin/lib/token.asm	/^TOK_FSLASH			.equ 1$/;"	l
TOK_MINUS	bin/lib/token.asm	/^TOK_MINUS 			.equ 4$/;"	l
TOK_NULL	bin/lib/token.asm	/^TOK_NULL			.equ 0$/;"	l
TOK_PLUS	bin/lib/token.asm	/^TOK_PLUS 			.equ 3$/;"	l
TOK_SEMI	bin/lib/token.asm	/^TOK_SEMI			.equ 6$/;"	l
TOK_TILDE	bin/lib/token.asm	/^TOK_TILDE			.equ 8$/;"	l
TOK_TIMES	bin/lib/token.asm	/^TOK_TIMES 			.equ 2$/;"	l
TOO_MANY_MATRIX_DIMENSIONS	def.h	/^  TOO_MANY_MATRIX_DIMENSIONS,$/;"	e	enum:__anon0f49ad0a0c03
TRUE	def.h	/^#define TRUE /;"	d
UNDECLARED_FUNC	def.h	/^  UNDECLARED_FUNC,$/;"	e	enum:__anon0f49ad0a0c03
UNDECLARED_STRUCT	def.h	/^  UNDECLARED_STRUCT,$/;"	e	enum:__anon0f49ad0a0c03
UNDECLARED_VARIABLE	def.h	/^  UNDECLARED_VARIABLE,$/;"	e	enum:__anon0f49ad0a0c03
UNEXPECTED_EOF	def.h	/^  UNEXPECTED_EOF,$/;"	e	enum:__anon0f49ad0a0c03
UNKNOWN_DIRECTIVE	def.h	/^  UNKNOWN_DIRECTIVE,$/;"	e	enum:__anon0f49ad0a0c03
UNKOWN_LIBRARY	def.h	/^  UNKOWN_LIBRARY,$/;"	e	enum:__anon0f49ad0a0c03
UNSIGNED	def.h	/^  SHORT, LONG, SIGNED, UNSIGNED,$/;"	e	enum:__anon0f49ad0a0103
USER_FUNC_CALLS_LIMIT_REACHED	def.h	/^  USER_FUNC_CALLS_LIMIT_REACHED,$/;"	e	enum:__anon0f49ad0a0c03
VAR_TYPE_EXPECTED	def.h	/^  VAR_TYPE_EXPECTED,$/;"	e	enum:__anon0f49ad0a0c03
VOID	def.h	/^  VOID, CHAR, INT, FLOAT, DOUBLE,$/;"	e	enum:__anon0f49ad0a0103
WHILE	def.h	/^  IF, ELSE, FOR, DO, WHILE, BREAK, CONTINUE, SWITCH, CASE, DEFAULT, RETURN, CONST,$/;"	e	enum:__anon0f49ad0a0103
WHILE_KEYWORD_EXPECTED	def.h	/^  WHILE_KEYWORD_EXPECTED,$/;"	e	enum:__anon0f49ad0a0c03
["	Session.vim	/^nnoremap <buffer> <silent> [" :call search('\\%(^\\s*".*\\n\\)\\%(^\\s*"\\)\\@!', "bW")$/;"	m
["	Session.vim	/^vnoremap <buffer> <silent> [" :exe "normal! gv"|call search('\\%(^\\s*".*\\n\\)\\%(^\\s*"\\)\\/;"	m
[[	Session.vim	/^nnoremap <buffer> <silent> [[ m':call search('^\\s*fu\\%[nction]\\>', "bW")$/;"	m
[[	Session.vim	/^vnoremap <buffer> <silent> [[ m':exe "normal! gv"|call search('^\\s*fu\\%[nction]\\>', "bW")$/;"	m
[]	Session.vim	/^nnoremap <buffer> <silent> [] m':call search('^\\s*endf\\%[unction]\\>', "bW")$/;"	m
[]	Session.vim	/^vnoremap <buffer> <silent> [] m':exe "normal! gv"|call search('^\\s*endf\\%[unction]\\>', "bW/;"	m
\x16\b	session_win.vim	/^map  h$/;"	m
\x16\f	session_win.vim	/^map  l$/;"	m
\x16\v	session_win.vim	/^map  k$/;"	m
\x16\x15	Session.vim	/^inoremap  u$/;"	m
\x16\x18	session_win.vim	/^vmap  "*d$/;"	m
]"	Session.vim	/^nnoremap <buffer> <silent> ]" :call search('^\\(\\s*".*\\n\\)\\@<!\\(\\s*"\\)', "W")$/;"	m
]"	Session.vim	/^vnoremap <buffer> <silent> ]" :exe "normal! gv"|call search('^\\(\\s*".*\\n\\)\\@<!\\(\\s*"\\/;"	m
][	Session.vim	/^nnoremap <buffer> <silent> ][ m':call search('^\\s*endf\\%[unction]\\>', "W")$/;"	m
][	Session.vim	/^vnoremap <buffer> <silent> ][ m':exe "normal! gv"|call search('^\\s*endf\\%[unction]\\>', "W"/;"	m
]]	Session.vim	/^nnoremap <buffer> <silent> ]] m':call search('^\\s*fu\\%[nction]\\>', "W")$/;"	m
]]	Session.vim	/^vnoremap <buffer> <silent> ]] m':exe "normal! gv"|call search('^\\s*fu\\%[nction]\\>', "W")$/;"	m
_BASIC_DATA	def.h	/^} _BASIC_DATA;$/;"	t	typeref:enum:__anon0f49ad0a0503
_CONST	def.h	/^} _CONST;$/;"	t	typeref:struct:__anon0f49ad0a0808
_DATA	def.h	/^} _DATA;$/;"	t	typeref:struct:__anon0f49ad0a0708
_ERROR	def.h	/^} _ERROR;$/;"	t	typeref:enum:__anon0f49ad0a0c03
_GLOBAL_VAR	def.h	/^} _GLOBAL_VAR;$/;"	t	typeref:struct:__anon0f49ad0a0a08
_JUMP_FLAG	def.h	/^} _JUMP_FLAG;$/;"	t	typeref:enum:__anon0f49ad0a0303
_LOCAL_VAR	def.h	/^} _LOCAL_VAR;$/;"	t	typeref:struct:__anon0f49ad0a0908
_MODIFIER	def.h	/^} _MODIFIER;$/;"	t	typeref:enum:__anon0f49ad0a0603
_TOKEN	def.h	/^} _TOKEN; \/\/ internal token representation$/;"	t	typeref:enum:__anon0f49ad0a0103
_TOKEN_TYPE	def.h	/^} _TOKEN_TYPE;$/;"	t	typeref:enum:__anon0f49ad0a0203
_USER_FUNC	def.h	/^} _USER_FUNC;$/;"	t	typeref:struct:__anon0f49ad0a0b08
_VALUE	def.h	/^} _VALUE;$/;"	t	typeref:union:__anon0f49ad0a040a
__anon0f49ad0a0103	def.h	/^typedef enum {$/;"	g
__anon0f49ad0a0203	def.h	/^typedef enum {$/;"	g
__anon0f49ad0a0303	def.h	/^typedef enum {$/;"	g
__anon0f49ad0a040a	def.h	/^typedef union {$/;"	u
__anon0f49ad0a0503	def.h	/^typedef enum {$/;"	g
__anon0f49ad0a0603	def.h	/^typedef enum {$/;"	g
__anon0f49ad0a0708	def.h	/^typedef struct {$/;"	s
__anon0f49ad0a0808	def.h	/^typedef struct {$/;"	s
__anon0f49ad0a0908	def.h	/^typedef struct {$/;"	s
__anon0f49ad0a0a08	def.h	/^typedef struct {$/;"	s
__anon0f49ad0a0b08	def.h	/^typedef struct {$/;"	s
__anon0f49ad0a0c03	def.h	/^typedef enum {$/;"	g
_keyword_table	def.h	/^struct _keyword_table{$/;"	s
as_string	def.h	/^  char as_string[256]; \/\/ this just saves the initialization string in case the var is a strin/;"	m	struct:__anon0f49ad0a0a08	typeref:typename:char[256]
asmp	def.h	/^char *asmp;$/;"	v	typeref:typename:char *
atoi	bin/lib/stdio.asm	/^atoi:$/;"	l
bp_offset	def.h	/^  int bp_offset; \/\/ if var is local, this holds the offset of the var from BP.$/;"	m	struct:__anon0f49ad0a0908	typeref:typename:int
c	def.h	/^  char c;$/;"	m	union:__anon0f49ad0a040a	typeref:typename:char
code_location	def.h	/^  char *code_location;$/;"	m	struct:__anon0f49ad0a0b08	typeref:typename:char *
coef	bin/options.c	/^int coef = 1;$/;"	v	typeref:typename:int
coef	bin/pascal.c	/^int coef = 1;$/;"	v	typeref:typename:int
constant	def.h	/^  char constant;$/;"	m	struct:__anon0f49ad0a0908	typeref:typename:char
constant	def.h	/^  char constant;$/;"	m	struct:__anon0f49ad0a0a08	typeref:typename:char
convert_constant	cc.c	/^void convert_constant(){$/;"	f	typeref:typename:void
count	bin/options.c	/^int count = 0;$/;"	v	typeref:typename:int
count	bin/primes.c	/^int count = 0;$/;"	v	typeref:typename:int
current_func_id	def.h	/^int current_func_id;$/;"	v	typeref:typename:int
current_function_var_bp_offset	def.h	/^int current_function_var_bp_offset;  \/\/ this is used to position local variables correctly rel/;"	v	typeref:typename:int
current_label_index_if	def.h	/^int current_label_index_if = 0; \/\/ index of current 'if' label. starts at 0$/;"	v	typeref:typename:int
current_label_index_loop	def.h	/^int current_label_index_loop = 0; \/\/ index of current 'while' label. starts at 0$/;"	v	typeref:typename:int
d	def.h	/^  double d;$/;"	m	union:__anon0f49ad0a040a	typeref:typename:double
data	def.h	/^  _DATA data; \/\/ holds the type of data and the value itself$/;"	m	struct:__anon0f49ad0a0908	typeref:typename:_DATA
data	def.h	/^  _DATA data; \/\/ holds the type of data and the value itself$/;"	m	struct:__anon0f49ad0a0a08	typeref:typename:_DATA
data	def.h	/^  _DATA data;$/;"	m	struct:__anon0f49ad0a0808	typeref:typename:_DATA
dbg	cc.c	/^void dbg(char *s){$/;"	f	typeref:typename:void
declare_func	cc.c	/^void declare_func(void){$/;"	f	typeref:typename:void
declare_global	cc.c	/^void declare_global(void){$/;"	f	typeref:typename:void
declare_local	cc.c	/^void declare_local(void){                        $/;"	f	typeref:typename:void
dims	def.h	/^  int dims[MAX_MATRIX_DIMS + 1];$/;"	m	struct:__anon0f49ad0a0908	typeref:typename:int[]
dims	def.h	/^  int dims[MAX_MATRIX_DIMS + 1];$/;"	m	struct:__anon0f49ad0a0a08	typeref:typename:int[]
divides	bin/options.c	/^int divides;$/;"	v	typeref:typename:int
divides	bin/primes.c	/^int divides;$/;"	v	typeref:typename:int
emit	cc.c	/^void emit(char *p){$/;"	f	typeref:typename:void
emit_global_variables	cc.c	/^void emit_global_variables(void){$/;"	f	typeref:typename:void
emit_libraries	cc.c	/^void emit_libraries(void){$/;"	f	typeref:typename:void
emitln	cc.c	/^void emitln(char *p){$/;"	f	typeref:typename:void
error_table	def.h	/^char *error_table[] = {$/;"	v	typeref:typename:char * []
f	def.h	/^  float f;$/;"	m	union:__anon0f49ad0a040a	typeref:typename:float
fact	bin/lib/math.asm	/^fact:$/;"	l
fact2	bin/lib/math.asm	/^fact2:$/;"	l
factors	bin/options.c	/^void factors(void){$/;"	f	typeref:typename:void
find_end_of_BLOCK	cc.c	/^void find_end_of_BLOCK(void){$/;"	f	typeref:typename:void
find_end_of_block	cc.c	/^void find_end_of_block(void){$/;"	f	typeref:typename:void
find_function	cc.c	/^int find_function(char *func_name){$/;"	f	typeref:typename:int
find_global_var	cc.c	/^int find_global_var(char *var_name){$/;"	f	typeref:typename:int
find_keyword	cc.c	/^int find_keyword(char *keyword){$/;"	f	typeref:typename:int
find_total_parameter_bytes	cc.c	/^int find_total_parameter_bytes(void){$/;"	f	typeref:typename:int
func_name	def.h	/^  char func_name[ID_LEN];$/;"	m	struct:__anon0f49ad0a0b08	typeref:typename:char[]
function_id	def.h	/^  int function_id; \/\/ the function does this local var belong to$/;"	m	struct:__anon0f49ad0a0908	typeref:typename:int
function_table	def.h	/^_USER_FUNC function_table[MAX_USER_FUNC];$/;"	v	typeref:typename:_USER_FUNC[]
function_table_tos	def.h	/^int function_table_tos;$/;"	v	typeref:typename:int
generate_file	cc.c	/^void generate_file(char *filename){$/;"	f	typeref:typename:void
get_arg	bin/lib/token.asm	/^get_arg:$/;"	l
get_arg_L0	bin/lib/token.asm	/^get_arg_L0:$/;"	l
get_arg_end	bin/lib/token.asm	/^get_arg_end:$/;"	l
get_arg_skip_spaces	bin/lib/token.asm	/^get_arg_skip_spaces:$/;"	l
get_global_var	cc.c	/^_GLOBAL_VAR *get_global_var(char *var_name){$/;"	f	typeref:typename:_GLOBAL_VAR *
get_line	bin/lib/token.asm	/^get_line:$/;"	l
get_line	cc.c	/^void get_line(void){$/;"	f	typeref:typename:void
get_line_L0	bin/lib/token.asm	/^get_line_L0:$/;"	l
get_line_exit	bin/lib/token.asm	/^get_line_exit:$/;"	l
get_local_var	cc.c	/^_LOCAL_VAR *get_local_var(char *var_name){$/;"	f	typeref:typename:_LOCAL_VAR *
get_number	bin/lib/token.asm	/^get_number:$/;"	l
get_number_L0	bin/lib/token.asm	/^get_number_L0:$/;"	l
get_number_return	bin/lib/token.asm	/^get_number_return:$/;"	l
get_number_skip_spaces	bin/lib/token.asm	/^get_number_skip_spaces:$/;"	l
get_path	bin/lib/token.asm	/^get_path:$/;"	l
get_path_end	bin/lib/token.asm	/^get_path_end:$/;"	l
get_path_is_pathchar	bin/lib/token.asm	/^get_path_is_pathchar:$/;"	l
get_path_skip_spaces	bin/lib/token.asm	/^get_path_skip_spaces:$/;"	l
get_tok_comment	bin/lib/token.asm	/^get_tok_comment:$/;"	l
get_tok_skip_spaces	bin/lib/token.asm	/^get_tok_skip_spaces:$/;"	l
get_token	bin/lib/token.asm	/^get_token:$/;"	l
get_token	cc.c	/^void get_token(void){$/;"	f	typeref:typename:void
get_token_angle	bin/lib/token.asm	/^get_token_angle:$/;"	l
get_token_colon	bin/lib/token.asm	/^get_token_colon:$/;"	l
get_token_comma	bin/lib/token.asm	/^get_token_comma:$/;"	l
get_token_end	bin/lib/token.asm	/^get_token_end:				; end of file token$/;"	l
get_token_equal	bin/lib/token.asm	/^get_token_equal:$/;"	l
get_token_minus	bin/lib/token.asm	/^get_token_minus:$/;"	l
get_token_return	bin/lib/token.asm	/^get_token_return:$/;"	l
get_token_semi	bin/lib/token.asm	/^get_token_semi:$/;"	l
get_token_skip	bin/lib/token.asm	/^get_token_skip:$/;"	l
get_token_slash	bin/lib/token.asm	/^get_token_slash:$/;"	l
get_token_tilde	bin/lib/token.asm	/^get_token_tilde:$/;"	l
getchar	bin/lib/stdio.asm	/^getchar:$/;"	l
getchar_retry	bin/lib/stdio.asm	/^getchar_retry:$/;"	l
gets	bin/lib/stdio.asm	/^gets:$/;"	l
gets_CR	bin/lib/stdio.asm	/^gets_CR:$/;"	l
gets_LF	bin/lib/stdio.asm	/^gets_LF:$/;"	l
gets_backspace	bin/lib/stdio.asm	/^gets_backspace:$/;"	l
gets_end	bin/lib/stdio.asm	/^gets_end:$/;"	l
gets_escape	bin/lib/stdio.asm	/^gets_escape:$/;"	l
gets_left_arrow	bin/lib/stdio.asm	/^gets_left_arrow:$/;"	l
gets_loop	bin/lib/stdio.asm	/^gets_loop:$/;"	l
gets_right_arrow	bin/lib/stdio.asm	/^gets_right_arrow:$/;"	l
gets_telnet_escape	bin/lib/stdio.asm	/^gets_telnet_escape:$/;"	l
gets_telnet_escape_phase2	bin/lib/stdio.asm	/^gets_telnet_escape_phase2:$/;"	l
gettxt	bin/lib/stdio.asm	/^gettxt:$/;"	l
gettxt_CR	bin/lib/stdio.asm	/^gettxt_CR:$/;"	l
gettxt_LF	bin/lib/stdio.asm	/^gettxt_LF:$/;"	l
gettxt_backspace	bin/lib/stdio.asm	/^gettxt_backspace:$/;"	l
gettxt_end	bin/lib/stdio.asm	/^gettxt_end:$/;"	l
gettxt_escape	bin/lib/stdio.asm	/^gettxt_escape:$/;"	l
gettxt_loop	bin/lib/stdio.asm	/^gettxt_loop:$/;"	l
global_var_exists	cc.c	/^int global_var_exists(char *var_name){$/;"	f	typeref:typename:int
global_var_tos	def.h	/^int global_var_tos;$/;"	v	typeref:typename:int
global_variables	def.h	/^_GLOBAL_VAR global_variables[MAX_GLOBAL_VARS];$/;"	v	typeref:typename:_GLOBAL_VAR[]
gx	Session.vim	/^nmap gx <Plug>NetrwBrowseX$/;"	m
gx	Session.vim	/^vmap gx <Plug>NetrwBrowseXVis$/;"	m
gx	session_win.vim	/^nmap gx <Plug>NetrwBrowseX$/;"	m
gx	session_win.vim	/^xmap gx <Plug>NetrwBrowseXVis$/;"	m
hex_ascii_encode	bin/lib/stdio.asm	/^hex_ascii_encode:$/;"	l
hex_letter	bin/lib/stdio.asm	/^hex_letter:$/;"	l
hex_to_int	bin/lib/stdio.asm	/^hex_to_int:$/;"	l
hex_to_int_L1	bin/lib/stdio.asm	/^hex_to_int_L1:$/;"	l
hex_to_int_ret	bin/lib/stdio.asm	/^hex_to_int_ret:$/;"	l
highest_label_index	def.h	/^int highest_label_index = 0;   \/\/ this keeps the next value of the label index for use in new /;"	v	typeref:typename:int
i	bin/factors.c	/^int num, i;$/;"	v	typeref:typename:int
i	bin/options.c	/^int n, i, j;$/;"	v	typeref:typename:int
i	bin/pascal.c	/^int rows, space, i, j;$/;"	v	typeref:typename:int
i	bin/primes.c	/^int n, i, j;$/;"	v	typeref:typename:int
i	def.h	/^  int i;$/;"	m	union:__anon0f49ad0a040a	typeref:typename:int
include_lib	cc.c	/^void include_lib(char *lib_name){$/;"	f	typeref:typename:void
includes_list_ASM	def.h	/^char includes_list_ASM[1024]; \/\/ keeps a list of all included files$/;"	v	typeref:typename:char[1024]
ind_level	def.h	/^  int ind_level; \/\/ holds the pointer indirection level$/;"	m	struct:__anon0f49ad0a0708	typeref:typename:int
initial_setup	cc.c	/^void initial_setup(void){$/;"	f	typeref:typename:void
integer	bin/a.s	/^integer: .dw 25$/;"	l
integer	bin/test.c	/^int integer = 25;$/;"	v	typeref:typename:int
is_alphanumeric	bin/lib/token.asm	/^is_alphanumeric:$/;"	l
is_idchar	cc.c	/^char is_idchar(char c){$/;"	f	typeref:typename:char
is_parameter	def.h	/^  char is_parameter; \/\/ is this a parameter variable or a normal local variable?$/;"	m	struct:__anon0f49ad0a0908	typeref:typename:char
isalnum	bin/lib/ctype.asm	/^isalnum:$/;"	l
isalnum_exit	bin/lib/ctype.asm	/^isalnum_exit:$/;"	l
isalpha	bin/lib/ctype.asm	/^isalpha:$/;"	l
isalpha_false	bin/lib/ctype.asm	/^isalpha_false:$/;"	l
isalpha_true	bin/lib/ctype.asm	/^isalpha_true:$/;"	l
isdelim	cc.c	/^char isdelim(char c){$/;"	f	typeref:typename:char
isdigit	bin/lib/ctype.asm	/^isdigit:$/;"	l
isdigit_false	bin/lib/ctype.asm	/^isdigit_false:$/;"	l
ispath	bin/lib/ctype.asm	/^ispath:$/;"	l
ispath_false	bin/lib/ctype.asm	/^ispath_false:$/;"	l
ispath_true	bin/lib/ctype.asm	/^ispath_true:$/;"	l
isspace	bin/lib/ctype.asm	/^isspace:$/;"	l
isspace_exit	bin/lib/ctype.asm	/^isspace_exit:$/;"	l
itoa	bin/lib/stdio.asm	/^itoa:$/;"	l
j	bin/options.c	/^int n, i, j;$/;"	v	typeref:typename:int
j	bin/pascal.c	/^int rows, space, i, j;$/;"	v	typeref:typename:int
j	bin/primes.c	/^int n, i, j;$/;"	v	typeref:typename:int
key	def.h	/^  _TOKEN key;$/;"	m	struct:_keyword_table	typeref:typename:_TOKEN
keyword	def.h	/^  char *keyword;$/;"	m	struct:_keyword_table	typeref:typename:char *
keyword_table	def.h	/^} keyword_table[] = {$/;"	v	typeref:struct:_keyword_table[]
label_stack_if	def.h	/^int label_stack_if[64]; \/\/ for nested if labels $/;"	v	typeref:typename:int[64]
label_stack_loop	def.h	/^int label_stack_loop[64]; \/\/ for nested loop labels $/;"	v	typeref:typename:int[64]
label_tos_if	def.h	/^int label_tos_if = 0; \/\/ label stack pointer$/;"	v	typeref:typename:int
label_tos_loop	def.h	/^int label_tos_loop = 0; \/\/ label stack pointer$/;"	v	typeref:typename:int
ld	def.h	/^  long double ld;$/;"	m	union:__anon0f49ad0a040a	typeref:typename:long double
li	def.h	/^  long int li;$/;"	m	union:__anon0f49ad0a040a	typeref:typename:long int
lli	def.h	/^  long long int lli;$/;"	m	union:__anon0f49ad0a040a	typeref:typename:long long int
lmodf	def.h	/^  _MODIFIER smodf, lmodf, modf3;$/;"	m	struct:__anon0f49ad0a0708	typeref:typename:_MODIFIER
load_program	cc.c	/^void load_program(char *filename){$/;"	f	typeref:typename:void
local_var_exists	cc.c	/^int local_var_exists(char *var_name){$/;"	f	typeref:typename:int
local_var_tos	def.h	/^  int local_var_tos;$/;"	m	struct:__anon0f49ad0a0b08	typeref:typename:int
local_vars	def.h	/^  _LOCAL_VAR local_vars[MAX_LOCAL_VARS + 1];$/;"	m	struct:__anon0f49ad0a0b08	typeref:typename:_LOCAL_VAR[]
mLONG	def.h	/^  mSIGNED = 1, mUNSIGNED, mSHORT, mLONG$/;"	e	enum:__anon0f49ad0a0603
mSHORT	def.h	/^  mSIGNED = 1, mUNSIGNED, mSHORT, mLONG$/;"	e	enum:__anon0f49ad0a0603
mSIGNED	def.h	/^  mSIGNED = 1, mUNSIGNED, mSHORT, mLONG$/;"	e	enum:__anon0f49ad0a0603
mUNSIGNED	def.h	/^  mSIGNED = 1, mUNSIGNED, mSHORT, mLONG$/;"	e	enum:__anon0f49ad0a0603
main	bin/a.s	/^main:$/;"	l
main	bin/factors.c	/^int main(void) {$/;"	f	typeref:typename:int
main	bin/options.c	/^int main(void) {$/;"	f	typeref:typename:int
main	bin/pascal.c	/^int main(void) {$/;"	f	typeref:typename:int
main	bin/primes.c	/^void main(void){$/;"	f	typeref:typename:void
main	bin/test.c	/^int main(void) {$/;"	f	typeref:typename:int
main	cc.c	/^int main(int argc, char *argv[]){$/;"	f	typeref:typename:int
modf3	def.h	/^  _MODIFIER smodf, lmodf, modf3;$/;"	m	struct:__anon0f49ad0a0708	typeref:typename:_MODIFIER
mov	bin/lib/string.asm	/^	mov di, d	; beginning of string (for destinations)$/;"	d
mov	bin/lib/string.asm	/^	mov di, d$/;"	d
mov	bin/lib/token.asm	/^	mov di, tokstr$/;"	d
mul_exit	bin/lib/stdio.asm	/^mul_exit:$/;"	l
mul_loop	bin/lib/stdio.asm	/^mul_loop:$/;"	l
n	bin/options.c	/^int n, i, j;$/;"	v	typeref:typename:int
n	bin/primes.c	/^int n, i, j;$/;"	v	typeref:typename:int
newline	bin/primes.c	/^char *newline = "\\n";$/;"	v	typeref:typename:char *
nl	bin/factors.c	/^char *nl = "\\n";$/;"	v	typeref:typename:char *
nl	bin/options.c	/^char *nl = "\\n";$/;"	v	typeref:typename:char *
nl	bin/pascal.c	/^char *nl = "\\n";$/;"	v	typeref:typename:char *
nn	bin/options.c	/^int nn;$/;"	v	typeref:typename:int
num	bin/factors.c	/^int num, i;$/;"	v	typeref:typename:int
num	bin/options.c	/^int num;$/;"	v	typeref:typename:int
opt	bin/options.c	/^char *opt = "Choose option: ";$/;"	v	typeref:typename:char *
option	bin/options.c	/^int option;$/;"	v	typeref:typename:int
p	def.h	/^  void *p;$/;"	m	union:__anon0f49ad0a040a	typeref:typename:void *
parse_asm	cc.c	/^void parse_asm(void){$/;"	f	typeref:typename:void
parse_atom	cc.c	/^void parse_atom(void){$/;"	f	typeref:typename:void
parse_attrib	cc.c	/^void parse_attrib(){$/;"	f	typeref:typename:void
parse_block	cc.c	/^void parse_block(void){$/;"	f	typeref:typename:void
parse_break	cc.c	/^void parse_break(void){$/;"	f	typeref:typename:void
parse_expr	cc.c	/^void parse_expr(){$/;"	f	typeref:typename:void
parse_factors	cc.c	/^void parse_factors(void){$/;"	f	typeref:typename:void
parse_for	cc.c	/^void parse_for(void){$/;"	f	typeref:typename:void
parse_function_arguments	cc.c	/^void parse_function_arguments(int func_id){$/;"	f	typeref:typename:void
parse_functions	cc.c	/^void parse_functions(void){$/;"	f	typeref:typename:void
parse_if	cc.c	/^void parse_if(void){$/;"	f	typeref:typename:void
parse_logical	cc.c	/^void parse_logical(void){$/;"	f	typeref:typename:void
parse_relational	cc.c	/^void parse_relational(void){$/;"	f	typeref:typename:void
parse_return	cc.c	/^void parse_return(void){$/;"	f	typeref:typename:void
parse_terms	cc.c	/^void parse_terms(void){$/;"	f	typeref:typename:void
parse_while	cc.c	/^void parse_while(void){$/;"	f	typeref:typename:void
pascal	bin/options.c	/^void pascal(void){$/;"	f	typeref:typename:void
pbuf	def.h	/^char pbuf[PROG_SIZE]; \/\/ pointer to the beginning of the source code$/;"	v	typeref:typename:char[]
pop	bin/lib/string.asm	/^	pop di$/;"	d
pop	bin/lib/token.asm	/^	pop di$/;"	d
pre_scan	cc.c	/^void pre_scan(void){$/;"	f	typeref:typename:void
primes	bin/options.c	/^void primes(void){$/;"	f	typeref:typename:void
primes	bin/primes.c	/^void primes(void){$/;"	f	typeref:typename:void
print	bin/options.c	/^void print(void){$/;"	f	typeref:typename:void
print	bin/pascal.c	/^void print(void){$/;"	f	typeref:typename:void
print_number	bin/lib/stdio.asm	/^print_number:$/;"	l
print_u16d	bin/lib/stdio.asm	/^print_u16d:$/;"	l
print_u16x	bin/lib/stdio.asm	/^print_u16x:$/;"	l
print_u8d	bin/lib/stdio.asm	/^print_u8d:$/;"	l
print_u8x	bin/lib/stdio.asm	/^print_u8x:$/;"	l
print_zero_or_space	bin/lib/stdio.asm	/^print_zero_or_space:$/;"	l
printf	bin/lib/stdio.asm	/^printf:$/;"	l
printnl	bin/lib/stdio.asm	/^printnl:$/;"	l
prog	bin/lib/token.asm	/^prog:		.dw 0			; pointer to current position in buffer$/;"	l
prog	def.h	/^char *prog; \/\/ pointer to the current program position$/;"	v	typeref:typename:char *
push	bin/lib/string.asm	/^	push di$/;"	d
push	bin/lib/token.asm	/^	push di$/;"	d
putback	bin/lib/token.asm	/^putback:$/;"	l
putback	cc.c	/^void putback(void){$/;"	f	typeref:typename:void
putback_end	bin/lib/token.asm	/^putback_end:$/;"	l
putback_loop	bin/lib/token.asm	/^putback_loop:$/;"	l
putchar	bin/lib/stdio.asm	/^putchar:$/;"	l
puts	bin/lib/stdio.asm	/^puts:$/;"	l
puts_END	bin/lib/stdio.asm	/^puts_END:$/;"	l
puts_L1	bin/lib/stdio.asm	/^puts_L1:$/;"	l
putsn	bin/lib/stdio.asm	/^putsn:$/;"	l
putsn_L0	bin/lib/stdio.asm	/^putsn_L0:$/;"	l
putsn_end	bin/lib/stdio.asm	/^putsn_end:$/;"	l
return_type	def.h	/^  _BASIC_DATA return_type;$/;"	m	struct:__anon0f49ad0a0b08	typeref:typename:_BASIC_DATA
rows	bin/options.c	/^int rows, space;$/;"	v	typeref:typename:int
rows	bin/pascal.c	/^int rows, space, i, j;$/;"	v	typeref:typename:int
s	bin/factors.c	/^char *s= "Enter a positive integer: ";$/;"	v	typeref:typename:char *
s	bin/pascal.c	/^char *s = "Enter the number of rows: ";$/;"	v	typeref:typename:char *
s	bin/primes.c	/^int s;$/;"	v	typeref:typename:int
s1	bin/options.c	/^char *s1= "Enter a positive integer: ";$/;"	v	typeref:typename:char *
s1	bin/primes.c	/^char *s1 = "TRUE";$/;"	v	typeref:typename:char *
s2	bin/factors.c	/^char *s2= "Factors are: ";$/;"	v	typeref:typename:char *
s2	bin/options.c	/^char *s2= "Factors are: ";$/;"	v	typeref:typename:char *
s3	bin/options.c	/^char *s3 = "Enter the number of rows: ";$/;"	v	typeref:typename:char *
s4	bin/options.c	/^char *s4 = "    ";$/;"	v	typeref:typename:char *
s:cpo_save	Session.vim	/^let s:cpo_save=&cpo$/;"	v
s:cpo_save	session_win.vim	/^let s:cpo_save=&cpo$/;"	v
s:l	Session.vim	/^let s:l = 1 - ((0 * winheight(0) + 11) \/ 23)$/;"	v
s:l	Session.vim	/^let s:l = 10 - ((4 * winheight(0) + 11) \/ 23)$/;"	v
s:l	Session.vim	/^let s:l = 13 - ((12 * winheight(0) + 27) \/ 55)$/;"	v
s:l	Session.vim	/^let s:l = 146 - ((10 * winheight(0) + 11) \/ 23)$/;"	v
s:l	Session.vim	/^let s:l = 17 - ((16 * winheight(0) + 27) \/ 55)$/;"	v
s:l	Session.vim	/^let s:l = 19 - ((5 * winheight(0) + 11) \/ 23)$/;"	v
s:l	Session.vim	/^let s:l = 283 - ((21 * winheight(0) + 27) \/ 55)$/;"	v
s:l	Session.vim	/^let s:l = 336 - ((45 * winheight(0) + 28) \/ 56)$/;"	v
s:l	Session.vim	/^let s:l = 34 - ((14 * winheight(0) + 11) \/ 23)$/;"	v
s:l	session_win.vim	/^let s:l = 1 - ((0 * winheight(0) + 24) \/ 49)$/;"	v
s:l	session_win.vim	/^let s:l = 10 - ((9 * winheight(0) + 24) \/ 49)$/;"	v
s:save_splitbelow	session_win.vim	/^let s:save_splitbelow = &splitbelow$/;"	v
s:save_splitright	session_win.vim	/^let s:save_splitright = &splitright$/;"	v
s:save_winminheight	session_win.vim	/^let s:save_winminheight = &winminheight$/;"	v
s:save_winminwidth	session_win.vim	/^let s:save_winminwidth = &winminwidth$/;"	v
s:so_save	Session.vim	/^let s:so_save = &so | let s:siso_save = &siso | set so=0 siso=0$/;"	v
s:so_save	session_win.vim	/^let s:so_save = &g:so | let s:siso_save = &g:siso | setg so=0 siso=0 | setl so=-1 siso=-1$/;"	v
s:sx	Session.vim	/^let s:sx = expand("<sfile>:p:r")."x.vim"$/;"	v
s:sx	session_win.vim	/^let s:sx = expand("<sfile>:p:r")."x.vim"$/;"	v
s:wipebuf	Session.vim	/^  let s:wipebuf = bufnr('%')$/;"	v
s:wipebuf	session_win.vim	/^  let s:wipebuf = bufnr('%')$/;"	v
s_hex_digits	bin/lib/stdio.asm	/^s_hex_digits:	.db "0123456789ABCDEF"	$/;"	l
scan_u16d	bin/lib/stdio.asm	/^scan_u16d:$/;"	l
scan_u16x	bin/lib/stdio.asm	/^scan_u16x:$/;"	l
scan_u8x	bin/lib/stdio.asm	/^scan_u8x:$/;"	l
scanf	bin/lib/stdio.asm	/^scanf:$/;"	l
si	def.h	/^  short int si;$/;"	m	union:__anon0f49ad0a040a	typeref:typename:short int
skip10	bin/lib/stdio.asm	/^skip10:$/;"	l
skip100	bin/lib/stdio.asm	/^skip100:$/;"	l
smodf	def.h	/^  _MODIFIER smodf, lmodf, modf3;$/;"	m	struct:__anon0f49ad0a0708	typeref:typename:_MODIFIER
space	bin/options.c	/^int rows, space;$/;"	v	typeref:typename:int
space	bin/pascal.c	/^int rows, space, i, j;$/;"	v	typeref:typename:int
ss	bin/pascal.c	/^char *ss = "    ";$/;"	v	typeref:typename:char *
str	def.h	/^  char *str;$/;"	m	struct:__anon0f49ad0a0808	typeref:typename:char *
strcat	bin/lib/string.asm	/^strcat:$/;"	l
strcat_L1	bin/lib/string.asm	/^strcat_L1:$/;"	l
strcat_end	bin/lib/string.asm	/^strcat_end:$/;"	l
strcat_goto_end_L1	bin/lib/string.asm	/^strcat_goto_end_L1:$/;"	l
strcat_start	bin/lib/string.asm	/^strcat_start:$/;"	l
strchr	bin/lib/string.asm	/^strchr:$/;"	l
strchr_L0	bin/lib/string.asm	/^strchr_L0:$/;"	l
strchr_end	bin/lib/string.asm	/^strchr_end:$/;"	l
strcmp	bin/lib/string.asm	/^strcmp:$/;"	l
strcmp_loop	bin/lib/string.asm	/^strcmp_loop:$/;"	l
strcmp_ret	bin/lib/string.asm	/^strcmp_ret:$/;"	l
strcpy	bin/lib/string.asm	/^strcpy:$/;"	l
strcpy_L1	bin/lib/string.asm	/^strcpy_L1:$/;"	l
strcpy_end	bin/lib/string.asm	/^strcpy_end:$/;"	l
string_constant	def.h	/^char string_constant[CONST_LEN + 2]; \/\/ holds string and char constants without quotes and wit/;"	v	typeref:typename:char[]
strlen	bin/lib/string.asm	/^strlen:$/;"	l
strlen_L1	bin/lib/string.asm	/^strlen_L1:$/;"	l
strlen_ret	bin/lib/string.asm	/^strlen_ret:$/;"	l
strrev	bin/lib/string.asm	/^strrev:$/;"	l
strrev_L0	bin/lib/string.asm	/^strrev_L0:$/;"	l
strrev_end	bin/lib/string.asm	/^strrev_end:$/;"	l
strstr	bin/lib/string.asm	/^strstr:$/;"	l
strstr_loop	bin/lib/string.asm	/^strstr_loop:$/;"	l
strstr_ret	bin/lib/string.asm	/^strstr_ret:$/;"	l
strtoint	bin/lib/stdio.asm	/^strtoint:$/;"	l
strtoint_L0	bin/lib/stdio.asm	/^strtoint_L0:$/;"	l
strtoint_end	bin/lib/stdio.asm	/^strtoint_end:$/;"	l
strtointx	bin/lib/stdio.asm	/^strtointx:$/;"	l
test	bin/options.c	/^void test(int i){$/;"	f	typeref:typename:void
to_lower	bin/lib/ctype.asm	/^to_lower:$/;"	l
to_lower_ret	bin/lib/ctype.asm	/^to_lower_ret:$/;"	l
to_upper	bin/lib/ctype.asm	/^to_upper:$/;"	l
to_upper_ret	bin/lib/ctype.asm	/^to_upper_ret:$/;"	l
tok	bin/lib/token.asm	/^tok:		.db 0			; current token symbol$/;"	l
tok	def.h	/^_TOKEN tok;$/;"	v	typeref:typename:_TOKEN
token	def.h	/^char token[CONST_LEN + 2]; \/\/ string token representation$/;"	v	typeref:typename:char[]
token_type	def.h	/^_TOKEN_TYPE token_type;$/;"	v	typeref:typename:_TOKEN_TYPE
tokstr	bin/lib/token.asm	/^tokstr:		.fill 256, 0	; token as a string$/;"	l
toktyp	bin/lib/token.asm	/^toktyp: 	.db 0			; token type symbol$/;"	l
trigger_err	cc.c	/^void trigger_err(_ERROR e){$/;"	f	typeref:typename:void
type	def.h	/^  _BASIC_DATA type;$/;"	m	struct:__anon0f49ad0a0708	typeref:typename:_BASIC_DATA
value	def.h	/^  _VALUE value;$/;"	m	struct:__anon0f49ad0a0708	typeref:typename:_VALUE
var_name	def.h	/^  char var_name[ID_LEN];$/;"	m	struct:__anon0f49ad0a0908	typeref:typename:char[]
var_name	def.h	/^  char var_name[ID_LEN];$/;"	m	struct:__anon0f49ad0a0a08	typeref:typename:char[]
x	bin/options.c	/^int x = 20;$/;"	v	typeref:typename:int
x	bin/primes.c	/^int x = 20;$/;"	v	typeref:typename:int
y	bin/options.c	/^int y = 5;$/;"	v	typeref:typename:int
y	bin/primes.c	/^int y = 5;$/;"	v	typeref:typename:int
z	bin/options.c	/^int z = 10;$/;"	v	typeref:typename:int
z	bin/primes.c	/^int z = 10;$/;"	v	typeref:typename:int
